<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="49ef276ba874be88caa55a5b3e4a37db519f9394" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and ISO8859 characters in column and table names.</source>
          <target state="translated">열 및 테이블 이름에서 UTF-8 및 ISO8859 문자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="78dc81c2a8faafa4c84493782b19c441e17956a6" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and UTF-16</source>
          <target state="translated">UTF-8 및 UTF-16 지원</target>
        </trans-unit>
        <trans-unit id="1e1164bc2160d30de5ee08ec06fc2a323f2028fc" translate="yes" xml:space="preserve">
          <source>Support for both UTF-8 and UTF-16 text.</source>
          <target state="translated">UTF-8 및 UTF-16 텍스트를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bf37e2ec021b62a6c46ffa2eb125d86eb07ffbc5" translate="yes" xml:space="preserve">
          <source>Support for correlated subqueries added.</source>
          <target state="translated">상관 하위 쿼리에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec9173b8e288c70be66cdbfa81d0ba7ad6705c9c" translate="yes" xml:space="preserve">
          <source>Support for full text search using the FTS1 module (beta)</source>
          <target state="translated">FTS1 모듈 (베타)을 사용한 전체 텍스트 검색 지원</target>
        </trans-unit>
        <trans-unit id="09344ff56160150e5ec18eb5a71ba2f29a6312fc" translate="yes" xml:space="preserve">
          <source>Support for internationalization including UTF-8, UTF-16, and user defined collating sequences.</source>
          <target state="translated">UTF-8, UTF-16 및 사용자 정의 배열 순서를 포함한 국제화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="091e86f3d19a27b9089ddce8c418dcc49fd9c304" translate="yes" xml:space="preserve">
          <source>Support for non-ASCII characters in win95 filenames</source>
          <target state="translated">win95 파일 이름에서 비 ASCII 문자 지원</target>
        </trans-unit>
        <trans-unit id="cfddf0106ec96c94ef54d4e7b75188870573ef30" translate="yes" xml:space="preserve">
          <source>Support for the EXISTS clause added.</source>
          <target state="translated">EXISTS 절에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="21d1badc676c125ad5e671e3ae8383a4753e9f6c" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">컴파일시 &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; 옵션을 지정하여 sqlite3_compileoption_used () 및 sqlite3_compileoption_get () 진단 ​​기능에 대한 지원을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceaebbe4250e5e44fc85c0a7be72215c2fc6b3df" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">컴파일시 &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; 옵션을 지정하여 sqlite3_compileoption_used () 및 sqlite3_compileoption_get () 진단 ​​기능에 대한 지원을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e227243100baec383101a5e3e5550db71fb48de1" translate="yes" xml:space="preserve">
          <source>Support operators IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE.</source>
          <target state="translated">지원 연산자는 참, 거짓, 거짓이 아니며 거짓이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8b76c3512f29a884a102a942cd3b81fe8d384ace" translate="yes" xml:space="preserve">
          <source>Supported unary prefix operators are these:</source>
          <target state="translated">지원되는 단항 접두사 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14453b6f0216ab7b03129623da62580288e5db4c" translate="yes" xml:space="preserve">
          <source>Supports terabyte-sized databases and gigabyte-sized strings and blobs. (See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;.)</source>
          <target state="translated">테라 바이트 크기의 데이터베이스와 기가 바이트 크기의 문자열 및 Blob을 지원합니다. ( &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f2a1709933364d69e93326e81a6775d317d15202" translate="yes" xml:space="preserve">
          <source>Suppose N=4. Then for the TPC-H Q8 graph, the first step finds the four shortest paths to visit any single node in the graph:</source>
          <target state="translated">N = 4라고 가정하자. 그런 다음 TPC-H Q8 그래프의 경우 첫 번째 단계는 그래프에서 단일 노드를 방문하는 가장 짧은 4 개의 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="61fbb5bff735b0969304e1938310f741780fb8bb" translate="yes" xml:space="preserve">
          <source>Suppose SQLite is used as the &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; for a particular design application. Two users, Alice and Bob, each start with a baseline design that is about a gigabyte in size. They work all day, in parallel, each making their own customizations and tweaks to the design. At the end of the day, they would like to merge their changes together into a single unified design.</source>
          <target state="translated">SQLite가 특정 디자인 응용 프로그램 의 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되었다고 가정 합니다. 두 명의 사용자 인 Alice와 Bob은 각각 기가 바이트 크기의 기본 디자인으로 시작합니다. 그들은 하루 종일 동시에 작동하며 각각 자체적으로 사용자 정의하고 디자인을 조정합니다. 하루가 끝나면 변경 사항을 하나의 통합 된 디자인으로 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ef94f961eb3bb04314c719aa5da9edd146e885d3" translate="yes" xml:space="preserve">
          <source>Suppose an application wants to display a list of contacts in alphabetical order by lastname, firstname, in a scrolling window that can only show 7 contacts at a time. Initialize the scrolling window to the first 7 entries is easy:</source>
          <target state="translated">애플리케이션이 한 번에 7 개의 연락처 만 표시 할 수있는 스크롤 창에서 성을 기준으로 알파벳순으로 연락처 목록을 표시하려고한다고 가정하십시오. 스크롤 창을 처음 7 개 항목으로 초기화하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="56904d3ea47369b0068186e8a39203c8a5f870c3" translate="yes" xml:space="preserve">
          <source>Suppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.</source>
          <target state="translated">BIG 테이블의 각 항목이 고유 식별자 인 '$ .id'필드와 깊이 중첩 된 오브젝트 일 수있는 '$ .partlist'필드가있는 JSON 오브젝트라고 가정하십시오. uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808'에 대한 하나 이상의 참조가 포함 된 모든 항목의 ID를 '$ .partlist'의 어디에서나 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="01636cb9299568d887d10674105e44b34b08d5bf" translate="yes" xml:space="preserve">
          <source>Suppose that after a while (about a month, usually) a new version of SQLite is released: 3.6.16. You will want to incorporate this new public version of SQLite into your repository in the public branch (the trunk). To do this, first change your repository over to the trunk:</source>
          <target state="translated">잠시 후 (일반적으로 약 한 달) 새 버전의 SQLite가 3.6.16으로 릴리스되었다고 가정하십시오. 이 새로운 공용 버전의 SQLite를 공용 분기 (트렁크)의 저장소에 통합하려고합니다. 이렇게하려면 먼저 저장소를 트렁크로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="cede4c6f59f784278daddf56ee62d38bbe080c9a" translate="yes" xml:space="preserve">
          <source>Suppose that in addition to the index on &quot;fruit&quot; there was also an index on &quot;state&quot;.</source>
          <target state="translated">&quot;fruit&quot;에 대한 인덱스 외에 &quot;state&quot;에 대한 인덱스도 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="66f9ffa5f1e3c7efa56791a73580d03426c293ab" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; 파일 형식, 특히 &quot;ODP&quot;OpenDocument 프레젠테이션 형식이 SQLite를 중심으로 구축되었다고 가정합니다 . 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a6796b2c9a16b027d38641aa802a501818a470f" translate="yes" xml:space="preserve">
          <source>Suppose the SQLite source tree is stored in a directory named &quot;sqlite&quot;. Plan to construct the amalgamation in a parallel directory named (for example) &quot;bld&quot;. First construct an appropriate Makefile by either running the configure script at the top of the SQLite source tree, or by making a copy of one of the template Makefiles at the top of the source tree. Then hand edit this Makefile to include the desired compile-time options. Finally run:</source>
          <target state="translated">SQLite 소스 트리가 &quot;sqlite&quot;라는 디렉토리에 저장되었다고 가정하십시오. 이름이 &quot;bld&quot;인 병렬 디렉토리에 통합을 계획하십시오. 먼저 SQLite 소스 트리 맨 위에서 configure 스크립트를 실행하거나 소스 트리 맨 위에 Makefile 템플리트 중 하나의 사본을 작성하여 적절한 Makefile을 구성하십시오. 그런 다음 원하는 Make-time 옵션을 포함하도록이 Makefile을 수동으로 편집하십시오. 마지막으로 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0b1da1daf13d7c26fba356306203b171fd80d646" translate="yes" xml:space="preserve">
          <source>Suppose the application normally does a query against table TAB1 when it starts up. If an attacker can gain access to the database file and modify the schema like this:</source>
          <target state="translated">응용 프로그램이 시작될 때 일반적으로 테이블 TAB1에 대해 쿼리를 수행한다고 가정합니다. 공격자가 데이터베이스 파일에 대한 액세스 권한을 얻고 다음과 같이 스키마를 수정할 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="3af5f7045e9a9cbdbcc9c95551ce4e94ea5602be" translate="yes" xml:space="preserve">
          <source>Suppose the demo_data.boundary field holds some proprietary data description of a complex two-dimensional boundary for an object and suppose that the application has used the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface to created application-defined functions &quot;contained_in&quot; and &quot;overlaps&quot; accepting two demo_data.boundary objects and return true or false. One may assume that &quot;contained_in&quot; and &quot;overlaps&quot; are relatively slow functions that we do not want to invoke too frequently. Then an efficient way to find the name of all objects located within the North Carolina 12th District, one may be to run a query like this:</source>
          <target state="translated">demo_data.boundary 필드에 객체의 복잡한 2 차원 경계에 대한 독점 데이터 설명이 있다고 가정하고 애플리케이션이 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스를 사용하여 두 개의 demo_data를 허용하는 &quot;contained_in&quot;및 &quot;overlaps&quot;애플리케이션 정의 함수를 작성했다고 가정하십시오. 경계 객체를 반환하고 true 또는 false를 반환합니다. &quot;contained_in&quot;과 &quot;overlaps&quot;는 우리가 너무 자주 호출하고 싶지 않은 비교적 느린 함수라고 가정 할 수 있습니다. 그런 다음 North Carolina 12th District에 위치한 모든 개체의 이름을 찾는 효율적인 방법은 다음과 같은 쿼리를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be9cbf4654b2bfbdcf1b2bf833bfb8cf7cccef29" translate="yes" xml:space="preserve">
          <source>Suppose the initial sequence of non-wildcard characters on the right-hand side of the LIKE or GLOB operator is</source>
          <target state="translated">LIKE 또는 GLOB 연산자의 오른쪽에 와일드 카드가 아닌 문자의 초기 순서가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="15341cf73e257c233d78d57ae1e295622b133b68" translate="yes" xml:space="preserve">
          <source>Suppose the power loss occurred during &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt; above, while the database changes were being written to disk. After power is restored, the situation might be something like what is shown to the right. We were trying to change three pages of the database file but only one page was successfully written. Another page was partially written and a third page was not written at all.</source>
          <target state="translated">데이터베이스 변경 사항이 디스크에 기록되는 동안 위의 &lt;a href=&quot;#section_3_10&quot;&gt;3.10 단계&lt;/a&gt; 에서 전원 손실이 발생했다고 가정하십시오 . 전원이 복구 된 후 상황은 오른쪽에 표시된 것과 같은 것일 수 있습니다. 데이터베이스 파일의 세 페이지를 변경하려고했으나 한 페이지 만 성공적으로 작성되었습니다. 다른 페이지는 부분적으로 작성되었고 세 번째 페이지는 전혀 작성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="502f7a3363de6f918e427baeeb23c0fbeb554eda" translate="yes" xml:space="preserve">
          <source>Suppose the table &quot;CREATE TABLE user(name,phone)&quot; stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:</source>
          <target state="translated">&quot;CREATE TABLE user (name, phone)&quot;테이블이 0 개 이상의 전화 번호를 user.phone 필드에 JSON 배열 오브젝트로 저장한다고 가정하십시오. 지역 번호가 704 인 전화 번호를 가진 모든 사용자를 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d5297ab1e192fe178acfe6ab94a19f582b117e15" translate="yes" xml:space="preserve">
          <source>Suppose the term that is being spell-corrected is X. To limit the search space, X is converted to a k2-like key using the equivalent of:</source>
          <target state="translated">철자가 수정되는 용어가 X라고 가정합니다. 검색 공간을 제한하기 위해 X는 다음과 같은 것을 사용하여 k2와 같은 키로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b244116e469acf86fbb0e19b53f1d8598b689446" translate="yes" xml:space="preserve">
          <source>Suppose there is a site hosting a database in state S0. And that modifications are made that move that database to state S1 and a changeset recorded (the &quot;local&quot; changeset). Then, a changeset based on S0 is received from another site (the &quot;remote&quot; changeset) and applied to the database. The database is then in state (S1+&quot;remote&quot;), where the exact state depends on any conflict resolution decisions (OMIT or REPLACE) made while applying &quot;remote&quot;. Rebasing a changeset is to update it to take those conflict resolution decisions into account, so that the same conflicts do not have to be resolved elsewhere in the network.</source>
          <target state="translated">상태 S0에 데이터베이스를 호스팅하는 사이트가 있다고 가정하십시오. 그리고 데이터베이스를 상태 S1로 옮기고 변경 세트 ( &quot;로컬&quot;변경 세트)를 기록하도록 수정되었습니다. 그런 다음 S0을 기반으로하는 변경 집합이 다른 사이트 ( &quot;원격&quot;변경 집합)에서 수신되어 데이터베이스에 적용됩니다. 그런 다음 데이터베이스는 상태 (S1 + &quot;원격&quot;)에 있으며, 여기서 정확한 상태는 &quot;원격&quot;을 적용하는 동안 작성된 충돌 해결 결정 (OMIT 또는 REPLACE)에 따라 다릅니다. 변경 세트를 리베이스하는 것은 이러한 충돌 해결 결정을 고려하여 네트워크의 다른 곳에서 동일한 충돌을 해결할 필요가 없도록 업데이트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ead91310400eb3c0d2b88fd20fde2e0225bdf31" translate="yes" xml:space="preserve">
          <source>Suppose we have a table X1 defined as follows:</source>
          <target state="translated">다음과 같이 정의 된 테이블 X1이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="538e32b0b37a9243b789f735088e6724ac330912" translate="yes" xml:space="preserve">
          <source>Suppose we want to find the prices of all kinds of oranges sorted in order of the state where they are grown. The query is this:</source>
          <target state="translated">모든 종류의 오렌지 가격이 자란 상태로 정렬되어 있다고 가정 해 봅시다. 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="064cebf29367ccdae2597fb8c1cb7630379e90ac" translate="yes" xml:space="preserve">
          <source>Suppose we want to know the order number, product number, and quantity for any item in which the product number and quantity match the product number and quantity of any item in order number 365:</source>
          <target state="translated">제품 번호 및 수량이 주문 번호 365의 품목 번호 및 수량과 일치하는 품목의 주문 번호, 제품 번호 및 수량을 알고 싶다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="465043a8fd6b7a4a4148ce99421e90822984188c" translate="yes" xml:space="preserve">
          <source>Suppose you want to look up the price of peaches. The query would be as follows:</source>
          <target state="translated">복숭아의 가격을 찾고 싶다고 가정 해보십시오. 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cde9a11c3caa7425e0b0c2c0bc60b2a242f9c61" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="translated">놀랍게도 ZIP 대신 SQLite를 사용하면 프리젠 테이션 파일이 더 작아집니다. 정말. 관계형 데이터베이스 파일은 ZIP 아카이브보다 크지 만 최소한 NeoOffice의 경우에는 그렇지 않습니다. 다음은 NeoOffice에서 생성 한 원본 ZIP 아카이브 형식 (self2014.odp)과 &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; 유틸리티를 사용하여 SQLite 데이터베이스로 다시 압축 한 동일한 NeoOffice 프리젠 테이션의 크기를 보여주는 실제 화면 스크랩입니다 .</target>
        </trans-unit>
        <trans-unit id="055c319b3692b1bab785599b3ba80b0068542bb5" translate="yes" xml:space="preserve">
          <source>Suspend Execution For A Short Time</source>
          <target state="translated">짧은 시간 동안 실행 일시 중단</target>
        </trans-unit>
        <trans-unit id="7bdfc376d6f876239b6de7abf665805218ef476e" translate="yes" xml:space="preserve">
          <source>Swap the program counter with the value in register P1. This has the effect of yielding to a coroutine.</source>
          <target state="translated">프로그램 카운터를 레지스터 P1의 값으로 교체하십시오. 이것은 코 루틴에 항복하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb264ae88f7fbec3546350312b9af582b1fc481" translate="yes" xml:space="preserve">
          <source>Swapping journal files between two different databases.</source>
          <target state="translated">서로 다른 두 데이터베이스간에 저널 파일 교환</target>
        </trans-unit>
        <trans-unit id="e8485294b019aa85fdb1a929771cba23d5593c45" translate="yes" xml:space="preserve">
          <source>Swarmvtab Virtual Table</source>
          <target state="translated">Swarmvtab 가상 테이블</target>
        </trans-unit>
        <trans-unit id="01d32f35e7401403e071bd64f5c3b26a4e4dc5be" translate="yes" xml:space="preserve">
          <source>Swarmvtab context</source>
          <target state="translated">Swarmvtab 컨텍스트</target>
        </trans-unit>
        <trans-unit id="875cb081d7d2e461450da0199489f1266311e3ff" translate="yes" xml:space="preserve">
          <source>Swarmvtab efficiently handles range and equality constraints on the rowid (or other INTEGER PRIMARY KEY) field only. If a query does not contain such a constraint, then swarmvtab finds the results by opening each database in turn and linearly scanning the component table. Which generates a correct result, but is often slow.</source>
          <target state="translated">Swarmvtab은 rowid (또는 다른 INTEGER PRIMARY KEY) 필드에서만 범위 및 동등 제한 조건을 효율적으로 처리합니다. 쿼리에 이러한 제약 조건이 포함되어 있지 않으면 swarmvtab은 각 데이터베이스를 차례로 열고 구성 요소 테이블을 선형으로 검색하여 결과를 찾습니다. 올바른 결과를 생성하지만 종종 느립니다.</target>
        </trans-unit>
        <trans-unit id="85aa4db2e47035bd4c2140f56e8799ea09c7ae90" translate="yes" xml:space="preserve">
          <source>Swarmvtab virtual tables must be created in the temp schema. Attempting to create a swarmvtab in the main or an attached database is an error.</source>
          <target state="translated">Swarmvtab 가상 테이블은 임시 스키마에서 작성해야합니다. 기본 또는 연결된 데이터베이스에서 swarmvtab을 작성하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0d92527f493460a8c4ce6ccbbd585c5ead2d11f" translate="yes" xml:space="preserve">
          <source>Synchronization Type Flags</source>
          <target state="translated">동기화 유형 플래그</target>
        </trans-unit>
        <trans-unit id="a7e6b31b20f1d4434bcadd521f6861e2f3378f97" translate="yes" xml:space="preserve">
          <source>Synchronous pragma</source>
          <target state="translated">동기식 프라 그마</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="c66891a446af4f02e4055198cbfa371561a78fd4" translate="yes" xml:space="preserve">
          <source>Syncing the Journal File</source>
          <target state="translated">저널 파일 동기화</target>
        </trans-unit>
        <trans-unit id="009e70db897489dd37e3be6570164d0a836b9c76" translate="yes" xml:space="preserve">
          <source>Syntactically, generated columns are designated using a &quot;GENERATED ALWAYS&quot; &lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint&lt;/a&gt;. For example:</source>
          <target state="translated">구문 적으로 생성 된 열은 &quot;GENERATED ALWAYS&quot; &lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint를&lt;/a&gt; 사용하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17aba038fa3266b07efa450a91b91b1e792d66c5" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams</source>
          <target state="translated">구문 다이어그램</target>
        </trans-unit>
        <trans-unit id="33bbfae733b0f97c3ea72475efb5dfbb61ebe1e1" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams For SQLite</source>
          <target state="translated">SQLite의 구문 다이어그램</target>
        </trans-unit>
        <trans-unit id="70a8fcc6fa01af0d580c320ddb0e42484905e68e" translate="yes" xml:space="preserve">
          <source>Syntax Restrictions On UPDATE, DELETE, and INSERT Statements Within Triggers</source>
          <target state="translated">트리거 내의 UPDATE, DELETE 및 INSERT 문에 대한 구문 제한</target>
        </trans-unit>
        <trans-unit id="34b408d97f8998a54cd64e9461c53dd4d1067b38" translate="yes" xml:space="preserve">
          <source>System Failure Related Assumptions</source>
          <target state="translated">시스템 장애 관련 가정</target>
        </trans-unit>
        <trans-unit id="ba2da263deb1258b36edfe6f11f1b761d86b8d6d" translate="yes" xml:space="preserve">
          <source>Systems designers report success using SQLite as a data store on server applications running in the datacenter, or in other words, using SQLite as the underlying storage engine for an application-specific database server.</source>
          <target state="translated">시스템 설계자는 데이터 센터에서 실행되는 서버 응용 프로그램에서 SQLite를 데이터 저장소로 사용하는 것으로, 즉 응용 프로그램 별 데이터베이스 서버의 기본 저장소 엔진으로 SQLite를 사용하여 성공을보고합니다.</target>
        </trans-unit>
        <trans-unit id="7244bff04e9f7001cbde5e129092d3ed31f1946c" translate="yes" xml:space="preserve">
          <source>Systems that run automatic backups in the background might try to make a backup copy of an SQLite database file while it is in the middle of a transaction. The backup copy then might contain some old and some new content, and thus be corrupt.</source>
          <target state="translated">백그라운드에서 자동 백업을 실행하는 시스템은 트랜잭션 도중에 SQLite 데이터베이스 파일의 백업 사본을 작성하려고 할 수 있습니다. 그런 다음 백업 사본에 오래된 내용과 일부 새로운 내용이 포함되어 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="2ba83e39946a4ce4cedf8d25757aa5972284aa54" translate="yes" xml:space="preserve">
          <source>TABLENAME</source>
          <target state="translated">TABLENAME</target>
        </trans-unit>
        <trans-unit id="4ff4bacb6a130128f6603752138b57217ef9b6fa" translate="yes" xml:space="preserve">
          <source>TBD...</source>
          <target state="translated">TBD...</target>
        </trans-unit>
        <trans-unit id="e44916ac43724313d53ca25dbe2f20ee993ff6ec" translate="yes" xml:space="preserve">
          <source>TBD: More information about the header</source>
          <target state="translated">TBD : 헤더에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="cdd060df603a64a7bee550bbc1c098580b231ab0" translate="yes" xml:space="preserve">
          <source>TCL interface authorizer method</source>
          <target state="translated">TCL 인터페이스 인증 자 방법</target>
        </trans-unit>
        <trans-unit id="aa517168bae4e2e388a6074b5a96fe2e5afc293f" translate="yes" xml:space="preserve">
          <source>TCL interface backup method</source>
          <target state="translated">TCL 인터페이스 백업 방법</target>
        </trans-unit>
        <trans-unit id="a29047291bb3d39d19d4b03699cb7f433f5736f2" translate="yes" xml:space="preserve">
          <source>TCL interface bind_fallback method</source>
          <target state="translated">TCL 인터페이스 bind_fallback 메소드</target>
        </trans-unit>
        <trans-unit id="1c5ad56544d8041c9b02f88d11a25782f14e4c9f" translate="yes" xml:space="preserve">
          <source>TCL interface busy method</source>
          <target state="translated">TCL 인터페이스 사용 방법</target>
        </trans-unit>
        <trans-unit id="6e4d989bf3b3b512cc61d500b0cb58cfc259ca59" translate="yes" xml:space="preserve">
          <source>TCL interface cache method</source>
          <target state="translated">TCL 인터페이스 캐시 방법</target>
        </trans-unit>
        <trans-unit id="f25b192d00bf0645e7eae602ec160016f797e6ac" translate="yes" xml:space="preserve">
          <source>TCL interface changes method</source>
          <target state="translated">TCL 인터페이스 변경 방법</target>
        </trans-unit>
        <trans-unit id="33f884ed1b8425d04cb3811d2ea16b66af480340" translate="yes" xml:space="preserve">
          <source>TCL interface close method</source>
          <target state="translated">TCL 인터페이스 닫기 방법</target>
        </trans-unit>
        <trans-unit id="96c5f46c7769b7e1d49b804ecba806907889a771" translate="yes" xml:space="preserve">
          <source>TCL interface collate method</source>
          <target state="translated">TCL 인터페이스 조합 방법</target>
        </trans-unit>
        <trans-unit id="2332befec61c50669cde60f3b1533591736f6a66" translate="yes" xml:space="preserve">
          <source>TCL interface collation_needed method</source>
          <target state="translated">TCL 인터페이스 collation_needed 메소드</target>
        </trans-unit>
        <trans-unit id="8cd4b4c1ed1732eb767f776cef0372d6c6cd1054" translate="yes" xml:space="preserve">
          <source>TCL interface commit_hook method</source>
          <target state="translated">TCL 인터페이스 commit_hook 메소드</target>
        </trans-unit>
        <trans-unit id="0157c2d923f1a0bec3d0245febd3f5035181a5aa" translate="yes" xml:space="preserve">
          <source>TCL interface complete method</source>
          <target state="translated">TCL 인터페이스 완료 방법</target>
        </trans-unit>
        <trans-unit id="c09e584a42654f26d29ff74df19ed9ca909905e4" translate="yes" xml:space="preserve">
          <source>TCL interface config method</source>
          <target state="translated">TCL 인터페이스 구성 방법</target>
        </trans-unit>
        <trans-unit id="b70df1b7dc237a292692ace288ac2eb93a3bcef2" translate="yes" xml:space="preserve">
          <source>TCL interface copy method</source>
          <target state="translated">TCL 인터페이스 복사 방법</target>
        </trans-unit>
        <trans-unit id="347f513a80d88ab334df317b8f83092d3ee26571" translate="yes" xml:space="preserve">
          <source>TCL interface deserialize method</source>
          <target state="translated">TCL 인터페이스 역 직렬화 방법</target>
        </trans-unit>
        <trans-unit id="0aa7225f1cfbaa7982110594b19739c6dbdfb9ac" translate="yes" xml:space="preserve">
          <source>TCL interface enable_load_extension method</source>
          <target state="translated">TCL 인터페이스 enable_load_extension 메소드</target>
        </trans-unit>
        <trans-unit id="64987beca677d7a4b95b820f3bed800e413b8cde" translate="yes" xml:space="preserve">
          <source>TCL interface errorcode method</source>
          <target state="translated">TCL 인터페이스 오류 코드 방법</target>
        </trans-unit>
        <trans-unit id="2189980d19fa911ed2ea4bb8d946cfdc55a53bc7" translate="yes" xml:space="preserve">
          <source>TCL interface eval method</source>
          <target state="translated">TCL 인터페이스 평가 방법</target>
        </trans-unit>
        <trans-unit id="f1bf6449a26eb7b025248f0b61a91066e3c39b49" translate="yes" xml:space="preserve">
          <source>TCL interface exists method</source>
          <target state="translated">TCL 인터페이스 존재 방법</target>
        </trans-unit>
        <trans-unit id="648b3c74c3afc3cad32dadd0965691c51538573c" translate="yes" xml:space="preserve">
          <source>TCL interface function method</source>
          <target state="translated">TCL 인터페이스 기능 방법</target>
        </trans-unit>
        <trans-unit id="4d842678586502cd1c46097c8ca3621079c38b98" translate="yes" xml:space="preserve">
          <source>TCL interface incrblob method</source>
          <target state="translated">TCL 인터페이스 incrblob 방법</target>
        </trans-unit>
        <trans-unit id="066821d02e0db49a10a7937ff6d8bc5c5b5055c7" translate="yes" xml:space="preserve">
          <source>TCL interface interrupt method</source>
          <target state="translated">TCL 인터페이스 인터럽트 방법</target>
        </trans-unit>
        <trans-unit id="f2e3158832088a3ccb54fc358c6461aace750451" translate="yes" xml:space="preserve">
          <source>TCL interface last_insert_rowid method</source>
          <target state="translated">TCL 인터페이스 last_insert_rowid 메소드</target>
        </trans-unit>
        <trans-unit id="50f8a5afc729daeaa27f3e057a6884d99bd7f622" translate="yes" xml:space="preserve">
          <source>TCL interface nullvalue method</source>
          <target state="translated">TCL 인터페이스 널값 방법</target>
        </trans-unit>
        <trans-unit id="e0711044ae2edb8698df1518d744c5b6309e1ba0" translate="yes" xml:space="preserve">
          <source>TCL interface onecolumn method</source>
          <target state="translated">TCL 인터페이스 onecolumn 방법</target>
        </trans-unit>
        <trans-unit id="7eb062b4a3cda7b5c21d07e42888d6f537605587" translate="yes" xml:space="preserve">
          <source>TCL interface profile method</source>
          <target state="translated">TCL 인터페이스 프로파일 방법</target>
        </trans-unit>
        <trans-unit id="4bd65df2fc14e08847cf659f886e3675b02fd603" translate="yes" xml:space="preserve">
          <source>TCL interface progress method</source>
          <target state="translated">TCL 인터페이스 진행 방법</target>
        </trans-unit>
        <trans-unit id="24560fa957755f945fd0a996100a7a50130fe691" translate="yes" xml:space="preserve">
          <source>TCL interface restore method</source>
          <target state="translated">TCL 인터페이스 복원 방법</target>
        </trans-unit>
        <trans-unit id="2c81f806023d5b1efa791fd568b8a71993cb3fc8" translate="yes" xml:space="preserve">
          <source>TCL interface rollback_hook method</source>
          <target state="translated">TCL 인터페이스 rollback_hook 메소드</target>
        </trans-unit>
        <trans-unit id="5d16200e0392f874424c9d693d564e213809df7d" translate="yes" xml:space="preserve">
          <source>TCL interface serialize method</source>
          <target state="translated">TCL 인터페이스 직렬화 방법</target>
        </trans-unit>
        <trans-unit id="8ad2308cc6d8c87dd4d39e3a54c207bf26684239" translate="yes" xml:space="preserve">
          <source>TCL interface status method</source>
          <target state="translated">TCL 인터페이스 상태 방법</target>
        </trans-unit>
        <trans-unit id="149cac088a8935337f35ceed17575a182fb384dd" translate="yes" xml:space="preserve">
          <source>TCL variable substitution</source>
          <target state="translated">TCL 변수 대체</target>
        </trans-unit>
        <trans-unit id="def1cac8277b55b62d6889e51352a77e3186587b" translate="yes" xml:space="preserve">
          <source>TEMP</source>
          <target state="translated">TEMP</target>
        </trans-unit>
        <trans-unit id="c02f25e228aca3bb6f42e48160b40dd55194b2cc" translate="yes" xml:space="preserve">
          <source>TEMP Triggers on Non-TEMP Tables</source>
          <target state="translated">비 TEMP 테이블에 대한 TEMP 트리거</target>
        </trans-unit>
        <trans-unit id="8d43ca29f9403615d1a5c8f0da40adcdae819802" translate="yes" xml:space="preserve">
          <source>TEMP databases</source>
          <target state="translated">TEMP 데이터베이스</target>
        </trans-unit>
        <trans-unit id="0c21d62a74809c85ca0475d94b6c298ee066de4e" translate="yes" xml:space="preserve">
          <source>TEMP tables and indices</source>
          <target state="translated">TEMP 테이블 및 인덱스</target>
        </trans-unit>
        <trans-unit id="df7db63622b3659c5ca6d357417169e72078f0bc" translate="yes" xml:space="preserve">
          <source>TEMP triggers on non-TEMP tables</source>
          <target state="translated">비 TEMP 테이블에 대한 TEMP 트리거</target>
        </trans-unit>
        <trans-unit id="2ec4186ff6dd054f66dc48342664cc916e7cee64" translate="yes" xml:space="preserve">
          <source>TEMPORARY</source>
          <target state="translated">TEMPORARY</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="6e2d2a0b927ccbcb0059d0c7ba90d9609187d08f" translate="yes" xml:space="preserve">
          <source>TH3</source>
          <target state="translated">TH3</target>
        </trans-unit>
        <trans-unit id="f0b11e9a80109508da2e3cbd3b7a0a8827845799" translate="yes" xml:space="preserve">
          <source>TH3 achieves 100% branch test coverage (and 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC/DC&lt;/a&gt;) over the SQLite core. (Test coverage of extensions such as FTS and RTREE is less than 100%).</source>
          <target state="translated">TH3는 SQLite 코어에서 100 % 분기 테스트 적용 범위 (및 100 % &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC / DC&lt;/a&gt; )를 달성합니다. (FTS 및 RTREE와 같은 확장의 테스트 범위는 100 % 미만입니다).</target>
        </trans-unit>
        <trans-unit id="b39ec8bc0fe82988bb1da1f05fc2de8eb41887fa" translate="yes" xml:space="preserve">
          <source>TH3 checks SQLite's response to out-of-memory errors, disk I/O errors, and power loss during transaction commit.</source>
          <target state="translated">TH3는 메모리 부족 오류, 디스크 I / O 오류 및 트랜잭션 커밋 중 전원 손실에 대한 SQLite의 응답을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="055f71da54f782f8f65239fd4fb6b9c021760b69" translate="yes" xml:space="preserve">
          <source>TH3 comes with additional TCL scripts that help automate the testing process on workstations. The &quot;th3make&quot; script automatically runs &quot;mkth3.tcl&quot; and &quot;gcc&quot; and then runs the resulting test program and checks the results. Arguments to th3make include all of the &quot;*.test&quot; test modules and &quot;*.cfg&quot; configurations that are to be included in the test. Additional options to th3make can cause the test program to be compiled using different compilers (GCC, Clang, MSVC), to use different output verbosity levels, to run the test program under valgrind, to check the output for coverage using gcov, and so forth. The th3make script also accepts &quot;*.rc&quot; filenames as arguments. These *.rc files are just collections of other arguments that are commonly used together for a single purpose. For example, the &quot;quick.rc&quot; file contains a set of eight arguments to th3make that run a fast (3-minute) full-coverage test. This allows the operator to type &quot;./th3make quick.rc&quot; as a short-cut to typing out all of the required command-line options. The following are a few of the more than 40 available *.rc files:</source>
          <target state="translated">TH3에는 워크 스테이션에서 테스트 프로세스를 자동화하는 데 도움이되는 추가 TCL 스크립트가 제공됩니다. &quot;th3make&quot;스크립트는 &quot;mkth3.tcl&quot;및 &quot;gcc&quot;를 자동으로 실행 한 다음 결과 테스트 프로그램을 실행하고 결과를 확인합니다. th3make에 대한 인수에는 테스트에 포함될 모든 &quot;* .test&quot;테스트 모듈 및 &quot;* .cfg&quot;구성이 포함됩니다. th3make에 대한 추가 옵션은 다른 컴파일러 (GCC, Clang, MSVC)를 사용하여 테스트 프로그램을 컴파일하고, 다른 출력 상세 레벨을 사용하고, valgrind에서 테스트 프로그램을 실행하고, gcov를 사용하여 커버리지에 대한 출력을 확인하는 등의 작업을 수행 할 수 있습니다. . th3make 스크립트는 또한 &quot;* .rc&quot;파일 이름을 인수로 허용합니다. 이 * .rc 파일은 단일 목적으로 공통적으로 사용되는 다른 인수의 모음입니다. 예를 들어&quot;quick.rc&quot;파일에는 빠른 (3 분) 전체 범위 테스트를 실행하는 th3make에 대한 8 개의 인수 세트가 포함되어 있습니다. 이를 통해 작업자는 필요한 모든 명령 줄 옵션을 바로 입력 할 수있는 &quot;./th3make quick.rc&quot;를 바로 입력 할 수 있습니다. 다음은 사용 가능한 40 개가 넘는 * .rc 파일 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="a2a05ad4acef3c330bf37c9357e657e9ed2af845" translate="yes" xml:space="preserve">
          <source>TH3 exercises SQLite in a variety of run-time configurations (UTF8 vs UTF16, different pages sizes, varying journal modes, etc.)</source>
          <target state="translated">TH3는 다양한 런타임 구성 (UTF8 vs UTF16, 다른 페이지 크기, 다양한 저널 모드 등)에서 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8e21da8c02749a044b3aef819f8092fd00ef786" translate="yes" xml:space="preserve">
          <source>TH3 is a test program generator. The output of TH3 is a program implemented in C-code and intended to be linked against the SQLite library under test. The generated test program is compiled and run on the target platform in order to verify correct operation of SQLite on that platform.</source>
          <target state="translated">TH3은 테스트 프로그램 생성기입니다. TH3의 출력은 C 코드로 구현 된 프로그램이며 테스트중인 SQLite 라이브러리와 연결되도록 고안되었습니다. 생성 된 테스트 프로그램은 해당 플랫폼에서 SQLite가 올바르게 작동하는지 확인하기 위해 대상 플랫폼에서 컴파일 및 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="35be3734cb33090a9156032bab76a3246a8875be" translate="yes" xml:space="preserve">
          <source>TH3 is able to run on embedded platforms that lack the support infrastructure of workstations.</source>
          <target state="translated">TH3는 워크 스테이션의 지원 인프라가없는 임베디드 플랫폼에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="924274e45e00b2de29022bcd422e62f257c51552" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="translated">TH3는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS에서&lt;/a&gt; SQLite를 테스트하려는 노력에서 비롯되었습니다 . TH3 이전에는 모든 SQLite 테스트가 &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; 스크립트 언어를 사용하여 실행 되었지만 TCL은 SymbianOS에서 (쉽게) 컴파일되지 않아 테스트가 어려웠습니다. 이 문제를 해결하기위한 첫 번째 시도는 &quot;TH1&quot;(Test Harness # 1) 스크립팅 언어였습니다. TCL 언어의 일부를보다 이식 가능한 형태로 다시 구현하여 SymbianOS에서 컴파일하고 실행할 수 있었으며 SQLite를 실행하기에 충분했습니다. 테스트. TH1은 SQLite의 표준 테스트 도구로 살아남지 못했지만 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 을 사용자 정의하는 데 사용되는 스크립팅 언어로 지속적인 서비스를 찾았습니다.버전 관리 시스템. 또한 &quot;Test Harness # 2&quot;도있었습니다. 이것은 테스트를 구동하기 위해 연산자 접두사 표기법을 사용하여 간단한 스크립팅 언어를 만들려는 시도였습니다. TH3은 세 번째 시도였습니다.</target>
        </trans-unit>
        <trans-unit id="2607d86f3f95561abb29b75d3920751195896dbd" translate="yes" xml:space="preserve">
          <source>TH3 tests SQLite in an as-deployed configuration using only published and documented interfaces. In other words, TH3 tests the compiled object code, not the source code, thus verifying that no problems were introduced by compiler bugs. &quot;Test what you fly and fly what you test.&quot;</source>
          <target state="translated">TH3는 게시 및 문서화 된 인터페이스 만 사용하여 배포 된 구성에서 SQLite를 테스트합니다. 즉, TH3는 소스 코드가 아닌 컴파일 된 객체 코드를 테스트하여 컴파일러 버그로 인한 문제가 없는지 확인합니다. &quot;무엇을 비행하고 테스트 한 것을 비행하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="c87cfbcfb0ff68ef8b8fa0759657744ff88b88af" translate="yes" xml:space="preserve">
          <source>TH3 was originally written for validation testing only, but has subsequently been used for development testing and debugging as well, and has proven very helpful in those roles. A full-coverage test takes less than five minutes on a workstation and hence serves as a fast regression test during day-to-day maintenance of the SQLite code base.</source>
          <target state="translated">TH3는 원래 검증 테스트 용으로 만 작성되었지만 이후에는 개발 테스트 및 디버깅에도 사용되었으며 이러한 역할에 매우 유용한 것으로 입증되었습니다. 전체 범위 테스트는 워크 스테이션에서 5 분 이내에 완료되므로 SQLite 코드베이스를 매일 유지 보수하는 동안 빠른 회귀 테스트 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bd7f8a83e07337beedb291a476a0abdb89ed6b4f" translate="yes" xml:space="preserve">
          <source>THEN</source>
          <target state="translated">THEN</target>
        </trans-unit>
        <trans-unit id="2c1d90a10bc6577f471f3c2c8cd6836385b31b82" translate="yes" xml:space="preserve">
          <source>TIES</source>
          <target state="translated">TIES</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="15f51444be75bc88e935c57ef2ee7477dc73a64e" translate="yes" xml:space="preserve">
          <source>TO</source>
          <target state="translated">TO</target>
        </trans-unit>
        <trans-unit id="cd4fd03fe967437fff9a9133b579cdd5421577a6" translate="yes" xml:space="preserve">
          <source>TODO:  Add something about checking the page-cache first etc.</source>
          <target state="translated">TODO : 페이지 캐시를 먼저 확인하는 것에 대해 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7fb66aab7e490b4f8a5b13b306c51e116175236a" translate="yes" xml:space="preserve">
          <source>TODO:  After sections 4 and 5 are finished, come back here and see if we can add a list of state items associated with each database connection to make things easier to understand. i.e each database connection has a file handle, a set of entries in the page cache, an expected page size etc.</source>
          <target state="translated">TODO : 섹션 4와 5가 끝나면 여기로 돌아와서 각 데이터베이스 연결과 관련된 상태 항목 목록을 추가하여 이해하기 쉽도록하십시오. 즉, 각 데이터베이스 연결에는 파일 핸들, 페이지 캐시의 항목 세트, 예상 페이지 크기 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc847eb4b63db6446f6040c4f09bb7ba16604ab" translate="yes" xml:space="preserve">
          <source>TODO:  After this document is ready, make the vocabulary consistent and then add a glossary here.</source>
          <target state="translated">TODO :이 문서가 준비되면 어휘를 일관성있게 만든 다음 여기에 용어집을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f4e2201a943d83ad82ae3edd3d70f87d9d34b73f" translate="yes" xml:space="preserve">
          <source>TODO:  Describe the parameters set to configure the page cache limits.</source>
          <target state="translated">TODO : 페이지 캐시 한계를 구성하기 위해 설정된 매개 변수를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="30bb6265750b23e36fff26fba218f095577396da" translate="yes" xml:space="preserve">
          <source>TODO:  Expand on and explain the above a bit.</source>
          <target state="translated">해야할 일 : 위의 내용을 확장하고 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="55f19663a5c44b6305b426b72aadfc9a70eb894d" translate="yes" xml:space="preserve">
          <source>TODO:  Introduce the following sub-sections.</source>
          <target state="translated">TODO : 다음 하위 섹션을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="593039ec1c1939952bb9949b2bcbe1140a495e60" translate="yes" xml:space="preserve">
          <source>TODO:  Is the shared lock held after committing a</source>
          <target state="translated">TODO : 커밋 후 공유 잠금이 유지됩니까?</target>
        </trans-unit>
        <trans-unit id="c4a151926d0634538ee91af79c910ea2132025f5" translate="yes" xml:space="preserve">
          <source>TODO:  Master journal file pointers?</source>
          <target state="translated">TODO : 마스터 저널 파일 포인터?</target>
        </trans-unit>
        <trans-unit id="2c459077da83b75d52b821b2b77b9e73be290e1e" translate="yes" xml:space="preserve">
          <source>TODO:  Requirements describing the way in which the configuration parameters are used. About LRU etc.</source>
          <target state="translated">TODO : 구성 매개 변수 사용 방법을 설명하는 요구 사항. LRU 등에 대하여</target>
        </trans-unit>
        <trans-unit id="f7e945f52e85f69c533b2d7abf6ea281ed104013" translate="yes" xml:space="preserve">
          <source>TODO:  System requirement references for the above points.</source>
          <target state="translated">TODO : 위의 포인트에 대한 시스템 요구 사항 참조.</target>
        </trans-unit>
        <trans-unit id="840394002935b6f4d9da99212e26895929cd86d7" translate="yes" xml:space="preserve">
          <source>TODO:  What happens if the exclusive lock cannot be obtained? It is not possible for the attempt to upgrade from a reserved to a pending lock to fail.</source>
          <target state="translated">TODO : 독점 잠금을 얻을 수 없으면 어떻게됩니까? 예약 된 잠금에서 보류중인 잠금으로 업그레이드하려는 시도는 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6714ad8471919f57bc47d379c3524d08542a02be" translate="yes" xml:space="preserve">
          <source>TODO:  Why a 16 byte block? Why not 4? (something to do with encrypted databases).</source>
          <target state="translated">TODO : 왜 16 바이트 블록입니까? 왜 4가 아닌가? (암호화 된 데이터베이스와 관련이 있음).</target>
        </trans-unit>
        <trans-unit id="2e614c97a332a0295344a53ea5da2a36633b1954" translate="yes" xml:space="preserve">
          <source>TPC-H Q8 is an eight-way join. As observed above, the main task of the query planner is to figure out the best nesting order of the eight loops in order to minimize the work needed to complete the join. A simplified model of this problem for the case of TPC-H Q8 is shown by the following diagram:</source>
          <target state="translated">TPC-H Q8은 8 방향 조인입니다. 위에서 살펴본 것처럼 쿼리 플래너의 주요 작업은 조인을 완료하는 데 필요한 작업을 최소화하기 위해 8 개의 루프 중 최상의 중첩 순서를 파악하는 것입니다. TPC-H Q8의 경우이 문제의 단순화 된 모델이 다음 다이어그램으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bac722ed74faff65da62171d3c4183479a271d1f" translate="yes" xml:space="preserve">
          <source>TRANSACTION</source>
          <target state="translated">TRANSACTION</target>
        </trans-unit>
        <trans-unit id="c162c076dc07a546449be9e07aa7a5c312ecbfe1" translate="yes" xml:space="preserve">
          <source>TRIGGER</source>
          <target state="translated">TRIGGER</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="dc45fdb7de43a003177f8df9ee10d01f58f57a58" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell (header 0x05):</source>
          <target state="translated">표 B- 트리 내부 셀 (헤더 0x05) :</target>
        </trans-unit>
        <trans-unit id="984abe18431413aca60298750d5de10b6d8716c4" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell:</source>
          <target state="translated">표 B- 트리 내부 셀 :</target>
        </trans-unit>
        <trans-unit id="94d19a21f457eb5da8f03166c4dbc3a6ef641531" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell (header 0x0d):</source>
          <target state="translated">표 B- 트리 잎 세포 (헤더 0x0d) :</target>
        </trans-unit>
        <trans-unit id="31beedcdbc76a09dd63a101eacf4e15dc87e80c5" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell:</source>
          <target state="translated">표 B- 트리 잎 세포 :</target>
        </trans-unit>
        <trans-unit id="cdad59a82a2e26e2fc2225d0629f7733aef385c4" translate="yes" xml:space="preserve">
          <source>Table Column Names</source>
          <target state="translated">테이블 열 이름</target>
        </trans-unit>
        <trans-unit id="1225362d8c3c05de317acf9684ffe2e1a7649c08" translate="yes" xml:space="preserve">
          <source>Table Interior (0x05)</source>
          <target state="translated">테이블 인테리어 (0x05)</target>
        </trans-unit>
        <trans-unit id="de156b09866349ad52b0a535e8144a86d129a154" translate="yes" xml:space="preserve">
          <source>Table Leaf (0x0d)</source>
          <target state="translated">테이블 리프 (0x0d)</target>
        </trans-unit>
        <trans-unit id="c27c7c360e130231f97ba874c98e3448dd648d35" translate="yes" xml:space="preserve">
          <source>Table Name</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="6a975d3ec2f404cfb761b1314fc6745ca72f942e" translate="yes" xml:space="preserve">
          <source>Table b-tree</source>
          <target state="translated">테이블 b- 트리</target>
        </trans-unit>
        <trans-unit id="92db13efcb630c92ecf1220fd763e9d0e237c97e" translate="yes" xml:space="preserve">
          <source>Table name</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="cf3467c6281e0ea2be2b55952d6893e3fbba049d" translate="yes" xml:space="preserve">
          <source>Table or index entries that are out of sequence</source>
          <target state="translated">순서를 벗어난 테이블 또는 인덱스 항목</target>
        </trans-unit>
        <trans-unit id="70aee3388a925e7cbb0852fe8dcdd4c402a95fd1" translate="yes" xml:space="preserve">
          <source>Table zTable does not exist within database zDb,</source>
          <target state="translated">테이블 zTable이 데이터베이스 zDb 내에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8886ec4df0da407409b6e2c6457e09d78592c0c0" translate="yes" xml:space="preserve">
          <source>Table zTable is a WITHOUT ROWID table,</source>
          <target state="translated">테이블 zTable은 WITHOUT ROWID 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="053f4c073c904977c9ac1e40ab060f8397a0907f" translate="yes" xml:space="preserve">
          <source>Table-name must already exists as a table. File-name must exist, and each row must contain the same number of columns as defined in the table. If a line in the file contains more or less than the number of columns defined, the copy method rollbacks any inserts, and returns an error.</source>
          <target state="translated">Table-name은 이미 테이블로 존재해야합니다. 파일 이름이 존재해야하며 각 행에는 테이블에 정의 된 것과 동일한 수의 열이 포함되어야합니다. 파일의 행에 정의 된 열 수보다 많거나 적은 행이 있으면 copy 메소드는 모든 삽입을 롤백하고 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aea731c8e5cbf2292cf08d50a7760fa0d709eb35" translate="yes" xml:space="preserve">
          <source>Table-valued Functions In The FROM Clause</source>
          <target state="translated">FROM 절의 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="fc3ba8bea68a8b6f73ff90024cfd6082eaf4a791" translate="yes" xml:space="preserve">
          <source>Table-valued functions</source>
          <target state="translated">테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="b503117e6dd30a0beff0cc1ab7fb7d005000dd03" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for PRAGMAs that return results and that have no side-effects.</source>
          <target state="translated">테이블 반환 함수는 결과를 반환하고 부작용이없는 PRAGMA에 대해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="f155ed85208e2d25c37ff0660af9e88e0ce41331" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control.</source>
          <target state="translated">테이블 반환 함수는 내장 PRAGMA에만 존재하며 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 컨트롤을 사용하여 정의 된 PRAGMA에는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="81ea5c3f4a86eb9511e7fd13ab5c2a7a105f6e9f" translate="yes" xml:space="preserve">
          <source>TableLock</source>
          <target state="translated">TableLock</target>
        </trans-unit>
        <trans-unit id="c52e87aa9f54904a290a1ea1125feb8f0b12b884" translate="yes" xml:space="preserve">
          <source>Tables are removed using the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 사용하여 테이블을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="5bee9f4ba2588a4abe8a5e77c961e698fb909d93" translate="yes" xml:space="preserve">
          <source>Tables created using CREATE TABLE AS are initially populated with the rows of data returned by the SELECT statement. Rows are assigned contiguously ascending &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; values, starting with 1, in the &lt;a href=&quot;lang_select#orderby&quot;&gt;order&lt;/a&gt; that they are returned by the SELECT statement.</source>
          <target state="translated">CREATE TABLE AS를 사용하여 작성된 테이블은 처음에 SELECT 문이 리턴 한 데이터 행으로 채워집니다. 행은 SELECT 문에 의해 반환되는 &lt;a href=&quot;lang_select#orderby&quot;&gt;순서대로&lt;/a&gt; 1부터 시작하여 연속적으로 상승하는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 값 으로 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b08405f06556bfc4a2cd40880fee5d5df353fe5" translate="yes" xml:space="preserve">
          <source>Tables created using the &quot;CREATE TEMP TABLE&quot; syntax are only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in which the &quot;CREATE TEMP TABLE&quot; statement is originally evaluated. These TEMP tables, together with any associated indices, triggers, and views, are collectively stored in a separate temporary database file that is created as soon as the first &quot;CREATE TEMP TABLE&quot; statement is seen. This separate temporary database file also has an associated rollback journal. The temporary database file used to store TEMP tables is deleted automatically when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">&quot;CREATE TEMP TABLE&quot;구문을 사용하여 작성된 테이블 은 &quot;CREATE TEMP TABLE&quot;문이 원래 평가 된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서만 볼 수 있습니다 . 이러한 TEMP 테이블은 연관된 인덱스, 트리거 및 뷰와 함께 첫 번째 &quot;CREATE TEMP TABLE&quot;문이 표시되는 즉시 작성되는 별도의 임시 데이터베이스 파일에 집합 적으로 저장됩니다. 이 별도의 임시 데이터베이스 파일에도 관련 롤백 저널이 있습니다. &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 닫으면 TEMP 테이블을 저장하는 데 사용 된 임시 데이터베이스 파일이 자동으로 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="398c675fc2fa417398cf9f153388d4a182136954" translate="yes" xml:space="preserve">
          <source>Tables in an attached database can be referred to using the syntax</source>
          <target state="translated">첨부 된 데이터베이스의 테이블은 구문을 사용하여 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230baa2e574ece0e6ffe7c574dcbbb9cd18fff76" translate="yes" xml:space="preserve">
          <source>Tables with names of the form &quot;sqlite_statN&quot; where N is an integer. Such tables store database statistics gathered by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used by the query planner to help determine the best algorithm to use for each query.</source>
          <target state="translated">&quot;sqlite_statN&quot;형식의 이름을 가진 테이블. 여기서 N은 정수입니다. 이러한 테이블은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 수집 하고 쿼리 플래너가 사용하는 데이터베이스 통계를 저장 하여 각 쿼리에 사용할 최상의 알고리즘을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6dbeddaf590f294decd7c12cd9b3ac14168d3997" translate="yes" xml:space="preserve">
          <source>Take advantage of the atomic-write capabilities in the &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS filesystem&lt;/a&gt; when available, for greatly reduced transaction overhead. This currently requires the &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; compile-time option.</source>
          <target state="translated">사용 가능한 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS 파일 시스템&lt;/a&gt; 의 원자 쓰기 기능을 활용하여 트랜잭션 오버 헤드를 크게 줄입니다. 현재 &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; 컴파일 타임 옵션 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="acf997da6bf4365bf440bc3ad9c07d7d7925e743" translate="yes" xml:space="preserve">
          <source>Take into account the fact WHERE clause terms that cannot be used with indices still probably reduce the number of output rows.</source>
          <target state="translated">인덱스와 함께 사용할 수없는 WHERE 절 용어를 고려하면 여전히 출력 행 수를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2975a6466c6b11f1519a6c8652f37b3cef0c265" translate="yes" xml:space="preserve">
          <source>Take the bit-wise AND of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 비트 단위 AND를 가져 와서 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="23882df60c1b18a8b147b1926280887dfe7acb8a" translate="yes" xml:space="preserve">
          <source>Take the bit-wise OR of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 비트 단위 OR을 가져 와서 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="6a0b05dea29609663a6574c364045bd831c5b261" translate="yes" xml:space="preserve">
          <source>Take the logical AND of the values in registers P1 and P2 and write the result into register P3.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 논리 AND를 가져 와서 결과를 레지스터 P3에 씁니다.</target>
        </trans-unit>
        <trans-unit id="9fe2090d6b7e599d38b33eca83b4b2c09d8a131d" translate="yes" xml:space="preserve">
          <source>Take the logical OR of the values in register P1 and P2 and store the answer in register P3.</source>
          <target state="translated">레지스터 P1 및 P2의 값에 대한 논리 OR을 취하여 레지스터 P3에 답을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="86743ec77172a00f99a2bc089314b61779948598" translate="yes" xml:space="preserve">
          <source>Taking into consideration all of the above, the SQLite developers recommend compiling SQLite using GCC-7 with the -Os optimization setting.</source>
          <target state="translated">위의 모든 사항을 고려하여 SQLite 개발자는 -Os 최적화 설정으로 GCC-7을 사용하여 SQLite를 컴파일하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76c9ad6f3798c330d93462b6d6a9dc1c1bbb0620" translate="yes" xml:space="preserve">
          <source>Tarball</source>
          <target state="translated">Tarball</target>
        </trans-unit>
        <trans-unit id="81919e9867e82f4145f1c83ee343766917076a71" translate="yes" xml:space="preserve">
          <source>Tcl Interface</source>
          <target state="translated">Tcl 인터페이스</target>
        </trans-unit>
        <trans-unit id="5962096d8eee555590e081b0968ff7c28d5fa0d8" translate="yes" xml:space="preserve">
          <source>Tcl command. Here is an example of opening and then immediately closing a database:</source>
          <target state="translated">Tcl 명령. 다음은 데이터베이스를 연 다음 즉시 닫는 예입니다.</target>
        </trans-unit>
        <trans-unit id="30d70929c5f61502f6c778af83fbc14057a6c36d" translate="yes" xml:space="preserve">
          <source>Tcl interface allows BLOB values to be transferred to user-defined functions</source>
          <target state="translated">Tcl 인터페이스를 통해 BLOB 값을 사용자 정의 함수로 전송할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82fe9aa4119c1f18902f153a0d50a82f529e5cfb" translate="yes" xml:space="preserve">
          <source>Tcl variable names can appear in the SQL statement of the second argument in any position where it is legal to put a string or number literal. The value of the variable is substituted for the variable name. If the variable does not exist a NULL values is used. For example:</source>
          <target state="translated">Tcl 변수 이름은 문자열 또는 숫자 리터럴을 넣는 것이 합법적 인 위치에서 두 번째 인수의 SQL 문에 나타날 수 있습니다. 변수의 값은 변수 이름으로 대체됩니다. 변수가 존재하지 않으면 NULL 값이 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2087e1ec9a4eee3edea091cbf4ce24dad9709230" translate="yes" xml:space="preserve">
          <source>Technical and Design Documentation</source>
          <target state="translated">기술 및 디자인 문서</target>
        </trans-unit>
        <trans-unit id="b6d6d722a0223fd3e9343b1f4796db6a665b091d" translate="yes" xml:space="preserve">
          <source>Temporary Databases</source>
          <target state="translated">임시 데이터베이스</target>
        </trans-unit>
        <trans-unit id="6035a1db7f899a29bfadee59c52d9c07fdd98c4f" translate="yes" xml:space="preserve">
          <source>Temporary Files Used By SQLite</source>
          <target state="translated">SQLite가 사용하는 임시 파일</target>
        </trans-unit>
        <trans-unit id="9fb2a1ec0fce944f3e17c8ab4b4f05b81d7ac8a9" translate="yes" xml:space="preserve">
          <source>Temporary directory search algorithm</source>
          <target state="translated">임시 디렉토리 검색 알고리즘</target>
        </trans-unit>
        <trans-unit id="72f84f0ca9f1ad9f151e46cd589374308dcbfc81" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored in memory regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 설정에 관계없이 항상 메모리에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="92a5156680aa1ea2c11db1f65a26abbd9db39a63" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored on disk regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 설정에 관계없이 항상 디스크에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7777ca8353568841ffb0454d79b2cf5d09f1f51b" translate="yes" xml:space="preserve">
          <source>Temporary files are now automatically deleted by the operating system when closed. There are no more dangling temporary files on a program crash. (If the OS crashes, fsck will delete the file after reboot under Unix. I do not know what happens under Windows.)</source>
          <target state="translated">임시 파일은 이제 닫힐 때 운영 체제에 의해 자동으로 삭제됩니다. 프로그램 충돌시 더 이상 매달려있는 임시 파일이 없습니다. (OS가 충돌하면 fsck가 Unix에서 재부팅 한 후 파일을 삭제합니다. Windows에서 어떤 일이 발생하는지 모르겠습니다.)</target>
        </trans-unit>
        <trans-unit id="96da9e1a1910e6d40a0e879229d60b3a31a1bf7a" translate="yes" xml:space="preserve">
          <source>Temporary files are stored in memory by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 기본적으로 메모리에 저장되지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11e15117ca75e55537b6f5f3dded721aee297def" translate="yes" xml:space="preserve">
          <source>Temporary files are stored on disk by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 기본적으로 디스크에 저장되지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7500f7d38f84089cbb32d6695814260f35c022d2" translate="yes" xml:space="preserve">
          <source>Temporary journal files are created as part of transaction control, but those extra files are not part of the steady-state database.</source>
          <target state="translated">임시 저널 파일은 트랜잭션 제어의 일부로 작성되지만 이러한 추가 파일은 정상 상태 데이터베이스의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="455a1e08ff236bc4fc37f10c45a4f1a9d962e921" translate="yes" xml:space="preserve">
          <source>Temporary tables</source>
          <target state="translated">임시 테이블</target>
        </trans-unit>
        <trans-unit id="4dff3aa4061b74df07e184cd766c027d8d0851b5" translate="yes" xml:space="preserve">
          <source>Terminate the sqlite3 program by typing your system End-Of-File character (usually a Control-D). Use the interrupt character (usually a Control-C) to stop a long-running SQL statement.</source>
          <target state="translated">시스템 파일 끝 문자 (일반적으로 Control-D)를 입력하여 sqlite3 프로그램을 종료하십시오. 인터럽트 문자 (일반적으로 Control-C)를 사용하여 오래 실행되는 SQL 문을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="f859f91a5306999f44ef0e2194daef49cbdeb611" translate="yes" xml:space="preserve">
          <source>Terminating a read-only transaction.</source>
          <target state="translated">읽기 전용 트랜잭션 종료</target>
        </trans-unit>
        <trans-unit id="46428866c7ab286d2c6ac557b2373b6b72377ee3" translate="yes" xml:space="preserve">
          <source>Terms of the ORDER BY clause that is part of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement may be assigned a collating sequence using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, in which case the specified collating function is used for sorting. Otherwise, if the expression sorted by an ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression is not a column and has no COLLATE clause, then the BINARY collating sequence is used.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 일부인 ORDER BY 절의 용어 에는 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하여 조합 순서가 지정 될 수 있으며 ,이 경우 지정된 조합 함수가 정렬에 사용됩니다. 그렇지 않으면 ORDER BY 절에 의해 정렬 된 표현식이 열인 경우 정렬 순서를 결정하기 위해 열의 조합 순서가 사용됩니다. 표현식이 열이 아니고 COLLATE 절이없는 경우 BINARY 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb252ee8cea482226d27c4a24f04af58befef27" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indices by prepending a unary *+* operator to the column name. The unary *+* is a no-op and will not generate any byte code in the prepared statement. But the unary *+* operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="translated">단항 * + * 연산자를 열 이름 앞에 추가하여 WHERE 절의 용어를 인덱스와 함께 사용하기 위해 수동으로 실격 할 수 있습니다. 단항 * + *는 작동하지 않으며 준비된 명령문에서 바이트 코드를 생성하지 않습니다. 그러나 단항 * + * 연산자는 용어가 색인을 제한하지 못하게합니다. 따라서 위의 예에서 쿼리가 다음과 같이 다시 작성된 경우 :</target>
        </trans-unit>
        <trans-unit id="db8a7aee242ffd686d07e20367e523410ddf047e" translate="yes" xml:space="preserve">
          <source>Test 10: 25000 text UPDATEs with an index</source>
          <target state="translated">테스트 10 : 인덱스가있는 25000 개의 텍스트 업데이트</target>
        </trans-unit>
        <trans-unit id="aacbc05d861c7b90deae327687214123e261d5d7" translate="yes" xml:space="preserve">
          <source>Test 11: INSERTs from a SELECT</source>
          <target state="translated">테스트 11 : SELECT에서 INSERT</target>
        </trans-unit>
        <trans-unit id="aca64bdf90089bb1a7f070072ce5ba7eb929e0ca" translate="yes" xml:space="preserve">
          <source>Test 12: DELETE without an index</source>
          <target state="translated">테스트 12 : 인덱스없이 삭제</target>
        </trans-unit>
        <trans-unit id="24752c37e60c377f791b489053904e7999992109" translate="yes" xml:space="preserve">
          <source>Test 13: DELETE with an index</source>
          <target state="translated">테스트 13 : 인덱스를 사용하여 삭제</target>
        </trans-unit>
        <trans-unit id="00cb0edebe54a9c5c407d066d9fcba0da202194b" translate="yes" xml:space="preserve">
          <source>Test 14: A big INSERT after a big DELETE</source>
          <target state="translated">테스트 14 : 큰 삭제 후 큰 삽입</target>
        </trans-unit>
        <trans-unit id="8033466c1d65a1a2a0c68dc77e0e42697e35f88b" translate="yes" xml:space="preserve">
          <source>Test 15: A big DELETE followed by many small INSERTs</source>
          <target state="translated">테스트 15 : 큰 삭제 후 많은 작은 INSERT</target>
        </trans-unit>
        <trans-unit id="391b748d4bf30ad6ba35b1537b20fb9263b9be11" translate="yes" xml:space="preserve">
          <source>Test 16: DROP TABLE</source>
          <target state="translated">테스트 16 : DROP TABLE</target>
        </trans-unit>
        <trans-unit id="700f1cfb18cec62b7bd8f4bd15b16b69774b094a" translate="yes" xml:space="preserve">
          <source>Test 1: 1000 INSERTs</source>
          <target state="translated">시험 1 : 1000 INSERT</target>
        </trans-unit>
        <trans-unit id="a74380705222d36f436d75c90099251831b68c6d" translate="yes" xml:space="preserve">
          <source>Test 2: 25000 INSERTs in a transaction</source>
          <target state="translated">테스트 2 : 트랜잭션에서 25000 INSERT</target>
        </trans-unit>
        <trans-unit id="d01c89b36c5ea1e456013c3cc10174d42005deaa" translate="yes" xml:space="preserve">
          <source>Test 3: 25000 INSERTs into an indexed table</source>
          <target state="translated">테스트 3 : 인덱스 테이블에 25000 INSERT</target>
        </trans-unit>
        <trans-unit id="5150380a9467a7720fe9216afc4866b3aea9f992" translate="yes" xml:space="preserve">
          <source>Test 4: 100 SELECTs without an index</source>
          <target state="translated">테스트 4 : 인덱스가없는 100 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="2d07089542c5b6e56dea3631a868016dd2267c55" translate="yes" xml:space="preserve">
          <source>Test 5: 100 SELECTs on a string comparison</source>
          <target state="translated">테스트 5 : 문자열 비교에서 100 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="1ee313e9981650c288efefb71dc3528b68b2a91a" translate="yes" xml:space="preserve">
          <source>Test 6: Creating an index</source>
          <target state="translated">테스트 6 : 색인 작성</target>
        </trans-unit>
        <trans-unit id="e0797e7844f18b5e63c9d2f6207a7266e87d829e" translate="yes" xml:space="preserve">
          <source>Test 7: 5000 SELECTs with an index</source>
          <target state="translated">테스트 7 : 인덱스가있는 5000 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="fccbfc70f55db2b38d057e5e2decb47d90df070e" translate="yes" xml:space="preserve">
          <source>Test 8: 1000 UPDATEs without an index</source>
          <target state="translated">테스트 8 : 인덱스가없는 1000 개의 업데이트</target>
        </trans-unit>
        <trans-unit id="47ad12d810778d98e72de67605dc988105d4b09b" translate="yes" xml:space="preserve">
          <source>Test 9: 25000 UPDATEs with an index</source>
          <target state="translated">테스트 9 : 인덱스를 사용한 25000 업데이트</target>
        </trans-unit>
        <trans-unit id="18a302ee283ea042f30ca2cb852a2846f97c9413" translate="yes" xml:space="preserve">
          <source>Test Code</source>
          <target state="translated">테스트 코드</target>
        </trans-unit>
        <trans-unit id="fbcf57d6160711801ae44b031c459127add7faaa" translate="yes" xml:space="preserve">
          <source>Test Environment</source>
          <target state="translated">테스트 환경</target>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="translated">자동 커밋 모드 테스트</target>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="translated">라이브러리가 스레드로부터 안전한지 테스트</target>
        </trans-unit>
        <trans-unit id="02446da6bfd0c0c261b870c2d7a5bfb426f2969d" translate="yes" xml:space="preserve">
          <source>Test data unavailable.</source>
          <target state="translated">테스트 데이터를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a364e52356a7ca07cff67161e3755ffa1a5b6b19" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes</source>
          <target state="translated">변경 세트가 변경을 기록했는지 테스트</target>
        </trans-unit>
        <trans-unit id="0687fd76855654ace6e8592132670b232e8466bb" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes.</source>
          <target state="translated">변경 세트가 변경을 기록했는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="975278e4cf4ae85f07454f0bd57ddce6fc5bd9a5" translate="yes" xml:space="preserve">
          <source>Testcase macros are also used when two or more cases of a switch statement go to the same block of code, to make sure that the code was reached for all cases:</source>
          <target state="translated">테스트 사례 매크로는 둘 이상의 switch 문의 사례가 동일한 코드 블록으로 이동하여 모든 경우에 대해 코드에 도달했는지 확인하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="translated">테스트 인터페이스</target>
        </trans-unit>
        <trans-unit id="8adc754de4730d9303e4e9dfdc04c11250d45d3c" translate="yes" xml:space="preserve">
          <source>Testing Interface Operation Codes</source>
          <target state="translated">테스트 인터페이스 작동 코드</target>
        </trans-unit>
        <trans-unit id="61b27896db003bc4e45807f83422aff3b0ba8af9" translate="yes" xml:space="preserve">
          <source>Testing of both source code and object code</source>
          <target state="translated">소스 코드와 객체 코드 모두 테스트</target>
        </trans-unit>
        <trans-unit id="e1859263f675753d24029e449e12bbca3196f641" translate="yes" xml:space="preserve">
          <source>Testing on multiple platforms and with multiple compilers</source>
          <target state="translated">여러 플랫폼 및 여러 컴파일러에서 테스트</target>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="translated">텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="104683d616e58eaef10d6dc4873ecdc3df7b2908" translate="yes" xml:space="preserve">
          <source>Text encoding</source>
          <target state="translated">텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="e12c4eeb80ad1f4c53769014c35b62416e040202" translate="yes" xml:space="preserve">
          <source>Text files read by the COPY command can now have line terminators of LF, CRLF, or CR.</source>
          <target state="translated">COPY 명령으로 읽은 텍스트 파일은 이제 LF, CRLF 또는 CR의 줄 종결자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc9a8c0f2eca40d02a98349a624352ec809c4662" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">텍스트는 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; 와 같은 다양한 방법을 사용하여 sqlite3_str 객체에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f06b000ef5df2cf2524013049769bc8b85cadef" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">텍스트는 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; 와 같은 다양한 방법을 사용하여 sqlite3_str 객체에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="65ebd99ce12ebe199710e41e33f5f3620f55ed7a" translate="yes" xml:space="preserve">
          <source>Text values (odd serial types 13 and larger) sort after numeric values in the order determined by the columns &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt;.</source>
          <target state="translated">텍스트 값 (홀수 직렬 유형 13 이상)은 열 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 기능에&lt;/a&gt; 의해 결정된 순서대로 숫자 값 뒤에 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="beca9771feb98f615524a1df72482f4458f93607" translate="yes" xml:space="preserve">
          <source>Text values come after numerics</source>
          <target state="translated">텍스트 값은 숫자 뒤에옵니다</target>
        </trans-unit>
        <trans-unit id="938716cf9d2d773dc94de020d7864e49e44b2b9d" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="translated">이 섹션에서 설명하는 기능은 &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt;SQLite 전문가 확장&lt;/a&gt; 코드를 사용하여 다른 응용 프로그램이나 도구에 통합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5401c7212b5c2e26aee89d6b33a167be2b97f64d" translate="yes" xml:space="preserve">
          <source>That command only works as written on Windows. The equivalent line on a Mac would be:</source>
          <target state="translated">이 명령은 Windows에서 작성된 대로만 작동합니다. Mac에서 동등한 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b3c3c06cd257877a1f47703881aa426e835ba23" translate="yes" xml:space="preserve">
          <source>That last command is the same &quot;ui&quot; command that we ran before. It starts a mini-webserver running and points your web browser at it. But this time we didn't have to specify the repository file because we are located inside a checkout and so fossil can figure out the repository for itself. If you want to type in the repository filename as the second argument, you can. But it is optional.</source>
          <target state="translated">마지막 명령은 이전에 실행했던 것과 동일한 &quot;ui&quot;명령입니다. 미니 웹 서버가 실행되고 웹 브라우저가 나타납니다. 그러나 이번에는 체크 아웃 내부에 위치하고 있기 때문에 저장소 파일을 지정할 필요가 없었으므로 화석은 저장소 자체를 알아낼 수 있습니다. 저장소 파일 이름을 두 번째 인수로 입력하려는 경우 가능합니다. 그러나 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="a5f3f833bc87b1f8e923756ce16d0960d01c9cad" translate="yes" xml:space="preserve">
          <source>That number is very close to 47.49, but it is not exact. It is a little too big. If we reduce M by one to 6683623321994526 so that we have the next smaller possible binary64 value, we get:</source>
          <target state="translated">이 숫자는 47.49에 매우 가깝지만 정확하지는 않습니다. 너무 큽니다. 다음으로 더 작은 가능한 binary64 값을 갖도록 M을 1 씩 6683623321994526으로 줄이면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec5cf39a76e0d09154e1a51128f437190f411ce" translate="yes" xml:space="preserve">
          <source>That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a database file. See &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt An SQLite Database File&lt;/a&gt; for further information.</source>
          <target state="translated">그러나 하드웨어 나 OS의 외부 프로그램이나 버그가 데이터베이스 파일을 손상시키기 위해 할 수있는 일이 많이 있습니다. 자세한 내용 &lt;a href=&quot;howtocorrupt&quot;&gt;은 SQLite 데이터베이스 파일을 손상시키는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac09579911e9129dbe219b67c0bf67a294beccfa" translate="yes" xml:space="preserve">
          <source>That statement is ambiguous, having at least two possible interpretations:</source>
          <target state="translated">이 진술은 모호하며 적어도 두 가지 해석이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c679c2a5140d95b7fe5e7a9c937890448e4790a5" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_parent table as there are non-leaf cells in the r-tree structure, and that there is a non-leaf cell that corresponds to each entry in the %_parent table.</source>
          <target state="translated">r-tree 구조에 리프가 아닌 셀이 있고 % _parent 테이블의 각 항목에 해당하는 리프가 아닌 셀이 % _parent 테이블에 같은 수의 항목이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bc14fa3c4653db3dfe511c9da292c9e32677da7" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_rowid table as there are leaf cells in the r-tree structure, and that there is a leaf cell that corresponds to each entry in the %_rowid table.</source>
          <target state="translated">r-tree 구조에 리프 셀이있는 것과 % _rowid 테이블에 동일한 개수의 항목이 있고 % _rowid 테이블의 각 항목에 해당하는 리프 셀이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="c3fcc1dd87de9c9ad15a933b970c62ff1decbfcb" translate="yes" xml:space="preserve">
          <source>The &quot;%&quot; in the name of each shadow table is replaced by the name of the R*Tree virtual table. So, if the name of the R*Tree table is &quot;xyz&quot; then the three shadow tables would be &quot;xyz_node&quot;, &quot;xyz_parent&quot;, and &quot;xyz_rowid&quot;.</source>
          <target state="translated">각 새도우 테이블 이름의 &quot;%&quot;는 R * Tree 가상 테이블 이름으로 바뀝니다. 따라서 R * Tree 테이블의 이름이 &quot;xyz&quot;이면 세 개의 새도우 테이블은 &quot;xyz_node&quot;, &quot;xyz_parent&quot;및 &quot;xyz_rowid&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ac1d4dc22d0f78dbeef0512926462de5ac6f42" translate="yes" xml:space="preserve">
          <source>The &quot;-1&quot; term at the start of the formula is not found in most implementations of the BM25 algorithm. Without it, a better match is assigned a numerically higher BM25 score. Since the default sorting order is &quot;ascending&quot;, this means that appending &quot;ORDER BY bm25(fts)&quot; to a query would cause results to be returned in order from worst to best. The &quot;DESC&quot; keyword would be required in order to return the best matches first. In order to avoid this pitfall, the FTS5 implementation of BM25 multiplies the result by -1 before returning it, ensuring that better matches are assigned numerically lower scores.</source>
          <target state="translated">수식 시작시 &quot;-1&quot;용어는 대부분의 BM25 알고리즘 구현에서 찾을 수 없습니다. 그것없이, 더 나은 경기는 수치 적으로 더 높은 BM25 점수가 할당됩니다. 기본 정렬 순서는 &quot;오름차순&quot;이므로 쿼리에 &quot;ORDER BY bm25 (fts)&quot;를 추가하면 결과가 최악에서 최상의 순서로 반환됩니다. 가장 일치하는 항목을 먼저 반환하려면 &quot;DESC&quot;키워드가 필요합니다. 이러한 함정을 피하기 위해, BM25의 FTS5 구현은 결과를 반환하기 전에 -1을 곱하여 더 나은 일치에 수치 적으로 낮은 점수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e8a8a21328c61527fb3df55781ac56d188f8d80f" translate="yes" xml:space="preserve">
          <source>The &quot;.archive&quot; dot-command and the &quot;-A&quot; command-line option provide built-in support for the &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive format&lt;/a&gt;. The interface is similar to that of the &quot;tar&quot; command on unix systems. Each invocation of the &quot;.ar&quot; command must specify a single command option. The following commands are available for &quot;.archive&quot;:</source>
          <target state="translated">&quot;.archive&quot;도트 명령 및 &quot;-A&quot;명령 행 옵션은 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive 형식&lt;/a&gt; 을 기본적으로 지원 합니다 . 인터페이스는 유닉스 시스템에서 &quot;tar&quot;명령의 인터페이스와 유사합니다. &quot;.ar&quot;명령을 호출 할 때마다 단일 명령 옵션을 지정해야합니다. &quot;.archive&quot;에 대해 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83487a27f6e8c5a3e4b3ee1c0c3210033e4ad993" translate="yes" xml:space="preserve">
          <source>The &quot;.breakpoint&quot; command in the CLI does nothing but invoke the procedure named &quot;test_breakpoint()&quot;, which is a no-op.</source>
          <target state="translated">CLI의 &quot;.breakpoint&quot;명령은 no-op 인 &quot;test_breakpoint ()&quot;라는 프로 시저를 호출 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="469a3442411a65b2a429f963b79791f612ed7d6e" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file.</source>
          <target state="translated">&quot;.databases&quot;명령은 현재 연결에서 열린 모든 데이터베이스 목록을 보여줍니다. 항상 2 개 이상이 있어야합니다. 첫 번째는 &quot;main&quot;이며 원래 데이터베이스가 열립니다. 두 번째는 임시 테이블에 사용되는 데이터베이스 인 &quot;temp&quot;입니다. ATTACH 문을 사용하여 첨부 된 데이터베이스에 대해 추가 데이터베이스가 나열 될 수 있습니다. 첫 번째 출력 열은 데이터베이스가 연결된 이름이고 두 번째 열은 외부 파일의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ee926b57bed300f9a7e5c92f6be433c508e9bcc7" translate="yes" xml:space="preserve">
          <source>The &quot;.dump&quot; output from the shell does not work if there are embedded newlines anywhere in the data. This is an old bug that was carried forward from version 1.0. To fix it, the &quot;.dump&quot; output no longer uses the COPY command. It instead generates INSERT statements.</source>
          <target state="translated">데이터의 아무 곳에도 줄 바꿈이 포함되어 있으면 셸의 &quot;.dump&quot;출력이 작동하지 않습니다. 이것은 버전 1.0에서 수행 된 오래된 버그입니다. 이 문제를 해결하기 위해 &quot;.dump&quot;출력은 더 이상 COPY 명령을 사용하지 않습니다. 대신 INSERT 문을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1b85291d31b07e89b01fbd9925959d88473c2a10" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is an alias for &quot;.once -x&quot;. It does exactly the same thing.</source>
          <target state="translated">&quot;.excel&quot;명령은 &quot;.once -x&quot;의 별명입니다. 정확히 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="9686c64857b56634cf1d980b549835b7a48ecb3c" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is really an alias for &quot;.once -x&quot;. The -x option to .once causes it to writes results as CSV into a temporary file that is named with a &quot;.csv&quot; suffix, then invoke the systems default handler for CSV files.</source>
          <target state="translated">&quot;.excel&quot;명령은 실제로 &quot;.once -x&quot;의 별명입니다. -x 옵션을 .once로 설정하면 &quot;.csv&quot;접미사로 이름 지정된 임시 파일에 결과를 CSV로 기록한 다음 CSV 파일에 대한 시스템 기본 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a0ea244938baaf074aedf53e702eadce70d483bf" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command accepts the following options:</source>
          <target state="translated">&quot;.expert&quot;명령은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="62869dd914f2d45ca628931082045505cc0aa98c" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command is issued first, followed by the SQL query on a separate line. For example, consider the following session:</source>
          <target state="translated">&quot;.expert&quot;명령이 먼저 발행 된 후 별도의 행에 SQL 조회가 수행됩니다. 예를 들어 다음 세션을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bf73e6ae296e826f7923e0357132694890491637" translate="yes" xml:space="preserve">
          <source>The &quot;.fullschema&quot; dot-command works like the &quot;.schema&quot; command in that it displays the entire database schema. But &quot;.fullschema&quot; also includes dumps of the statistics tables &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;, and &quot;sqlite_stat4&quot;, if they exist. The &quot;.fullschema&quot; command normally provides all of the information needed to exactly recreate a query plan for a specific query. When reporting suspected problems with the SQLite query planner to the SQLite development team, developers are requested to provide the complete &quot;.fullschema&quot; output as part of the trouble report. Note that the sqlite_stat3 and sqlite_stat4 tables contain samples of index entries and so might contain sensitive data, so do not send the &quot;.fullschema&quot; output of a proprietary database over a public channel.</source>
          <target state="translated">&quot;.fullschema&quot;도트 명령은 전체 데이터베이스 스키마를 표시한다는 점에서 &quot;.schema&quot;명령과 동일하게 작동합니다. 그러나 &quot;.fullschema&quot;에는 통계 테이블 &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;및 &quot;sqlite_stat4&quot;(있는 경우)의 덤프도 포함됩니다. &quot;.fullschema&quot;명령은 일반적으로 특정 쿼리에 대한 쿼리 계획을 정확하게 재생성하는 데 필요한 모든 정보를 제공합니다. SQLite 쿼리 플래너에서 의심되는 문제를 SQLite 개발 팀에보고 할 때 개발자는 문제 보고서의 일부로 완전한 &quot;.fullschema&quot;출력을 제공해야합니다. sqlite_stat3 및 sqlite_stat4 테이블에는 색인 항목의 샘플이 포함되므로 민감한 데이터가 포함될 수 있으므로 &quot;.fullschema&quot;를 보내지 마십시오.공개 채널을 통한 독점 데이터베이스 출력.</target>
        </trans-unit>
        <trans-unit id="8c41f773b4bec069e65cdeb1f84472339fd67927" translate="yes" xml:space="preserve">
          <source>The &quot;.genfkey&quot; operator has been removed from the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&quot;.genfkey&quot;연산자가 &lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6da1e8e52719870c46e4714e803817bbb945c7a2" translate="yes" xml:space="preserve">
          <source>The &quot;.indexes&quot; command works in a similar way to list all of the indexes. If the &quot;.indexes&quot; command is given an argument which is the name of a table, then it shows just indexes on that table.</source>
          <target state="translated">&quot;.indexes&quot;명령은 모든 색인을 나열하는 유사한 방식으로 작동합니다. &quot;.indexes&quot;명령에 테이블 이름 인 인수가 제공되면 해당 테이블의 인덱스 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="332e81eb83bf30c51e9f2eb4830d160fd5e91b60" translate="yes" xml:space="preserve">
          <source>The &quot;.load&quot; command with one argument invokes sqlite3_load_extension() with the zProc parameter set to NULL, causing SQLite to first look for an entry point named &quot;sqlite3_extension_init&quot; and then &quot;sqlite3_X_init&quot; where &quot;X&quot; is derived from the filename. If your extension has an entry point with a different name, simply supply that name as the second argument. For example:</source>
          <target state="translated">하나의 인수가있는 &quot;.load&quot;명령은 zProc 매개 변수가 NULL로 설정된 sqlite3_load_extension ()을 호출하여 SQLite가 먼저 &quot;sqlite3_extension_init&quot;라는 진입 점을 찾은 다음 &quot;sqlite3_X_init&quot;를 찾게되며 여기서 &quot;X&quot;는 파일 이름에서 파생됩니다. 확장에 다른 이름의 진입 점이 있으면 해당 이름을 두 번째 인수로 제공하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e0f642688db88c440c3786a62b2e62ab2274b87" translate="yes" xml:space="preserve">
          <source>The &quot;.parameter&quot; command exists to simplify managing this table. The &quot;.parameter init&quot; command (often abbreviated as just &quot;.param init&quot;) creates the temp.sqlite_parameters table if it does not already exist. The &quot;.param list&quot; command shows all entries in the temp.sqlite_parameters table. The &quot;.param clear&quot; command drops the temp.sqlite_parameters table. The &quot;.param set KEY VALUE&quot; and &quot;.param unset KEY&quot; commands create or delete entries from the temp.sqlite_parameters table.</source>
          <target state="translated">이 테이블 관리를 단순화하기 위해 &quot;.parameter&quot;명령이 존재합니다. &quot;.parameter init&quot;명령 (종종 &quot;.param init&quot;로 축약 됨)은 temp.sqlite_parameters 테이블이없는 경우이를 작성합니다. &quot;.param list&quot;명령은 temp.sqlite_parameters 테이블의 모든 항목을 보여줍니다. &quot;.param clear&quot;명령은 temp.sqlite_parameters 테이블을 삭제합니다. &quot;.param set KEY VALUE&quot;및 &quot;.param unset KEY&quot;명령은 temp.sqlite_parameters 테이블에서 항목을 작성하거나 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="789a156efc523de5bfce09730a51219cae2ec0c9" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command can be augmented with the &quot;--indent&quot; option, in which case it tries to reformat the various CREATE statements of the schema so that they are more easily readable by humans.</source>
          <target state="translated">&quot;. 들여 쓰기&quot;옵션을 사용하여 &quot;.schema&quot;명령을 보강 할 수 있습니다.이 경우 스키마는 사람이보다 쉽게 ​​읽을 수 있도록 스키마의 다양한 CREATE 문을 다시 형식화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="754968254f462d66877df03c1c7cd51953693cab" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command is roughly the same as setting list mode, then entering the following query:</source>
          <target state="translated">&quot;.schema&quot;명령은 설정 목록 모드와 거의 동일하며 다음 쿼리를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="7428559526f83a5c56d268af9889807faae2685e" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the complete schema for the database, or for a single table if an optional tablename argument is provided:</source>
          <target state="translated">&quot;.schema&quot;명령은 데이터베이스 또는 선택적 tablename 인수가 제공되는 경우 단일 테이블에 대한 전체 스키마를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="52ace065300c40138c37799338bd3ec51aca18df" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the structure of virtual tables.</source>
          <target state="translated">&quot;.schema&quot;명령은 가상 테이블의 구조를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="73bcba8970e82dc921d7f4ec8db20bb33cbfb0a3" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest --init&quot; command creates the selftest table if it does not already exists, then appends entries that check the SHA3 hash of the content of all tables. Subsequent runs of &quot;.selftest&quot; will verify that the database has not been changed in any way. To generates tests to verify that a subset of the tables are unchanged, simply run &quot;.selftest --init&quot; then &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; the selftest rows that refer to tables that are not constant.</source>
          <target state="translated">&quot;.selftest --init&quot;명령은 selftest 테이블이 없으면 작성하고 모든 테이블 내용의 SHA3 해시를 확인하는 항목을 추가합니다. &quot;.selftest&quot;의 후속 실행은 데이터베이스가 변경되지 않았 음을 확인합니다. 테이블의 하위 집합이 변경되지 않았 음을 확인하는 테스트를 생성하려면 &quot;.selftest --init&quot;를 실행 한 다음 상수가 아닌 테이블을 참조하는 자체 테스트 행 을 &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b23d6efbb796b87124747de656b1313433a59a58" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest&quot; command attempts to verify that a database is intact and is not corrupt. The .selftest command looks for a table in schema named &quot;selftest&quot; and defined as follows:</source>
          <target state="translated">&quot;.selftest&quot;명령은 데이터베이스가 손상되지 않았는지 확인하려고 시도합니다. .selftest 명령은 &quot;selftest&quot;라는 스키마에서 다음과 같이 정의 된 테이블을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="da3394cbf6e430093bb273dc53c5c24290fb42a2" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command is implemented with the help of the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;extension function &quot;sha3_query()&quot;&lt;/a&gt; that is included with the command-line shell.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 명령 행 쉘에 포함 된 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;확장 기능 &quot;sha3_query ()&quot;&lt;/a&gt; 의 도움으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="49607863a0b317eaa9e0bb0334b35c6b17a96a09" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command supports options &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;, and &quot;--sha3-512&quot; to define which variety of SHA3 to use for the hash. The default is SHA3-256.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;및 &quot;--sha3-512&quot;옵션을 지원하여 다양한 SHA3에 사용할 SHA3를 정의합니다. 해시시. 기본값은 SHA3-256입니다.</target>
        </trans-unit>
        <trans-unit id="e496b68fde3cba7a6d3e4d071d1b64676cd89817" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command takes a single optional argument which is a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern. If this option is present, only tables whose names match the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern will be hashed.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 패턴 인 단일 선택적 인수를 사용 합니다. 이 옵션이 있으면 이름이 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 패턴 과 일치하는 테이블 만 해시됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e55e4c460c47133735d47238f402c87368287c" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; dot-command computes a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; hash of the &lt;em&gt;content&lt;/em&gt; of the database. To be clear, the hash is computed over the database content, not its representation on disk. This means, for example, that a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or similar data-preserving transformation does not change the hash.</source>
          <target state="translated">&quot;.sha3sum&quot;도트 명령은 데이터베이스 &lt;em&gt;컨텐츠&lt;/em&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; 해시를 계산 합니다. 분명히 해시는 디스크상의 표현이 아니라 데이터베이스 내용에 대해 계산됩니다. 예를 들어, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 또는 이와 유사한 데이터 보존 변환은 해시를 변경하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2252b9e19709b03f7ab086b59b1a77291173bd1" translate="yes" xml:space="preserve">
          <source>The &quot;.tables&quot; command is similar to setting list mode then executing the following query:</source>
          <target state="translated">&quot;.tables&quot;명령은 목록 모드를 설정 한 후 다음 쿼리를 실행하는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9eda9619ee5cbc80757e21696103e58ade470ff1" translate="yes" xml:space="preserve">
          <source>The &quot;.width&quot; command in the example above sets the width of the first column to 12 and the width of the second column to 6. All other column widths were unaltered. You can give as many arguments to &quot;.width&quot; as necessary to specify the widths of as many columns as are in your query results.</source>
          <target state="translated">위 예에서 &quot;.width&quot;명령은 첫 번째 열의 너비를 12로 설정하고 두 번째 열의 너비를 6으로 설정합니다. 다른 모든 열 너비는 변경되지 않았습니다. 쿼리 결과에있는 열의 너비를 지정하는 데 필요한만큼 &quot;.width&quot;에 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d28508cd52964017863df7d9bff1bae6f7b1b73" translate="yes" xml:space="preserve">
          <source>The &quot;1&quot; at the end of the name for the json1 extension is deliberate. The designers anticipate that there will be future incompatible JSON extensions building upon the lessons learned from json1. Once sufficient experience is gained, some kind of JSON extension might be folded into the SQLite core. For now, JSON support remains an extension.</source>
          <target state="translated">json1 확장자의 이름 끝에 &quot;1&quot;이 있습니다. 설계자는 json1에서 배운 교훈을 바탕으로 미래에 호환되지 않는 JSON 확장이있을 것으로 예상합니다. 충분한 경험을 얻으면 어떤 종류의 JSON 확장이 SQLite 코어로 접힐 수 있습니다. 현재 JSON 지원은 확장으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec1a7b1bff513b8dc885dad8096593de50c679b9" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;&quot; command ignores an initial UTF-8 BOM.</source>
          <target state="translated">&quot; &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; &quot;명령은 초기 UTF-8 BOM을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="39a3b12173588647fa6bbe9bfdec68cffc6ff3a2" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; where the right-most &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt; is either UNION or UNION ALL.</source>
          <target state="translated">&quot; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &quot;는 가장 오른쪽의 &lt;a href=&quot;syntax/compound-operator&quot;&gt;복합 연산자&lt;/a&gt; 가 UNION 또는 UNION ALL 인 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 선택&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1ee86a4eb35dd217941c49a4c1f826afe5d0c7" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following &quot;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&quot; is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.</source>
          <target state="translated">위의 &quot; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &quot;구문 다이어그램은 일부 독자가 유용하다고 생각하기 때문에 단일 다이어그램에서 가능한 많은 SELECT 문 구문을 표시하려고 시도합니다. 다음 &quot; &lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt; &quot;는 동일한 구문을 표현하지만 구문을 더 작은 청크로 나누는 대체 구문 다이어그램입니다.</target>
        </trans-unit>
        <trans-unit id="9f631ef63bea49256ea8a2d7bafc4554c3faedfb" translate="yes" xml:space="preserve">
          <source>The &quot;Application ID&quot; set by &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;.</source>
          <target state="translated">에 의해 &quot;응용 프로그램 ID&quot;세트 &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA는 APPLICATION_ID&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f5d1070df133cbc828d184fa205995550d45fd" translate="yes" xml:space="preserve">
          <source>The &quot;CREATE TABLE&quot; command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:</source>
          <target state="translated">&quot;CREATE TABLE&quot;명령은 SQLite 데이터베이스에서 새 테이블을 작성하는 데 사용됩니다. CREATE TABLE 명령은 새 테이블의 다음 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="07114418ccb01065c3be30aab50b4df2c4bf363e" translate="yes" xml:space="preserve">
          <source>The &quot;GENERATED ALWAYS&quot; keywords at the beginning of the constraint and the &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword at the end are all optional. Only the &quot;AS&quot; keyword and the parenthesized expression are required. If the trailing &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword is omitted, then VIRTUAL is the default. Hence, the example statement above could be simplified to just:</source>
          <target state="translated">제약 조건의 시작 부분에있는 &quot;GENERATED ALWAYS&quot;키워드와 끝 부분에있는 &quot;VIRTUAL&quot;또는 &quot;STORED&quot;키워드는 모두 선택 사항입니다. &quot;AS&quot;키워드와 괄호로 묶인 표현식 만 필요합니다. 후행 &quot;VIRTUAL&quot;또는 &quot;STORED&quot;키워드가 생략되면 VIRTUAL이 기본값입니다. 따라서 위의 예제 문은 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5736b1f20cbfd4541c75d144c2bb263b3a789707" translate="yes" xml:space="preserve">
          <source>The &quot;INDEXED BY index-name&quot; phrase specifies that the named index must be used in order to look up values on the preceding table. If index-name does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The &quot;NOT INDEXED&quot; clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; can still be used to look up entries even when &quot;NOT INDEXED&quot; is specified.</source>
          <target state="translated">&quot;INDEXED BY index-name&quot;구문은 이전 표에서 값을 조회하기 위해 명명 된 색인을 사용해야 함을 지정합니다. index-name이 없거나 조회에 사용할 수없는 경우 SQL 문 준비에 실패합니다. &quot;NOT INDEXED&quot;절은 UNIQUE 및 PRIMARY KEY 제약 조건에 의해 생성 된 암시 적 인덱스를 포함하여 앞의 테이블에 액세스 할 때 인덱스를 사용하지 않도록 지정합니다. 그러나 &quot;NOT INDEXED&quot;가 지정된 경우에도 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 사용하여 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21fa27bc6e581b8fb060c98b51ebafd394898e71" translate="yes" xml:space="preserve">
          <source>The &quot;INSERT INTO</source>
          <target state="translated">&quot;삽입</target>
        </trans-unit>
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">&quot;ORDER BY 2&quot;( &quot;ORDER BY under_alice.level + 1&quot;과 동일 함)는 조직도에서 더 높은 레벨 (더 작은 &quot;레벨&quot;값을 가짐)이 먼저 처리되어 광범위한 검색을 수행합니다. 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">재귀 선택의 &quot;ORDER BY checkin.mtime DESC&quot;용어는 오래 전부터 체크인을 병합하는 분기를 따르지 않도록하여 쿼리를 훨씬 빠르게 실행합니다. ORDER BY는 재귀 선택이 우리가 원하는 가장 최근의 체크인에 집중하도록합니다. 재귀 선택에 ORDER BY가 없으면 수천 명의 조상 전체를 계산하고 mtime별로 정렬 한 다음 상위 20 위를 차지해야합니다. ORDER BY는 본질적으로 재귀 쿼리가 가장 최근의 조상을 먼저 보도록하는 우선 순위 큐를 설정하므로 LIMIT 절을 사용하여 쿼리의 범위를 관심있는 체크인으로 만 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">&quot;PRAGMA cache_spill =</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">&quot;PRAGMA data_version&quot;명령은 데이터베이스 파일이 수정되었음을 표시합니다. 메모리에 데이터베이스 컨텐츠를 보유하거나 화면에 데이터베이스 컨텐츠를 표시하는 대화식 프로그램은 PRAGMA data_version 명령을 사용하여 메모리를 비우고 다시로드하거나 화면 표시를 업데이트해야하는지 여부를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">&quot;PRAGMA data_version&quot;값은 각 데이터베이스 연결의 로컬 특성이므로 별도의 데이터베이스 연결에서 &quot;PRAGMA data_version&quot;을 두 번 동시에 호출하여 리턴 된 값은 기본 데이터베이스가 동일하더라도 종종 다릅니다. 동일한 데이터베이스 연결에서 반환 된 &quot;PRAGMA data_version&quot;값을 서로 다른 두 시점에서 비교하는 것만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">&quot;페이지 수&quot;-저널의 다음 세그먼트에있는 페이지 수 또는 모든 컨텐츠를 파일 끝까지 의미하는 -1</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">위 출력의 &quot;USING TEMP B-TREE&quot;절은 임시 b- 트리 구조가 두 개의 하위 선택 결과의 UNION을 구현하는 데 사용됨을 나타냅니다. 복합을 계산하는 다른 방법은 각 하위 쿼리를 공동 루틴으로 실행하고 출력이 정렬 된 순서로 표시되도록 정렬하고 결과를 병합하는 것입니다. 쿼리 플래너가이 후자의 접근 방식을 선택하면 EXPLAIN QUERY PLAN 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">&lt;a href=&quot;printf&quot;&gt;내장 printf&lt;/a&gt; 구현 의 &quot;alternate-form-2&quot;플래그 ( &quot;!&quot;)는 이제 문자열 대체가 바이트 대신 문자의 너비와 정밀도를 측정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">&quot;atom&quot;열은 기본 요소 (JSON 배열 및 객체 이외의 요소)에 해당하는 SQL 값입니다. JSON 배열 또는 객체의 &quot;atom&quot;열은 NULL입니다. &quot;value&quot;열은 기본 JSON 요소의 &quot;atom&quot;열과 동일하지만 배열 및 객체의 JSON 값 텍스트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">&quot;authorizer&quot;방법</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">&quot;authorizer&quot;메소드는 &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++ 인터페이스에 대한 액세스를 제공합니다 . 권한 부 여자에 대한 인수는 특정 조작을 권한 부여하기 위해 SQL 문을 컴파일 할 때 호출되는 프로 시저 이름입니다. 콜백 프로시 저는 코딩중인 오퍼레이션을 설명하는 5 개의 인수를 사용합니다. 콜백이 텍스트 문자열 &quot;SQLITE_OK&quot;를 리턴하면 조작이 허용됩니다. &quot;SQLITE_IGNORE&quot;를 반환하면 작업이 자동으로 비활성화됩니다. 리턴이 &quot;SQLITE_DENY&quot;인 경우 오류로 컴파일에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">&quot;automerge = N&quot;명령 (여기서 N은 0에서 15 사이의 정수임)은 자동 증분 반전 인덱스 병합을 제어하는 ​​FTS3 / 4 테이블 &quot;automerge&quot;매개 변수를 구성하는 데 사용됩니다. 새 테이블의 기본 자동 병합 값은 0입니다. 즉, 자동 증분 병합이 완전히 사용되지 않습니다. &quot;automerge = N&quot;명령을 사용하여 automerge 매개 변수의 값을 수정하면 새 매개 변수 값이 데이터베이스에 지속적으로 저장되고 이후에 설정된 모든 데이터베이스 연결에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">&quot;백업&quot;방법</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">&quot;backup&quot;방법은 라이브 데이터베이스의 백업 사본을 만듭니다. 명령 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">&quot;bind_fallback&quot;메소드</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">&quot;bind_fallback&quot;메소드는 매개 변수 이름과 일치하는 TCL 변수가 없을 때 응용 프로그램이 매개 변수 바인딩을 처리하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">&quot;bind_fallback&quot;메소드에는 단일 선택적 인수가 있습니다. 인수가 빈 문자열이면 bind_fallback이 취소되고 기본 동작이 복원됩니다. 인수가 비어 있지 않은 문자열 인 경우, 인수는 TCL 변수와 일치하지 않는 SQL 매개 변수가 표시 될 때마다 호출하는 TCL 명령 (일반적으로 proc의 이름)입니다. &quot;bind_fallback&quot;메소드에 인수가 없으면 현재 bind_fallback 명령이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">&quot;바쁜&quot;방법</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">&quot;timeout&quot;과 같은 &quot;busy&quot;방법은 데이터베이스가 잠겨있을 때만 작동합니다. 그러나 &quot;사용 중&quot;방법을 사용하면 프로그래머가 수행 할 작업을 훨씬 더 많이 제어 할 수 있습니다. &quot;busy&quot;메소드는 SQLite가 잠긴 데이터베이스를 열려고 시도 할 때마다 호출되는 콜백 Tcl 프로 시저를 지정합니다. 단일 정수 인수가 호출되기 전에 콜백에 추가됩니다. 인수는 현재 잠금 이벤트에 대한 통화 중 콜백에 대한 이전 호출 수입니다. 콜백은 잠깐 동안 다른 유용한 작업 (예 : 서비스 GUI 이벤트)을 수행 한 후 리턴하여 잠금을 다시 시도 할 수 있도록하기위한 것입니다. 콜백 프로시 저는 SQLite가 데이터베이스를 다시 열려고 할 경우 &quot;0&quot;을 리턴하고 SQLite가 현재 조작을 포기하도록하려면 &quot;1&quot;을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">&quot;캐시&quot;방법</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">&quot;변경&quot;방법</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">&quot;changes&quot;메소드는 가장 최근의 &quot;eval&quot;메소드에 의해 삽입, 삭제 및 / 또는 수정 된 데이터베이스의 행 수인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b6c35aac78db7a1383140bebe49b233115675bec" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will always respond with &quot;0&quot; if the database file does not have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of 8. The pragma will return no rows at all if the cksumvfs extension is not loaded.</source>
          <target state="translated">&quot;checksum_verification&quot;pragma는 데이터베이스 파일에 &lt;a href=&quot;fileformat2#resbyte&quot;&gt;예비 바이트&lt;/a&gt; 값 8이 없는 경우 항상 &quot;0&quot;으로 응답합니다 . pragma는 cksumvfs 확장이로드되지 않은 경우 행을 전혀 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1066b4da2db6b6f62f1cb1a75e51624adbe905f6" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will return &quot;1&quot; (true) or &quot;0&quot; (false) if checksum verification is enabled or disabled, respectively. &quot;Verification&quot; in this context means the feature that causes SQLITE_IOERR_DATA errors if a checksum mismatch is detected while reading. Checksums are always kept up-to-date as long as the &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of the database is 8, regardless of the setting of this pragma. Checksum verification can be disabled (for example) to do forensic analysis of a database that has previously reported a checksum error.</source>
          <target state="translated">&quot;checksum_verification&quot;pragma는 체크섬 확인이 활성화되거나 비활성화 된 경우 각각 &quot;1&quot;(true) 또는 &quot;0&quot;(false)을 반환합니다. 이 컨텍스트에서 &quot;확인&quot;은 읽는 동안 체크섬 불일치가 감지되면 SQLITE_IOERR_DATA 오류를 발생시키는 기능을 의미합니다. 이 pragma의 설정에 관계없이 데이터베이스 의 &lt;a href=&quot;fileformat2#resbyte&quot;&gt;예약 바이트&lt;/a&gt; 값이 8 인 한 체크섬은 항상 최신 상태로 유지됩니다 . 예를 들어, 체크섬 확인을 비활성화하여 이전에 체크섬 오류를보고 한 데이터베이스의 포렌식 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">&quot;닫기&quot;방법</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">&quot;콜레이트&quot;방법</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">&quot;collation_needed&quot;메소드</target>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="translated">&quot;열&quot;모드는 표 형식의 출력 형식입니다. &quot;box&quot;, &quot;markdown&quot;및 &quot;table&quot;과 같은 기타 표 형식 출력 형식 :</target>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="translated">&quot;column&quot;출력 모드는 가장 긴 출력 행을 포함하도록 자동으로 열을 확장하고 이전에 설정되지 않은 경우 &quot;.header&quot;를 자동으로 켭니다.</target>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 또는 FROM- 절 서브 쿼리 의 &quot;열&quot; 은 실제로 VIEW 또는 서브 쿼리를 구현하는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에있는 표현식입니다 . 따라서 VIEW 또는 하위 쿼리의 열에 대한 선호도는 위의 표현식 선호도 규칙에 의해 결정됩니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">&quot;commit_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">&quot;완전한&quot;방법</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">&quot;완전한&quot;방법은 사용자가 SQL 코드 줄을 입력 한 시점을 알기 위해 대화식 응용 프로그램을 작성할 때 유용합니다. 이것은 실제로 &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete ()&lt;/b&gt;&lt;/a&gt; C 함수에 대한 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">&quot;complete&quot;메소드는 유일한 SQL 문자열로 간주됩니다. 문자열이 완전한 SQL 문인 경우 TRUE를, 더 입력해야 할 경우 FALSE를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">&quot;config&quot;메소드</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">&quot;config&quot;메소드는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스를 사용하여 데이터베이스 연결에 대한 특정 구성 설정을 조회하거나 변경합니다 . 사용 가능한 구성 설정 및 현재 값의 TCL 목록을 얻으려면 인수없이이 메소드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">&quot;configure&quot;스크립트는 이제 큰 파일 지원을 위해 Unix 시스템을 자동으로 구성해야합니다. 큰 파일이 있고 큰 파일 지원이 비활성화 된 경우에 대한 오류 메시지가 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X 번째 루프에 대한 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명이 포함 된 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X 번째 루프에 대한 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명이 포함 된 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수는 X 번째 루프에 사용 된 인덱스 또는 테이블 이름을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X- 번째 루프에 대한 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X- 번째 루프에 대한 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수는 X 번째 루프에 사용되는 인덱스 또는 테이블의 이름을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">&quot;content&quot;옵션은 FTS5 테이블을 &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;외부 컨텐츠 또는 contentless 테이블&lt;/a&gt; 로 만드는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">&quot;content_rowid&quot;옵션은 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 컨텐츠 테이블&lt;/a&gt; 의 rowid 필드를 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">&quot;복사&quot;방법</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">&quot;복사&quot;방법은 파일에서 테이블로 데이터를 복사합니다. 파일에서 성공적으로 처리 된 행 수를 리턴합니다. 복사 방법의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">여기서 &quot;비용&quot;은 로그입니다. 중첩 루프를 사용하면 작업이 곱해지고 추가되지 않습니다. 그러나 가중 가중치가있는 그래프를 생각하는 것이 일반적이므로 그래프는 다양한 비용의 로그를 보여줍니다. 그래프는 S가 약 6.87 인 L의 비용 이점을 보여 주지만 이는 S 루프가 L 루프의 외부가 아닌 L 루프의 내부에있을 때 약 963 배 더 빠르게 실행되는 쿼리로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">쉘의 &quot;csv&quot;모드 옵션은 문자열을 큰 따옴표 안에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">&quot;db&quot;매개 변수는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터 입니다. &quot;main&quot;인수는 임 포스터 테이블이 작성 될 스키마의 이름입니다. &quot;1&quot;인수는 임 포스터 테이블 메커니즘을 사용 가능하게합니다. &quot;tnum&quot;은 임 포스터 테이블이 미러링해야하는 인덱스의 루트 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">&quot;직렬화 해제&quot;방법</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">&quot;deserialize&quot;메소드는 SQLite 데이터베이스 파일이 포함 된 TCL 바이트 배열을 가져 와서 데이터베이스 연결에 추가합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">&quot;docid&quot;별명이 존재하지 않습니다. 응용 프로그램은 &quot;rowid&quot;를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;double&quot;변수는 X 번째 루프의 각 반복에서 출력 된 평균 행 수에 대한 쿼리 플래너의 추정치로 설정됩니다. 쿼리 플래너의 추정값이 정확하면이 값은 몫 NVISIT / NLOOP에 근사하며 동일한 SELECTID를 가진 모든 이전 루프에 대한이 값의 곱은 현재 루프의 NLOOP 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;double&quot;변수는 X 번째 루프의 각 반복에서 출력되는 평균 행 수에 대한 쿼리 플래너의 추정치로 설정됩니다. 쿼리 플래너의 추정값이 정확하면이 값은 몫 NVISIT / NLOOP에 가깝고 동일한 SELECTID를 가진 모든 이전 루프에 대한이 값의 곱은 현재 루프의 NLOOP 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">&quot;인상&quot;텍스트.</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">&quot;enable_load_extension&quot;메소드</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">&quot;엔드 매치&quot;텍스트</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">&quot;오류 코드&quot;방법</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">&quot;평가&quot;방법</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">&lt;a href=&quot;#eval&quot;&gt;위에서&lt;/a&gt; 설명한 &quot;eval&quot;메소드는 최근에 평가 된 SQL 명령에 대해 &lt;a href=&quot;c3ref/prepare&quot;&gt;준비된 명령문&lt;/a&gt; 의 캐시를 유지 합니다. &quot;캐시&quot;방법은이 캐시를 제어하는 ​​데 사용됩니다. 이 명령의 첫 번째 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">&quot;존재&quot;방법</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">&quot;exists&quot;메소드는 종종 테이블에 행이 있는지 테스트하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">&quot;exists&quot;메소드는 SQL 문을 실행한다는 점에서 &quot;onecolumn&quot;및 &quot;eval&quot;과 유사합니다. 차이점은 &quot;exists&quot;메소드는 SQL 문의 쿼리가 하나 이상의 행을 리턴하면 SQL이 빈 세트를 리턴하면 FALSE 인 부울 값을 항상 리턴한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">&quot;family&quot;테이블은 이전의 &quot;org&quot;테이블과 비슷하지만 각 구성원마다 두 명의 부모가 있습니다. 우리는 가장 오래된 것부터 가장 어린 것까지 Alice의 모든 살아있는 조상을 알고 싶습니다. 일반적인 공통 테이블 표현식 &quot;parent_of&quot;가 먼저 정의됩니다. 그 평범한 CTE는 개인의 모든 부모를 찾는 데 사용될 수있는 견해입니다. 이 일반 CTE는 &quot;ancestor_of_alice&quot;재귀 CTE에서 사용됩니다. 그런 다음 재귀 CTE가 최종 쿼리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">secure_delete의 &quot;fast&quot;설정 (2017-08-01 경에 추가됨)은 &quot;on&quot;과 &quot;off&quot;사이의 중간 설정입니다. secure_delete가 &quot;fast&quot;로 설정되면 SQLite는 I / O의 양을 늘리지 않는 경우에만 삭제 된 내용을 0으로 덮어 씁니다. 즉, &quot;빠른&quot;설정은 더 많은 CPU주기를 사용하지만 더 많은 I / O를 사용하지는 않습니다. 이는 &lt;a href=&quot;fileformat2#btree&quot;&gt;b- 트리 페이지&lt;/a&gt; 에서 모든 오래된 컨텐츠를 제거 하지만 &lt;a href=&quot;fileformat2#freelist&quot;&gt;프리리스트 페이지에는&lt;/a&gt; 법 의학적 흔적을 남기는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">헤더가 WAL 재설정으로 작성된 후 발생하는 &quot;fsync ()&quot;는 이제 체크 포인트에 대한 동기화 설정을 사용합니다. 이는 &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync가&lt;/a&gt; 설정된 경우 Mac에서 &quot;fullfsync&quot;를 사용한다는 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">&quot;fts3tokenize&quot;가상 테이블을 사용하여 모든 토크 나이저에 직접 액세스 할 수 있습니다. 다음 SQL은 fts3tokenize 가상 테이블의 인스턴스를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">&quot;풀키&quot;열은 원래 JSON 문자열 내에서 현재 행 요소를 고유하게 식별하는 텍스트 경로입니다. &quot;루트&quot;인수로 대체 시작점이 제공 되더라도 실제 최상위 레벨 요소의 완전한 키가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">&quot;기능&quot;방법</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">&quot;function&quot;메소드는 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">&quot;function&quot;메소드는 새로운 SQL 함수를 SQLite 엔진에 등록합니다. 인수는 새 SQL 함수의 이름과 해당 함수를 구현하는 TCL 명령입니다. 함수에 대한 인수는 TCL 명령이 호출되기 전에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">&quot;fuzzershell.c&quot;프로그램은 일부 &lt;a href=&quot;#fuzztesting&quot;&gt;퍼즈 테스트&lt;/a&gt; 를 실행하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&quot;iScanStatusOp&quot;매개 변수는 반환 할 상태 정보를 결정합니다. &quot;iScanStatusOp&quot;는 &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus 옵션&lt;/a&gt; 중 하나이거나이 인터페이스의 동작이 정의되어 있지 않습니다. 요청 된 측정은 &quot;pOut&quot;매개 변수가 가리키는 변수에 기록됩니다. &quot;idx&quot;매개 변수는 통계를 검색 할 특정 루프를 식별합니다. 루프는 0부터 시작하여 번호가 매겨집니다. idx가 명령문을 구현하는 데 사용 된 총 루프 수보다 크거나 같은 범위를 벗어나면 0이 아닌 값이 리턴되고 pOut이 가리키는 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&quot;iScanStatusOp&quot;매개 변수는 반환 할 상태 정보를 결정합니다. &quot;iScanStatusOp&quot;는 &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus 옵션&lt;/a&gt; 중 하나이거나이 인터페이스의 동작이 정의되어 있지 않습니다. 요청 된 측정은 &quot;pOut&quot;매개 변수가 가리키는 변수에 기록됩니다. &quot;idx&quot;매개 변수는 통계를 검색 할 특정 루프를 식별합니다. 루프는 0부터 시작하여 번호가 매겨집니다. idx가 명령문을 구현하는 데 사용 된 총 루프 수보다 크거나 같은 범위를 벗어나면 0이 아닌 값이 리턴되고 pOut이 가리키는 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">&quot;id&quot;열은 전체 JSON 문자열에서 특정 JSON 요소를 식별하는 정수입니다. &quot;id&quot;정수는 내부 하우스 키핑 번호이며 계산은 향후 릴리스에서 변경 될 수 있습니다. 유일한 보장은 &quot;id&quot;열이 모든 행마다 다르다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">&quot;incrblob&quot;방법</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">&quot;인덱스&quot;또는 준비 영역</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">&quot;입력&quot;CTE는 입력 퍼즐을 정의합니다. &quot;숫자&quot;CTE는 1과 9 사이의 모든 숫자를 보유하는 테이블을 정의합니다. 퍼즐 해결 작업은 &quot;x&quot;CTE에 의해 수행됩니다. x (s, ind)의 항목은 81 자 문자열 &quot;s&quot;가 유효한 스도쿠 퍼즐 (충돌이 없음)이고 첫 번째 알 수없는 문자가 &quot;ind&quot;위치에 있거나 ind == 0 인 경우를 의미합니다. 문자 위치가 채워집니다. 그런 다음 목표는 &quot;ind&quot;가 0 인 &quot;x&quot;에 대한 항목을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프에 대해 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 값과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프에 대해 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 값과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프의 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 것과 동일한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프의 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 것과 동일한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">&quot;integrity-check&quot;명령은 SQLite가 반전 된 인덱스를 원본 컨텐츠와 비교하여 FTS3 / 4 테이블의 모든 반전 된 인덱스의 정확성을 읽고 확인하도록합니다. &quot;integrity-check&quot;명령은 반전 된 인덱스가 모두 정상이면 자동으로 성공하지만 문제점이 발견되면 SQLITE_CORRUPT 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">&quot;integrity-check&quot;명령은 개념적으로 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 와 유사 합니다 . 작업 시스템에서 &quot;integrity-command&quot;는 항상 성공해야합니다. 무결성 검사 실패의 가능한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">&quot;인터럽트&quot;방법</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">&quot;interrupt&quot;메소드는 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 인터페이스를 호출하여 보류중인 쿼리를 중지시킵니다.</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">&quot;isInit&quot;플래그 shm 파일이 초기화 된 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">데이터베이스의 &quot;격리&quot;속성은 한 작업에 의한 데이터베이스 변경 사항이 다른 동시 작업에 표시되는 시점을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">&quot;키&quot;열은 JSON 배열 요소의 정수 배열 색인이고 JSON 오브젝트 요소의 텍스트 레이블입니다. 다른 모든 경우에는 키 열이 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">&quot;last_insert_rowid&quot;메소드</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">&quot;last_insert_rowid&quot;메소드는 가장 최근에 삽입 된 데이터베이스 행의 ROWID 인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">&quot;localtime&quot;수정 자 (12)는 왼쪽의 시간 문자열이 UTC (Universal Coordinated Time)에 있다고 가정하고 현지 시간을 표시하도록 시간 문자열을 조정합니다. &quot;localtime&quot;이 UTC가 아닌 시간을 따르는 경우 동작이 정의되지 않습니다. &quot;utc&quot;수정자는 &quot;localtime&quot;과 반대입니다. &quot;utc&quot;는 왼쪽에있는 문자열이 현지 시간대에 있다고 가정하고 해당 문자열을 UTC로 조정합니다. 이전 문자열이 현지 시간이 아닌 경우 &quot;utc&quot;의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">&quot;lost_and_found&quot;테이블에는 데이터베이스에서 복구 된 각 고아 행마다 하나의 행이 있습니다. 또한 복구 된 각 인덱스 항목마다 하나의 행이있어 SQL 인덱스에 기인 할 수 없습니다. 이는 SQLite 데이터베이스에서 동일한 형식이 SQL 인덱스 항목과 WITHOUT ROWID 테이블 항목을 저장하는 데 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">dbstat의 &quot;main&quot;인수는 정보를 제공 할 기본 스키마입니다. 기본값은 &quot;main&quot;이므로 위 예에서 &quot;main&quot;은 중복됩니다. 특정 쿼리의 경우 대체 스키마를 쿼리의 FROM 절에서 가상 테이블 이름에 대한 함수 인수로 지정하여 스키마를 변경할 수 있습니다. (자세한 내용 &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;은 FROM 절의 테이블 반환 함수에&lt;/a&gt; 대한 자세한 설명을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">&quot;make&quot;유틸리티 또는 Windows의 경우 선택적으로 &quot;nmake&quot;</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">&quot;matchinfo = fts3&quot;옵션을 사용할 수 없습니다. &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;ColumnSize가 = 0&quot;&lt;/a&gt; 옵션은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">&quot;병합&quot;명령은 원 (1)과 (4) 사이의 모든 변경 사항을 로컬 체크 아웃의 파일에 적용하려고합니다. 서클 (5)은 아직 생성되지 않았습니다. 서클 (5)을 만들려면 &quot;커밋&quot;을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">&quot;merge = X, Y&quot;명령 (여기서 X 및 Y는 정수)은 SQLite가 FTS3 / 4 테이블의 다양한 반전 인덱스 b- 트리를 하나의 큰 b- 트리로 병합하기 위해 제한된 양의 작업을 수행하게합니다. X 값은 병합 할 &quot;블록&quot;의 대상 수이고 Y는 병합이 해당 수준에 적용되기 전에 필요한 수준의 최소 b- 트리 세그먼트 수입니다. Y 값은 권장 값 8을 사용하여 2와 16 사이 여야합니다. X 값은 양의 정수일 수 있지만 100-300 정도의 값이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">&quot;missing&quot;매개 변수를 사용 하면 필요한 데이터베이스 파일이 디스크에없는 경우 swarmvtab이 데이터베이스를 열기 직전에 호출 될 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 이를 통해 응용 프로그램은 swarmvtab에서 데이터베이스를 열기 전에 원격 소스에서 필요한 데이터베이스를 검색 할 수 있습니다. &quot;누락 된&quot;함수에 전달되는 유일한 인수는 열려있는 데이터베이스를 식별하는 이름 또는 URI입니다. 가정 :</target>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">&quot;missing&quot;매개 변수를 사용 하면 필요한 데이터베이스 파일이 디스크에없는 경우 swarmvtab에서 데이터베이스를 열기 직전에 호출 될 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 이를 통해 swarmvtab에서 데이터베이스를 열려고 시도하기 전에 원격 소스에서 필요한 데이터베이스를 검색 할 수 있습니다. &quot;missing&quot;함수에 전달 된 유일한 인수는 열려는 데이터베이스를 식별하는 이름 또는 URI입니다. 가정 :</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">&quot;mmap_size&quot;는 SQLite가 한 번에 프로세스 주소 공간에 맵핑하려고 시도하는 데이터베이스 파일의 최대 바이트 수입니다. mmap_size는 각 데이터베이스 파일에 개별적으로 적용되므로 잠재적으로 사용될 수있는 총 프로세스 주소 공간은 mmap_size와 열린 데이터베이스 파일 수의 곱입니다.</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">&quot;mptester.c&quot;프로그램은 단일 데이터베이스를 동시에 읽고 쓰는 여러 프로세스에 대한 스트레스 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">&quot;널값&quot;방법</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">&quot;널값&quot;메소드는 &quot;eval&quot;메소드의 결과로 리턴 된 NULL의 표시를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">&quot;nullvalue&quot;방법은 Tcl에 NULL 표현이 없기 때문에 NULL과 빈 열 값을 다르게하는 데 유용합니다. NULL 값의 기본 표현은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">&quot;onecolumn&quot;방법</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">&quot;onecolumn&quot;메소드 는 인수로 제공된 SQL 쿼리 문을 평가한다는 점에서 &quot; &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; &quot; 과 같이 작동합니다 . 차이점은 &quot;onecolumn&quot;은 쿼리 결과의 첫 번째 행의 첫 번째 열인 단일 요소를 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">&quot;onoff&quot;매개 변수는 메모리 통계 추적을 사용하려면 true이고 통계 추적을 사용하지 않으려면 false입니다.</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&quot;openclose&quot;매개 변수를 사용하면 swarmvtab이 데이터베이스를 열기 직전과 데이터베이스를 닫은 직후에 다시 호출 될 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 열기 닫기 함수에 전달 된 첫 번째 인수는 열거 나 최근에 닫을 데이터베이스를 식별하는 파일 이름 또는 URI입니다 (CREATE VIRTUAL TABLE 명령에 제공된 SQL 문의 맨 왼쪽 열에 반환 된 동일한 값). 두 번째 인수는 데이터베이스를 열기 전에 함수가 호출 될 때 정수 값 0이고, 하나가 닫힌 후 호출 될 때 1입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&quot;openclose&quot;매개 변수를 통해 사용자 는 swarmvtab이 데이터베이스를 열기 직전에, 그리고 데이터베이스를 닫은 직후에 호출 될 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. open close 함수에 전달 된 첫 번째 인수는 열거 나 최근에 닫을 데이터베이스를 식별하는 파일 이름 또는 URI입니다 (CREATE VIRTUAL TABLE 명령에 제공된 SQL 문의 가장 왼쪽 열에 리턴 된 것과 동일한 값). 두 번째 인수는 데이터베이스를 열기 전에 함수를 호출 할 때 정수 값 0이고, 하나를 닫은 후 호출 될 때 1입니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">&quot;optimize&quot;명령은 FTS3 / 4가 모든 거꾸로 된 인덱스 b- 트리를 하나의 크고 완전한 b- 트리로 병합하도록합니다. 최적화를 수행하면 검색 할 b- 트리가 적기 때문에 후속 쿼리 실행 속도가 빨라지고 중복 항목을 병합하여 디스크 사용량이 줄어들 수 있습니다. 그러나 큰 FTS 테이블의 경우 최적화 실행은 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 실행만큼 비쌀 수 있습니다 . optimize 명령은 본질적으로 전체 FTS 테이블을 읽고 써야하므로 큰 트랜잭션이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">&quot;order&quot;옵션은 &quot;DESC&quot;또는 &quot;ASC&quot;(대문자 또는 소문자)로 설정 될 수 있습니다. &quot;DESC&quot;로 설정된 경우 FTS4는 반환 결과를 docid로 내림차순으로 최적화하는 방식으로 데이터를 저장합니다. &quot;ASC&quot;(기본값)로 설정된 경우 데이터 구조는 결과를 오름차순으로 docid로 반환하도록 최적화됩니다. 다시 말해, FTS4 테이블에 대해 실행되는 많은 쿼리가 &quot;ORDER BY docid DESC&quot;를 사용하는 경우 &quot;order = desc&quot;옵션을 CREATE VIRTUAL TABLE 문에 추가하는 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">&quot;pBuf&quot;매개 변수는 lookaside 메모리 풀에 사용될 메모리 공간에 대한 포인터입니다. pBuf가 NULL이면 SQLite는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 메모리 풀을위한 자체 공간을 확보합니다 . &quot;sz&quot;및 &quot;cnt&quot;매개 변수는 각 lookaside 슬롯의 크기와 슬롯 수입니다. pBuf가 NULL이 아닌 경우 최소 sz * cnt 바이트의 메모리를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">json_each ()의 &quot;부모&quot;열은 항상 NULL입니다. json_tree ()의 경우, &quot;parent&quot;열은 현재 요소의 부모에 대한 &quot;id&quot;정수이거나 최상위 JSON 요소 또는 두 번째 인수에서 루트 경로로 식별되는 요소에 대해서는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">&quot;경로&quot;열은 btree 구조의 루트 노드에서 각 페이지로가는 경로를 설명합니다. 루트 노드 자체의 &quot;경로&quot;는 '/'입니다. btree 페이지 루트의 가장 왼쪽에있는 하위 페이지의 &quot;경로&quot;는 '/ 000 /'입니다. (트리에는 왼쪽에서 오른쪽으로 정렬 된 내용이 저장되므로 왼쪽에있는 페이지는 오른쪽에있는 페이지보다 작은 키를 갖습니다.) 루트 페이지의 가장 왼쪽에있는 하위 옆에있는 '/ 001'은 각 형제 페이지입니다. 3 자리 16 진수 값으로 식별됩니다. 가장 왼쪽의 451 번째 형제의 자식에는 '/ 1c2 / 000 /,'/ 1c2 / 001 / '등과 같은 경로가 있습니다. 오버플로 페이지는 경로에'+ '문자와 6 자리 16 진수 값을 추가하여 지정됩니다. 그들이 연결된 세포에. 예를 들어루트 페이지에서 450 번째 자식 하위의 가장 왼쪽 셀에서 연결된 체인의 3 개의 오버플로 페이지는 경로로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">&quot;경로&quot;열은 btree 구조의 루트 노드에서 각 페이지로 가져온 경로를 설명합니다. 루트 노드 자체의 &quot;경로&quot;는 '/'입니다. &quot;aggregate&quot;가 TRUE 인 경우 &quot;path&quot;는 NULL입니다. btree 페이지 루트의 맨 왼쪽 자식 페이지에 대한 &quot;경로&quot;는 '/ 000 /'입니다. (Btree는 콘텐츠를 왼쪽에서 오른쪽으로 정렬하여 저장하므로 왼쪽 페이지는 오른쪽 페이지보다 작은 키를 갖습니다.) 루트 페이지의 맨 왼쪽 자식 옆은 '/ 001'이고 각 형제 페이지는 계속됩니다. 3 자리 16 진수 값으로 식별됩니다. 451 번째 가장 왼쪽 형제의 자식에는 '/ 1c2 / 000 /,'/ 1c2 / 001 / '등과 같은 경로가 있습니다. 오버플로 페이지는 경로에'+ '문자와 6 자리 16 진수 값을 추가하여 지정됩니다. 연결된 셀에. 예를 들면루트 페이지의 450 번째 자식의 가장 왼쪽 셀에서 링크 된 체인의 세 오버플로 페이지는 경로로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">&quot;경로&quot;열은 현재 행을 보유하는 배열 또는 객체 컨테이너의 경로이거나, 기본 유형에서 반복이 시작되어 단일 행의 출력 만 제공하는 경우 현재 행의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 에 대한 마지막 매개 변수의 &quot;포인터 유형&quot;은 한 확장에 대한 포인터가 다른 확장으로 리디렉션되지 않도록하는 데 사용됩니다. 예를 들어, 포인터 유형을 사용하지 않아도 공격자는 여전히 &lt;a href=&quot;fts3&quot;&gt;다음&lt;/a&gt; 과 같은 SQL을 사용하여 FTS3 및 &lt;a href=&quot;carray&quot;&gt;CARRAY 확장&lt;/a&gt; 을 모두 포함하는 시스템의 포인터 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">각 포인터 전달 인터페이스에 대한 마지막 매개 변수 인 &quot;포인터 유형&quot;문자열은 API 호출에 직접 나타나는 고유 한 응용 프로그램 특정 문자열 리터럴이어야합니다. 포인터 유형은 상위 수준 함수에서 전달 된 매개 변수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">&quot;접두사&quot;옵션 은 FTS5 테이블에 &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;접두사 색인&lt;/a&gt; 을 추가하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">&quot;캘리포니아 오렌지의 가격&quot;쿼리는 2 열 인덱스를 사용하여보다 효율적으로 이루어졌습니다. 그러나 SQLite는 &quot;price&quot;열을 포함하는 3 열 인덱스를 사용하여 더 잘 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">&quot;프로파일&quot;방법</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">&quot;진보&quot;방법</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="translated">&quot;따옴표&quot;출력 모드는 &quot;.separator&quot;를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">&quot;rbu_control&quot;열은 INSERT에 대해 정수 값 2로 설정 될 수도 있습니다. 이 경우 새 행은 기본 키 값이 동일한 기존 행을 자동으로 바꿉니다. 이는 동일한 기본 키 값을 가진 INSERT 뒤에 DELETE와 같습니다. 새 행이 충돌하는 기본 키가있는 행뿐만 아니라 충돌하는 행 (즉, UNIQUE 제한 조건 또는 인덱스로 인해 충돌하는 행)을 대체 할 수 있으므로 SQL REPLACE 명령과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">&quot;rebuild&quot;명령은 SQLite가 전체 FTS3 / 4 테이블을 버린 다음 원래 텍스트에서 다시 작성합니다. 이 개념은 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 와 유사하지만 일반 색인 대신 FTS3 / 4 테이블에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">모든 콘텐츠를 다시 토큰화할 수 있도록 사용자 정의 토크 나이저의 구현이 변경 될 때마다 &quot;재 구축&quot;명령을 실행해야합니다. &quot;재 구축&quot;명령은 원본 컨텐츠 테이블을 변경 한 후 &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 컨텐츠 옵션&lt;/a&gt; 을 사용할 때도 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">&quot;복원&quot;방법</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">&quot;복원&quot;방법은 별도의 데이터베이스 파일에서 현재 데이터베이스 연결로 내용을 복사하여 기존의 내용을 덮어 씁니다. 명령 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">&quot;rollback_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">비교를위한 &quot;점수&quot;는 패턴과 단어 사이의 편집 거리이며 단어 순위의 밑이 2 인 로그에 의해 조정됩니다. 예를 들어, 거리가 100이지만 순위가 1000 인 일치의 점수는 122 (= 100-log2 (1000) + 32)이며, 거리가 100 인 일치하는 순위는 131 (100-log2 ( 1) + 32). (NB : 편집 거리가 0 인 경우 음수가되지 않도록 상수 32가 각 점수에 추가됩니다.) 이런 방식으로 자주 사용되는 단어는 약간 더 낮은 비용을 가져서 목록의 맨 위로 이동합니다. 대체 철자.</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">&quot;직렬화&quot;방법</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">&quot;직렬화&quot;메소드는 기본 데이터베이스의 전체 사본 인 BLOB를 작성합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">행 값의 &quot;크기&quot;는 행 값에 포함 된 스칼라 값의 수입니다. 행 값의 크기는 항상 2 이상입니다. 단일 열이있는 행 값은 스칼라 값입니다. 열이없는 행 값은 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">&quot;speedtest1.c&quot;프로그램은 일반적인 워크로드에서 SQLite의 성능을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">&quot;spellfix1&quot;용어는 spellfix 모듈의 이름이며 표시된대로 입력해야합니다. &quot;데모&quot;용어는 생성 할 가상 테이블의 이름이며 응용 프로그램의 요구에 맞게 변경할 수 있습니다. 가상 테이블은 처음에 비어 있습니다. 가상 테이블을 유용하게 사용하려면 가상 테이블을 어휘로 채워야합니다. &quot;big_vocabulary&quot;라는 테이블에 단어 목록이 있다고 가정하십시오. 그런 다음이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">&quot;sqlite3.c&quot;코드 파일에는 VFS 및 Unix, Windows 및 OS / 2에 적합한 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 함수 의 기본 구현이 포함되어 있습니다 . sqlite3.c를 컴파일 할 때 이러한 기본 구성 요소 중 하나가로드되지 않도록하려면 다음 컴파일 타임 옵션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">&quot;sqlite3.c&quot;make 대상은 일반 &quot; &lt;b&gt;sqlite3.c&lt;/b&gt; &quot;합병 소스 파일, 헤더 파일 &quot; &lt;b&gt;sqlite3.h&lt;/b&gt; &quot;및 TCL 인터페이스를 포함하는 &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot;합병 소스 파일을 자동으로 구성합니다 . 그런 다음 필요한 파일을 프로젝트 디렉토리에 복사하고 위에서 설명한 절차에 따라 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">SQLite 소스 트리에서 소스 코드로 또는 &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite 다운로드 페이지&lt;/a&gt; 에서 사전 컴파일 된 바이너리로 사용 가능한 &quot;sqlite3_analyzer.exe&quot;유틸리티 프로그램을 사용 하여 기존 SQLite 데이터베이스에서 테이블 행의 평균 크기를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">&quot;시작 일치&quot;텍스트</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">&quot;시작&quot;수정 자 (7-9)는 날짜를 현재 월, 연도 또는 일의 시작으로 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">&quot;state&quot;인덱스는 rowid 앞에 여분의 열이 있고 새로운 키를 기본 키로 정렬한다는 점에서 &quot;fruit&quot;인덱스와 동일하게 작동합니다. 유일한 차이점은 Idx2에서 첫 번째 열은 Idx1에서와 같이 &quot;fruit&quot;대신 &quot;state&quot;라는 것입니다. 이 예제 데이터 세트에서 &quot;상태&quot;열에는 중복성이 더 많으므로 중복 항목이 더 많습니다. 관계는 여전히 rowid를 사용하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">&quot;상태&quot;방법</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">&quot;swarmvtab&quot;가상 테이블을 사용하면 사용자는 유사한 스키마를 갖지만 단일 범위의 rowid 값을 단일 데이터베이스 테이블 인 것처럼 많은 수의 테이블 (이하 &quot;구성 요소&quot;테이블)을 쿼리 할 수 ​​있습니다. 테이블은 다른 데이터베이스에있을 수 있습니다. Swarmvtab 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">&quot;sz&quot;매개 변수는 각 lookaside 슬롯의 크기 (바이트)입니다. &quot;cnt&quot;매개 변수는 데이터베이스 연결 당 총 lookaside 메모리 슬롯 수입니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 할당 된 lookaside 메모리의 총량 은 sz * cnt 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">&quot;sz = NNN&quot;인수 (NNN은 1 자리 이상의 시퀀스를 나타냄)는 테이블 또는 인덱스의 모든 레코드에 대한 평균 행 크기가 행당 NNN 바이트임을 의미합니다. SQLite 쿼리 플래너는 &quot;sz = NNN&quot;토큰이 제공하는 예상 행 크기 정보를 사용하여 디스크 I / O가 덜 필요한 더 작은 테이블과 인덱스를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">&quot;temp&quot;데이터베이스 (TEMP 테이블 및 인덱스가 저장 됨) 및 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스는&lt;/a&gt; 항상 독점 잠금 모드를 사용합니다. 임시 및 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 잠금 모드는 변경할 수 없습니다. 다른 모든 데이터베이스는 기본적으로 일반 잠금 모드를 사용하며이 pragma의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">위에서 만든 &quot;test1.dir&quot;디렉토리는 모든 얼룩을 단일 폴더에 넣습니다. 단일 디렉토리에 100,000 개의 오브젝트가있는 경우 일부 운영 체제의 성능이 저하 될 것이라고 추측했습니다. 이를 테스트하기 위해 kvtest 프로그램은 폴더 당 파일 및 / 또는 하위 디렉토리가 100 개 이하인 폴더 계층 구조에 블롭을 저장할 수도 있습니다. 다음과 같이 --tree 명령 행 옵션을 사용하여 &quot;export&quot;명령에 대한 블랍의 대체 디스크 상 표현을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">&quot;th3&quot;바이너리가 실행되고 출력에 오류가 있는지 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">&quot;threadtest3.c&quot;프로그램은 SQLite를 동시에 사용하는 여러 스레드에 대한 스트레스 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">&quot;세&quot;열-버킷의 열쇠</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">&quot;타임 아웃&quot;방법</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">&quot;timeout&quot;메소드는 데이터베이스 트랜잭션을 포기하기 전에 SQLite 라이브러리가 잠금이 해제 될 때까지 대기하는 시간을 제어하는 ​​데 사용됩니다. 기본 시간 초과는 0 밀리 초입니다. 즉, 기본 동작은 전혀 기다리지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">&quot;토큰 화&quot;옵션은 &lt;a href=&quot;fts5#tokenizers&quot;&gt;사용자 정의 토크 나이저&lt;/a&gt; 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">&quot;total_changes&quot;메소드</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">&quot;total_changes&quot;메소드는 현재 데이터베이스 연결이 처음 열린 이후 데이터베이스에서 삽입, 삭제 및 / 또는 수정 된 행 수인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">&quot;추적&quot;방법</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">&quot;trace&quot;메소드는 각 SQL 문이 컴파일 될 때 호출되는 콜백을 등록합니다. SQL 텍스트는 호출되기 전에 명령에 단일 문자열로 추가됩니다. 예를 들어 응용 프로그램이 수행하는 모든 SQL 작업의 로그를 유지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">&quot;trace_v2&quot;메소드</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">&quot;trace_v2&quot;메소드는 각 SQL 문이 컴파일 될 때 호출되는 콜백을 등록합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">&quot;트랜잭션&quot;방법</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">&quot;트랜잭션&quot;메소드는 SQLite 데이터베이스 트랜잭션 내에서 TCL 스크립트를 실행하는 데 사용됩니다. 스크립트가 완료되면 트랜잭션이 커밋되거나 스크립트가 실패하면 롤백됩니다. 트랜잭션이 다른 트랜잭션 (BEGIN을 사용하여 수동으로 시작된 트랜잭션) 내에서 발생하는 경우 트랜잭션이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">&quot;type&quot;열은 유형에 따라 ( 'null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object')에서 가져온 SQL 텍스트 값입니다. 현재 JSON 요소</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">&quot;일반적인&quot;워크로드는 표준 SQLite 소스 트리 의 &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; 프로그램에 의해 생성됩니다 . 이 프로그램은 실제 응용 프로그램에서 일반적인 방식으로 SQLite 라이브러리를 실행하려고합니다. 물론 모든 응용 프로그램이 다르므로 테스트 응용 프로그램이 모든 응용 프로그램의 동작을 정확하게 반영 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">&quot;ui&quot;명령은 화석이 소형 내장 웹 서버를 실행하고 해당 웹 서버를 가리키는 웹 브라우저를 시작하게합니다. 웹 브라우저를 사용하여 다양한 방법으로 프로젝트를 구성 할 수 있습니다. 추가 정보는 화석 웹 사이트의 지침을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">&quot;unicode61&quot;토크 나이 저는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;버전 3.7.13&lt;/a&gt; (2012-06-11) 부터 사용할 수 있습니다 . Unicode61은 유니 코드 버전 6.1의 규칙에 따라 간단한 유니 코드 케이스 접기를 수행하고 유니 코드 공간과 문장 부호 문자를 인식하고이를 토큰을 분리하는 데 사용한다는 점을 제외하고는 &quot;단순&quot;과 매우 유사합니다. 간단한 토크 나이 저는 ASCII 문자를 접는 경우에만 ASCII 공백과 문장 부호 문자를 토큰 구분 기호로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">&quot;unixepoch&quot;수정 자 (11)는 DDDDDDDDDD 형식의 시간 문자열 바로 뒤에 오는 경우에만 작동합니다. 이 수정자를 사용하면 DDDDDDDDDDDD가 일반적으로 줄리안 일수로 해석되지 않고 1970 년 이후의 초 수인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;유닉스 시간&lt;/a&gt; 으로 해석됩니다 . &quot;unixepoch&quot;수정자가 DDDDDDDDDD 형식의 시간 문자열을 따르지 않는 경우 1970 년 이후의 시간 (초) 또는 다른 수정자가 &quot;unixepoch&quot;수정자를 이전 DDDDDDDDDD와 분리하면 동작이 정의되지 않습니다. 3.16.0 (2017-01-02) 이전의 SQLite 버전의 경우 &quot;unixepoch&quot;수정자는 0000-01-01 00:00:00에서 5352-11-01 10:52:47 사이의 날짜에 대해서만 작동합니다. -62167219200부터 106751991167까지).</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">&quot;unlock_notify&quot;메소드</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">&quot;update_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">데이터베이스 페이지의 &quot;사용 가능한 크기&quot;는 헤더의 오프셋 20에서 1 바이트 정수로 기록 된 &quot;예약 된&quot;공간 크기보다 헤더의 오프셋 16에서 2 바이트 정수로 지정된 페이지 크기입니다. 사용 가능한 페이지 크기는 홀수 일 수 있습니다. 그러나 사용 가능한 크기는 480보다 작을 수 없습니다. 즉, 페이지 크기가 512 인 경우 예약 된 공간 크기는 32를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">바이 읽기와 세트로 &quot;사용자 버전&quot; &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version 프라그&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">&quot;verb&quot;인수는 액세스 할 통계를 결정합니다. 있습니다 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;다양한 동사&lt;/a&gt; 정의는. &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스가 성숙함에 따라 목록이 커질 것으로 예상됩니다 . 선택한 매개 변수의 현재 값은 정수 &quot;current&quot;에 기록되고 가장 높은 히스토리 값은 정수 &quot;highwater&quot;에 기록됩니다. resetflag가 true이면 통화가 반환 된 후 최고 사용 표시 점이 현재 값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">&quot;버전&quot;방법</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">&quot;wal_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">&quot;평일&quot;수정자는 필요한 경우, 요일 번호가 N 인 다음 날짜로 날짜를 앞으로 이동합니다. 일요일은 0, 월요일은 1 등입니다. 날짜가 원하는 요일에 이미 있으면 &quot;요일&quot;수정자가 날짜를 변경하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nExtCode 확장 결과 코드는 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h에 정의되며&lt;/a&gt; 아래에 알파벳 순서로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nPrimCode 결과 코드는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h에 정의&lt;/a&gt; 되어 있으며 알파벳 순서로 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">$ prefix 매개 변수는 NULL 일 수 있으며이 경우 접두어는 $ wholeline에서 추론됩니다. 또는 컨텍스트 정보를 사용할 수 없거나 컨텍스트 인식 완료를 원하지 않는 경우 $ wholeline 매개 변수는 NULL이거나 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">% _content 테이블에는 사용자가 사용자가 FTS 가상 테이블에 삽입 한 성인 데이터가 포함되어 있습니다. 레코드를 삽입 할 때 사용자가 &quot;docid&quot;값을 명시 적으로 제공하지 않으면 시스템에서 자동으로 값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">% _stat 및 % _docsize 테이블은 FTS 테이블이 FTS3이 아닌 FTS4 모듈을 사용하는 경우에만 작성됩니다. 또한 CREATE VIRTUAL TABLE 문의 일부로 지정된 &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo = fts3&quot;&lt;/a&gt; 지시문으로 FTS4 테이블을 작성하면 % _docsize 테이블이 생략됩니다 . 이들이 작성되면 두 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">% q 및 % Q 대체는 SQLite 개선 사항으로, 대부분의 다른 printf () 구현에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">% s 대체는 보편적이지만 % z 대체는 SQLite 향상으로 다른 printf () 구현에서는 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">% w 대체는 SQLite의 향상된 기능으로 대부분의 다른 printf () 구현에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">'%'문자는 C, Java 및 Javascript와 같은 프로그래밍 언어와 마찬가지로 모듈러스 연산자를 나타 내기 위해 요구 사항 H35300에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">'crisismerge'옵션은 전체 텍스트 인덱스를 구성하는 구성 요소 b- 트리가 병합되는 방식과 빈도를 결정한다는 점에서 'automerge'와 유사합니다. 존재하면</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">* x * 열의 * + * 연산자는 해당 용어가 인덱스를 제한하지 않도록합니다. 이렇게하면 ex2i2 인덱스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater 매개 변수는 가장 깊은 구문 분석기 스택을 기록합니다. * pCurrent 값은 정의되어 있지 않습니다. * pHighwater 값은 SQLite가 &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; 로 컴파일 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater 매개 변수는 가장 깊은 구문 분석기 스택을 기록합니다. * pCurrent 값은 정의되어 있지 않습니다. * pHighwater 값은 SQLite가 &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; 로 컴파일 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">데이터베이스 읽기 테스트의 --blob-api 옵션을 사용하면 kvtest 는 SQLite 의 &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 기능 을 사용하여 순수한 SQL 문을 실행하지 않고 Blob의 컨텐츠를로드합니다. 이를 통해 SQLite가 읽기 테스트에서 약간 더 빠르게 실행될 수 있습니다. SQL 문을 실행하는 SQLite의 성능을 비교하기 위해이 옵션을 생략 할 수 있습니다. 이 경우, &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()를&lt;/a&gt; 사용할 때만 큼 SQLite는 여전히 직접 읽기보다 성능이 뛰어납니다 . 개별 디스크 파일에서 읽는 테스트의 경우 --blob-api 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">새 데이터베이스를 여는 데 관련된 --deserialize 옵션을 사용하면 데이터베이스 파일을 메모리로 읽고 &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; API를 사용하여 액세스 할 수 있습니다 . 이렇게하면 디스크의 파일을 수정하지 않고도 데이터베이스에서 테스트를 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">--primarykey 플래그는 스키마 선언 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 가 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 가있는 테이블에서도 항상 페어링에 사용 되도록 페어링 알고리즘을 약간 변경합니다 . 이것은 차이를 찾기 위해 종종 더 나은 선택이지만, 하나 이상의 PRIMARY KEY 열이 NULL로 설정된 행의 경우에는 차이를 놓칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">--update 및 --insert 명령은 시작하기 전에 현재 아카이브를 삭제하지 않는다는 점을 제외하고 --create 명령과 동일하게 작동합니다. 새 버전의 파일은 기존 파일을 동일한 이름으로 자동으로 바꾸지 만 아카이브의 초기 내용 (있는 경우)은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">동적로드, &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스 및 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 를 지원하려면 -ldl 라이브러리가 필요 합니다 . 이러한 기능이 필요하지 않은 경우 &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; 컴파일 타임 옵션을 사용하여 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">.selftest 명령은 selftest.tno 순서로 selftest 테이블의 행을 읽습니다. 각 'memo'행에 대해 'cmd'의 텍스트를 출력에 씁니다. 각 '실행'행에 대해 'cmd'텍스트를 SQL로 실행하고 결과를 'ans'의 값과 비교하고 결과가 다른 경우 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">100 바이트 데이터베이스 파일 헤더 (1 페이지에만 있음)</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">100 바이트 데이터베이스 파일 헤더는 항상 테이블 b- 트리 페이지 인 1 페이지에만 있습니다. 데이터베이스 파일의 다른 모든 b- 트리 페이지는이 100 바이트 헤더를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">위의 12 단계 &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;일반 ALTER TABLE 프로시 저는&lt;/a&gt; 스키마 변경으로 인해 테이블에 저장된 정보가 변경 되더라도 작동합니다. 따라서 위의 전체 12 단계 절차는 열 삭제, 열 순서 변경, UNIQUE 제약 조건 또는 기본 키 추가 또는 제거, CHECK 또는 FOREIGN KEY 또는 NOT NULL 제약 조건 추가 또는 열의 데이터 유형 변경에 적합합니다. 예. 그러나 디스크 내용에 영향을 미치지 않는 일부 변경 사항에는 더 간단하고 빠른 절차를 선택적으로 사용할 수 있습니다. 다음의 간단한 절차는 CHECK 또는 FOREIGN KEY 또는 NOT NULL 제약 조건을 제거하거나 열의 기본값을 추가, 제거 또는 변경하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="2e3276be673e6a294c05cbdaa0d3884fdd5a279f" translate="yes" xml:space="preserve">
          <source>The 1st parameter, &lt;b&gt;context&lt;/b&gt;, is a pointer to an opaque object that describes the content from which the SQL function was invoked. This context point becomes the first parameter to many other routines that the function implement might to invoke, including:</source>
          <target state="translated">첫 번째 매개 변수 인 &lt;b&gt;context&lt;/b&gt; 는 SQL 함수가 호출 된 내용을 설명하는 불투명 한 객체에 대한 포인터입니다. 이 컨텍스트 지점은 다음을 포함하여 함수 구현이 호출 할 수있는 다른 많은 루틴에 대한 첫 번째 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="2e86ab7971614c6f24df9cffe9f9872849aa09c9" translate="yes" xml:space="preserve">
          <source>The 2nd and 3rd arguments to the scalar SQL function implemenetation, &lt;b&gt;argc&lt;/b&gt; and &lt;b&gt;argv&lt;/b&gt;, are the number of arguments to the SQL function itself and the values for each argument of the SQL function. Argument values can be of any datatype and are thus stored in instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. Specific C-language values can be extracted from this object using the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value() family of interfaces&lt;/a&gt;.</source>
          <target state="translated">스칼라 SQL 함수 구현에 대한 두 번째 및 세 번째 인수 인 &lt;b&gt;argc&lt;/b&gt; 및 &lt;b&gt;argv&lt;/b&gt; 는 SQL 함수 자체에 대한 인수의 수와 SQL 함수의 각 인수에 대한 값입니다. 인수 값은 모든 데이터 유형이 될 수 있으므로 &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; 객체의 인스턴스에 저장됩니다 . &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value () 인터페이스 제품군을&lt;/a&gt; 사용하여이 객체에서 특정 C 언어 값을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec () 콜백 함수의 두 번째 인수는 결과의 열 수입니다. sqlite3_exec () 콜백에 제 3 인자에서 얻어진 것처럼 스트링 포인터 배열이다 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , 각 열에 하나. 결과 행의 요소가 NULL 인 경우 sqlite3_exec () 콜백에 해당하는 문자열 포인터는 NULL 포인터입니다. sqlite3_exec () 콜백에 대한 네 번째 인수는 문자열에 대한 포인터 배열이며, 각 항목은 &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 에서 얻은 해당 결과 열의 이름을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec () 콜백 함수의 두 번째 인수는 결과의 열 수입니다. sqlite3_exec () 콜백에 제 3 인자에서 얻어진 것처럼 스트링 포인터 배열이다 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , 각 열에 하나. 결과 행의 요소가 NULL 인 경우 sqlite3_exec () 콜백에 해당하는 문자열 포인터는 NULL 포인터입니다. sqlite3_exec () 콜백에 대한 네 번째 인수는 문자열에 대한 포인터 배열이며, 각 항목은 &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 에서 얻은 해당 결과 열의 이름을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">31 개의 결과 코드는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h&lt;/a&gt; 에 정의되어 있으며 아래에 알파벳 순서로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">32 비트 정수 값 P1이 레지스터 P2에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">WAL- 색인 헤더의 오프셋 128에서 부호없는 32 비트 정수를 &quot;nBackfill&quot;이라고합니다. 이 필드는 WAL 파일에서 기본 데이터베이스로 다시 복사 된 프레임 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">오프셋 16에서 32 비트 부호없는 정수 (및 오프셋 64에서 반복됨)는 WAL의 유효한 프레임 수입니다. WAL 프레임은 1부터 시작하여 번호가 매겨 지므로 mxFrame은 WAL에서 마지막으로 유효한 커밋 프레임의 인덱스이기도합니다. 커밋 프레임은 프레임 헤더의 바이트 4에서 7까지 0이 아닌 &quot;데이터베이스 크기&quot;값이 0 인 프레임이며 트랜잭션의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">35 % 수치는 작성자가 쉽게 확보 할 수있는 모든 컴퓨터에서 테스트를 실행 한 결과입니다. 이 기사의 일부 검토 자들은 SQLite가 시스템의 직접 I / O보다 대기 시간이 더 높다고보고합니다. 우리는 아직 그 차이를 이해하지 못합니다. 또한 콜드 파일 시스템 캐시를 사용하여 실험을 수행 할 때 직접 I / O뿐만 아니라 SQLite가 수행하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">내장 SUBSTR () 함수의 세 번째 매개 변수는 이제 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">헤더에 대한 오프셋 28의 4 바이트 빅 엔디안 정수는 데이터베이스 파일의 크기를 페이지에 저장합니다. 이 헤더 내 데이터 크기 크기가 유효하지 않으면 (다음 단락 참조) 데이터베이스 크기는 데이터베이스 파일의 실제 크기를 확인하여 계산됩니다. 이전 버전의 SQLite는 헤더 내 데이터베이스 크기를 무시하고 실제 파일 크기를 독점적으로 사용했습니다. 최신 버전의 SQLite는 사용 가능한 경우 헤더 내 데이터베이스 크기를 사용하지만 헤더 내 데이터베이스 크기가 유효하지 않으면 실제 파일 크기로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">오프셋 56의 4 바이트 빅 엔디안 정수는 데이터베이스에 저장된 모든 텍스트 문자열에 사용되는 인코딩을 결정합니다. 값 1은 UTF-8을 의미합니다. 값 2는 UTF-16le을 의미합니다. 3의 값은 UTF-16be를 의미합니다. 다른 값은 허용되지 않습니다. sqlite3.h 헤더 파일은 텍스트 인코딩을위한 숫자 코드 대신 사용하기 위해 C 프리 프로세서 매크로 SQLITE_UTF8을 1로, SQLITE_UTF16LE를 2로, SQLITE_UTF16BE를 3으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">오프셋 60의 4 바이트 빅 엔디안 정수는 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma에&lt;/a&gt; 의해 설정되고 쿼리되는 사용자 버전입니다 . SQLite에서는 사용자 버전을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">오프셋 68의 4 바이트 빅 엔디안 정수는 &quot;응용 프로그램 ID&quot;이며 &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; 명령으로 데이터베이스를 특정 응용 프로그램에 속하거나 특정 응용 프로그램과 관련된 것으로 식별하기 위해 설정할 수 있습니다 . 응용 프로그램 ID는 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되는 데이터베이스 파일을위한 것입니다 . 응용 프로그램 ID는 &quot;SQLite3 Database&quot;를보고하기보다는 &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1)&lt;/a&gt; 과 같은 유틸리티 에서 특정 파일 형식을 결정하는 데 사용할 수 있습니다 . SQLite 소스 저장소 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; 파일 을 참조하여 지정된 애플리케이션 ID 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">오프셋 96의 4 바이트 빅 엔디안 정수는 가장 최근에 데이터베이스 파일을 수정 한 SQLite 라이브러리 의 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; 값을 저장 합니다. 오프셋 92의 4 바이트 빅 엔디안 정수 는 버전 번호가 저장된 &lt;a href=&quot;fileformat2#chngctr&quot;&gt;변경 카운터&lt;/a&gt; 의 값입니다 . 오프셋 92의 정수는 버전 번호가 유효한 트랜잭션을 나타내며 &quot;버전 유효 번호&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">오프셋 48의 4 바이트 빅 엔디안 부호있는 정수는 데이터베이스 파일의 페이지에서 제안 된 캐시 크기입니다. 가치는 제안 일 뿐이며 SQLite는이를 존중할 의무가 없습니다. 정수의 절대 값이 제안 된 크기로 사용됩니다. 제안 된 캐시 크기는 &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma를&lt;/a&gt; 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53d2cb69bc07058d95cd55a2bf0ace6be99d3312" translate="yes" xml:space="preserve">
          <source>The 4th parameter as more recently be extended with additional flag bits to convey additional information about the function. The additional bits include:</source>
          <target state="translated">4 번째 매개 변수는 최근에 추가 플래그 비트로 확장되어 기능에 대한 추가 정보를 전달합니다. 추가 비트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">61 개의 확장 결과 코드는 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h에 정의되어&lt;/a&gt; 있으며 아래에 알파벳순으로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8 또는 12 바이트 b- 트리 페이지 헤더</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE는&lt;/a&gt; TEMP 데이터베이스 및 일지, 과도 데이터베이스 및 subjournals 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 항상 함께 사용됩니다 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE의&lt;/a&gt; 모두 POSIX 개방 () API의 O_EXCL과 O_CREAT 플래그에 직접적으로 유사하다 플래그입니다. SQLITE_OPEN_CREATE와 함께 사용될 때 SQLITE_OPEN_EXCLUSIVE 플래그는 파일이 항상 작성되어야하며 파일이 이미 존재하는 경우 오류임을 표시하는 데 사용됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h 헤더 의 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C 전 처리기 매크로는 &quot;XYZ&quot;형식의 SQLite 버전 인 문자열 리터럴로 평가합니다. 여기서 X는 주 버전 번호 (항상 SQLite3의 경우 3)이고 Y는 부 버전 번호이고 Z는 릴리스 번호 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C 전처리 값을 갖는 정수 매크로 리졸 (X + Y * 1000000 * 1000 + Z) X, Y 및 Z가 사용되는 동일한 숫자 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . 지정된 SQLite 릴리스에 대한 SQLITE_VERSION_NUMBER도 파생 된 릴리스보다 큽니다. Y는 일정하게 유지되고 Z는 증가하거나 그렇지 않으면 Y는 증가하고 Z는 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="translated">&lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz의&lt;/b&gt;&lt;/a&gt; 엔진은 독점 경찰 테스터입니다. &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLite의&lt;/a&gt; 다른 퍼 저는 SQL 입력 또는 데이터베이스 파일을 변경합니다. Dbsqlfuzz는 SQL과 데이터베이스 파일을 동시에 변경하므로 새로운 오류 상태에 도달 할 수 있습니다. Dbsqlfuzz는 사용자 지정 뮤 테이터와 함께 LLVM 의 &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; 프레임 워크를 사용하여 빌드됩니다 . 236 개의 시드 파일에서 시작하여 dbsqlfuzz 퍼 저는 수천만 개의 돌연변이를 조사하여 각각의 새로운 퍼징 세션의 기초를 형성하는 63493 개의 개별 테스트 케이스를 생성했습니다. Dbsqlfuzz는 SQLite가 악의적 인 SQL 또는 데이터베이스 입력을 통한 공격에 대해 강력 함을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 호출에서 포인터 D &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt (D, S)는&lt;/a&gt; 개방형 데이터베이스 연결과 NULL 포인터하지 특히 필요 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 오브젝트 자체는 부분적으로 쓰레드이다. 여러 스레드가 sqlite3_backup_step ()을 여러 번 동시에 호출 할 수 있습니다. 그러나 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () API는 엄격하게 말하면 스레드 안전하지 않습니다. 다른 스레드가 sqlite3_backup_step ()을 호출하는 것과 동시에 호출되면 유효하지 않은 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 인터페이스와는 내장 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob의&lt;/a&gt; SQL 함수 증분 762 인터페이스를 통해 판독 또는 기록 할 수있는 충전 제로 블롭들을 생성하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스에 호출하여 이전 등록 된 초기화 루틴 X 등록 취소 &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension (X)를&lt;/a&gt; . &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 으로 돌아 간다 (1) 초기화 루틴의 X 성공적으로 등록했다 경우 X 초기화 루틴의 목록에없는했다 경우 0 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) 인터페이스 sqlite3_pcache_methods2 구조체의 인스턴스를 전달하여 다른 페이지의 캐시 구현을 등록 할 수있다. 많은 응용 프로그램에서 SQLite에 의해 할당 된 대부분의 힙 메모리는 페이지 캐시에 사용됩니다. 이 API를 사용하여 사용자 정의 페이지 캐시를 구현하면 애플리케이션이 SQLite가 소비하는 메모리 양, 메모리가 할당 및 해제되는 방식 및 캐시 된 데이터베이스 파일의 부분을 정확히 결정하는 데 사용되는 정책을보다 잘 제어 할 수 있습니다. 얼마나 오래.</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를위한 방법 xFileControl 직접 호출한다 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 두 번째 인수에 의해 식별되는 특정 데이터베이스와 연관된 객체. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 데이터베이스의 경우 &quot;temp&quot;이거나 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 추가 된 데이터베이스의 AS 키워드 뒤에 나타나는 이름입니다 . &quot;main&quot;대신 NULL 포인터를 사용하여 기본 데이터베이스 파일을 참조 할 수 있습니다. 이 루틴에 대한 세 번째 및 네 번째 매개 변수는 xFileControl 메소드의 두 번째 및 세 번째 매개 변수로 직접 전달됩니다. xFileControl 메소드의 리턴 값은이 루틴의 리턴 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하는 T 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 변수는 T 매개 변수가 X 번째 루프가 실행 된 총 횟수로 설정됩니다에 의해 지적했다.</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하기 V 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; V 자 파라미터가 가리키는 변수는 X 번째 루프가 실행 된 총 횟수로 설정한다.</target>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스에 메시지를 기록 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에 의해 설립 &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; 에 옵션 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; . 로깅이 사용 가능한 경우 zFormat 문자열 및 후속 인수는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 와 함께 사용되어 최종 출력 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 뛰어난 (malloc으로 할당하지만 해제) 메모리의 바이트 수. &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 루틴 반환의 최대 값 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 하이 워터 마크 보낸 사람을 마지막으로 재설정 한. 반환하는 값 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()는&lt;/a&gt; 모든 오버 헤드의 구현으로 SQLite는 추가 포함 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 하지만 오버하는 모든 기본 시스템 라이브러리 루틴 추가하지 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; 인터페이스는이 정수 상수들 중 하나 인 하나의 인수를 취하는.</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; 인터페이스, 삽입, 업데이트 또는 삭제되는 행의 열 수를 반환한다.</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; preupdate 콜백이 직접 삽입, 업데이트 또는 삭제 작업의 결과로 호출 된 경우 인터페이스를 반환 0; 또는 최상위 트리거에 의해 호출 된 삽입, 업데이트 또는 삭제의 경우 1; 또는 최상위 트리거에 의해 호출 된 트리거로 인한 변경에 대해서는 2; 기타 등등.</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 전에 각 호출되는 콜백 함수를 등록 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 데이터베이스 테이블에 동작. 단일 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 한 번에 최대 하나의 사전 업데이트 후크를 등록 할 수 있습니다 . &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()에 대한&lt;/a&gt; 각 호출 은 이전 설정보다 우선합니다. 사전 갱신 후크는 두 번째 매개 변수로 널 포인터를 사용하여 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 을 호출하여 사용 불가능합니다 . &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 의 세 번째 매개 변수는 콜백에 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트 된 후 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_INSERT 및 SQLITE_UPDATE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_DELETE 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new ()는&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; 인터페이스는 preupdate 이벤트에 관한 추가 정보를 제공한다. 이러한 루틴은 사전 업데이트 콜백 내에서만 호출 할 수 있습니다. 사전 갱신 콜백 외부에서 또는 사전 갱신 콜백에 제공된 것과 다른 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터를 사용하여 이러한 루틴을 호출하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트되기 전에 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_UPDATE 및 SQLITE_DELETE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_INSERT 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 임의의 값이 변경되지 않는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 온 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 재설정 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문은&lt;/a&gt; 그 프로그램의 시작 부분에 다시 S.</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;권한 부여 콜백 기능&lt;/a&gt; 중 하나를 반환해야 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 작업이 허용되는지 여부를 SQLite는 신호하기 위해 또는이 두 상수 중 하나를. 추가 정보 는 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;권한 부 여자 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스는 특정 SQL 문 작업 권한을 부여하기 위해 호출되는 콜백 함수를 등록합니다. 콜백에 대한 두 번째 매개 변수는 권한이 부여되는 조치를 지정하는 정수 코드입니다. 이것은 권한 부 여자 콜백이 전달 될 수있는 정수 조치 코드입니다.</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 에 성공적으로 호출에서 반환 된 개체 &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;() sqlite3_snapshot_get를&lt;/a&gt; 사용하여 해제해야 &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free을 ()&lt;/a&gt; 메모리 누수를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; 계면을 파괴&lt;a href=&quot;#sqlite3_snapshot&quot;&gt; sqlite3_snapshot&lt;/a&gt; P.이 응용 프로그램은 결국 모든 해제해야합니다 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 메모리 누수를 방지하기 위해이 루틴을 사용하여 객체를.</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; 인터페이스 시도는 새로운 만드는 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 스키마의 현재 상태가 데이터베이스 연결 D.에 성공에 S 기록 것을 객체를의&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt; sqlite3_snapshot_get는 (D, S는 P)&lt;/a&gt; 인터페이스가 새로 생성에 대한 포인터를 기록 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 오브젝트를 * P로 가져오고 SQLITE_OK를 리턴합니다. 이 함수가 호출 될 때 스키마 S에 읽기 트랜잭션이 아직 열려 있지 않으면 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 인터페이스 중 하나는 새로운 읽기 트랜잭션을 시작 또는 스키마 S에 대한 기존의 것을 업그레이드 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 읽기 트랜잭션이 역사를 의미하도록 D &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;스냅 샷&lt;/a&gt; 이 아니라 데이터베이스에 대한 가장 최근의 변화보다, P. &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스 반환 성공 또는 적절한에 SQLITE_OK &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; 방법은 N의 단부에 문자열 S 바이트로부터 정확하게 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; X. N은 음이 아닌 있어야 개체. S는 0이 아닌 0 바이트 이상의 콘텐츠를 포함해야합니다. 0으로 끝나는 문자열을 전체적으로 추가하려면 대신 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall는 (X, S)의&lt;/a&gt; 방법은 결국 제로로 끝나는 문자열 S의 전체 콘텐츠를 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar은 (X는 N, C)&lt;/a&gt; 방법의 마지막에 1 바이트 문자 C의 N 카피를 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 공백 압입 부가, 예를 들면이 방법은 사용할 수있는 객체 X..</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; 과 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; 인터페이스가 사용 &lt;a href=&quot;printf&quot;&gt;내장의 printf&lt;/a&gt; SQLite는 기능성의 단부 상 형식의 텍스트를 추가 할&lt;a href=&quot;#sqlite3_str&quot;&gt; sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; 에있어서 내부 공사중 문자열 리셋 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str을&lt;/a&gt; 길이는 0 바이트로 오브젝트 X의 뒷면.</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 방법 공사중 동적 문자열 바이트 현재 길이를 반환 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 길이에 의해 리턴 된 객체 X.&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt; sqlite3_str_length (X)가&lt;/a&gt; 제로 종료 바이트를 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; 메소드에 의해 리턴 된 값 X. 공사중 동적 캐릭터의 현재 콘텐츠에 대한 포인터를 리턴 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; sqlite3_str 오브젝트 X에 의해 관리되고, 동일한에 후속 법에 의해 해제되거나 변경 될 수도 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체. 응용 프로그램은 동일한 오브젝트에서 후속 메소드 호출 후 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; 리턴 한 포인터를 사용해서는 안됩니다 . 응용 프로그램은 0에서 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 범위를 벗어난 바이트에 쓰지 않고 후속 sqlite3_str 메소드 호출 후 바이트를 읽거나 쓰지 않는 한 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)에&lt;/a&gt; 의해 반환되는 문자열의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 인터페이스 sqlite3_str 오브젝트 X 되돌아로부터 획득 된 버퍼 메모리에 대한 포인터 파괴 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 구축 된 스트링을 포함한다. 호출 애플리케이션은 메모리 누수를 피하기 위해 리턴 된 값을 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 로 전달해야합니다. &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 오류가 캐릭터 라인의 건설 중 발생 된 경우 인터페이스는 NULL 포인터를 반환 할 수 있습니다. &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 의 문자열 경우 인터페이스도 NULL 포인터를 반환합니다 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 X가 0 바이트 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스에 할당하고 새로운 초기화 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; 개체. 메모리 누수를 피하려면 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()에&lt;/a&gt; 의해 반환 된 객체 는 다음에 대한 호출로 해제되어야합니다.&lt;a href=&quot;#sqlite3_str_finish&quot;&gt; sqlite3_str_finish (X) sqlite3_str_new (&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스는 항상 유효한에 대한 포인터를 반환 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; 메모리 부족 오류의 경우에 반환 된 객체가 새 텍스트를 거부 자동으로하는 특별한 싱글이 될 수도 있지만, 객체를 항상에서 SQLITE_NOMEM을 반환 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;) (sqlite3_str_errcode &lt;/a&gt;&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length ()에&lt;/a&gt; 대해 항상 0을 반환하고 &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에서 항상 NULL을 반환합니다 . &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 의해 리턴 된 값을 sqlite3_str 매개 변수로 다른 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 메소드 에 사용하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 인터페이스를 반환하는 경우에만 문자열 X가 일치하면 제로 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 패턴 P.의 정의 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;#sqlite3_strglob&quot;&gt;(P, X) sqlite3_strglob를&lt;/a&gt; 에서 &quot;X GLOB P&quot;연산자와 동일 SQLite는 SQL 언어를 이해합니다. 그만큼&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 함수는 대소 문자를 구분한다.</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및&lt;a href=&quot;#sqlite3_stricmp&quot;&gt; sqlite3_strnicmp ()&lt;/a&gt; API는 식별자를 비교할 때 SQLite는 내부에서 사용하는 &quot;경우 독립&quot;의 정의와 동일하여, 애플리케이션 및 확장이 경우 독립적 방식으로 UTF-8 스트링을 포함하는 두 버퍼의 내용과 비교하도록 허용한다.</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; ASCII 문자 만이 경우 접힌 비록 기능은 유니 코드 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 인터페이스에 리턴하고 문자열 X가 일치하는 경우에만 0 일 경우 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 제어 문자 E.의 정의 패턴 P &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike를 (P는, X, E)이&lt;/a&gt; 와 동일 SQLite에서 이해하는 SQL 언어의 &quot;X LIKE P ESCAPE E&quot;연산자 ESCAPE 절이없는 &quot;X LIKE P&quot;의 경우 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 의 E 매개 변수 를 0으로 설정하십시오. LIKE 연산자와 마찬가지로 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 함수는 대소 문자를 구분하지 않습니다. 소문자 ASCII 문자는 서로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; 인터페이스는 다른 데이터베이스 연결에 의해 변경이 무시되고 데이터베이스 연결 D.에 대해 SQL 문 실행으로 인해 변경된 것을 행의 수를보고합니다. 다른 데이터베이스 연결에서 데이터베이스 파일에 대해 변화를 감지하기 위해 사용 &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령 또는 &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION을&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt; 파일 제어를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint (D, N)의&lt;/a&gt; 래퍼입니다 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 에 데이터베이스를 야기 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 자동으로 D &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 가있는 경우에 트랜잭션을 커밋 후 N 이상의 프레임을&lt;a href=&quot;wal&quot;&gt; 미리 쓰기 로그&lt;/a&gt; 파일. nFrame 매개 변수로 0 또는 음수 값을 전달하면 자동 검사 점이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 함수 WAL 모드에서 데이터베이스로 커밋 될 때마다 데이터를 호출 콜백을 등록하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결의 busy-handler를 호출하려면 배열의 두 번째 (void *)를 유일한 인수로 사용하여이 함수를 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값으로 구성된 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결 처리기 핸들러를 호출하려면이 함수는 배열의 두 번째 (void *)를 유일한 인수로 사용하여 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 포기해야합니다.</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE의&lt;/a&gt; 연산 코드는 VFS가 확장하고 사용자가 지정한 크기의 덩어리에서 데이터베이스 파일을 자릅니다 것을 요구하는 경우에 사용됩니다. &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 네 번째 인수 는 지명 된 데이터베이스에 사용할 새 청크 크기를 포함하는 정수 (유형 int)를 가리켜 야합니다. 큰 청크 (예 : 한 번에 1MB)로 데이터베이스 파일 공간을 할당하면 파일 시스템 조각화가 줄어들고 일부 시스템의 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE의&lt;/a&gt; * 표시 -shm 파일 페이지가 체크 포인트 된 사실을 기록하기 위해 업데이트되기 전에 연산 코드는 클라이언트가 데이터베이스 파일에 월마트 파일에서 완성 된 복사 페이지가 이후 월마트 모드에서 체크 포인트 내에서 호출되지만.</target>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START의&lt;/a&gt; 클라이언트가 데이터베이스 파일에 월마트 파일에서 페이지를 복사하기 시작하기 전에 옵 코드는 월마트 모드에서 체크 포인트 내에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE이&lt;/a&gt; 원자 적으로 수행 할 수 있습니다. 이 파일 제어는 쓰기가 모두 성공적으로 수행되고 지속적 스토리지에 커미트 된 경우에만 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 성공 여부에 관계없이이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 해제하여 모든 후속 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 호출 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되어 VFS에 전송 트랜잭션이 즉시 커밋 된 후에 만 데이터베이스 잠금이 해제되기 전에된다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 이 opcode와 함께 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 호출해서는 안되며 이를 요구하는 특수 VFS의 작동을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 부호없는 32 비트 정수에 대한 포인터입니다. 호출기에 대한 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결에서 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결로 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한&lt;a href=&quot;#sqlite3_total_changes&quot;&gt; sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략는 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하는 변경 사항을 감지하고 연결된 특정 데이터베이스와 연관된 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 32 비트 부호없는 정수에 대한 포인터입니다. 호출기의 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결의 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결에 의해 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략가 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하고 특정 연결된 데이터베이스와 관련된 변경 사항을 감지하는 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 코드는 포인터 얻기 위해 사용된다 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 특정 데이터베이스 연결과 관련된 개체. &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; 파일 제어 정수에 대한 포인터로 인수를 해석하고는, 이름이 이동하거나 처음 열린 이후 삭제 된 여부 파일에 따라 그 정수에 부울을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER의&lt;/a&gt; 연산 코드는 포인터 가져 오는 데 사용됩니다 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 저널 파일합니다 (하나와 관련된 객체 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 또는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 특정 데이터베이스 연결을). &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 잠금의 현재 상태 ( &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 중 하나 )를 pArg 인수가 가리키는 정수로 쓰도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST 컴파일 타임 옵션이 사용 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 연산 코드는 M은 하나의 부호없는 정수 파라미터이고, 실패 전에 M 밀리 초까지 기다릴 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려는 시도를 야기한다.</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 오피은 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려고 시도 할 때 실패 전에 M 밀리 세컨드까지의 블록에 대해 VFS를 구성하는데 사용된다. 매개 변수는 M이 설정 될 값을 포함하는 32 비트 부호있는 정수에 대한 포인터입니다. 반환하기 전에 부호있는 32 비트 정수를 이전 값 M으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE의&lt;/a&gt; 파일 제어에 사용되는 최대 바이트 수 쿼리에 사용되거나 설정되어 I / O를 메모리 매핑. 인수는 파일 대 메모리 맵의 권고 최대 바이트 수인 sqlite3_int64 유형의 값에 대한 포인터입니다. 이전 값으로 포인터를 덮어 씁니다. 원래 가리키는 값이 음수이면 한계가 변경되지 않으므로 포인터를 음수로 전달하여 현재 한계를 쿼리 할 수 ​​있습니다. 이 파일 제어는 &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; 구현에 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE의&lt;/a&gt; 연산 코드는 그 어떤 이유로 롤백하지 않는 것을 나타 내기 위해 쓰기 트랜잭션을 연 후 SQLite는에 의해 호출, 전체 데이터베이스 파일은 현재 트랜잭션을 덮어 씁니다. VACUUM 작업에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; op 코드 세트에 사용되거나 지속적인 쿼리입니다 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 설정을. 기본적으로 트랜잭션 제어에 사용되는 보조 미리 쓰기 로그 ( &lt;a href=&quot;wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; ) 및 공유 메모리 파일은 데이터베이스에 대한 최신 연결이 닫힐 때 자동으로 삭제됩니다. 영구 WAL 모드를 설정하면 파일을 닫은 후에도 해당 파일이 유지됩니다. 데이터베이스를 읽을 수 있으려면 WAL 및 공유 메모리 파일이 있어야하므로 데이터베이스 파일을 포함하는 디렉토리에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스 파일을 읽으려는 경우 파일을 유지하는 것이 유용합니다. &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수이 opcode는 정수에 대한 포인터 여야합니다. 이 정수는 영속 WAL 모드를 비활성화하려면 0이고 영속 WAL 모드를 활성화하려면 1입니다. 정수가 -1이면 현재 WAL 지속성 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE의&lt;/a&gt; op 코드 세트에 사용되거나 영구 &quot;powersafe 덮어 쓰기&quot;또는 &quot;PSOW&quot;설정을 조회한다. PSOW 설정 에 따라 xDeviceCharacteristics 메서드 의 &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; 비트가 결정 됩니다. 이 opcode에 대한 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수 는 정수에 대한 포인터 여야합니다. 이 정수는 0으로 제로 손상 모드를 비활성화하거나 1로 제로 손상 모드를 활성화합니다. 정수가 -1이면 현재 제로 손상 모드 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU의&lt;/a&gt; 연산 코드 만 RBU 확장에 사용되는 특수 VFS에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE가&lt;/a&gt; 롤백 할 수 있습니다. 이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 꺼내어 이후의 모든 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 호출 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT의&lt;/a&gt; 연산 코드는 VFS 층을 데이터베이스 파일이 현재 트랜잭션 동안으로 성장하는 방법 대규모의 힌트를 제공하는 SQLite는 데 사용됩니다. 이 힌트는 정확하지는 않지만 종종 가깝습니다. 기본 VFS는 데이터베이스 파일에 대한 쓰기 속도를 높이기 위해이 힌트를 기반으로 데이터베이스 파일 공간을 사전 할당하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT의&lt;/a&gt; 연산 코드가 구현 그 메모리 VFS가 사용된다 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 이 상부 메모리 데이터베이스의 크기에 바인딩 설정한다. 인수는 &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64에&lt;/a&gt; 대한 포인터 입니다. 가리키는 정수가 음수이면 전류 제한으로 채워집니다. 그렇지 않으면 한계는 지정된 정수 값과 현재 데이터베이스 크기보다 크게 설정됩니다. 지정된 정수가 새로운 한계로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성하여 xSync 메소드가 호출되지 않은 경우 xSync 메소드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 마스터 저널 파일 이름을 포함하는 널 종료 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;#sqlite3_file_control&quot;&gt; sqlite3_file_control ()을&lt;/a&gt;이 opcode를 호출해서는 안되며 이를 요구하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성했기 때문에 xSync 메서드가 호출되지 않은 경우 xSync 메서드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 수퍼 저널 파일 이름을 포함하는 널로 끝나는 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 조용히 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출해서는 안됩니다. 이 opcode를 사용하면이를 필요로하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE의&lt;/a&gt; 파일 제어는 SQLite는 스택의 상위 계층이 무엇을하고 있는지에 대한 VFS에 자문 정보를 제공합니다. 이 파일 제어는 일부 VFS 활동 추적 &lt;a href=&quot;vfs#shim&quot;&gt;shim에서&lt;/a&gt; 사용됩니다 . 인수는 0으로 끝나는 문자열입니다. &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; 컴파일 타임 옵션이 활성화 된 경우 SQLite 스택의 상위 계층에서이 파일 컨트롤의 인스턴스를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME의&lt;/a&gt; 오피 모든 이름 얻기 위해 사용될 수있다 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; VFS에 스택한다. 이름은 모든 VFS 심의 이름이며 최종 하위 레벨 VFS는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록되고 결과는 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수가 가리키는 char * 변수에 저장 됩니다. 호출자가 완료되면 메모리를 확보해야합니다. 모든 파일 제어 작업과 마찬가지로 실제로이 작업이 수행 될 것이라는 보장은 없습니다. 이 파일 제어가 구현되지 않은 경우 호출자는 char * 변수를 NULL 포인터로 초기화해야합니다. 이 파일 제어는 진단 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 연산 코드 최상위에 대한 포인터 발견 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 현재 사용합니다. sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X)의 인수 X는 &quot; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; 유형이어야합니다 . 이 opcode는 * X를 최상위 VFS의 포인터로 설정합니다. 스택에 여러 VFS 심이있는 경우이 opcode는 최상위 심만 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK는&lt;/a&gt; 로크가 바로 사용할 수없는 경우가 다음 WAL 로크에 차단하는 것이 유리할 수 있다는 VFS 계층 신호이다. WAL 하위 시스템은 우선 순위 반전 문제를 해결하기 위해 드문 상황에서이 신호를 발행합니다. 응용 프로그램은 이 파일 제어를 사용 &lt;em&gt;하지 않아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY의&lt;/a&gt; 연산 코드는 특정 디스크에 대한 자동 재시도 횟수와 간격을 구성하는 데 사용되는 윈도우에 대한 I / O 작업 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;안티 바이러스 프로그램이있을 때 견고성을 제공합니다. 기본적으로, Windows VFS는 파일 다시 읽기, 파일 쓰기 및 파일 삭제 조작을 최대 10 번까지 다시 시도하며, 첫 번째 재시도 전에 25 밀리 초의 지연이 발생하며 이후의 재 시도마다 25 밀리 초씩 지연됩니다. 이 opcode를 사용하면이 두 값 (재시도 10 회 및 25 밀리 초 지연)을 조정할 수 있습니다. 동일한 프로세스 내의 모든 데이터베이스 연결에 대한 값이 변경됩니다. 인수는 첫 번째 정수는 새로운 재시도 횟수이고 두 번째 정수는 지연되는 두 정수 배열에 대한 포인터입니다. 정수가 음수이면 설정이 변경되지 않고 대신 해당 설정의 이전 값이 배열 항목에 기록되어 현재 재시도 설정을 조사 할 수 있습니다.zDbName 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE의&lt;/a&gt; 연산 코드는 파일 핸들과 관련된 기본 기본 파일 핸들을 얻을 수 있습니다. 이 파일 컨트롤은 인수를 기본 파일 핸들에 대한 포인터로 해석하여 결과 값을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 파일 핸들을 pArg 인수가 가리키는 핸들과 교체하도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST가 정의 된 경우에만 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS의&lt;/a&gt; 오피은 zipvfs에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 시간 옵션의 길이를 제한하기 위해 사용될 수있는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;결합 된 파라미터&lt;/a&gt; sqlite3_trace의 출력 확장 ().</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT의&lt;/a&gt; 컴파일시 옵션은 바인딩 매개 변수 확장의 크기를 제한합니다. &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE의&lt;/a&gt; 컴파일시 옵션 원인 sqlite3_expanded_sql ()는 항상 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보관되어 있다고 가정 하고 pragma는 &lt;a href=&quot;free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = OFF의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보유되어 있다고 가정 하며 pragma는 &lt;a href=&quot;free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 만들거나 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다. &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma에서&lt;/a&gt; 요청한 경우 제외SQLite는 sqlite3_temp_directory가 가리키는 메모리를 해제하지 않습니다. 응용 프로그램이 해당 메모리를 비우기를 원하면 모든 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트가 소멸 된 후에 만주의를 기울여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그는&lt;/a&gt; SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA의 wal_checkpoint의&lt;/a&gt; 명령은 SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA의 writable_schema은 ON =&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex 번째 항목이됩니다. aConstraintUsage []. omit가 true 인 경우 제한 조건은 가상 테이블에서 완전히 처리 된 것으로 간주되며 SQLite에서 다시 점검하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex-th 항목이됩니다. aConstraintUsage []. omit이 참이면 제약 조건은 가상 테이블에서 완전히 처리되는 것으로 간주되며 바이트 코드에서 다시 검사하지 않을 수 있습니다. aConstraintUsage []. omit 플래그는 최적화 힌트입니다. 생략 플래그가 기본 설정 인 false로 남아 있으면 제약 조건은 항상 바이트 코드에서 별도로 검사됩니다. 생략 플래그가 참으로 변경되면 제약 조건이 바이트 코드에서 확인되거나 확인되지 않을 수 있습니다. 즉, 생략 플래그가 참이면 제약 조건이 바이트 코드를 사용하여 다시 검사되지 않는다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드는 이 인터페이스를 호출하여 구현 하는 가상 테이블 의 형식 (열의 이름 및 데이터 유형)을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="bcf8720fcb25c1b9008caa098927de8f2ece3d5e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt; document describes how SQLite implements transactions.</source>
          <target state="translated">&lt;a href=&quot;atomiccommit&quot;&gt;원자 커밋&lt;/a&gt; 문서는 어떻게 SQLite는 구현 트랜잭션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;atomiccommit&quot;&gt;원자 업데이트 기능&lt;/a&gt; 을 통해 문서에 작은 증분 변경 사항을 안전하게 쓸 수 있습니다. 이렇게하면 전체 디스크 I / O가 줄어들고 파일 / 저장 성능이 향상되어 사용자 경험이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 기능은 MySQL과는 다르게 작동합니다. 이것은 종종 MySQL에서 SQL을 배우고 SQLite를 사용하기 시작한 사람들에게 혼란을 야기하며 두 시스템이 동일하게 작동 할 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 오브젝트 자체는 부분적으로 쓰레드이다. 여러 스레드가 sqlite3_backup_step ()을 여러 번 동시에 호출 할 수 있습니다. 그러나 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () API는 엄격하게 말하면 스레드 안전하지 않습니다. 다른 스레드가 sqlite3_backup_step ()을 호출하는 것과 동시에 호출되면 유효하지 않은 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; 및 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 인터페이스와는 내장 &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob의&lt;/a&gt; SQL 함수 증분 762 인터페이스를 통해 판독 또는 기록 할 수있는 충전 제로 블롭들을 생성하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="c7e4db04e283ee079f91c197314578446dc39a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine is used only in the implementations of aggregate and window functions. Scalar functions may not use &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;. The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; function is included in the interface list only for completeness.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; 루틴은 집계 창 함수의 구현에 사용됩니다. 스칼라 함수는 &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context ()를&lt;/a&gt; 사용할 수 없습니다 . &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; 함수는 완전성에 대한 인터페이스 목록에 포함된다.</target>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; 사용되지 않는 8 년 동안 문서화 된 인터페이스는, 무 조작으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm의&lt;/a&gt; 루틴은 메모리 할당 이벤트에 대한 콜백을 등록하는 데 사용됩니다. 이 루틴은 할당 된 메모리 양이 iThreshold를 초과 할 때 발생하는 콜백을 등록하거나 지 웁니다. 한 번에 하나의 콜백 만 등록 할 수 있습니다. &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()에 대한&lt;/a&gt; 각 호출 은 이전 콜백을 덮어 씁니다. 콜백은 xCallback을 NULL 포인터로 설정하여 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup ()&lt;/a&gt; 인터페이스는 어떤 조합 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;온라인 백업 API는&lt;/a&gt; 이러한 문제를 해결하기 위해 만들어졌다. 온라인 백업 API를 사용하면 한 데이터베이스의 컨텐츠를 다른 데이터베이스로 복사하여 대상 데이터베이스의 원래 컨텐츠를 겹쳐 쓸 수 있습니다. 복사 조작은 증 분식으로 수행 될 수 있으며,이 경우 소스 데이터베이스를 실제로 읽는 동안 잠깐 동안 만 소스 데이터베이스를 잠글 필요는 없습니다. 이를 통해 온라인 데이터베이스를 백업하는 동안 다른 데이터베이스 사용자가 중단없이 계속 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 인터페이스는 않습니다 &lt;u&gt;되지&lt;/u&gt; 노조 - vtab을 위해 작동합니다. BLOB 컨텐츠는 일반 SQL 문을 사용하여 union-vtab에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ의 &lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부여 콜백이&lt;/a&gt; 더 열이 추출되지되는 쿼리에서 참조 된 모든 테이블에 빈 문자열 열 이름을 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; 런타임 옵션과 &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; 컴파일 타임 옵션은 가능 &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;쿼리 플래너 안정성 보장&lt;/a&gt; . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; 비트 수단이 기기의 모든 기록 역시 전체 기록이 발생하는 점에서 원자 것을 또는 그 어느 것도 발생하지 않는다. 다른 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; 값은 표시된 크기의 정렬 된 블록의 쓰기가 원자 적임을 나타냅니다. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; 는 새 데이터로 파일을 확장 할 때 새 데이터가 먼저 작성된 다음 파일 크기가 업데이트 됨을 의미합니다. 따라서 정전이 발생하면 파일이 무작위로 확장되었을 가능성이 없습니다. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; 비트 수단 모든 쓰기는 그들이 발행 및 기본 파일 시스템에 의해 재정렬되지 순서대로 일어난다.</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. TEMP 데이터베이스 및 저널 및 서브 저널에 대해 항상 설정됩니다. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 파일이 독점 액세스를 위해 열 수 있습니다 의미합니다. 이 플래그는 기본 데이터베이스 파일을 제외한 모든 파일에 설정됩니다. xOpen에 세 번째 인수로 전달 된 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조는 호출자가 할당합니다. xOpen은 이것을 채 웁니다. 호출자는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조에 대해 최소 szOsFile 바이트를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그를 사용하여 런타임시 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 조정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 옵션이 추가되었습니다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type ()&lt;/a&gt; 함수는 N 번째 열에있는 값의 데이터 유형을 리턴한다. 반환 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 함수는 결과 집합의 열 수를 반환합니다. sqlite3_column_count은 () 후 언제든지 호출 할 수 있습니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count는 ()&lt;/a&gt; 와 비슷하게 동작 &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 단지 다음과 같은 것을 제외하면, &lt;a href=&quot;c3ref/step&quot;&gt;() sqlite3_step&lt;/a&gt; . &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 이전 호출이 SQLITE_DONE 또는 오류 코드 를 리턴 한 경우 &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; 는 0을 리턴하는 반면 &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 는 결과 세트의 열 수를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 SQLite는 글로벌 프로세스 전체의 구성을 변경하는 데 사용된다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 보다 먼저 인터페이스를 호출해야 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 생성됩니다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스는 같은 일을 할 수있는 프로그래머를 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config은&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI는&lt;/a&gt; , 1) 인터페이스는 시동시에 호출한다.</target>
        </trans-unit>
        <trans-unit id="faa946b5075b7749c61a0c77f6eb5fe8e812f89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; routine returns a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; 루틴에 대한 포인터를 반환 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스는 새로운 만드는 데 사용되는 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 텍스트를 정렬합니다. &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 인터페이스는 새로운 등록에 사용되는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스는 새로운 생성 &lt;a href=&quot;vfs&quot;&gt;VFSes을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="965853485ed37d427cfb8a0c73c9695bbb338f24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces is used to create new custom SQL functions. Each member of this family is a wrapper around a common core. All family members accomplish the same thing; they merely have different calling signatures.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스 제품군은 새로운 사용자 정의 SQL 함수를 작성하는 데 사용됩니다. 이 제품군의 각 구성원은 공통 코어를 둘러싼 래퍼입니다. 모든 가족 구성원은 같은 일을합니다. 그들은 단지 다른 호출 서명을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스의 가족은 지금 돌아 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE을&lt;/a&gt; 대신 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 잘못된 매개 변수 조합을 통과 할 때.</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스 등 () 함수를 오버라이드함으로써의 동작 변경하는데 사용될 수있다 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 오퍼레이터. like () 함수를 재정의하는 경우 like () 함수의 두 개 및 세 개의 인수 버전을 모두 재정의하는 것이 중요 할 수 있습니다. 그렇지 않으면 ESCAPE 절의 지정 여부에 따라 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 를 구현하기 위해 다른 코드가 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 스칼라 또는 집계 중 - 인터페이스는 새로운 SQL 함수를 작성합니다. 새로운 기능 구현은 일반적으로 다음과 같은 추가 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스는 과부하에 대한 시도에서 SQLITE_MISUSE을 반환하거나 교체 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 모듈을. 이 경우 소멸자는 항상 기록 및 현재 문서에 따라 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 루틴과 연관 모듈 이름 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조 및 각각의 모듈에 특정한 개별 클라이언트 데이터. 두 create_module 메소드의 유일한 차이점은 _v2 메소드에 클라이언트 데이터 포인터의 소멸자를 지정하는 추가 매개 변수가 포함된다는 것입니다. 모듈 구조는 가상 테이블의 동작을 정의합니다. 모듈 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; (dB, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS이&lt;/a&gt; 가 연기하고 해결되지 않은 외래 키 제약하는 경우, ...) C 언어 인터페이스는 트랜잭션 동안 사용할 수있는 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; 인터페이스는 이제하지가 실행 된 단지 하나 개의 스레드, 프로세스 내의 모든 스레드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 는 컴파일 및 실행 SQLite는 버전 2 0 개 두 번째 매개 변수에 지정된 이상의 SQL 문에서와 마찬가지로 기능이 많이 작동합니다. 조회 결과는 콜백 루틴으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 인터페이스는 하나의 함수 호출과 상기 단계 네를 행하는 간이 래퍼이다. &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()에&lt;/a&gt; 전달 된 콜백 함수 는 결과 집합의 각 행을 처리하는 데 사용됩니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;) (sqlite3_get_table는&lt;/a&gt; 위의 단계의 네 가지 않는 다른 편의 래퍼입니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 에서 인터페이스 상이 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()는&lt;/a&gt; 점에서 오히려 콜백을 호출보다 힙 메모리의 쿼리의 결과를 저장한다.</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 모든 준비된 문에 인터페이스가 작동을 사용하여 만든 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3을 ()&lt;/a&gt; . 그것은 사용하는 것이 더 이상 필요 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 와 &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE를&lt;/a&gt; 사용하기 위해 &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 개체가 열려있는 파일을 나타냅니다. &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 의 xOpen 메소드 는 파일을 열 때 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트를 구성합니다 . &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file가&lt;/a&gt; 열릴 때 파일의 상태를 추적 유지합니다.</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 용 SQLite는 범용 메모리 할당 한번에 우수 할 수 있다는 뛰어난 메모리의 총량을 결합하는 상부를 설정하는데 사용될 수있다. 소프트 힙 제한에 지정된 것보다 더 많은 메모리를 할당하려고 시도하면 SQLite는 할당 요청을 계속하기 전에 먼저 캐시 메모리를 해제하려고 시도합니다. 소프트 힙 제한 메커니즘은 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 가 활성화 된 경우에만 작동 하며 SQLite 라이브러리가 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 가장 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 구조 및 모듈로 구현하는 가상 테이블의 xBestIndex 방법에서 정보를 전달하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 인터페이스는 명시 적으로 초기화 SQLite는 서브 시스템에 호출 할 수 있습니다. &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 의 사용 때문에 특정 인터페이스를 호출 할 때 인터페이스가 자동으로 호출됩니다 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()가&lt;/a&gt; 필요하지는 않지만 권장합니다.</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 인터페이스는 SQLite는에 의해 할당 된 수있는 시스템 자원 (메모리 할당, 뮤텍스, 열린 파일 핸들) 해제됩니다 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 인터페이스는 창 아래에있는 모든 뮤텍스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 루틴은 다른 스레드를 위해 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 열려있는 파일과 상호 작용하는 데 사용되는 방법을 보유하고 있습니다. 각 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 은 그것이 나타내는 파일에 적합한 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체에 대한 포인터를 포함합니다 . &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 읽기 및 쓰기 파일에서, 영구 저장소에 변경 사항을 플러시하기 위해 파일의 크기를 찾기 위해, 잠금 및 파일의 잠금을 해제하고, 가까운 파일에 파일을 절단하는 등의 일을하는 방법을 포함 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 읽기, 쓰기, 그렇지 않으면 파일을 다루는 방법에 대한 포인터를 포함하는 구조입니다. 이 객체는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; 함수 시도는 소스 코드 버전 관리에 체크 어떤에서 수정되었습니다 및 수정을가있는 경우, 버전 해시의 마지막 네 문자 &quot;ALT1&quot;또는 &quot;ALT2&quot;로 표시하는 경우 감지합니다. 실수 나 부주의 한 편집을 감지하는 것이 목적입니다. 위조자는이 기능을 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스로드합니다 &lt;a href=&quot;loadext&quot;&gt;확장&lt;/a&gt; 하나의 데이터베이스 연결로. 기본 동작은 데이터베이스 연결이 닫힐 때 해당 확장이 자동으로 언로드되는 것입니다. 그러나 확장 진입 점이 SQLITE_OK 대신 SQLITE_OK_LOAD_PERMANENTLY를 리턴하면 데이터베이스 연결이 닫힌 후에도 확장이 프로세스 주소 공간에로드 된 상태로 유지됩니다. 즉, 데이터베이스 연결이 닫힐 때 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xDlClose 메소드가 확장에 대해 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스는 사용되지 않습니다. &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()를&lt;/a&gt; 통해 동등한 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스의 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ) 인터페이스 및 &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; 메모리 사용량 추적이 해제 된 경우 컴파일시 옵션은 모든 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조는 가상 테이블을 구현하는 데 사용되는 모듈 객체를 정의합니다. 모듈은 비슷한 속성을 가진 여러 가상 테이블을 생성 할 수있는 클래스로 생각하십시오. 예를 들어, 디스크의 CSV (쉼표로 분리 된 값) 파일에 대한 읽기 전용 액세스를 제공하는 모듈이있을 수 있습니다. 그런 다음 하나의 모듈을 사용하여 각 가상 테이블이 다른 CSV 파일을 참조하는 여러 가상 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter은 ()&lt;/a&gt; 다른 스레드가 이미있는 경우 뮤텍스와 블록을 입력하려고합니다. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try ()&lt;/a&gt; 는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 입력하고 다른 스레드가 이미있는 경우 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴하려고 시도 합니다 . &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; 는 뮤텍스를 종료합니다. 뮤텍스는 출구 수가 입구 수와 일치 할 때까지 유지됩니다. 경우 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()이&lt;/a&gt; 스레드가 현재 유지되지 않는다는 뮤텍스에서 호출 한 다음 동작은 정의되지 않는다. 할당 취소 된 뮤텍스에 대한 루틴이 호출되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free ()&lt;/a&gt; 루틴은 비 정적 뮤텍스를 해방하기 위해서 사용합니다. 정적 뮤텍스가이 루틴으로 전달되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 인터페이스는 모든 발견 할 수있는 응용 프로그램 수 있도록 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 관련 인터페이스는 SQL 바이트 코드로 문자를 변환하는 컴파일러로 작용한다. &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt의&lt;/a&gt; 객체는 하나의 SQL 문을 구현하기 위해 사용하는 단일 바이트 코드 프로그램의 컨테이너입니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 가상 머신에 바이트 코드 프로그램을 전달하고까지 프로그램의 실행 결과의 행 리턴하는 하나 완료되거나 형태 또는 심각한 오류 안타되거나 &lt;a href=&quot;c3ref/interrupt&quot;&gt;중단&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 인터페이스는 생성 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 스키마가 변경되면 자동으로 다시 컴파일됩니다. 를 처리하는 가장 쉬운 방법 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA의&lt;/a&gt; 오류가 항상 사용하는 것입니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;) sqlite3_prepare_v2을 (&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 (에 의해 호출 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 완료 실행되지 않은 문에 대한).</target>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스는 이제 인터페이스를 호출 스레드에서뿐만 아니라 연결, 모든 스레드에서 모든 데이터베이스 연결을 통해 메모리 사용량을 줄이기 위해 시도합니다.</target>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; , 및 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; 인터페이스는 이제 작품은, 그 과정에서 자신을 호출하는 단지 하나의 스레드 모든 스레드를 교차. *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="a58543f2b7ba8e8bf7e29c328f9ab5da7da2ea1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result() family of functions&lt;/a&gt; are used to specify the result of the scalar SQL function. One or more of these should be invoked by the callback to set the function return value. If none of these routines are invoked for a specific callback, then the return value will be NULL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_blob&quot;&gt;기능 sqlite3_result () 패밀리는&lt;/a&gt; 스칼라 SQL 함수의 결과를 지정하는 데 사용된다. 이들 중 하나 이상은 함수 반환 값을 설정하기 위해 콜백에 의해 호출되어야합니다. 특정 콜백에 대해 이러한 루틴이 호출되지 않으면 반환 값은 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부여 콜백는&lt;/a&gt; 관계없이 EXPLAIN 또는 EXPLAIN 쿼리 계획의 존재 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 인터페이스는 이제하지가 실행 된 단지 하나 개의 스레드, 프로세스 내의 모든 스레드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 인터페이스는 부드러운 힙 한계에 메모리 경보를 등록하고 호출하여 작동 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 알람 콜백을. &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 모듈을 방해하므로 응용 프로그램은 sqlite3_memory_alarm () 인터페이스 를 사용해서는 안됩니다 . 이 인터페이스는 SQLite 코어가 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 으로 컴파일 될 때 애플리케이션이 자체 대체 구현을 제공 할 수 있도록 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 용 SQLite는 범용 메모리 할당 한번에 우수 할 수 있다는 뛰어난 메모리의 총량을 결합하는 상부를 설정하는데 사용될 수있다. 소프트 힙 한계에 의해 지정된 것보다 많은 메모리를 할당하려고 시도하면 SQLite는 할당 요청을 계속하기 전에 먼저 캐시 메모리를 해제하려고 시도합니다. 소프트 힙 제한 메커니즘은 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 가 사용 가능한 경우에만 작동 하며 SQLite 라이브러리가 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 가장 효과적 입니다.</target>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문의&lt;/a&gt; 객체는 다음과 같습니다 C / C ++ 인터페이스 루틴의 작은 집합에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 개체 : sqlite3를</target>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 문에 VACUUM를 실행하는 원래 사용하여 연 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI의&lt;/a&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체 : sqlite3_stmt</target>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; C ++ 인터페이스를 함께와 C / &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; 동사는 SQL 문이 인덱스의 효과적인 사용을하지 않을 때 실행시에 감지 할 수 있습니다. 많은 응용 프로그램이 여기에 설명 된 INDEXED BY 구문 대신 인덱스 오용을 탐지 하기 위해 &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 를 사용하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata ()가&lt;/a&gt; 제대로 작동하도록 향상 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블과 열 이름 매개 변수가 NULL 인 경우 AA 테이블의 존재를 확인 할 수 있습니다. 인터페이스는 이제 &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; 컴파일 타임 옵션 을 요구하지 않고 기본적으로 빌드에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="translated">&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control은&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt; , ...) 인터페이스는 SQL 문 최적화를 선택 허용 런타임 비활성화 할 수 있습니다. SQLite는 최적화가 활성화되고 최적화가 비활성화 된 상태에서 항상 정확히 같은 답을 생성해야합니다. 최적화를 켜면 대답이 더 빨리 도착합니다. 따라서 프로덕션 환경에서는 항상 최적화를 켜 둡니다 (기본 설정).</target>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; &quot;-&quot;주석 마커 중첩 된 SQL 문에 대한 출력은 항상로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 라이브러리가 전처리 심볼로 컴파일하는 경우에만 사용할 수 있습니다 API, &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY는&lt;/a&gt; 정의가되어 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;여기에 문서화&lt;/a&gt; . 이 기사는 전체 API 문서를 읽는 것을 대체하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스는 각각에 할당 별도의 스레드가 시스템에 사용하도록 설계되어 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; . 구현시 단일 스레드가 여러 데이터베이스 연결을 실행하지 못하게하는 것은 없습니다. 그러나 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스는 한 번에 단일 연결에서만 작동하므로 여기에 제시된 잠금 해결 논리는 스레드 당 단일 데이터베이스 연결에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="translated">&lt;a href=&quot;c3ref/update_hook&quot;&gt;업데이트 후크&lt;/a&gt; 바꾸기 충돌 해결 전략에 의해 삭제 된 행에 대해 호출되지 않습니다. REPLACE도 &lt;a href=&quot;c3ref/changes&quot;&gt;변경 카운터를&lt;/a&gt; 증가시키지 않습니다 . 이 단락에 정의 된 예외적 인 동작은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="174d9ce4b7cba75823debe78170b5d882dfa96e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt; routine returns a copy of the &lt;b&gt;pArg&lt;/b&gt; pointer that was given to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; when the SQL function was created.</source>
          <target state="translated">&lt;a href=&quot;c3ref/user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; 루틴의 반환의 사본 &lt;b&gt;pArg의&lt;/b&gt; 주어졌다 포인터 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; SQL 함수가 생성되었다.</target>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; API는 이름으로 특정 VFS를 찾는 데 사용됩니다. 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister ()&lt;/a&gt; API는 시스템에서 기존 VFS를 제거하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor의&lt;/a&gt; 구조는 가상 테이블의 특정 행에 대한 포인터를 나타냅니다. 이것은 sqlite3_vtab_cursor의 모습입니다 :</target>
        </trans-unit>
        <trans-unit id="7da2c1fa98bb7a679ac7ffc72d14de8a7e2722aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결의 busy-handler를 호출하려면 배열의 두 번째 (void *)를 유일한 인수로 사용하여이 함수를 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값으로 구성된 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결 처리기 핸들러를 호출하려면이 함수는 배열의 두 번째 (void *)를 유일한 인수로 사용하여 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 포기해야합니다.</target>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE의&lt;/a&gt; 연산 코드는 VFS가 확장하고 사용자가 지정한 크기의 덩어리에서 데이터베이스 파일을 자릅니다 것을 요구하는 경우에 사용됩니다. &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 네 번째 인수 는 지명 된 데이터베이스에 사용할 새 청크 크기를 포함하는 정수 (유형 int)를 가리켜 야합니다. 큰 청크 (예 : 한 번에 1MB)로 데이터베이스 파일 공간을 할당하면 파일 시스템 조각화가 줄어들고 일부 시스템의 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2724ba1a9151f430bfc44ff351307f4c931e3d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE의&lt;/a&gt; * 표시 -shm 파일 페이지가 체크 포인트 된 사실을 기록하기 위해 업데이트되기 전에 연산 코드는 클라이언트가 데이터베이스 파일에 월마트 파일에서 완성 된 복사 페이지가 이후 월마트 모드에서 체크 포인트 내에서 호출되지만.</target>
        </trans-unit>
        <trans-unit id="e6b7ae020cfbad6284212ff443474df4c8cbc164" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START의&lt;/a&gt; 클라이언트가 데이터베이스 파일에 월마트 파일에서 페이지를 복사하기 시작하기 전에 옵 코드는 월마트 모드에서 체크 포인트 내에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE이&lt;/a&gt; 원자 적으로 수행 할 수 있습니다. 이 파일 제어는 쓰기가 모두 성공적으로 수행되고 지속적 스토리지에 커미트 된 경우에만 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 성공 여부에 관계없이이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 해제하여 모든 후속 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 호출 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되어 VFS에 전송 트랜잭션이 즉시 커밋 된 후에 만 데이터베이스 잠금이 해제되기 전에된다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 이 opcode와 함께 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 호출해서는 안되며 이를 요구하는 특수 VFS의 작동을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 부호없는 32 비트 정수에 대한 포인터입니다. 호출기에 대한 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결에서 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결로 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략는 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하는 변경 사항을 감지하고 연결된 특정 데이터베이스와 연관된 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="429853e91982da517f099946a428569f5a10010d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 32 비트 부호없는 정수에 대한 포인터입니다. 호출기의 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결의 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결에 의해 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략가 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하고 특정 연결된 데이터베이스와 관련된 변경 사항을 감지하는 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 코드는 포인터 얻기 위해 사용된다 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 특정 데이터베이스 연결과 관련된 개체. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; 파일 제어 정수에 대한 포인터로 인수를 해석하고는, 이름이 이동하거나 처음 열린 이후 삭제 된 여부 파일에 따라 그 정수에 부울을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER의&lt;/a&gt; 연산 코드는 포인터 가져 오는 데 사용됩니다 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 저널 파일합니다 (하나와 관련된 객체 &lt;a href=&quot;../lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 또는 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 특정 데이터베이스 연결을). &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 잠금의 현재 상태 ( &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; 또는 &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 중 하나 )를 pArg 인수가 가리키는 정수로 쓰도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST 컴파일 타임 옵션이 사용 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 연산 코드는 M은 하나의 부호없는 정수 파라미터이고, 실패 전에 M 밀리 초까지 기다릴 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려는 시도를 야기한다.</target>
        </trans-unit>
        <trans-unit id="f76db0b59ac49aa27a2ffafc1d9d0b7df64c41cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 오피은 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려고 시도 할 때 실패 전에 M 밀리 세컨드까지의 블록에 대해 VFS를 구성하는데 사용된다. 매개 변수는 M이 설정 될 값을 포함하는 32 비트 부호있는 정수에 대한 포인터입니다. 반환하기 전에 부호있는 32 비트 정수를 이전 값 M으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE의&lt;/a&gt; 파일 제어에 사용되는 최대 바이트 수 쿼리에 사용되거나 설정되어 I / O를 메모리 매핑. 인수는 파일 대 메모리 맵의 권고 최대 바이트 수인 sqlite3_int64 유형의 값에 대한 포인터입니다. 이전 값으로 포인터를 덮어 씁니다. 원래 가리키는 값이 음수이면 한계가 변경되지 않으므로 포인터를 음수로 전달하여 현재 한계를 쿼리 할 수 ​​있습니다. 이 파일 제어는 &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; 구현에 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE의&lt;/a&gt; 연산 코드는 그 어떤 이유로 롤백하지 않는 것을 나타 내기 위해 쓰기 트랜잭션을 연 후 SQLite는에 의해 호출, 전체 데이터베이스 파일은 현재 트랜잭션을 덮어 씁니다. VACUUM 작업에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; op 코드 세트에 사용되거나 지속적인 쿼리입니다 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 설정을. 기본적으로 트랜잭션 제어에 사용되는 보조 미리 쓰기 로그 ( &lt;a href=&quot;../wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; ) 및 공유 메모리 파일은 데이터베이스에 대한 최신 연결이 닫힐 때 자동으로 삭제됩니다. 영구 WAL 모드를 설정하면 파일을 닫은 후에도 해당 파일이 유지됩니다. 데이터베이스를 읽을 수 있으려면 WAL 및 공유 메모리 파일이 있어야하므로 데이터베이스 파일을 포함하는 디렉토리에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스 파일을 읽으려는 경우 파일을 유지하는 것이 유용합니다. &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수이 opcode는 정수에 대한 포인터 여야합니다. 이 정수는 영속 WAL 모드를 비활성화하려면 0이고 영속 WAL 모드를 활성화하려면 1입니다. 정수가 -1이면 현재 WAL 지속성 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE의&lt;/a&gt; op 코드 세트에 사용되거나 영구 &quot;powersafe 덮어 쓰기&quot;또는 &quot;PSOW&quot;설정을 조회한다. PSOW 설정 은 xDeviceCharacteristics 메소드 의 &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; 비트를 결정합니다 . 이 opcode에 대한 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수 는 정수에 대한 포인터 여야합니다. 이 정수는 0으로 제로 손상 모드를 비활성화하거나 1로 제로 손상 모드를 활성화합니다. 정수가 -1이면 현재 제로 손상 모드 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU의&lt;/a&gt; 연산 코드 만 RBU 확장에 사용되는 특수 VFS에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE가&lt;/a&gt; 롤백 할 수 있습니다. 이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 꺼내어 이후의 모든 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 호출 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT의&lt;/a&gt; 연산 코드는 VFS 층을 데이터베이스 파일이 현재 트랜잭션 동안으로 성장하는 방법 대규모의 힌트를 제공하는 SQLite는 데 사용됩니다. 이 힌트는 정확하지는 않지만 종종 가깝습니다. 기본 VFS는 데이터베이스 파일에 대한 쓰기 속도를 높이기 위해이 힌트를 기반으로 데이터베이스 파일 공간을 사전 할당하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT의&lt;/a&gt; 연산 코드가 구현 그 메모리 VFS가 사용된다 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 이 상부 메모리 데이터베이스의 크기에 바인딩 설정한다. 인수는 &lt;a href=&quot;int64&quot;&gt;sqlite3_int64에&lt;/a&gt; 대한 포인터 입니다. 가리키는 정수가 음수이면 현재 한계로 채워집니다. 그렇지 않으면 한계는 지정된 정수 값과 현재 데이터베이스 크기보다 크게 설정됩니다. 지정된 정수가 새로운 한계로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성하여 xSync 메소드가 호출되지 않은 경우 xSync 메소드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 마스터 저널 파일 이름을 포함하는 널 종료 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출하면 안됩니다 이 opcode를 사용하면이를 요구하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca40036ed80ac456626498e6b097f64ffd5f3c6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성했기 때문에 xSync 메서드가 호출되지 않은 경우 xSync 메서드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 수퍼 저널 파일 이름을 포함하는 널로 끝나는 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 조용히 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출해서는 안됩니다. 이 opcode를 사용하면이를 필요로하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE의&lt;/a&gt; 파일 제어는 SQLite는 스택의 상위 계층이 무엇을하고 있는지에 대한 VFS에 자문 정보를 제공합니다. 이 파일 제어는 일부 VFS 활동 추적 &lt;a href=&quot;../vfs#shim&quot;&gt;shim에서&lt;/a&gt; 사용됩니다 . 인수는 0으로 끝나는 문자열입니다. &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; 컴파일 타임 옵션이 활성화 된 경우 SQLite 스택의 상위 계층에서이 파일 컨트롤의 인스턴스를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME의&lt;/a&gt; 오피 모든 이름 얻기 위해 사용될 수있다 &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; VFS에 스택한다. 이름은 모든 VFS 심의 이름이며 최종 하위 레벨 VFS는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록되며 결과는 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수가 가리키는 char * 변수에 저장 됩니다. 호출자가 완료되면 메모리를 확보해야합니다. 모든 파일 제어 작업과 마찬가지로 실제로이 작업이 수행 될 것이라는 보장은 없습니다. 이 파일 제어가 구현되지 않은 경우 호출자는 char * 변수를 NULL 포인터로 초기화해야합니다. 이 파일 제어는 진단 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 연산 코드 최상위에 대한 포인터 발견 &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; 현재 사용합니다. sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X)의 인수 X는 &quot; &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; 유형이어야합니다 . 이 opcode는 * X를 최상위 VFS의 포인터로 설정합니다. 스택에 여러 VFS 심이있는 경우이 opcode는 최상위 심만 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK는&lt;/a&gt; 로크가 바로 사용할 수없는 경우가 다음 WAL 로크에 차단하는 것이 유리할 수 있다는 VFS 계층 신호이다. WAL 하위 시스템은 우선 순위 반전 문제를 해결하기 위해 드문 상황에서이 신호를 발행합니다. 응용 프로그램은 이 파일 제어를 사용 &lt;em&gt;하지 않아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY의&lt;/a&gt; 연산 코드는 특정 디스크에 대한 자동 재시도 횟수와 간격을 구성하는 데 사용되는 윈도우에 대한 I / O 작업 &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;안티 바이러스 프로그램이있을 때 견고성을 제공합니다. 기본적으로, Windows VFS는 파일 다시 읽기, 파일 쓰기 및 파일 삭제 조작을 최대 10 번까지 다시 시도하며, 첫 번째 재시도 전에 25 밀리 초의 지연이 발생하며 이후의 재 시도마다 25 밀리 초씩 지연됩니다. 이 opcode를 사용하면이 두 값 (재시도 10 회 및 25 밀리 초 지연)을 조정할 수 있습니다. 동일한 프로세스 내의 모든 데이터베이스 연결에 대한 값이 변경됩니다. 인수는 첫 번째 정수가 새 재시도 횟수이고 두 번째 정수가 지연되는 두 정수 배열에 대한 포인터입니다. 정수 중 하나가 음수이면 설정이 변경되지 않고 대신 해당 설정의 이전 값이 배열 항목에 기록되어 현재 재시도 설정을 조사 할 수 있습니다.zDbName 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE의&lt;/a&gt; 연산 코드는 파일 핸들과 관련된 기본 기본 파일 핸들을 얻을 수 있습니다. 이 파일 컨트롤은 인수를 기본 파일 핸들에 대한 포인터로 해석하여 결과 값을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 파일 핸들을 pArg 인수가 가리키는 핸들과 교체하도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST가 정의 된 경우에만 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS의&lt;/a&gt; 오피은 zipvfs에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE는&lt;/a&gt; TEMP 데이터베이스 및 일지, 과도 데이터베이스 및 subjournals 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 항상 함께 사용됩니다 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE의&lt;/a&gt; 모두 POSIX 개방 () API의 O_EXCL과 O_CREAT 플래그에 직접적으로 유사하다 플래그입니다. SQLITE_OPEN_CREATE와 함께 사용될 때 SQLITE_OPEN_EXCLUSIVE 플래그는 파일이 항상 작성되어야하며 파일이 이미 존재하는 경우 오류임을 표시하는 데 사용됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h 헤더 의 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C 전 처리기 매크로는 &quot;XYZ&quot;형식의 SQLite 버전 인 문자열 리터럴로 평가합니다. 여기서 X는 주 버전 번호 (항상 SQLite3의 경우 3)이고 Y는 부 버전 번호이고 Z는 릴리스 번호 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C 전처리 값을 갖는 정수 매크로 리졸 (X + Y * 1000000 * 1000 + Z) X, Y 및 Z가 사용되는 동일한 숫자 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; . 지정된 SQLite 릴리스에 대한 SQLITE_VERSION_NUMBER도 파생 된 릴리스보다 큽니다. Y는 일정하게 유지되고 Z는 증가하거나 그렇지 않으면 Y는 증가하고 Z는 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스에 호출하여 이전 등록 된 초기화 루틴 X 등록 취소 &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension (X)를&lt;/a&gt; . &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 으로 돌아 간다 (1) 초기화 루틴의 X 성공적으로 등록했다 경우 X 초기화 루틴의 목록에없는했다 경우 0 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="translated">&lt;a href=&quot;carray&quot;&gt;carray 테이블 반환 함수는&lt;/a&gt; 응용 프로그램에서 C 언어 값의 배열에 대한 포인터를 받아 들일 필요가있다.</target>
        </trans-unit>
        <trans-unit id="467a3e3add4e8f323509cb384ea9db3beaf1960c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; omits the first NUL character and all subsequent text in the SQL output that it generates. In fact, the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; omits everything past the first NUL character in all contexts.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 의 &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; 명령은 생성하는 SQL 출력에서 ​​첫 번째 NUL 문자와 모든 후속 텍스트를 생략합니다. 실제로 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 는 모든 컨텍스트에서 첫 번째 NUL 문자 이후의 모든 것을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="99b9d11b0a4071822aa18a343a895720b0d0af06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command now accepts multiple LIKE-pattern arguments and outputs the union of all matching tables.</source>
          <target state="translated">&lt;a href=&quot;cli#dump&quot;&gt;.dump의&lt;/a&gt; 명령이 여러 LIKE 패턴 인수를 받아, 모든 매칭 테이블의 조합을 출력한다.</target>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; 컴파일시 옵션은 새 데이터베이스에 할당 된 기본 페이지 크기를 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE는&lt;/a&gt; 1024에서 4096로 증가 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE는&lt;/a&gt; 같은 크기의 캐시 메모리가 기본적으로 사용되도록 -2000 2000에서 변경됩니다. 자세한 정보 는 &lt;a href=&quot;pgszchng2016&quot;&gt;버전 3.12.0 페이지 크기 변경에&lt;/a&gt; 대한 애플리케이션 노트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 컴파일시 옵션은 페이지 캐시 바이 패스 오버 플로우 페이지의 내용을 읽을 때에 SQLite는 발생합니다. 이를 통해 10K Blob의 데이터베이스 읽기 속도가 약간 빨라지지만 훨씬 빠르지는 않습니다. SQLite는 여전히 SQLITE_DIRECT_OVERFLOW_READ 컴파일 타임 옵션이없는 직접 파일 시스템 읽기보다 속도 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS은&lt;/a&gt; 컴파일 시간 옵션은 현재 표준에 기본적으로 설정되어 빌드.</target>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 컴파일시 옵션은이 원인 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 더 나은 도움말 SQLite는에, 각 인덱스의 작은 히스토그램을 수집 경쟁 범위 질의 지표 중에서 선택 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt; 정규 소스 파일에서 빌드 할 때 컴파일시 옵션은 작동합니다. SQLite &lt;a href=&quot;amalgamation&quot;&gt;통합&lt;/a&gt; 또는 사전 처리 된 소스 파일에서 빌드 할 때는 작동 하지 &lt;u&gt;않습니다&lt;/u&gt; .</target>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="translated">&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT의&lt;/a&gt; 옵션은 쿼리 계획을 고려하는 것이 인덱스 앤 제약 조합의 최대 번호에 대한 초기 기본 값을 설정합니다. 기본 조인 계획자 한계는 조인의 각 테이블을 처리하기 전에 SQLITE_QUERY_PLANNER_LIMIT_INCR에 의해 증가되어 각 테이블이 조인의 이전 테이블이 소진 된 경우에도 옵티 마이저에 최소한 일부 인덱스 및 제약 조건 조합을 제안 할 수 있습니다. 기준선 한도. 이 컴파일 시간 옵션과 &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; 옵션 모두에 대한 기본값 은 실제 쿼리에 도달 할 수 없도록 충분히 높게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="translated">&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 컴파일시 옵션을 확인하면 내용도 삭제되었는지 확인하기 위해 고정 &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;잘라 내기 최적화가&lt;/a&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 파라미터 값이 0에서 3까지의 정수이다 #define 값이다. &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수 의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 시간 옵션의 길이를 제한하기 위해 사용될 수있는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;결합 된 파라미터&lt;/a&gt; sqlite3_trace의 출력 확장 ().</target>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT의&lt;/a&gt; 컴파일시 옵션은 바인딩 매개 변수 확장의 크기를 제한합니다. &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE의&lt;/a&gt; 컴파일시 옵션 원인 sqlite3_expanded_sql ()는 항상 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d80a700ed456a052f14722da1654635b16877833" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option will cause this setting to default to OFF.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt; 컴파일시 옵션이 설정이 OFF로 기본 설정하게됩니다.</target>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) 인터페이스 sqlite3_pcache_methods2 구조체의 인스턴스를 전달하여 다른 페이지의 캐시 구현을 등록 할 수있다. 많은 응용 프로그램에서 SQLite에 의해 할당 된 대부분의 힙 메모리는 페이지 캐시에 사용됩니다. 이 API를 사용하여 사용자 정의 페이지 캐시를 구현함으로써, 애플리케이션은 SQLite가 소비하는 메모리의 양, 메모리가 할당 및 해제되는 방식, 데이터베이스 파일의 어떤 부분이 정확하게 캐시되는지를 결정하는 데 사용되는 정책을보다 잘 제어 할 수 있습니다. 얼마나 오래.</target>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="translated">는 &lt;a href=&quot;eqp&quot;&gt;QUERY 계획 EXPLAIN&lt;/a&gt; A의 각 루프에 의해 생성 된 행의 추정 가입 출력 더이상 보여준다.</target>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를위한 방법 xFileControl 직접 호출한다 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 두 번째 인수에 의해 식별되는 특정 데이터베이스와 연관된 객체. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 데이터베이스의 경우 &quot;temp&quot;이거나 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 추가 된 데이터베이스의 AS 키워드 뒤에 나타나는 이름입니다 . &quot;main&quot;대신 NULL 포인터를 사용하여 기본 데이터베이스 파일을 참조 할 수 있습니다. 이 루틴에 대한 세 번째 및 네 번째 매개 변수는 xFileControl 메소드의 두 번째 및 세 번째 매개 변수로 직접 전달됩니다. xFileControl 메소드의 리턴 값은이 루틴의 리턴 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="translated">SQLite 데이터베이스 의 &lt;a href=&quot;fileformat2&quot;&gt;기본 파일 형식&lt;/a&gt; 은 호환되지 않는 방식으로 변경되지 않습니다. 문자 그대로 수십억 개, 아마도 1 조 개에 달하는 SQLite 데이터베이스 파일이 유통되고 있으며 SQLite 개발자는 수십 년 동안이 파일을 지원하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#validfor&quot;&gt;버전 유효-에 대한 수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL 파일 형식은&lt;/a&gt; 정확하게 정의 및 크로스 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="d24509e4b9939bc43b94f948e05ab88b6b7e58c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; and the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; are built-in to the CLI</source>
          <target state="translated">&lt;a href=&quot;floatingpoint#decext&quot;&gt;진수 확장&lt;/a&gt; 과 &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;IEEE754 확장&lt;/a&gt; 내장되어있는 CLI에</target>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;상위 키&lt;/a&gt; (A)의 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건은&lt;/a&gt; ROWID를를 사용할 수 없습니다. 부모 키는 명명 된 열만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH 연산자로 포인터 전달 &lt;a href=&quot;fts3#snippet&quot;&gt;니펫 ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋 ()&lt;/a&gt; 과 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4이 명령은 &quot;다시&quot;&lt;/a&gt; 전체 전체 텍스트 인덱스를 삭제하고 내용 테이블에있는 문서의 현재 설정을 기반으로 다시 작성합니다. &quot;t3&quot;이 외부 컨텐츠 FTS4 테이블의 이름이라고 다시 가정하면, 재 빌드 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수는 항상 NULL을 반환하지 않는 중 하나를 사용하여 활성화 된 인터페이스 레거시 응용 프로그램 정의 FTS3의 tokenizers &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ) 설정, 또는 fts3_tokenizer에 첫 번째 인수 ()가 아닌 경우 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인딩 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="translated">&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH의&lt;/a&gt; 운영자는 내장 전체 텍스트 인덱스를 기반으로 쿼리 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'X'플래그는&lt;/a&gt; 문구 &quot;A&quot;와 &quot;C&quot;에 대한 하나의 타격을보고있다. 그러나 'y'지시문은 문서와 일치하지 않는 하위 표현식의 일부이므로 &quot;c&quot;에 대한 적중 횟수를 0으로보고합니다 (b AND c). OR 연산자에서 내림차순 AND 연산자를 포함하지 않는 쿼리의 경우 'y'에 의해 반환되는 결과 값은 항상 'x'에 의해 반환 된 결과 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 기능은&lt;/a&gt; , &lt;a href=&quot;fts3#snippet&quot;&gt;스 니펫 ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋 ()&lt;/a&gt; , 및 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()는&lt;/a&gt; 전체 텍스트 쿼리를 지원하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;조각의&lt;/a&gt; 기능은 위의 쿼리와 함께 사용할 수 없습니다. 외부 쿼리에는 &quot;WHERE ... MATCH&quot;절이 포함되어 있지 않으므로 스 니펫 함수와 함께 사용할 수 없습니다. 한 가지 해결책은 외부 쿼리에서 하위 쿼리에 사용 된 WHERE 절을 복제하는 것입니다. 이와 관련된 오버 헤드는 일반적으로 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; 토크 나이는 지금에 포함되어 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;BM25 () 보조 기능은&lt;/a&gt; 현재 매치의 정확성을 반영 실제 값을 반환한다. 더 나은 일치는 수치 적으로 낮은 값으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;ColumnSize가&quot;옵션&lt;/a&gt; FTS5 테이블의 각 값의 토큰의 크기가 데이터베이스 내에서 별도로 저장할지 여부를 구성하는 데 사용.</target>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;세부 사항&quot;옵션&lt;/a&gt; . 이 옵션을 사용하면 일부 정보를 생략하여 디스크의 FTS 인덱스 크기를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="translated">&lt;a href=&quot;fts5#the_highlight_function&quot;&gt;하이라이트 () 보조 기능&lt;/a&gt; 복귀 예컨대 지정된 태그 (둘러싸인 결과 내의 질의 용어의 각 인스턴스는 현재 매치의 열 중 하나의 텍스트 복사 &quot;&amp;lt;B&amp;gt;&quot;및 &quot;&amp;lt;/ B&amp;gt;&quot; ).</target>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;니펫 () 함수는 보조&lt;/a&gt; 정합 행 및 질의 용어의 각 인스턴스를 반환하여 하이라이트 () 함수와 같은 방식으로 마크 업에 의해 둘러싸여의 열 중 하나의 텍스트의 짧은 단편을 선택한다. 포함 된 쿼리 용어의 수를 최대화하기 위해 텍스트 조각이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;미국 퍼지 롭&lt;/a&gt; 또는 마이클 잘레 스키의 최근 (2014 년경) 혁신 fuzzer &quot;AFL&quot;. 무작위 입력을 맹목적으로 생성하는 대부분의 다른 퍼저와 달리 AFL 퍼 저는 테스트중인 프로그램을 계측하고 (C 컴파일러의 어셈블리 언어 출력을 수정하여) 입력을 통해 프로그램이 다른 작업을 수행하는시기를 감지하기 위해 해당 계측을 사용합니다. 새로운 제어 경로 또는 다른 횟수의 루프. 새로운 동작을 유발하는 입력은 유지되고 추가로 변경됩니다. 이러한 방식으로 AFL은 디자이너가 상상하지 못한 행동을 포함하여 테스트중인 프로그램의 새로운 행동을 &quot;발견&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석 DVCS는&lt;/a&gt; SQLite는 모든 소스 코드를 추적하는 데 사용되는 버전 관리 시스템입니다. Fossil 저장소는 SQLite 데이터베이스 파일입니다. 독자들은이 재귀를 독립적 인 연습으로 숙고하도록 초대받습니다. 화석은 SQLite의 버전 제어 시스템이자 SQLite의 테스트 플랫폼입니다. SQLite가 개선 될 때마다 Fossil은 이러한 개선 사항을 테스트하고 평가하는 최초의 응용 프로그램 중 하나입니다. 그래서 화석은 NGQP의 초기 채택 자였습니다.</target>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL 로직 테스트&lt;/b&gt;&lt;/a&gt; 또는 SLT 테스트 장치는 SQLite는 여러 다른 SQL 데이터베이스 엔진 모두에 대한 SQL 문의 거대한 수를 실행하고 그들이 모두 같은 답변을 얻을 수 있는지 확인하는 데 사용됩니다. SLT는 현재 SQLite를 PostgreSQL, MySQL, Microsoft SQL Server 및 Oracle 10g와 비교합니다. SLT는 1.12GB의 테스트 데이터로 구성된 720 만 개의 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="translated">웹킷에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; 인터페이스는 모든 웹 페이지가 Chrome 및 Safari 용 브라우저에서 임의의 SQL을 실행할 수 있도록 허용했습니다. 그 임의의 SQL은 악용 되더라도 해를 끼칠 수없는 샌드 박스 내에서 실행되어야했지만, 그 샌드 박스는 사람들보다 안전하지 않은 것으로 판명되었습니다. 2017 년 봄, 한 해커 팀은 긴 시퀀스의 익스플로잇을 사용하여 iMac을 루팅 할 수있었습니다. 그 중 하나는 WebSQL 인터페이스를 통해 실행되는 SQLite 데이터베이스의 snippet () FTS3 함수에 BLOB 값으로 전달 된 포인터를 손상시키는 것과 관련이있었습니다. 사파리 내부.</target>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;화석 분산 버전 관리&lt;/a&gt; 시스템은 하나있는 TAR, ZIP 아카이브, 또는 SQLite는 아카이브로 다운로드 체크인하는 옵션을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;추가] VFS는&lt;/a&gt; A는 &lt;a href=&quot;vfs#shim&quot;&gt;VFS 심&lt;/a&gt; SQLite는 데이터베이스가 다른 파일에 추가 할 수 있습니다. 이를 통해 데이터베이스를 실행 파일에 추가 한 다음 데이터베이스를 열고 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; introspecting과 데이터베이스에한데, btree의 크기를 추정 시조 가상 테이블.</target>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="translated">는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;확장 () 기억&lt;/a&gt; 이 통과 값을 기억하는 C 언어의 정수 변수에 대한 포인터를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c의&lt;/a&gt; 확장은 지속적으로 새로운 VFS 새로운 가상 테이블을 모두 등록하는 적재 가능한 확장의 일례를 도시한다. 해당 확장 의 &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init ()&lt;/a&gt; 초기화 루틴은 확장이 처음로드 될 때 한 번만 호출됩니다. 새로운 &quot;vfslog&quot;VFS를 한 번만 등록하고 &quot;vfslog&quot;VFS를 구현하는 데 사용되는 코드가 메모리에 남아 있도록 SQLITE_OK_LOAD_PERMANENTLY를 반환합니다. 초기화 루틴은 또한 &quot;vstatRegister ()&quot;함수에 대한 포인터에서 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 을 호출하여 모든 후속 데이터베이스 연결이 시작될 때 &quot;vstatRegister ()&quot;함수를 호출하고 &quot;vfsstat&quot;가상 테이블을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; 쉘 스크립트는 또한 정규 소스 트리에서 speedtest1.c 프로그램을 실행하는 데 사용됩니다. 성능 측정을 복제하려면 다음 파일을 단일 디렉토리로 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘에&lt;/a&gt; 대한 &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src / shell.c&lt;/a&gt; 소스 코드 는 더 이상 버전 제어를받지 않습니다. 이 파일은 이제 빌드 프로세스의 일부로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite는 화석 저장소는&lt;/a&gt; 타르볼, ZIP 아카이브, 또는 다운로드를위한 링크가 포함 &lt;a href=&quot;sqlar&quot;&gt;SQLite는 아카이브&lt;/a&gt; SQLite는 모든 역사적 버전을. 이러한 다운로드의 URL은 간단하며 자동화 된 도구에 쉽게 통합 될 수 있습니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON 표준&lt;/a&gt; JSON을 사용하여 지리 정보를 교환하기위한 구문이다. GeoJSON은 거의 모든 종류의 지리 공간 컨텐츠를 설명 할 수있는 풍부한 표준입니다.</target>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;화석 버전 제어 시스템은&lt;/a&gt; SQLite는의 printf () 구현의 초기 버전에서 파생 자신의 printf () 구현을 사용하지만, 그 두 가지 구현 이후 분기있다.</target>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 버전 제어 시스템 (설계 및 SQLite는 개발을 지원하기위한 목적으로 작성)은 약간 문제 티켓 보고서를 생성하는 임의의 SQL를 입력하도록 사용자를 신뢰할 수있게. &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 SQL을 삭제 하고 익스플로잇을 찾지 못했습니다. 그러나 이것은 잠재적으로 적대적인 에이전트가 시스템에 임의의 SQL을 주입 할 수있는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하는 T 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 변수는 T 매개 변수가 X 번째 루프가 실행 된 총 횟수로 설정됩니다에 의해 지적했다.</target>
        </trans-unit>
        <trans-unit id="ffcdafee896254e841c8ceef0c82d886514030ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하기 V 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="c0533f74a6fe1362e5ed7a748ce1c72de0f80c71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; V 자 파라미터가 가리키는 변수는 X 번째 루프가 실행 된 총 횟수로 설정한다.</target>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="translated">이 웹 사이트 의 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;내부 대 외부 BLOB&lt;/a&gt; 기사는 2011 년경의 초기 조사로, Jim 회색 종이와 같은 접근 방식을 사용합니다 (데이터베이스에 항목으로 BLOB 파일 이름을 저장) &amp;ndash; SQL Server 대신 SQLite에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="translated">&lt;a href=&quot;lang&quot;&gt;SQL 언어 문서를&lt;/a&gt; 사용하도록 변환되는 &lt;a href=&quot;syntaxdiagrams&quot;&gt;구문 도표&lt;/a&gt; 대신 BNF의를.</target>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE의&lt;/a&gt; 외래 키 제약 조건을 사용할 때 명령은 두 가지 측면에서 다르게 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="translated">는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 가 어떤 인덱스가없는 경우에도 명령은 이제 테이블에 대한 통계를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="translated">는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문이 두 개 이상의 데이터베이스가 동일한 데이터베이스 연결에 연관되어 그들이 하나의 데이터베이스 인 것처럼 작동 할 수 있도록하는 SQLite는 확장입니다. 동시에 접속 된 데이터베이스 수는 SQLITE_MAX_ATTACHED로 제한되며 기본적으로 10으로 설정됩니다. 연결된 데이터베이스의 최대 수는 125를 초과하여 증가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 절</target>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;IFNULL ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;유착 ()&lt;/a&gt; SQL 함수는 사용되지 않은 인수가 평가되지 않을 필요가 그래서, 인라인 VDBE 코드를 사용하기보다는 외부 함수를 호출 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="b195fd330fb530068f989ff0d4930e52e4333b6b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#length&quot;&gt;length() SQL function&lt;/a&gt; only counts characters up through and excluding the first NUL.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#length&quot;&gt;길이 () SQL 함수는&lt;/a&gt; 첫 번째 NUL 통해 제외하고 최대 문자 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c97e1aa1d73b591cf5ec83039aad0924cf633432" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; is subject to the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; limit of &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. Hence any printf() result with a width or precision more than the SQLITE_LIMIT_LENGTH will cause an &lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; error. However, the low-level formatting for the printf() function is done by a subroutine that does not have access to SQLITE_LIMIT_LENGTH. So the low-level formatting is done into a memory allocation that might be considerably larger than SQLITE_LIMIT_LENGTH and the SQLITE_LIMIT_LENGTH check is only performed after all formatting is complete. Thus there might be a transient buffer that exceeds SQLITE_LIMIT_LENGTH. The SQLITE_PRINTF_PRECISION_LIMIT option is an additional check that prevents excess sizes for the transient buffer used inside the low-level formatting subroutine, prior to the SQLITE_LIMIT_LENGTH check.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;의 printf () 함수는 SQL&lt;/a&gt; 받는 될 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH의&lt;/a&gt; 한계 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; . 따라서 너비 또는 정밀도가 SQLITE_LIMIT_LENGTH보다 큰 printf () 결과는 SQLITE_TOOBIG를 발생 &lt;a href=&quot;rescode#toobig&quot;&gt;시킵니다.&lt;/a&gt;오류. 그러나 printf () 함수에 대한 하위 레벨 형식화는 SQLITE_LIMIT_LENGTH에 대한 액세스 권한이없는 서브 루틴에 의해 수행됩니다. 따라서 로우 레벨 포맷은 SQLITE_LIMIT_LENGTH보다 상당히 클 수있는 메모리 할당으로 수행되고 SQLITE_LIMIT_LENGTH 검사는 모든 포맷이 완료된 후에 만 ​​수행됩니다. 따라서 SQLITE_LIMIT_LENGTH를 초과하는 임시 버퍼가있을 수 있습니다. SQLITE_PRINTF_PRECISION_LIMIT 옵션은 SQLITE_LIMIT_LENGTH 검사 전에 하위 수준 서식 지정 서브 루틴 내에서 사용되는 임시 버퍼의 초과 크기를 방지하는 추가 검사입니다.</target>
        </trans-unit>
        <trans-unit id="96634860ea9e8b060f6a1b99af9b163a5a4df212" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; only shows characters up through and excluding the first NUL.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#quote&quot;&gt;따옴표 () SQL 기능&lt;/a&gt; 만을 통해 첫 번째 NUL을 제외한 모든 문자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#random&quot;&gt;임의 ()&lt;/a&gt; 는 다른 대답을가 호출 될 때마다 제공하기 때문에 기능은 분명히 비 결정적이다. &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid ()&lt;/a&gt; 의 답변은 이전 SQL 문에 의존하므로 결정적이지 않습니다. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version ()&lt;/a&gt; 함수는 대부분 일정이지만, 항상 특정 세션에 대해 같은 대답을 반환하지만 그것은 여전히 비 결정적으로 간주됩니다 세션에서 답변을 변경할 수 있기 때문에, 그래서 심지어 SQLite는이 업그레이드 될 때 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 함수는 B 트리 스토리지 엔진에 새로운 인터페이스의 새로운 연산 코드가 필요 &lt;a href=&quot;opcode&quot;&gt;가상 머신&lt;/a&gt; 이 실행이 문을 SQL 것을, 및 코드 생성기의 중요한 경로에 새로운 조건을. sqlite_offset (X)의 유틸리티가 필요하지 않은 응용 프로그램의 오버 헤드를 피하기 위해이 기능은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#substr&quot;&gt;SUBSTR ()&lt;/a&gt; 는 단지 프리픽스를 계산하는 경우 SQL 함수 길이를 전체 입력 문자열을 측정하는데 귀찮게하지 않는다</target>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid 테이블 의 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; (있는 경우)는 기본 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 스토리지 엔진 에서 사용하는 고유 키가 아니라는 점에서 일반적으로 테이블의 실제 기본 키가 아닙니다 . 이 규칙의 예외는 rowid 테이블이 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY를&lt;/a&gt; 선언 할 때 입니다. 예외적으로 INTEGER PRIMARY KEY는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 별명이됩니다 .</target>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; ROWID 테이블의 읽기 또는 &quot;ROWID&quot;또는 &quot;OID&quot;또는 &quot;_ROWID_&quot;열 중 쓰기 액세스하거나 변경할 수 있습니다. 테이블에 특수 이름을 사용하는 선언 된 열이있는 경우를 제외하고 해당 이름은 기본 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid가&lt;/a&gt; 아니라 선언 된 열을 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="translated">테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 는 정수 여야합니다. 세트에 시도 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 의 정수 (또는 자동으로 사용 가능한 다음 정수 ROWID로 변환됩니다 NULL) 이외의 아무것도를 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW를 CREATE&lt;/a&gt; 문은 이제보기 이름 다음에 열 이름의 선택적 목록을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; ( '지금') JULIANDAY (예) 항상 같은 내에서 여러 함수 호출에 대해 동일 현재 시간이되도록 개선된다 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;QUERY PLAN EXPLAIN&lt;/a&gt; SQL을 명령 SQLite는 특정의 SQL 쿼리를 구현하는 데 사용하는 전략이나 계획에 대한 높은 수준의 기술을 취득하기 위해서 사용된다. 가장 중요한 것은 EXPLAIN QUERY PLAN이 쿼리가 데이터베이스 인덱스를 사용하는 방식을보고합니다. 이 문서는 EXPLAIN QUERY PLAN 출력을 이해하고 해석하기위한 안내서입니다. 배경 정보는 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="translated">SQL 문에 대한 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 및 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN 접&lt;/a&gt; 두부는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 동안 명령문의 작동에만 영향을줍니다 . 이는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 중에 적용되는 PRAGMA 문이 &quot;EXPLAIN&quot;으로 시작하는지 여부에 관계없이 동일한 방식으로 작동 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="translated">&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="translated">는 &lt;a href=&quot;lang_expr#isisnot&quot;&gt;운영자 IS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS 운영자는&lt;/a&gt; 현재 인덱스를 구동 할 수있다.</target>
        </trans-unit>
        <trans-unit id="b253f85844781796ef1ae81936dfc99cf231cc5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator now overrides wildcard characters, so that the behavior matches what PostgreSQL does.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 의 &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; 절은 이제 와일드 카드 문자를 재정의하므로 동작이 PostgreSQL이 수행하는 것과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;인덱스 BY의&lt;/a&gt; 절</target>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="translated">는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 보류중인 트랜잭션이없는 경우 명령은 트랜잭션 스택이 비어있는 경우 작동, 또는 다른 말로. &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 명령이 호출 될 때 트랜잭션 스택이 비어 있지 않으면 명령이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="translated">는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령은 트랜잭션이 스택 비어 않은 모든 거래와 잎을 얻어냅니다.</target>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령이 대기중인 쿼리가있는 경우에도 성공합니다. 보류중인 증분 BLOB I / O 요청이있는 경우 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 모든 거래와 잎은 트랜잭션이 스택 비어 A를 절 롤 백없이 명령.</target>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;업데이트&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; 및 &lt;a href=&quot;lang_insert&quot;&gt;삽입&lt;/a&gt; 트리거 내에서 문의 전체 구문을 지원하지 않는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_insert&quot;&gt;INSERT의&lt;/a&gt; 문. 다음 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령은 1 % 엄격한에 대한 데이터베이스를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령의 설정 보존 &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그를&lt;/a&gt; . (티켓 # 2804)</target>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령은 임시 파일을 만든 다음 그 임시 파일에 전체 데이터베이스를 재 구축하여 작동합니다. 그런 다음 임시 파일의 내용이 원래 데이터베이스 파일로 다시 복사되고 임시 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; 절은 첫 번째 SELECT에 발생해야 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; . &lt;a href=&quot;syntax/compound-operator&quot;&gt;복합 연산자를&lt;/a&gt; 따를 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기는&lt;/a&gt; 빠른 파서를 생성한다.</target>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 문서는 방법에 대해 설명 &lt;a href=&quot;loadext#build&quot;&gt;로드 가능한 확장 컴파일&lt;/a&gt; 공유 라이브러리 등을. 거기에 설명 된 기술은 json1 모듈에 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스에 메시지를 기록 &lt;a href=&quot;../errlog&quot;&gt;오류 로그&lt;/a&gt; 에 의해 설립 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; 에 옵션 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; . 로깅이 사용 가능한 경우 zFormat 문자열 및 후속 인수는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 와 함께 사용되어 최종 출력 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4883693c0c81d8dd1cc3d7c0223f243712aeaf0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is enhanced to support two separate memory pools with different sized allocations in each pool. This allows more memory allocations to be covered by lookaside while at the same time reducing the heap memory usage to 48KB per connection, down from 120KB.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;룩어 메모리 할당은&lt;/a&gt; 각각의 풀에서 다른 크기의 할당을 가진 두 개의 메모리 풀을 지원하도록 개선된다. 이를 통해 더 많은 메모리 할당을 lookaside로 처리하는 동시에 힙 메모리 사용량을 120KB에서 연결 당 48KB로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;를 lookaside 메모리 할당&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="translated">페이지 &lt;a href=&quot;malloc#pagecache&quot;&gt;캐시 메모리 할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 뛰어난 (malloc으로 할당하지만 해제) 메모리의 바이트 수. &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 루틴 반환의 최대 값 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 하이 워터 마크 보낸 사람을 마지막으로 재설정 한. 반환하는 값 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()는&lt;/a&gt; 모든 오버 헤드의 구현으로 SQLite는 추가 포함 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 하지만 오버하는 모든 기본 시스템 라이브러리 루틴 추가하지 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; 인터페이스는이 정수 상수들 중 하나 인 하나의 인수를 취하는.</target>
        </trans-unit>
        <trans-unit id="6bac46a1cfe1872e452f2e80ec2bbd9faeb289c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; document has more information on the bytecode format used by SQLite, and how to view and interpret an SQLite prepared statement.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;바이트 코드 엔진&lt;/a&gt; 문서보기로 바이트 코드 SQLite는에 의해 사용되는 형식 및 방법에 대한 자세한 정보를 가지고 있으며, SQLite는 문을 준비 해석한다.</target>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 코드 생성기에 의해 생성 프로그램은 가상 머신에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="translated">&lt;a href=&quot;opcode#Delete&quot;&gt;삭제는&lt;/a&gt; 이 루프의 작업을 수행합니다; 스택에서 정수 키를 꺼내고 (앞의 ListRead에 의해 배치됨) 해당 키가있는 커서 P1의 레코드를 삭제합니다. P2가 true이므로 행 변경 카운터가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Ge&quot;&gt;게르마늄&lt;/a&gt; 작업자는 상부를 스택에 두 요소들을 비교 팝하고 분기 비교 결과에 기초. 두 번째 요소가 최상위 요소보다 크거나 같으면 주소 P2 (루프 끝의 다음 명령어)로 이동합니다. P1이 true이므로 피연산자 중 하나가 NULL (결과가 NULL)이면 점프를 수행합니다. 우리가 점프하지 않으면 다음 지시로 넘어가십시오.</target>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="translated">&lt;a href=&quot;opcode#Gosub&quot;&gt;GOSUB의&lt;/a&gt; 오피 P1 저장 레지스터에 현재 프로그램 카운터는 어드레스 P2로 이동합니다. &lt;a href=&quot;opcode#Return&quot;&gt;반환&lt;/a&gt; 오피 코드는 주소 P1 + 1로 이동합니다. 따라서 모든 서브 루틴은 두 개의 정수, 즉 서브 루틴의 진입 점 주소와 리턴 주소를 보유하는 데 사용되는 레지스터 번호와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#Goto&quot;&gt;고토&lt;/a&gt; 루프의 처음으로 다시 이동합니다. 이것이 루프의 끝입니다.</target>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead의&lt;/a&gt; 명령어는 임시 저장리스트로부터 요소를 판독하고, 스택에 넘겨 준다. 이것이 성공하면 다음 명령으로 계속 진행됩니다. 리스트가 비어 있기 때문에 이것이 실패하면 P2로 분기되는데, 이는 루프 바로 다음의 명령어입니다. 그 후 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset의&lt;/a&gt; 명령은 임시 저장 목록을 비 웁니다. 이 목록은 VDBE 프로그램이 종료되면 자동으로 비워 지므로이 경우에는 필요하지 않습니다. 닫기 명령은 커서 P1을 닫습니다. 이 과정은 VDBE 엔진이이 프로그램 실행을 마치면 수행됩니다. 커밋은 현재 트랜잭션을 성공적으로 종료하고이 트랜잭션에서 발생한 모든 변경 사항이 데이터베이스에 저장되도록합니다. 마지막 Halt도 실행할 준비가되면 모든 VDBE 프로그램에 추가되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind의&lt;/a&gt; 명령은 처음에 임시 저장 목록을 되감기. 이를 통해 두 번째 루프에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;다음의&lt;/a&gt; 연산 코드는 다음과 같은 경우에만 유효 &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 에 커서를 위치 시키는데 사용될 오피. &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 은 &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; 를 따라갈 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists의&lt;/a&gt; 명령은 상위 스택 요소 나타나고 정수 키로 사용한다. 해당 키가있는 레코드가 테이블 P1에 없으면 P2로 이동하십시오. 레코드가 존재하면 다음 명령어로 넘어갑니다. 이 경우 P2는 루프 끝에서 Goto로 이동하여 처음에는 ListRead로 되돌아갑니다. 이것은 루프 시작시 P2를 16으로, ListRead로 코딩하도록 코딩 될 수 있었지만이 코드를 생성 한 SQLite 파서는 그 최적화를하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists는&lt;/a&gt; 수행을 동일한 동작을 오피하지만으로 &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; P3 레지스터는 정수 값을 포함하도록 보장되어야한다. 이 opcode를 사용하면 레지스터 P3에 정수가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="translated">&lt;a href=&quot;opcode#NotFound&quot;&gt;NOTFOUND의&lt;/a&gt; 오피 코드를 수행한다 (임의의 다치 키) 인덱스한데, btree에 동일한 동작.</target>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Prev&quot;&gt;이전의&lt;/a&gt; 연산 코드는 다음과 같은 경우에만 유효 &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; , 또는 &lt;a href=&quot;opcode#Last&quot;&gt;마지막&lt;/a&gt; 커서 위치를 사용 오피 코드. &lt;a href=&quot;opcode#Prev&quot;&gt;이전&lt;/a&gt; 은 &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; 를 따를 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#Recno&quot;&gt;RECNO의&lt;/a&gt; 스택 커서 P1 가리키는 테이블 순차 주사에서 현재 항목 키의 처음 4 바이트 정수 상 명령 푸시. &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite의&lt;/a&gt; 명령어는 임시 저장 목록으로 스택 상단의 정수를 기입 상단 요소 나옵니다. 이것은 삭제 될 레코드의 키를 저장하여 두 번째 루프에서 삭제할 수 있도록이 루프의 중요한 작업입니다. 이 ListWrite 명령 후 스택이 다시 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx의&lt;/a&gt; 오피은 P5 == 0 또는 P5 == OPFLAG_SEEKEQ와 P4가 P4_KEYINFO 오브젝트되고 사용될 수있다. 또한 P3 값은 동일한 커서 번호에 대해 다른 모든 &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; 또는 &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; 와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx의&lt;/a&gt; op 코드처럼 작동 &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; P1에 커서가 이미 동일한 B- 트리에 열려있는 경우 제 여부를 확인하는 것을 제외하고 있는지이 opcode 무 조작된다 없다. 즉, 커서가 이미 열려 있으면 다시 열지 마십시오.</target>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow의&lt;/a&gt; op 코드는 중지 할 바이트 코드 엔진 및 대응 발생 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 리턴 문안 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW를&lt;/a&gt; . &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; 를 호출하기 전에 바이트 코드 프로그램은 쿼리의 단일 행에 대한 결과를 일련의 레지스터에로드합니다. &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; 와 같은 C 언어 API 는 해당 레지스터에서 쿼리 결과를 추출합니다. 바이트 코드 엔진 은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에 대한 다음 호출 에서 &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; 다음에 다음 명령으로 재개됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 명령은 루프를 초기화 &quot;examp&quot;테이블을 반복하는. 커서 P1을 테이블의 첫 번째 항목으로 되감습니다. 이것은 커서를 사용하여 테이블을 반복하는 Column 및 Next 명령어에 필요합니다. 테이블이 비어 있으면 루프 바로 뒤의 명령 인 P2 (10)로 이동합니다. 테이블이 비어 있지 않으면 루프 본문의 시작 인 6시에 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; 오피 수행하는 동일한 동작뿐만 아니라, P3 레지스터 점프 항상 수행되는 경우에 정수가 아닌 값을 포함 할 수있다. 이 opcode에는 P3에 항상 정수가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="translated">&lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; op 코드는 레지스터 P1의 정수 값으로 프로그램 카운터의 값을 스왑. 이 opcode는 코 루틴을 구현하는 데 사용됩니다. 코 루틴은 종종 필요에 따라 콘텐츠를 가져 오는 하위 쿼리를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="db4abc1eb0c372a241642380d3b5ec05a20c9f32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; and &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; documents have further details on the algorithms SQLite uses to implement SQL statements and how it goes above choosing an appropriate algorithm for each individual SQL statement.</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;SQLite는 쿼리 계획&lt;/a&gt; 및 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 문서는 SQL 문을 구현하는 알고리즘 SQLite는 사용에 대한 자세한 내용을 가지고 있으며 각 개별 SQL 문에 대한 적절한 알고리즘을 선택 위에 어떻게되는지.</target>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 최적화 이제 생성 할 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스를&lt;/a&gt; 그 적절한 경우.</target>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화는&lt;/a&gt; 수술실 표현 또한 IN 표현으로 변환 된 경우에도 계속 허용됩니다. OR 최적화 사용이 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 출력 에 &lt;a href=&quot;eqp#or-opt&quot;&gt;더 명확하게 표시&lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA의 auto_vacuum는 = 증분&lt;/a&gt; 설정은 이제 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA의 compile_options은&lt;/a&gt; 이제 라이브러리를 생성 컴파일러의 버전 번호를 표시하는 시도를 명령.</target>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보관되어 있다고 가정 하고 pragma는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;ON PRAGMA의 defer_foreign_keys =&lt;/a&gt; 문은 이제 비활성화는 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;활동 제한,&lt;/a&gt; 외부 키에 있습니다.</target>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;프라그가 defer_foreign_keys&lt;/a&gt; 일시적으로 사용할 수에 관계없이 선언하는 방법의 연기에 모든 외래 키 제약 조건을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="be06db32b407171ea5432f85af4fdd64982ffbf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;database encoding&lt;/a&gt; is UTF-8.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;데이터베이스 인코딩은&lt;/a&gt; UTF-8이다.</target>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA의 function_list&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA의 module_list&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA의 pragma_list의&lt;/a&gt; 모든 기본적으로 빌드의 명령은 이제 사용할 수 있습니다. &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS를&lt;/a&gt; 사용하여 비활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; 프라그 마를는의에 디스크 표현에 대한 정보 제공 강화되는 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블을.</target>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check 프라그는&lt;/a&gt; 아웃 오브 오더의 ROWID를 검출하기 위해 강화된다.</target>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode은&lt;/a&gt; OFF, MEMORY, 또는 WAL 아니다</target>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = OFF의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 설정은이 메소드를 호출하기 전에 활성화되고 legacy_alter_table 값은이 방법이 완료 한 후에 복원된다. 새 가상 테이블 이름과 일치하도록 새도우 테이블의 이름을 바꿔야하는 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 사용하는 가상 테이블의 올바른 조작에 필요 합니다. legacy_alter_format이 해제 된 경우 xRename 메소드가 새도우 테이블의 이름을 변경하려고 시도 할 때마다 가상 테이블에 대해 xConnect 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4d57758d0157882a76f0628926b46c59a64bbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; is deactivated. It is now a no-op. In its place, the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is provided. The legacy_file_format pragma is deactivated because (1) it is rarely useful and (2) it is incompatible with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in schemas that have tables with both generated columns and descending indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format의 pragma는&lt;/a&gt; 비활성화됩니다. 이제는 작동하지 않습니다. 대신 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; 옵션 이 제공됩니다. legacy_file_format pragma는 (1) 거의 유용하지 않고 (2) 생성 된 열과 내림차순 인덱스가 모두있는 테이블이있는 스키마의 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 과 호환되지 않기 때문에 비활성화 됩니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count PRAGMA는&lt;/a&gt; 인상 또는 런타임에서이 한계를 절감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA의 mmap_size의&lt;/a&gt; 문에 사용되는 주소 공간의 양이 증가하지 않습니다 I 바이 하드 한계 설정 위 / O 메모리 매핑 &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE의&lt;/a&gt; 컴파일시 옵션도 sqlite3_config (에 2 번째의 인수로 하드 한계 설정 시작 시간 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA을 최적화&lt;/a&gt; 명령은 먼저 SQLite는 3.18.0 (2017년 3월 28일) 도입과 SQLite는 모든 이전 릴리스에 대한 조작은 행해지 지 않았다.</target>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA을 최적화&lt;/a&gt; 명령은 자동으로 필요에 따라 개별 테이블에 ANALYZE 실행됩니다. 권장되는 방법은 응용 프로그램이 각 데이터베이스 연결을 닫기 직전에 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 문 을 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="433dda316207c42123f3ff5f78471afdde0a76ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; is usually a no-op but it will occasionally run ANALYZE if it seems like doing so will be useful to the query planner. The &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma&lt;/a&gt; limits the scope of any ANALYZE command that the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; runs so that it does not consume too many CPU cycles. The constant &quot;400&quot; can be adjusted as needed. Values between 100 and 1000 work well for most applications.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;최적화 pragma는&lt;/a&gt; 보통 어떤 조합입니다 만 쿼리 계획에 도움이 될 것입니다 그렇게 보인다 경우가 가끔 ANALYZE 실행됩니다. &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma는&lt;/a&gt; 어떤의 범위는 것을 명령 ANALYZE 제한 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;최적화 프라그가&lt;/a&gt; 너무 많은 CPU 사이클을 소모 할 수 있도록 실행합니다. 상수 &quot;400&quot;은 필요에 따라 조정할 수 있습니다. 100에서 1000 사이의 값은 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정 OFF 아니다</target>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store의 pragma는&lt;/a&gt; 또한 임시 파일을 저장하는 위치의 결정에 영향을 정수 값을 갖는다. temp_store pragma의 값은 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보유되어 있다고 가정 하며 pragma는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma에서&lt;/a&gt; 요청한 경우 제외SQLite는 sqlite3_temp_directory가 가리키는 메모리를 해제하지 않습니다. 응용 프로그램이 해당 메모리를 비우기를 원하면 모든 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트가 소멸 된 후에 만 처리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; 프라그 마를 올바르게 결과 집합에서 자신의 열 이름을 설정</target>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그는&lt;/a&gt; SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA의 wal_checkpoint의&lt;/a&gt; 명령은 SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA의 writable_schema은 ON =&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; 인터페이스, 삽입, 업데이트 또는 삭제되는 행의 열 수를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; preupdate 콜백이 직접 삽입, 업데이트 또는 삭제 작업의 결과로 호출 된 경우 인터페이스를 반환 0; 또는 최상위 트리거에 의해 호출 된 삽입, 업데이트 또는 삭제의 경우 1; 또는 최상위 트리거에 의해 호출 된 트리거로 인한 변경에 대해서는 2; 기타 등등.</target>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 전에 각 호출되는 콜백 함수를 등록 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 데이터베이스 테이블에 동작. 단일 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 한 번에 최대 하나의 사전 업데이트 후크를 등록 할 수 있습니다 . &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()에 대한&lt;/a&gt; 각 호출 은 이전 설정보다 우선합니다. 사전 갱신 후크는 두 번째 매개 변수로 NULL 포인터를 사용하여 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 을 호출하여 사용 불가능합니다 . &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 의 세 번째 매개 변수는 콜백에 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트 된 후 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_INSERT 및 SQLITE_UPDATE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_DELETE 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new ()는&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; 및 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; 인터페이스는 preupdate 이벤트에 관한 추가 정보를 제공한다. 이 루틴은 사전 업데이트 콜백 내에서만 호출 할 수 있습니다. 사전 갱신 콜백 외부에서 또는 사전 갱신 콜백에 제공된 것과 다른 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터를 사용하여 이러한 루틴을 호출하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트되기 전에 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_UPDATE 및 SQLITE_DELETE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_INSERT 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;쿼리 계획 체크리스트는&lt;/a&gt; 애플리케이션 개발자가 해결하는 데 도움이 쿼리 계획 문제를 다음해야하는 단계에 대해 설명합니다. INDEXED BY를 사용하는 것은 최후의 수단이며 다른 모든 측정이 실패한 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; 읽기가 이전 스냅 샷에 있기 때문에 읽기 트랜잭션이 쓰기 트랜잭션으로 업그레이드 할 수없는 경우 확장 오류 코드는 WAL 모드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 임의의 값이 변경되지 않는 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 온 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 재설정 &lt;a href=&quot;stmt&quot;&gt;준비된 문은&lt;/a&gt; 그 프로그램의 시작 부분에 다시 S.</target>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-트리 확장은&lt;/a&gt; 또 다른 준비된 문이 적극적으로 R-트리를 읽는 동안 시도는 R-트리를 업데이트되어이 결과 코드를 반환합니다. R-Tree를 변경하면 노드의 전환 및 재조정이 필요할 수 있으며, 이로 인해 읽기 커서가 중단되어 일부 행이 반복되고 다른 행이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b6d7c356a19c81f66c0c808b762014df51dab6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; supports shared-cache read and write locks in the same way as all other database tables (see description above). The following special rules also apply:</source>
          <target state="translated">&lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블&lt;/a&gt; 다른 모든 데이터베이스 테이블과 동일한 방법으로 공유 캐시 읽기 지원 및 쓰기 잠금 (위 설명 참조). 다음 특수 규칙도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; API를 작성하고 변경 집합의 내용을 반복하는 반복자를 초기화하기 위해 호출됩니다. 처음에는 반복자가 요소가 없음을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;권한 부여 콜백 기능&lt;/a&gt; 중 하나를 반환해야 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 작업이 허용되는지 여부를 SQLite는 신호하기 위해 또는이 두 상수 중 하나를. 추가 정보 는 &lt;a href=&quot;set_authorizer&quot;&gt;권한 부 여자 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스는 특정 SQL 문 작업 권한을 부여하기 위해 호출되는 콜백 함수를 등록합니다. 콜백의 두 번째 매개 변수는 권한이 부여되는 조치를 지정하는 정수 코드입니다. 이것은 권한 부 여자 콜백이 전달 될 수있는 정수 조치 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 에 성공적으로 호출에서 반환 된 개체 &lt;a href=&quot;snapshot_get&quot;&gt;() sqlite3_snapshot_get를&lt;/a&gt; 사용하여 해제해야 &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free을 ()&lt;/a&gt; 메모리 누수를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; 인터페이스 파괴한다 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.이 응용 프로그램은 결국 모든 해제해야합니다 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 메모리 누수를 방지하기 위해이 루틴을 사용하여 객체를.</target>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; 인터페이스 시도는 새로운 만들 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 기록 데이터베이스 연결 D.에 성공의 스키마 S의 현재 상태는 것을 객체를 &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get는 (D, S는 P)&lt;/a&gt; 인터페이스가 새로 생성에 대한 포인터를 기록 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 오브젝트를 * P로 가져오고 SQLITE_OK를 리턴합니다. 이 함수가 호출 될 때 스키마 S에 읽기 트랜잭션이 아직 열려 있지 않은 경우 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 인터페이스 중 하나는 새로운 읽기 트랜잭션을 시작 또는 스키마 S에 대한 기존의 것을 업그레이드 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 읽기 트랜잭션이 역사를 의미하도록 D &lt;a href=&quot;snapshot&quot;&gt;스냅 샷&lt;/a&gt; 이 아니라 데이터베이스에 대한 가장 최근의 변화보다, P. &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스 반환 성공 또는 적절한에 SQLITE_OK &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1의&lt;/a&gt; 확장은 선택적으로 각 INSERT에 대한 ROWID를 지정할 수있는 응용 프로그램을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="translated">&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3 ()&lt;/a&gt; 편집 거리 함수는 가상 테이블의 &quot;명령어&quot;칼럼에 적합한 문자열을 삽입함으로써 선택 또는 실행 시간에 해제 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="translated">&lt;a href=&quot;sqlar&quot;&gt;SQLite는 아카이브&lt;/a&gt; SQLite는이 ZIP 아카이브 또는 TAR 파일에 대한 대용으로 사용할 수있는 방법을 생각 보여줍니다. SQLite에 저장된 파일의 아카이브는 동등한 ZIP 아카이브보다 매우 약간 크며 경우에 따라 실제로는 더 작습니다. 또한 SQLite 아카이브에는 증분 및 원자 업데이트가 있으며 훨씬 더 풍부한 메타 데이터를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 호출에서 포인터 D &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt (D, S)는&lt;/a&gt; 개방형 데이터베이스 연결과 NULL 포인터하지 특히 필요 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; 방법은 N의 단부에 문자열 S 바이트로부터 정확하게 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; X. N은 음이 아닌 있어야 개체. S는 0이 아닌 0 바이트 이상의 콘텐츠를 포함해야합니다. 0으로 끝나는 문자열을 전체적으로 추가하려면 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; 메서드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall는 (X, S)의&lt;/a&gt; 방법은 결국 제로로 끝나는 문자열 S의 전체 콘텐츠를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar은 (X는 N, C)&lt;/a&gt; 방법의 마지막에 1 바이트 문자 C의 N 카피를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 공백 압입 부가, 예를 들면이 방법은 사용할 수있는 객체 X..</target>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; 과 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; 인터페이스가 사용 &lt;a href=&quot;../printf&quot;&gt;내장의 printf&lt;/a&gt; SQLite는 기능성의 단부 상 형식의 텍스트를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; 에있어서 내부 공사중 문자열 리셋 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 길이는 0 바이트로 오브젝트 X의 뒷면.</target>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 방법 공사중 동적 문자열 바이트 현재 길이를 반환 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 의해 리턴 된 길이 오브젝트 X. &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)가&lt;/a&gt; 제로 종료 바이트를 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; 메소드에 의해 리턴 된 값 X. 공사중 동적 캐릭터의 현재 콘텐츠에 대한 포인터를 리턴 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; sqlite3_str 오브젝트 X에 의해 관리되고, 동일한에 후속 법에 의해 해제되거나 변경 될 수도 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체. 응용 프로그램은 동일한 오브젝트에서 후속 메소드 호출 후 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; 리턴 한 포인터를 사용해서는 안됩니다 . 응용 프로그램은 0에서 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 범위를 벗어난 바이트에 쓰지 않고 후속 sqlite3_str 메소드 호출 후 바이트를 읽거나 쓰지 않는 한 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)에&lt;/a&gt; 의해 반환되는 문자열의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 인터페이스 sqlite3_str 오브젝트 X 되돌아로부터 획득 된 버퍼 메모리에 대한 포인터 파괴 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 구축 된 스트링을 포함한다. 호출 애플리케이션은 메모리 누수를 피하기 위해 리턴 된 값을 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 로 전달해야합니다. &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 오류가 캐릭터 라인의 건설 중 발생 된 경우 인터페이스는 NULL 포인터를 반환 할 수 있습니다. &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 의 문자열 경우 인터페이스도 NULL 포인터를 반환합니다 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 X가 0 바이트 길이입니다.</target>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스에 할당하고 새로운 초기화 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; 개체. 메모리 누수를 방지하려면 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에 대한 후속 호출을 통해 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()에서&lt;/a&gt; 반환 한 객체를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스는 항상 유효한에 대한 포인터를 반환 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; 메모리 부족 오류의 경우에 반환 된 객체가 새 텍스트를 거부 자동으로하는 특별한 싱글이 될 수도 있지만, 객체를 항상에서 SQLITE_NOMEM을 반환 &lt;a href=&quot;str_errcode&quot;&gt;) (sqlite3_str_errcode &lt;/a&gt;&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length ()에&lt;/a&gt; 대해 항상 0을 반환하고 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에서 항상 NULL을 반환합니다 . &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 의해 리턴 된 값을 sqlite3_str 매개 변수로 다른 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 메소드 에 사용하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 인터페이스를 반환하는 경우에만 문자열 X가 일치하면 제로 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 패턴 P.의 정의 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;strglob&quot;&gt;(P, X) sqlite3_strglob를&lt;/a&gt; 에서 &quot;X GLOB P&quot;연산자와 동일 SQLite는 SQL 언어를 이해합니다. &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 함수는 대소 문자를 구분한다.</target>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; API는 식별자를 비교할 때 SQLite는 내부에서 사용하는 &quot;경우 독립&quot;의 정의와 동일하여, 애플리케이션 및 확장이 경우 독립적 방식으로 UTF-8 스트링을 포함하는 두 버퍼의 내용과 비교하도록 허용한다.</target>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; ASCII 문자 만이 경우 접힌 비록 기능은 유니 코드 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 인터페이스에 리턴하고 문자열 X가 일치하는 경우에만 0 일 경우 &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 제어 문자 E.의 정의 패턴 P &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike를 (P는, X, E)이&lt;/a&gt; 와 동일 SQLite에서 이해하는 SQL 언어의 &quot;X LIKE P ESCAPE E&quot;연산자 ESCAPE 절이없는 &quot;X LIKE P&quot;의 경우 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 의 E 매개 변수 를 0으로 설정하십시오. LIKE 연산자와 마찬가지로 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 함수는 대소 문자를 구분하지 않습니다. 소문자 ASCII 문자는 서로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 를 사용하는 개선 된 &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;비 - 순환 엔진 (NRE)&lt;/a&gt; 이후 TCL 8.6에 링크시 TCL 인터프리터 인터페이스.</target>
        </trans-unit>
        <trans-unit id="23310616ad13ff4bf64157f6f266be2fa9a80e64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer also does an excellent job of verifying that SQLite responds sanely to malformed database files.</source>
          <target state="translated">&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz의&lt;/a&gt; fuzzer는 SQLite는 조작 된 데이터베이스 파일을 올바로 수행 응답하는지 확인하는 훌륭한 일을한다.</target>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="translated">&lt;a href=&quot;testing#slt&quot;&gt;SQL 로직 테스트는&lt;/a&gt; SQLite는 다른 SQL 데이터베이스 엔진과 동일한 동작 것을 보여주기 위해 디자인 된 테스트 케이스의 집합입니다. 이러한 테스트는 별도의 코드 공용 저장소에서 호스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="translated">&lt;a href=&quot;th3&quot;&gt;테스트 장치 # 3&lt;/a&gt; 또는 &lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt; 테스트 세트는 그대로 전달되는 구성에서 100 % MC / DC에 SQLite는 실험에 사용 된 테스트 케이스 전용 세트이다. TH3 소스는 다른 SQLite 리포지토리와 동일한 서버에서 제공되지만 독점적 인 점에서 다른 서버와 다릅니다. TH3 코드는 SQLite 개발자 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; 인터페이스는 다른 데이터베이스 연결에 의해 변경이 무시되고 데이터베이스 연결 D.에 대해 SQL 문 실행으로 인해 변경된 것을 행의 수를보고합니다. 다른 데이터베이스 연결에서 데이터베이스 파일에 대한 변경을 감지하려면 &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; 명령 또는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;파일 제어를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f49c08b6ed161fe2560890c885dd50855619ba24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; extension is automatically loaded</source>
          <target state="translated">&lt;a href=&quot;uintcseq&quot;&gt;UINT의 배열 순서의&lt;/a&gt; 확장은 자동으로로드됩니다</target>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;versionnumbers&quot;&gt;버전 번호 지정 규칙&lt;/a&gt; 은 새로운 &lt;a href=&quot;http://semver.org/&quot;&gt;버전&lt;/a&gt; 의 시맨틱 버전 지정 을 사용하도록 개정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="translated">&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; SQLite는 용 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16)는 새로운 장치라는 특성이 추가 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE를&lt;/a&gt; . 이 특성을보고하는 데이터베이스 파일은 전원 안전 덮어 쓰기 속성이있는 스토리지 시스템에 상주한다고 가정합니다. 기본 UNIX와 Windows &lt;a href=&quot;vfs&quot;&gt;VFSes는&lt;/a&gt; 지금보고 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE를&lt;/a&gt; SQLite는 함께 컴파일 된 경우 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 1&lt;/a&gt; 하거나 컴파일하면 저장이 powersafe 덮어 쓰기 속성을 가지고 있지 않는 레거시 가정 할 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 0&lt;/a&gt; . 현재로서는 기본적으로 전원 안전 덮어 쓰기가 켜져 있지만 나중에 다시 방문하여 기본값을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex의&lt;/a&gt; 숨은 열에 대하여 평등 제약 표 확인의 구현 방법 및 생성하는 정수 &quot;값&quot;출력의 범위를 결정하기 위해 입력 파라미터 들로서 이들을 사용한다. 제한되지 않은 열에는 합리적인 기본값이 사용됩니다. 예를 들어, 5에서 50 사이의 모든 정수를 나열하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex 번째 항목이됩니다. aConstraintUsage []. omit가 true 인 경우 제한 조건은 가상 테이블에서 완전히 처리 된 것으로 간주되며 SQLite에서 다시 점검하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8ae1ca39afc04ccf6f18ad86632ba85cedd64de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex-th 항목이됩니다. aConstraintUsage []. omit이 참이면 제약 조건은 가상 테이블에서 완전히 처리되는 것으로 간주되며 바이트 코드에서 다시 검사하지 않을 수 있습니다. aConstraintUsage []. omit 플래그는 최적화 힌트입니다. 생략 플래그가 기본 설정 인 false로 남아 있으면 제약 조건은 항상 바이트 코드에서 별도로 검사됩니다. 생략 플래그가 참으로 변경되면 제약 조건이 바이트 코드에서 확인되거나 확인되지 않을 수 있습니다. 즉, 생략 플래그가 참이면 제약 조건이 바이트 코드를 사용하여 다시 검사되지 않는다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드는 이 인터페이스를 호출하여 구현 하는 가상 테이블 의 형식 (열의 이름 및 데이터 유형)을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="translated">&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect의&lt;/a&gt; 가상 테이블을 사용하는 데이터베이스에 접속이 폐쇄 될 때마다 메소드가 호출된다. xDestroy 메소드는 가상 테이블에 대해 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문이 실행될 때만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xupdate&quot;&gt;을 XUpdate의&lt;/a&gt; 방법은 원래 가지고 주위에 디자인 된 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 하나의 값으로한다. &lt;a href=&quot;vtab#xupdate&quot;&gt;에서 XUpdate&lt;/a&gt; 방법은 ROWID 대신 임의 PRIMARY KEY를 수용하도록 확장되어 있지만 PRIMARY KEY는 여전히 단지 하나의 열을해야한다. 이러한 이유로 SQLite는 둘 이상의 PRIMARY KEY 열과 NULL이 아닌 xUpdate 메소드가있는 WITHOUT ROWID 가상 테이블을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="translated">&lt;a href=&quot;wal#advantages&quot;&gt;WAL 모드&lt;/a&gt; 의 두 번째 장점은 기록기가 판독기를 차단하지 않으며 기록기가 차단하지 않도록하는 것입니다. 이것은 &lt;u&gt;대부분&lt;/u&gt; 사실입니다. 그러나 WAL 모드 데이터베이스에 대한 쿼리가 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 리턴 할 수있는 모호한 경우가 있으므로 해당 상황에 맞게 애플리케이션을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint (D, N)의&lt;/a&gt; 래퍼입니다 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 에 데이터베이스를 야기 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 자동으로 D &lt;a href=&quot;../wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; N 이상의 프레임이에있는 경우 트랜잭션을 커밋 한 후 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 파일. nFrame 매개 변수로 0 또는 음수 값을 전달하면 자동 검사 점이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 함수 WAL 모드에서 데이터베이스로 커밋 될 때마다 데이터를 호출 콜백을 등록하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="translated">&lt;a href=&quot;walformat#locks&quot;&gt;WAL 모드 자물쇠는&lt;/a&gt; 상술되어있다.</target>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">&lt;a href=&quot;walformat#shm&quot;&gt;월마트 지수는&lt;/a&gt; 견고 mmap 된되는 일반 파일을 사용하여 구현됩니다. WAL 모드의 초기 (시험판) 구현에서는 wal-index를 휘발성 공유 메모리에 저장했습니다 (예 : Linux의 경우 / dev / shm에 작성된 파일 또는 다른 유닉스 시스템의 / tmp). 이 접근 방식의 문제점은 다른 루트 디렉토리가있는 프로세스 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt; 를 통해 변경됨)입니다.)에 따라 파일이 달라 지므로 공유 메모리 영역이 달라져 데이터베이스가 손상 될 수 있습니다. 이름없는 공유 메모리 블록을 만드는 다른 방법은 다양한 종류의 유닉스에서 이식 할 수 없습니다. 그리고 우리는 창에서 이름없는 공유 메모리 블록을 만드는 방법을 찾지 못했습니다. 동일한 데이터베이스 파일에 액세스하는 모든 프로세스가 동일한 공유 메모리를 사용하도록 보장하는 유일한 방법은 데이터베이스 자체와 동일한 디렉토리에 파일을 mmapping하여 공유 메모리를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="translated">&lt;a href=&quot;whentouse#website&quot;&gt;SQLite&lt;/a&gt; 의 적절한 사용 페이지에 따르면 SQLite 웹 사이트의 동적 페이지는 일반적으로 각각 약 200 개의 SQL 문을 수행합니다. 이것은 독자들의 비판을 불러 일으켰습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;ZipFile를 가상 테이블을&lt;/a&gt; 읽고 쓸 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCL 테스트는&lt;/b&gt; SQLite는 대한 테스트의 가장 오래된 집합입니다. 그것들은 SQLite 코어와 동일한 소스 트리에 포함되며 SQLite 코어가 공개 도메인에있는 것처럼. TCL 테스트는 개발 중에 사용되는 기본 테스트입니다. TCL 테스트는 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL 스크립팅 언어를&lt;/a&gt; 사용하여 작성됩니다 . TCL 테스트 하니스 자체는 TCL 인터페이스를 작성하는 데 사용되는 26.9 KSLOC의 C 코드로 구성됩니다. 테스트 스크립트는 총 20.5MB 크기의 1264 파일에 포함되어 있습니다. 44792 개의 개별 테스트 사례가 있지만 전체 테스트 실행에서 수백만 개의 개별 테스트가 수행되도록 많은 테스트 사례가 매개 변수화되고 다른 매개 변수와 함께 여러 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec2f6c6133a8488b1cdbdaeca80a7abf2b8d280" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 27.0 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1272 files totaling 21.1MB in size. There are 46363 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCL 테스트는&lt;/b&gt; SQLite는 대한 테스트의 가장 오래된 집합입니다. SQLite 코어와 동일한 소스 트리에 포함되어 있으며 SQLite 코어와 마찬가지로 공용 도메인에 있습니다. TCL 테스트는 개발 중에 사용되는 기본 테스트입니다. TCL 테스트는 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL 스크립팅 언어를&lt;/a&gt; 사용하여 작성됩니다 . TCL 테스트 하네스 자체는 TCL 인터페이스를 생성하는 데 사용되는 27.0 KSLOC의 C 코드로 구성됩니다. 테스트 스크립트는 총 21.1MB 크기의 1272 개 파일에 포함되어 있습니다. 46363 개의 개별 테스트 케이스가 있지만 많은 테스트 케이스가 매개 변수화되고 여러 번 (다른 매개 변수 사용) 실행되므로 전체 테스트에서 수백만 개의 개별 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt;&lt;/b&gt; 테스트 하니스 100 % 분기 시험 범위 (C 및 제공에 기입 전용 테스트 세트 인 &lt;a href=&quot;testing#mcdc&quot;&gt;100 % MC / DC 시험에 따르면&lt;/a&gt; , 코어 SQLite는 라이브러리 참조). TH3 테스트는 TCL 또는 기타 워크 스테이션 서비스를 쉽게 지원하지 않는 임베디드 및 특수 플랫폼에서 실행되도록 설계되었습니다. TH3 테스트는 게시 된 SQLite 인터페이스 만 사용합니다. TH3은 44753 개의 개별 테스트 사례를 구현하는 약 69.4MB 또는 948.1 KSLOC의 C 코드로 구성됩니다. TH3 테스트는 매개 변수가 많으므로 전체 범위 테스트는 약 170 만 개의 다른 테스트 인스턴스에서 실행됩니다. 100 % 분기 테스트 적용 범위를 제공하는 사례는 총 TH3 테스트 스위트의 하위 세트를 구성합니다. 릴리스 전의 담금 테스트는 수억 개의 테스트를 수행합니다. TH3에 대한 추가 정보는 &lt;a href=&quot;th3&quot;&gt;별도로 제공됩니다&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6d35eb6cfeae174de2bae520fa16645d47318a8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 71.5 MB or 978.3 KSLOC of C code implementing 46622 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.9 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt;&lt;/b&gt; 테스트 하니스 100 % 분기 시험 범위 (C 및 제공에 기입 전용 테스트 세트 인 &lt;a href=&quot;testing#mcdc&quot;&gt;100 % MC / DC 시험에 따르면&lt;/a&gt; , 코어 SQLite는 라이브러리 참조). TH3 테스트는 TCL 또는 기타 워크 스테이션 서비스를 쉽게 지원하지 않는 임베디드 및 특수 플랫폼에서 실행되도록 설계되었습니다. TH3 테스트는 게시 된 SQLite 인터페이스 만 사용합니다. TH3는 46622 개의 개별 테스트 케이스를 구현하는 약 71.5MB 또는 978.3 KSLOC의 C 코드로 구성됩니다. 그러나 TH3 테스트는 크게 매개 변수화되어 있으므로 전체 범위 테스트는 약 190 만 개의 서로 다른 테스트 인스턴스를 실행합니다. 100 % 분기 테스트 커버리지를 제공하는 케이스는 전체 TH3 테스트 스위트의 하위 집합을 구성합니다. 출시 전에 담그는 테스트는 수억 번의 테스트를 수행합니다. TH3에 대한 추가 정보는 &lt;a href=&quot;th3&quot;&gt;별도로 제공됩니다.&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="translated">캐시 된 페이지 의 &lt;b&gt;&lt;i&gt;페이지 번호&lt;/i&gt;&lt;/b&gt; 입니다. 페이지는 1 페이지부터 시작하여 데이터베이스 파일 내에서 순차적으로 번호가 매겨집니다 (1 페이지는 바이트 오프셋 0에서 시작). 인용하다</target>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; 컴파일 시간 플래그를 더 이상 작동합니다. I / O 절차는 이제 항상 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="translated">ASCII 코드 포인트 범위 (0-127) 이외의 모든 문자를 토큰 문자로 취급한다고 가정 하는 &lt;b&gt;ASCII&lt;/b&gt; 토큰 화 프로그램.</target>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="translated">&lt;b&gt;원자 쓰기&lt;/b&gt; 속성입니다. 이 속성을 지원하는 시스템은 또한 쓸 수있는 블록의 크기를 지정합니다. 유효한 크기는 512보다 큰 2의 거듭 제곱입니다. 쓰기 작업이 블록을 수정하는 경우</target>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="translated">&lt;b&gt;캐시 된 데이터&lt;/b&gt; ; 많은 데이터</target>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="translated">&lt;b&gt;이니셜 체크섬&lt;/b&gt; 필드는 의사 - 랜덤 값으로 설정된다. 모두에 대한 체크섬을 계산하는 알고리즘의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="translated">&lt;b&gt;체크섬&lt;/b&gt; 필드는 4 바이트 빅 엔디안 부호있는 정수로 저장 체크섬 값이 포함되어 있습니다. 체크섬 값은 다음을 구성하는 바이트의 합계로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="translated">&lt;b&gt;아이 키&lt;/b&gt; 은 참조 절을 보유하고있는 열 또는 외래 키 제약 조건에 의해 제약되고 자식 테이블의 열 집합입니다.</target>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="translated">&lt;b&gt;자식 테이블은&lt;/b&gt; 외래 키 제약 조건이 적용되는 것을 테이블과 참조 절을 포함하는 테이블입니다. 이 섹션의 예는</target>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;열 =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="translated">&lt;b&gt;데이터 =&lt;/b&gt; 인수 지정이</target>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="translated">&lt;b&gt;dbhash bsdhash.hashopen에&lt;/b&gt; (또는 &lt;b&gt;dbhash.exe&lt;/b&gt; 유틸리티 Windows에서)는 SQLite 데이터베이스의 스키마 및 콘텐츠의 SHA1 해시를 계산하는 명령 줄 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="translated">&lt;b&gt;dbstat와&lt;/b&gt; 가상 테이블 모두 볼 수 있습니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; SQLite는이 사용하여 구축 될 때 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB의&lt;/a&gt; 컴파일시 옵션을 선택합니다. dbstat 가상 테이블은 데이터베이스 파일의 btree 및 overflow 페이지에 대한 저수준 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="translated">&lt;b&gt;파일 이름은 =&lt;/b&gt; 인수는 CSV의 콘텐츠를 읽을 외부 파일을 지정합니다. 모든 CSV 가상 테이블에는 &lt;b&gt;filename =&lt;/b&gt; 인수 또는 &lt;b&gt;data =&lt;/b&gt; 인수 중 하나만 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="translated">&lt;b&gt;저널 마법&lt;/b&gt; 필드는 항상 SQLite는 저널 파일을 식별하는 데 사용되는 잘 알려진 8 바이트 문자열 값을 포함합니다. 잘 알려진 바이트 값 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2e5b0d62ca7f429d717982cbc08462058d705f1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1의&lt;/b&gt; 확장은입니다 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 을 구현하는 다섯 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 와 두 개의 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 관리를위한 유용한 &lt;a href=&quot;http://json.org/&quot;&gt;JSON의&lt;/a&gt; SQLite는 데이터베이스에 저장된 컨텐츠를. 13 개의 스칼라 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1의&lt;/b&gt; 확장은입니다 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 을 구현하는 다섯 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 와 두 개의 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 관리를위한 유용한 &lt;a href=&quot;http://json.org/&quot;&gt;JSON의&lt;/a&gt; SQLite는 데이터베이스에 저장된 컨텐츠를. 13 개의 스칼라 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="translated">&lt;b&gt;마스터 저널 이름&lt;/b&gt; 필드는 UTF-8 문자열로 인코딩 된 마스터 저널 파일의 이름을 포함합니다. 문자열에 추가 된 널 종결자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="translated">&lt;b&gt;이름 길이&lt;/b&gt; 필드는 4 바이트 빅 엔디안 부호없는 정수로 포맷 바이트 이전 필드의 길이를 포함한다.</target>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="translated">&lt;b&gt;페이지 크기&lt;/b&gt; 필드는 해당 사용하는 데이터베이스 페이지 크기를 포함</target>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;상위 키&lt;/b&gt; 외래 키 제약이 참조하는 상위 테이블의 열 또는 열 세트이다. 일반적으로 부모 테이블의 기본 키는 아니지만 항상 그런 것은 아닙니다. 부모 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid가&lt;/a&gt; 아닌 부모 테이블의 명명 된 열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="translated">&lt;b&gt;부모 테이블은&lt;/b&gt; 외래 키 제약 조건에 참조하는 테이블입니다. 이 섹션의 예제에서 상위 테이블은</target>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;포터&lt;/b&gt; 구현 토크 나이, &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;포터 형태소 분석 알고리즘을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="translated">&lt;b&gt;안전 APPEND의&lt;/b&gt; 속성입니다. 시스템이</target>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="translated">&lt;b&gt;스키마 =&lt;/b&gt; 인수는이 지정 &lt;a href=&quot;lang_createtable&quot;&gt;표 CREATE&lt;/a&gt; csv로 가상 테이블이에 전달하는 문을 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 가상 테이블의 C 럼 이름을 정의하기 위해 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="translated">&lt;b&gt;순차 쓰기&lt;/b&gt; 속성입니다. 를 지원하는 시스템</target>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="translated">&lt;b&gt;sqlite3를&lt;/b&gt; 다음과 같이 명령을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="translated">&lt;b&gt;sqlite3를&lt;/b&gt; 명령은 두 번째 인수에 지정된 데이터베이스를 엽니 다. 데이터베이스가 아직없는 경우 기본 동작은 자동으로 작성되는 것입니다 ( &quot; &lt;b&gt;-create false&lt;/b&gt; &quot;옵션 을 사용하여이를 변경할 수 있음 ). &lt;b&gt;sqlite3를의&lt;/b&gt; 명령은 항상 데이터베이스를 제어 할 수있는 새로운 Tcl의 명령을 생성합니다. 새 Tcl 명령의 이름은 첫 번째 인수로 제공됩니다. 이 방법은 Tk에서 위젯이 작성되는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="translated">&lt;b&gt;sqlite가&lt;/b&gt; 명령 줄 유틸리티를 사용 &lt;b&gt;sqlite_complete&lt;/b&gt; 가 전화를해야 할 때 알고 기능을 &lt;b&gt;sqlite_exec&lt;/b&gt; . 각 입력 행이 수신 된 후 &lt;b&gt;sqlite&lt;/b&gt; 는 버퍼의 모든 입력에서 &lt;b&gt;sqlite_complete&lt;/b&gt; 를 호출 합니다. 경우 &lt;b&gt;sqlite_complete&lt;/b&gt; true를 반환하고 &lt;b&gt;sqlite_exec&lt;/b&gt; 전화를 입력 버퍼를 리셋한다. 경우 &lt;b&gt;sqlite_complete&lt;/b&gt; 반환 거짓, 다음 프롬프트가 계속 프롬프트로 변경되고 텍스트의 또 다른 라인을 읽고 입력 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="translated">&lt;b&gt;sqlite_busy_handler의&lt;/b&gt; 절차는 오픈 SQLite 데이터베이스 바쁜 콜백을 등록 할 수 있습니다. SQLite가 잠긴 데이터베이스에 액세스하려고 할 때마다 통화 중 콜백이 호출됩니다. 콜백은 일반적으로 잠금을 해제 할 기회를주기 위해 다른 유용한 작업 또는 절전 모드를 수행합니다. 콜백이 0이 아닌 값을 리턴하면 SQLite는 데이터베이스 액세스를 다시 시도하고주기가 반복됩니다. 콜백이 0을 반환하면 SQLite는 현재 작업을 중단하고 SQLITE_BUSY를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="translated">&lt;b&gt;sqlite_changes의&lt;/b&gt; API 함수는 데이터베이스가 마지막으로 대기가 된 이후, 삽입, 삭제 또는 수정 된 행의 수를 반환합니다. &quot;정지&quot;데이터베이스는 &lt;b&gt;sqlite_exec에&lt;/b&gt; 대한 미해결 호출이없고 &lt;b&gt;sqlite_finalize에&lt;/b&gt; 의해 &lt;b&gt;종료&lt;/b&gt; 되지 않은 &lt;b&gt;sqlite_compile&lt;/b&gt; 에 의해 생성 된 VM 이없는 &lt;b&gt;데이터베이스&lt;/b&gt; 입니다. 일반적인 사용에서, &lt;b&gt;sqlite_changes의&lt;/b&gt; 반환 삽입 된 행의 수, 삭제, 또는 가장 최근에 의해 수정 &lt;b&gt;sqlite_exec&lt;/b&gt; 전화 또는 가장 최근의 이후 &lt;b&gt;sqlite_compile&lt;/b&gt; . 그러나 &lt;b&gt;sqlite_exec에&lt;/b&gt; 대한 중첩 호출이있는 경우 (즉, 한 &lt;b&gt;sqlite_exec&lt;/b&gt; 의 콜백 루틴이 다른 호출을 호출하는 경우)&lt;b&gt;sqlite_exec&lt;/b&gt; ) 또는 &lt;b&gt;sqlite_compile&lt;/b&gt; 을 호출 하여 여전히 다른 VM이있는 동안 새 VM을 만들면 &lt;b&gt;sqlite_changes&lt;/b&gt; 가 반환하는 숫자의 의미 가 더 복잡합니다. 보고 된 수에는 나중에 ROLLBACK 또는 ABORT에 의해 취소 된 변경 사항이 포함됩니다. 그러나 DROP TABLE로 인해 삭제 된 행은 계산 &lt;em&gt;되지&lt;/em&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt; &quot;컴파일&quot;(두 번째 매개 변수에 의해 지정된) 단일 SQL 문 및 그 문을 실행할 수있는 가상 머신을 생성합니다. 인터페이스 루틴과 마찬가지로 첫 번째 매개 변수는 &lt;b&gt;sqlite_open에&lt;/b&gt; 대한 이전 호출에서 얻은 sqlite 구조에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="translated">&lt;b&gt;sqlite_create_function ()&lt;/b&gt; 인터페이스는 일반 기능과 생성하는 데 사용됩니다 &lt;b&gt;() sqlite_create_aggregate를&lt;/b&gt; 새로운 집계 함수를 만드는 데 사용됩니다. 두 경우 모두 &lt;b&gt;db&lt;/b&gt; 매개 변수는 함수를 등록해야하는 공개 SQLite 데이터베이스이고, &lt;b&gt;zName&lt;/b&gt; 은 새 함수의 이름이고, &lt;b&gt;nArg&lt;/b&gt; 는 인수 수이며, &lt;b&gt;pUserData&lt;/b&gt; 는 C 구현으로 변경되지 않은 채 전달되는 포인터입니다. 기능의. 두 루틴 모두 성공하면 0을 리턴하고 오류가 있으면 0이 아닌 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 기능은 프로세스 SQL 문 및 쿼리하는 데 사용됩니다. 이 기능에는 다음과 같은 5 개의 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 기능은 일반적으로 SQLITE_OK를 반환합니다. 그러나 무언가 잘못되면 오류 유형을 나타내는 다른 값을 반환 할 수 있습니다. 다음은 리턴 코드의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 사용 위에서 설명한 루틴은 SQLite 데이터베이스에서 데이터를 검색 할 수있는 유일한 방법이 될 수 있습니다. 그러나 많은 프로그래머들은 콜백 함수를 사용하여 결과를 얻는 것이 불편하다는 것을 알았습니다. 따라서 SQLite 버전 2.7.7부터 콜백을 사용하지 않는 두 번째 액세스 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="translated">&lt;b&gt;sqlite_finalize의&lt;/b&gt; 루틴은 또한 가상 머신이 수행하는 SQL 작업의 성공 또는 실패를 나타내는 결과 코드를 반환합니다. 같은 SQL에 의해 실행되었다 반환 된 것처럼 sqlite_finalize (에 의해 반환되는 값) 동일합니다 &lt;b&gt;sqlite_exec&lt;/b&gt; . 반환 된 오류 메시지도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table ()&lt;/b&gt; 함수는 이제 그것을 컬럼의 다른 번호를 돌려 두 개 이상의에 select를 줄 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 함수 래퍼이다 &lt;b&gt;sqlite_exec&lt;/b&gt; 수집하는 모든 연속 콜백의 정보와의 malloc에 의한 메모리 ()에 그것을 기록하는. 응용 프로그램이 단일 함수 호출로 데이터베이스 쿼리의 전체 결과를 가져올 수있는 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 돌아 간다와 같은 정수 결과 코드 &lt;b&gt;sqlite_exec&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="translated">&lt;b&gt;sqlite_interrupt&lt;/b&gt; 기능은 첫 번째 기회에서 종료 현재 데이터베이스 작업을 일으키는 다른 스레드 또는 신호 처리기를 호출 할 수 있습니다. 이 경우, 데이터베이스 조작을 시작한 &lt;b&gt;sqlite_exec&lt;/b&gt; 루틴 (또는 동등한 항목)이 SQLITE_INTERRUPT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_mprintf ()&lt;/b&gt; 표준 라이브러리와 같은 일상적인 작업 &lt;b&gt;의 sprintf ()&lt;/b&gt; 는 malloc에에서 얻은 메모리에 그 결과를 기록 ()와 malloc으로 할당 된 버퍼에 대한 포인터를 반환하는 것을 제외하고. &lt;b&gt;sqlite_mprintf ()&lt;/b&gt; 는 위에서 설명한 % q 및 % Q 확장명도 이해합니다. &lt;b&gt;sqlite_vmprintf는 ()&lt;/b&gt; 같은 루틴의 가변 인자 버전입니다. 이러한 루틴이 리턴하는 문자열 포인터는 &lt;b&gt;sqlite_freemem ()&lt;/b&gt; 에 전달하여 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="translated">&lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; 루틴가 SQLite는 데이터베이스와 콜백 루틴을 등록하는 데 사용할 수있는 것은 긴 실행 통화 중 주기적으로 호출 될 &lt;b&gt;sqlite_exec ()&lt;/b&gt; , &lt;b&gt;sqlite_step ()&lt;/b&gt; 및 다양한 래퍼 함수.</target>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="translated">&lt;b&gt;unicode61&lt;/b&gt; 유니 코드 6.1 표준을 기반으로 토큰 화. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; 및 &lt;code&gt;-wal&lt;/code&gt; 파일이 이미 존재하고 읽을 수</target>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="translated">&lt;code&gt;sqldiff.exe&lt;/code&gt; 바이너리는 명령 줄 유틸리티 프로그램입니다 SQLite 데이터베이스 사이의 표시 차이가. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 바이너리는 측정 및 표시 얼마나 어떻게 효율적으로 공간이 SQLite는 데이터베이스 파일 개별 테이블과 인덱스에 의해 사용되는 명령 줄 유틸리티 프로그램입니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 프로그램은 인 &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL의&lt;/a&gt; 용도 프로그램 &lt;a href=&quot;dbstat&quot;&gt;dbstat와 가상 테이블을&lt;/a&gt; 데이터베이스 파일에 대한 정보를 수집하고 깔끔하게 정보를 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="translated">&lt;em&gt;&amp;lt;이름&amp;gt;&lt;/em&gt; 은 R * 트리 인덱스 용 애플리케이션 선택하는 이름 &lt;em&gt;&amp;lt;열 이름&amp;gt;&lt;/em&gt; 쉼표가 3 내지 11 컬럼에서 분리된다. 가상 &amp;lt;name&amp;gt; 테이블은 실제로 내용을 저장하기 위해 세 개의 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 작성 합니다. 이 새도우 테이블의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="translated">ADD COLUMN 구문은 기존 테이블에 새 열을 추가하는 데 사용됩니다. 새 열은 항상 기존 열 목록의 끝에 추가됩니다. &lt;a href=&quot;syntax/column-def&quot;&gt;열 데프&lt;/a&gt; 규칙은 새로운 컬럼의 특성을 정의합니다. 새 컬럼은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 허용되는 양식을 사용할 수 있으며 다음 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE 명령은 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블에&lt;/a&gt; 저장된 스키마의 SQL 텍스트를 수정하여 작동 합니다 . 테이블 내용은 변경되지 않습니다. 이로 인해 ALTER TABLE 명령의 실행 시간은 테이블의 데이터 양과 무관합니다. ALTER TABLE 명령은 1 개의 행이있는 테이블에서와 같이 천만 개의 행이있는 테이블에서 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b0731871ca262efc59fc6d44f9562ddd3fdb4667" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE 명령은 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블에&lt;/a&gt; 저장된 스키마의 SQL 텍스트를 수정하여 작동 합니다 . 테이블 내용은 변경되지 않습니다. 이 때문에 ALTER TABLE 명령의 실행 시간은 테이블의 데이터 양과 무관합니다. ALTER TABLE 명령은 행이 1 개인 테이블에서와 마찬가지로 1000 만 행이있는 테이블에서 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="translated">ALWAYS (X) 및 NEVER (X) 매크로는 X의 진실에 대한 약한 진술입니다. ALWAYS (X) 또는 NEVER (X)의 존재는 개발자가 X가 항상 또는 절대 사실이라고 믿지만 증거는 없습니다 또는 증명이 복잡하고 오류가 발생하기 쉬우거나 변경 될 가능성이있는 시스템의 다른 측면에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="translated">ALWAYS (X) 및 NEVER (X) 매크로는 기능 테스트 중에 assert (X)처럼 동작합니다. X의 값이 예상 한 값과 다른 경우 개발자가 문제에 대해 즉시 경고하기를 원하기 때문입니다. 그러나 배달을 위해 ALWAYS (X) 및 NEVER (X)는 심층 방어를 제공하는 간단한 통과 매크로입니다. 적용 범위 테스트의 경우 ALWAYS (X) 및 NEVER (X)는 도달 불가능한 기계 코드가 생성되지 않도록 하드 코딩 된 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="translated">ANALYZE 명령은 테이블 및 인덱스에 대한 통계를 수집하고 수집 된 정보를 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블&lt;/a&gt; 에 저장합니다. 데이터베이스의 에 하여 쿼리 최적화 프로그램이 정보에 액세스하고이를 사용하여 더 나은 쿼리 계획을 선택할 수 있도록합니다. 인수가 제공되지 않으면 연결된 모든 데이터베이스가 분석됩니다. 스키마 이름이 인수로 제공되면 해당 데이터베이스의 모든 테이블과 인덱스가 분석됩니다. 인수가 테이블 이름 인 경우 해당 테이블 및 해당 테이블과 연관된 인덱스 만 분석됩니다. 인수가 인덱스 이름 인 경우 해당 인덱스 하나만 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">AND 연산자 는 두 문서 세트의 &lt;b&gt;교집합&lt;/b&gt; 을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="translated">AND 연산자는 암시 적으로 지정 될 수 있습니다. FTS 쿼리 문자열에서 연산자를 분리하지 않고 두 개의 기본 쿼리가 나타나면 두 개의 기본 쿼리가 AND 연산자로 분리 된 것과 결과가 같습니다. 예를 들어 &quot;암시 적 연산자&quot;쿼리 식은 &quot;암시 적 AND 연산자&quot;의 간결한 버전입니다.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="translated">SQLite 3.0 용 API에는 여러 데이터 구조 및 #defines 외에도 83 개의 개별 함수가 포함되어 있습니다. (완전한 &lt;a href=&quot;c3ref/intro&quot;&gt;API 참조&lt;/a&gt; 는 별도의 문서로 제공됩니다.) 다행히 인터페이스는 크기가 의미하는 것만 큼 복잡하지 않습니다. 간단한 프로그램은 여전히 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()의&lt;/a&gt; 3 가지 기능으로 만 수행 할 수 있습니다 . &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 를 사용하여 SQLite 문을 바이트 코드로 컴파일하고 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 을 사용하여 해당 바이트 코드를 실행하는 데이터베이스 엔진 실행에 대한 추가 제어가 제공됩니다 . &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_로&lt;/a&gt; 시작하는 이름을 가진 루틴 제품군쿼리 결과 집합에 대한 정보를 추출하는 데 사용됩니다. 많은 인터페이스 기능이 UTF-8 및 UTF-16 버전과 함께 쌍으로 제공됩니다. 그리고 사용자 정의 SQL 함수 및 사용자 정의 텍스트 조합 순서를 구현하는 데 사용되는 루틴 콜렉션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="translated">버전 3.0 용 API는 버전 2.X API와 유사하지만 몇 가지 중요한 변경 사항이 있습니다. 가장 주목할만한 것은 모든 API 함수 및 데이터 구조의 시작 부분에서 발생 하는 &quot; &lt;code&gt;sqlite_&lt;/code&gt; &quot;접두사가 &quot; &lt;code&gt;sqlite3_&lt;/code&gt; &quot; 로 변경됩니다 . 이를 통해 두 API 간의 혼동을 피하고 SQLite 2.X와 SQLite 3.0을 동시에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="translated">ATTACH DATABASE 문은 다른 데이터베이스 파일을 현재 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 추가 합니다 . 이전에 첨부 된 데이터베이스 파일은 &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; 명령을 사용하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="translated">AUTOINCREMENT 키워드는 추가 CPU, 메모리, 디스크 공간 및 디스크 I / O 오버 헤드를 부과하므로 엄격하게 필요하지 않은 경우 피해야합니다. 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="translated">Ascii 토크 나이 저는 다음을 제외하고는 Unicode61 토크 나이저와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="translated">B- 트리 모듈은 디스크에서 고정 크기 페이지로 정보를 요청합니다. 기본 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 는 4096 바이트이지만 512에서 65536 바이트 사이의 2의 제곱이 될 수 있습니다. 페이지 캐시는 이러한 페이지를 읽고 쓰고 캐싱하는 역할을합니다. 페이지 캐시는 롤백 및 원자 커밋 추상화를 제공하며 데이터베이스 파일의 잠금을 처리합니다. B- 트리 드라이버는 페이지 캐시에서 특정 페이지를 요청하고 페이지를 수정하거나 변경 사항을 커밋 또는 롤백 할 때 페이지 캐시에 알립니다. 페이지 캐시는 요청이 빠르고 안전하며 효율적으로 처리되도록하는 복잡한 세부 사항을 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="translated">BEFORE 또는 AFTER 키워드는 연관된 행의 삽입, 수정 또는 제거와 관련하여 트리거 조치가 실행될시기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="21f8310c8a4f643230a41569cc835883561b2976" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row. BEFORE is the default when neither keyword is present.</source>
          <target state="translated">BEFORE 또는 AFTER 키워드는 연관된 행의 삽입, 수정 또는 제거와 관련하여 트리거 조치가 실행되는시기를 결정합니다. 키워드가없는 경우 BEFORE가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="translated">BETWEEN 연산자</target>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="translated">BETWEEN 연산자는 논리적으로 비교 쌍과 같습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="translated">snippet ()에 대한 BLOB 인수에는 올바른 하위 유형이 없으므로 snippet 함수는이를 무시하고 데이터 구조를 변경하지 않으며 무해하게 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="translated">BTree 모듈은 스택 공간이 제한된 시스템에서 더 잘 재생하기 위해 스택 대신 malloc ()을 사용하여 큰 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="28ec130c322725529d5d7532a31940b3096646c9" translate="yes" xml:space="preserve">
          <source>The Bytecode() And Tables_Used() Table-Valued Functions</source>
          <target state="translated">Bytecode () 및 Tables_Used () 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="translated">아래 C 코드는 sumint ()라는 간단한 창 집계 함수를 구현합니다. 이것은 내장 sum () 함수와 같은 방식으로 작동하지만 정수 값이 아닌 인수를 전달하면 예외가 발생한다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="translated">오른쪽의 C 함수는 백업 API의 가장 단순하고 가장 일반적인 용도 중 하나를 보여줍니다. 인 메모리 데이터베이스의 내용을 디스크의 파일로로드 및 저장합니다. 이 예제에서 백업 API는 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="translated">SQLite 버전 2에 대한 C 언어 인터페이스</target>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="translated">C 언어는 오래되었고 지루하다. 잘 알려지고 이해되는 언어입니다. 이것은 SQLite와 같은 모듈을 개발할 때 원하는 것입니다. 작고 빠르며 안정적인 데이터베이스 엔진을 작성하는 것은 구현 언어 사양이 업데이트 될 때마다 구현 언어가 변경되지 않기 때문에 충분히 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">ㄴ 파라미터하는 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close (C)&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; NULL 포인터 또는 여야 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를 용&lt;/a&gt; 로부터 얻어지는 오브젝트 포인터 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 그리고 이전에 폐쇄. NULL 포인터 인수를 사용하여 sqlite3_close () 또는 sqlite3_close_v2 ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">ㄴ 파라미터하는 &lt;a href=&quot;close&quot;&gt;sqlite3_close (C)&lt;/a&gt; 와 &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; NULL 포인터 또는 여야 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를 용&lt;/a&gt; 로부터 얻어지는 오브젝트 포인터 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 그리고 이전에 폐쇄. NULL 포인터 인수를 사용하여 sqlite3_close () 또는 sqlite3_close_v2 ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="translated">SQLite 용 C 언어 API는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;&lt;/a&gt; 는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현에 새로운 PRAGMA 문을 추가하거나 내장 PRAGMA 문의 의미를 대체 할 수있는 기회를 SQLITE_FCNTL_PRAGMA &lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="translated">CASE 표현</target>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="translated">CAST 연산자는 십진 정수만 이해합니다. &lt;a href=&quot;lang_expr#hexint&quot;&gt; 16 16&lt;/a&gt; 문자열의 &quot;0x&quot;접두어에서 &quot;x&quot;에서 중지되므로 CAST의 결과는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="translated">CLI에는 edit ()라는 또 다른 내장 SQL 함수가 있습니다. Edit ()는 하나 또는 두 개의 인수를 사용합니다. 첫 번째 인수는 값입니다. 일반적으로 편집 할 큰 여러 줄 문자열입니다. 두 번째 인수는 텍스트 편집기의 이름입니다. 두 번째 인수를 생략하면 VISUAL 환경 변수가 사용됩니다. edit () 함수는 첫 번째 인수를 임시 파일에 쓰고 임시 파일에서 편집기를 호출하고 편집기가 완료된 후 파일을 메모리로 다시 읽은 다음 편집 된 텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="translated">CLI는 줄 끝에서 공백 (주석 포함)을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="translated">선택적으로 각 열 이름 또는 표현식 뒤에 오는 COLLATE 절은 해당 열의 텍스트 항목에 사용되는 조합 순서를 정의합니다. 기본 조합 순서는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 에서 해당 열에 대해 정의 된 조합 순서입니다. 문 입니다. 또는 조합 순서가 달리 정의되어 있지 않으면 내장 BINARY 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="translated">COLLATE 절 은 열의 기본 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 로 사용할 조합 순서 의 이름을 지정합니다 . COLLATE 절이 지정되지 않은 경우 기본 조합 순서는 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="translated">COLLATE 연산자는 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 시퀀스&lt;/a&gt; 를 표현식에 지정하는 단항 접미사 연산자입니다 . COLLATE 연산자는 &quot;~&quot;를 제외한 모든 이진 연산자 및 단항 접두사 연산자보다 우선 순위가 높습니다 (더 밀접하게 바인딩). (COLLATE와 &quot;~&quot;는 연관되므로 바인딩 순서는 중요하지 않습니다.) COLLATE 연산자에 의해 설정된 조합 순서는 테이블 &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;컬럼 정의&lt;/a&gt; 에서 COLLATE 절에 의해 결정된 조합 순서를 대체합니다 . 추가 정보 는 &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; 문서 의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 에 대한 자세한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="translated">COMPLETION 확장 은 &quot;completion&quot;이라는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수를&lt;/a&gt; 구현하여 대화식 SQL 입력 중에 부분적으로 입력 된 단어의 완성을 제안하는 데 사용할 수 있습니다. 예를 들어 완료 테이블을 사용하여 탭 완성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="translated">COMPLETION () 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="translated">COPY 명령은 데이터가 '\ N'인 열에 NULL을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="translated">CORRUPT_DB 매크로는 많은 assert () 문에서 사용됩니다. 기능 테스트 빌드에서 CORRUPT_DB는 데이터베이스 파일에 손상이있을 수있는 경우 전역 변수를 참조합니다. 이 변수는 기본적으로 데이터베이스가 손상되었는지 여부를 알지 못하지만 제대로 구성된 것으로 알려진 데이터베이스에서 작업하는 동안 테스트하는 동안 전역 변수를 false로 설정할 수 있으므로 기본적으로 true입니다. 그러면 CORRUPT_DB 매크로는 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680에&lt;/a&gt; 표시된 assert () 문에 사용될 수 있습니다.. 이러한 assert ()는 일관된 데이터베이스 파일에 대해 true이지만 데이터베이스 파일이 손상된 경우 false 일 수있는 루틴에 사전 조건을 지정합니다. 이러한 종류의 조건에 대한 지식은 격리 된 코드 블록을 이해하려는 독자에게 매우 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="translated">CREATE INDEX 명령은 키워드 &quot;CREATE INDEX&quot;와 새 인덱스 이름, 키워드 &quot;ON&quot;, 색인을 생성 할 이전에 작성된 테이블 이름 및 괄호로 묶은 테이블 열 이름 및 /으로 구성됩니다. 또는 인덱스 키에 사용되는 표현식. 선택적 WHERE 절이 포함 된 경우 색인은 &quot; &lt;a href=&quot;partialindex&quot;&gt;부분 색인&lt;/a&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="translated">CREATE TRIGGER 문은 데이터베이스 스키마에 트리거를 추가하는 데 사용됩니다. 트리거는 지정된 데이터베이스 이벤트가 발생할 때 자동으로 수행되는 데이터베이스 작업입니다.</target>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="translated">CREATE VIEW 명령은 사전 패키지화 된 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에 이름을 지정합니다 . 뷰가 작성되면 테이블 이름 대신 다른 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 의 FROM 절에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="translated">CREATE VIRTUAL TABLE &quot;tokenize&quot;옵션은 FTS5 테이블에서 사용하는 특정 토크 나이저를 구성하는 데 사용됩니다. 옵션 인수는 FTS5 베어 워드 또는 SQL 텍스트 리터럴이어야합니다. 인수의 텍스트 자체는 하나 이상의 FTS5 베어 워드 또는 SQL 텍스트 리터럴의 공백 시리즈로 취급됩니다. 이들 중 첫 번째는 사용할 토크 나이저의 이름입니다. 두 번째 및 이후의 목록 요소는 존재하는 경우 토크 나이저 구현에 전달되는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="translated">CREATE VIRTUAL TABLE 문은 클래스 클래스 module-name에서 파생 된 table-name이라는 새 테이블을 작성합니다. module-name은 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 인터페이스에 의해 가상 테이블에 등록 된 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="translated">명령문 시작 부분의 CREATE, TABLE, VIEW, TRIGGER 및 INDEX 키워드는 모든 대문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="translated">CSV 가상 테이블</target>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="translated">CSV 가상 테이블은 SQLite 통합에 기본 제공되지 않습니다. &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장자&lt;/a&gt; 로 컴파일 할 수 있는 &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;별도의 소스 파일&lt;/a&gt; 로 제공됩니다 . &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 CSV 가상 테이블의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="translated">CSV 가상 테이블은 대량의 쉼표로 구분 된 값 컨텐츠를 대량로드해야하는 애플리케이션에 유용합니다. CSV 가상 테이블은 다른 가상 테이블을 구현하기위한 템플릿 소스 파일로도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="translated">CSV 가상 테이블은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; 형식의 쉼표로 구분 된 값을 읽고 해당 컨텐츠를 SQL 테이블의 행 및 열인 것처럼 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="translated">이 예제의 콜백 명령어는 2 개 대신 3 개의 결과 열에 대한 데이터를 생성해야하지만 그렇지 않으면 첫 번째 쿼리와 동일합니다. 콜백 명령어가 호출되면 결과의 가장 왼쪽 열이 스택에서 가장 낮아야하고 가장 오른쪽 결과 열이 스택의 맨 위에 있어야합니다. 주소 11에서 15까지 이러한 방식으로 스택이 설정되는 것을 볼 수 있습니다. 11 및 12의 열 명령어는 결과에서 처음 두 열의 값을 푸시합니다. 13과 14의 두 열 명령어는 세 번째 결과 열을 계산하는 데 필요한 값을 가져오고 15의 Concat 명령어는이를 스택의 단일 항목으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="translated">Carray () 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="translated">점검표 선언</target>
        </trans-unit>
        <trans-unit id="9d300d65d6982ada326a006dd308b939bbd26748" translate="yes" xml:space="preserve">
          <source>The Checksum VFS Shim</source>
          <target state="translated">체크섬 VFS 심</target>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="translated">Clang / LLVM 컴파일러는 GCC와 경쟁이되지 않습니다. Clang 생성 바이너리는 GCC 생성 바이너리보다 지속적으로 크고 느립니다.</target>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="translated">프로그램 끝의 닫기 명령은 &quot;examp&quot;테이블을 가리키는 커서를 닫습니다. 프로그램이 중지되면 VDBE에 의해 모든 커서가 자동으로 닫히므로 여기서 Close를 호출 할 필요는 없습니다. 그러나 우리는 되감기 명령이 필요했기 때문에 앞으로 나아가서 그 지시가 유용한 일을하도록 할 수있었습니다. 중지 명령은 VDBE 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M)에 대한 D 및 N 인수는 각각 대상 데이터베이스 및 데이터베이스 이름과 연관된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;, 임시 데이터베이스의 경우 &quot;temp&quot;또는 연결된 데이터베이스 의 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. sqlite3_backup_init (D, N, S, M)에 전달 된 S 및 M 인수는 각각 소스 데이터베이스 의 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 데이터베이스 이름을 식별합니다 . 소스 및 대상 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (매개 변수 S 및 D)은 달라야합니다. 그렇지 않으면 sqlite3_backup_init (D, N, S, M)가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M)에 대한 D 및 N 인수는 각각 대상 데이터베이스 및 데이터베이스 이름과 연관된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;, 임시 데이터베이스의 경우 &quot;temp&quot;또는 연결된 데이터베이스 의 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. sqlite3_backup_init (D, N, S, M)에 전달 된 S 및 M 인수는 각각 소스 데이터베이스 의 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 데이터베이스 이름을 식별합니다 . 소스 및 대상 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (매개 변수 S 및 D)은 달라야합니다. 그렇지 않으면 sqlite3_backup_init (D, N, S, M)가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 대한 D 매개 변수 는 NULL 일 수 있습니다. &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 의 D 매개 변수 가 NULL이 아닌 경우, &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 포함 된 문자열의 최대 길이는 &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 대신 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, SQLITE_LIMIT_LENGTH )에 설정된 값 이 &lt;a href=&quot;limits#max_length&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 대한 D 매개 변수 는 NULL 일 수 있습니다. &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 의 D 매개 변수 가 NULL이 아닌 경우, &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 포함 된 문자열의 최대 길이는 &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 대신 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, SQLITE_LIMIT_LENGTH )에 설정된 값 이 &lt;a href=&quot;../limits#max_length&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
