<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">&quot;ORDER BY 2&quot;( &quot;ORDER BY under_alice.level + 1&quot;과 동일 함)는 조직도에서 더 높은 레벨 (더 작은 &quot;레벨&quot;값을 가짐)이 먼저 처리되어 광범위한 검색을 수행합니다. 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">재귀 선택의 &quot;ORDER BY checkin.mtime DESC&quot;용어는 오래 전부터 체크인을 병합하는 분기를 따르지 않도록하여 쿼리를 훨씬 빠르게 실행합니다. ORDER BY는 재귀 선택이 우리가 원하는 가장 최근의 체크인에 집중하도록합니다. 재귀 선택에 ORDER BY가 없으면 수천 명의 조상 전체를 계산하고 mtime별로 정렬 한 다음 상위 20 위를 차지해야합니다. ORDER BY는 본질적으로 재귀 쿼리가 가장 최근의 조상을 먼저 보도록하는 우선 순위 큐를 설정하므로 LIMIT 절을 사용하여 쿼리의 범위를 관심있는 체크인으로 만 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">&quot;PRAGMA cache_spill =</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">&quot;PRAGMA data_version&quot;명령은 데이터베이스 파일이 수정되었음을 표시합니다. 메모리에 데이터베이스 컨텐츠를 보유하거나 화면에 데이터베이스 컨텐츠를 표시하는 대화식 프로그램은 PRAGMA data_version 명령을 사용하여 메모리를 비우고 다시로드하거나 화면 표시를 업데이트해야하는지 여부를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">&quot;PRAGMA data_version&quot;값은 각 데이터베이스 연결의 로컬 특성이므로 별도의 데이터베이스 연결에서 &quot;PRAGMA data_version&quot;을 두 번 동시에 호출하여 리턴 된 값은 기본 데이터베이스가 동일하더라도 종종 다릅니다. 동일한 데이터베이스 연결에서 반환 된 &quot;PRAGMA data_version&quot;값을 서로 다른 두 시점에서 비교하는 것만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">&quot;페이지 수&quot;-저널의 다음 세그먼트에있는 페이지 수 또는 모든 컨텐츠를 파일 끝까지 의미하는 -1</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">위 출력의 &quot;USING TEMP B-TREE&quot;절은 임시 b- 트리 구조가 두 개의 하위 선택 결과의 UNION을 구현하는 데 사용됨을 나타냅니다. 복합을 계산하는 다른 방법은 각 하위 쿼리를 공동 루틴으로 실행하고 출력이 정렬 된 순서로 표시되도록 정렬하고 결과를 병합하는 것입니다. 쿼리 플래너가이 후자의 접근 방식을 선택하면 EXPLAIN QUERY PLAN 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">&lt;a href=&quot;printf&quot;&gt;내장 printf&lt;/a&gt; 구현 의 &quot;alternate-form-2&quot;플래그 ( &quot;!&quot;)는 이제 문자열 대체가 바이트 대신 문자의 너비와 정밀도를 측정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">&quot;atom&quot;열은 기본 요소 (JSON 배열 및 객체 이외의 요소)에 해당하는 SQL 값입니다. JSON 배열 또는 객체의 &quot;atom&quot;열은 NULL입니다. &quot;value&quot;열은 기본 JSON 요소의 &quot;atom&quot;열과 동일하지만 배열 및 객체의 JSON 값 텍스트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">&quot;authorizer&quot;방법</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">&quot;authorizer&quot;메소드는 &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++ 인터페이스에 대한 액세스를 제공합니다 . 권한 부 여자에 대한 인수는 특정 조작을 권한 부여하기 위해 SQL 문을 컴파일 할 때 호출되는 프로 시저 이름입니다. 콜백 프로시 저는 코딩중인 오퍼레이션을 설명하는 5 개의 인수를 사용합니다. 콜백이 텍스트 문자열 &quot;SQLITE_OK&quot;를 리턴하면 조작이 허용됩니다. &quot;SQLITE_IGNORE&quot;를 반환하면 작업이 자동으로 비활성화됩니다. 리턴이 &quot;SQLITE_DENY&quot;인 경우 오류로 컴파일에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">&quot;automerge = N&quot;명령 (여기서 N은 0에서 15 사이의 정수임)은 자동 증분 반전 인덱스 병합을 제어하는 ​​FTS3 / 4 테이블 &quot;automerge&quot;매개 변수를 구성하는 데 사용됩니다. 새 테이블의 기본 자동 병합 값은 0입니다. 즉, 자동 증분 병합이 완전히 사용되지 않습니다. &quot;automerge = N&quot;명령을 사용하여 automerge 매개 변수의 값을 수정하면 새 매개 변수 값이 데이터베이스에 지속적으로 저장되고 이후에 설정된 모든 데이터베이스 연결에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">&quot;백업&quot;방법</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">&quot;backup&quot;방법은 라이브 데이터베이스의 백업 사본을 만듭니다. 명령 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">&quot;bind_fallback&quot;메소드</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">&quot;bind_fallback&quot;메소드는 매개 변수 이름과 일치하는 TCL 변수가 없을 때 응용 프로그램이 매개 변수 바인딩을 처리하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">&quot;bind_fallback&quot;메소드에는 단일 선택적 인수가 있습니다. 인수가 빈 문자열이면 bind_fallback이 취소되고 기본 동작이 복원됩니다. 인수가 비어 있지 않은 문자열 인 경우, 인수는 TCL 변수와 일치하지 않는 SQL 매개 변수가 표시 될 때마다 호출하는 TCL 명령 (일반적으로 proc의 이름)입니다. &quot;bind_fallback&quot;메소드에 인수가 없으면 현재 bind_fallback 명령이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">&quot;바쁜&quot;방법</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">&quot;timeout&quot;과 같은 &quot;busy&quot;방법은 데이터베이스가 잠겨있을 때만 작동합니다. 그러나 &quot;사용 중&quot;방법을 사용하면 프로그래머가 수행 할 작업을 훨씬 더 많이 제어 할 수 있습니다. &quot;busy&quot;메소드는 SQLite가 잠긴 데이터베이스를 열려고 시도 할 때마다 호출되는 콜백 Tcl 프로 시저를 지정합니다. 단일 정수 인수가 호출되기 전에 콜백에 추가됩니다. 인수는 현재 잠금 이벤트에 대한 통화 중 콜백에 대한 이전 호출 수입니다. 콜백은 잠깐 동안 다른 유용한 작업 (예 : 서비스 GUI 이벤트)을 수행 한 후 리턴하여 잠금을 다시 시도 할 수 있도록하기위한 것입니다. 콜백 프로시 저는 SQLite가 데이터베이스를 다시 열려고 할 경우 &quot;0&quot;을 리턴하고 SQLite가 현재 조작을 포기하도록하려면 &quot;1&quot;을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">&quot;캐시&quot;방법</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">&quot;변경&quot;방법</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">&quot;changes&quot;메소드는 가장 최근의 &quot;eval&quot;메소드에 의해 삽입, 삭제 및 / 또는 수정 된 데이터베이스의 행 수인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">&quot;닫기&quot;방법</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">&quot;콜레이트&quot;방법</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">&quot;collation_needed&quot;메소드</target>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="translated">&quot;열&quot;모드는 표 형식의 출력 형식입니다. &quot;box&quot;, &quot;markdown&quot;및 &quot;table&quot;과 같은 기타 표 형식 출력 형식 :</target>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="translated">&quot;column&quot;출력 모드는 가장 긴 출력 행을 포함하도록 자동으로 열을 확장하고 이전에 설정되지 않은 경우 &quot;.header&quot;를 자동으로 켭니다.</target>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 또는 FROM- 절 서브 쿼리 의 &quot;열&quot; 은 실제로 VIEW 또는 서브 쿼리를 구현하는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에있는 표현식입니다 . 따라서 VIEW 또는 하위 쿼리의 열에 대한 선호도는 위의 표현식 선호도 규칙에 의해 결정됩니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">&quot;commit_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">&quot;완전한&quot;방법</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">&quot;완전한&quot;방법은 사용자가 SQL 코드 줄을 입력 한 시점을 알기 위해 대화식 응용 프로그램을 작성할 때 유용합니다. 이것은 실제로 &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete ()&lt;/b&gt;&lt;/a&gt; C 함수에 대한 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">&quot;complete&quot;메소드는 유일한 SQL 문자열로 간주됩니다. 문자열이 완전한 SQL 문인 경우 TRUE를, 더 입력해야 할 경우 FALSE를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">&quot;config&quot;메소드</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">&quot;config&quot;메소드는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스를 사용하여 데이터베이스 연결에 대한 특정 구성 설정을 조회하거나 변경합니다 . 사용 가능한 구성 설정 및 현재 값의 TCL 목록을 얻으려면 인수없이이 메소드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">&quot;configure&quot;스크립트는 이제 큰 파일 지원을 위해 Unix 시스템을 자동으로 구성해야합니다. 큰 파일이 있고 큰 파일 지원이 비활성화 된 경우에 대한 오류 메시지가 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X 번째 루프에 대한 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명이 포함 된 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X 번째 루프에 대한 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명이 포함 된 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;const char *&quot;변수는 X 번째 루프에 사용 된 인덱스 또는 테이블 이름을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X- 번째 루프에 대한 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수 는 X- 번째 루프에 대한 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 설명을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;const char *&quot;변수는 X 번째 루프에 사용되는 인덱스 또는 테이블의 이름을 포함하는 0으로 끝나는 UTF-8 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">&quot;content&quot;옵션은 FTS5 테이블을 &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;외부 컨텐츠 또는 contentless 테이블&lt;/a&gt; 로 만드는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">&quot;content_rowid&quot;옵션은 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 컨텐츠 테이블&lt;/a&gt; 의 rowid 필드를 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">&quot;복사&quot;방법</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">&quot;복사&quot;방법은 파일에서 테이블로 데이터를 복사합니다. 파일에서 성공적으로 처리 된 행 수를 리턴합니다. 복사 방법의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">여기서 &quot;비용&quot;은 로그입니다. 중첩 루프를 사용하면 작업이 곱해지고 추가되지 않습니다. 그러나 가중 가중치가있는 그래프를 생각하는 것이 일반적이므로 그래프는 다양한 비용의 로그를 보여줍니다. 그래프는 S가 약 6.87 인 L의 비용 이점을 보여 주지만 이는 S 루프가 L 루프의 외부가 아닌 L 루프의 내부에있을 때 약 963 배 더 빠르게 실행되는 쿼리로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">쉘의 &quot;csv&quot;모드 옵션은 문자열을 큰 따옴표 안에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">&quot;db&quot;매개 변수는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터 입니다. &quot;main&quot;인수는 임 포스터 테이블이 작성 될 스키마의 이름입니다. &quot;1&quot;인수는 임 포스터 테이블 메커니즘을 사용 가능하게합니다. &quot;tnum&quot;은 임 포스터 테이블이 미러링해야하는 인덱스의 루트 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">&quot;직렬화 해제&quot;방법</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">&quot;deserialize&quot;메소드는 SQLite 데이터베이스 파일이 포함 된 TCL 바이트 배열을 가져 와서 데이터베이스 연결에 추가합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">&quot;docid&quot;별명이 존재하지 않습니다. 응용 프로그램은 &quot;rowid&quot;를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;double&quot;변수는 X 번째 루프의 각 반복에서 출력 된 평균 행 수에 대한 쿼리 플래너의 추정치로 설정됩니다. 쿼리 플래너의 추정값이 정확하면이 값은 몫 NVISIT / NLOOP에 근사하며 동일한 SELECTID를 가진 모든 이전 루프에 대한이 값의 곱은 현재 루프의 NLOOP 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;double&quot;변수는 X 번째 루프의 각 반복에서 출력되는 평균 행 수에 대한 쿼리 플래너의 추정치로 설정됩니다. 쿼리 플래너의 추정값이 정확하면이 값은 몫 NVISIT / NLOOP에 가깝고 동일한 SELECTID를 가진 모든 이전 루프에 대한이 값의 곱은 현재 루프의 NLOOP 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">&quot;인상&quot;텍스트.</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">&quot;enable_load_extension&quot;메소드</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">&quot;엔드 매치&quot;텍스트</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">&quot;오류 코드&quot;방법</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">&quot;평가&quot;방법</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">&lt;a href=&quot;#eval&quot;&gt;위에서&lt;/a&gt; 설명한 &quot;eval&quot;메소드는 최근에 평가 된 SQL 명령에 대해 &lt;a href=&quot;c3ref/prepare&quot;&gt;준비된 명령문&lt;/a&gt; 의 캐시를 유지 합니다. &quot;캐시&quot;방법은이 캐시를 제어하는 ​​데 사용됩니다. 이 명령의 첫 번째 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">&quot;존재&quot;방법</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">&quot;exists&quot;메소드는 종종 테이블에 행이 있는지 테스트하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">&quot;exists&quot;메소드는 SQL 문을 실행한다는 점에서 &quot;onecolumn&quot;및 &quot;eval&quot;과 유사합니다. 차이점은 &quot;exists&quot;메소드는 SQL 문의 쿼리가 하나 이상의 행을 리턴하면 SQL이 빈 세트를 리턴하면 FALSE 인 부울 값을 항상 리턴한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">&quot;family&quot;테이블은 이전의 &quot;org&quot;테이블과 비슷하지만 각 구성원마다 두 명의 부모가 있습니다. 우리는 가장 오래된 것부터 가장 어린 것까지 Alice의 모든 살아있는 조상을 알고 싶습니다. 일반적인 공통 테이블 표현식 &quot;parent_of&quot;가 먼저 정의됩니다. 그 평범한 CTE는 개인의 모든 부모를 찾는 데 사용될 수있는 견해입니다. 이 일반 CTE는 &quot;ancestor_of_alice&quot;재귀 CTE에서 사용됩니다. 그런 다음 재귀 CTE가 최종 쿼리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">secure_delete의 &quot;fast&quot;설정 (2017-08-01 경에 추가됨)은 &quot;on&quot;과 &quot;off&quot;사이의 중간 설정입니다. secure_delete가 &quot;fast&quot;로 설정되면 SQLite는 I / O의 양을 늘리지 않는 경우에만 삭제 된 내용을 0으로 덮어 씁니다. 즉, &quot;빠른&quot;설정은 더 많은 CPU주기를 사용하지만 더 많은 I / O를 사용하지는 않습니다. 이는 &lt;a href=&quot;fileformat2#btree&quot;&gt;b- 트리 페이지&lt;/a&gt; 에서 모든 오래된 컨텐츠를 제거 하지만 &lt;a href=&quot;fileformat2#freelist&quot;&gt;프리리스트 페이지에는&lt;/a&gt; 법 의학적 흔적을 남기는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">헤더가 WAL 재설정으로 작성된 후 발생하는 &quot;fsync ()&quot;는 이제 체크 포인트에 대한 동기화 설정을 사용합니다. 이는 &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync가&lt;/a&gt; 설정된 경우 Mac에서 &quot;fullfsync&quot;를 사용한다는 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">&quot;fts3tokenize&quot;가상 테이블을 사용하여 모든 토크 나이저에 직접 액세스 할 수 있습니다. 다음 SQL은 fts3tokenize 가상 테이블의 인스턴스를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">&quot;풀키&quot;열은 원래 JSON 문자열 내에서 현재 행 요소를 고유하게 식별하는 텍스트 경로입니다. &quot;루트&quot;인수로 대체 시작점이 제공 되더라도 실제 최상위 레벨 요소의 완전한 키가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">&quot;기능&quot;방법</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">&quot;function&quot;메소드는 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">&quot;function&quot;메소드는 새로운 SQL 함수를 SQLite 엔진에 등록합니다. 인수는 새 SQL 함수의 이름과 해당 함수를 구현하는 TCL 명령입니다. 함수에 대한 인수는 TCL 명령이 호출되기 전에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">&quot;fuzzershell.c&quot;프로그램은 일부 &lt;a href=&quot;#fuzztesting&quot;&gt;퍼즈 테스트&lt;/a&gt; 를 실행하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&quot;iScanStatusOp&quot;매개 변수는 반환 할 상태 정보를 결정합니다. &quot;iScanStatusOp&quot;는 &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus 옵션&lt;/a&gt; 중 하나이거나이 인터페이스의 동작이 정의되어 있지 않습니다. 요청 된 측정은 &quot;pOut&quot;매개 변수가 가리키는 변수에 기록됩니다. &quot;idx&quot;매개 변수는 통계를 검색 할 특정 루프를 식별합니다. 루프는 0부터 시작하여 번호가 매겨집니다. idx가 명령문을 구현하는 데 사용 된 총 루프 수보다 크거나 같은 범위를 벗어나면 0이 아닌 값이 리턴되고 pOut이 가리키는 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">&quot;iScanStatusOp&quot;매개 변수는 반환 할 상태 정보를 결정합니다. &quot;iScanStatusOp&quot;는 &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus 옵션&lt;/a&gt; 중 하나이거나이 인터페이스의 동작이 정의되어 있지 않습니다. 요청 된 측정은 &quot;pOut&quot;매개 변수가 가리키는 변수에 기록됩니다. &quot;idx&quot;매개 변수는 통계를 검색 할 특정 루프를 식별합니다. 루프는 0부터 시작하여 번호가 매겨집니다. idx가 명령문을 구현하는 데 사용 된 총 루프 수보다 크거나 같은 범위를 벗어나면 0이 아닌 값이 리턴되고 pOut이 가리키는 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">&quot;id&quot;열은 전체 JSON 문자열에서 특정 JSON 요소를 식별하는 정수입니다. &quot;id&quot;정수는 내부 하우스 키핑 번호이며 계산은 향후 릴리스에서 변경 될 수 있습니다. 유일한 보장은 &quot;id&quot;열이 모든 행마다 다르다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">&quot;incrblob&quot;방법</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">&quot;인덱스&quot;또는 준비 영역</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">&quot;입력&quot;CTE는 입력 퍼즐을 정의합니다. &quot;숫자&quot;CTE는 1과 9 사이의 모든 숫자를 보유하는 테이블을 정의합니다. 퍼즐 해결 작업은 &quot;x&quot;CTE에 의해 수행됩니다. x (s, ind)의 항목은 81 자 문자열 &quot;s&quot;가 유효한 스도쿠 퍼즐 (충돌이 없음)이고 첫 번째 알 수없는 문자가 &quot;ind&quot;위치에 있거나 ind == 0 인 경우를 의미합니다. 문자 위치가 채워집니다. 그런 다음 목표는 &quot;ind&quot;가 0 인 &quot;x&quot;에 대한 항목을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프에 대해 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 값과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">T 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프에 대해 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 값과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프의 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 것과 동일한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">V 매개 변수가 가리키는 &quot;int&quot;변수는 X 번째 루프의 &quot;select-id&quot;로 설정됩니다. select-id는 루프가 속한 쿼리 또는 하위 쿼리를 식별합니다. 기본 쿼리의 select-id는 0입니다. select-id는 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 쿼리 의 첫 번째 열에 출력 된 것과 동일한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">&quot;integrity-check&quot;명령은 SQLite가 반전 된 인덱스를 원본 컨텐츠와 비교하여 FTS3 / 4 테이블의 모든 반전 된 인덱스의 정확성을 읽고 확인하도록합니다. &quot;integrity-check&quot;명령은 반전 된 인덱스가 모두 정상이면 자동으로 성공하지만 문제점이 발견되면 SQLITE_CORRUPT 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">&quot;integrity-check&quot;명령은 개념적으로 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 와 유사 합니다 . 작업 시스템에서 &quot;integrity-command&quot;는 항상 성공해야합니다. 무결성 검사 실패의 가능한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">&quot;인터럽트&quot;방법</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">&quot;interrupt&quot;메소드는 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 인터페이스를 호출하여 보류중인 쿼리를 중지시킵니다.</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">&quot;isInit&quot;플래그 shm 파일이 초기화 된 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">데이터베이스의 &quot;격리&quot;속성은 한 작업에 의한 데이터베이스 변경 사항이 다른 동시 작업에 표시되는 시점을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">&quot;키&quot;열은 JSON 배열 요소의 정수 배열 색인이고 JSON 오브젝트 요소의 텍스트 레이블입니다. 다른 모든 경우에는 키 열이 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">&quot;last_insert_rowid&quot;메소드</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">&quot;last_insert_rowid&quot;메소드는 가장 최근에 삽입 된 데이터베이스 행의 ROWID 인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">&quot;localtime&quot;수정 자 (12)는 왼쪽의 시간 문자열이 UTC (Universal Coordinated Time)에 있다고 가정하고 현지 시간을 표시하도록 시간 문자열을 조정합니다. &quot;localtime&quot;이 UTC가 아닌 시간을 따르는 경우 동작이 정의되지 않습니다. &quot;utc&quot;수정자는 &quot;localtime&quot;과 반대입니다. &quot;utc&quot;는 왼쪽에있는 문자열이 현지 시간대에 있다고 가정하고 해당 문자열을 UTC로 조정합니다. 이전 문자열이 현지 시간이 아닌 경우 &quot;utc&quot;의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">&quot;lost_and_found&quot;테이블에는 데이터베이스에서 복구 된 각 고아 행마다 하나의 행이 있습니다. 또한 복구 된 각 인덱스 항목마다 하나의 행이있어 SQL 인덱스에 기인 할 수 없습니다. 이는 SQLite 데이터베이스에서 동일한 형식이 SQL 인덱스 항목과 WITHOUT ROWID 테이블 항목을 저장하는 데 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">dbstat의 &quot;main&quot;인수는 정보를 제공 할 기본 스키마입니다. 기본값은 &quot;main&quot;이므로 위 예에서 &quot;main&quot;은 중복됩니다. 특정 쿼리의 경우 대체 스키마를 쿼리의 FROM 절에서 가상 테이블 이름에 대한 함수 인수로 지정하여 스키마를 변경할 수 있습니다. (자세한 내용 &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;은 FROM 절의 테이블 반환 함수에&lt;/a&gt; 대한 자세한 설명을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">&quot;make&quot;유틸리티 또는 Windows의 경우 선택적으로 &quot;nmake&quot;</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">&quot;matchinfo = fts3&quot;옵션을 사용할 수 없습니다. &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;ColumnSize가 = 0&quot;&lt;/a&gt; 옵션은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">&quot;병합&quot;명령은 원 (1)과 (4) 사이의 모든 변경 사항을 로컬 체크 아웃의 파일에 적용하려고합니다. 서클 (5)은 아직 생성되지 않았습니다. 서클 (5)을 만들려면 &quot;커밋&quot;을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">&quot;merge = X, Y&quot;명령 (여기서 X 및 Y는 정수)은 SQLite가 FTS3 / 4 테이블의 다양한 반전 인덱스 b- 트리를 하나의 큰 b- 트리로 병합하기 위해 제한된 양의 작업을 수행하게합니다. X 값은 병합 할 &quot;블록&quot;의 대상 수이고 Y는 병합이 해당 수준에 적용되기 전에 필요한 수준의 최소 b- 트리 세그먼트 수입니다. Y 값은 권장 값 8을 사용하여 2와 16 사이 여야합니다. X 값은 양의 정수일 수 있지만 100-300 정도의 값이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">&quot;missing&quot;매개 변수를 사용 하면 필요한 데이터베이스 파일이 디스크에없는 경우 swarmvtab이 데이터베이스를 열기 직전에 호출 될 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 이를 통해 응용 프로그램은 swarmvtab에서 데이터베이스를 열기 전에 원격 소스에서 필요한 데이터베이스를 검색 할 수 있습니다. &quot;누락 된&quot;함수에 전달되는 유일한 인수는 열려있는 데이터베이스를 식별하는 이름 또는 URI입니다. 가정 :</target>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">&quot;missing&quot;매개 변수를 사용 하면 필요한 데이터베이스 파일이 디스크에없는 경우 swarmvtab에서 데이터베이스를 열기 직전에 호출 될 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 이를 통해 swarmvtab에서 데이터베이스를 열려고 시도하기 전에 원격 소스에서 필요한 데이터베이스를 검색 할 수 있습니다. &quot;missing&quot;함수에 전달 된 유일한 인수는 열려는 데이터베이스를 식별하는 이름 또는 URI입니다. 가정 :</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">&quot;mmap_size&quot;는 SQLite가 한 번에 프로세스 주소 공간에 맵핑하려고 시도하는 데이터베이스 파일의 최대 바이트 수입니다. mmap_size는 각 데이터베이스 파일에 개별적으로 적용되므로 잠재적으로 사용될 수있는 총 프로세스 주소 공간은 mmap_size와 열린 데이터베이스 파일 수의 곱입니다.</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">&quot;mptester.c&quot;프로그램은 단일 데이터베이스를 동시에 읽고 쓰는 여러 프로세스에 대한 스트레스 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">&quot;널값&quot;방법</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">&quot;널값&quot;메소드는 &quot;eval&quot;메소드의 결과로 리턴 된 NULL의 표시를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">&quot;nullvalue&quot;방법은 Tcl에 NULL 표현이 없기 때문에 NULL과 빈 열 값을 다르게하는 데 유용합니다. NULL 값의 기본 표현은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">&quot;onecolumn&quot;방법</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">&quot;onecolumn&quot;메소드 는 인수로 제공된 SQL 쿼리 문을 평가한다는 점에서 &quot; &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; &quot; 과 같이 작동합니다 . 차이점은 &quot;onecolumn&quot;은 쿼리 결과의 첫 번째 행의 첫 번째 열인 단일 요소를 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">&quot;onoff&quot;매개 변수는 메모리 통계 추적을 사용하려면 true이고 통계 추적을 사용하지 않으려면 false입니다.</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&quot;openclose&quot;매개 변수를 사용하면 swarmvtab이 데이터베이스를 열기 직전과 데이터베이스를 닫은 직후에 다시 호출 될 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. 열기 닫기 함수에 전달 된 첫 번째 인수는 열거 나 최근에 닫을 데이터베이스를 식별하는 파일 이름 또는 URI입니다 (CREATE VIRTUAL TABLE 명령에 제공된 SQL 문의 맨 왼쪽 열에 반환 된 동일한 값). 두 번째 인수는 데이터베이스를 열기 전에 함수가 호출 될 때 정수 값 0이고, 하나가 닫힌 후 호출 될 때 1입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">&quot;openclose&quot;매개 변수를 통해 사용자 는 swarmvtab이 데이터베이스를 열기 직전에, 그리고 데이터베이스를 닫은 직후에 호출 될 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 이름을 지정할 수 있습니다. open close 함수에 전달 된 첫 번째 인수는 열거 나 최근에 닫을 데이터베이스를 식별하는 파일 이름 또는 URI입니다 (CREATE VIRTUAL TABLE 명령에 제공된 SQL 문의 가장 왼쪽 열에 리턴 된 것과 동일한 값). 두 번째 인수는 데이터베이스를 열기 전에 함수를 호출 할 때 정수 값 0이고, 하나를 닫은 후 호출 될 때 1입니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">&quot;optimize&quot;명령은 FTS3 / 4가 모든 거꾸로 된 인덱스 b- 트리를 하나의 크고 완전한 b- 트리로 병합하도록합니다. 최적화를 수행하면 검색 할 b- 트리가 적기 때문에 후속 쿼리 실행 속도가 빨라지고 중복 항목을 병합하여 디스크 사용량이 줄어들 수 있습니다. 그러나 큰 FTS 테이블의 경우 최적화 실행은 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 실행만큼 비쌀 수 있습니다 . optimize 명령은 본질적으로 전체 FTS 테이블을 읽고 써야하므로 큰 트랜잭션이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">&quot;order&quot;옵션은 &quot;DESC&quot;또는 &quot;ASC&quot;(대문자 또는 소문자)로 설정 될 수 있습니다. &quot;DESC&quot;로 설정된 경우 FTS4는 반환 결과를 docid로 내림차순으로 최적화하는 방식으로 데이터를 저장합니다. &quot;ASC&quot;(기본값)로 설정된 경우 데이터 구조는 결과를 오름차순으로 docid로 반환하도록 최적화됩니다. 다시 말해, FTS4 테이블에 대해 실행되는 많은 쿼리가 &quot;ORDER BY docid DESC&quot;를 사용하는 경우 &quot;order = desc&quot;옵션을 CREATE VIRTUAL TABLE 문에 추가하는 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">&quot;pBuf&quot;매개 변수는 lookaside 메모리 풀에 사용될 메모리 공간에 대한 포인터입니다. pBuf가 NULL이면 SQLite는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 메모리 풀을위한 자체 공간을 확보합니다 . &quot;sz&quot;및 &quot;cnt&quot;매개 변수는 각 lookaside 슬롯의 크기와 슬롯 수입니다. pBuf가 NULL이 아닌 경우 최소 sz * cnt 바이트의 메모리를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">json_each ()의 &quot;부모&quot;열은 항상 NULL입니다. json_tree ()의 경우, &quot;parent&quot;열은 현재 요소의 부모에 대한 &quot;id&quot;정수이거나 최상위 JSON 요소 또는 두 번째 인수에서 루트 경로로 식별되는 요소에 대해서는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">&quot;경로&quot;열은 btree 구조의 루트 노드에서 각 페이지로가는 경로를 설명합니다. 루트 노드 자체의 &quot;경로&quot;는 '/'입니다. btree 페이지 루트의 가장 왼쪽에있는 하위 페이지의 &quot;경로&quot;는 '/ 000 /'입니다. (트리에는 왼쪽에서 오른쪽으로 정렬 된 내용이 저장되므로 왼쪽에있는 페이지는 오른쪽에있는 페이지보다 작은 키를 갖습니다.) 루트 페이지의 가장 왼쪽에있는 하위 옆에있는 '/ 001'은 각 형제 페이지입니다. 3 자리 16 진수 값으로 식별됩니다. 가장 왼쪽의 451 번째 형제의 자식에는 '/ 1c2 / 000 /,'/ 1c2 / 001 / '등과 같은 경로가 있습니다. 오버플로 페이지는 경로에'+ '문자와 6 자리 16 진수 값을 추가하여 지정됩니다. 그들이 연결된 세포에. 예를 들어루트 페이지에서 450 번째 자식 하위의 가장 왼쪽 셀에서 연결된 체인의 3 개의 오버플로 페이지는 경로로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">&quot;경로&quot;열은 btree 구조의 루트 노드에서 각 페이지로 가져온 경로를 설명합니다. 루트 노드 자체의 &quot;경로&quot;는 '/'입니다. &quot;aggregate&quot;가 TRUE 인 경우 &quot;path&quot;는 NULL입니다. btree 페이지 루트의 맨 왼쪽 자식 페이지에 대한 &quot;경로&quot;는 '/ 000 /'입니다. (Btree는 콘텐츠를 왼쪽에서 오른쪽으로 정렬하여 저장하므로 왼쪽 페이지는 오른쪽 페이지보다 작은 키를 갖습니다.) 루트 페이지의 맨 왼쪽 자식 옆은 '/ 001'이고 각 형제 페이지는 계속됩니다. 3 자리 16 진수 값으로 식별됩니다. 451 번째 가장 왼쪽 형제의 자식에는 '/ 1c2 / 000 /,'/ 1c2 / 001 / '등과 같은 경로가 있습니다. 오버플로 페이지는 경로에'+ '문자와 6 자리 16 진수 값을 추가하여 지정됩니다. 연결된 셀에. 예를 들면루트 페이지의 450 번째 자식의 가장 왼쪽 셀에서 링크 된 체인의 세 오버플로 페이지는 경로로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">&quot;경로&quot;열은 현재 행을 보유하는 배열 또는 객체 컨테이너의 경로이거나, 기본 유형에서 반복이 시작되어 단일 행의 출력 만 제공하는 경우 현재 행의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 에 대한 마지막 매개 변수의 &quot;포인터 유형&quot;은 한 확장에 대한 포인터가 다른 확장으로 리디렉션되지 않도록하는 데 사용됩니다. 예를 들어, 포인터 유형을 사용하지 않아도 공격자는 여전히 &lt;a href=&quot;fts3&quot;&gt;다음&lt;/a&gt; 과 같은 SQL을 사용하여 FTS3 및 &lt;a href=&quot;carray&quot;&gt;CARRAY 확장&lt;/a&gt; 을 모두 포함하는 시스템의 포인터 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">각 포인터 전달 인터페이스에 대한 마지막 매개 변수 인 &quot;포인터 유형&quot;문자열은 API 호출에 직접 나타나는 고유 한 응용 프로그램 특정 문자열 리터럴이어야합니다. 포인터 유형은 상위 수준 함수에서 전달 된 매개 변수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">&quot;접두사&quot;옵션 은 FTS5 테이블에 &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;접두사 색인&lt;/a&gt; 을 추가하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">&quot;캘리포니아 오렌지의 가격&quot;쿼리는 2 열 인덱스를 사용하여보다 효율적으로 이루어졌습니다. 그러나 SQLite는 &quot;price&quot;열을 포함하는 3 열 인덱스를 사용하여 더 잘 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">&quot;프로파일&quot;방법</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">&quot;진보&quot;방법</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="translated">&quot;따옴표&quot;출력 모드는 &quot;.separator&quot;를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">&quot;rbu_control&quot;열은 INSERT에 대해 정수 값 2로 설정 될 수도 있습니다. 이 경우 새 행은 기본 키 값이 동일한 기존 행을 자동으로 바꿉니다. 이는 동일한 기본 키 값을 가진 INSERT 뒤에 DELETE와 같습니다. 새 행이 충돌하는 기본 키가있는 행뿐만 아니라 충돌하는 행 (즉, UNIQUE 제한 조건 또는 인덱스로 인해 충돌하는 행)을 대체 할 수 있으므로 SQL REPLACE 명령과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">&quot;rebuild&quot;명령은 SQLite가 전체 FTS3 / 4 테이블을 버린 다음 원래 텍스트에서 다시 작성합니다. 이 개념은 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 와 유사하지만 일반 색인 대신 FTS3 / 4 테이블에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">모든 콘텐츠를 다시 토큰화할 수 있도록 사용자 정의 토크 나이저의 구현이 변경 될 때마다 &quot;재 구축&quot;명령을 실행해야합니다. &quot;재 구축&quot;명령은 원본 컨텐츠 테이블을 변경 한 후 &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 컨텐츠 옵션&lt;/a&gt; 을 사용할 때도 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">&quot;복원&quot;방법</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">&quot;복원&quot;방법은 별도의 데이터베이스 파일에서 현재 데이터베이스 연결로 내용을 복사하여 기존의 내용을 덮어 씁니다. 명령 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">&quot;rollback_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">비교를위한 &quot;점수&quot;는 패턴과 단어 사이의 편집 거리이며 단어 순위의 밑이 2 인 로그에 의해 조정됩니다. 예를 들어, 거리가 100이지만 순위가 1000 인 일치의 점수는 122 (= 100-log2 (1000) + 32)이며, 거리가 100 인 일치하는 순위는 131 (100-log2 ( 1) + 32). (NB : 편집 거리가 0 인 경우 음수가되지 않도록 상수 32가 각 점수에 추가됩니다.) 이런 방식으로 자주 사용되는 단어는 약간 더 낮은 비용을 가져서 목록의 맨 위로 이동합니다. 대체 철자.</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">&quot;직렬화&quot;방법</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">&quot;직렬화&quot;메소드는 기본 데이터베이스의 전체 사본 인 BLOB를 작성합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">행 값의 &quot;크기&quot;는 행 값에 포함 된 스칼라 값의 수입니다. 행 값의 크기는 항상 2 이상입니다. 단일 열이있는 행 값은 스칼라 값입니다. 열이없는 행 값은 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">&quot;speedtest1.c&quot;프로그램은 일반적인 워크로드에서 SQLite의 성능을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">&quot;spellfix1&quot;용어는 spellfix 모듈의 이름이며 표시된대로 입력해야합니다. &quot;데모&quot;용어는 생성 할 가상 테이블의 이름이며 응용 프로그램의 요구에 맞게 변경할 수 있습니다. 가상 테이블은 처음에 비어 있습니다. 가상 테이블을 유용하게 사용하려면 가상 테이블을 어휘로 채워야합니다. &quot;big_vocabulary&quot;라는 테이블에 단어 목록이 있다고 가정하십시오. 그런 다음이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">&quot;sqlite3.c&quot;코드 파일에는 VFS 및 Unix, Windows 및 OS / 2에 적합한 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 함수 의 기본 구현이 포함되어 있습니다 . sqlite3.c를 컴파일 할 때 이러한 기본 구성 요소 중 하나가로드되지 않도록하려면 다음 컴파일 타임 옵션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">&quot;sqlite3.c&quot;make 대상은 일반 &quot; &lt;b&gt;sqlite3.c&lt;/b&gt; &quot;합병 소스 파일, 헤더 파일 &quot; &lt;b&gt;sqlite3.h&lt;/b&gt; &quot;및 TCL 인터페이스를 포함하는 &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot;합병 소스 파일을 자동으로 구성합니다 . 그런 다음 필요한 파일을 프로젝트 디렉토리에 복사하고 위에서 설명한 절차에 따라 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">SQLite 소스 트리에서 소스 코드로 또는 &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite 다운로드 페이지&lt;/a&gt; 에서 사전 컴파일 된 바이너리로 사용 가능한 &quot;sqlite3_analyzer.exe&quot;유틸리티 프로그램을 사용 하여 기존 SQLite 데이터베이스에서 테이블 행의 평균 크기를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">&quot;시작 일치&quot;텍스트</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">&quot;시작&quot;수정 자 (7-9)는 날짜를 현재 월, 연도 또는 일의 시작으로 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">&quot;state&quot;인덱스는 rowid 앞에 여분의 열이 있고 새로운 키를 기본 키로 정렬한다는 점에서 &quot;fruit&quot;인덱스와 동일하게 작동합니다. 유일한 차이점은 Idx2에서 첫 번째 열은 Idx1에서와 같이 &quot;fruit&quot;대신 &quot;state&quot;라는 것입니다. 이 예제 데이터 세트에서 &quot;상태&quot;열에는 중복성이 더 많으므로 중복 항목이 더 많습니다. 관계는 여전히 rowid를 사용하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">&quot;상태&quot;방법</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">&quot;swarmvtab&quot;가상 테이블을 사용하면 사용자는 유사한 스키마를 갖지만 단일 범위의 rowid 값을 단일 데이터베이스 테이블 인 것처럼 많은 수의 테이블 (이하 &quot;구성 요소&quot;테이블)을 쿼리 할 수 ​​있습니다. 테이블은 다른 데이터베이스에있을 수 있습니다. Swarmvtab 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">&quot;sz&quot;매개 변수는 각 lookaside 슬롯의 크기 (바이트)입니다. &quot;cnt&quot;매개 변수는 데이터베이스 연결 당 총 lookaside 메모리 슬롯 수입니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 할당 된 lookaside 메모리의 총량 은 sz * cnt 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">&quot;sz = NNN&quot;인수 (NNN은 1 자리 이상의 시퀀스를 나타냄)는 테이블 또는 인덱스의 모든 레코드에 대한 평균 행 크기가 행당 NNN 바이트임을 의미합니다. SQLite 쿼리 플래너는 &quot;sz = NNN&quot;토큰이 제공하는 예상 행 크기 정보를 사용하여 디스크 I / O가 덜 필요한 더 작은 테이블과 인덱스를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">&quot;temp&quot;데이터베이스 (TEMP 테이블 및 인덱스가 저장 됨) 및 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스는&lt;/a&gt; 항상 독점 잠금 모드를 사용합니다. 임시 및 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 잠금 모드는 변경할 수 없습니다. 다른 모든 데이터베이스는 기본적으로 일반 잠금 모드를 사용하며이 pragma의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">위에서 만든 &quot;test1.dir&quot;디렉토리는 모든 얼룩을 단일 폴더에 넣습니다. 단일 디렉토리에 100,000 개의 오브젝트가있는 경우 일부 운영 체제의 성능이 저하 될 것이라고 추측했습니다. 이를 테스트하기 위해 kvtest 프로그램은 폴더 당 파일 및 / 또는 하위 디렉토리가 100 개 이하인 폴더 계층 구조에 블롭을 저장할 수도 있습니다. 다음과 같이 --tree 명령 행 옵션을 사용하여 &quot;export&quot;명령에 대한 블랍의 대체 디스크 상 표현을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">&quot;th3&quot;바이너리가 실행되고 출력에 오류가 있는지 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">&quot;threadtest3.c&quot;프로그램은 SQLite를 동시에 사용하는 여러 스레드에 대한 스트레스 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">&quot;세&quot;열-버킷의 열쇠</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">&quot;타임 아웃&quot;방법</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">&quot;timeout&quot;메소드는 데이터베이스 트랜잭션을 포기하기 전에 SQLite 라이브러리가 잠금이 해제 될 때까지 대기하는 시간을 제어하는 ​​데 사용됩니다. 기본 시간 초과는 0 밀리 초입니다. 즉, 기본 동작은 전혀 기다리지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">&quot;토큰 화&quot;옵션은 &lt;a href=&quot;fts5#tokenizers&quot;&gt;사용자 정의 토크 나이저&lt;/a&gt; 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">&quot;total_changes&quot;메소드</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">&quot;total_changes&quot;메소드는 현재 데이터베이스 연결이 처음 열린 이후 데이터베이스에서 삽입, 삭제 및 / 또는 수정 된 행 수인 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">&quot;추적&quot;방법</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">&quot;trace&quot;메소드는 각 SQL 문이 컴파일 될 때 호출되는 콜백을 등록합니다. SQL 텍스트는 호출되기 전에 명령에 단일 문자열로 추가됩니다. 예를 들어 응용 프로그램이 수행하는 모든 SQL 작업의 로그를 유지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">&quot;trace_v2&quot;메소드</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">&quot;trace_v2&quot;메소드는 각 SQL 문이 컴파일 될 때 호출되는 콜백을 등록합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">&quot;트랜잭션&quot;방법</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">&quot;트랜잭션&quot;메소드는 SQLite 데이터베이스 트랜잭션 내에서 TCL 스크립트를 실행하는 데 사용됩니다. 스크립트가 완료되면 트랜잭션이 커밋되거나 스크립트가 실패하면 롤백됩니다. 트랜잭션이 다른 트랜잭션 (BEGIN을 사용하여 수동으로 시작된 트랜잭션) 내에서 발생하는 경우 트랜잭션이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">&quot;type&quot;열은 유형에 따라 ( 'null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object')에서 가져온 SQL 텍스트 값입니다. 현재 JSON 요소</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">&quot;일반적인&quot;워크로드는 표준 SQLite 소스 트리 의 &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; 프로그램에 의해 생성됩니다 . 이 프로그램은 실제 응용 프로그램에서 일반적인 방식으로 SQLite 라이브러리를 실행하려고합니다. 물론 모든 응용 프로그램이 다르므로 테스트 응용 프로그램이 모든 응용 프로그램의 동작을 정확하게 반영 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">&quot;ui&quot;명령은 화석이 소형 내장 웹 서버를 실행하고 해당 웹 서버를 가리키는 웹 브라우저를 시작하게합니다. 웹 브라우저를 사용하여 다양한 방법으로 프로젝트를 구성 할 수 있습니다. 추가 정보는 화석 웹 사이트의 지침을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">&quot;unicode61&quot;토크 나이 저는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;버전 3.7.13&lt;/a&gt; (2012-06-11) 부터 사용할 수 있습니다 . Unicode61은 유니 코드 버전 6.1의 규칙에 따라 간단한 유니 코드 케이스 접기를 수행하고 유니 코드 공간과 문장 부호 문자를 인식하고이를 토큰을 분리하는 데 사용한다는 점을 제외하고는 &quot;단순&quot;과 매우 유사합니다. 간단한 토크 나이 저는 ASCII 문자를 접는 경우에만 ASCII 공백과 문장 부호 문자를 토큰 구분 기호로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">&quot;unixepoch&quot;수정 자 (11)는 DDDDDDDDDD 형식의 시간 문자열 바로 뒤에 오는 경우에만 작동합니다. 이 수정자를 사용하면 DDDDDDDDDDDD가 일반적으로 줄리안 일수로 해석되지 않고 1970 년 이후의 초 수인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;유닉스 시간&lt;/a&gt; 으로 해석됩니다 . &quot;unixepoch&quot;수정자가 DDDDDDDDDD 형식의 시간 문자열을 따르지 않는 경우 1970 년 이후의 시간 (초) 또는 다른 수정자가 &quot;unixepoch&quot;수정자를 이전 DDDDDDDDDD와 분리하면 동작이 정의되지 않습니다. 3.16.0 (2017-01-02) 이전의 SQLite 버전의 경우 &quot;unixepoch&quot;수정자는 0000-01-01 00:00:00에서 5352-11-01 10:52:47 사이의 날짜에 대해서만 작동합니다. -62167219200부터 106751991167까지).</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">&quot;unlock_notify&quot;메소드</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">&quot;update_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">데이터베이스 페이지의 &quot;사용 가능한 크기&quot;는 헤더의 오프셋 20에서 1 바이트 정수로 기록 된 &quot;예약 된&quot;공간 크기보다 헤더의 오프셋 16에서 2 바이트 정수로 지정된 페이지 크기입니다. 사용 가능한 페이지 크기는 홀수 일 수 있습니다. 그러나 사용 가능한 크기는 480보다 작을 수 없습니다. 즉, 페이지 크기가 512 인 경우 예약 된 공간 크기는 32를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">바이 읽기와 세트로 &quot;사용자 버전&quot; &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version 프라그&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">&quot;verb&quot;인수는 액세스 할 통계를 결정합니다. 있습니다 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;다양한 동사&lt;/a&gt; 정의는. &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스가 성숙함에 따라 목록이 커질 것으로 예상됩니다 . 선택한 매개 변수의 현재 값은 정수 &quot;current&quot;에 기록되고 가장 높은 히스토리 값은 정수 &quot;highwater&quot;에 기록됩니다. resetflag가 true이면 통화가 반환 된 후 최고 사용 표시 점이 현재 값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">&quot;버전&quot;방법</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">&quot;wal_hook&quot;메소드</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">&quot;평일&quot;수정자는 필요한 경우, 요일 번호가 N 인 다음 날짜로 날짜를 앞으로 이동합니다. 일요일은 0, 월요일은 1 등입니다. 날짜가 원하는 요일에 이미 있으면 &quot;요일&quot;수정자가 날짜를 변경하지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nExtCode 확장 결과 코드는 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h에 정의되며&lt;/a&gt; 아래에 알파벳 순서로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">$ nPrimCode 결과 코드는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h에 정의&lt;/a&gt; 되어 있으며 알파벳 순서로 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">$ prefix 매개 변수는 NULL 일 수 있으며이 경우 접두어는 $ wholeline에서 추론됩니다. 또는 컨텍스트 정보를 사용할 수 없거나 컨텍스트 인식 완료를 원하지 않는 경우 $ wholeline 매개 변수는 NULL이거나 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">% _content 테이블에는 사용자가 사용자가 FTS 가상 테이블에 삽입 한 성인 데이터가 포함되어 있습니다. 레코드를 삽입 할 때 사용자가 &quot;docid&quot;값을 명시 적으로 제공하지 않으면 시스템에서 자동으로 값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">% _stat 및 % _docsize 테이블은 FTS 테이블이 FTS3이 아닌 FTS4 모듈을 사용하는 경우에만 작성됩니다. 또한 CREATE VIRTUAL TABLE 문의 일부로 지정된 &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo = fts3&quot;&lt;/a&gt; 지시문으로 FTS4 테이블을 작성하면 % _docsize 테이블이 생략됩니다 . 이들이 작성되면 두 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">% q 및 % Q 대체는 SQLite 개선 사항으로, 대부분의 다른 printf () 구현에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">% s 대체는 보편적이지만 % z 대체는 SQLite 향상으로 다른 printf () 구현에서는 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">% w 대체는 SQLite의 향상된 기능으로 대부분의 다른 printf () 구현에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">'%'문자는 C, Java 및 Javascript와 같은 프로그래밍 언어와 마찬가지로 모듈러스 연산자를 나타 내기 위해 요구 사항 H35300에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">'crisismerge'옵션은 전체 텍스트 인덱스를 구성하는 구성 요소 b- 트리가 병합되는 방식과 빈도를 결정한다는 점에서 'automerge'와 유사합니다. 존재하면</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">* x * 열의 * + * 연산자는 해당 용어가 인덱스를 제한하지 않도록합니다. 이렇게하면 ex2i2 인덱스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater 매개 변수는 가장 깊은 구문 분석기 스택을 기록합니다. * pCurrent 값은 정의되어 있지 않습니다. * pHighwater 값은 SQLite가 &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; 로 컴파일 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">* pHighwater 매개 변수는 가장 깊은 구문 분석기 스택을 기록합니다. * pCurrent 값은 정의되어 있지 않습니다. * pHighwater 값은 SQLite가 &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; 로 컴파일 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">데이터베이스 읽기 테스트의 --blob-api 옵션을 사용하면 kvtest 는 SQLite 의 &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 기능 을 사용하여 순수한 SQL 문을 실행하지 않고 Blob의 컨텐츠를로드합니다. 이를 통해 SQLite가 읽기 테스트에서 약간 더 빠르게 실행될 수 있습니다. SQL 문을 실행하는 SQLite의 성능을 비교하기 위해이 옵션을 생략 할 수 있습니다. 이 경우, &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()를&lt;/a&gt; 사용할 때만 큼 SQLite는 여전히 직접 읽기보다 성능이 뛰어납니다 . 개별 디스크 파일에서 읽는 테스트의 경우 --blob-api 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">새 데이터베이스를 여는 데 관련된 --deserialize 옵션을 사용하면 데이터베이스 파일을 메모리로 읽고 &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; API를 사용하여 액세스 할 수 있습니다 . 이렇게하면 디스크의 파일을 수정하지 않고도 데이터베이스에서 테스트를 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">--primarykey 플래그는 스키마 선언 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 가 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 가있는 테이블에서도 항상 페어링에 사용 되도록 페어링 알고리즘을 약간 변경합니다 . 이것은 차이를 찾기 위해 종종 더 나은 선택이지만, 하나 이상의 PRIMARY KEY 열이 NULL로 설정된 행의 경우에는 차이를 놓칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">--update 및 --insert 명령은 시작하기 전에 현재 아카이브를 삭제하지 않는다는 점을 제외하고 --create 명령과 동일하게 작동합니다. 새 버전의 파일은 기존 파일을 동일한 이름으로 자동으로 바꾸지 만 아카이브의 초기 내용 (있는 경우)은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">동적로드, &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스 및 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 를 지원하려면 -ldl 라이브러리가 필요 합니다 . 이러한 기능이 필요하지 않은 경우 &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; 컴파일 타임 옵션을 사용하여 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">.selftest 명령은 selftest.tno 순서로 selftest 테이블의 행을 읽습니다. 각 'memo'행에 대해 'cmd'의 텍스트를 출력에 씁니다. 각 '실행'행에 대해 'cmd'텍스트를 SQL로 실행하고 결과를 'ans'의 값과 비교하고 결과가 다른 경우 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">100 바이트 데이터베이스 파일 헤더 (1 페이지에만 있음)</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">100 바이트 데이터베이스 파일 헤더는 항상 테이블 b- 트리 페이지 인 1 페이지에만 있습니다. 데이터베이스 파일의 다른 모든 b- 트리 페이지는이 100 바이트 헤더를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">위의 12 단계 &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;일반 ALTER TABLE 프로시 저는&lt;/a&gt; 스키마 변경으로 인해 테이블에 저장된 정보가 변경 되더라도 작동합니다. 따라서 위의 전체 12 단계 절차는 열 삭제, 열 순서 변경, UNIQUE 제약 조건 또는 기본 키 추가 또는 제거, CHECK 또는 FOREIGN KEY 또는 NOT NULL 제약 조건 추가 또는 열의 데이터 유형 변경에 적합합니다. 예. 그러나 디스크 내용에 영향을 미치지 않는 일부 변경 사항에는 더 간단하고 빠른 절차를 선택적으로 사용할 수 있습니다. 다음의 간단한 절차는 CHECK 또는 FOREIGN KEY 또는 NOT NULL 제약 조건을 제거하거나 열의 기본값을 추가, 제거 또는 변경하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec () 콜백 함수의 두 번째 인수는 결과의 열 수입니다. sqlite3_exec () 콜백에 제 3 인자에서 얻어진 것처럼 스트링 포인터 배열이다 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , 각 열에 하나. 결과 행의 요소가 NULL 인 경우 sqlite3_exec () 콜백에 해당하는 문자열 포인터는 NULL 포인터입니다. sqlite3_exec () 콜백에 대한 네 번째 인수는 문자열에 대한 포인터 배열이며, 각 항목은 &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 에서 얻은 해당 결과 열의 이름을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_exec () 콜백 함수의 두 번째 인수는 결과의 열 수입니다. sqlite3_exec () 콜백에 제 3 인자에서 얻어진 것처럼 스트링 포인터 배열이다 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , 각 열에 하나. 결과 행의 요소가 NULL 인 경우 sqlite3_exec () 콜백에 해당하는 문자열 포인터는 NULL 포인터입니다. sqlite3_exec () 콜백에 대한 네 번째 인수는 문자열에 대한 포인터 배열이며, 각 항목은 &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 에서 얻은 해당 결과 열의 이름을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">31 개의 결과 코드는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;sqlite3.h&lt;/a&gt; 에 정의되어 있으며 아래에 알파벳 순서로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">32 비트 정수 값 P1이 레지스터 P2에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">WAL- 색인 헤더의 오프셋 128에서 부호없는 32 비트 정수를 &quot;nBackfill&quot;이라고합니다. 이 필드는 WAL 파일에서 기본 데이터베이스로 다시 복사 된 프레임 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">오프셋 16에서 32 비트 부호없는 정수 (및 오프셋 64에서 반복됨)는 WAL의 유효한 프레임 수입니다. WAL 프레임은 1부터 시작하여 번호가 매겨 지므로 mxFrame은 WAL에서 마지막으로 유효한 커밋 프레임의 인덱스이기도합니다. 커밋 프레임은 프레임 헤더의 바이트 4에서 7까지 0이 아닌 &quot;데이터베이스 크기&quot;값이 0 인 프레임이며 트랜잭션의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">35 % 수치는 작성자가 쉽게 확보 할 수있는 모든 컴퓨터에서 테스트를 실행 한 결과입니다. 이 기사의 일부 검토 자들은 SQLite가 시스템의 직접 I / O보다 대기 시간이 더 높다고보고합니다. 우리는 아직 그 차이를 이해하지 못합니다. 또한 콜드 파일 시스템 캐시를 사용하여 실험을 수행 할 때 직접 I / O뿐만 아니라 SQLite가 수행하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">내장 SUBSTR () 함수의 세 번째 매개 변수는 이제 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">헤더에 대한 오프셋 28의 4 바이트 빅 엔디안 정수는 데이터베이스 파일의 크기를 페이지에 저장합니다. 이 헤더 내 데이터 크기 크기가 유효하지 않으면 (다음 단락 참조) 데이터베이스 크기는 데이터베이스 파일의 실제 크기를 확인하여 계산됩니다. 이전 버전의 SQLite는 헤더 내 데이터베이스 크기를 무시하고 실제 파일 크기를 독점적으로 사용했습니다. 최신 버전의 SQLite는 사용 가능한 경우 헤더 내 데이터베이스 크기를 사용하지만 헤더 내 데이터베이스 크기가 유효하지 않으면 실제 파일 크기로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">오프셋 56의 4 바이트 빅 엔디안 정수는 데이터베이스에 저장된 모든 텍스트 문자열에 사용되는 인코딩을 결정합니다. 값 1은 UTF-8을 의미합니다. 값 2는 UTF-16le을 의미합니다. 3의 값은 UTF-16be를 의미합니다. 다른 값은 허용되지 않습니다. sqlite3.h 헤더 파일은 텍스트 인코딩을위한 숫자 코드 대신 사용하기 위해 C 프리 프로세서 매크로 SQLITE_UTF8을 1로, SQLITE_UTF16LE를 2로, SQLITE_UTF16BE를 3으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">오프셋 60의 4 바이트 빅 엔디안 정수는 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma에&lt;/a&gt; 의해 설정되고 쿼리되는 사용자 버전입니다 . SQLite에서는 사용자 버전을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">오프셋 68의 4 바이트 빅 엔디안 정수는 &quot;응용 프로그램 ID&quot;이며 &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; 명령으로 데이터베이스를 특정 응용 프로그램에 속하거나 특정 응용 프로그램과 관련된 것으로 식별하기 위해 설정할 수 있습니다 . 응용 프로그램 ID는 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되는 데이터베이스 파일을위한 것입니다 . 응용 프로그램 ID는 &quot;SQLite3 Database&quot;를보고하기보다는 &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1)&lt;/a&gt; 과 같은 유틸리티 에서 특정 파일 형식을 결정하는 데 사용할 수 있습니다 . SQLite 소스 저장소 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; 파일 을 참조하여 지정된 애플리케이션 ID 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">오프셋 96의 4 바이트 빅 엔디안 정수는 가장 최근에 데이터베이스 파일을 수정 한 SQLite 라이브러리 의 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; 값을 저장 합니다. 오프셋 92의 4 바이트 빅 엔디안 정수 는 버전 번호가 저장된 &lt;a href=&quot;fileformat2#chngctr&quot;&gt;변경 카운터&lt;/a&gt; 의 값입니다 . 오프셋 92의 정수는 버전 번호가 유효한 트랜잭션을 나타내며 &quot;버전 유효 번호&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">오프셋 48의 4 바이트 빅 엔디안 부호있는 정수는 데이터베이스 파일의 페이지에서 제안 된 캐시 크기입니다. 가치는 제안 일 뿐이며 SQLite는이를 존중할 의무가 없습니다. 정수의 절대 값이 제안 된 크기로 사용됩니다. 제안 된 캐시 크기는 &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma를&lt;/a&gt; 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">61 개의 확장 결과 코드는 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;sqlite3.h에 정의되어&lt;/a&gt; 있으며 아래에 알파벳순으로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8 또는 12 바이트 b- 트리 페이지 헤더</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE는&lt;/a&gt; TEMP 데이터베이스 및 일지, 과도 데이터베이스 및 subjournals 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 항상 함께 사용됩니다 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE의&lt;/a&gt; 모두 POSIX 개방 () API의 O_EXCL과 O_CREAT 플래그에 직접적으로 유사하다 플래그입니다. SQLITE_OPEN_CREATE와 함께 사용될 때 SQLITE_OPEN_EXCLUSIVE 플래그는 파일이 항상 작성되어야하며 파일이 이미 존재하는 경우 오류임을 표시하는 데 사용됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h 헤더 의 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C 전 처리기 매크로는 &quot;XYZ&quot;형식의 SQLite 버전 인 문자열 리터럴로 평가합니다. 여기서 X는 주 버전 번호 (항상 SQLite3의 경우 3)이고 Y는 부 버전 번호이고 Z는 릴리스 번호 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C 전처리 값을 갖는 정수 매크로 리졸 (X + Y * 1000000 * 1000 + Z) X, Y 및 Z가 사용되는 동일한 숫자 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . 지정된 SQLite 릴리스에 대한 SQLITE_VERSION_NUMBER도 파생 된 릴리스보다 큽니다. Y는 일정하게 유지되고 Z는 증가하거나 그렇지 않으면 Y는 증가하고 Z는 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="translated">&lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz의&lt;/b&gt;&lt;/a&gt; 엔진은 독점 경찰 테스터입니다. &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLite의&lt;/a&gt; 다른 퍼 저는 SQL 입력 또는 데이터베이스 파일을 변경합니다. Dbsqlfuzz는 SQL과 데이터베이스 파일을 동시에 변경하므로 새로운 오류 상태에 도달 할 수 있습니다. Dbsqlfuzz는 사용자 지정 뮤 테이터와 함께 LLVM 의 &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; 프레임 워크를 사용하여 빌드됩니다 . 236 개의 시드 파일에서 시작하여 dbsqlfuzz 퍼 저는 수천만 개의 돌연변이를 조사하여 각각의 새로운 퍼징 세션의 기초를 형성하는 63493 개의 개별 테스트 케이스를 생성했습니다. Dbsqlfuzz는 SQLite가 악의적 인 SQL 또는 데이터베이스 입력을 통한 공격에 대해 강력 함을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 호출에서 포인터 D &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt (D, S)는&lt;/a&gt; 개방형 데이터베이스 연결과 NULL 포인터하지 특히 필요 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 오브젝트 자체는 부분적으로 쓰레드이다. 여러 스레드가 sqlite3_backup_step ()을 여러 번 동시에 호출 할 수 있습니다. 그러나 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () API는 엄격하게 말하면 스레드 안전하지 않습니다. 다른 스레드가 sqlite3_backup_step ()을 호출하는 것과 동시에 호출되면 유효하지 않은 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 인터페이스와는 내장 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob의&lt;/a&gt; SQL 함수 증분 762 인터페이스를 통해 판독 또는 기록 할 수있는 충전 제로 블롭들을 생성하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스에 호출하여 이전 등록 된 초기화 루틴 X 등록 취소 &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension (X)를&lt;/a&gt; . &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 으로 돌아 간다 (1) 초기화 루틴의 X 성공적으로 등록했다 경우 X 초기화 루틴의 목록에없는했다 경우 0 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) 인터페이스 sqlite3_pcache_methods2 구조체의 인스턴스를 전달하여 다른 페이지의 캐시 구현을 등록 할 수있다. 많은 응용 프로그램에서 SQLite에 의해 할당 된 대부분의 힙 메모리는 페이지 캐시에 사용됩니다. 이 API를 사용하여 사용자 정의 페이지 캐시를 구현하면 애플리케이션이 SQLite가 소비하는 메모리 양, 메모리가 할당 및 해제되는 방식 및 캐시 된 데이터베이스 파일의 부분을 정확히 결정하는 데 사용되는 정책을보다 잘 제어 할 수 있습니다. 얼마나 오래.</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를위한 방법 xFileControl 직접 호출한다 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 두 번째 인수에 의해 식별되는 특정 데이터베이스와 연관된 객체. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 데이터베이스의 경우 &quot;temp&quot;이거나 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 추가 된 데이터베이스의 AS 키워드 뒤에 나타나는 이름입니다 . &quot;main&quot;대신 NULL 포인터를 사용하여 기본 데이터베이스 파일을 참조 할 수 있습니다. 이 루틴에 대한 세 번째 및 네 번째 매개 변수는 xFileControl 메소드의 두 번째 및 세 번째 매개 변수로 직접 전달됩니다. xFileControl 메소드의 리턴 값은이 루틴의 리턴 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하는 T 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 변수는 T 매개 변수가 X 번째 루프가 실행 된 총 횟수로 설정됩니다에 의해 지적했다.</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하기 V 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64의&lt;/a&gt; V 자 파라미터가 가리키는 변수는 X 번째 루프가 실행 된 총 횟수로 설정한다.</target>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스에 메시지를 기록 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에 의해 설립 &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; 에 옵션 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; . 로깅이 사용 가능한 경우 zFormat 문자열 및 후속 인수는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 와 함께 사용되어 최종 출력 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 뛰어난 (malloc으로 할당하지만 해제) 메모리의 바이트 수. &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 루틴 반환의 최대 값 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 하이 워터 마크 보낸 사람을 마지막으로 재설정 한. 반환하는 값 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()는&lt;/a&gt; 모든 오버 헤드의 구현으로 SQLite는 추가 포함 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 하지만 오버하는 모든 기본 시스템 라이브러리 루틴 추가하지 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; 인터페이스는이 정수 상수들 중 하나 인 하나의 인수를 취하는.</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; 인터페이스, 삽입, 업데이트 또는 삭제되는 행의 열 수를 반환한다.</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; preupdate 콜백이 직접 삽입, 업데이트 또는 삭제 작업의 결과로 호출 된 경우 인터페이스를 반환 0; 또는 최상위 트리거에 의해 호출 된 삽입, 업데이트 또는 삭제의 경우 1; 또는 최상위 트리거에 의해 호출 된 트리거로 인한 변경에 대해서는 2; 기타 등등.</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 전에 각 호출되는 콜백 함수를 등록 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 데이터베이스 테이블에 동작. 단일 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 한 번에 최대 하나의 사전 업데이트 후크를 등록 할 수 있습니다 . &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()에 대한&lt;/a&gt; 각 호출 은 이전 설정보다 우선합니다. 사전 갱신 후크는 두 번째 매개 변수로 널 포인터를 사용하여 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 을 호출하여 사용 불가능합니다 . &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 의 세 번째 매개 변수는 콜백에 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트 된 후 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_INSERT 및 SQLITE_UPDATE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_DELETE 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new ()는&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; 인터페이스는 preupdate 이벤트에 관한 추가 정보를 제공한다. 이러한 루틴은 사전 업데이트 콜백 내에서만 호출 할 수 있습니다. 사전 갱신 콜백 외부에서 또는 사전 갱신 콜백에 제공된 것과 다른 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터를 사용하여 이러한 루틴을 호출하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트되기 전에 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_UPDATE 및 SQLITE_DELETE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_INSERT 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 임의의 값이 변경되지 않는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 온 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 재설정 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문은&lt;/a&gt; 그 프로그램의 시작 부분에 다시 S.</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;권한 부여 콜백 기능&lt;/a&gt; 중 하나를 반환해야 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 작업이 허용되는지 여부를 SQLite는 신호하기 위해 또는이 두 상수 중 하나를. 추가 정보 는 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;권한 부 여자 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스는 특정 SQL 문 작업 권한을 부여하기 위해 호출되는 콜백 함수를 등록합니다. 콜백에 대한 두 번째 매개 변수는 권한이 부여되는 조치를 지정하는 정수 코드입니다. 이것은 권한 부 여자 콜백이 전달 될 수있는 정수 조치 코드입니다.</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 에 성공적으로 호출에서 반환 된 개체 &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;() sqlite3_snapshot_get를&lt;/a&gt; 사용하여 해제해야 &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free을 ()&lt;/a&gt; 메모리 누수를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; 계면을 파괴&lt;a href=&quot;#sqlite3_snapshot&quot;&gt; sqlite3_snapshot&lt;/a&gt; P.이 응용 프로그램은 결국 모든 해제해야합니다 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 메모리 누수를 방지하기 위해이 루틴을 사용하여 객체를.</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; 인터페이스 시도는 새로운 만드는 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 스키마의 현재 상태가 데이터베이스 연결 D.에 성공에 S 기록 것을 객체를의&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt; sqlite3_snapshot_get는 (D, S는 P)&lt;/a&gt; 인터페이스가 새로 생성에 대한 포인터를 기록 &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 오브젝트를 * P로 가져오고 SQLITE_OK를 리턴합니다. 이 함수가 호출 될 때 스키마 S에 읽기 트랜잭션이 아직 열려 있지 않으면 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 인터페이스 중 하나는 새로운 읽기 트랜잭션을 시작 또는 스키마 S에 대한 기존의 것을 업그레이드 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 읽기 트랜잭션이 역사를 의미하도록 D &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;스냅 샷&lt;/a&gt; 이 아니라 데이터베이스에 대한 가장 최근의 변화보다, P. &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스 반환 성공 또는 적절한에 SQLITE_OK &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; 방법은 N의 단부에 문자열 S 바이트로부터 정확하게 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; X. N은 음이 아닌 있어야 개체. S는 0이 아닌 0 바이트 이상의 콘텐츠를 포함해야합니다. 0으로 끝나는 문자열을 전체적으로 추가하려면 대신 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall는 (X, S)의&lt;/a&gt; 방법은 결국 제로로 끝나는 문자열 S의 전체 콘텐츠를 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar은 (X는 N, C)&lt;/a&gt; 방법의 마지막에 1 바이트 문자 C의 N 카피를 추가 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 공백 압입 부가, 예를 들면이 방법은 사용할 수있는 객체 X..</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; 과 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; 인터페이스가 사용 &lt;a href=&quot;printf&quot;&gt;내장의 printf&lt;/a&gt; SQLite는 기능성의 단부 상 형식의 텍스트를 추가 할&lt;a href=&quot;#sqlite3_str&quot;&gt; sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; 에있어서 내부 공사중 문자열 리셋 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str을&lt;/a&gt; 길이는 0 바이트로 오브젝트 X의 뒷면.</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 방법 공사중 동적 문자열 바이트 현재 길이를 반환 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 길이에 의해 리턴 된 객체 X.&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt; sqlite3_str_length (X)가&lt;/a&gt; 제로 종료 바이트를 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; 메소드에 의해 리턴 된 값 X. 공사중 동적 캐릭터의 현재 콘텐츠에 대한 포인터를 리턴 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; sqlite3_str 오브젝트 X에 의해 관리되고, 동일한에 후속 법에 의해 해제되거나 변경 될 수도 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체. 응용 프로그램은 동일한 오브젝트에서 후속 메소드 호출 후 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; 리턴 한 포인터를 사용해서는 안됩니다 . 응용 프로그램은 0에서 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 범위를 벗어난 바이트에 쓰지 않고 후속 sqlite3_str 메소드 호출 후 바이트를 읽거나 쓰지 않는 한 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)에&lt;/a&gt; 의해 반환되는 문자열의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 인터페이스 sqlite3_str 오브젝트 X 되돌아로부터 획득 된 버퍼 메모리에 대한 포인터 파괴 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 구축 된 스트링을 포함한다. 호출 애플리케이션은 메모리 누수를 피하기 위해 리턴 된 값을 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 로 전달해야합니다. &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 오류가 캐릭터 라인의 건설 중 발생 된 경우 인터페이스는 NULL 포인터를 반환 할 수 있습니다. &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 의 문자열 경우 인터페이스도 NULL 포인터를 반환합니다 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 X가 0 바이트 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스에 할당하고 새로운 초기화 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; 개체. 메모리 누수를 피하려면 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()에&lt;/a&gt; 의해 반환 된 객체 는 다음에 대한 호출로 해제되어야합니다.&lt;a href=&quot;#sqlite3_str_finish&quot;&gt; sqlite3_str_finish (X) sqlite3_str_new (&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스는 항상 유효한에 대한 포인터를 반환 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str의&lt;/a&gt; 메모리 부족 오류의 경우에 반환 된 객체가 새 텍스트를 거부 자동으로하는 특별한 싱글이 될 수도 있지만, 객체를 항상에서 SQLITE_NOMEM을 반환 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;) (sqlite3_str_errcode &lt;/a&gt;&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length ()에&lt;/a&gt; 대해 항상 0을 반환하고 &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에서 항상 NULL을 반환합니다 . &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 의해 리턴 된 값을 sqlite3_str 매개 변수로 다른 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 메소드 에 사용하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 인터페이스를 반환하는 경우에만 문자열 X가 일치하면 제로 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 패턴 P.의 정의 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;#sqlite3_strglob&quot;&gt;(P, X) sqlite3_strglob를&lt;/a&gt; 에서 &quot;X GLOB P&quot;연산자와 동일 SQLite는 SQL 언어를 이해합니다. 그만큼&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 함수는 대소 문자를 구분한다.</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및&lt;a href=&quot;#sqlite3_stricmp&quot;&gt; sqlite3_strnicmp ()&lt;/a&gt; API는 식별자를 비교할 때 SQLite는 내부에서 사용하는 &quot;경우 독립&quot;의 정의와 동일하여, 애플리케이션 및 확장이 경우 독립적 방식으로 UTF-8 스트링을 포함하는 두 버퍼의 내용과 비교하도록 허용한다.</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; ASCII 문자 만이 경우 접힌 비록 기능은 유니 코드 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 인터페이스에 리턴하고 문자열 X가 일치하는 경우에만 0 일 경우 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 제어 문자 E.의 정의 패턴 P &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike를 (P는, X, E)이&lt;/a&gt; 와 동일 SQLite에서 이해하는 SQL 언어의 &quot;X LIKE P ESCAPE E&quot;연산자 ESCAPE 절이없는 &quot;X LIKE P&quot;의 경우 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 의 E 매개 변수 를 0으로 설정하십시오. LIKE 연산자와 마찬가지로 &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 함수는 대소 문자를 구분하지 않습니다. 소문자 ASCII 문자는 서로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; 인터페이스는 다른 데이터베이스 연결에 의해 변경이 무시되고 데이터베이스 연결 D.에 대해 SQL 문 실행으로 인해 변경된 것을 행의 수를보고합니다. 다른 데이터베이스 연결에서 데이터베이스 파일에 대해 변화를 감지하기 위해 사용 &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령 또는 &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION을&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt; 파일 제어를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint (D, N)의&lt;/a&gt; 래퍼입니다 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 에 데이터베이스를 야기 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 자동으로 D &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 가있는 경우에 트랜잭션을 커밋 후 N 이상의 프레임을&lt;a href=&quot;wal&quot;&gt; 미리 쓰기 로그&lt;/a&gt; 파일. nFrame 매개 변수로 0 또는 음수 값을 전달하면 자동 검사 점이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 함수 WAL 모드에서 데이터베이스로 커밋 될 때마다 데이터를 호출 콜백을 등록하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결의 busy-handler를 호출하려면 배열의 두 번째 (void *)를 유일한 인수로 사용하여이 함수를 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값으로 구성된 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결 처리기 핸들러를 호출하려면이 함수는 배열의 두 번째 (void *)를 유일한 인수로 사용하여 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 포기해야합니다.</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE의&lt;/a&gt; 연산 코드는 VFS가 확장하고 사용자가 지정한 크기의 덩어리에서 데이터베이스 파일을 자릅니다 것을 요구하는 경우에 사용됩니다. &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 네 번째 인수 는 지명 된 데이터베이스에 사용할 새 청크 크기를 포함하는 정수 (유형 int)를 가리켜 야합니다. 큰 청크 (예 : 한 번에 1MB)로 데이터베이스 파일 공간을 할당하면 파일 시스템 조각화가 줄어들고 일부 시스템의 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE의&lt;/a&gt; * 표시 -shm 파일 페이지가 체크 포인트 된 사실을 기록하기 위해 업데이트되기 전에 연산 코드는 클라이언트가 데이터베이스 파일에 월마트 파일에서 완성 된 복사 페이지가 이후 월마트 모드에서 체크 포인트 내에서 호출되지만.</target>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START의&lt;/a&gt; 클라이언트가 데이터베이스 파일에 월마트 파일에서 페이지를 복사하기 시작하기 전에 옵 코드는 월마트 모드에서 체크 포인트 내에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE이&lt;/a&gt; 원자 적으로 수행 할 수 있습니다. 이 파일 제어는 쓰기가 모두 성공적으로 수행되고 지속적 스토리지에 커미트 된 경우에만 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 성공 여부에 관계없이이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 해제하여 모든 후속 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 호출 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되어 VFS에 전송 트랜잭션이 즉시 커밋 된 후에 만 데이터베이스 잠금이 해제되기 전에된다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 이 opcode와 함께 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 호출해서는 안되며 이를 요구하는 특수 VFS의 작동을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 부호없는 32 비트 정수에 대한 포인터입니다. 호출기에 대한 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결에서 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결로 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한&lt;a href=&quot;#sqlite3_total_changes&quot;&gt; sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략는 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하는 변경 사항을 감지하고 연결된 특정 데이터베이스와 연관된 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 32 비트 부호없는 정수에 대한 포인터입니다. 호출기의 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결의 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결에 의해 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략가 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하고 특정 연결된 데이터베이스와 관련된 변경 사항을 감지하는 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 코드는 포인터 얻기 위해 사용된다 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 특정 데이터베이스 연결과 관련된 개체. &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; 파일 제어 정수에 대한 포인터로 인수를 해석하고는, 이름이 이동하거나 처음 열린 이후 삭제 된 여부 파일에 따라 그 정수에 부울을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER의&lt;/a&gt; 연산 코드는 포인터 가져 오는 데 사용됩니다 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 저널 파일합니다 (하나와 관련된 객체 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 또는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 특정 데이터베이스 연결을). &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 잠금의 현재 상태 ( &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 중 하나 )를 pArg 인수가 가리키는 정수로 쓰도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST 컴파일 타임 옵션이 사용 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 연산 코드는 M은 하나의 부호없는 정수 파라미터이고, 실패 전에 M 밀리 초까지 기다릴 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려는 시도를 야기한다.</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 오피은 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려고 시도 할 때 실패 전에 M 밀리 세컨드까지의 블록에 대해 VFS를 구성하는데 사용된다. 매개 변수는 M이 설정 될 값을 포함하는 32 비트 부호있는 정수에 대한 포인터입니다. 반환하기 전에 부호있는 32 비트 정수를 이전 값 M으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE의&lt;/a&gt; 파일 제어에 사용되는 최대 바이트 수 쿼리에 사용되거나 설정되어 I / O를 메모리 매핑. 인수는 파일 대 메모리 맵의 권고 최대 바이트 수인 sqlite3_int64 유형의 값에 대한 포인터입니다. 이전 값으로 포인터를 덮어 씁니다. 원래 가리키는 값이 음수이면 한계가 변경되지 않으므로 포인터를 음수로 전달하여 현재 한계를 쿼리 할 수 ​​있습니다. 이 파일 제어는 &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; 구현에 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE의&lt;/a&gt; 연산 코드는 그 어떤 이유로 롤백하지 않는 것을 나타 내기 위해 쓰기 트랜잭션을 연 후 SQLite는에 의해 호출, 전체 데이터베이스 파일은 현재 트랜잭션을 덮어 씁니다. VACUUM 작업에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; op 코드 세트에 사용되거나 지속적인 쿼리입니다 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 설정을. 기본적으로 트랜잭션 제어에 사용되는 보조 미리 쓰기 로그 ( &lt;a href=&quot;wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; ) 및 공유 메모리 파일은 데이터베이스에 대한 최신 연결이 닫힐 때 자동으로 삭제됩니다. 영구 WAL 모드를 설정하면 파일을 닫은 후에도 해당 파일이 유지됩니다. 데이터베이스를 읽을 수 있으려면 WAL 및 공유 메모리 파일이 있어야하므로 데이터베이스 파일을 포함하는 디렉토리에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스 파일을 읽으려는 경우 파일을 유지하는 것이 유용합니다. &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수이 opcode는 정수에 대한 포인터 여야합니다. 이 정수는 영속 WAL 모드를 비활성화하려면 0이고 영속 WAL 모드를 활성화하려면 1입니다. 정수가 -1이면 현재 WAL 지속성 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE의&lt;/a&gt; op 코드 세트에 사용되거나 영구 &quot;powersafe 덮어 쓰기&quot;또는 &quot;PSOW&quot;설정을 조회한다. PSOW 설정 에 따라 xDeviceCharacteristics 메서드 의 &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; 비트가 결정 됩니다. 이 opcode에 대한 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수 는 정수에 대한 포인터 여야합니다. 이 정수는 0으로 제로 손상 모드를 비활성화하거나 1로 제로 손상 모드를 활성화합니다. 정수가 -1이면 현재 제로 손상 모드 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU의&lt;/a&gt; 연산 코드 만 RBU 확장에 사용되는 특수 VFS에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE가&lt;/a&gt; 롤백 할 수 있습니다. 이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 꺼내어 이후의 모든 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 호출 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT의&lt;/a&gt; 연산 코드는 VFS 층을 데이터베이스 파일이 현재 트랜잭션 동안으로 성장하는 방법 대규모의 힌트를 제공하는 SQLite는 데 사용됩니다. 이 힌트는 정확하지는 않지만 종종 가깝습니다. 기본 VFS는 데이터베이스 파일에 대한 쓰기 속도를 높이기 위해이 힌트를 기반으로 데이터베이스 파일 공간을 사전 할당하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT의&lt;/a&gt; 연산 코드가 구현 그 메모리 VFS가 사용된다 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 이 상부 메모리 데이터베이스의 크기에 바인딩 설정한다. 인수는 &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64에&lt;/a&gt; 대한 포인터 입니다. 가리키는 정수가 음수이면 전류 제한으로 채워집니다. 그렇지 않으면 한계는 지정된 정수 값과 현재 데이터베이스 크기보다 크게 설정됩니다. 지정된 정수가 새로운 한계로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성하여 xSync 메소드가 호출되지 않은 경우 xSync 메소드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 마스터 저널 파일 이름을 포함하는 널 종료 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;#sqlite3_file_control&quot;&gt; sqlite3_file_control ()을&lt;/a&gt;이 opcode를 호출해서는 안되며 이를 요구하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성했기 때문에 xSync 메서드가 호출되지 않은 경우 xSync 메서드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 수퍼 저널 파일 이름을 포함하는 널로 끝나는 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 조용히 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출해서는 안됩니다. 이 opcode를 사용하면이를 필요로하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE의&lt;/a&gt; 파일 제어는 SQLite는 스택의 상위 계층이 무엇을하고 있는지에 대한 VFS에 자문 정보를 제공합니다. 이 파일 제어는 일부 VFS 활동 추적 &lt;a href=&quot;vfs#shim&quot;&gt;shim에서&lt;/a&gt; 사용됩니다 . 인수는 0으로 끝나는 문자열입니다. &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; 컴파일 타임 옵션이 활성화 된 경우 SQLite 스택의 상위 계층에서이 파일 컨트롤의 인스턴스를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME의&lt;/a&gt; 오피 모든 이름 얻기 위해 사용될 수있다 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; VFS에 스택한다. 이름은 모든 VFS 심의 이름이며 최종 하위 레벨 VFS는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록되고 결과는 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수가 가리키는 char * 변수에 저장 됩니다. 호출자가 완료되면 메모리를 확보해야합니다. 모든 파일 제어 작업과 마찬가지로 실제로이 작업이 수행 될 것이라는 보장은 없습니다. 이 파일 제어가 구현되지 않은 경우 호출자는 char * 변수를 NULL 포인터로 초기화해야합니다. 이 파일 제어는 진단 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 연산 코드 최상위에 대한 포인터 발견 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 현재 사용합니다. sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X)의 인수 X는 &quot; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; 유형이어야합니다 . 이 opcode는 * X를 최상위 VFS의 포인터로 설정합니다. 스택에 여러 VFS 심이있는 경우이 opcode는 최상위 심만 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK는&lt;/a&gt; 로크가 바로 사용할 수없는 경우가 다음 WAL 로크에 차단하는 것이 유리할 수 있다는 VFS 계층 신호이다. WAL 하위 시스템은 우선 순위 반전 문제를 해결하기 위해 드문 상황에서이 신호를 발행합니다. 응용 프로그램은 이 파일 제어를 사용 &lt;em&gt;하지 않아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY의&lt;/a&gt; 연산 코드는 특정 디스크에 대한 자동 재시도 횟수와 간격을 구성하는 데 사용되는 윈도우에 대한 I / O 작업 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;안티 바이러스 프로그램이있을 때 견고성을 제공합니다. 기본적으로, Windows VFS는 파일 다시 읽기, 파일 쓰기 및 파일 삭제 조작을 최대 10 번까지 다시 시도하며, 첫 번째 재시도 전에 25 밀리 초의 지연이 발생하며 이후의 재 시도마다 25 밀리 초씩 지연됩니다. 이 opcode를 사용하면이 두 값 (재시도 10 회 및 25 밀리 초 지연)을 조정할 수 있습니다. 동일한 프로세스 내의 모든 데이터베이스 연결에 대한 값이 변경됩니다. 인수는 첫 번째 정수는 새로운 재시도 횟수이고 두 번째 정수는 지연되는 두 정수 배열에 대한 포인터입니다. 정수가 음수이면 설정이 변경되지 않고 대신 해당 설정의 이전 값이 배열 항목에 기록되어 현재 재시도 설정을 조사 할 수 있습니다.zDbName 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE의&lt;/a&gt; 연산 코드는 파일 핸들과 관련된 기본 기본 파일 핸들을 얻을 수 있습니다. 이 파일 컨트롤은 인수를 기본 파일 핸들에 대한 포인터로 해석하여 결과 값을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 파일 핸들을 pArg 인수가 가리키는 핸들과 교체하도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST가 정의 된 경우에만 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS의&lt;/a&gt; 오피은 zipvfs에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 시간 옵션의 길이를 제한하기 위해 사용될 수있는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;결합 된 파라미터&lt;/a&gt; sqlite3_trace의 출력 확장 ().</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT의&lt;/a&gt; 컴파일시 옵션은 바인딩 매개 변수 확장의 크기를 제한합니다. &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE의&lt;/a&gt; 컴파일시 옵션 원인 sqlite3_expanded_sql ()는 항상 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보관되어 있다고 가정 하고 pragma는 &lt;a href=&quot;free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = OFF의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보유되어 있다고 가정 하며 pragma는 &lt;a href=&quot;free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 만들거나 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다. &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma에서&lt;/a&gt; 요청한 경우 제외SQLite는 sqlite3_temp_directory가 가리키는 메모리를 해제하지 않습니다. 응용 프로그램이 해당 메모리를 비우기를 원하면 모든 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트가 소멸 된 후에 만주의를 기울여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그는&lt;/a&gt; SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA의 wal_checkpoint의&lt;/a&gt; 명령은 SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA의 writable_schema은 ON =&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex 번째 항목이됩니다. aConstraintUsage []. omit가 true 인 경우 제한 조건은 가상 테이블에서 완전히 처리 된 것으로 간주되며 SQLite에서 다시 점검하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex-th 항목이됩니다. aConstraintUsage []. omit이 참이면 제약 조건은 가상 테이블에서 완전히 처리되는 것으로 간주되며 바이트 코드에서 다시 검사하지 않을 수 있습니다. aConstraintUsage []. omit 플래그는 최적화 힌트입니다. 생략 플래그가 기본 설정 인 false로 남아 있으면 제약 조건은 항상 바이트 코드에서 별도로 검사됩니다. 생략 플래그가 참으로 변경되면 제약 조건이 바이트 코드에서 확인되거나 확인되지 않을 수 있습니다. 즉, 생략 플래그가 참이면 제약 조건이 바이트 코드를 사용하여 다시 검사되지 않는다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드는 이 인터페이스를 호출하여 구현 하는 가상 테이블 의 형식 (열의 이름 및 데이터 유형)을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;atomiccommit&quot;&gt;원자 업데이트 기능&lt;/a&gt; 을 통해 문서에 작은 증분 변경 사항을 안전하게 쓸 수 있습니다. 이렇게하면 전체 디스크 I / O가 줄어들고 파일 / 저장 성능이 향상되어 사용자 경험이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 기능은 MySQL과는 다르게 작동합니다. 이것은 종종 MySQL에서 SQL을 배우고 SQLite를 사용하기 시작한 사람들에게 혼란을 야기하며 두 시스템이 동일하게 작동 할 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">&lt;a href=&quot;backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 오브젝트 자체는 부분적으로 쓰레드이다. 여러 스레드가 sqlite3_backup_step ()을 여러 번 동시에 호출 할 수 있습니다. 그러나 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () API는 엄격하게 말하면 스레드 안전하지 않습니다. 다른 스레드가 sqlite3_backup_step ()을 호출하는 것과 동시에 호출되면 유효하지 않은 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; 및 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 인터페이스와는 내장 &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob의&lt;/a&gt; SQL 함수 증분 762 인터페이스를 통해 판독 또는 기록 할 수있는 충전 제로 블롭들을 생성하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; 사용되지 않는 8 년 동안 문서화 된 인터페이스는, 무 조작으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm의&lt;/a&gt; 루틴은 메모리 할당 이벤트에 대한 콜백을 등록하는 데 사용됩니다. 이 루틴은 할당 된 메모리 양이 iThreshold를 초과 할 때 발생하는 콜백을 등록하거나 지 웁니다. 한 번에 하나의 콜백 만 등록 할 수 있습니다. &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()에 대한&lt;/a&gt; 각 호출 은 이전 콜백을 덮어 씁니다. 콜백은 xCallback을 NULL 포인터로 설정하여 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup ()&lt;/a&gt; 인터페이스는 어떤 조합 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;온라인 백업 API는&lt;/a&gt; 이러한 문제를 해결하기 위해 만들어졌다. 온라인 백업 API를 사용하면 한 데이터베이스의 컨텐츠를 다른 데이터베이스로 복사하여 대상 데이터베이스의 원래 컨텐츠를 겹쳐 쓸 수 있습니다. 복사 조작은 증 분식으로 수행 될 수 있으며,이 경우 소스 데이터베이스를 실제로 읽는 동안 잠깐 동안 만 소스 데이터베이스를 잠글 필요는 없습니다. 이를 통해 온라인 데이터베이스를 백업하는 동안 다른 데이터베이스 사용자가 중단없이 계속 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 인터페이스는 않습니다 &lt;u&gt;되지&lt;/u&gt; 노조 - vtab을 위해 작동합니다. BLOB 컨텐츠는 일반 SQL 문을 사용하여 union-vtab에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ의 &lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부여 콜백이&lt;/a&gt; 더 열이 추출되지되는 쿼리에서 참조 된 모든 테이블에 빈 문자열 열 이름을 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; 런타임 옵션과 &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; 컴파일 타임 옵션은 가능 &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;쿼리 플래너 안정성 보장&lt;/a&gt; . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; 비트 수단이 기기의 모든 기록 역시 전체 기록이 발생하는 점에서 원자 것을 또는 그 어느 것도 발생하지 않는다. 다른 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; 값은 표시된 크기의 정렬 된 블록의 쓰기가 원자 적임을 나타냅니다. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; 는 새 데이터로 파일을 확장 할 때 새 데이터가 먼저 작성된 다음 파일 크기가 업데이트 됨을 의미합니다. 따라서 정전이 발생하면 파일이 무작위로 확장되었을 가능성이 없습니다. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; 비트 수단 모든 쓰기는 그들이 발행 및 기본 파일 시스템에 의해 재정렬되지 순서대로 일어난다.</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. TEMP 데이터베이스 및 저널 및 서브 저널에 대해 항상 설정됩니다. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 파일이 독점 액세스를 위해 열 수 있습니다 의미합니다. 이 플래그는 기본 데이터베이스 파일을 제외한 모든 파일에 설정됩니다. xOpen에 세 번째 인수로 전달 된 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조는 호출자가 할당합니다. xOpen은 이것을 채 웁니다. 호출자는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조에 대해 최소 szOsFile 바이트를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그를 사용하여 런타임시 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 조정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 옵션이 추가되었습니다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type ()&lt;/a&gt; 함수는 N 번째 열에있는 값의 데이터 유형을 리턴한다. 반환 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 함수는 결과 집합의 열 수를 반환합니다. sqlite3_column_count은 () 후 언제든지 호출 할 수 있습니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count는 ()&lt;/a&gt; 와 비슷하게 동작 &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 단지 다음과 같은 것을 제외하면, &lt;a href=&quot;c3ref/step&quot;&gt;() sqlite3_step&lt;/a&gt; . &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 이전 호출이 SQLITE_DONE 또는 오류 코드 를 리턴 한 경우 &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; 는 0을 리턴하는 반면 &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; 는 결과 세트의 열 수를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 SQLite는 글로벌 프로세스 전체의 구성을 변경하는 데 사용된다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 보다 먼저 인터페이스를 호출해야 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 생성됩니다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스는 같은 일을 할 수있는 프로그래머를 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config은&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI는&lt;/a&gt; , 1) 인터페이스는 시동시에 호출한다.</target>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스는 새로운 만드는 데 사용되는 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 텍스트를 정렬합니다. &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 인터페이스는 새로운 등록에 사용되는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스는 새로운 생성 &lt;a href=&quot;vfs&quot;&gt;VFSes을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스의 가족은 지금 돌아 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE을&lt;/a&gt; 대신 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 잘못된 매개 변수 조합을 통과 할 때.</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스 등 () 함수를 오버라이드함으로써의 동작 변경하는데 사용될 수있다 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 오퍼레이터. like () 함수를 재정의하는 경우 like () 함수의 두 개 및 세 개의 인수 버전을 모두 재정의하는 것이 중요 할 수 있습니다. 그렇지 않으면 ESCAPE 절의 지정 여부에 따라 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 를 구현하기 위해 다른 코드가 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 스칼라 또는 집계 중 - 인터페이스는 새로운 SQL 함수를 작성합니다. 새로운 기능 구현은 일반적으로 다음과 같은 추가 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스는 과부하에 대한 시도에서 SQLITE_MISUSE을 반환하거나 교체 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 모듈을. 이 경우 소멸자는 항상 기록 및 현재 문서에 따라 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 루틴과 연관 모듈 이름 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조 및 각각의 모듈에 특정한 개별 클라이언트 데이터. 두 create_module 메소드의 유일한 차이점은 _v2 메소드에 클라이언트 데이터 포인터의 소멸자를 지정하는 추가 매개 변수가 포함된다는 것입니다. 모듈 구조는 가상 테이블의 동작을 정의합니다. 모듈 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; (dB, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS이&lt;/a&gt; 가 연기하고 해결되지 않은 외래 키 제약하는 경우, ...) C 언어 인터페이스는 트랜잭션 동안 사용할 수있는 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; 인터페이스는 이제하지가 실행 된 단지 하나 개의 스레드, 프로세스 내의 모든 스레드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 는 컴파일 및 실행 SQLite는 버전 2 0 개 두 번째 매개 변수에 지정된 이상의 SQL 문에서와 마찬가지로 기능이 많이 작동합니다. 조회 결과는 콜백 루틴으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 인터페이스는 하나의 함수 호출과 상기 단계 네를 행하는 간이 래퍼이다. &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()에&lt;/a&gt; 전달 된 콜백 함수 는 결과 집합의 각 행을 처리하는 데 사용됩니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;) (sqlite3_get_table는&lt;/a&gt; 위의 단계의 네 가지 않는 다른 편의 래퍼입니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 에서 인터페이스 상이 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()는&lt;/a&gt; 점에서 오히려 콜백을 호출보다 힙 메모리의 쿼리의 결과를 저장한다.</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 모든 준비된 문에 인터페이스가 작동을 사용하여 만든 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3을 ()&lt;/a&gt; . 그것은 사용하는 것이 더 이상 필요 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 와 &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE를&lt;/a&gt; 사용하기 위해 &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 개체가 열려있는 파일을 나타냅니다. &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 의 xOpen 메소드 는 파일을 열 때 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트를 구성합니다 . &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file가&lt;/a&gt; 열릴 때 파일의 상태를 추적 유지합니다.</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 용 SQLite는 범용 메모리 할당 한번에 우수 할 수 있다는 뛰어난 메모리의 총량을 결합하는 상부를 설정하는데 사용될 수있다. 소프트 힙 제한에 지정된 것보다 더 많은 메모리를 할당하려고 시도하면 SQLite는 할당 요청을 계속하기 전에 먼저 캐시 메모리를 해제하려고 시도합니다. 소프트 힙 제한 메커니즘은 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 가 활성화 된 경우에만 작동 하며 SQLite 라이브러리가 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 가장 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 구조 및 모듈로 구현하는 가상 테이블의 xBestIndex 방법에서 정보를 전달하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 인터페이스는 명시 적으로 초기화 SQLite는 서브 시스템에 호출 할 수 있습니다. &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 의 사용 때문에 특정 인터페이스를 호출 할 때 인터페이스가 자동으로 호출됩니다 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()가&lt;/a&gt; 필요하지는 않지만 권장합니다.</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 인터페이스는 SQLite는에 의해 할당 된 수있는 시스템 자원 (메모리 할당, 뮤텍스, 열린 파일 핸들) 해제됩니다 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 인터페이스는 창 아래에있는 모든 뮤텍스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 루틴은 다른 스레드를 위해 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 열려있는 파일과 상호 작용하는 데 사용되는 방법을 보유하고 있습니다. 각 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 은 그것이 나타내는 파일에 적합한 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체에 대한 포인터를 포함합니다 . &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 읽기 및 쓰기 파일에서, 영구 저장소에 변경 사항을 플러시하기 위해 파일의 크기를 찾기 위해, 잠금 및 파일의 잠금을 해제하고, 가까운 파일에 파일을 절단하는 등의 일을하는 방법을 포함 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체는 읽기, 쓰기, 그렇지 않으면 파일을 다루는 방법에 대한 포인터를 포함하는 구조입니다. 이 객체는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; 함수 시도는 소스 코드 버전 관리에 체크 어떤에서 수정되었습니다 및 수정을가있는 경우, 버전 해시의 마지막 네 문자 &quot;ALT1&quot;또는 &quot;ALT2&quot;로 표시하는 경우 감지합니다. 실수 나 부주의 한 편집을 감지하는 것이 목적입니다. 위조자는이 기능을 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스로드합니다 &lt;a href=&quot;loadext&quot;&gt;확장&lt;/a&gt; 하나의 데이터베이스 연결로. 기본 동작은 데이터베이스 연결이 닫힐 때 해당 확장이 자동으로 언로드되는 것입니다. 그러나 확장 진입 점이 SQLITE_OK 대신 SQLITE_OK_LOAD_PERMANENTLY를 리턴하면 데이터베이스 연결이 닫힌 후에도 확장이 프로세스 주소 공간에로드 된 상태로 유지됩니다. 즉, 데이터베이스 연결이 닫힐 때 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xDlClose 메소드가 확장에 대해 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스는 사용되지 않습니다. &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()를&lt;/a&gt; 통해 동등한 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스의 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ) 인터페이스 및 &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; 메모리 사용량 추적이 해제 된 경우 컴파일시 옵션은 모든 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조는 가상 테이블을 구현하는 데 사용되는 모듈 객체를 정의합니다. 모듈은 비슷한 속성을 가진 여러 가상 테이블을 생성 할 수있는 클래스로 생각하십시오. 예를 들어, 디스크의 CSV (쉼표로 분리 된 값) 파일에 대한 읽기 전용 액세스를 제공하는 모듈이있을 수 있습니다. 그런 다음 하나의 모듈을 사용하여 각 가상 테이블이 다른 CSV 파일을 참조하는 여러 가상 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter은 ()&lt;/a&gt; 다른 스레드가 이미있는 경우 뮤텍스와 블록을 입력하려고합니다. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try ()&lt;/a&gt; 는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 입력하고 다른 스레드가 이미있는 경우 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴하려고 시도 합니다 . &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; 는 뮤텍스를 종료합니다. 뮤텍스는 출구 수가 입구 수와 일치 할 때까지 유지됩니다. 경우 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()이&lt;/a&gt; 스레드가 현재 유지되지 않는다는 뮤텍스에서 호출 한 다음 동작은 정의되지 않는다. 할당 취소 된 뮤텍스에 대한 루틴이 호출되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free ()&lt;/a&gt; 루틴은 비 정적 뮤텍스를 해방하기 위해서 사용합니다. 정적 뮤텍스가이 루틴으로 전달되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 인터페이스는 모든 발견 할 수있는 응용 프로그램 수 있도록 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 관련 인터페이스는 SQL 바이트 코드로 문자를 변환하는 컴파일러로 작용한다. &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt의&lt;/a&gt; 객체는 하나의 SQL 문을 구현하기 위해 사용하는 단일 바이트 코드 프로그램의 컨테이너입니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 가상 머신에 바이트 코드 프로그램을 전달하고까지 프로그램의 실행 결과의 행 리턴하는 하나 완료되거나 형태 또는 심각한 오류 안타되거나 &lt;a href=&quot;c3ref/interrupt&quot;&gt;중단&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 인터페이스는 생성 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 스키마가 변경되면 자동으로 다시 컴파일됩니다. 를 처리하는 가장 쉬운 방법 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA의&lt;/a&gt; 오류가 항상 사용하는 것입니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;) sqlite3_prepare_v2을 (&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 (에 의해 호출 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 완료 실행되지 않은 문에 대한).</target>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스는 이제 인터페이스를 호출 스레드에서뿐만 아니라 연결, 모든 스레드에서 모든 데이터베이스 연결을 통해 메모리 사용량을 줄이기 위해 시도합니다.</target>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="translated">&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; , 및 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; 인터페이스는 이제 작품은, 그 과정에서 자신을 호출하는 단지 하나의 스레드 모든 스레드를 교차. *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부여 콜백는&lt;/a&gt; 관계없이 EXPLAIN 또는 EXPLAIN 쿼리 계획의 존재 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 인터페이스는 이제하지가 실행 된 단지 하나 개의 스레드, 프로세스 내의 모든 스레드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 인터페이스는 부드러운 힙 한계에 메모리 경보를 등록하고 호출하여 작동 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 알람 콜백을. &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 모듈을 방해하므로 응용 프로그램은 sqlite3_memory_alarm () 인터페이스 를 사용해서는 안됩니다 . 이 인터페이스는 SQLite 코어가 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 으로 컴파일 될 때 애플리케이션이 자체 대체 구현을 제공 할 수 있도록 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 용 SQLite는 범용 메모리 할당 한번에 우수 할 수 있다는 뛰어난 메모리의 총량을 결합하는 상부를 설정하는데 사용될 수있다. 소프트 힙 한계에 의해 지정된 것보다 많은 메모리를 할당하려고 시도하면 SQLite는 할당 요청을 계속하기 전에 먼저 캐시 메모리를 해제하려고 시도합니다. 소프트 힙 제한 메커니즘은 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 가 사용 가능한 경우에만 작동 하며 SQLite 라이브러리가 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 가장 효과적 입니다.</target>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문의&lt;/a&gt; 객체는 다음과 같습니다 C / C ++ 인터페이스 루틴의 작은 집합에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 개체 : sqlite3를</target>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 문에 VACUUM를 실행하는 원래 사용하여 연 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI의&lt;/a&gt; 플래그.</target>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체 : sqlite3_stmt</target>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; C ++ 인터페이스를 함께와 C / &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; 동사는 SQL 문이 인덱스의 효과적인 사용을하지 않을 때 실행시에 감지 할 수 있습니다. 많은 응용 프로그램이 여기에 설명 된 INDEXED BY 구문 대신 인덱스 오용을 탐지 하기 위해 &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 를 사용하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata ()가&lt;/a&gt; 제대로 작동하도록 향상 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블과 열 이름 매개 변수가 NULL 인 경우 AA 테이블의 존재를 확인 할 수 있습니다. 인터페이스는 이제 &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; 컴파일 타임 옵션 을 요구하지 않고 기본적으로 빌드에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="translated">&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control은&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt; , ...) 인터페이스는 SQL 문 최적화를 선택 허용 런타임 비활성화 할 수 있습니다. SQLite는 최적화가 활성화되고 최적화가 비활성화 된 상태에서 항상 정확히 같은 답을 생성해야합니다. 최적화를 켜면 대답이 더 빨리 도착합니다. 따라서 프로덕션 환경에서는 항상 최적화를 켜 둡니다 (기본 설정).</target>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; &quot;-&quot;주석 마커 중첩 된 SQL 문에 대한 출력은 항상로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 라이브러리가 전처리 심볼로 컴파일하는 경우에만 사용할 수 있습니다 API, &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY는&lt;/a&gt; 정의가되어 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;여기에 문서화&lt;/a&gt; . 이 기사는 전체 API 문서를 읽는 것을 대체하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스는 각각에 할당 별도의 스레드가 시스템에 사용하도록 설계되어 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; . 구현시 단일 스레드가 여러 데이터베이스 연결을 실행하지 못하게하는 것은 없습니다. 그러나 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스는 한 번에 단일 연결에서만 작동하므로 여기에 제시된 잠금 해결 논리는 스레드 당 단일 데이터베이스 연결에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="translated">&lt;a href=&quot;c3ref/update_hook&quot;&gt;업데이트 후크&lt;/a&gt; 바꾸기 충돌 해결 전략에 의해 삭제 된 행에 대해 호출되지 않습니다. REPLACE도 &lt;a href=&quot;c3ref/changes&quot;&gt;변경 카운터를&lt;/a&gt; 증가시키지 않습니다 . 이 단락에 정의 된 예외적 인 동작은 다음 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; API는 이름으로 특정 VFS를 찾는 데 사용됩니다. 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister ()&lt;/a&gt; API는 시스템에서 기존 VFS를 제거하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor의&lt;/a&gt; 구조는 가상 테이블의 특정 행에 대한 포인터를 나타냅니다. 이것은 sqlite3_vtab_cursor의 모습입니다 :</target>
        </trans-unit>
        <trans-unit id="7da2c1fa98bb7a679ac7ffc72d14de8a7e2722aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결의 busy-handler를 호출하려면 배열의 두 번째 (void *)를 유일한 인수로 사용하여이 함수를 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER의&lt;/a&gt; 파일 제어가 연결 바쁜 핸들러 콜백에 액세스 할 수있는 사용자 정의 VFS를 제공하기 위해 열린 직후 데이터베이스 파일 핸들에 SQLite는 호출 할 수 있습니다. 인수는 유형 (void **)-두 개의 (void *) 값으로 구성된 배열입니다. 첫 번째 (void *)는 실제로 (int (*) (void *)) 유형의 함수를 가리 킵니다. 연결 처리기 핸들러를 호출하려면이 함수는 배열의 두 번째 (void *)를 유일한 인수로 사용하여 호출해야합니다. 0이 아닌 값을 반환하면 작업을 다시 시도해야합니다. 0을 반환하면 사용자 지정 VFS는 현재 작업을 포기해야합니다.</target>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE의&lt;/a&gt; 연산 코드는 VFS가 확장하고 사용자가 지정한 크기의 덩어리에서 데이터베이스 파일을 자릅니다 것을 요구하는 경우에 사용됩니다. &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 네 번째 인수 는 지명 된 데이터베이스에 사용할 새 청크 크기를 포함하는 정수 (유형 int)를 가리켜 야합니다. 큰 청크 (예 : 한 번에 1MB)로 데이터베이스 파일 공간을 할당하면 파일 시스템 조각화가 줄어들고 일부 시스템의 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2724ba1a9151f430bfc44ff351307f4c931e3d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE의&lt;/a&gt; * 표시 -shm 파일 페이지가 체크 포인트 된 사실을 기록하기 위해 업데이트되기 전에 연산 코드는 클라이언트가 데이터베이스 파일에 월마트 파일에서 완성 된 복사 페이지가 이후 월마트 모드에서 체크 포인트 내에서 호출되지만.</target>
        </trans-unit>
        <trans-unit id="e6b7ae020cfbad6284212ff443474df4c8cbc164" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START의&lt;/a&gt; 클라이언트가 데이터베이스 파일에 월마트 파일에서 페이지를 복사하기 시작하기 전에 옵 코드는 월마트 모드에서 체크 포인트 내에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE이&lt;/a&gt; 원자 적으로 수행 할 수 있습니다. 이 파일 제어는 쓰기가 모두 성공적으로 수행되고 지속적 스토리지에 커미트 된 경우에만 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 성공 여부에 관계없이이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 해제하여 모든 후속 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 호출 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되어 VFS에 전송 트랜잭션이 즉시 커밋 된 후에 만 데이터베이스 잠금이 해제되기 전에된다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 이 opcode와 함께 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 호출해서는 안되며 이를 요구하는 특수 VFS의 작동을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 부호없는 32 비트 정수에 대한 포인터입니다. 호출기에 대한 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결에서 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결로 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략는 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하는 변경 사항을 감지하고 연결된 특정 데이터베이스와 연관된 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="429853e91982da517f099946a428569f5a10010d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION의&lt;/a&gt; 연산 코드는 데이터베이스 파일에 대한 변경 사항을 감지하는 데 사용됩니다. 인수는 32 비트 부호없는 정수에 대한 포인터입니다. 호출기의 &quot;데이터 버전&quot;이 포인터에 기록됩니다. &quot;데이터 버전&quot;은 동일한 데이터베이스 연결의 SQL 문을 통해 또는 다른 프로세스에서 별도의 데이터베이스 연결에 의해 커밋 된 트랜잭션을 통해 해당 데이터베이스 파일이 변경 될 때마다 변경됩니다. &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스는 연결에 대한 데이터베이스가 변경된 경우 찾을 수 있습니다,하지만 인터페이스 TEMP의 변경뿐만 아니라 홈페이지에 응답하고는 주요 변경 사항을 감지하는 메커니즘을 제공하지 않습니다. 또한 &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;인터페이스는 내부 변경에만 응답하고 다른 데이터베이스 연결에 의한 변경은 생략합니다. &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA의 data_version의&lt;/a&gt; 명령은 다른 데이터베이스 연결로 인해 발생하는 단일 연결된 데이터베이스에 대한 변경을 검출하는 메커니즘을 제공하지만를 생략가 호출되는 데이터베이스 연결 구현 변화한다. 이 파일 제어는 내부 또는 외부에서 발생하고 특정 연결된 데이터베이스와 관련된 변경 사항을 감지하는 유일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 코드는 포인터 얻기 위해 사용된다 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 특정 데이터베이스 연결과 관련된 개체. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; 파일 제어 정수에 대한 포인터로 인수를 해석하고는, 이름이 이동하거나 처음 열린 이후 삭제 된 여부 파일에 따라 그 정수에 부울을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER의&lt;/a&gt; 연산 코드는 포인터 가져 오는 데 사용됩니다 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 저널 파일합니다 (하나와 관련된 객체 &lt;a href=&quot;../lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 또는 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 특정 데이터베이스 연결을). &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 잠금의 현재 상태 ( &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; 또는 &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 중 하나 )를 pArg 인수가 가리키는 정수로 쓰도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST 컴파일 타임 옵션이 사용 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 연산 코드는 M은 하나의 부호없는 정수 파라미터이고, 실패 전에 M 밀리 초까지 기다릴 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려는 시도를 야기한다.</target>
        </trans-unit>
        <trans-unit id="f76db0b59ac49aa27a2ffafc1d9d0b7df64c41cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT의&lt;/a&gt; 오피은 VFS의 XLOCK xShmLock 또는 방법을 이용하여 파일에 잠금을 획득하려고 시도 할 때 실패 전에 M 밀리 세컨드까지의 블록에 대해 VFS를 구성하는데 사용된다. 매개 변수는 M이 설정 될 값을 포함하는 32 비트 부호있는 정수에 대한 포인터입니다. 반환하기 전에 부호있는 32 비트 정수를 이전 값 M으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE의&lt;/a&gt; 파일 제어에 사용되는 최대 바이트 수 쿼리에 사용되거나 설정되어 I / O를 메모리 매핑. 인수는 파일 대 메모리 맵의 권고 최대 바이트 수인 sqlite3_int64 유형의 값에 대한 포인터입니다. 이전 값으로 포인터를 덮어 씁니다. 원래 가리키는 값이 음수이면 한계가 변경되지 않으므로 포인터를 음수로 전달하여 현재 한계를 쿼리 할 수 ​​있습니다. 이 파일 제어는 &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; 구현에 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE의&lt;/a&gt; 연산 코드는 그 어떤 이유로 롤백하지 않는 것을 나타 내기 위해 쓰기 트랜잭션을 연 후 SQLite는에 의해 호출, 전체 데이터베이스 파일은 현재 트랜잭션을 덮어 씁니다. VACUUM 작업에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; op 코드 세트에 사용되거나 지속적인 쿼리입니다 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 설정을. 기본적으로 트랜잭션 제어에 사용되는 보조 미리 쓰기 로그 ( &lt;a href=&quot;../wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; ) 및 공유 메모리 파일은 데이터베이스에 대한 최신 연결이 닫힐 때 자동으로 삭제됩니다. 영구 WAL 모드를 설정하면 파일을 닫은 후에도 해당 파일이 유지됩니다. 데이터베이스를 읽을 수 있으려면 WAL 및 공유 메모리 파일이 있어야하므로 데이터베이스 파일을 포함하는 디렉토리에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스 파일을 읽으려는 경우 파일을 유지하는 것이 유용합니다. &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수이 opcode는 정수에 대한 포인터 여야합니다. 이 정수는 영속 WAL 모드를 비활성화하려면 0이고 영속 WAL 모드를 활성화하려면 1입니다. 정수가 -1이면 현재 WAL 지속성 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE의&lt;/a&gt; op 코드 세트에 사용되거나 영구 &quot;powersafe 덮어 쓰기&quot;또는 &quot;PSOW&quot;설정을 조회한다. PSOW 설정 은 xDeviceCharacteristics 메소드 의 &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; 비트를 결정합니다 . 이 opcode에 대한 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수 는 정수에 대한 포인터 여야합니다. 이 정수는 0으로 제로 손상 모드를 비활성화하거나 1로 제로 손상 모드를 활성화합니다. 정수가 -1이면 현재 제로 손상 모드 설정으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU의&lt;/a&gt; 연산 코드 만 RBU 확장에 사용되는 특수 VFS에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE의&lt;/a&gt; 에 이전 호출이 성공한 이후 연산 코드는 모든 쓰기 작업이 발생 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE가&lt;/a&gt; 롤백 할 수 있습니다. 이 파일 제어는 파일 디스크립터를 배치 쓰기 모드에서 꺼내어 이후의 모든 쓰기 조작이 독립적입니다. SQLite는 것입니다 결코에 전에 성공적으로 호출없이 SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 호출 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT의&lt;/a&gt; 연산 코드는 VFS 층을 데이터베이스 파일이 현재 트랜잭션 동안으로 성장하는 방법 대규모의 힌트를 제공하는 SQLite는 데 사용됩니다. 이 힌트는 정확하지는 않지만 종종 가깝습니다. 기본 VFS는 데이터베이스 파일에 대한 쓰기 속도를 높이기 위해이 힌트를 기반으로 데이터베이스 파일 공간을 사전 할당하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT의&lt;/a&gt; 연산 코드가 구현 그 메모리 VFS가 사용된다 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 이 상부 메모리 데이터베이스의 크기에 바인딩 설정한다. 인수는 &lt;a href=&quot;int64&quot;&gt;sqlite3_int64에&lt;/a&gt; 대한 포인터 입니다. 가리키는 정수가 음수이면 현재 한계로 채워집니다. 그렇지 않으면 한계는 지정된 정수 값과 현재 데이터베이스 크기보다 크게 설정됩니다. 지정된 정수가 새로운 한계로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성하여 xSync 메소드가 호출되지 않은 경우 xSync 메소드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 마스터 저널 파일 이름을 포함하는 널 종료 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 자동으로 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출하면 안됩니다 이 opcode를 사용하면이를 요구하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca40036ed80ac456626498e6b097f64ffd5f3c6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC의&lt;/a&gt; 연산 코드는 SQLite는에 의해 내부적으로 생성되고 xSync 방법은 데이터베이스 파일 기술자에 호출되기 전에 즉시 VFS로 전송됩니다. 또는 사용자가 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF로&lt;/a&gt; SQLite를 구성했기 때문에 xSync 메서드가 호출되지 않은 경우 xSync 메서드 대신 호출됩니다. 대부분의 경우이 파일 제어와 함께 전달 된 포인터 인수는 NULL입니다. 그러나 데이터베이스 파일이 다중 데이터베이스 커밋의 일부로 동기화되는 경우 인수는 트랜잭션 수퍼 저널 파일 이름을 포함하는 널로 끝나는 문자열을 가리 킵니다. 이 신호가 필요하지 않은 VFS는이 opcode를 조용히 무시해야합니다. 응용 프로그램은 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()을&lt;/a&gt; 호출해서는 안됩니다. 이 opcode를 사용하면이를 필요로하는 특수 VFS의 작동이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE의&lt;/a&gt; 파일 제어는 SQLite는 스택의 상위 계층이 무엇을하고 있는지에 대한 VFS에 자문 정보를 제공합니다. 이 파일 제어는 일부 VFS 활동 추적 &lt;a href=&quot;../vfs#shim&quot;&gt;shim에서&lt;/a&gt; 사용됩니다 . 인수는 0으로 끝나는 문자열입니다. &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; 컴파일 타임 옵션이 활성화 된 경우 SQLite 스택의 상위 계층에서이 파일 컨트롤의 인스턴스를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME의&lt;/a&gt; 오피 모든 이름 얻기 위해 사용될 수있다 &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; VFS에 스택한다. 이름은 모든 VFS 심의 이름이며 최종 하위 레벨 VFS는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록되며 결과는 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 의 네 번째 매개 변수가 가리키는 char * 변수에 저장 됩니다. 호출자가 완료되면 메모리를 확보해야합니다. 모든 파일 제어 작업과 마찬가지로 실제로이 작업이 수행 될 것이라는 보장은 없습니다. 이 파일 제어가 구현되지 않은 경우 호출자는 char * 변수를 NULL 포인터로 초기화해야합니다. 이 파일 제어는 진단 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 연산 코드 최상위에 대한 포인터 발견 &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; 현재 사용합니다. sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X)의 인수 X는 &quot; &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot; 유형이어야합니다 . 이 opcode는 * X를 최상위 VFS의 포인터로 설정합니다. 스택에 여러 VFS 심이있는 경우이 opcode는 최상위 심만 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK는&lt;/a&gt; 로크가 바로 사용할 수없는 경우가 다음 WAL 로크에 차단하는 것이 유리할 수 있다는 VFS 계층 신호이다. WAL 하위 시스템은 우선 순위 반전 문제를 해결하기 위해 드문 상황에서이 신호를 발행합니다. 응용 프로그램은 이 파일 제어를 사용 &lt;em&gt;하지 않아야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY의&lt;/a&gt; 연산 코드는 특정 디스크에 대한 자동 재시도 횟수와 간격을 구성하는 데 사용되는 윈도우에 대한 I / O 작업 &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;안티 바이러스 프로그램이있을 때 견고성을 제공합니다. 기본적으로, Windows VFS는 파일 다시 읽기, 파일 쓰기 및 파일 삭제 조작을 최대 10 번까지 다시 시도하며, 첫 번째 재시도 전에 25 밀리 초의 지연이 발생하며 이후의 재 시도마다 25 밀리 초씩 지연됩니다. 이 opcode를 사용하면이 두 값 (재시도 10 회 및 25 밀리 초 지연)을 조정할 수 있습니다. 동일한 프로세스 내의 모든 데이터베이스 연결에 대한 값이 변경됩니다. 인수는 첫 번째 정수가 새 재시도 횟수이고 두 번째 정수가 지연되는 두 정수 배열에 대한 포인터입니다. 정수 중 하나가 음수이면 설정이 변경되지 않고 대신 해당 설정의 이전 값이 배열 항목에 기록되어 현재 재시도 설정을 조사 할 수 있습니다.zDbName 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE의&lt;/a&gt; 연산 코드는 파일 핸들과 관련된 기본 기본 파일 핸들을 얻을 수 있습니다. 이 파일 컨트롤은 인수를 기본 파일 핸들에 대한 포인터로 해석하여 결과 값을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE의&lt;/a&gt; op 코드 디버깅에 사용된다. 이 opcode는 xFileControl 메소드가 파일 핸들을 pArg 인수가 가리키는 핸들과 교체하도록합니다. 이 기능은 테스트 중에 사용되며 SQLITE_TEST가 정의 된 경우에만 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS의&lt;/a&gt; 오피은 zipvfs에 의해 구현됩니다. 다른 모든 VFS는이 opcode에 대해 SQLITE_NOTFOUND를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE의&lt;/a&gt; 플래그는 닫을 때 파일을 삭제해야 의미합니다. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE는&lt;/a&gt; TEMP 데이터베이스 및 일지, 과도 데이터베이스 및 subjournals 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; 플래그는 항상 함께 사용됩니다 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE의&lt;/a&gt; 모두 POSIX 개방 () API의 O_EXCL과 O_CREAT 플래그에 직접적으로 유사하다 플래그입니다. SQLITE_OPEN_CREATE와 함께 사용될 때 SQLITE_OPEN_EXCLUSIVE 플래그는 파일이 항상 작성되어야하며 파일이 이미 존재하는 경우 오류임을 표시하는 데 사용됩니다. 그것은</target>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">sqlite3.h 헤더 의 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C 전 처리기 매크로는 &quot;XYZ&quot;형식의 SQLite 버전 인 문자열 리터럴로 평가합니다. 여기서 X는 주 버전 번호 (항상 SQLite3의 경우 3)이고 Y는 부 버전 번호이고 Z는 릴리스 번호 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C 전처리 값을 갖는 정수 매크로 리졸 (X + Y * 1000000 * 1000 + Z) X, Y 및 Z가 사용되는 동일한 숫자 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; . 지정된 SQLite 릴리스에 대한 SQLITE_VERSION_NUMBER도 파생 된 릴리스보다 큽니다. Y는 일정하게 유지되고 Z는 증가하거나 그렇지 않으면 Y는 증가하고 Z는 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">&lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스에 호출하여 이전 등록 된 초기화 루틴 X 등록 취소 &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension (X)를&lt;/a&gt; . &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 으로 돌아 간다 (1) 초기화 루틴의 X 성공적으로 등록했다 경우 X 초기화 루틴의 목록에없는했다 경우 0 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="translated">&lt;a href=&quot;carray&quot;&gt;carray 테이블 반환 함수는&lt;/a&gt; 응용 프로그램에서 C 언어 값의 배열에 대한 포인터를 받아 들일 필요가있다.</target>
        </trans-unit>
        <trans-unit id="99b9d11b0a4071822aa18a343a895720b0d0af06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command now accepts multiple LIKE-pattern arguments and outputs the union of all matching tables.</source>
          <target state="translated">&lt;a href=&quot;cli#dump&quot;&gt;.dump의&lt;/a&gt; 명령이 여러 LIKE 패턴 인수를 받아, 모든 매칭 테이블의 조합을 출력한다.</target>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; 컴파일시 옵션은 새 데이터베이스에 할당 된 기본 페이지 크기를 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE는&lt;/a&gt; 1024에서 4096로 증가 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE는&lt;/a&gt; 같은 크기의 캐시 메모리가 기본적으로 사용되도록 -2000 2000에서 변경됩니다. 자세한 정보 는 &lt;a href=&quot;pgszchng2016&quot;&gt;버전 3.12.0 페이지 크기 변경에&lt;/a&gt; 대한 애플리케이션 노트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 컴파일시 옵션은 페이지 캐시 바이 패스 오버 플로우 페이지의 내용을 읽을 때에 SQLite는 발생합니다. 이를 통해 10K Blob의 데이터베이스 읽기 속도가 약간 빨라지지만 훨씬 빠르지는 않습니다. SQLite는 여전히 SQLITE_DIRECT_OVERFLOW_READ 컴파일 타임 옵션이없는 직접 파일 시스템 읽기보다 속도 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS은&lt;/a&gt; 컴파일 시간 옵션은 현재 표준에 기본적으로 설정되어 빌드.</target>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 컴파일시 옵션은이 원인 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 더 나은 도움말 SQLite는에, 각 인덱스의 작은 히스토그램을 수집 경쟁 범위 질의 지표 중에서 선택 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt; 정규 소스 파일에서 빌드 할 때 컴파일시 옵션은 작동합니다. SQLite &lt;a href=&quot;amalgamation&quot;&gt;통합&lt;/a&gt; 또는 사전 처리 된 소스 파일에서 빌드 할 때는 작동 하지 &lt;u&gt;않습니다&lt;/u&gt; .</target>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="translated">&lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT의&lt;/a&gt; 옵션은 쿼리 계획을 고려하는 것이 인덱스 앤 제약 조합의 최대 번호에 대한 초기 기본 값을 설정합니다. 기본 조인 계획자 한계는 조인의 각 테이블을 처리하기 전에 SQLITE_QUERY_PLANNER_LIMIT_INCR에 의해 증가되어 각 테이블이 조인의 이전 테이블이 소진 된 경우에도 옵티 마이저에 최소한 일부 인덱스 및 제약 조건 조합을 제안 할 수 있습니다. 기준선 한도. 이 컴파일 시간 옵션과 &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; 옵션 모두에 대한 기본값 은 실제 쿼리에 도달 할 수 없도록 충분히 높게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="translated">&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 컴파일시 옵션을 확인하면 내용도 삭제되었는지 확인하기 위해 고정 &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;잘라 내기 최적화가&lt;/a&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 파라미터 값이 0에서 3까지의 정수이다 #define 값이다. &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수 의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 시간 옵션의 길이를 제한하기 위해 사용될 수있는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;결합 된 파라미터&lt;/a&gt; sqlite3_trace의 출력 확장 ().</target>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT의&lt;/a&gt; 컴파일시 옵션은 바인딩 매개 변수 확장의 크기를 제한합니다. &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE의&lt;/a&gt; 컴파일시 옵션 원인 sqlite3_expanded_sql ()는 항상 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d80a700ed456a052f14722da1654635b16877833" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option will cause this setting to default to OFF.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt; 컴파일시 옵션이 설정이 OFF로 기본 설정하게됩니다.</target>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) 인터페이스 sqlite3_pcache_methods2 구조체의 인스턴스를 전달하여 다른 페이지의 캐시 구현을 등록 할 수있다. 많은 응용 프로그램에서 SQLite에 의해 할당 된 대부분의 힙 메모리는 페이지 캐시에 사용됩니다. 이 API를 사용하여 사용자 정의 페이지 캐시를 구현함으로써, 애플리케이션은 SQLite가 소비하는 메모리의 양, 메모리가 할당 및 해제되는 방식, 데이터베이스 파일의 어떤 부분이 정확하게 캐시되는지를 결정하는 데 사용되는 정책을보다 잘 제어 할 수 있습니다. 얼마나 오래.</target>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="translated">는 &lt;a href=&quot;eqp&quot;&gt;QUERY 계획 EXPLAIN&lt;/a&gt; A의 각 루프에 의해 생성 된 행의 추정 가입 출력 더이상 보여준다.</target>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를위한 방법 xFileControl 직접 호출한다 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 두 번째 인수에 의해 식별되는 특정 데이터베이스와 연관된 객체. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 데이터베이스의 경우 &quot;temp&quot;이거나 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 추가 된 데이터베이스의 AS 키워드 뒤에 나타나는 이름입니다 . &quot;main&quot;대신 NULL 포인터를 사용하여 기본 데이터베이스 파일을 참조 할 수 있습니다. 이 루틴에 대한 세 번째 및 네 번째 매개 변수는 xFileControl 메소드의 두 번째 및 세 번째 매개 변수로 직접 전달됩니다. xFileControl 메소드의 리턴 값은이 루틴의 리턴 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="translated">SQLite 데이터베이스 의 &lt;a href=&quot;fileformat2&quot;&gt;기본 파일 형식&lt;/a&gt; 은 호환되지 않는 방식으로 변경되지 않습니다. 문자 그대로 수십억 개, 아마도 1 조 개에 달하는 SQLite 데이터베이스 파일이 유통되고 있으며 SQLite 개발자는 수십 년 동안이 파일을 지원하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#validfor&quot;&gt;버전 유효-에 대한 수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL 파일 형식은&lt;/a&gt; 정확하게 정의 및 크로스 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="d24509e4b9939bc43b94f948e05ab88b6b7e58c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; and the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; are built-in to the CLI</source>
          <target state="translated">&lt;a href=&quot;floatingpoint#decext&quot;&gt;진수 확장&lt;/a&gt; 과 &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;IEEE754 확장&lt;/a&gt; 내장되어있는 CLI에</target>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;상위 키&lt;/a&gt; (A)의 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건은&lt;/a&gt; ROWID를를 사용할 수 없습니다. 부모 키는 명명 된 열만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH 연산자로 포인터 전달 &lt;a href=&quot;fts3#snippet&quot;&gt;니펫 ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋 ()&lt;/a&gt; 과 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4이 명령은 &quot;다시&quot;&lt;/a&gt; 전체 전체 텍스트 인덱스를 삭제하고 내용 테이블에있는 문서의 현재 설정을 기반으로 다시 작성합니다. &quot;t3&quot;이 외부 컨텐츠 FTS4 테이블의 이름이라고 다시 가정하면, 재 빌드 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수는 항상 NULL을 반환하지 않는 중 하나를 사용하여 활성화 된 인터페이스 레거시 응용 프로그램 정의 FTS3의 tokenizers &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ) 설정, 또는 fts3_tokenizer에 첫 번째 인수 ()가 아닌 경우 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인딩 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="translated">&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH의&lt;/a&gt; 운영자는 내장 전체 텍스트 인덱스를 기반으로 쿼리 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'X'플래그는&lt;/a&gt; 문구 &quot;A&quot;와 &quot;C&quot;에 대한 하나의 타격을보고있다. 그러나 'y'지시문은 문서와 일치하지 않는 하위 표현식의 일부이므로 &quot;c&quot;에 대한 적중 횟수를 0으로보고합니다 (b AND c). OR 연산자에서 내림차순 AND 연산자를 포함하지 않는 쿼리의 경우 'y'에 의해 반환되는 결과 값은 항상 'x'에 의해 반환 된 결과 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 기능은&lt;/a&gt; , &lt;a href=&quot;fts3#snippet&quot;&gt;스 니펫 ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋 ()&lt;/a&gt; , 및 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()는&lt;/a&gt; 전체 텍스트 쿼리를 지원하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;조각의&lt;/a&gt; 기능은 위의 쿼리와 함께 사용할 수 없습니다. 외부 쿼리에는 &quot;WHERE ... MATCH&quot;절이 포함되어 있지 않으므로 스 니펫 함수와 함께 사용할 수 없습니다. 한 가지 해결책은 외부 쿼리에서 하위 쿼리에 사용 된 WHERE 절을 복제하는 것입니다. 이와 관련된 오버 헤드는 일반적으로 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; 토크 나이는 지금에 포함되어 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;BM25 () 보조 기능은&lt;/a&gt; 현재 매치의 정확성을 반영 실제 값을 반환한다. 더 나은 일치는 수치 적으로 낮은 값으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;ColumnSize가&quot;옵션&lt;/a&gt; FTS5 테이블의 각 값의 토큰의 크기가 데이터베이스 내에서 별도로 저장할지 여부를 구성하는 데 사용.</target>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;세부 사항&quot;옵션&lt;/a&gt; . 이 옵션을 사용하면 일부 정보를 생략하여 디스크의 FTS 인덱스 크기를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="translated">&lt;a href=&quot;fts5#the_highlight_function&quot;&gt;하이라이트 () 보조 기능&lt;/a&gt; 복귀 예컨대 지정된 태그 (둘러싸인 결과 내의 질의 용어의 각 인스턴스는 현재 매치의 열 중 하나의 텍스트 복사 &quot;&amp;lt;B&amp;gt;&quot;및 &quot;&amp;lt;/ B&amp;gt;&quot; ).</target>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;니펫 () 함수는 보조&lt;/a&gt; 정합 행 및 질의 용어의 각 인스턴스를 반환하여 하이라이트 () 함수와 같은 방식으로 마크 업에 의해 둘러싸여의 열 중 하나의 텍스트의 짧은 단편을 선택한다. 포함 된 쿼리 용어의 수를 최대화하기 위해 텍스트 조각이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;미국 퍼지 롭&lt;/a&gt; 또는 마이클 잘레 스키의 최근 (2014 년경) 혁신 fuzzer &quot;AFL&quot;. 무작위 입력을 맹목적으로 생성하는 대부분의 다른 퍼저와 달리 AFL 퍼 저는 테스트중인 프로그램을 계측하고 (C 컴파일러의 어셈블리 언어 출력을 수정하여) 입력을 통해 프로그램이 다른 작업을 수행하는시기를 감지하기 위해 해당 계측을 사용합니다. 새로운 제어 경로 또는 다른 횟수의 루프. 새로운 동작을 유발하는 입력은 유지되고 추가로 변경됩니다. 이러한 방식으로 AFL은 디자이너가 상상하지 못한 행동을 포함하여 테스트중인 프로그램의 새로운 행동을 &quot;발견&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석 DVCS는&lt;/a&gt; SQLite는 모든 소스 코드를 추적하는 데 사용되는 버전 관리 시스템입니다. Fossil 저장소는 SQLite 데이터베이스 파일입니다. 독자들은이 재귀를 독립적 인 연습으로 숙고하도록 초대받습니다. 화석은 SQLite의 버전 제어 시스템이자 SQLite의 테스트 플랫폼입니다. SQLite가 개선 될 때마다 Fossil은 이러한 개선 사항을 테스트하고 평가하는 최초의 응용 프로그램 중 하나입니다. 그래서 화석은 NGQP의 초기 채택 자였습니다.</target>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL 로직 테스트&lt;/b&gt;&lt;/a&gt; 또는 SLT 테스트 장치는 SQLite는 여러 다른 SQL 데이터베이스 엔진 모두에 대한 SQL 문의 거대한 수를 실행하고 그들이 모두 같은 답변을 얻을 수 있는지 확인하는 데 사용됩니다. SLT는 현재 SQLite를 PostgreSQL, MySQL, Microsoft SQL Server 및 Oracle 10g와 비교합니다. SLT는 1.12GB의 테스트 데이터로 구성된 720 만 개의 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="translated">웹킷에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; 인터페이스는 모든 웹 페이지가 Chrome 및 Safari 용 브라우저에서 임의의 SQL을 실행할 수 있도록 허용했습니다. 그 임의의 SQL은 악용 되더라도 해를 끼칠 수없는 샌드 박스 내에서 실행되어야했지만, 그 샌드 박스는 사람들보다 안전하지 않은 것으로 판명되었습니다. 2017 년 봄, 한 해커 팀은 긴 시퀀스의 익스플로잇을 사용하여 iMac을 루팅 할 수있었습니다. 그 중 하나는 WebSQL 인터페이스를 통해 실행되는 SQLite 데이터베이스의 snippet () FTS3 함수에 BLOB 값으로 전달 된 포인터를 손상시키는 것과 관련이있었습니다. 사파리 내부.</target>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;화석 분산 버전 관리&lt;/a&gt; 시스템은 하나있는 TAR, ZIP 아카이브, 또는 SQLite는 아카이브로 다운로드 체크인하는 옵션을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;추가] VFS는&lt;/a&gt; A는 &lt;a href=&quot;vfs#shim&quot;&gt;VFS 심&lt;/a&gt; SQLite는 데이터베이스가 다른 파일에 추가 할 수 있습니다. 이를 통해 데이터베이스를 실행 파일에 추가 한 다음 데이터베이스를 열고 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; introspecting과 데이터베이스에한데, btree의 크기를 추정 시조 가상 테이블.</target>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="translated">는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;확장 () 기억&lt;/a&gt; 이 통과 값을 기억하는 C 언어의 정수 변수에 대한 포인터를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c의&lt;/a&gt; 확장은 지속적으로 새로운 VFS 새로운 가상 테이블을 모두 등록하는 적재 가능한 확장의 일례를 도시한다. 해당 확장 의 &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init ()&lt;/a&gt; 초기화 루틴은 확장이 처음로드 될 때 한 번만 호출됩니다. 새로운 &quot;vfslog&quot;VFS를 한 번만 등록하고 &quot;vfslog&quot;VFS를 구현하는 데 사용되는 코드가 메모리에 남아 있도록 SQLITE_OK_LOAD_PERMANENTLY를 반환합니다. 초기화 루틴은 또한 &quot;vstatRegister ()&quot;함수에 대한 포인터에서 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 을 호출하여 모든 후속 데이터베이스 연결이 시작될 때 &quot;vstatRegister ()&quot;함수를 호출하고 &quot;vfsstat&quot;가상 테이블을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; 쉘 스크립트는 또한 정규 소스 트리에서 speedtest1.c 프로그램을 실행하는 데 사용됩니다. 성능 측정을 복제하려면 다음 파일을 단일 디렉토리로 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘에&lt;/a&gt; 대한 &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src / shell.c&lt;/a&gt; 소스 코드 는 더 이상 버전 제어를받지 않습니다. 이 파일은 이제 빌드 프로세스의 일부로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite는 화석 저장소는&lt;/a&gt; 타르볼, ZIP 아카이브, 또는 다운로드를위한 링크가 포함 &lt;a href=&quot;sqlar&quot;&gt;SQLite는 아카이브&lt;/a&gt; SQLite는 모든 역사적 버전을. 이러한 다운로드의 URL은 간단하며 자동화 된 도구에 쉽게 통합 될 수 있습니다. 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON 표준&lt;/a&gt; JSON을 사용하여 지리 정보를 교환하기위한 구문이다. GeoJSON은 거의 모든 종류의 지리 공간 컨텐츠를 설명 할 수있는 풍부한 표준입니다.</target>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;화석 버전 제어 시스템은&lt;/a&gt; SQLite는의 printf () 구현의 초기 버전에서 파생 자신의 printf () 구현을 사용하지만, 그 두 가지 구현 이후 분기있다.</target>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="translated">&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 버전 제어 시스템 (설계 및 SQLite는 개발을 지원하기위한 목적으로 작성)은 약간 문제 티켓 보고서를 생성하는 임의의 SQL를 입력하도록 사용자를 신뢰할 수있게. &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 SQL을 삭제 하고 익스플로잇을 찾지 못했습니다. 그러나 이것은 잠재적으로 적대적인 에이전트가 시스템에 임의의 SQL을 주입 할 수있는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하는 T 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 변수는 T 매개 변수가 X 번째 루프가 실행 된 총 횟수로 설정됩니다에 의해 지적했다.</target>
        </trans-unit>
        <trans-unit id="ffcdafee896254e841c8ceef0c82d886514030ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; 행의 갯수가 X 번째 루프의 모든 반복에 의해 검사하기 V 파라미터가 가리키는 변수가 설정된다.</target>
        </trans-unit>
        <trans-unit id="c0533f74a6fe1362e5ed7a748ce1c72de0f80c71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;sqlite3_int64의&lt;/a&gt; V 자 파라미터가 가리키는 변수는 X 번째 루프가 실행 된 총 횟수로 설정한다.</target>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="translated">이 웹 사이트 의 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;내부 대 외부 BLOB&lt;/a&gt; 기사는 2011 년경의 초기 조사로, Jim 회색 종이와 같은 접근 방식을 사용합니다 (데이터베이스에 항목으로 BLOB 파일 이름을 저장) &amp;ndash; SQL Server 대신 SQLite에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="translated">&lt;a href=&quot;lang&quot;&gt;SQL 언어 문서를&lt;/a&gt; 사용하도록 변환되는 &lt;a href=&quot;syntaxdiagrams&quot;&gt;구문 도표&lt;/a&gt; 대신 BNF의를.</target>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE의&lt;/a&gt; 외래 키 제약 조건을 사용할 때 명령은 두 가지 측면에서 다르게 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="translated">는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 가 어떤 인덱스가없는 경우에도 명령은 이제 테이블에 대한 통계를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="translated">는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문이 두 개 이상의 데이터베이스가 동일한 데이터베이스 연결에 연관되어 그들이 하나의 데이터베이스 인 것처럼 작동 할 수 있도록하는 SQLite는 확장입니다. 동시에 접속 된 데이터베이스 수는 SQLITE_MAX_ATTACHED로 제한되며 기본적으로 10으로 설정됩니다. 연결된 데이터베이스의 최대 수는 125를 초과하여 증가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 절</target>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;IFNULL ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;유착 ()&lt;/a&gt; SQL 함수는 사용되지 않은 인수가 평가되지 않을 필요가 그래서, 인라인 VDBE 코드를 사용하기보다는 외부 함수를 호출 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c97e1aa1d73b591cf5ec83039aad0924cf633432" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; is subject to the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; limit of &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. Hence any printf() result with a width or precision more than the SQLITE_LIMIT_LENGTH will cause an &lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; error. However, the low-level formatting for the printf() function is done by a subroutine that does not have access to SQLITE_LIMIT_LENGTH. So the low-level formatting is done into a memory allocation that might be considerably larger than SQLITE_LIMIT_LENGTH and the SQLITE_LIMIT_LENGTH check is only performed after all formatting is complete. Thus there might be a transient buffer that exceeds SQLITE_LIMIT_LENGTH. The SQLITE_PRINTF_PRECISION_LIMIT option is an additional check that prevents excess sizes for the transient buffer used inside the low-level formatting subroutine, prior to the SQLITE_LIMIT_LENGTH check.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;의 printf () 함수는 SQL&lt;/a&gt; 받는 될 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH의&lt;/a&gt; 한계 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; . 따라서 너비 또는 정밀도가 SQLITE_LIMIT_LENGTH보다 큰 printf () 결과는 SQLITE_TOOBIG를 발생 &lt;a href=&quot;rescode#toobig&quot;&gt;시킵니다.&lt;/a&gt;오류. 그러나 printf () 함수에 대한 하위 레벨 형식화는 SQLITE_LIMIT_LENGTH에 대한 액세스 권한이없는 서브 루틴에 의해 수행됩니다. 따라서 로우 레벨 포맷은 SQLITE_LIMIT_LENGTH보다 상당히 클 수있는 메모리 할당으로 수행되고 SQLITE_LIMIT_LENGTH 검사는 모든 포맷이 완료된 후에 만 ​​수행됩니다. 따라서 SQLITE_LIMIT_LENGTH를 초과하는 임시 버퍼가있을 수 있습니다. SQLITE_PRINTF_PRECISION_LIMIT 옵션은 SQLITE_LIMIT_LENGTH 검사 전에 하위 수준 서식 지정 서브 루틴 내에서 사용되는 임시 버퍼의 초과 크기를 방지하는 추가 검사입니다.</target>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#random&quot;&gt;임의 ()&lt;/a&gt; 는 다른 대답을가 호출 될 때마다 제공하기 때문에 기능은 분명히 비 결정적이다. &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid ()&lt;/a&gt; 의 답변은 이전 SQL 문에 의존하므로 결정적이지 않습니다. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version ()&lt;/a&gt; 함수는 대부분 일정이지만, 항상 특정 세션에 대해 같은 대답을 반환하지만 그것은 여전히 비 결정적으로 간주됩니다 세션에서 답변을 변경할 수 있기 때문에, 그래서 심지어 SQLite는이 업그레이드 될 때 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 함수는 B 트리 스토리지 엔진에 새로운 인터페이스의 새로운 연산 코드가 필요 &lt;a href=&quot;opcode&quot;&gt;가상 머신&lt;/a&gt; 이 실행이 문을 SQL 것을, 및 코드 생성기의 중요한 경로에 새로운 조건을. sqlite_offset (X)의 유틸리티가 필요하지 않은 응용 프로그램의 오버 헤드를 피하기 위해이 기능은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#substr&quot;&gt;SUBSTR ()&lt;/a&gt; 는 단지 프리픽스를 계산하는 경우 SQL 함수 길이를 전체 입력 문자열을 측정하는데 귀찮게하지 않는다</target>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid 테이블 의 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; (있는 경우)는 기본 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 스토리지 엔진 에서 사용하는 고유 키가 아니라는 점에서 일반적으로 테이블의 실제 기본 키가 아닙니다 . 이 규칙의 예외는 rowid 테이블이 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY를&lt;/a&gt; 선언 할 때 입니다. 예외적으로 INTEGER PRIMARY KEY는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 별명이됩니다 .</target>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; ROWID 테이블의 읽기 또는 &quot;ROWID&quot;또는 &quot;OID&quot;또는 &quot;_ROWID_&quot;열 중 쓰기 액세스하거나 변경할 수 있습니다. 테이블에 특수 이름을 사용하는 선언 된 열이있는 경우를 제외하고 해당 이름은 기본 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid가&lt;/a&gt; 아니라 선언 된 열을 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="translated">테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 는 정수 여야합니다. 세트에 시도 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 의 정수 (또는 자동으로 사용 가능한 다음 정수 ROWID로 변환됩니다 NULL) 이외의 아무것도를 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;VIEW를 CREATE&lt;/a&gt; 문은 이제보기 이름 다음에 열 이름의 선택적 목록을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; ( '지금') JULIANDAY (예) 항상 같은 내에서 여러 함수 호출에 대해 동일 현재 시간이되도록 개선된다 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;QUERY PLAN EXPLAIN&lt;/a&gt; SQL을 명령 SQLite는 특정의 SQL 쿼리를 구현하는 데 사용하는 전략이나 계획에 대한 높은 수준의 기술을 취득하기 위해서 사용된다. 가장 중요한 것은 EXPLAIN QUERY PLAN이 쿼리가 데이터베이스 인덱스를 사용하는 방식을보고합니다. 이 문서는 EXPLAIN QUERY PLAN 출력을 이해하고 해석하기위한 안내서입니다. 배경 정보는 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="translated">SQL 문에 대한 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 및 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN 접&lt;/a&gt; 두부는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 동안 명령문의 작동에만 영향을줍니다 . 이는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 중에 적용되는 PRAGMA 문이 &quot;EXPLAIN&quot;으로 시작하는지 여부에 관계없이 동일한 방식으로 작동 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="translated">&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="translated">는 &lt;a href=&quot;lang_expr#isisnot&quot;&gt;운영자 IS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS 운영자는&lt;/a&gt; 현재 인덱스를 구동 할 수있다.</target>
        </trans-unit>
        <trans-unit id="b253f85844781796ef1ae81936dfc99cf231cc5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator now overrides wildcard characters, so that the behavior matches what PostgreSQL does.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 의 &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; 절은 이제 와일드 카드 문자를 재정의하므로 동작이 PostgreSQL이 수행하는 것과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;인덱스 BY의&lt;/a&gt; 절</target>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="translated">는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 보류중인 트랜잭션이없는 경우 명령은 트랜잭션 스택이 비어있는 경우 작동, 또는 다른 말로. &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 명령이 호출 될 때 트랜잭션 스택이 비어 있지 않으면 명령이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="translated">는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령은 트랜잭션이 스택 비어 않은 모든 거래와 잎을 얻어냅니다.</target>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령이 대기중인 쿼리가있는 경우에도 성공합니다. 보류중인 증분 BLOB I / O 요청이있는 경우 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 모든 거래와 잎은 트랜잭션이 스택 비어 A를 절 롤 백없이 명령.</target>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;업데이트&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; 및 &lt;a href=&quot;lang_insert&quot;&gt;삽입&lt;/a&gt; 트리거 내에서 문의 전체 구문을 지원하지 않는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_insert&quot;&gt;INSERT의&lt;/a&gt; 문. 다음 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령은 1 % 엄격한에 대한 데이터베이스를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령의 설정 보존 &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그를&lt;/a&gt; . (티켓 # 2804)</target>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; 명령은 임시 파일을 만든 다음 그 임시 파일에 전체 데이터베이스를 재 구축하여 작동합니다. 그런 다음 임시 파일의 내용이 원래 데이터베이스 파일로 다시 복사되고 임시 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; 절은 첫 번째 SELECT에 발생해야 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; . &lt;a href=&quot;syntax/compound-operator&quot;&gt;복합 연산자를&lt;/a&gt; 따를 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기는&lt;/a&gt; 빠른 파서를 생성한다.</target>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 문서는 방법에 대해 설명 &lt;a href=&quot;loadext#build&quot;&gt;로드 가능한 확장 컴파일&lt;/a&gt; 공유 라이브러리 등을. 거기에 설명 된 기술은 json1 모듈에 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">&lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스에 메시지를 기록 &lt;a href=&quot;../errlog&quot;&gt;오류 로그&lt;/a&gt; 에 의해 설립 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; 에 옵션 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; . 로깅이 사용 가능한 경우 zFormat 문자열 및 후속 인수는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 와 함께 사용되어 최종 출력 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4883693c0c81d8dd1cc3d7c0223f243712aeaf0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is enhanced to support two separate memory pools with different sized allocations in each pool. This allows more memory allocations to be covered by lookaside while at the same time reducing the heap memory usage to 48KB per connection, down from 120KB.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;룩어 메모리 할당은&lt;/a&gt; 각각의 풀에서 다른 크기의 할당을 가진 두 개의 메모리 풀을 지원하도록 개선된다. 이를 통해 더 많은 메모리 할당을 lookaside로 처리하는 동시에 힙 메모리 사용량을 120KB에서 연결 당 48KB로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;를 lookaside 메모리 할당&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="translated">페이지 &lt;a href=&quot;malloc#pagecache&quot;&gt;캐시 메모리 할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 뛰어난 (malloc으로 할당하지만 해제) 메모리의 바이트 수. &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 루틴 반환의 최대 값 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 하이 워터 마크 보낸 사람을 마지막으로 재설정 한. 반환하는 값 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()는&lt;/a&gt; 모든 오버 헤드의 구현으로 SQLite는 추가 포함 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 하지만 오버하는 모든 기본 시스템 라이브러리 루틴 추가하지 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; 인터페이스는이 정수 상수들 중 하나 인 하나의 인수를 취하는.</target>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 코드 생성기에 의해 생성 프로그램은 가상 머신에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="translated">&lt;a href=&quot;opcode#Delete&quot;&gt;삭제는&lt;/a&gt; 이 루프의 작업을 수행합니다; 스택에서 정수 키를 꺼내고 (앞의 ListRead에 의해 배치됨) 해당 키가있는 커서 P1의 레코드를 삭제합니다. P2가 true이므로 행 변경 카운터가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Ge&quot;&gt;게르마늄&lt;/a&gt; 작업자는 상부를 스택에 두 요소들을 비교 팝하고 분기 비교 결과에 기초. 두 번째 요소가 최상위 요소보다 크거나 같으면 주소 P2 (루프 끝의 다음 명령어)로 이동합니다. P1이 true이므로 피연산자 중 하나가 NULL (결과가 NULL)이면 점프를 수행합니다. 우리가 점프하지 않으면 다음 지시로 넘어가십시오.</target>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="translated">&lt;a href=&quot;opcode#Gosub&quot;&gt;GOSUB의&lt;/a&gt; 오피 P1 저장 레지스터에 현재 프로그램 카운터는 어드레스 P2로 이동합니다. &lt;a href=&quot;opcode#Return&quot;&gt;반환&lt;/a&gt; 오피 코드는 주소 P1 + 1로 이동합니다. 따라서 모든 서브 루틴은 두 개의 정수, 즉 서브 루틴의 진입 점 주소와 리턴 주소를 보유하는 데 사용되는 레지스터 번호와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#Goto&quot;&gt;고토&lt;/a&gt; 루프의 처음으로 다시 이동합니다. 이것이 루프의 끝입니다.</target>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead의&lt;/a&gt; 명령어는 임시 저장리스트로부터 요소를 판독하고, 스택에 넘겨 준다. 이것이 성공하면 다음 명령으로 계속 진행됩니다. 리스트가 비어 있기 때문에 이것이 실패하면 P2로 분기되는데, 이는 루프 바로 다음의 명령어입니다. 그 후 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset의&lt;/a&gt; 명령은 임시 저장 목록을 비 웁니다. 이 목록은 VDBE 프로그램이 종료되면 자동으로 비워 지므로이 경우에는 필요하지 않습니다. 닫기 명령은 커서 P1을 닫습니다. 이 과정은 VDBE 엔진이이 프로그램 실행을 마치면 수행됩니다. 커밋은 현재 트랜잭션을 성공적으로 종료하고이 트랜잭션에서 발생한 모든 변경 사항이 데이터베이스에 저장되도록합니다. 마지막 Halt도 실행할 준비가되면 모든 VDBE 프로그램에 추가되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind의&lt;/a&gt; 명령은 처음에 임시 저장 목록을 되감기. 이를 통해 두 번째 루프에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;다음의&lt;/a&gt; 연산 코드는 다음과 같은 경우에만 유효 &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 에 커서를 위치 시키는데 사용될 오피. &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 은 &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; 를 따라갈 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists의&lt;/a&gt; 명령은 상위 스택 요소 나타나고 정수 키로 사용한다. 해당 키가있는 레코드가 테이블 P1에 없으면 P2로 이동하십시오. 레코드가 존재하면 다음 명령어로 넘어갑니다. 이 경우 P2는 루프 끝에서 Goto로 이동하여 처음에는 ListRead로 되돌아갑니다. 이것은 루프 시작시 P2를 16으로, ListRead로 코딩하도록 코딩 될 수 있었지만이 코드를 생성 한 SQLite 파서는 그 최적화를하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists는&lt;/a&gt; 수행을 동일한 동작을 오피하지만으로 &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; P3 레지스터는 정수 값을 포함하도록 보장되어야한다. 이 opcode를 사용하면 레지스터 P3에 정수가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="translated">&lt;a href=&quot;opcode#NotFound&quot;&gt;NOTFOUND의&lt;/a&gt; 오피 코드를 수행한다 (임의의 다치 키) 인덱스한데, btree에 동일한 동작.</target>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Prev&quot;&gt;이전의&lt;/a&gt; 연산 코드는 다음과 같은 경우에만 유효 &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; , 또는 &lt;a href=&quot;opcode#Last&quot;&gt;마지막&lt;/a&gt; 커서 위치를 사용 오피 코드. &lt;a href=&quot;opcode#Prev&quot;&gt;이전&lt;/a&gt; 은 &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; 를 따를 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#Recno&quot;&gt;RECNO의&lt;/a&gt; 스택 커서 P1 가리키는 테이블 순차 주사에서 현재 항목 키의 처음 4 바이트 정수 상 명령 푸시. &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite의&lt;/a&gt; 명령어는 임시 저장 목록으로 스택 상단의 정수를 기입 상단 요소 나옵니다. 이것은 삭제 될 레코드의 키를 저장하여 두 번째 루프에서 삭제할 수 있도록이 루프의 중요한 작업입니다. 이 ListWrite 명령 후 스택이 다시 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx의&lt;/a&gt; 오피은 P5 == 0 또는 P5 == OPFLAG_SEEKEQ와 P4가 P4_KEYINFO 오브젝트되고 사용될 수있다. 또한 P3 값은 동일한 커서 번호에 대해 다른 모든 &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; 또는 &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; 와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="translated">&lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx의&lt;/a&gt; op 코드처럼 작동 &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; P1에 커서가 이미 동일한 B- 트리에 열려있는 경우 제 여부를 확인하는 것을 제외하고 있는지이 opcode 무 조작된다 없다. 즉, 커서가 이미 열려 있으면 다시 열지 마십시오.</target>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow의&lt;/a&gt; op 코드는 중지 할 바이트 코드 엔진 및 대응 발생 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 리턴 문안 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW를&lt;/a&gt; . &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; 를 호출하기 전에 바이트 코드 프로그램은 쿼리의 단일 행에 대한 결과를 일련의 레지스터에로드합니다. &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; 와 같은 C 언어 API 는 해당 레지스터에서 쿼리 결과를 추출합니다. 바이트 코드 엔진 은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에 대한 다음 호출 에서 &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; 다음에 다음 명령으로 재개됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 명령은 루프를 초기화 &quot;examp&quot;테이블을 반복하는. 커서 P1을 테이블의 첫 번째 항목으로 되감습니다. 이것은 커서를 사용하여 테이블을 반복하는 Column 및 Next 명령어에 필요합니다. 테이블이 비어 있으면 루프 바로 뒤의 명령 인 P2 (10)로 이동합니다. 테이블이 비어 있지 않으면 루프 본문의 시작 인 6시에 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="translated">&lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; 오피 수행하는 동일한 동작뿐만 아니라, P3 레지스터 점프 항상 수행되는 경우에 정수가 아닌 값을 포함 할 수있다. 이 opcode에는 P3에 항상 정수가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="translated">&lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; op 코드는 레지스터 P1의 정수 값으로 프로그램 카운터의 값을 스왑. 이 opcode는 코 루틴을 구현하는 데 사용됩니다. 코 루틴은 종종 필요에 따라 콘텐츠를 가져 오는 하위 쿼리를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 최적화 이제 생성 할 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스를&lt;/a&gt; 그 적절한 경우.</target>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화는&lt;/a&gt; 수술실 표현 또한 IN 표현으로 변환 된 경우에도 계속 허용됩니다. OR 최적화 사용이 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 출력 에 &lt;a href=&quot;eqp#or-opt&quot;&gt;더 명확하게 표시&lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA의 auto_vacuum는 = 증분&lt;/a&gt; 설정은 이제 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA의 compile_options은&lt;/a&gt; 이제 라이브러리를 생성 컴파일러의 버전 번호를 표시하는 시도를 명령.</target>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보관되어 있다고 가정 하고 pragma는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;ON PRAGMA의 defer_foreign_keys =&lt;/a&gt; 문은 이제 비활성화는 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;활동 제한,&lt;/a&gt; 외부 키에 있습니다.</target>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;프라그가 defer_foreign_keys&lt;/a&gt; 일시적으로 사용할 수에 관계없이 선언하는 방법의 연기에 모든 외래 키 제약 조건을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="be06db32b407171ea5432f85af4fdd64982ffbf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;database encoding&lt;/a&gt; is UTF-8.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;데이터베이스 인코딩은&lt;/a&gt; UTF-8이다.</target>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA의 function_list&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA의 module_list&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA의 pragma_list의&lt;/a&gt; 모든 기본적으로 빌드의 명령은 이제 사용할 수 있습니다. &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS를&lt;/a&gt; 사용하여 비활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; 프라그 마를는의에 디스크 표현에 대한 정보 제공 강화되는 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블을.</target>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check 프라그는&lt;/a&gt; 아웃 오브 오더의 ROWID를 검출하기 위해 강화된다.</target>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode은&lt;/a&gt; OFF, MEMORY, 또는 WAL 아니다</target>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = OFF의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 설정은이 메소드를 호출하기 전에 활성화되고 legacy_alter_table 값은이 방법이 완료 한 후에 복원된다. 새 가상 테이블 이름과 일치하도록 새도우 테이블의 이름을 바꿔야하는 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 사용하는 가상 테이블의 올바른 조작에 필요 합니다. legacy_alter_format이 해제 된 경우 xRename 메소드가 새도우 테이블의 이름을 변경하려고 시도 할 때마다 가상 테이블에 대해 xConnect 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4d57758d0157882a76f0628926b46c59a64bbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; is deactivated. It is now a no-op. In its place, the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is provided. The legacy_file_format pragma is deactivated because (1) it is rarely useful and (2) it is incompatible with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in schemas that have tables with both generated columns and descending indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format의 pragma는&lt;/a&gt; 비활성화됩니다. 이제는 작동하지 않습니다. 대신 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; 옵션 이 제공됩니다. legacy_file_format pragma는 (1) 거의 유용하지 않고 (2) 생성 된 열과 내림차순 인덱스가 모두있는 테이블이있는 스키마의 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 과 호환되지 않기 때문에 비활성화 됩니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count PRAGMA는&lt;/a&gt; 인상 또는 런타임에서이 한계를 절감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA의 mmap_size의&lt;/a&gt; 문에 사용되는 주소 공간의 양이 증가하지 않습니다 I 바이 하드 한계 설정 위 / O 메모리 매핑 &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE의&lt;/a&gt; 컴파일시 옵션도 sqlite3_config (에 2 번째의 인수로 하드 한계 설정 시작 시간 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA을 최적화&lt;/a&gt; 명령은 먼저 SQLite는 3.18.0 (2017년 3월 28일) 도입과 SQLite는 모든 이전 릴리스에 대한 조작은 행해지 지 않았다.</target>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA을 최적화&lt;/a&gt; 명령은 자동으로 필요에 따라 개별 테이블에 ANALYZE 실행됩니다. 권장되는 방법은 응용 프로그램이 각 데이터베이스 연결을 닫기 직전에 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 문 을 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="433dda316207c42123f3ff5f78471afdde0a76ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; is usually a no-op but it will occasionally run ANALYZE if it seems like doing so will be useful to the query planner. The &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma&lt;/a&gt; limits the scope of any ANALYZE command that the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; runs so that it does not consume too many CPU cycles. The constant &quot;400&quot; can be adjusted as needed. Values between 100 and 1000 work well for most applications.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;최적화 pragma는&lt;/a&gt; 보통 어떤 조합입니다 만 쿼리 계획에 도움이 될 것입니다 그렇게 보인다 경우가 가끔 ANALYZE 실행됩니다. &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma는&lt;/a&gt; 어떤의 범위는 것을 명령 ANALYZE 제한 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;최적화 프라그가&lt;/a&gt; 너무 많은 CPU 사이클을 소모 할 수 있도록 실행합니다. 상수 &quot;400&quot;은 필요에 따라 조정할 수 있습니다. 100에서 1000 사이의 값은 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정 OFF 아니다</target>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store의 pragma는&lt;/a&gt; 또한 임시 파일을 저장하는 위치의 결정에 영향을 정수 값을 갖는다. temp_store pragma의 값은 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory 프라그는&lt;/a&gt; 이 변수를 수정에 의한 메모리에 포인트로 발생할 수 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . 또한 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma는&lt;/a&gt; 항상이 변수가 가리키는 문자열이 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 보유되어 있다고 가정 하며 pragma는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free를&lt;/a&gt; 사용하여 해당 메모리를 해제하려고 시도 할 수 있습니다. 따라서이 변수를 직접 수정하는 경우 변수를 NULL로 설정하거나 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리를 가리 키도록 하거나 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma를&lt;/a&gt; 사용 하지 않아야합니다. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma에서&lt;/a&gt; 요청한 경우 제외SQLite는 sqlite3_temp_directory가 가리키는 메모리를 해제하지 않습니다. 응용 프로그램이 해당 메모리를 비우기를 원하면 모든 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트가 소멸 된 후에 만 처리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; 프라그 마를 올바르게 결과 집합에서 자신의 열 이름을 설정</target>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그는&lt;/a&gt; SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA의 wal_checkpoint의&lt;/a&gt; 명령은 SQL에서이 인터페이스를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA의 writable_schema은 ON =&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; 인터페이스, 삽입, 업데이트 또는 삭제되는 행의 열 수를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; preupdate 콜백이 직접 삽입, 업데이트 또는 삭제 작업의 결과로 호출 된 경우 인터페이스를 반환 0; 또는 최상위 트리거에 의해 호출 된 삽입, 업데이트 또는 삭제의 경우 1; 또는 최상위 트리거에 의해 호출 된 트리거로 인한 변경에 대해서는 2; 기타 등등.</target>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 전에 각 호출되는 콜백 함수를 등록 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 데이터베이스 테이블에 동작. 단일 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 한 번에 최대 하나의 사전 업데이트 후크를 등록 할 수 있습니다 . &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()에 대한&lt;/a&gt; 각 호출 은 이전 설정보다 우선합니다. 사전 갱신 후크는 두 번째 매개 변수로 NULL 포인터를 사용하여 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 을 호출하여 사용 불가능합니다 . &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 의 세 번째 매개 변수는 콜백에 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트 된 후 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_INSERT 및 SQLITE_UPDATE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_DELETE 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new ()는&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; 및 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; 인터페이스는 preupdate 이벤트에 관한 추가 정보를 제공한다. 이 루틴은 사전 업데이트 콜백 내에서만 호출 할 수 있습니다. 사전 갱신 콜백 외부에서 또는 사전 갱신 콜백에 제공된 것과 다른 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터를 사용하여 이러한 루틴을 호출하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">&lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; P 인터페이스에 기록하는 포인터 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 가 업데이트되기 전에 테이블 행의 N 번째 컬럼의 값을 포함한다. N 매개 변수는 0-1의 열 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다. 이것은 SQLITE_UPDATE 및 SQLITE_DELETE 사전 갱신 콜백 내에서만 사용해야합니다. SQLITE_INSERT 콜백에서 사용하는 경우 동작이 정의되지 않습니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value은&lt;/a&gt; P 점은 때 preupdate 콜백 수익을 파괴한다하는 것을.</target>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;쿼리 계획 체크리스트는&lt;/a&gt; 애플리케이션 개발자가 해결하는 데 도움이 쿼리 계획 문제를 다음해야하는 단계에 대해 설명합니다. INDEXED BY를 사용하는 것은 최후의 수단이며 다른 모든 측정이 실패한 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; 읽기가 이전 스냅 샷에 있기 때문에 읽기 트랜잭션이 쓰기 트랜잭션으로 업그레이드 할 수없는 경우 확장 오류 코드는 WAL 모드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 임의의 값이 변경되지 않는 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 온 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 인터페이스는 재설정 &lt;a href=&quot;stmt&quot;&gt;준비된 문은&lt;/a&gt; 그 프로그램의 시작 부분에 다시 S.</target>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-트리 확장은&lt;/a&gt; 또 다른 준비된 문이 적극적으로 R-트리를 읽는 동안 시도는 R-트리를 업데이트되어이 결과 코드를 반환합니다. R-Tree를 변경하면 노드의 전환 및 재조정이 필요할 수 있으며, 이로 인해 읽기 커서가 중단되어 일부 행이 반복되고 다른 행이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b6d7c356a19c81f66c0c808b762014df51dab6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; supports shared-cache read and write locks in the same way as all other database tables (see description above). The following special rules also apply:</source>
          <target state="translated">&lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블&lt;/a&gt; 다른 모든 데이터베이스 테이블과 동일한 방법으로 공유 캐시 읽기 지원 및 쓰기 잠금 (위 설명 참조). 다음 특수 규칙도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; API를 작성하고 변경 집합의 내용을 반복하는 반복자를 초기화하기 위해 호출됩니다. 처음에는 반복자가 요소가 없음을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;권한 부여 콜백 기능&lt;/a&gt; 중 하나를 반환해야 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 작업이 허용되는지 여부를 SQLite는 신호하기 위해 또는이 두 상수 중 하나를. 추가 정보 는 &lt;a href=&quot;set_authorizer&quot;&gt;권한 부 여자 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">&lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스는 특정 SQL 문 작업 권한을 부여하기 위해 호출되는 콜백 함수를 등록합니다. 콜백의 두 번째 매개 변수는 권한이 부여되는 조치를 지정하는 정수 코드입니다. 이것은 권한 부 여자 콜백이 전달 될 수있는 정수 조치 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 에 성공적으로 호출에서 반환 된 개체 &lt;a href=&quot;snapshot_get&quot;&gt;() sqlite3_snapshot_get를&lt;/a&gt; 사용하여 해제해야 &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free을 ()&lt;/a&gt; 메모리 누수를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">&lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; 인터페이스 파괴한다 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P.이 응용 프로그램은 결국 모든 해제해야합니다 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 메모리 누수를 방지하기 위해이 루틴을 사용하여 객체를.</target>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; 인터페이스 시도는 새로운 만들 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot의&lt;/a&gt; 기록 데이터베이스 연결 D.에 성공의 스키마 S의 현재 상태는 것을 객체를 &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get는 (D, S는 P)&lt;/a&gt; 인터페이스가 새로 생성에 대한 포인터를 기록 &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 오브젝트를 * P로 가져오고 SQLITE_OK를 리턴합니다. 이 함수가 호출 될 때 스키마 S에 읽기 트랜잭션이 아직 열려 있지 않은 경우 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 때 인터페이스에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 인터페이스 중 하나는 새로운 읽기 트랜잭션을 시작 또는 스키마 S에 대한 기존의 것을 업그레이드 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 읽기 트랜잭션이 역사를 의미하도록 D &lt;a href=&quot;snapshot&quot;&gt;스냅 샷&lt;/a&gt; 이 아니라 데이터베이스에 대한 가장 최근의 변화보다, P. &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스 반환 성공 또는 적절한에 SQLITE_OK &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1의&lt;/a&gt; 확장은 선택적으로 각 INSERT에 대한 ROWID를 지정할 수있는 응용 프로그램을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="translated">&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3 ()&lt;/a&gt; 편집 거리 함수는 가상 테이블의 &quot;명령어&quot;칼럼에 적합한 문자열을 삽입함으로써 선택 또는 실행 시간에 해제 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="translated">&lt;a href=&quot;sqlar&quot;&gt;SQLite는 아카이브&lt;/a&gt; SQLite는이 ZIP 아카이브 또는 TAR 파일에 대한 대용으로 사용할 수있는 방법을 생각 보여줍니다. SQLite에 저장된 파일의 아카이브는 동등한 ZIP 아카이브보다 매우 약간 크며 경우에 따라 실제로는 더 작습니다. 또한 SQLite 아카이브에는 증분 및 원자 업데이트가 있으며 훨씬 더 풍부한 메타 데이터를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 호출에서 포인터 D &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt (D, S)는&lt;/a&gt; 개방형 데이터베이스 연결과 NULL 포인터하지 특히 필요 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; 방법은 N의 단부에 문자열 S 바이트로부터 정확하게 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; X. N은 음이 아닌 있어야 개체. S는 0이 아닌 0 바이트 이상의 콘텐츠를 포함해야합니다. 0으로 끝나는 문자열을 전체적으로 추가하려면 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; 메서드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall는 (X, S)의&lt;/a&gt; 방법은 결국 제로로 끝나는 문자열 S의 전체 콘텐츠를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar은 (X는 N, C)&lt;/a&gt; 방법의 마지막에 1 바이트 문자 C의 N 카피를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 공백 압입 부가, 예를 들면이 방법은 사용할 수있는 객체 X..</target>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; 과 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; 인터페이스가 사용 &lt;a href=&quot;../printf&quot;&gt;내장의 printf&lt;/a&gt; SQLite는 기능성의 단부 상 형식의 텍스트를 추가 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트 X.</target>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">&lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; 에있어서 내부 공사중 문자열 리셋 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 길이는 0 바이트로 오브젝트 X의 뒷면.</target>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 방법 공사중 동적 문자열 바이트 현재 길이를 반환 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 의해 리턴 된 길이 오브젝트 X. &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)가&lt;/a&gt; 제로 종료 바이트를 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; 메소드에 의해 리턴 된 값 X. 공사중 동적 캐릭터의 현재 콘텐츠에 대한 포인터를 리턴 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; sqlite3_str 오브젝트 X에 의해 관리되고, 동일한에 후속 법에 의해 해제되거나 변경 될 수도 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체. 응용 프로그램은 동일한 오브젝트에서 후속 메소드 호출 후 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)가&lt;/a&gt; 리턴 한 포인터를 사용해서는 안됩니다 . 응용 프로그램은 0에서 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; 범위를 벗어난 바이트에 쓰지 않고 후속 sqlite3_str 메소드 호출 후 바이트를 읽거나 쓰지 않는 한 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)에&lt;/a&gt; 의해 반환되는 문자열의 내용을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 인터페이스 sqlite3_str 오브젝트 X 되돌아로부터 획득 된 버퍼 메모리에 대한 포인터 파괴 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 구축 된 스트링을 포함한다. 호출 애플리케이션은 메모리 누수를 피하기 위해 리턴 된 값을 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 로 전달해야합니다. &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 오류가 캐릭터 라인의 건설 중 발생 된 경우 인터페이스는 NULL 포인터를 반환 할 수 있습니다. &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 의 문자열 경우 인터페이스도 NULL 포인터를 반환합니다 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 X가 0 바이트 길이입니다.</target>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스에 할당하고 새로운 초기화 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; 개체. 메모리 누수를 방지하려면 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에 대한 후속 호출을 통해 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()에서&lt;/a&gt; 반환 한 객체를 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 인터페이스는 항상 유효한에 대한 포인터를 반환 &lt;a href=&quot;str&quot;&gt;sqlite3_str의&lt;/a&gt; 메모리 부족 오류의 경우에 반환 된 객체가 새 텍스트를 거부 자동으로하는 특별한 싱글이 될 수도 있지만, 객체를 항상에서 SQLITE_NOMEM을 반환 &lt;a href=&quot;str_errcode&quot;&gt;) (sqlite3_str_errcode &lt;/a&gt;&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length ()에&lt;/a&gt; 대해 항상 0을 반환하고 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; 에서 항상 NULL을 반환합니다 . &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 의해 리턴 된 값을 sqlite3_str 매개 변수로 다른 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 메소드 에 사용하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 인터페이스를 반환하는 경우에만 문자열 X가 일치하면 제로 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 패턴 P.의 정의 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;strglob&quot;&gt;(P, X) sqlite3_strglob를&lt;/a&gt; 에서 &quot;X GLOB P&quot;연산자와 동일 SQLite는 SQL 언어를 이해합니다. &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; 함수는 대소 문자를 구분한다.</target>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; API는 식별자를 비교할 때 SQLite는 내부에서 사용하는 &quot;경우 독립&quot;의 정의와 동일하여, 애플리케이션 및 확장이 경우 독립적 방식으로 UTF-8 스트링을 포함하는 두 버퍼의 내용과 비교하도록 허용한다.</target>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; ASCII 문자 만이 경우 접힌 비록 기능은 유니 코드 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 인터페이스에 리턴하고 문자열 X가 일치하는 경우에만 0 일 경우 &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE의&lt;/a&gt; 제어 문자 E.의 정의 패턴 P &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE 용&lt;/a&gt; 에 사용되는 패턴 매칭 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike를 (P는, X, E)이&lt;/a&gt; 와 동일 SQLite에서 이해하는 SQL 언어의 &quot;X LIKE P ESCAPE E&quot;연산자 ESCAPE 절이없는 &quot;X LIKE P&quot;의 경우 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 의 E 매개 변수 를 0으로 설정하십시오. LIKE 연산자와 마찬가지로 &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; 함수는 대소 문자를 구분하지 않습니다. 소문자 ASCII 문자는 서로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 를 사용하는 개선 된 &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;비 - 순환 엔진 (NRE)&lt;/a&gt; 이후 TCL 8.6에 링크시 TCL 인터프리터 인터페이스.</target>
        </trans-unit>
        <trans-unit id="23310616ad13ff4bf64157f6f266be2fa9a80e64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer also does an excellent job of verifying that SQLite responds sanely to malformed database files.</source>
          <target state="translated">&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz의&lt;/a&gt; fuzzer는 SQLite는 조작 된 데이터베이스 파일을 올바로 수행 응답하는지 확인하는 훌륭한 일을한다.</target>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="translated">&lt;a href=&quot;testing#slt&quot;&gt;SQL 로직 테스트는&lt;/a&gt; SQLite는 다른 SQL 데이터베이스 엔진과 동일한 동작 것을 보여주기 위해 디자인 된 테스트 케이스의 집합입니다. 이러한 테스트는 별도의 코드 공용 저장소에서 호스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="translated">&lt;a href=&quot;th3&quot;&gt;테스트 장치 # 3&lt;/a&gt; 또는 &lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt; 테스트 세트는 그대로 전달되는 구성에서 100 % MC / DC에 SQLite는 실험에 사용 된 테스트 케이스 전용 세트이다. TH3 소스는 다른 SQLite 리포지토리와 동일한 서버에서 제공되지만 독점적 인 점에서 다른 서버와 다릅니다. TH3 코드는 SQLite 개발자 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; 인터페이스는 다른 데이터베이스 연결에 의해 변경이 무시되고 데이터베이스 연결 D.에 대해 SQL 문 실행으로 인해 변경된 것을 행의 수를보고합니다. 다른 데이터베이스 연결에서 데이터베이스 파일에 대한 변경을 감지하려면 &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; 명령 또는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;파일 제어를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f49c08b6ed161fe2560890c885dd50855619ba24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; extension is automatically loaded</source>
          <target state="translated">&lt;a href=&quot;uintcseq&quot;&gt;UINT의 배열 순서의&lt;/a&gt; 확장은 자동으로로드됩니다</target>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;versionnumbers&quot;&gt;버전 번호 지정 규칙&lt;/a&gt; 은 새로운 &lt;a href=&quot;http://semver.org/&quot;&gt;버전&lt;/a&gt; 의 시맨틱 버전 지정 을 사용하도록 개정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="translated">&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; SQLite는 용 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16)는 새로운 장치라는 특성이 추가 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE를&lt;/a&gt; . 이 특성을보고하는 데이터베이스 파일은 전원 안전 덮어 쓰기 속성이있는 스토리지 시스템에 상주한다고 가정합니다. 기본 UNIX와 Windows &lt;a href=&quot;vfs&quot;&gt;VFSes는&lt;/a&gt; 지금보고 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE를&lt;/a&gt; SQLite는 함께 컴파일 된 경우 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 1&lt;/a&gt; 하거나 컴파일하면 저장이 powersafe 덮어 쓰기 속성을 가지고 있지 않는 레거시 가정 할 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 0&lt;/a&gt; . 현재로서는 기본적으로 전원 안전 덮어 쓰기가 켜져 있지만 나중에 다시 방문하여 기본값을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex의&lt;/a&gt; 숨은 열에 대하여 평등 제약 표 확인의 구현 방법 및 생성하는 정수 &quot;값&quot;출력의 범위를 결정하기 위해 입력 파라미터 들로서 이들을 사용한다. 제한되지 않은 열에는 합리적인 기본값이 사용됩니다. 예를 들어, 5에서 50 사이의 모든 정수를 나열하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex 번째 항목이됩니다. aConstraintUsage []. omit가 true 인 경우 제한 조건은 가상 테이블에서 완전히 처리 된 것으로 간주되며 SQLite에서 다시 점검하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8ae1ca39afc04ccf6f18ad86632ba85cedd64de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex에&lt;/a&gt; 있어서 xFilter 전달할 어떤 파라미터에 대한 정보 aConstraintUsage []를 작성한다. argvIndex&amp;gt; 0이면 해당 aConstraint []의 오른쪽이 평가되고 argv에서 argvIndex-th 항목이됩니다. aConstraintUsage []. omit이 참이면 제약 조건은 가상 테이블에서 완전히 처리되는 것으로 간주되며 바이트 코드에서 다시 검사하지 않을 수 있습니다. aConstraintUsage []. omit 플래그는 최적화 힌트입니다. 생략 플래그가 기본 설정 인 false로 남아 있으면 제약 조건은 항상 바이트 코드에서 별도로 검사됩니다. 생략 플래그가 참으로 변경되면 제약 조건이 바이트 코드에서 확인되거나 확인되지 않을 수 있습니다. 즉, 생략 플래그가 참이면 제약 조건이 바이트 코드를 사용하여 다시 검사되지 않는다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드는 이 인터페이스를 호출하여 구현 하는 가상 테이블 의 형식 (열의 이름 및 데이터 유형)을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="translated">&lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect의&lt;/a&gt; 가상 테이블을 사용하는 데이터베이스에 접속이 폐쇄 될 때마다 메소드가 호출된다. xDestroy 메소드는 가상 테이블에 대해 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문이 실행될 때만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xupdate&quot;&gt;을 XUpdate의&lt;/a&gt; 방법은 원래 가지고 주위에 디자인 된 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 하나의 값으로한다. &lt;a href=&quot;vtab#xupdate&quot;&gt;에서 XUpdate&lt;/a&gt; 방법은 ROWID 대신 임의 PRIMARY KEY를 수용하도록 확장되어 있지만 PRIMARY KEY는 여전히 단지 하나의 열을해야한다. 이러한 이유로 SQLite는 둘 이상의 PRIMARY KEY 열과 NULL이 아닌 xUpdate 메소드가있는 WITHOUT ROWID 가상 테이블을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="translated">&lt;a href=&quot;wal#advantages&quot;&gt;WAL 모드&lt;/a&gt; 의 두 번째 장점은 기록기가 판독기를 차단하지 않으며 기록기가 차단하지 않도록하는 것입니다. 이것은 &lt;u&gt;대부분&lt;/u&gt; 사실입니다. 그러나 WAL 모드 데이터베이스에 대한 쿼리가 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 리턴 할 수있는 모호한 경우가 있으므로 해당 상황에 맞게 애플리케이션을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint (D, N)의&lt;/a&gt; 래퍼입니다 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 에 데이터베이스를 야기 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 자동으로 D &lt;a href=&quot;../wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; N 이상의 프레임이에있는 경우 트랜잭션을 커밋 한 후 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 파일. nFrame 매개 변수로 0 또는 음수 값을 전달하면 자동 검사 점이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 함수 WAL 모드에서 데이터베이스로 커밋 될 때마다 데이터를 호출 콜백을 등록하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="translated">&lt;a href=&quot;walformat#locks&quot;&gt;WAL 모드 자물쇠는&lt;/a&gt; 상술되어있다.</target>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">&lt;a href=&quot;walformat#shm&quot;&gt;월마트 지수는&lt;/a&gt; 견고 mmap 된되는 일반 파일을 사용하여 구현됩니다. WAL 모드의 초기 (시험판) 구현에서는 wal-index를 휘발성 공유 메모리에 저장했습니다 (예 : Linux의 경우 / dev / shm에 작성된 파일 또는 다른 유닉스 시스템의 / tmp). 이 접근 방식의 문제점은 다른 루트 디렉토리가있는 프로세스 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt; 를 통해 변경됨)입니다.)에 따라 파일이 달라 지므로 공유 메모리 영역이 달라져 데이터베이스가 손상 될 수 있습니다. 이름없는 공유 메모리 블록을 만드는 다른 방법은 다양한 종류의 유닉스에서 이식 할 수 없습니다. 그리고 우리는 창에서 이름없는 공유 메모리 블록을 만드는 방법을 찾지 못했습니다. 동일한 데이터베이스 파일에 액세스하는 모든 프로세스가 동일한 공유 메모리를 사용하도록 보장하는 유일한 방법은 데이터베이스 자체와 동일한 디렉토리에 파일을 mmapping하여 공유 메모리를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="translated">&lt;a href=&quot;whentouse#website&quot;&gt;SQLite&lt;/a&gt; 의 적절한 사용 페이지에 따르면 SQLite 웹 사이트의 동적 페이지는 일반적으로 각각 약 200 개의 SQL 문을 수행합니다. 이것은 독자들의 비판을 불러 일으켰습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;ZipFile를 가상 테이블을&lt;/a&gt; 읽고 쓸 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCL 테스트는&lt;/b&gt; SQLite는 대한 테스트의 가장 오래된 집합입니다. 그것들은 SQLite 코어와 동일한 소스 트리에 포함되며 SQLite 코어가 공개 도메인에있는 것처럼. TCL 테스트는 개발 중에 사용되는 기본 테스트입니다. TCL 테스트는 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL 스크립팅 언어를&lt;/a&gt; 사용하여 작성됩니다 . TCL 테스트 하니스 자체는 TCL 인터페이스를 작성하는 데 사용되는 26.9 KSLOC의 C 코드로 구성됩니다. 테스트 스크립트는 총 20.5MB 크기의 1264 파일에 포함되어 있습니다. 44792 개의 개별 테스트 사례가 있지만 전체 테스트 실행에서 수백만 개의 개별 테스트가 수행되도록 많은 테스트 사례가 매개 변수화되고 다른 매개 변수와 함께 여러 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec2f6c6133a8488b1cdbdaeca80a7abf2b8d280" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 27.0 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1272 files totaling 21.1MB in size. There are 46363 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">&lt;b id=&quot;tcl&quot;&gt;TCL 테스트는&lt;/b&gt; SQLite는 대한 테스트의 가장 오래된 집합입니다. SQLite 코어와 동일한 소스 트리에 포함되어 있으며 SQLite 코어와 마찬가지로 공용 도메인에 있습니다. TCL 테스트는 개발 중에 사용되는 기본 테스트입니다. TCL 테스트는 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL 스크립팅 언어를&lt;/a&gt; 사용하여 작성됩니다 . TCL 테스트 하네스 자체는 TCL 인터페이스를 생성하는 데 사용되는 27.0 KSLOC의 C 코드로 구성됩니다. 테스트 스크립트는 총 21.1MB 크기의 1272 개 파일에 포함되어 있습니다. 46363 개의 개별 테스트 케이스가 있지만 많은 테스트 케이스가 매개 변수화되고 여러 번 (다른 매개 변수 사용) 실행되므로 전체 테스트에서 수백만 개의 개별 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt;&lt;/b&gt; 테스트 하니스 100 % 분기 시험 범위 (C 및 제공에 기입 전용 테스트 세트 인 &lt;a href=&quot;testing#mcdc&quot;&gt;100 % MC / DC 시험에 따르면&lt;/a&gt; , 코어 SQLite는 라이브러리 참조). TH3 테스트는 TCL 또는 기타 워크 스테이션 서비스를 쉽게 지원하지 않는 임베디드 및 특수 플랫폼에서 실행되도록 설계되었습니다. TH3 테스트는 게시 된 SQLite 인터페이스 만 사용합니다. TH3은 44753 개의 개별 테스트 사례를 구현하는 약 69.4MB 또는 948.1 KSLOC의 C 코드로 구성됩니다. TH3 테스트는 매개 변수가 많으므로 전체 범위 테스트는 약 170 만 개의 다른 테스트 인스턴스에서 실행됩니다. 100 % 분기 테스트 적용 범위를 제공하는 사례는 총 TH3 테스트 스위트의 하위 세트를 구성합니다. 릴리스 전의 담금 테스트는 수억 개의 테스트를 수행합니다. TH3에 대한 추가 정보는 &lt;a href=&quot;th3&quot;&gt;별도로 제공됩니다&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6d35eb6cfeae174de2bae520fa16645d47318a8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 71.5 MB or 978.3 KSLOC of C code implementing 46622 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.9 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3의&lt;/a&gt;&lt;/b&gt; 테스트 하니스 100 % 분기 시험 범위 (C 및 제공에 기입 전용 테스트 세트 인 &lt;a href=&quot;testing#mcdc&quot;&gt;100 % MC / DC 시험에 따르면&lt;/a&gt; , 코어 SQLite는 라이브러리 참조). TH3 테스트는 TCL 또는 기타 워크 스테이션 서비스를 쉽게 지원하지 않는 임베디드 및 특수 플랫폼에서 실행되도록 설계되었습니다. TH3 테스트는 게시 된 SQLite 인터페이스 만 사용합니다. TH3는 46622 개의 개별 테스트 케이스를 구현하는 약 71.5MB 또는 978.3 KSLOC의 C 코드로 구성됩니다. 그러나 TH3 테스트는 크게 매개 변수화되어 있으므로 전체 범위 테스트는 약 190 만 개의 서로 다른 테스트 인스턴스를 실행합니다. 100 % 분기 테스트 커버리지를 제공하는 케이스는 전체 TH3 테스트 스위트의 하위 집합을 구성합니다. 출시 전에 담그는 테스트는 수억 번의 테스트를 수행합니다. TH3에 대한 추가 정보는 &lt;a href=&quot;th3&quot;&gt;별도로 제공됩니다.&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="translated">캐시 된 페이지 의 &lt;b&gt;&lt;i&gt;페이지 번호&lt;/i&gt;&lt;/b&gt; 입니다. 페이지는 1 페이지부터 시작하여 데이터베이스 파일 내에서 순차적으로 번호가 매겨집니다 (1 페이지는 바이트 오프셋 0에서 시작). 인용하다</target>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; 컴파일 시간 플래그를 더 이상 작동합니다. I / O 절차는 이제 항상 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="translated">ASCII 코드 포인트 범위 (0-127) 이외의 모든 문자를 토큰 문자로 취급한다고 가정 하는 &lt;b&gt;ASCII&lt;/b&gt; 토큰 화 프로그램.</target>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="translated">&lt;b&gt;원자 쓰기&lt;/b&gt; 속성입니다. 이 속성을 지원하는 시스템은 또한 쓸 수있는 블록의 크기를 지정합니다. 유효한 크기는 512보다 큰 2의 거듭 제곱입니다. 쓰기 작업이 블록을 수정하는 경우</target>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="translated">&lt;b&gt;캐시 된 데이터&lt;/b&gt; ; 많은 데이터</target>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="translated">&lt;b&gt;이니셜 체크섬&lt;/b&gt; 필드는 의사 - 랜덤 값으로 설정된다. 모두에 대한 체크섬을 계산하는 알고리즘의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="translated">&lt;b&gt;체크섬&lt;/b&gt; 필드는 4 바이트 빅 엔디안 부호있는 정수로 저장 체크섬 값이 포함되어 있습니다. 체크섬 값은 다음을 구성하는 바이트의 합계로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="translated">&lt;b&gt;아이 키&lt;/b&gt; 은 참조 절을 보유하고있는 열 또는 외래 키 제약 조건에 의해 제약되고 자식 테이블의 열 집합입니다.</target>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="translated">&lt;b&gt;자식 테이블은&lt;/b&gt; 외래 키 제약 조건이 적용되는 것을 테이블과 참조 절을 포함하는 테이블입니다. 이 섹션의 예는</target>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;열 =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="translated">&lt;b&gt;데이터 =&lt;/b&gt; 인수 지정이</target>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="translated">&lt;b&gt;dbhash bsdhash.hashopen에&lt;/b&gt; (또는 &lt;b&gt;dbhash.exe&lt;/b&gt; 유틸리티 Windows에서)는 SQLite 데이터베이스의 스키마 및 콘텐츠의 SHA1 해시를 계산하는 명령 줄 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="translated">&lt;b&gt;dbstat와&lt;/b&gt; 가상 테이블 모두 볼 수 있습니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; SQLite는이 사용하여 구축 될 때 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB의&lt;/a&gt; 컴파일시 옵션을 선택합니다. dbstat 가상 테이블은 데이터베이스 파일의 btree 및 overflow 페이지에 대한 저수준 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="translated">&lt;b&gt;파일 이름은 =&lt;/b&gt; 인수는 CSV의 콘텐츠를 읽을 외부 파일을 지정합니다. 모든 CSV 가상 테이블에는 &lt;b&gt;filename =&lt;/b&gt; 인수 또는 &lt;b&gt;data =&lt;/b&gt; 인수 중 하나만 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="translated">&lt;b&gt;저널 마법&lt;/b&gt; 필드는 항상 SQLite는 저널 파일을 식별하는 데 사용되는 잘 알려진 8 바이트 문자열 값을 포함합니다. 잘 알려진 바이트 값 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2e5b0d62ca7f429d717982cbc08462058d705f1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1의&lt;/b&gt; 확장은입니다 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 을 구현하는 다섯 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 와 두 개의 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 관리를위한 유용한 &lt;a href=&quot;http://json.org/&quot;&gt;JSON의&lt;/a&gt; SQLite는 데이터베이스에 저장된 컨텐츠를. 13 개의 스칼라 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">&lt;b&gt;json1의&lt;/b&gt; 확장은입니다 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 을 구현하는 다섯 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 와 두 개의 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 관리를위한 유용한 &lt;a href=&quot;http://json.org/&quot;&gt;JSON의&lt;/a&gt; SQLite는 데이터베이스에 저장된 컨텐츠를. 13 개의 스칼라 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="translated">&lt;b&gt;마스터 저널 이름&lt;/b&gt; 필드는 UTF-8 문자열로 인코딩 된 마스터 저널 파일의 이름을 포함합니다. 문자열에 추가 된 널 종결자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="translated">&lt;b&gt;이름 길이&lt;/b&gt; 필드는 4 바이트 빅 엔디안 부호없는 정수로 포맷 바이트 이전 필드의 길이를 포함한다.</target>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="translated">&lt;b&gt;페이지 크기&lt;/b&gt; 필드는 해당 사용하는 데이터베이스 페이지 크기를 포함</target>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;상위 키&lt;/b&gt; 외래 키 제약이 참조하는 상위 테이블의 열 또는 열 세트이다. 일반적으로 부모 테이블의 기본 키는 아니지만 항상 그런 것은 아닙니다. 부모 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid가&lt;/a&gt; 아닌 부모 테이블의 명명 된 열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="translated">&lt;b&gt;부모 테이블은&lt;/b&gt; 외래 키 제약 조건에 참조하는 테이블입니다. 이 섹션의 예제에서 상위 테이블은</target>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;포터&lt;/b&gt; 구현 토크 나이, &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;포터 형태소 분석 알고리즘을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="translated">&lt;b&gt;안전 APPEND의&lt;/b&gt; 속성입니다. 시스템이</target>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="translated">&lt;b&gt;스키마 =&lt;/b&gt; 인수는이 지정 &lt;a href=&quot;lang_createtable&quot;&gt;표 CREATE&lt;/a&gt; csv로 가상 테이블이에 전달하는 문을 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 가상 테이블의 C 럼 이름을 정의하기 위해 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="translated">&lt;b&gt;순차 쓰기&lt;/b&gt; 속성입니다. 를 지원하는 시스템</target>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="translated">&lt;b&gt;sqlite3를&lt;/b&gt; 다음과 같이 명령을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="translated">&lt;b&gt;sqlite3를&lt;/b&gt; 명령은 두 번째 인수에 지정된 데이터베이스를 엽니 다. 데이터베이스가 아직없는 경우 기본 동작은 자동으로 작성되는 것입니다 ( &quot; &lt;b&gt;-create false&lt;/b&gt; &quot;옵션 을 사용하여이를 변경할 수 있음 ). &lt;b&gt;sqlite3를의&lt;/b&gt; 명령은 항상 데이터베이스를 제어 할 수있는 새로운 Tcl의 명령을 생성합니다. 새 Tcl 명령의 이름은 첫 번째 인수로 제공됩니다. 이 방법은 Tk에서 위젯이 작성되는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="translated">&lt;b&gt;sqlite가&lt;/b&gt; 명령 줄 유틸리티를 사용 &lt;b&gt;sqlite_complete&lt;/b&gt; 가 전화를해야 할 때 알고 기능을 &lt;b&gt;sqlite_exec&lt;/b&gt; . 각 입력 행이 수신 된 후 &lt;b&gt;sqlite&lt;/b&gt; 는 버퍼의 모든 입력에서 &lt;b&gt;sqlite_complete&lt;/b&gt; 를 호출 합니다. 경우 &lt;b&gt;sqlite_complete&lt;/b&gt; true를 반환하고 &lt;b&gt;sqlite_exec&lt;/b&gt; 전화를 입력 버퍼를 리셋한다. 경우 &lt;b&gt;sqlite_complete&lt;/b&gt; 반환 거짓, 다음 프롬프트가 계속 프롬프트로 변경되고 텍스트의 또 다른 라인을 읽고 입력 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="translated">&lt;b&gt;sqlite_busy_handler의&lt;/b&gt; 절차는 오픈 SQLite 데이터베이스 바쁜 콜백을 등록 할 수 있습니다. SQLite가 잠긴 데이터베이스에 액세스하려고 할 때마다 통화 중 콜백이 호출됩니다. 콜백은 일반적으로 잠금을 해제 할 기회를주기 위해 다른 유용한 작업 또는 절전 모드를 수행합니다. 콜백이 0이 아닌 값을 리턴하면 SQLite는 데이터베이스 액세스를 다시 시도하고주기가 반복됩니다. 콜백이 0을 반환하면 SQLite는 현재 작업을 중단하고 SQLITE_BUSY를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="translated">&lt;b&gt;sqlite_changes의&lt;/b&gt; API 함수는 데이터베이스가 마지막으로 대기가 된 이후, 삽입, 삭제 또는 수정 된 행의 수를 반환합니다. &quot;정지&quot;데이터베이스는 &lt;b&gt;sqlite_exec에&lt;/b&gt; 대한 미해결 호출이없고 &lt;b&gt;sqlite_finalize에&lt;/b&gt; 의해 &lt;b&gt;종료&lt;/b&gt; 되지 않은 &lt;b&gt;sqlite_compile&lt;/b&gt; 에 의해 생성 된 VM 이없는 &lt;b&gt;데이터베이스&lt;/b&gt; 입니다. 일반적인 사용에서, &lt;b&gt;sqlite_changes의&lt;/b&gt; 반환 삽입 된 행의 수, 삭제, 또는 가장 최근에 의해 수정 &lt;b&gt;sqlite_exec&lt;/b&gt; 전화 또는 가장 최근의 이후 &lt;b&gt;sqlite_compile&lt;/b&gt; . 그러나 &lt;b&gt;sqlite_exec에&lt;/b&gt; 대한 중첩 호출이있는 경우 (즉, 한 &lt;b&gt;sqlite_exec&lt;/b&gt; 의 콜백 루틴이 다른 호출을 호출하는 경우)&lt;b&gt;sqlite_exec&lt;/b&gt; ) 또는 &lt;b&gt;sqlite_compile&lt;/b&gt; 을 호출 하여 여전히 다른 VM이있는 동안 새 VM을 만들면 &lt;b&gt;sqlite_changes&lt;/b&gt; 가 반환하는 숫자의 의미 가 더 복잡합니다. 보고 된 수에는 나중에 ROLLBACK 또는 ABORT에 의해 취소 된 변경 사항이 포함됩니다. 그러나 DROP TABLE로 인해 삭제 된 행은 계산 &lt;em&gt;되지&lt;/em&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt; &quot;컴파일&quot;(두 번째 매개 변수에 의해 지정된) 단일 SQL 문 및 그 문을 실행할 수있는 가상 머신을 생성합니다. 인터페이스 루틴과 마찬가지로 첫 번째 매개 변수는 &lt;b&gt;sqlite_open에&lt;/b&gt; 대한 이전 호출에서 얻은 sqlite 구조에 대한 포인터 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="translated">&lt;b&gt;sqlite_create_function ()&lt;/b&gt; 인터페이스는 일반 기능과 생성하는 데 사용됩니다 &lt;b&gt;() sqlite_create_aggregate를&lt;/b&gt; 새로운 집계 함수를 만드는 데 사용됩니다. 두 경우 모두 &lt;b&gt;db&lt;/b&gt; 매개 변수는 함수를 등록해야하는 공개 SQLite 데이터베이스이고, &lt;b&gt;zName&lt;/b&gt; 은 새 함수의 이름이고, &lt;b&gt;nArg&lt;/b&gt; 는 인수 수이며, &lt;b&gt;pUserData&lt;/b&gt; 는 C 구현으로 변경되지 않은 채 전달되는 포인터입니다. 기능의. 두 루틴 모두 성공하면 0을 리턴하고 오류가 있으면 0이 아닌 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 기능은 프로세스 SQL 문 및 쿼리하는 데 사용됩니다. 이 기능에는 다음과 같은 5 개의 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 기능은 일반적으로 SQLITE_OK를 반환합니다. 그러나 무언가 잘못되면 오류 유형을 나타내는 다른 값을 반환 할 수 있습니다. 다음은 리턴 코드의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="translated">&lt;b&gt;sqlite_exec&lt;/b&gt; 사용 위에서 설명한 루틴은 SQLite 데이터베이스에서 데이터를 검색 할 수있는 유일한 방법이 될 수 있습니다. 그러나 많은 프로그래머들은 콜백 함수를 사용하여 결과를 얻는 것이 불편하다는 것을 알았습니다. 따라서 SQLite 버전 2.7.7부터 콜백을 사용하지 않는 두 번째 액세스 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="translated">&lt;b&gt;sqlite_finalize의&lt;/b&gt; 루틴은 또한 가상 머신이 수행하는 SQL 작업의 성공 또는 실패를 나타내는 결과 코드를 반환합니다. 같은 SQL에 의해 실행되었다 반환 된 것처럼 sqlite_finalize (에 의해 반환되는 값) 동일합니다 &lt;b&gt;sqlite_exec&lt;/b&gt; . 반환 된 오류 메시지도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table ()&lt;/b&gt; 함수는 이제 그것을 컬럼의 다른 번호를 돌려 두 개 이상의에 select를 줄 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 함수 래퍼이다 &lt;b&gt;sqlite_exec&lt;/b&gt; 수집하는 모든 연속 콜백의 정보와의 malloc에 의한 메모리 ()에 그것을 기록하는. 응용 프로그램이 단일 함수 호출로 데이터베이스 쿼리의 전체 결과를 가져올 수있는 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 돌아 간다와 같은 정수 결과 코드 &lt;b&gt;sqlite_exec&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="translated">&lt;b&gt;sqlite_interrupt&lt;/b&gt; 기능은 첫 번째 기회에서 종료 현재 데이터베이스 작업을 일으키는 다른 스레드 또는 신호 처리기를 호출 할 수 있습니다. 이 경우, 데이터베이스 조작을 시작한 &lt;b&gt;sqlite_exec&lt;/b&gt; 루틴 (또는 동등한 항목)이 SQLITE_INTERRUPT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_mprintf ()&lt;/b&gt; 표준 라이브러리와 같은 일상적인 작업 &lt;b&gt;의 sprintf ()&lt;/b&gt; 는 malloc에에서 얻은 메모리에 그 결과를 기록 ()와 malloc으로 할당 된 버퍼에 대한 포인터를 반환하는 것을 제외하고. &lt;b&gt;sqlite_mprintf ()&lt;/b&gt; 는 위에서 설명한 % q 및 % Q 확장명도 이해합니다. &lt;b&gt;sqlite_vmprintf는 ()&lt;/b&gt; 같은 루틴의 가변 인자 버전입니다. 이러한 루틴이 리턴하는 문자열 포인터는 &lt;b&gt;sqlite_freemem ()&lt;/b&gt; 에 전달하여 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="translated">&lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; 루틴가 SQLite는 데이터베이스와 콜백 루틴을 등록하는 데 사용할 수있는 것은 긴 실행 통화 중 주기적으로 호출 될 &lt;b&gt;sqlite_exec ()&lt;/b&gt; , &lt;b&gt;sqlite_step ()&lt;/b&gt; 및 다양한 래퍼 함수.</target>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="translated">&lt;b&gt;unicode61&lt;/b&gt; 유니 코드 6.1 표준을 기반으로 토큰 화. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; 및 &lt;code&gt;-wal&lt;/code&gt; 파일이 이미 존재하고 읽을 수</target>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="translated">&lt;code&gt;sqldiff.exe&lt;/code&gt; 바이너리는 명령 줄 유틸리티 프로그램입니다 SQLite 데이터베이스 사이의 표시 차이가. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 바이너리는 측정 및 표시 얼마나 어떻게 효율적으로 공간이 SQLite는 데이터베이스 파일 개별 테이블과 인덱스에 의해 사용되는 명령 줄 유틸리티 프로그램입니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; 프로그램은 인 &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL의&lt;/a&gt; 용도 프로그램 &lt;a href=&quot;dbstat&quot;&gt;dbstat와 가상 테이블을&lt;/a&gt; 데이터베이스 파일에 대한 정보를 수집하고 깔끔하게 정보를 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="translated">&lt;em&gt;&amp;lt;이름&amp;gt;&lt;/em&gt; 은 R * 트리 인덱스 용 애플리케이션 선택하는 이름 &lt;em&gt;&amp;lt;열 이름&amp;gt;&lt;/em&gt; 쉼표가 3 내지 11 컬럼에서 분리된다. 가상 &amp;lt;name&amp;gt; 테이블은 실제로 내용을 저장하기 위해 세 개의 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 작성 합니다. 이 새도우 테이블의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="translated">ADD COLUMN 구문은 기존 테이블에 새 열을 추가하는 데 사용됩니다. 새 열은 항상 기존 열 목록의 끝에 추가됩니다. &lt;a href=&quot;syntax/column-def&quot;&gt;열 데프&lt;/a&gt; 규칙은 새로운 컬럼의 특성을 정의합니다. 새 컬럼은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 허용되는 양식을 사용할 수 있으며 다음 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE 명령은 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블에&lt;/a&gt; 저장된 스키마의 SQL 텍스트를 수정하여 작동 합니다 . 테이블 내용은 변경되지 않습니다. 이로 인해 ALTER TABLE 명령의 실행 시간은 테이블의 데이터 양과 무관합니다. ALTER TABLE 명령은 1 개의 행이있는 테이블에서와 같이 천만 개의 행이있는 테이블에서 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b0731871ca262efc59fc6d44f9562ddd3fdb4667" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">ALTER TABLE 명령은 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블에&lt;/a&gt; 저장된 스키마의 SQL 텍스트를 수정하여 작동 합니다 . 테이블 내용은 변경되지 않습니다. 이 때문에 ALTER TABLE 명령의 실행 시간은 테이블의 데이터 양과 무관합니다. ALTER TABLE 명령은 행이 1 개인 테이블에서와 마찬가지로 1000 만 행이있는 테이블에서 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="translated">ALWAYS (X) 및 NEVER (X) 매크로는 X의 진실에 대한 약한 진술입니다. ALWAYS (X) 또는 NEVER (X)의 존재는 개발자가 X가 항상 또는 절대 사실이라고 믿지만 증거는 없습니다 또는 증명이 복잡하고 오류가 발생하기 쉬우거나 변경 될 가능성이있는 시스템의 다른 측면에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="translated">ALWAYS (X) 및 NEVER (X) 매크로는 기능 테스트 중에 assert (X)처럼 동작합니다. X의 값이 예상 한 값과 다른 경우 개발자가 문제에 대해 즉시 경고하기를 원하기 때문입니다. 그러나 배달을 위해 ALWAYS (X) 및 NEVER (X)는 심층 방어를 제공하는 간단한 통과 매크로입니다. 적용 범위 테스트의 경우 ALWAYS (X) 및 NEVER (X)는 도달 불가능한 기계 코드가 생성되지 않도록 하드 코딩 된 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="translated">ANALYZE 명령은 테이블 및 인덱스에 대한 통계를 수집하고 수집 된 정보를 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블&lt;/a&gt; 에 저장합니다. 데이터베이스의 에 하여 쿼리 최적화 프로그램이 정보에 액세스하고이를 사용하여 더 나은 쿼리 계획을 선택할 수 있도록합니다. 인수가 제공되지 않으면 연결된 모든 데이터베이스가 분석됩니다. 스키마 이름이 인수로 제공되면 해당 데이터베이스의 모든 테이블과 인덱스가 분석됩니다. 인수가 테이블 이름 인 경우 해당 테이블 및 해당 테이블과 연관된 인덱스 만 분석됩니다. 인수가 인덱스 이름 인 경우 해당 인덱스 하나만 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">AND 연산자 는 두 문서 세트의 &lt;b&gt;교집합&lt;/b&gt; 을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="translated">AND 연산자는 암시 적으로 지정 될 수 있습니다. FTS 쿼리 문자열에서 연산자를 분리하지 않고 두 개의 기본 쿼리가 나타나면 두 개의 기본 쿼리가 AND 연산자로 분리 된 것과 결과가 같습니다. 예를 들어 &quot;암시 적 연산자&quot;쿼리 식은 &quot;암시 적 AND 연산자&quot;의 간결한 버전입니다.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="translated">SQLite 3.0 용 API에는 여러 데이터 구조 및 #defines 외에도 83 개의 개별 함수가 포함되어 있습니다. (완전한 &lt;a href=&quot;c3ref/intro&quot;&gt;API 참조&lt;/a&gt; 는 별도의 문서로 제공됩니다.) 다행히 인터페이스는 크기가 의미하는 것만 큼 복잡하지 않습니다. 간단한 프로그램은 여전히 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()의&lt;/a&gt; 3 가지 기능으로 만 수행 할 수 있습니다 . &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 를 사용하여 SQLite 문을 바이트 코드로 컴파일하고 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 을 사용하여 해당 바이트 코드를 실행하는 데이터베이스 엔진 실행에 대한 추가 제어가 제공됩니다 . &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_로&lt;/a&gt; 시작하는 이름을 가진 루틴 제품군쿼리 결과 집합에 대한 정보를 추출하는 데 사용됩니다. 많은 인터페이스 기능이 UTF-8 및 UTF-16 버전과 함께 쌍으로 제공됩니다. 그리고 사용자 정의 SQL 함수 및 사용자 정의 텍스트 조합 순서를 구현하는 데 사용되는 루틴 콜렉션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="translated">버전 3.0 용 API는 버전 2.X API와 유사하지만 몇 가지 중요한 변경 사항이 있습니다. 가장 주목할만한 것은 모든 API 함수 및 데이터 구조의 시작 부분에서 발생 하는 &quot; &lt;code&gt;sqlite_&lt;/code&gt; &quot;접두사가 &quot; &lt;code&gt;sqlite3_&lt;/code&gt; &quot; 로 변경됩니다 . 이를 통해 두 API 간의 혼동을 피하고 SQLite 2.X와 SQLite 3.0을 동시에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="translated">ATTACH DATABASE 문은 다른 데이터베이스 파일을 현재 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 추가 합니다 . 이전에 첨부 된 데이터베이스 파일은 &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; 명령을 사용하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="translated">AUTOINCREMENT 키워드는 추가 CPU, 메모리, 디스크 공간 및 디스크 I / O 오버 헤드를 부과하므로 엄격하게 필요하지 않은 경우 피해야합니다. 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="translated">Ascii 토크 나이 저는 다음을 제외하고는 Unicode61 토크 나이저와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="translated">B- 트리 모듈은 디스크에서 고정 크기 페이지로 정보를 요청합니다. 기본 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 는 4096 바이트이지만 512에서 65536 바이트 사이의 2의 제곱이 될 수 있습니다. 페이지 캐시는 이러한 페이지를 읽고 쓰고 캐싱하는 역할을합니다. 페이지 캐시는 롤백 및 원자 커밋 추상화를 제공하며 데이터베이스 파일의 잠금을 처리합니다. B- 트리 드라이버는 페이지 캐시에서 특정 페이지를 요청하고 페이지를 수정하거나 변경 사항을 커밋 또는 롤백 할 때 페이지 캐시에 알립니다. 페이지 캐시는 요청이 빠르고 안전하며 효율적으로 처리되도록하는 복잡한 세부 사항을 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="translated">BEFORE 또는 AFTER 키워드는 연관된 행의 삽입, 수정 또는 제거와 관련하여 트리거 조치가 실행될시기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="21f8310c8a4f643230a41569cc835883561b2976" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row. BEFORE is the default when neither keyword is present.</source>
          <target state="translated">BEFORE 또는 AFTER 키워드는 연관된 행의 삽입, 수정 또는 제거와 관련하여 트리거 조치가 실행되는시기를 결정합니다. 키워드가없는 경우 BEFORE가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="translated">BETWEEN 연산자</target>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="translated">BETWEEN 연산자는 논리적으로 비교 쌍과 같습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="translated">snippet ()에 대한 BLOB 인수에는 올바른 하위 유형이 없으므로 snippet 함수는이를 무시하고 데이터 구조를 변경하지 않으며 무해하게 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="translated">BTree 모듈은 스택 공간이 제한된 시스템에서 더 잘 재생하기 위해 스택 대신 malloc ()을 사용하여 큰 버퍼를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="translated">아래 C 코드는 sumint ()라는 간단한 창 집계 함수를 구현합니다. 이것은 내장 sum () 함수와 같은 방식으로 작동하지만 정수 값이 아닌 인수를 전달하면 예외가 발생한다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="translated">오른쪽의 C 함수는 백업 API의 가장 단순하고 가장 일반적인 용도 중 하나를 보여줍니다. 인 메모리 데이터베이스의 내용을 디스크의 파일로로드 및 저장합니다. 이 예제에서 백업 API는 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="translated">SQLite 버전 2에 대한 C 언어 인터페이스</target>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="translated">C 언어는 오래되었고 지루하다. 잘 알려지고 이해되는 언어입니다. 이것은 SQLite와 같은 모듈을 개발할 때 원하는 것입니다. 작고 빠르며 안정적인 데이터베이스 엔진을 작성하는 것은 구현 언어 사양이 업데이트 될 때마다 구현 언어가 변경되지 않기 때문에 충분히 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">ㄴ 파라미터하는 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close (C)&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; NULL 포인터 또는 여야 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를 용&lt;/a&gt; 로부터 얻어지는 오브젝트 포인터 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 그리고 이전에 폐쇄. NULL 포인터 인수를 사용하여 sqlite3_close () 또는 sqlite3_close_v2 ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">ㄴ 파라미터하는 &lt;a href=&quot;close&quot;&gt;sqlite3_close (C)&lt;/a&gt; 와 &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; NULL 포인터 또는 여야 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를 용&lt;/a&gt; 로부터 얻어지는 오브젝트 포인터 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 그리고 이전에 폐쇄. NULL 포인터 인수를 사용하여 sqlite3_close () 또는 sqlite3_close_v2 ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="translated">SQLite 용 C 언어 API는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;&lt;/a&gt; 는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현에 새로운 PRAGMA 문을 추가하거나 내장 PRAGMA 문의 의미를 대체 할 수있는 기회를 SQLITE_FCNTL_PRAGMA &lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="translated">CASE 표현</target>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="translated">CAST 연산자는 십진 정수만 이해합니다. &lt;a href=&quot;lang_expr#hexint&quot;&gt; 16 16&lt;/a&gt; 문자열의 &quot;0x&quot;접두어에서 &quot;x&quot;에서 중지되므로 CAST의 결과는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="translated">CLI에는 edit ()라는 또 다른 내장 SQL 함수가 있습니다. Edit ()는 하나 또는 두 개의 인수를 사용합니다. 첫 번째 인수는 값입니다. 일반적으로 편집 할 큰 여러 줄 문자열입니다. 두 번째 인수는 텍스트 편집기의 이름입니다. 두 번째 인수를 생략하면 VISUAL 환경 변수가 사용됩니다. edit () 함수는 첫 번째 인수를 임시 파일에 쓰고 임시 파일에서 편집기를 호출하고 편집기가 완료된 후 파일을 메모리로 다시 읽은 다음 편집 된 텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="translated">CLI는 줄 끝에서 공백 (주석 포함)을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="translated">선택적으로 각 열 이름 또는 표현식 뒤에 오는 COLLATE 절은 해당 열의 텍스트 항목에 사용되는 조합 순서를 정의합니다. 기본 조합 순서는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 에서 해당 열에 대해 정의 된 조합 순서입니다. 문 입니다. 또는 조합 순서가 달리 정의되어 있지 않으면 내장 BINARY 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="translated">COLLATE 절 은 열의 기본 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 로 사용할 조합 순서 의 이름을 지정합니다 . COLLATE 절이 지정되지 않은 경우 기본 조합 순서는 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="translated">COLLATE 연산자는 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 시퀀스&lt;/a&gt; 를 표현식에 지정하는 단항 접미사 연산자입니다 . COLLATE 연산자는 &quot;~&quot;를 제외한 모든 이진 연산자 및 단항 접두사 연산자보다 우선 순위가 높습니다 (더 밀접하게 바인딩). (COLLATE와 &quot;~&quot;는 연관되므로 바인딩 순서는 중요하지 않습니다.) COLLATE 연산자에 의해 설정된 조합 순서는 테이블 &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;컬럼 정의&lt;/a&gt; 에서 COLLATE 절에 의해 결정된 조합 순서를 대체합니다 . 추가 정보 는 &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; 문서 의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 에 대한 자세한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="translated">COMPLETION 확장 은 &quot;completion&quot;이라는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수를&lt;/a&gt; 구현하여 대화식 SQL 입력 중에 부분적으로 입력 된 단어의 완성을 제안하는 데 사용할 수 있습니다. 예를 들어 완료 테이블을 사용하여 탭 완성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="translated">COMPLETION () 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="translated">COPY 명령은 데이터가 '\ N'인 열에 NULL을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="translated">CORRUPT_DB 매크로는 많은 assert () 문에서 사용됩니다. 기능 테스트 빌드에서 CORRUPT_DB는 데이터베이스 파일에 손상이있을 수있는 경우 전역 변수를 참조합니다. 이 변수는 기본적으로 데이터베이스가 손상되었는지 여부를 알지 못하지만 제대로 구성된 것으로 알려진 데이터베이스에서 작업하는 동안 테스트하는 동안 전역 변수를 false로 설정할 수 있으므로 기본적으로 true입니다. 그러면 CORRUPT_DB 매크로는 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680에&lt;/a&gt; 표시된 assert () 문에 사용될 수 있습니다.. 이러한 assert ()는 일관된 데이터베이스 파일에 대해 true이지만 데이터베이스 파일이 손상된 경우 false 일 수있는 루틴에 사전 조건을 지정합니다. 이러한 종류의 조건에 대한 지식은 격리 된 코드 블록을 이해하려는 독자에게 매우 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="translated">CREATE INDEX 명령은 키워드 &quot;CREATE INDEX&quot;와 새 인덱스 이름, 키워드 &quot;ON&quot;, 색인을 생성 할 이전에 작성된 테이블 이름 및 괄호로 묶은 테이블 열 이름 및 /으로 구성됩니다. 또는 인덱스 키에 사용되는 표현식. 선택적 WHERE 절이 포함 된 경우 색인은 &quot; &lt;a href=&quot;partialindex&quot;&gt;부분 색인&lt;/a&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="translated">CREATE TRIGGER 문은 데이터베이스 스키마에 트리거를 추가하는 데 사용됩니다. 트리거는 지정된 데이터베이스 이벤트가 발생할 때 자동으로 수행되는 데이터베이스 작업입니다.</target>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="translated">CREATE VIEW 명령은 사전 패키지화 된 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에 이름을 지정합니다 . 뷰가 작성되면 테이블 이름 대신 다른 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 의 FROM 절에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="translated">CREATE VIRTUAL TABLE &quot;tokenize&quot;옵션은 FTS5 테이블에서 사용하는 특정 토크 나이저를 구성하는 데 사용됩니다. 옵션 인수는 FTS5 베어 워드 또는 SQL 텍스트 리터럴이어야합니다. 인수의 텍스트 자체는 하나 이상의 FTS5 베어 워드 또는 SQL 텍스트 리터럴의 공백 시리즈로 취급됩니다. 이들 중 첫 번째는 사용할 토크 나이저의 이름입니다. 두 번째 및 이후의 목록 요소는 존재하는 경우 토크 나이저 구현에 전달되는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="translated">CREATE VIRTUAL TABLE 문은 클래스 클래스 module-name에서 파생 된 table-name이라는 새 테이블을 작성합니다. module-name은 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 인터페이스에 의해 가상 테이블에 등록 된 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="translated">명령문 시작 부분의 CREATE, TABLE, VIEW, TRIGGER 및 INDEX 키워드는 모든 대문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="translated">CSV 가상 테이블</target>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="translated">CSV 가상 테이블은 SQLite 통합에 기본 제공되지 않습니다. &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장자&lt;/a&gt; 로 컴파일 할 수 있는 &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;별도의 소스 파일&lt;/a&gt; 로 제공됩니다 . &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 CSV 가상 테이블의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="translated">CSV 가상 테이블은 대량의 쉼표로 구분 된 값 컨텐츠를 대량로드해야하는 애플리케이션에 유용합니다. CSV 가상 테이블은 다른 가상 테이블을 구현하기위한 템플릿 소스 파일로도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="translated">CSV 가상 테이블은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; 형식의 쉼표로 구분 된 값을 읽고 해당 컨텐츠를 SQL 테이블의 행 및 열인 것처럼 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="translated">이 예제의 콜백 명령어는 2 개 대신 3 개의 결과 열에 대한 데이터를 생성해야하지만 그렇지 않으면 첫 번째 쿼리와 동일합니다. 콜백 명령어가 호출되면 결과의 가장 왼쪽 열이 스택에서 가장 낮아야하고 가장 오른쪽 결과 열이 스택의 맨 위에 있어야합니다. 주소 11에서 15까지 이러한 방식으로 스택이 설정되는 것을 볼 수 있습니다. 11 및 12의 열 명령어는 결과에서 처음 두 열의 값을 푸시합니다. 13과 14의 두 열 명령어는 세 번째 결과 열을 계산하는 데 필요한 값을 가져오고 15의 Concat 명령어는이를 스택의 단일 항목으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="translated">Carray () 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="translated">점검표 선언</target>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="translated">Clang / LLVM 컴파일러는 GCC와 경쟁이되지 않습니다. Clang 생성 바이너리는 GCC 생성 바이너리보다 지속적으로 크고 느립니다.</target>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="translated">프로그램 끝의 닫기 명령은 &quot;examp&quot;테이블을 가리키는 커서를 닫습니다. 프로그램이 중지되면 VDBE에 의해 모든 커서가 자동으로 닫히므로 여기서 Close를 호출 할 필요는 없습니다. 그러나 우리는 되감기 명령이 필요했기 때문에 앞으로 나아가서 그 지시가 유용한 일을하도록 할 수있었습니다. 중지 명령은 VDBE 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M)에 대한 D 및 N 인수는 각각 대상 데이터베이스 및 데이터베이스 이름과 연관된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;, 임시 데이터베이스의 경우 &quot;temp&quot;또는 연결된 데이터베이스 의 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. sqlite3_backup_init (D, N, S, M)에 전달 된 S 및 M 인수는 각각 소스 데이터베이스 의 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 데이터베이스 이름을 식별합니다 . 소스 및 대상 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (매개 변수 S 및 D)은 달라야합니다. 그렇지 않으면 sqlite3_backup_init (D, N, S, M)가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M)에 대한 D 및 N 인수는 각각 대상 데이터베이스 및 데이터베이스 이름과 연관된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;, 임시 데이터베이스의 경우 &quot;temp&quot;또는 연결된 데이터베이스 의 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. sqlite3_backup_init (D, N, S, M)에 전달 된 S 및 M 인수는 각각 소스 데이터베이스 의 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 데이터베이스 이름을 식별합니다 . 소스 및 대상 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (매개 변수 S 및 D)은 달라야합니다. 그렇지 않으면 sqlite3_backup_init (D, N, S, M)가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 대한 D 매개 변수 는 NULL 일 수 있습니다. &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 의 D 매개 변수 가 NULL이 아닌 경우, &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 포함 된 문자열의 최대 길이는 &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 대신 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, SQLITE_LIMIT_LENGTH )에 설정된 값 이 &lt;a href=&quot;limits#max_length&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)에&lt;/a&gt; 대한 D 매개 변수 는 NULL 일 수 있습니다. &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; 의 D 매개 변수 가 NULL이 아닌 경우, &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 포함 된 문자열의 최대 길이는 &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 대신 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, SQLITE_LIMIT_LENGTH )에 설정된 값 이 &lt;a href=&quot;../limits#max_length&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="translated">DBSTAT 가상 테이블</target>
        </trans-unit>
        <trans-unit id="97ceb7c4621bdd8f62a9cfbb2a879b8e9e999bd7" translate="yes" xml:space="preserve">
          <source>The DBSTAT table only reports on the content of btrees within the database file. Freelist pages, pointer-map pages, and the lock page are omitted from the analysis.</source>
          <target state="translated">DBSTAT 테이블은 데이터베이스 파일 내의 btree 내용에 대해서만보고합니다. 자유 목록 페이지, 포인터 맵 페이지 및 잠금 페이지는 분석에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="76cd10f2092ca8f1b285dee48937f8c50e332d42" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about the amount of disk space used to store the content of an SQLite database. Example use cases for the DBSTAT virtual table include the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program and the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT 가상 테이블은 SQLite 데이터베이스의 콘텐츠를 저장하는 데 사용되는 디스크 공간의 양에 대한 정보를 반환 하는 읽기 전용 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; 입니다. DBSTAT 가상 테이블의 예제 사용 사례에는 SQLite 용 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 구현&lt;/a&gt; 버전 제어 시스템 의 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램과 &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;테이블 크기 원형 차트가 포함&lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">dbstat와 가상 테이블은 읽기 전용입니다 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; 을 반환 정보가있는에 대한 데이터베이스 파일의 페이지가 사용하는 스키마에있는 테이블과 인덱스에 의해. DBSTAT 가상 테이블은 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램 을 구현 하고 SQLite 용 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 구현&lt;/a&gt; 버전 제어 시스템 에서 &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;테이블 크기 원형 차트&lt;/a&gt; 를 계산하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ce5a525fa3a87844d5ab55ef30cdd54b0cc3c2" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">DBSTAT 가상 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블입니다&lt;/a&gt; . 즉, 사용하기 전에 dbstat 가상 테이블의 인스턴스를 생성하기 위해 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 을 실행할 필요가 없습니다 . &quot;dbstat&quot;모듈 이름은 dbstat 가상 테이블을 직접 쿼리하는 테이블 이름 인 것처럼 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f357b6765d9672540c415d35375e9c82ab3dde27" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">DBSTAT 가상 테이블은 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 컴파일 시간 옵션을 사용하여 SQLite를 빌드 할 때 모든 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="translated">DEFAULT 절은 &lt;a href=&quot;lang_insert&quot;&gt;INSERT를&lt;/a&gt; 수행 할 때 사용자가 명시 적으로 값을 제공하지 않으면 열에 사용할 기본값을 지정합니다 . 열 정의에 명시 적 DEFAULT 절이 첨부되지 않은 경우 열의 기본값은 NULL입니다. 명시 적 DEFAULT 절은 기본값이 NULL, 문자열 상수, 얼룩 상수, 부호있는 숫자 또는 괄호로 묶인 상수 표현식임을 지정할 수 있습니다. 기본값은 대소 문자를 구분하지 않는 특수 키워드 CURRENT_TIME, CURRENT_DATE 또는 CURRENT_TIMESTAMP 중 하나 일 수도 있습니다. DEFAULT 절의 목적 상, 서브 쿼리, 열 또는 테이블 참조, &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 또는 작은 따옴표 대신 큰 따옴표로 묶인 문자열 리터럴 이없는 표현식은 상수로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="translated">DELETE 명령은 &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;Qualified-table-name으로&lt;/a&gt; 식별 된 테이블에서 레코드를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="translated">WHILE 절이없는 DELETE 명령은 레코드별로 레코드를 삭제하거나 삭제하지 않고 디스크에서 데이터베이스 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="translated">DELETE 저널링 모드는 정상적인 동작입니다. 삭제 모드에서 롤백 저널은 각 트랜잭션이 끝날 때 삭제됩니다. 실제로 삭제 작업은 트랜잭션을 커밋하는 작업입니다. (자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 문서를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="translated">컨텐츠 테이블에서 실제 삭제를 수행하기 전에 DELETE 트리거를 시작해야합니다. FTS4가 여전히 전체 텍스트 인덱스를 업데이트하기 위해 원래 값을 검색 할 수 있습니다. 그리고 시스템 내에서 rowid가 자동으로 할당되는 경우를 처리 할 수 ​​있도록 새 행을 삽입 한 후에 INSERT 트리거를 시작해야합니다. UPDATE 트리거는 동일한 이유로 컨텐츠 테이블 업데이트 전후에 발생하는 두 부분으로 나누어야합니다.</target>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="translated">DELETE 모드 잠금은 기본 데이터베이스 파일 의 &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;잠금 바이트 페이지&lt;/a&gt; 에 저장됩니다. SQLITE_LOCK_SHARED 및 SQLITE_LOCK_EXCLUSIVE 만 WAL 모드 데이터베이스의 요소입니다. 다른 잠금 상태는 롤백 모드에서 사용되지만 WAL 모드에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="translated">집계 쿼리의 DISTINCT 키워드</target>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="translated">DISTINCT 키워드는 적절한 색인을 사용할 수 있고 최적화 프로그램에서 사용이 유리하다고 생각할 때 때때로 INDEX를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="translated">집계 쿼리의 DISTINCT 키워드는 임시 파일에 임시 색인을 작성하고 각 결과 행을 해당 색인에 저장하여 구현됩니다. 새 결과 행이 계산되면 임시 색인에 이미 존재하는지와 새 결과 행이 있는지 확인하기 위해 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="translated">DROP INDEX 문은 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문으로 추가 된 색인을 제거합니다 . 디스크에서 인덱스가 완전히 제거됩니다. 인덱스를 복구하는 유일한 방법은 적절한 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 명령 을 다시 입력하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="translated">DROP TABLE 문은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문으로 추가 된 테이블을 제거합니다 . 지정된 이름이 테이블 이름입니다. 삭제 된 테이블은 데이터베이스 스키마 및 디스크 파일에서 완전히 제거됩니다. 테이블을 복구 할 수 없습니다. 테이블과 관련된 모든 인덱스 및 트리거도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">DROP TRIGGER 문은 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로 작성된 트리거를 제거합니다 . 일단 제거되면 트리거 정의가 더 이상 sqlite_master (또는 sqlite_temp_master) 테이블에 존재하지 않으며 후속 INSERT, UPDATE 또는 DELETE 문에 의해 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="translated">DROP VIEW 문은 &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 문으로 작성된보기를 제거합니다 . 뷰 정의는 데이터베이스 스키마에서 제거되지만 기본 테이블의 실제 데이터는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="translated">Dbbe 추상화와 GDBM 및 메모리 드라이버가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="translated">SQLite 3.12.0의 기본 페이지 크기 변경</target>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="translated">복합 쿼리에 대한 EXCEPT 연산자는 임시 파일에 임시 색인을 작성하고이 임시 색인에 왼쪽 서브 쿼리의 결과를 저장 한 후 오른쪽 서브 쿼리의 결과를 임시 색인에서 제거하고 마지막으로 색인을 시작하여 구현됩니다. 최종 출력을 얻기 위해 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="translated">EXISTS 연산자</target>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="translated">EXISTS 연산자는 항상 정수 값 0과 1 중 하나로 평가됩니다. EXISTS 연산자의 오른쪽 피연산자로 지정된 SELECT 문을 실행하면 하나 이상의 행이 리턴되면 EXISTS 연산자는 1로 평가됩니다. 행을 전혀 반환하지 않으면 EXISTS 연산자는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="translated">EXPLAIN QUERY PLAN 명령에 대한 &lt;a href=&quot;eqp&quot;&gt;자세한 내용은 여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="translated">EXPLAIN 및 EXPLAIN QUERY PLAN 접두사는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 실행하는 동작에 영향을줍니다 . &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 이와 유사한 것을 사용하여 새로운 준비된 명령문을 생성하는 프로세스 는 (대부분) EXPLAIN의 영향을받지 않습니다. (이전 문장의 예외는 EXPLAIN QUERY PLAN 준비 명령문을 빌드 할 때 EXPLAIN QUERY PLAN에서 사용하는 일부 특수 opcode가 성능 최적화로 생략 된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="translated">오류 및 경고 로그</target>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="translated">FAIL 동작은 고유성, NOT NULL 및 CHECK 제약 조건에서만 작동합니다. &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건의&lt;/a&gt; 위반은 ABORT가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="translated">트리거의 FOR EACH STATEMENT 절이 구문 오류를 발생시킵니다. 예전에는 무시당했습니다.</target>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="translated">FTS 모듈은 두 가지 약간 다른 버전의 전체 텍스트 쿼리 구문 인 &quot;표준&quot;쿼리 구문과 &quot;향상된&quot;쿼리 구문 중 하나를 사용하도록 컴파일 될 수 있습니다. 위에서 설명한 기본 용어, 용어 접두사, 구문 및 NEAR 쿼리는 두 버전의 구문에서 동일합니다. 세트 연산이 지정되는 방식은 약간 다릅니다. 다음 두 하위 섹션에서는 작업 설정과 관련된 두 쿼리 구문의 일부를 설명합니다. 컴파일 노트는 &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;fts&lt;/a&gt; 를 컴파일 하는 방법에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="translated">FTS 쿼리 구문 (MATCH 연산자의 오른쪽)이 몇 가지 방식으로 변경되었습니다. FTS5 구문은 FTS4 &quot;향상된 구문&quot;에 매우 가깝습니다. 주요 차이점은 FTS5가 인식 할 수없는 문장 부호 문자에 대해 더 까다 롭고 쿼리 문자열 내에서 유사하다는 것입니다. FTS3 / 4에서 작동하는 대부분의 쿼리는 FTS5에서도 작동해야하며 구문 분석 오류를 반환하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="translated">반환 된 텍스트 조각을 추출 할 FTS 테이블 열 번호입니다. 열은 왼쪽에서 오른쪽으로 0부터 시작하여 번호가 매겨집니다. 음수 값은 텍스트가 임의의 열에서 추출 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="translated">FTS3 및 FTS4 확장 모듈을 사용하면 내장 된 전체 텍스트 인덱스 (이하 &quot;FTS 테이블&quot;)가있는 특수 테이블을 만들 수 있습니다. 전체 텍스트 인덱스를 사용하면 테이블에 많은 큰 문서가 포함되어 있어도 하나 이상의 단어 (이하 &quot;토큰&quot;)가 포함 된 모든 행에 대해 데이터베이스를 효율적으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="translated">FTS3 및 FTS4 모듈은 전체 텍스트 쿼리 시스템 개발자에게 유용한 &quot;스 니펫&quot;, &quot;오프셋&quot;및 &quot;matchinfo&quot;의 세 가지 특수 SQL 스칼라 함수를 제공합니다. &quot;스 니펫&quot;및 &quot;오프셋&quot;기능의 목적은 사용자가 반환 된 문서에서 쿼리 된 용어의 위치를 ​​식별 할 수 있도록하는 것입니다. &quot;matchinfo&quot;기능은 관련성에 따라 쿼리 결과를 필터링하거나 정렬하는 데 유용한 메트릭을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="translated">FTS3 확장은 주요 재 작업 및 정리를 거쳤습니다. 새로운 &lt;a href=&quot;fts3&quot;&gt;FTS3 문서&lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4 &quot;automerge = X&quot;명령이 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge 옵션&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4 &quot;merge = X, Y&quot;명령이 &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge 명령&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="translated">FTS4 접두사 옵션은 FTS가 항상 완전한 용어를 색인화하는 것과 같은 방식으로 지정된 길이의 용어 접 두부를 색인화합니다. 접두사 옵션은 쉼표로 구분 된 양수가 아닌 정수 목록으로 설정해야합니다. 목록의 각 값 N에 대해 길이가 N 바이트 인 접두어 (UTF-8을 사용하여 인코딩 된 경우)가 색인화됩니다. FTS4는 용어 접두사 인덱스를 사용하여 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두사 쿼리&lt;/a&gt; 속도를 높 입니다. 물론 전체 용어뿐만 아니라 색인 용어 접두어는 데이터베이스 크기를 늘리고 FTS4 테이블에서 쓰기 작업을 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="translated">동기식 pragma가 &quot;full&quot;이외의 것으로 설정된 경우 F_FULLSYNC ioctl (현재 Mac OS X에서만 지원됨)이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="translated">화석 NGQP 업그레이드 사례 연구</target>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="translated">TAGXREF_I1 색인의 가장 왼쪽 열 (TAGID 열)에 대해 동일한 값을 가진 TAGXREF 테이블에 10 천 개가 넘는 항목이 있기 때문에이 문서의 이전 섹션에서 설명한 화석 성능 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="translated">화석보기는 지점이 결국 트렁크로 다시 병합되었음을 분명히 보여줍니다. 분기가 시작된 위치를 표시하고 트렁크의 변경 사항이 분기에 병합 된 두 가지 경우를 보여줍니다. GitHub는이 중 어느 것도 보여주지 않습니다. 실제로 GitHub 디스플레이는 어떤 일이 발생했는지 파악하는 데 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="translated">Fts5PhraseIter 구조는 위에 정의되어 있습니다. 응용 프로그램은이 구조를 직접 수정해서는 안됩니다. xPhraseFirst () 및 xPhraseNext () API 메서드와 함께 (아래 그림과 같이 xPhraseFirstColumn () 및 xPhraseNextColumn ()에 의해) 위에 표시된 대로만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="translated">GLOB 연산자는 항상 대소 문자를 구분합니다. GLOB 연산자의 왼쪽 열은 항상 내장 BINARY 배열 순서를 사용해야합니다. 그렇지 않으면 해당 연산자를 인덱스로 최적화하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="translated">GLOB 연산자는 LIKE와 비슷하지만 와일드 카드에 유닉스 파일 글 로빙 구문을 사용합니다. 또한 GLOB은 LIKE와 달리 대소 문자를 구분합니다. GLOB와 LIKE 앞에 NOT 키워드를 붙여 테스트 의미를 반전시킬 수 있습니다. 삽입 GLOB 연산자는 &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; )&lt;/a&gt; 함수를 호출하여 구현되며 해당 함수를 대체하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="translated">SQLite R * Tree 모듈에 대한 Geopoly 인터페이스</target>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="translated">Geopoly 모듈은 &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 표기법 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt; )을 사용하여 2 차원 다각형을 설명 하는 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장에&lt;/a&gt; 대한 대체 인터페이스 입니다. Geopoly에는 다각형으로 둘러싸인 영역을 계산하거나 다각형의 선형 변형을 수행하거나 다각형을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; 로 렌더링하기위한 다각형 및 기타 유사한 작업 을 수행하기 위해 하나의 다각형이 다른 다각형 내에 포함되거나 중복되는시기를 감지하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="translated">Geopoly 모듈은 GeoJSON의 작은 부분 집합 만 이해하지만 중요한 부분 집합을 이해합니다. 특히 GeoJSON은 간단한 다각형을 설명하는 정점의 JSON 배열을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="translated">ICU 토크 나이저 구현은 매우 간단합니다. 단어 경계를 찾기 위해 ICU 규칙에 따라 입력 텍스트를 분할하고 공백으로 구성된 토큰을 모두 버립니다. 이는 일부 로케일의 일부 응용 프로그램에 적합 할 수 있지만 전부는 아닙니다. 예를 들어 형태소 분석 또는 폐기 구두점을 구현하기 위해 더 복잡한 처리가 필요한 경우, ICU 토큰 화기를 구현의 일부로 사용하는 토큰 화기 구현을 작성하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="translated">ICU 토크 나이저를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="translated">IN 및 NOT IN 연산자</target>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="translated">IN 및 NOT IN 연산자는 왼쪽에 표현식을, 오른쪽에 값 목록 또는 하위 쿼리를 가져옵니다. IN 또는 NOT IN 연산자의 오른쪽 피연산자가 서브 쿼리 인 경우 서브 쿼리는 왼쪽 피연산자 의 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 에있는 열과 동일한 수의 열을 가져야합니다 . 왼쪽 표현식이 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 표현식 이 아닌 경우 IN 또는 NOT IN 연산자의 오른쪽에있는 하위 쿼리는 스칼라 하위 쿼리 여야합니다 . IN 또는 NOT IN 연산자의 오른쪽 피연산자가 값 목록 인 경우 해당 값은 각각 스칼라 여야하고 왼쪽 표현식도 스칼라 여야합니다. IN 또는 NOT IN 연산자의 오른쪽은 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="translated">IN 연산자는 왼쪽이 인덱스의 가장 왼쪽 항이 아니더라도 이제 최적화 후보입니다. 동일한 IN 인덱스에 여러 IN 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="translated">IN-early-out 최적화 : 다중 열 인덱스에서 조회를 수행하고 맨 왼쪽 열 이외의 열에서 IN 연산자를 사용하는 경우 첫 번째 IN 값과 일치하는 행이 없으면 다음을 확인하십시오. 다음 IN 값을 계속하기 전에 열과 오른쪽에 일치하는 행이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c69ea675978574ca724f9055d892093e6e8c8e6f" translate="yes" xml:space="preserve">
          <source>The INDEXED BY Clause</source>
          <target state="translated">INDEXED BY 절</target>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="translated">INDEXED BY 및 NOT INDEXED 절은 트리거 내의 DELETE 문에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="translated">INDEXED BY 및 NOT INDEXED 절은 트리거 내의 UPDATE 문에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에는 INDEXED BY 및 NOT INDEXED 절이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="translated">INDEXED BY 절은 쿼리 성능 조정에 사용하기위한 것이 &lt;em&gt;아닙니다&lt;/em&gt; . INDEXED BY 절의 목적은 인덱스 삭제 또는 작성과 같은 스키마 변경으로 인해 시간에 민감한 쿼리에 대한 쿼리 계획이 변경되는 경우 런타임 오류를 발생시키는 것입니다. INDEXED BY 절은 회귀 테스트 중에 원하지 않는 쿼리 계획 변경을 감지하는 데 도움이되도록 설계되었습니다. 응용 프로그램 개발자는 응용 프로그램 디자인, 구현, 테스트 및 조정 중에 INDEXED BY를 모두 사용하지 않는 것이 좋습니다. INDEXED BY를 사용하려면 디자인을 &quot;잠글&quot;때 개발 프로세스의 맨 끝에 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="translated">INDEXED BY 구문은 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 가 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 특정 명명 된 인덱스를 사용하도록 합니다. INDEXED BY 구문은 SQLite 확장이며 다른 SQL 데이터베이스 엔진으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="translated">INSERT 변경은 ​​변경 그룹에 남아 있습니다. INSERT 변경의 값은 행이 기존 변경에 의해 삽입 된 것처럼 수정 된 다음 새 변경에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">위의 INSERT 문은 sqlite_master 테이블에 새 행을 추가합니다.이 테이블은 &quot;t1bc&quot;색인과 동일한 온 디스크 형식을 가지며 동일한 b- 트리를 가리키는 &quot;t2&quot;테이블을 정의합니다. 이 sqlite_master 테이블 항목을 추가 한 후 SQLite가 스키마를 다시 읽도록하려면 데이터베이스를 닫았다가 다시 열어야합니다. 그런 다음 &quot;t1bc&quot;인덱스의 내용을보기 위해 &quot;t2&quot;테이블을 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe3ae8d2c81f2e60d52f407b340e91b2e1ca71c" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_schema table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_schema table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">위의 INSERT 문은 인덱스 &quot;t1bc&quot;와 동일한 온 디스크 형식을 가지며 동일한 b- 트리를 가리키는 테이블 &quot;t2&quot;를 정의하는 sqlite_schema 테이블에 새 행을 추가합니다. 이 sqlite_schema 테이블 항목을 추가 한 후 SQLite가 스키마를 다시 읽도록하려면 데이터베이스를 닫았다가 다시 열어야합니다. 그런 다음 &quot;t2&quot;테이블을 쿼리하여 &quot;t1bc&quot;인덱스의 내용을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="translated">INSERT 문은 세 가지 기본 형식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="translated">복합 쿼리에 대한 INTERSECT 연산자는 각각 별도의 임시 파일에 두 개의 별도 임시 인덱스를 작성하여 구현됩니다. 왼쪽 및 오른쪽 하위 쿼리는 각각 별도의 임시 인덱스로 평가됩니다. 그런 다음 두 인덱스가 함께 걸러지고 두 인덱스에 나타나는 항목이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="translated">과일별로 순서대로 각 항목의 rowid를 찾기 위해 Idx1 인덱스가 위에서 아래로 (또는 &quot;ORDER BY fruit DESC&quot;를 사용하는 경우 아래에서 위로) 스캔됩니다. 그런 다음 각 rowid에 대해 이진 검색을 수행하여 해당 행을 조회하고 출력합니다. 이러한 방식으로 출력은 전체 출력을 수집하고 별도의 단계를 사용하여 정렬 할 필요없이 요청 된 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="translated">JSON1 확장</target>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">LIKE 연산자는 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma를&lt;/a&gt; 사용하여 대소 문자를 구분할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="translated">LIKE 연산자는 패턴 일치 비교를 수행합니다. LIKE 연산자의 오른쪽에있는 피연산자는 패턴을 포함하고 왼쪽 피연산자는 패턴과 일치하는 문자열을 포함합니다. LIKE 패턴의 퍼센트 기호 ( &quot;%&quot;)는 문자열에서 0 개 이상의 문자 시퀀스와 일치합니다. LIKE 패턴의 밑줄 ( &quot;_&quot;)은 문자열의 단일 문자와 일치합니다. 다른 모든 문자는 자체 또는 대소 문자가 일치합니다 (예 : 대소 문자를 구분하지 않음). &lt;u&gt;중요 사항 :&lt;/u&gt; SQLite는 기본적으로 ASCII 문자의 대 / 소문자 만 이해합니다. LIKE 연산자는 기본적으로 ASCII 범위를 벗어난 유니 코드 문자에 대해 대소 문자를 구분합니다. 예를 들어 &lt;b&gt;'a'LIKE 'A'&lt;/b&gt; 표현식 은 TRUE이지만 &lt;b&gt;'&amp;aelig;'LIKE '&amp;AElig; '&lt;/b&gt;거짓입니다. SQLite의 ICU 확장에는 모든 유니 코드 문자를 접는 경우를 포함하는 향상된 버전의 LIKE 연산자가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="translated">LIKE 연산자에는 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt; 로 설정할 수있는 두 가지 모드가 있습니다 . 기본 모드는 LIKE 비교가 latin1 문자의 대소 문자 차이에 영향을받지 않는 것입니다. 따라서 기본적으로 다음 표현식은 true입니다.</target>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="translated">LIKE 연산자는 SQL 표준에서 요구하는 것이므로 기본적으로 대소 문자를 구분하지 않습니다. 컴파일러에 &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; 명령 행 옵션을 사용하여 컴파일시 기본 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="translated">내장 된 BINARY 조합 순서를 사용하여 연산자 왼쪽에 명명 된 열이 색인화되고 case_sensitive_like가 설정된 경우 LIKE 최적화가 발생할 수 있습니다. 또는 내장 NOCASE 조합 순서를 사용하여 열이 색인화되고 case_sensitive_like 모드가 해제 된 경우 최적화가 발생할 수 있습니다. LIKE 연산자가 최적화되는 유일한 두 가지 조합입니다.</target>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="translated">LIKE 최적화는 잘못된 바이트 코드를 생성하여 왼쪽 피연산자가 숫자 선호도를 갖고 오른쪽 패턴이 '/ %'이거나 패턴이 ESCAPE 문자로 시작하는 경우 잘못된 응답을 얻습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b에&lt;/a&gt; 대한 수정</target>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">GLOB 또는 LIKE 연산자의 우측 어느 문자 또는 문자열 인 경우 등에 최적화 만 시도 될 것이다 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개&lt;/a&gt; 된 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;결합 된&lt;/a&gt; 캐릭터 문자로이. 문자열 리터럴은 와일드 카드로 시작해서는 안됩니다. 오른쪽이 와일드 카드 문자로 시작하면이 최적화가 시도됩니다. 오른쪽 이 문자열에 바인딩 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수 인&lt;/a&gt; 경우이 최적화는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문이있는&lt;/a&gt; 경우에만 시도됩니다 , 표현식을 포함하는 이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 로 컴파일 된 . 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문을 사용하여 명령문을 준비한 경우 LIKE 최적화가 시도되지 않습니다.&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75a37b85ec9af203958779031808e1e864da0987" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is not attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">GLOB 또는 LIKE 연산자의 우측 어느 문자 또는 문자열 인 경우 등에 최적화 만 시도 될 것이다 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개&lt;/a&gt; 된 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;결합 된&lt;/a&gt; 캐릭터 문자로이. 문자열 리터럴은 와일드 카드로 시작하면 안됩니다. 오른쪽이 와일드 카드 문자로 시작하면이 최적화가 시도되지 않습니다. 오른쪽 이 문자열에 바인딩 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수 인&lt;/a&gt; 경우 표현식이 포함 된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 로 컴파일 된 경우에만이 최적화가 시도됩니다 . 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문이 다음을 사용하여 준비된 경우 LIKE 최적화가 시도되지 않습니다.&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="translated">LIKE, GLOB, REGEXP 및 MATCH 연산자</target>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="translated">LIMIT 및 ORDER BY 절 (아래 설명 참조)은 트리거 내의 DELETE 문에 대해 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="translated">UPDATE에 대한 LIMIT 및 ORDER BY 절은 SQLite를 빌드하는 데 사용 된 컴파일 옵션에 관계없이 트리거 내에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="translated">LIMIT 절</target>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="translated">LIMIT 절은 전체 SELECT 문이 리턴 한 행 수에 상한을 두는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="translated">LIMIT 절은 이제 부속 선택에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="translated">LIMIT 절이 있으면 2b 단계에서 재귀 테이블에 추가 될 최대 행 수를 결정합니다. 한도에 도달하면 재귀가 중지됩니다. 제한이 0이면 재귀 테이블에 행이 추가되지 않고 음수 제한이 있으면 무한 반복 행이 재귀 테이블에 추가 될 수 있다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="translated">LOCKING_STYLE 확장은 이제 Mac OS X에서 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="translated">레몬 LALR (1) 파서 생성기</target>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="translated">레몬 소스 코드는 원래 별도의 소스 파일로 작성되었으며 나중에 단일 &quot;lemon.c&quot;소스 파일로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="translated">MATCH 연산자는 match () 응용 프로그램 정의 함수의 특수 구문입니다. 기본 match () 함수 구현은 예외를 발생시키고 실제로는 유용하지 않습니다. 그러나 확장은 더 유용한 논리로 match () 함수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="translated">사용자 정의 R * Tree 조회 함수의 MATCH 연산자는 WHERE 절의 최상위 AND 연결 용어 여야합니다. 그렇지 않으면 R * Tree 조회 최적화 프로그램에서 사용할 수 없으며 조회를 실행할 수 없습니다. 예를 들어, MATCH 연산자가 OR 연산자를 통해 WHERE 절의 다른 용어에 연결되면 쿼리는 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="translated">MEMORY 저널링 모드는 롤백 저널을 휘발성 RAM에 저장합니다. 이는 디스크 I / O를 절약하지만 데이터베이스 안전 및 무결성을 희생합니다. MEMORY 저널링 모드가 설정되어있을 때 트랜잭션 도중 SQLite를 사용하는 응용 프로그램이 충돌하면 데이터베이스 파일이 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;손상&lt;/a&gt; 될 가능성이 큽니다 .</target>
        </trans-unit>
        <trans-unit id="f83732bb3e32c92cf54961a7828a9a9bf48899eb" translate="yes" xml:space="preserve">
          <source>The MySQL UPDATE statement does not have just one target table like other systems. Any of the tables that participate in the join can be modified in the SET clause. The MySQL UPDATE syntax allows you to update multiple tables at once!</source>
          <target state="translated">MySQL UPDATE 문에는 다른 시스템과 같이 대상 테이블이 하나만있는 것은 아닙니다. 조인에 참여하는 테이블은 SET 절에서 수정할 수 있습니다. MySQL UPDATE 구문을 사용하면 한 번에 여러 테이블을 업데이트 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="translated">신화적인 남자-월</target>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="translated">NGQP는 데이터베이스에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 가 실행 되지 않는 한이 쿼리에서 TAGXREF_I1이 거의 쓸모가 없음을 알 수있는 방법이 없습니다 . 는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 다양한 인덱스와 상점에서 그 통계의 품질에 명령 집결 통계를 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; 테이블. 이 통계 정보에 액세스하면 NGQP는 알고리즘 1을 가장 좋은 알고리즘으로 쉽게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="translated">NGQP는 레거시 쿼리 플래너보다 거의 항상 좋습니다. 그러나 레거시 쿼리 플래너에서 정의되지 않은 및 / 또는 차선의 동작에 무의식적으로 의존하는 레거시 응용 프로그램이있을 수 있으며 이러한 레거시 응용 프로그램에서 NGQP로 업그레이드하면 성능이 저하 될 수 있습니다. 이 위험을 고려하고 위험을 줄이고 발생하는 문제를 해결하기위한 점검 목록이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="translated">NGQP는 &quot;N Nearest Neighbors&quot;(이하 &quot;N3&quot;) 그래프를 통해 최상의 경로를 찾는 데 새로운 휴리스틱을 사용합니다. N3을 사용하면 각 단계마다 가장 가까운 이웃을 하나만 선택하는 대신 알고리즘은 일부 작은 정수 N에 대해 각 단계에서 N 개의 최고의 경로를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="translated">NGQP는 스키마가 인덱스의 맨 왼쪽 열에 동일한 값을 가진 약 10 또는 20 개가 넘는 행을 갖는 인덱스를 포함하지 않는 한 항상 좋은 쿼리 계획을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="translated">정확한가에 NGQP는 항상 액세스 할 수있는만큼, 이전의 쿼리 계획에 비해 동일하거나 더 나은 쿼리 계획을 찾을 수 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 의 데이터를 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1의&lt;/a&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="translated">NOCASE 데이터 정렬은 비교를 실행하기 전에 대문자 ASCII 문자 ( 'A'- 'Z')가 소문자로 접힌다는 점을 제외하고는 BINARY와 같습니다. ASCII 문자 만 대소 문자를 사용합니다. NOCASE는 범용 유니 코드 대소 문자를 비교하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="translated">NOT 연산자 (또는 표준 구문을 사용하는 경우 단항 &quot;-&quot;연산자)를 사용하면 다른 문서와 관련하여 한 문서 세트의 &lt;b&gt;상대적인 보완&lt;/b&gt; 을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="translated">NOT 연산자는 지원되지 않습니다. NOT 연산자 대신 표준 쿼리 구문은 기본 용어 및 용어 접두사 쿼리 (구문 또는 NEAR 쿼리에는 적용되지 않음)에 적용될 수있는 단항 &quot;-&quot;연산자를 지원합니다. 단항 &quot;-&quot;연산자가 첨부 된 용어 또는 접두어는 OR 연산자에 피연산자로 표시되지 않을 수 있습니다. FTS 쿼리는 단항 &quot;-&quot;연산자가 첨부 된 용어 또는 접두사 쿼리로 완전히 구성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f10f8b9e2a034cee1135ad17b2a216a2126edd" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hence NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLS FIRST 및 NULLS LAST 술어는 인덱스에 대해 지원되지 않습니다. 대한 &lt;a href=&quot;datatype3#sortorder&quot;&gt;목적을 정렬&lt;/a&gt; , SQLite는 다른 모든 값보다 작게 NULL 값을 고려합니다. 따라서 NULL 값은 항상 ASC 색인의 시작과 DESC 색인의 끝에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLS FIRST 및 NULLS LAST 술어는 인덱스에 지원되지 않습니다. 대한 &lt;a href=&quot;datatype3#sortorder&quot;&gt;분류 목적&lt;/a&gt; , SQLite는 다른 모든 값보다 작게 NULL 값을 고려합니다. 따라서 NULL 값은 항상 ASC 색인의 시작과 DESC 색인의 끝에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="translated">Next 명령어는 커서 P0이 가리키는 테이블의 다음 요소를 가리 키도록 커서를 증가시키고, 성공한 경우 P2 (6, 루프 본문의 시작)로 분기됩니다. 닫기 명령은 커서 P1을 닫습니다. 커서 P1과 연관되지 않으므로 임시 스토리지 목록에 영향을 미치지 않습니다. 대신 전역 작업 목록입니다 (ListPush로 저장할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="translated">차세대 쿼리 플래너</target>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="translated">ODP ZIP 아카이브에는 content.xml, styles.xml, meta.xml 및 settings.xml의 네 가지 XML 파일이 있습니다. 이 4 개의 파일은 슬라이드 레이아웃, 텍스트 내용 및 스타일을 정의합니다. 이 특정 프레젠테이션에는 전체 화면 사진에서 작은 아이콘에 이르는 62 개의 이미지가 포함되어 있으며 각각은 그림 폴더에 별도의 파일로 저장됩니다. &quot;mimetype&quot;파일에는 다음과 같은 한 줄의 텍스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="translated">OFF 저널링 모드는 롤백 저널을 완전히 비활성화합니다. 롤백 저널이 작성되지 않으므로 삭제할 롤백 저널이 없습니다. OFF 저널링 모드는 SQLite의 자동 커밋 및 롤백 기능을 비활성화합니다. &lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 명령이 더 이상 작동하지 않습니다; 정의되지 않은 방식으로 동작합니다. 저널 모드가 OFF 인 경우 응용 프로그램은 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령을 사용하지 않아야합니다 . OFF 저널링 모드가 설정 될 때 트랜잭션 중간에 응용 프로그램이 충돌하면 데이터베이스 파일이 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;손상&lt;/a&gt; 될 가능성이 큽니다 . 저널이 없으면 제한 조건 오류 후에 명령문이 부분적으로 완료된 조작을 해제 할 수있는 방법이 없습니다. 또한 데이터베이스가 손상된 상태로 남아있을 수 있습니다. 예를 들어, 중복 된 항목으로 인해&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; 문이 중간에 실패하면 부분적으로 생성 된 인덱스가 남게됩니다. OFF 저널링 모드에서는 일반 SQL을 사용하여 데이터베이스 파일을 손상시킬 수 있으므로 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 가 활성화 되면 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="translated">OFFSET 절이 존재하고 양수 값 N을 갖는 경우, 첫 번째 N 개의 행이 재귀 테이블에 추가되지 않도록합니다. 첫 번째 N 행은 여전히 ​​재귀 선택에 의해 처리되며 재귀 테이블에는 추가되지 않습니다. 모든 OFFSET 행을 건너 뛸 때까지 행은 LIMIT를 이행하는 것으로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b277e3e2e965c40320745de00278d14c1b4c238" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT Clause</source>
          <target state="translated">ON CONFLICT 조항</target>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="translated">ON CONFLICT 절은 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; , &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 적용됩니다. ON CONFLICT 알고리즘은 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY 제약 조건&lt;/a&gt; 에는 적용되지 않습니다 . ROLLBACK, ABORT, FAIL, IGNORE 및 REPLACE의 5 가지 충돌 해결 알고리즘 중에서 선택할 수 있습니다. 기본 충돌 해결 알고리즘은 ABORT입니다. 이것이 의미하는 바입니다.</target>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="translated">여기에 설명 된 ON CONFLICT 절은 버전 3.0.0 (2004-06-18) 이전부터 SQLite의 일부입니다. &quot;ON CONFLICT&quot;라는 문구는 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT의&lt;/a&gt; 일부이며 버전 3.24.0 (2018-06-04)에 추가 된 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 의 확장 입니다. &quot;ON CONFLICT&quot;문구의이 두 가지 용도를 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="translated">ON CONFLICT 절은 다른 많은 SQL 명령에 나타날 수있는 SQLite에 특정한 비표준 확장입니다. 이 문서는 표준 SQL의 일부가 아니므로 친숙하지 않기 때문에이 문서에서 자체 섹션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="translated">SQLite 데이터베이스의 각 외래 키와 관련된 ON DELETE 및 ON UPDATE 작업은 &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot;또는 &quot;CASCADE&quot;중 하나입니다. 조치가 명시 적으로 지정되지 않은 경우 기본값은 &quot;NO ACTION&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">내부 조인의 ON 및 USING 절은 위에서 단락 1.0에서 설명한 WHERE 절 분석 전에 WHERE 절의 추가 조건으로 변환됩니다. 따라서 SQLite의 경우 이전 SQL89 쉼표 결합 구문보다 새로운 SQL92 결합 구문을 사용하면 계산상의 이점이 없습니다. 둘 다 내부 조인에서 정확히 같은 것을 달성합니다.</target>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">OR 연산자 는 두 문서 세트의 &lt;b&gt;합집합&lt;/b&gt; 을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="translated">ORDER BY LIMIT 최적화는 가장 안쪽 IN 연산자 루프가 실제로 쿼리 계획에 의해 사용되지 않는 한 유효하지 않습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="translated">ORDER BY LIMIT 최적화는 쿼리 최적화 프로그램의 사소한 결함의 합류로 인해 매우 모호한 상황에서 준비된 명령문의 바이트 코드에서 무한 루프를 발생시킬 수 있습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt; 수정</target>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에 대한 ORDER BY 및 LIMIT 절 은 지원되지 않습니다. ORDER BY 및 LIMIT는 일반적으로 모든 컨텍스트에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 에 대해 지원되지 않지만 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 타임 옵션을 사용하여 최상위 레벨 명령문에 사용할 수 있습니다 . 그러나 컴파일 시간 옵션 은 트리거 내의 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문이 아닌 최상위 레벨 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">DELETE 문의 ORDER BY 절은 LIMIT 내에 속하는 행을 판별하는 데만 사용됩니다. 행이 삭제되는 순서는 임의적이며 ORDER BY 절의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">UPDATE 문의 ORDER BY 절은 LIMIT에 속하는 행을 판별하는 데만 사용됩니다. 행이 수정되는 순서는 임의적이며 ORDER BY 절의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="translated">&quot;VFS&quot;라고도하는 OS 인터페이스는 운영 체제에서 SQLite를 이식 가능하게 만드는 것입니다. SQLite의 다른 모듈이 운영 체제와 통신해야 할 때마다 VFS에서 메소드를 호출합니다. 그런 다음 VFS는 요청을 충족시키는 데 필요한 운영 관련 코드를 호출합니다. 따라서 SQLite를 새로운 운영 체제로 포팅하는 것은 단순히 새로운 OS 인터페이스 계층 또는 &quot;VFS&quot;를 작성하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="translated">OS 인터페이스 계층이 완전히 재 작업되었습니다.</target>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="translated">OVER 절은 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능에&lt;/a&gt; 필요하며 그렇지 않으면 금지됩니다. DISTINCT 키워드는 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; 에서만 사용할 수 있습니다 . FILTER 절은 &lt;a href=&quot;lang_corefunc&quot;&gt;간단한 함수&lt;/a&gt; 에 나타나지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">OpenDocument 파일 형식은 워드 프로세서, 스프레드 시트 및 프리젠 테이션과 같은 사무용 응용 프로그램에 사용됩니다. 원래 OpenOffice 제품 군용으로 설계되었지만 이후 다른 데스크톱 응용 프로그램 제품군에 통합되었습니다. OpenOffice 응용 프로그램이 몇 번 분기되어 이름이 변경되었습니다. OpenDocument에 대한이 저자의 주요 용도는 &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice (&lt;/a&gt; Mac) 또는 &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice (&lt;/a&gt; Linux 및 Windows)를 사용하여 슬라이드 프레젠테이션을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a12f97809890d0843d3b379960cdb5a48586d66d" translate="yes" xml:space="preserve">
          <source>The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array of 2*N pointers to strings. Each pair of pointers in this array corresponds to a key and value for a query parameter. The P parameter may be a NULL pointer if N is zero. None of the 2*N pointers in the P array may be NULL pointers and key pointers should not be empty strings. None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may be NULL pointers, though they can be empty strings.</source>
          <target state="translated">sqlite3_create_filename (D, J, W, N, P)의 P 매개 변수는 문자열에 대한 2 * N 포인터의 배열이어야합니다. 이 배열의 각 포인터 쌍은 쿼리 매개 변수의 키와 값에 해당합니다. N이 0이면 P 매개 변수는 NULL 포인터가 될 수 있습니다. P 배열의 2 * N 포인터는 NULL 포인터가 될 수 없으며 키 포인터는 빈 문자열이 아니어야합니다. sqlite3_create_filename (D, J, W, N, P)에 대한 D, J 또는 W 매개 변수는 비어있는 문자열 일 수 있지만 NULL 포인터가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="translated">P1 커서는 의사 테이블이 아니라 실제 테이블 용이어야합니다. P1이 열려 있지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="translated">P1 커서는 의사 테이블이 아닌 실제 테이블 용이어야합니다. 이 opcode 이전에 P1이 열려 있어야합니다. 그렇지 않으면 프로그램이 segfault입니다.</target>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="translated">P1 매개 변수는이 opcode에서 실제로 사용되지 않습니다. 그러나이 &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; 는 루프의 맨 아래이며 P2에서 현재 행까지의 행은 EXPLAIN 출력을 위해 들여 쓰기되어야한다는 명령 행 쉘에 대한 힌트로 때때로 0 대신 1로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="translated">명령 11의 P3 주장은 특히 중요하다. 정렬 키는 P3에서 각 문자열 앞에 한 문자를 추가하고 모든 문자열을 연결하여 구성됩니다. 정렬 비교 기능은이 문자를보고 정렬 순서가 오름차순인지 내림차순인지, 문자열 또는 숫자로 정렬 할지를 결정합니다. 이 예에서 첫 번째 열은 내림차순으로 문자열로 정렬되어야하며 접두사가 &quot;D&quot;이고 두 번째 열은 숫자가 오름차순으로 정렬되어 접두사가 &quot;+&quot;입니다. 오름차순 문자열 정렬은 &quot;A&quot;를 사용하고 내림차순 숫자 정렬은 &quot;-&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="translated">P3 값은 btree 구현에 대한 힌트입니다. P3 == 1이면 P1이 SQL 인덱스이고 해당 인덱스가 고유 한 경우이 명령어를 생략했을 수 있습니다. P3은 일반적으로 0입니다. P3은 항상 0 또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="translated">P3으로 시작하는 P4 레지스터 값은 PRIMARY KEY 또는 ROWID를 생략하는 압축 해제 된 인덱스 키를 형성합니다. P1 인덱스의 PRIMARY KEY 또는 ROWID를 무시하고 P1이 현재 가리키는 인덱스와이 키 값을 &lt;a href=&quot;opcode#Compare&quot;&gt;비교하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="translated">P3으로 시작하는 P4 레지스터 값은 PRIMARY KEY를 생략하는 압축 해제 된 인덱스 키를 형성합니다. 마지막에 PRIMARY KEY 또는 ROWID 필드를 무시하고 P1이 현재 가리키는 인덱스와이 키 값을 &lt;a href=&quot;opcode#Compare&quot;&gt;비교하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="translated">P4 값은 정수 (P4_INT32) 또는 KeyInfo 구조에 대한 포인터 (P4_KEYINFO) 일 수 있습니다. KeyInfo 오브젝트에 대한 포인터 인 경우, 열려있는 테이블은 &lt;a href=&quot;fileformat2#btypes&quot;&gt;인덱스 b- 트리&lt;/a&gt; 여야하며 KeyInfo 오브젝트는 해당 인덱스 b- 트리의 컨텐츠 및 조합 순서를 정의합니다. 그렇지 않으면 P4가 정수 값인 경우 열려는 &lt;a href=&quot;fileformat2#btypes&quot;&gt;테이블&lt;/a&gt; 은 P4 값 이상의 열 이있는 테이블 b- 트리 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="translated">P5 인수는 레지스터 P2와 그 후속 장치에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="translated">P5 매개 변수는 btree.h에 정의 된 BTREE_ * 플래그의 마스크 일 수 있습니다. 이 플래그는 btree 작업의 측면을 제어합니다. BTREE_OMIT_JOURNAL 및 BTREE_SINGLE 플래그가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">PERSIST 저널링 모드는 각 트랜잭션이 끝날 때 롤백 저널이 삭제되는 것을 방지합니다. 대신 저널의 머리글을 0으로 덮어 씁니다. 이렇게하면 다른 데이터베이스 연결이 저널을 롤백하지 못하게됩니다. PERSIST 저널링 모드는 파일을 삭제하거나 자르는 것이 파일의 첫 번째 블록을 0으로 덮어 쓰는 것보다 훨씬 비싼 플랫폼에서 최적화하는 데 유용합니다. &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; 및 &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="translated">PLINK 테이블은 체크인 간의 상위-하위 관계를 보유합니다. TAGXREF 테이블은 태그를 체크인에 매핑합니다. 참고로이 두 테이블에 대한 스키마의 관련 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="translated">PRAGMA 문은 SQLite에 고유 한 SQL 확장이며 SQLite 라이브러리의 조작을 수정하거나 내부 (테이블이 아닌) 데이터에 대한 SQLite 라이브러리를 조회하는 데 사용됩니다. PRAGMA 문은 다른 SQLite 명령 (예 : &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ) 과 동일한 인터페이스를 사용하여 발행 되지만 다음과 같은 중요한 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="translated">PRAGMA synchronous = off 문은 이제 일반 롤백 저널 외에 마스터 저널 파일의 동기화를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="translated">rowid 테이블에 대한 PRIMARY KEY 제약 조건 (실제 기본 키 또는 INTEGER PRIMARY KEY가 아닌 한)은 실제로 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건&lt;/a&gt; 과 동일 합니다 . 실제 기본 키가 아니기 때문에 PRIMARY KEY의 열은 모든 SQL 표준을 위반하여 NULL이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="translated">수정 된 행을 식별하는 PRIMARY KEY 값</target>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="translated">페이지 캐시</target>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="translated">사용 된 PostgreSQL 및 MySQL 서버는 기본적으로 RedHat 7.2에서 제공되었습니다. (PostgreSQL 버전 7.1.3 및 MySQL 버전 3.23.41) 이러한 엔진을 조정하려는 노력은 없었습니다. 특히 RedHat 7.2의 기본 MySQL 구성은 트랜잭션을 지원하지 않습니다. 트랜잭션을 지원하지 않아도 MySQL은 큰 속도 이점을 제공하지만 SQLite는 여전히 대부분의 테스트에서 자체적으로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="translated">PutIntKey 명령 (INSERT에 대한 설명 중에도 설명 됨)은 데이터가 스택의 최상위이고 키가 스택의 다음 키인 데이터베이스 파일에 항목을 쓴 다음 스택을 두 번 팝합니다. PutIntKey 명령어는 기존 레코드의 데이터를 동일한 키로 덮어 씁니다. INSERT를 사용하면 이전에 사용되지 않은 키를 제공하도록 보장 된 NewRecno 명령에 의해 키가 생성 되었기 때문에 INSERT에서는 덮어 쓰기가 문제가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="translated">QPSG는 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일시 또는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; , 1,0) 를 호출하여 런타임에 사용 가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="translated">QPSG는 테스트 중에 모든 쿼리가 효율적으로 실행되고 응용 프로그램이 스키마를 변경하지 않으면 SQLite가 다른 쿼리 계획을 사용하여 갑자기 시작하지 않기 때문에 응용 프로그램이 릴리스 된 후에 성능 문제가 발생할 수 있음을 의미합니다. 사용자. 응용 프로그램이 랩에서 작동하는 경우 배포 후에도 같은 방식으로 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="translated">R-Tree 개념은 &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt; 에서 시작되었습니다 . &lt;em&gt;R-Trees : 공간 검색을위한 동적 인덱스 구조&lt;/em&gt; , Proc. 1984 ACM SIGMOD 국제 데이터 관리 회의, pp. 47-57. SQLite에서 구현 된 구현은 Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger : &lt;em&gt;R *&lt;/em&gt; -Tree &lt;em&gt;: 효율적이고 강력한 액세스에&lt;/em&gt; 의해 설명 된 Guttman의 원래 아이디어를 일반적으로 &quot;R * Trees&quot;로 개선 한 것입니다. &lt;em&gt;점과 사각형의 방법. &lt;/em&gt;SIGMOD Conference 1990 : 322-331.</target>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="translated">RAISE () 함수</target>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="translated">RBU 확장</target>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="translated">RBU 데이터베이스 테이블에는 업데이트에 의해 삽입, 업데이트 또는 삭제 된 각 대상 데이터베이스 행에 대한 단일 행이 포함됩니다. RBU 데이터베이스 테이블 채우기는 &lt;a href=&quot;rbu#database_contents&quot;&gt;다음 섹션&lt;/a&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="translated">RBU 확장 인터페이스를 통해 응용 프로그램은 RBU 데이터베이스에 저장된 RBU 업데이트를 기존 대상 데이터베이스에 적용 할 수 있습니다. 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="translated">RBU 확장은 네트워크 에지의 저전력 장치에서 대용량 SQLite 데이터베이스 파일과 함께 사용하도록 설계된 SQLite 용 애드온입니다. RBU는 두 가지 별도의 작업에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="translated">RBU 확장은 기본적으로 활성화되어 있지 않습니다. 이를 가능하게하려면 &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; 컴파일 시간 옵션을 사용하여 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 을 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="translated">RBU 업데이트는 외래 키 또는 CHECK 제약 조건 위반을 감지하거나 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="translated">RBU 업데이트는 트리거를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6564cc776de2c808e8f2b66fc117a6728b91dc4" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP 연산자는 regexp () 사용자 함수에 대한 특수 구문입니다. 기본적으로 regexp () 사용자 함수가 정의되어 있지 않으므로 REGEXP 연산자를 사용하면 일반적으로 오류 메시지가 표시됩니다. 경우 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; &quot;정규 표현식&quot;라는 이름은 실행시, 다음을 &quot;추가</target>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP 연산자는 regexp () 사용자 함수의 특수 구문입니다. regexp () 사용자 함수는 기본적으로 정의되어 있지 않으므로 REGEXP 연산자를 사용하면 일반적으로 오류 메시지가 나타납니다. 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; &quot;정규 표현식&quot;라는 이름은 실행시, 다음을 &quot;추가</target>
        </trans-unit>
        <trans-unit id="f6504d5094ffa58be5ab1ac79df65f0b1aba5e47" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed, or when there are &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; involving a function whose definition has changed.</source>
          <target state="translated">REINDEX 명령은 인덱스를 처음부터 삭제하고 다시 만드는 데 사용됩니다. 이는 데이터 정렬 시퀀스의 정의가 변경되었거나 정의가 변경된 함수를 포함하는 &lt;a href=&quot;expridx&quot;&gt;표현식에 인덱스&lt;/a&gt; 가있을 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="translated">REINDEX 명령은 인덱스를 처음부터 삭제하고 다시 작성하는 데 사용됩니다. 데이터 정렬 순서의 정의가 변경된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="translated">REINDEX 명령이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">RELEASE 명령은 SAVEPOINT에 대한 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 와 같습니다 . RELEASE 명령은 이름이 일치하는 가장 최근의 저장 점을 포함하여 모든 저장 점이 트랜잭션 스택에서 제거되도록합니다. 내부 트랜잭션의 릴리스는 데이터베이스 파일에 변경 사항을 기록하지 않습니다. 더 이상 해당 저장 점으로 롤백 할 수 없도록 트랜잭션 스택에서 저장 점을 제거합니다. RELEASE 명령이 가장 바깥 쪽 저장 점을 해제하여 트랜잭션 스택이 비게되면 RELEASE는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 와 같습니다 . &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령은 모든 세이브 포인트를 해제하고 트랜잭션이 원래 대신이의 SAVEPOINT 명령에 의해 시작된 경우에도 트랜잭션을 커밋하기 위해 사용될 수있다 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="translated">RELEASE 명령은 트랜잭션 스택에 가장 최근에 추가 된 것으로 시작하여 저장 점 이름이 일치하는 저장 점을 해제 할 때까지 저장 점을 뒤로 되돌립니다. 이전 세이브 포인트, 심지어 세이브 포인트 이름이 일치하는 세이브 포인트도 변경되지 않습니다. RELEASE 명령으로 인해 트랜잭션 스택이 비게되면 (RELEASE 명령이 스택에서 가장 바깥 쪽 트랜잭션을 해제하면) 트랜잭션이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="translated">RENAME COLUMN TO 구문은 table-name 테이블의 column-name을 new-column-name으로 변경합니다. 열 이름은 테이블 정의 자체와 열을 참조하는 모든 인덱스, 트리거 및보기 내에서 변경됩니다. 컬럼 이름 변경으로 인해 트리거 또는보기에서 의미 상 모호성이 발생하는 경우 RENAME COLUMN이 오류와 함께 실패하고 변경 사항이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="translated">RENAME TO 구문은 table-name의 이름을 new-table-name으로 변경합니다. 이 명령은 연결된 데이터베이스간에 테이블을 이동하는 데 사용할 수 없으며 동일한 데이터베이스 내에서 테이블 이름을 바꾸는 데만 사용됩니다. 이름을 바꾼 테이블에 트리거 또는 인덱스가있는 경우 이름을 바꾼 후에도 테이블에 연결된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="translated">REPLACE 명령은 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 명령 의 &quot; &lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt; &quot;변형에 대한 별명입니다 . 이 별명은 다른 SQL 데이터베이스 엔진과의 호환성을 위해 제공됩니다. 추가 정보 는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 명령 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="translated">ROLLBACK TO 명령은 데이터베이스 상태를 해당 SAVEPOINT 바로 다음 상태로 되돌립니다. TO 키워드없이 일반 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령 과 달리 ROLLBACK TO 명령은 트랜잭션을 취소하지 않습니다. 트랜잭션을 취소하는 대신 ROLLBACK TO 명령은 처음에 트랜잭션을 다시 시작합니다. 그러나 모든 개입 SAVEPOINT는 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="translated">TO 절이있는 ROLLBACK 명령은 시간이 지난 트랜잭션을 일치하는 이름을 가진 가장 최근의 SAVEPOINT로 롤백합니다. 이름이 일치하는 SAVEPOINT는 트랜잭션 스택에 유지되지만 해당 SAVEPOINT가 작성된 후 발생한 모든 데이터베이스 변경 사항은 롤백됩니다. ROLLBACK TO 명령의 저장 점 이름이 스택의 SAVEPOINT와 일치하지 않으면 ROLLBACK 명령이 오류와 함께 실패하고 데이터베이스 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="translated">ROWS 및 GROUPS 프레임 유형은 현재 행을 기준으로 계산하여 프레임 범위를 결정한다는 점에서 비슷합니다. 차이점은 ROWS는 개별 행을 계산하고 GROUPS는 피어 그룹을 계산한다는 것입니다. RANGE 프레임 유형이 다릅니다. RANGE 프레임 유형은 현재 행을 기준으로 일부 값 범위 내에있는 표현식 값을 찾아 프레임의 범위를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="translated">Robson 증명은 SQLite에서 사용하는 각 메모리 할당 자에 별도로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="translated">RowSet 객체는 정수 세트가 별개의 단계로 삽입되는 경우에 최적화되며, 각 세트에는 중복이 없습니다. 각 세트는 고유 한 P4 값으로 식별됩니다. 첫 번째 세트는 P4 == 0이어야하고 마지막 세트는 P4 ==-1이어야하고 다른 모든 세트의 경우 P4&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="translated">SAVEPOINT 명령은 이름으로 새 트랜잭션을 시작합니다. 트랜잭션 이름은 고유하지 않아도됩니다. SAVEPOINT는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 내부 또는 외부에서 시작할 수 있습니다 . SAVEPOINT가 가장 바깥쪽에있는 저장 점이고 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 이 아닌 경우 ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 동작은 BEGIN DEFERRED TRANSACTION과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 ZIPVFS 백엔드를 조사하는 경우를 제외하고 SCHEMA 컬럼은 NULL 입니다. memstat.c 모듈이 -DSQLITE_ENABLE_ZIPVFS로 컴파일 될 때와&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt; ZIPVFS&lt;/a&gt; 가 사용중인 에만 SCHEMA가 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="translated">SELECT는 친숙한 방식으로 시작됩니다. 먼저 열 이름이 초기화되고 쿼리중인 테이블이 열립니다. 색인 파일도 열리는 지침 5 및 6부터 상황이 달라집니다. 명령어 7과 8은 값이 50 인 키를 만듭니다. 9 의 &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; 명령어는 인덱스 키를 VDBE 메모리 위치 0에 저장합니다. VDBE 메모리는 스택의 깊은 곳에서 값을 가져올 필요가 없도록하기 위해 사용됩니다. 프로그램을 생성하기 어렵게 만듭니다. 주소 10의 &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; 명령 은 스택에서 키를 팝하고 인덱스 키를 해당 키가있는 인덱스의 첫 번째 행으로 이동합니다. 이것은 다음 루프에서 사용하기 위해 커서를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="translated">SELECT 문은 SQL 언어에서 가장 복잡한 명령입니다. 설명을보다 쉽게 ​​수행 할 수 있도록 아래 문장 중 일부는 SELECT 문에서 반환 한 데이터가 일련의 단계로 결정되는 방식을 설명합니다. 이것은 단지 설명을위한 것이라는 점을 명심해야합니다. 실제로 SQLite 나 다른 SQL 엔진이이 프로세스 나 다른 특정 프로세스를 따를 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="translated">SELECT 문은 데이터베이스를 쿼리하는 데 사용됩니다. SELECT의 결과는 각 행에 고정 된 수의 열이있는 0 개 이상의 데이터 행입니다. SELECT 문은 데이터베이스를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="translated">왼쪽의 SELECT 문은 '0'과 '0.0'이 숫자로 취급되므로 구별되지 않기 때문에 단일 행을 반환합니다. 그러나 0과 0.0은 다른 문자열로 취급되므로 오른쪽의 SELECT 문은 두 개의 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="translated">SQL 명령 &quot;BEGIN TRANSACTION&quot;(TRANSACTION 키워드는 선택 사항)은 SQLite를 자동 커미트 모드에서 해제하는 데 사용됩니다. BEGIN 명령은 데이터베이스에 대한 잠금을 획득하지 않습니다. BEGIN 명령 후 첫 번째 SELECT 문이 실행될 때 SHARED 잠금이 획득됩니다. 첫 번째 INSERT, UPDATE 또는 DELETE 문이 실행될 때 RESERVED 잠금이 획득됩니다. 메모리 캐시가 가득 차서 디스크에 쏟아 지거나 트랜잭션이 커밋 될 때까지 독점 잠금은 확보되지 않습니다. 이런 방식으로 시스템은 파일 파일에 대한 읽기 액세스 차단을 마지막 순간까지 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="translated">SQL 명령 &quot;COMMIT&quot;은 실제로 변경 사항을 디스크에 커밋하지 않습니다. 자동 커밋이 다시 켜집니다. 그런 다음 명령이 완료되면 일반 자동 커밋 논리가 인계하여 실제 디스크 커밋이 발생합니다. SQL 명령 &quot;ROLLBACK&quot;도 자동 커밋을 다시 설정하여 작동하지만 자동 커밋 논리에 커밋이 아니라 롤백하도록 지시하는 플래그도 설정합니다.</target>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="translated">SQL 퍼지 생성기 테스트는 TCL 테스트 스위트의 일부입니다. 전체 테스트 실행 중에 약 111.3 천 개의 퍼즈 SQL 문이 생성 및 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="translated">SQL 언어에는 표현식이 평가되고 결과가 부울 (true 또는 false) 값으로 변환되는 여러 컨텍스트가 있습니다. 이러한 맥락은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="translated">SQL 언어는 &quot;표준&quot;입니다. 그럼에도 불구하고 두 개의 SQL 데이터베이스 엔진이 정확히 동일하게 작동하지는 않습니다. 모든 SQL 구현에는 고유 한 특성과 이상한 점이 있으며 SQLite도이 규칙에서 예외가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="translated">SQL 언어는 키워드가 풍부합니다. 대부분의 SQL 구현에서는 키워드를 큰 따옴표로 묶지 않으면 키워드를 식별자 (테이블 또는 열 이름)로 사용할 수 없습니다. 그러나 SQLite는 더 유연합니다. 많은 키워드는 식별자가 될 의도가있는 상황에서 사용되는 한 따옴표없이 식별자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="translated">SQL 언어는 매우 강력하므로 악의적 인 SQL 입력 (또는 응용 프로그램 버그로 인한 잘못된 SQL 입력)이 매우 오랫동안 실행되는 SQL을 제출할 수 있습니다. 이것이 서비스 거부 공격이되지 않도록하려면 &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; 인터페이스를 사용하여 각 SQL 문이 실행될 때 주기적으로 콜백을 호출하고 명령문이 너무 오래 실행되면 명령문이 중단되도록 콜백이 0이 아닌 값을 리턴하도록 고려하십시오. . 또는 별도의 스레드에서 타이머를 설정 하고 타이머가 꺼질 때 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()를&lt;/a&gt; 호출 하여 SQL 문이 영원히 실행되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="translated">SQLite 용 SQL 언어 파서는 &quot;Lemon&quot;이라는 코드 생성기 프로그램을 사용하여 생성됩니다. 레몬 프로그램은 입력 언어의 문법을 읽고 해당 언어에 대한 파서를 구현하기 위해 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 에서 생성 된 SQL 출력 이 이제 &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; 값을 포함하도록 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="translated">위 예제의 SQL 쿼리는이 섹션의 첫 번째 예제보다 적은 CPU를 사용하지만 여전히 명백한 성능 문제가 있습니다. SQLite는 결과를 정렬하고 제한하기 전에 사용자 쿼리와 일치하는 모든 행에 대해 FTS 모듈에서 &quot;title&quot;열 및 matchinfo 데이터의 값을 검색하여이 쿼리를 충족시킵니다. SQLite의 가상 테이블 인터페이스가 작동하는 방식으로 인해 &quot;title&quot;열의 값을 검색하려면 디스크에서 전체 행을로드해야합니다 ( &quot;content&quot;필드 포함). 즉, 사용자 쿼리가 수천 개의 문서와 일치하는 경우 어떤 목적으로도 사용되지 않더라도 디스크에서 메모리로 메가 바이트의 &quot;제목&quot;및 &quot;콘텐츠&quot;데이터를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="translated">다음 예제 블록의 SQL 쿼리는이 문제에 대한 한 가지 해결책입니다. SQLite &lt;a href=&quot;optoverview#flattening&quot;&gt;에서 조인에 사용 된 하위 쿼리에 LIMIT 절이 포함되어 있으면&lt;/a&gt; 기본 쿼리가 실행되기 전에 하위 쿼리의 결과가 임시 테이블에 계산되어 저장됩니다. 즉, SQLite는 사용자 쿼리와 일치하는 각 행의 docid 및 matchinfo 데이터 만 메모리에로드하고 가장 관련성이 높은 10 개의 문서에 해당하는 docid 값을 결정한 다음 해당 10 개의 문서에 대한 제목 및 내용 정보 만로드합니다. matchinfo 및 docid 값이 전체 텍스트 인덱스에서 완전히 수집되므로 데이터베이스에서 메모리로로드되는 데이터가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="translated">SQL 표준에는 식별자 주위에 큰 따옴표가 필요하고 문자열 리터럴에는 작은 따옴표가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="translated">SQL 표준에서는 제약 조건의 하나 이상의 열이 NULL 인 경우에도 UNIQUE 제약 조건을 적용해야하지만 SQLite는이를 수행하지 않습니다. 그게 버그 아니야?</target>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="translated">SQL 표준은 테이블, 인덱스, 열, 데이터베이스, 사용자 정의 함수, 데이터 정렬, 가상 테이블 모듈 또는 기타 이름 지정된 오브젝트의 이름으로 사용되지 않을 수있는 많은 키워드를 지정합니다. 키워드 목록이 너무 길어서 모든 사람을 기억할 수있는 사람은 거의 없습니다. 대부분의 SQL 코드에서 가장 안전한 방법은 영어 단어를 사용자 정의 개체의 이름으로 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="translated">SQL 표준은 두 개의 작은 따옴표를 한 줄에 넣어 문자열의 작은 따옴표를 이스케이프하도록 지정합니다. SQL은 이와 관련하여 Pascal 프로그래밍 언어와 같이 작동합니다. 예:</target>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="translated">SQL 문은 sqlite3_prepare ()에 대한 UTF-8 문자열입니다. sqlite3_prepare16 ()은 UTF-16 문자열을 SQL 입력으로 예상한다는 점을 제외하고는 동일한 방식으로 작동합니다. 입력 문자열의 첫 번째 SQL 문만 컴파일됩니다. 다섯 번째 매개 변수는 입력 문자열에서 다음 (컴파일되지 않은) SQLite 문에 대한 포인터로 채워집니다 (있는 경우). sqlite3_finalize () 루틴은 준비된 SQL 문을 할당 해제합니다. 데이터베이스를 닫기 전에 준비된 모든 명령문을 완료해야합니다. sqlite3_reset () 루틴은 준비된 SQL 문을 재설정하여 다시 실행할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="translated">SQL 문은 &quot;?&quot;형식의 토큰을 포함 할 수 있습니다. 또는 &quot;? nnn&quot;또는 &quot;: aaa&quot;. 여기서 &quot;nnn&quot;은 정수이고 &quot;aaa&quot;는 식별자입니다. 이러한 토큰은 나중에 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; 인터페이스 로 채워질 지정되지 않은 리터럴 값 (또는 &quot;와일드 카드&quot;)을 나타냅니다 . 각 와일드 카드에는 &quot;? nnn&quot;형식의 경우 문 또는 &quot;nnn&quot;의 순서와 관련된 번호가 있습니다. 동일한 SQL 문에서 동일한 와일드 카드가 두 번 이상 발생할 수 있으며,이 경우 해당 와일드 카드의 모든 인스턴스가 동일한 값으로 채워집니다. 언 바운드 와일드 카드의 값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="translated">CREATE VIRTUAL TABLE 문에 인수로 제공된 SQL 문은 테이블이 작성 될 때 실행됩니다. 4 개 또는 5 개의 열을 반환해야합니다. 리턴 된 각 행은 구성 요소 테이블 중 하나를 설명합니다. 처음 네 개의 열은 처음부터 끝까지 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="translated">SQLite Archive 작업을 구현하는 데 사용되는 SQL 문은 다양한 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장을&lt;/a&gt; 사용 합니다 . 이 확장은 모두 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc / 하위 폴더&lt;/a&gt; 의 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite 소스 트리&lt;/a&gt; 에서 사용할 수 있습니다 . 완전한 SQLite Archive 지원에 필요한 확장 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="translated">사용자 정의 조회에 대한 SQL 구문은 SQL 함수를 등록하는 데 사용되는 sqlite3_rtree_geometry_callback () 또는 sqlite3_rtree_query_callback () 인터페이스에 관계없이 동일합니다. 그러나 새로운 쿼리 스타일 콜백을 사용하면 응용 프로그램에서 쿼리 진행 방식을보다 효과적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="translated">SQL : 1999 스펙에서는 RECURSIVE 키워드가 재귀 공통 테이블 표현식을 포함하는 WITH 절에서 WITH 뒤에 와야합니다. 그러나 SqlServer 및 Oracle과의 호환성을 위해 SQLite는이 규칙을 시행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_ABORT 결과 코드는 작업이 완료되기 전에 중단되었으며 대개 응용 프로그램 요청임을 나타냅니다. &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="translated">SQLITE_ABORT_ROLLBACK 오류 코드는 SQLITE_ABORT에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 로 , SQL 문을 처음 시작할 때 활성화 된 트랜잭션이 롤백 &lt;a href=&quot;rescode#abort&quot;&gt;되었으므로&lt;/a&gt; SQL 문이 중단되었음을 나타냅니다. 롤백이 발생하면 보류중인 쓰기 작업이 항상이 오류와 함께 실패합니다. &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK은&lt;/a&gt; 스키마가 트랜잭션이 롤백 내에서 변경된 경우 보류중인 읽기 작업은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="translated">P5의 SQLITE_AFF_MASK 부분은 선호도 문자 (SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER 등) 여야합니다. 비교하기 전에이 선호도에 따라 두 입력을 강제하려고 시도합니다. SQLITE_AFF_MASK가 0x00이면 숫자 선호도가 사용됩니다. 선호도 변환은 입력 레지스터 P1 및 P3에 다시 저장됩니다. 따라서이 opcode는 레지스터 P1 및 P3을 지속적으로 변경시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자 콜백&lt;/a&gt; 이 준비중인 SQL 문에 권한이 없음을 표시 하면 SQLITE_AUTH 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="translated">에서 SQLITE_BUSY 결과 코드 다릅니다 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 그 SQLITE_BUSY에서 별도의와의 충돌이 발생 함을 의미&lt;a href=&quot;c3ref/sqlite3&quot;&gt; 데이터베이스 연결을&lt;/a&gt; 하는 반면, 아마도 별도의 프로세스에서, &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED이&lt;/a&gt; 같은 내 충돌을 나타냅니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (때로는 나와 데이터베이스 연결 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="translated">SQLITE_BUSY 결과 코드는 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (일반적으로 별도 프로세스의 데이터베이스 연결)에 의한 동시 활동으로 인해 데이터베이스 파일을 쓸 수 없거나 일부 경우 읽을 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="translated">SQLITE_BUSY_RECOVERY 오류 코드는 다음에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다.&lt;a href=&quot;rescode#busy&quot;&gt;&lt;/a&gt; 충돌 후 다른 프로세스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 파일을 복구 중이므로 조작을 계속할 수 없음을 나타내는 SQLITE_BUSY . SQLITE_BUSY_RECOVERY 오류 코드는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="translated">SQLITE_BUSY_SNAPSHOT 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 데이터베이스 연결이 읽기 트랜잭션을 쓰기 트랜잭션으로 승격하려고 시도하지만 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 이미 데이터베이스에 기록되어 이전 읽기를 무효화 할 때 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서 발생하는 .</target>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CANTOPEN 결과 코드는 SQLite가 파일을 열 수 없음을 나타냅니다. 문제의 파일은 기본 데이터베이스 파일이거나 여러 &lt;a href=&quot;tempfiles&quot;&gt;임시 디스크 파일&lt;/a&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="translated">SQLITE_CANTOPEN_CONVPATH 오류 코드는 Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서만 사용되는 &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다. 파일을 열려는 동안 cygwin_conv_path () 시스템 호출이 실패했음을 나타냅니다. 참조 : &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="translated">현재 SQLITE_CANTOPEN_DIRTYWAL 결과 코드는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="translated">SQLITE_CANTOPEN_FULLPATH 오류 코드는 다음에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다.&lt;a href=&quot;rescode#cantopen&quot;&gt;&lt;/a&gt; 운영 체제에서 파일 이름을 전체 경로 이름으로 변환 할 수 없어 파일 열기 작업이 실패했음을 나타내는 SQLITE_CANTOPEN에 .</target>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="translated">SQLITE_CANTOPEN_ISDIR 오류 코드는 SQLITE_CANTOPEN에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 &lt;a href=&quot;rescode#cantopen&quot;&gt;.&lt;/a&gt; 파일이 실제로 디렉토리이므로 파일 열기 조작이 실패했음을 나타내는 .</target>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="translated">SQLITE_CANTOPEN_NOTEMPDIR 오류 코드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="translated">SQLITE_CHECKPOINT_FULL, RESTART 및 TRUNCATE 모드는 데이터베이스 파일에 대한 독점적 인 &quot;기록기&quot;잠금도 얻습니다. 작성기 잠금을 즉시 확보 할 수없고 사용 중 핸들러를 구성한 경우, 호출자가 처리되고 사용 중 처리기가 0을 리턴하거나 잠금이 성공적으로 확보 될 때까지 작성기 잠금을 재 시도합니다. 사용중인 핸들러는 또한 위에서 설명한대로 데이터베이스 리더를 기다리는 동안 호출됩니다. 작성기 잠금을 확보하기 전에 또는 데이터베이스 리더를 기다리는 동안 사용 중 핸들러가 0을 리턴하면, 검사 점 조작은 SQLITE_CHECKPOINT_PASSIVE와 동일한 방식으로 해당 지점에서 진행됩니다. 이 경우 SQLITE_BUSY가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN 옵션은 단일 정수 인수를 사용하여 쿼리 최적화 프로그램에서 전체 테이블 스캔에 대한 커버링 인덱스 사용을 활성화 또는 비활성화하기 위해 부울로 해석됩니다. 기본 설정은 &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; 컴파일 시간 옵션에 의해 결정 되거나 컴파일 시간 옵션이 생략되면 &quot;on&quot;입니다. 전체 테이블 스캔에 인덱스 적용을 사용하지 않는 기능은 최적화가 사용 가능한 경우 잘못 코딩 된 일부 레거시 애플리케이션이 오작동 할 수 있기 때문입니다. 최적화를 비활성화 할 수있는 기능을 제공하면 최신 버전의 SQLite에서도 오래된 버그가있는 응용 프로그램 코드를 변경하지 않고도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN 옵션은 단일 정수 인수를 사용하여 쿼리 최적화 프로그램에서 전체 테이블 스캔에 대한 커버링 인덱스 사용을 활성화 또는 비활성화하기 위해 부울로 해석됩니다. 기본 설정은 &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; 컴파일 시간 옵션에 의해 결정 되거나 컴파일 시간 옵션이 생략되면 &quot;on&quot;입니다. 전체 테이블 스캔에 인덱스 적용을 사용하지 않는 기능은 최적화가 사용 가능한 경우 잘못 코딩 된 일부 레거시 애플리케이션이 오작동 할 수 있기 때문입니다. 최적화를 비활성화 할 수있는 기능을 제공하면 최신 버전의 SQLite에서도 오래된 버그가있는 응용 프로그램 코드를 변경하지 않고도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC 옵션은 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조는 현재 정의 된 메모리 할당 루틴들로 채워진다. 이 옵션을 사용하면 메모리 할당 실패를 시뮬레이션하거나 메모리 사용을 추적하는 래퍼로 기본 메모리 할당 루틴을 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC 옵션은 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods의&lt;/a&gt; 구조는 현재 정의 된 메모리 할당 루틴들로 채워진다. 이 옵션을 사용하면 메모리 할당 실패를 시뮬레이션하거나 메모리 사용을 추적하는 래퍼로 기본 메모리 할당 루틴을 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX 옵션은 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods의&lt;/a&gt; 구조는 현재 정의 된 뮤텍스 루틴 채워진다. 이 옵션은 예를 들어 성능 프로파일 링 또는 테스트를 위해 뮤텍스 사용을 추적하는 데 사용되는 래퍼로 기본 뮤텍스 할당 루틴을 오버로드하는 데 사용할 수 있습니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_GETMUTEX 구성 옵션을 사용하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX 옵션은 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods의&lt;/a&gt; 구조는 현재 정의 된 뮤텍스 루틴 채워진다. 이 옵션은 예를 들어 성능 프로파일 링 또는 테스트를 위해 뮤텍스 사용을 추적하는 데 사용되는 래퍼로 기본 뮤텍스 할당 루틴을 오버로드하는 데 사용할 수 있습니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_GETMUTEX 구성 옵션을 사용하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;../rescode#error&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2 옵션은 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 현재 페이지 캐시 구현의 SQLite 사본을 해당 오브젝트에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2 옵션은 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 현재 페이지 캐시 구현의 SQLite 사본을 해당 오브젝트에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP 옵션은 SQLite가 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에서&lt;/a&gt; 제공 한 것보다 모든 동적 메모리 할당 요구에 사용할 정적 메모리 버퍼를 지정합니다 . SQLite는이 중 하나를 컴파일하면 SQLITE_CONFIG_HEAP 옵션에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 그렇지 않으면 호출합니다. SQLITE_CONFIG_HEAP에 대한 세 가지 인수가 있습니다. 메모리에 대한 8 바이트 정렬 포인터, 메모리 버퍼의 바이트 수 및 최소 할당 크기. 첫 번째 포인터 (메모리 포인터)가 NULL이면 SQLite는 기본 메모리 할당 자 (시스템 malloc () 구현)를 사용하여 이전 호출을 취소합니다.&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt; SQLITE_CONFIG_MALLOC의&lt;/a&gt;. 메모리 포인터가 NULL이 아닌 경우 대체 메모리 할당자는 모든 SQLites 메모리 할당 요구를 처리하기 위해 사용됩니다. 첫 번째 포인터 (메모리 포인터)는 8 바이트 경계에 맞춰야합니다. 그렇지 않으면 후속 SQLite 동작이 정의되지 않습니다. 최소 할당 크기는 2 ** 12로 제한됩니다. 최소 할당 크기의 합리적인 값은 2 ** 5에서 2 ** 8입니다.</target>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP 옵션은 SQLite가 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에서&lt;/a&gt; 제공 한 것보다 모든 동적 메모리 할당 요구에 사용할 정적 메모리 버퍼를 지정합니다 . SQLite는이 중 하나를 컴파일하면 SQLITE_CONFIG_HEAP 옵션에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; 또는 &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; 반환 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 그렇지 않으면 호출합니다. SQLITE_CONFIG_HEAP에 대한 세 가지 인수가 있습니다. 메모리에 대한 8 바이트 정렬 포인터, 메모리 버퍼의 바이트 수 및 최소 할당 크기. 첫 번째 포인터 (메모리 포인터)가 NULL이면 SQLite는 기본 메모리 할당 자 (시스템 malloc () 구현)를 사용하여&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt; SQLITE_CONFIG_MALLOC의&lt;/a&gt; 이전 호출을 실행 취소합니다.. 메모리 포인터가 NULL이 아닌 경우 대체 메모리 할당자는 모든 SQLites 메모리 할당 요구를 처리하기 위해 사용됩니다. 첫 번째 포인터 (메모리 포인터)는 8 바이트 경계에 맞춰야합니다. 그렇지 않으면 후속 SQLite 동작이 정의되지 않습니다. 최소 할당 크기는 2 ** 12로 제한됩니다. 최소 할당 크기의 합리적인 값은 2 ** 5에서 2 ** 8입니다.</target>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG 옵션은 SQLite 전역 &lt;a href=&quot;../errlog&quot;&gt;오류 로그&lt;/a&gt; 를 구성하는 데 사용됩니다 . (SQLITE_CONFIG_LOG 옵션은 두 개의 인수, void (*) (void *, int, const char *)의 호출 서명이있는 함수에 대한 포인터와 void에 대한 포인터를 사용합니다. 함수 포인터가 NULL이 아닌 경우 호출됩니다. 각 로깅 이벤트를 처리하기 위해 &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 에 의해 함수 포인터가 NULL 인 경우, &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스는 no-op가되고 SQLITE_CONFIG_LOG에 대한 두 번째 인수 인 void 포인터는 애플리케이션 정의에 대한 첫 번째 매개 변수로 전달됩니다. 로거 함수에 대한 두 번째 매개 변수는 해당 &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 호출 . 에 대한 첫 번째 매개 변수의 사본 &lt;a href=&quot;../rescode&quot;&gt;결과 코드 &lt;/a&gt;이거나&lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; . 로거에 전달 된 세 번째 매개 변수는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통한 형식화 후 로그 메시지 입니다. SQLite 로깅 인터페이스는 재진입되지 않습니다. 응용 프로그램이 제공 한 로거 기능은 SQLite 인터페이스를 호출하지 않아야합니다. 다중 스레드 응용 프로그램에서 응용 프로그램 정의 로거 기능은 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG 옵션은 SQLite 전역 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 를 구성하는 데 사용됩니다 . (SQLITE_CONFIG_LOG 옵션은 두 개의 인수, void (*) (void *, int, const char *)의 호출 서명이있는 함수에 대한 포인터와 void에 대한 포인터를 사용합니다. 함수 포인터가 NULL이 아닌 경우 호출됩니다. 각 로깅 이벤트를 처리하기 위해 &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 에 의해 함수 포인터가 NULL 인 경우, &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스는 no-op가되고 SQLITE_CONFIG_LOG에 대한 두 번째 인수 인 void 포인터는 애플리케이션 정의에 대한 첫 번째 매개 변수로 전달됩니다. 로거 함수에 대한 두 번째 매개 변수는 해당 &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 호출 . 에 대한 첫 번째 매개 변수의 사본 &lt;a href=&quot;rescode&quot;&gt;결과 코드 &lt;/a&gt;이거나&lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; . 로거에 전달 된 세 번째 매개 변수는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통한 형식화 후 로그 메시지 입니다. SQLite 로깅 인터페이스는 재진입되지 않습니다. 응용 프로그램이 제공 한 로거 기능은 SQLite 인터페이스를 호출하지 않아야합니다. 다중 스레드 응용 프로그램에서 응용 프로그램 정의 로거 기능은 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE 옵션은 각 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 lookaside 메모리의 기본 크기를 결정하는 두 개의 인수를 사용합니다 . 첫 번째 인수는 각 lookaside 버퍼 슬롯의 크기이고 두 번째 인수는 각 데이터베이스 연결에 할당 된 슬롯 수입니다. SQLITE_CONFIG_LOOKASIDE는</target>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE 옵션은 각 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 lookaside 메모리의 기본 크기를 결정하는 두 개의 인수를 사용합니다 . 첫 번째 인수는 각 lookaside 버퍼 슬롯의 크기이고 두 번째 인수는 각 데이터베이스 연결에 할당 된 슬롯 수입니다. SQLITE_CONFIG_LOOKASIDE는</target>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC 옵션은 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 메모리 할당 루틴 대신 사용할 대체 저수준 메모리 할당 루틴을 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 리턴 되기 전에 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 컨텐츠의 자체 개인 사본을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC 옵션은 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 메모리 할당 루틴 대신 사용할 대체 저수준 메모리 할당 루틴을 지정합니다. SQLite는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 리턴 되기 전에 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 컨텐츠의 자체 개인 사본을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE 옵션은 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스의 기본 최대 크기 인 단일 매개 변수 &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; 매개 변수를 승인합니다 . 이 기본 최대 크기는 &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 위 또는 아래로 조정할 수 있습니다 . 이 구성 설정을 사용하지 않으면 기본 최대 값은 &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 . 해당 컴파일 시간 옵션이 설정되지 않은 경우 기본 최대 값은 1073741824입니다.</target>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE 옵션은 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스의 기본 최대 크기 인 단일 매개 변수 &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; 매개 변수를 승인합니다 . 이 기본 최대 크기는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 위 또는 아래로 조정할 수 있습니다 . 이 구성 설정을 사용하지 않으면 기본 최대 값은 &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 . 해당 컴파일 시간 옵션이 설정되지 않은 경우 기본 최대 값은 1073741824입니다.</target>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="translated">SQLITE_CONFIG_MEMSTATUS 옵션은 int 유형의 단일 인수를 부울로 해석하여 메모리 할당 통계 콜렉션을 사용하거나 사용하지 않도록 설정합니다. 메모리 할당 통계가 사용 불가능하면 다음 SQLite 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX 옵션은 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 뮤텍스 루틴 대신 사용할 대체 저수준 뮤텍스 루틴을 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 되기 전에 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 내용을 복사 합니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_MUTEX 구성 옵션을 사용하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX 옵션은 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 뮤텍스 루틴 대신 사용할 대체 저수준 뮤텍스 루틴을 지정합니다. SQLite는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 되기 전에 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 내용을 복사 합니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_MUTEX 구성 옵션을 사용하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;../rescode#error&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여 애플리케이션 정의 페이지 캐시 구현을로드하는 경우이 구성 옵션은 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에 대한 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인 (sz)의 크기 및 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512와 65536 사이의 2의 거듭 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 판별 할 수 있습니다.. 낭비되는 메모리를 제외하고 sz 매개 변수가 필요한 것보다 큰 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우, SQLite는 페이지 캐시 요구를 충족시키기 위해 제공된 메모리를 사용하기 위해 노력하며 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 모두 소모되면 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()로&lt;/a&gt; 되돌아갑니다 . pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트에 충분합니다. 초기 할당에서 제공하는 것 이상의 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 개별적 으로 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여 애플리케이션 정의 페이지 캐시 구현을로드하는 경우이 구성 옵션은 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에 대한 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인 (sz)의 크기 및 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512와 65536 사이의 2의 거듭 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 다음을 사용하여 확인할 수 있습니다.&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt;. 낭비되는 메모리를 제외하고 sz 매개 변수가 필요한 것보다 큰 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우, SQLite는 페이지 캐시 요구를 충족시키기 위해 제공된 메모리를 사용하기 위해 노력하며 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 모두 소모되면 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()로&lt;/a&gt; 되돌아갑니다 . pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트에 충분합니다. 초기 할당에서 제공하는 것 이상의 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 개별적 으로 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="373c6de3bbf7db29ed258a5d09d9109fe9568cc5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. 이 구성 옵션은 애플리케이션 정의 페이지 캐시 구현이 &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여로드되는 경우 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에는 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인의 크기 (sz), 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512에서 65536 사이의 2 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 확인할 수 있습니다.. 낭비되는 메모리를 제외하고는 sz 매개 변수가 필요 이상으로 커지는 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우 SQLite는 페이지 캐시 요구 사항을 충족하기 위해 제공된 메모리를 사용하려고 노력하고 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 소진되면 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 폴백합니다. pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트입니다. 초기 할당에서 제공하는 것보다 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 별도로 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="fe2e2404fd6d076f4a9442bd42821a9709933fc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. 이 구성 옵션은 애플리케이션 정의 페이지 캐시 구현이 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여로드되는 경우 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에는 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인의 크기 (sz), 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512에서 65536 사이의 2 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 확인할 수 있습니다.. 낭비되는 메모리를 제외하고는 sz 매개 변수가 필요 이상으로 커지는 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우 SQLite는 페이지 캐시 요구 사항을 충족하기 위해 제공된 메모리를 사용하려고 노력하고 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 소진되면 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 폴백합니다. pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트입니다. 초기 할당에서 제공하는 것보다 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 별도로 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2 옵션은 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 이 객체는 사용자 정의 페이지 캐시 구현에 대한 인터페이스를 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 객체 의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2 옵션은 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 이 객체는 사용자 정의 페이지 캐시 구현에 대한 인터페이스를 지정합니다. SQLite는 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 객체 의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ 옵션은 정수에 대한 포인터 인 단일 매개 변수를 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;취하여 SQLITE_CONFIG_PAGECACHE의&lt;/a&gt; 각 페이지에 필요한 페이지 당 추가 바이트 수를 해당 정수에 기록합니다 . 필요한 추가 공간은 컴파일러, 대상 플랫폼 및 SQLite 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ 옵션은 정수에 대한 포인터 인 단일 매개 변수를 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;취하여 SQLITE_CONFIG_PAGECACHE의&lt;/a&gt; 각 페이지에 필요한 페이지 당 추가 바이트 수를 해당 정수에 기록합니다 . 필요한 추가 공간은 컴파일러, 대상 플랫폼 및 SQLite 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ 옵션은 부호없는 정수인 단일 매개 변수를 사용하여 멀티 스레드 정렬 기의 &quot;최소 PMA 크기&quot;를 해당 정수로 설정합니다. 기본 최소 PMA 크기는 &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일 타임 옵션으로 설정됩니다 . &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; 명령을 사용하여 다중 스레드 정렬을 사용하고 정렬 할 컨텐츠의 양이 페이지 크기에서 최소 &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 설정 및이 값을 초과하면 정렬 작업에 도움이되는 새 스레드가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ 옵션은 부호없는 정수인 단일 매개 변수를 사용하여 멀티 스레드 정렬 기의 &quot;최소 PMA 크기&quot;를 해당 정수로 설정합니다. 기본 최소 PMA 크기는 &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일 타임 옵션으로 설정됩니다 . &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; 명령을 사용하여 다중 스레드 정렬을 사용하고 정렬 할 컨텐츠의 양이 페이지 크기에서 최소 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 설정 및이 값을 초과하면 정렬 작업에 도움이되는 새 스레드가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="translated">SQLITE_CONFIG_SCRATCH 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="translated">SQLITE_CONFIG_SMALL_MALLOC 옵션은 부울로 해석되는 int 유형의 단일 인수를 사용합니다. true 인 경우 가능한 경우 큰 메모리 할당을 피해야한다는 힌트를 SQLite에 제공합니다. 큰 메모리 할당을 자유롭게 할 수 있으면 SQLite가 더 빠르게 실행되지만 일부 응용 프로그램은 큰 할당을 피할 수있는 경우 메모리 조각화를 보장하기 위해 느리게 실행하는 것을 선호 할 수 있습니다. 이 힌트는 일반적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE 옵션은 분류기 참조 크기 임계 값의 새로운 값 (int) 유형의 단일 매개 변수를 허용합니다. 일반적으로 SQLite가 외부 정렬을 사용하여 ORDER BY 절에 따라 레코드를 정렬하면 호출자가 요구하는 모든 필드가 정렬 된 레코드에 있습니다. 그러나 SQLite가 선언 된 테이블 열 유형에 따라 값이 구성된 분류기 참조 크기 임계 값보다 클 가능성이 큰 것으로 판단되면 참조는 각 정렬 된 레코드에 저장되고 필요한 열 값은 다음에서로드됩니다. 레코드로서의 데이터베이스는 정렬 된 순서로 리턴됩니다. 이 옵션의 기본값은이 최적화를 사용하지 않는 것입니다. 이 옵션에 음수 값을 지정하면 기본 동작이 복원됩니다. 이 옵션은 SQLite가&lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; 컴파일 타임 옵션.</target>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE 옵션은 분류기 참조 크기 임계 값의 새 값인 유형 (int)의 단일 매개 변수를 허용합니다. 일반적으로 SQLite가 외부 정렬을 사용하여 ORDER BY 절에 따라 레코드를 정렬하면 호출자가 요구하는 모든 필드가 정렬 된 레코드에 있습니다. 그러나 SQLite가 선언 된 테이블 열 유형에 따라 값이 구성된 정렬 기 참조 크기 임계 값보다 클 가능성이 큰 것으로 판단되면 참조는 각 정렬 된 레코드에 저장되고 필요한 열 값은 다음에서로드됩니다. 레코드로서의 데이터베이스는 정렬 된 순서로 리턴됩니다. 이 옵션의 기본값은이 최적화를 사용하지 않는 것입니다. 이 옵션에 음수 값을 지정하면 기본 동작이 복원됩니다. 이 옵션은 SQLite가&lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; 컴파일 타임 옵션.</target>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL 옵션은 단일 매개 변수를 사용하여 &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 디스크 유출 임계 값이됩니다. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 은 크기 (바이트)가이 임계 값을 초과하여 디스크에 기록 될 때까지 메모리에 보유됩니다. 또는 임계 값이 -1이면 명령문 저널은 항상 독점적으로 메모리에 보유됩니다. 많은 명세서 일지가 커지지 않기 때문에 유출 임계 값을 64KiB와 같은 값으로 설정하면 명세서 롤백을 지원하는 데 필요한 I / O 양이 크게 줄어들 수 있습니다. 이 설정의 기본값은 &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 컴파일 타임 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL 옵션은 단일 매개 변수를 사용하여 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 디스크 유출 임계 값이됩니다. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 은 크기 (바이트)가이 임계 값을 초과하여 디스크에 기록 될 때까지 메모리에 보유됩니다. 또는 임계 값이 -1이면 명령문 저널은 항상 독점적으로 메모리에 보유됩니다. 많은 명세서 일지가 커지지 않기 때문에 유출 임계 값을 64KiB와 같은 값으로 설정하면 명세서 롤백을 지원하는 데 필요한 I / O 양이 크게 줄어들 수 있습니다. 이 설정의 기본값은 &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 컴파일 타임 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI 옵션은 int 유형의 단일 인수를 사용합니다. 0이 아닌 경우 URI 처리가 전체적으로 사용 가능합니다. 매개 변수가 0이면 URI 처리가 전체적으로 사용 불가능합니다. URI 처리가 전체적으로 사용 가능한 경우, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()에 전달&lt;/a&gt; 되거나 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령의 일부로 지정된 모든 파일 이름 은 데이터베이스 연결이 열릴 때 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 설정 여부에 관계없이 URI로 해석됩니다 . 전역 적으로 사용 불가능한 경우, 파일 이름은 데이터베이스 연결이 열릴 때 SQLITE_OPEN_URI 플래그가 설정된 경우에만 URI로 해석됩니다. 기본적으로 URI 처리는 전체적으로 비활성화되어 있습니다. 다음과 같이 컴파일하여 기본값을 변경할 수 있습니다.&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 기호가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI 옵션은 int 유형의 단일 인수를 사용합니다. 0이 아닌 경우 URI 처리가 전체적으로 사용 가능합니다. 매개 변수가 0이면 URI 처리가 전체적으로 사용 불가능합니다. URI 처리가 전체적으로 사용 가능한 경우, &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()에 전달&lt;/a&gt; 되거나 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령의 일부로 지정된 모든 파일 이름 은 데이터베이스 연결이 열릴 때 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 설정 여부에 관계없이 URI로 해석됩니다 . 전역 적으로 사용 불가능한 경우, 파일 이름은 데이터베이스 연결이 열릴 때 SQLITE_OPEN_URI 플래그가 설정된 경우에만 URI로 해석됩니다. 기본적으로 URI 처리는 전체적으로 비활성화되어 있습니다. 다음과 같이 컴파일하여 기본값을 변경할 수 있습니다.&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 기호가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZE 옵션은 SQLITE가 &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; 전 처리기 매크로가 정의 된 상태로 Windows 용으로 컴파일 된 경우에만 사용할 수 있습니다 . SQLITE_CONFIG_WIN32_HEAPSIZE는 작성된 힙의 최대 크기를 지정하는 부호없는 32 비트 정수 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZE 옵션은 SQLITE가 &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; 전 처리기 매크로가 정의 된 상태로 Windows 용으로 컴파일 된 경우에만 사용할 수 있습니다 . SQLITE_CONFIG_WIN32_HEAPSIZE는 작성된 힙의 최대 크기를 지정하는 부호없는 32 비트 정수 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="translated">SQLITE_CONSTRAINT 코드는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt; 메소드의 리턴 값으로도 사용될 수 있습니다 . xBestIndex ()가 SQLITE_CONSTRAINT를 리턴하면 xBestIndex ()에 제출 된 특정 입력 조합이 사용 가능한 쿼리 계획을 생성 할 수 없으며 추가 고려 사항이 없어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT 오류 코드는 SQL 문을 처리하는 중 SQL 제한 조건 위반이 발생했음을 의미합니다. 실패한 제한 조건에 대한 추가 정보는 함께 제공되는 오류 메시지 ( &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; 를 통해 리턴 됨 )를 참조하거나 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드를&lt;/a&gt; 보면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_CHECK 오류 코드는 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="translated">SQLITE_CONSTRAINT_COMMITHOOK 오류 코드는 &lt;a href=&quot;c3ref/commit_hook&quot;&gt;커미트 후크 콜백&lt;/a&gt; 이 0이 아닌 값을 리턴하여 SQL 문이 롤백 되었음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_FOREIGNKEY 오류 코드는 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="translated">SQLITE_CONSTRAINT_FUNCTION 오류 코드는 현재 SQLite 코어에서 사용되지 않습니다. 그러나이 오류 코드는 확장 기능에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_NOTNULL 오류 코드는 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_PRIMARYKEY 오류 코드는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="translated">SQLITE_CONSTRAINT_ROWID 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT이&lt;/a&gt; 것을 나타내는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID가&lt;/a&gt; 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="translated">SQLITE_CONSTRAINT_TRIGGER 오류 코드는 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 내 &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE 함수&lt;/a&gt; 가 실행 되어 SQL 문이 중단 되었음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_UNIQUE 오류 코드는 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT_VTAB 오류 코드는 현재 SQLite 코어에서 사용되지 않습니다. 그러나이 오류 코드는 응용 프로그램 정의 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="translated">SQLITE_CORRUPT 결과 코드는 데이터베이스 파일이 손상되었음을 나타냅니다. 손상이 발생할 수있는 방법에 대한 자세한 내용은 &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;데이터베이스 파일을 손상&lt;/a&gt; 시키는 방법을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="translated">SQLITE_CORRUPT_SEQUENCE 결과 코드는 sqlite_sequence 테이블의 스키마가 손상되었음을 의미합니다. sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 기능을 구현하는 데 도움이됩니다 . sqlite_sequence 테이블의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="translated">SQLITE_CORRUPT_VTAB 오류 코드는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에서&lt;/a&gt; 사용되는 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . &lt;a href=&quot;vtab&quot;&gt;가상 테이블은&lt;/a&gt; 가상 테이블의 콘텐츠가 손상 나타 내기 위해 SQLITE_CORRUPT_VTAB를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="translated">SQLITE_DBCONFIG_DEFENSIVE 옵션은 데이터베이스 연결에 대한 &quot;방어&quot;플래그를 활성화하거나 비활성화합니다. 방어 플래그가 활성화되면 일반 SQL에서 의도적으로 데이터베이스 파일을 손상시킬 수있는 언어 기능이 비활성화됩니다. 비활성화 된 기능에는 다음이 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS 옵션 은 CREATE TABLE 및 CREATE INDEX와 같은 DDL 문에 대한 기존의 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS 옵션 은 CREATE TABLE 및 CREATE INDEX와 같은 DDL 문에 대한 기존의 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문 (DELETE, INSERT, SELECT 및 UPDATE 문)에 대해서만 기존의 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ef07fd34a275a246ee518a98e66084fe0a55fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문, 즉 DELETE, INSERT, SELECT 및 UPDATE 문에 대해서만 레거시 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표 문자열 리터럴&lt;/a&gt; 잘못된 기능을 활성화하거나 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문 (DELETE, INSERT, SELECT 및 UPDATE 문)에 대해서만 기존의 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
