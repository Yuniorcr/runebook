<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">피연산자 중 하나가 열인 경우 해당 열의 조합 함수가 왼쪽 피연산자에 우선하여 사용됩니다. 이전 문장의 목적을 위해 열 이름 앞에는 하나 이상의 단항 &quot;+&quot;연산자 및 / 또는 CAST 연산자가 여전히 열 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">현재 값 또는 상위 워터 마크가 너무 커서 32 비트 정수로 표시 할 수없는 경우 sqlite3_status ()에 의해 리턴되는 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">파일 잠금이 활성화 된 경우 (기본적으로 활성화되어 있음) 여러 프로세스의 연결에서 데이터베이스 파일을 읽고 쓸 수도 있습니다. 그러나 동시성은 다음과 같이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">외래 키 제한 조건이 준비 될 때 사용 가능하면 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령은 내재적 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 를 수행 하여 테이블에서 모든 행을 삭제하기 전에 테이블에서 삭제합니다. 암시 적 DELETE는 SQL 트리거를 발생시키지 않지만 외래 키 동작 또는 제약 조건 위반을 호출 할 수 있습니다. 즉시 외래 키 제약 조건을 위반하면 DROP TABLE 문이 실패하고 테이블이 삭제되지 않습니다. 지연된 외래 키 제약 조건을 위반하면 해당 시점에 외래 키 제약 조건 위반이 여전히 존재하는 경우 사용자가 트랜잭션을 커밋하려고 시도 할 때 오류가보고됩니다. 암시 적 DELETE의 일부로 발생한 &quot;외부 키 불일치&quot;오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">외래 키 제약 조건이 활성화 된 경우 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF를&lt;/a&gt; 사용하여 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">외래 키 제약 조건이 원래 활성화 된 경우 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 를 실행 하여 스키마 변경으로 외래 키 제약 조건이 깨지지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">외래 키 처리가 활성화되어 있고 변경 세트를 적용하면 데이터베이스가 외래 키 위반이 포함 된 상태로 유지되는 경우 변경 세트가 커밋되기 직전에 CHANGESET_FOREIGN_KEY를 두 번째 인수로 충돌 핸들러가 호출됩니다. 충돌 처리기가 CHANGESET_OMIT를 반환하면 외래 키 제약 조건 위반의 원인을 포함하여 변경 내용이 커밋됩니다. 또는 CHANGESET_ABORT를 반환하면 변경 집합이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">외래 키 제약 조건이 원래 활성화 된 경우 지금 다시 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 아직 첨부되지 않은 경우이 함수는 &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 함수 와 동일한 방식으로 테이블 zTbl을 첨부합니다 . zTbl이 없거나 기본 키가없는 경우이 기능은 작동하지 않습니다 (그러나 오류를 리턴하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 아직 첨부되지 않은 경우이 함수는 &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 함수 와 동일한 방식으로 테이블 zTbl을 첨부합니다 . zTbl이 없거나 기본 키가없는 경우이 기능은 작동하지 않습니다 (그러나 오류를 리턴하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">많은 스레드 및 / 또는 프로세스가 같은 순간에 데이터베이스를 작성해야하는 경우 (대기열 및 전환을 수행 할 수없는 경우) 해당 기능을 지원하는 데이터베이스 엔진을 선택하는 것이 가장 좋습니다. 이는 항상 클라이언트 / 서버 데이터베이스 엔진을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">mmap_size가 N으로 설정되면 모든 현재 구현은 데이터베이스 파일의 첫 번째 N 바이트를 맵핑하고 N 바이트 이상의 컨텐츠에 대해 레거시 xRead () 호출을 사용합니다. 데이터베이스 파일이 N 바이트보다 작은 경우 전체 파일이 맵핑됩니다. 앞으로 새로운 OS 인터페이스는 이론상 처음 N 바이트 이외의 파일 영역을 매핑 할 수 있지만 현재는 그러한 구현이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">하나 이상의 그러한 단편이 발견 될 경우, 더 많은 수의 &quot;추가&quot;문구 일치를 포함하는 단편이 선호된다. 선택된 텍스트 프래그먼트의 시작은 프래그먼트의 중심을 향해 구문 일치를 집중 시키려고 몇 개의 토큰을 앞뒤로 움직일 수있다.</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA 스레드&lt;/a&gt; 설정을 통해 다중 스레드 처리를 사용하는 경우 정렬 할 컨텐츠의 양이 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션에 의해 결정된 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; 및 PMA 크기 의 최소값을 초과하면 정렬 조작이 헬퍼 스레드를 시작하려고 시도합니다 . 이 컴파일 시간 옵션은 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션 의 기본값을 설정합니다 . 기본값은 250입니다.</target>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">동일한 SQLite 데이터베이스 연결에 대해 여러 명령을 동시에 실행중인 경우 마지막 명령이 완료 될 때까지 자동 커밋이 연기됩니다. 예를 들어, SELECT 문이 실행중인 경우 결과의 각 행이 리턴 될 때 명령 실행이 일시 정지됩니다. 이 일시 정지 중에 데이터베이스의 다른 테이블에 대해 다른 INSERT, UPDATE 또는 DELETE 명령을 실행할 수 있습니다. 그러나 원래 SELECT 문이 완료 될 때까지 이러한 변경 사항은 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">이 두 가지 쿼리 전략 중 어느 것도 사용할 수없는 경우 FTS 테이블의 모든 쿼리는 전체 테이블의 선형 스캔을 사용하여 구현됩니다. 테이블에 많은 양의 데이터가 포함 된 경우 이는 실용적이지 않을 수 있습니다 (이 페이지의 첫 번째 예는 최신 PC를 사용하여 1.5GB의 데이터를 선형 스캔하는 데 약 30 초가 걸린다는 것을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">그렇지 않다면</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">삽입에 ROWID가 지정되지 않았거나 지정된 ROWID의 값이 NULL이면 적절한 ROWID가 자동으로 작성됩니다. 일반적인 알고리즘은 새로 생성 된 행에 삽입 전에 테이블에서 가장 큰 ROWID보다 큰 ROWID를 제공하는 것입니다. 테이블이 처음에 비어 있으면 ROWID 1이 사용됩니다. 가장 큰 ROWID가 가능한 가장 큰 정수 (9223372036854775807)와 같으면 데이터베이스 엔진은 이전에 사용되지 않은 것을 찾을 때까지 긍정적 인 후보 ROWID를 임의로 선택하기 시작합니다. 적당한 횟수의 시도 후에 사용되지 않은 ROWID를 찾을 수 없으면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 와 함께 삽입 조작이 실패합니다 . 음의 ROWID 값이 명시 적으로 삽입되지 않으면 자동으로 생성 된 ROWID 값은 항상 0보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다. 오류가 발생하면 SQLite 오류 코드가 리턴됩니다. 이 경우 출력 변수의 값을 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">마스터 저널이 포함되지 않은 경우 저널이 존재하고 0이 아닌 헤더가 있고 해당 데이터베이스 파일에 RESERVED 잠금이 없으면 저널이 뜨겁습니다. 마스터 저널이 파일 저널에 이름이 지정된 경우 마스터 저널이 있고 해당 데이터베이스 파일에 예약 된 잠금이 없으면 파일 저널이 뜨겁습니다. 저널이 뜨거울 때이를 이해하여 앞의 규칙이 글 머리 기호로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">기본 키 값과 일치하는 행이 데이터베이스에 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;없으면&lt;/a&gt; 충돌 핸들러 함수가 두 번째 인수로 전달 된 SQLITE_CHANGESET_NOTFOUND 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">기본 키 값과 일치하는 행이 데이터베이스에 &lt;a href=&quot;c_changeset_conflict&quot;&gt;없으면&lt;/a&gt; 충돌 핸들러 함수가 두 번째 인수로 전달 된 SQLITE_CHANGESET_NOTFOUND 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">수퍼 저널이 포함되지 않은 경우 저널이 존재하고 0이 아닌 헤더가 있고 해당 데이터베이스 파일에 RESERVED 잠금이없는 경우 저널이 핫입니다. 수퍼 저널이 파일 저널에 명명 된 경우 수퍼 저널이 존재하고 해당 데이터베이스 파일에 대한 RESERVED 잠금이없는 경우 파일 저널은 핫입니다. 저널이 뜨거울 때를 이해하는 것이 중요하므로 앞의 규칙이 글 머리 기호로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">위의 문자열 중 어느 것도 형식 선언의 어느 곳에서도 발생하지 않으면 데이터 형식은 숫자입니다. 특히 빈 형식 선언이있는 열의 데이터 형식은 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. Blob의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. Blob의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">한 피연산자에 INTEGER, REAL 또는 NUMERIC 선호도가 있고 다른 피연산자가 TEXT 또는 BLOB이거나 선호도가없는 경우 NUMERIC 선호도가 다른 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">한 피연산자가 TEXT 선호도를 갖고 다른 피연산자가 선호도를 가지지 않으면 TEXT 선호도가 다른 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">새 변경에 의해 삽입 된 행의 하나 이상의 열 값이 기존 변경에 의해 삭제 된 행의 열 값과 다른 경우 기존 DELETE는 변경 그룹 내의 UPDATE로 바뀝니다. 그렇지 않으면, 삽입 된 행이 삭제 된 행과 정확히 동일한 경우 기존 DELETE는 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; NULL이 아닌 D 매개 변수를 제공하여 포인터 소유권이 SQLite로 전달 되면 소유권이 개체가 손상 될 때까지 SQLite로 유지됩니다. 소유권을 SQLite에서 다시 애플리케이션으로 다시 전송할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">H35230에서 요구하는대로 1 페이지 데이터를 읽는 경우</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">iCol 매개 변수가 테이블의 열 수보다 크거나 같으면 SQLITE_RANGE가 리턴됩니다. 또는 오류 (예 : OOM 조건 또는 IO 오류)가 발생하면 적절한 SQLite 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">iCol 매개 변수가 0보다 작은 경우 출력 변수 * pnToken을 FTS5 테이블의 총 토큰 수로 설정하십시오. 또는 iCol이 음수가 아니지만 테이블의 열 수보다 적은 경우 FTS5 테이블의 모든 행을 고려하여 iCol 열의 총 토큰 수를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">iCol 매개 변수가 0보다 작은 경우 출력 변수 * pnToken을 현재 행의 총 토큰 수로 설정하십시오. 또는 iCol이 음수가 아니지만 테이블의 열 수보다 적은 경우 * pnToken을 현재 행의 열 iCol에있는 토큰 수로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDB는 NULL 또는 0 길이 문자열 점이다 매개 변수 다음 지정된 작업은 모든 WAL 데이터베이스에 시도하면 &lt;a href=&quot;../lang_attach&quot;&gt;연결&lt;/a&gt; 에 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; dB. 이 경우 출력 매개 변수 * pnLog 및 * pnCkpt에 기록 된 값은 정의되지 않습니다. 하나 이상의 연결된 WAL 데이터베이스를 처리 할 때 SQLITE_BUSY 오류가 발생하면 나머지 연결된 데이터베이스에서 작업이 계속 시도되고 끝에 SQLITE_BUSY가 반환됩니다. 연결된 데이터베이스를 처리하는 동안 다른 오류가 발생하면 처리가 중단되고 오류 코드가 즉시 호출자에게 반환됩니다. 연결된 데이터베이스를 처리하는 동안 오류 (SQLITE_BUSY 또는 기타)가 발생하지 않으면 SQLITE_OK가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDB는 NULL 또는 0 길이 문자열 점이다 매개 변수 다음 지정된 작업은 모든 WAL 데이터베이스에 시도하면 &lt;a href=&quot;lang_attach&quot;&gt;연결&lt;/a&gt; 에 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; dB. 이 경우 출력 매개 변수 * pnLog 및 * pnCkpt에 기록 된 값은 정의되지 않습니다. 하나 이상의 연결된 WAL 데이터베이스를 처리 할 때 SQLITE_BUSY 오류가 발생하면 나머지 연결된 데이터베이스에서 작업이 계속 시도되고 끝에 SQLITE_BUSY가 반환됩니다. 연결된 데이터베이스를 처리하는 동안 다른 오류가 발생하면 처리가 중단되고 오류 코드가 즉시 호출자에게 반환됩니다. 연결된 데이터베이스를 처리하는 동안 오류 (SQLITE_BUSY 또는 기타)가 발생하지 않으면 SQLITE_OK가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLog가 NULL이 아닌 경우, * pnLog는 로그 파일의 총 프레임 수로 설정되거나 오류로 인해 또는 데이터베이스가 &lt;a href=&quot;../wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않아 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다 . pnCkpt가 NULL이 아닌 경우 * pnCkpt는 로그 파일에서 체크 포인트 된 총 프레임 수 (함수가 호출되기 전에 이미 체크 포인트 된 프레임 포함)로 설정되거나 오류로 인해 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다. 데이터베이스가 WAL 모드가 아니기 때문입니다. SQLITE_CHECKPOINT_TRUNCATE를 성공적으로 완료하면 로그 파일이 0 바이트로 잘 리므로 * pnLog 및 * pnCkpt는 모두 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLog가 NULL이 아닌 경우, * pnLog는 로그 파일의 총 프레임 수로 설정되거나 오류로 인해 또는 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않아 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다 . pnCkpt가 NULL이 아닌 경우 * pnCkpt는 로그 파일에서 체크 포인트 된 총 프레임 수 (함수가 호출되기 전에 이미 체크 포인트 된 프레임 포함)로 설정되거나 오류로 인해 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다. 데이터베이스가 WAL 모드가 아니기 때문입니다. SQLITE_CHECKPOINT_TRUNCATE를 성공적으로 완료하면 로그 파일이 0 바이트로 잘 리므로 * pnLog 및 * pnCkpt는 모두 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">있는 경우 분석 된 각 쿼리에 대해 더 자세한 보고서를 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">pzTail이 NULL이 아닌 경우 * pzTail은 zSql의 첫 번째 SQL 문 끝을지나 첫 번째 바이트를 가리 키도록합니다. 이 루틴은 zSql의 첫 번째 명령문 만 컴파일하므로 * pzTail은 컴파일되지 않은 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">r [P3]이 0 또는 음수 인 경우, 이는 OFFSET이없고 r [P2]가 LIMIT, r [P1]의 값으로 설정되어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">레지스터 P1에 정수가 있으면 실수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">데이터베이스 파일의 끝에서 데이터베이스 페이지를 잘라야하는 경우</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">이전 &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; 와 동일한 두 피연산자에 대한 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 비교 결과 가 NULL 또는 false (0)이면 P2로 이동합니다. 이전 두 피연산자에 대한 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 비교 결과 가 참 (1)이면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 실행중인 경우 애플리케이션은 백업이 실행되는 동안 대상 데이터베이스가 사용하는 공유 캐시에 액세스하지 않도록해야합니다. 실제로 이것은 응용 프로그램이 백업중인 디스크 파일이 sqlite3_backup_init ()에 전달 된 특정 연결뿐만 아니라 프로세스 내의 모든 연결에 의해 액세스되지 않도록 보장해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 실행중인 경우 애플리케이션은 백업이 실행되는 동안 대상 데이터베이스가 사용하는 공유 캐시에 액세스하지 않도록해야합니다. 실제로 이것은 응용 프로그램이 백업중인 디스크 파일이 sqlite3_backup_init ()에 전달 된 특정 연결뿐만 아니라 프로세스 내의 모든 연결에 의해 액세스되지 않도록 보장해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">1로 설정하면 기본 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 가 EXCLUSIVE로 설정됩니다. 생략하거나 0으로 설정하면 기본 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 는 NORMAL입니다.</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">컴파일 타임 또는 시작시 단일 스레드 모드를 선택하지 않은 경우 개별 데이터베이스 연결을 다중 스레드 또는 직렬화로 작성할 수 있습니다. 개별 데이터베이스 연결을 단일 스레드 모드로 다운 그레이드 할 수 없습니다. 컴파일 타임 또는 시작 타임 모드가 단일 스레드 인 경우 개별 데이터베이스 연결을 에스컬레이션 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">컴파일 타임에 단일 스레드 모드를 선택하면 빌드에서 중요한 뮤팅 논리가 생략되고 시작 시간 또는 런타임에 멀티 스레드 또는 직렬 모드를 활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">향후 버전의 SQLite에 새로운 ALTER TABLE 기능이 추가되면 해당 기능은 위에서 설명한 두 절차 중 하나를 사용할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">다른 오류 (예 : OOM 조건)가 발생하면 SQLite 오류 코드가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">지정된 경우, 모든 작업 경로를 현재 작업 디렉토리 대신 DIR을 기준으로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">지정된 경우 FILE 파일을 아카이브로 사용하십시오. 그렇지 않으면 현재 &quot;기본&quot;데이터베이스가 작동 할 아카이브라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step ()이 필요한 파일 시스템 잠금을 확보 할 수 없으면 사용 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;중 핸들러 기능&lt;/a&gt; 이 호출됩니다 (지정된 경우). 잠금이 사용 가능하기 전에 통화 중 핸들러가 0이 아닌 값을 리턴하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 호출자에게 리턴됩니다. 이 경우 나중에 sqlite3_backup_step ()에 대한 호출을 재 시도 할 수 있습니다. sqlite3_backup_step ()이 호출 될 때 소스 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 사용하여 소스 데이터베이스에 쓰는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;중이면 SQLITE_LOCKED&lt;/a&gt; 가 즉시 리턴됩니다. 이 경우에도 sqlite3_backup_step ()에 대한 호출은 나중에 다시 시도 할 수 있습니다. 만약 &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;이 반환되면 sqlite3_backup_step ()에 대한 호출을 다시 시도 할 필요가 없습니다. 이러한 오류는 치명적인 것으로 간주됩니다. 애플리케이션은 백업 조작이 실패했음을 승인하고 백업 조작 핸들을 sqlite3_backup_finish ()에 전달하여 연관된 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step ()이 필요한 파일 시스템 잠금을 확보 할 수 없으면 사용 &lt;a href=&quot;busy_handler&quot;&gt;중 핸들러 기능&lt;/a&gt; 이 호출됩니다 (지정된 경우). 잠금이 사용 가능하기 전에 통화 중 핸들러가 0이 아닌 값을 리턴하면 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 호출자에게 리턴됩니다. 이 경우 나중에 sqlite3_backup_step ()에 대한 호출을 재 시도 할 수 있습니다. sqlite3_backup_step ()이 호출 될 때 소스 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 사용하여 소스 데이터베이스에 쓰는 &lt;a href=&quot;../rescode#locked&quot;&gt;중이면 SQLITE_LOCKED&lt;/a&gt; 가 즉시 리턴됩니다. 이 경우에도 sqlite3_backup_step ()에 대한 호출은 나중에 다시 시도 할 수 있습니다. 만약 &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , 또는 &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;이 반환되면 sqlite3_backup_step ()에 대한 호출을 다시 시도 할 필요가 없습니다. 이러한 오류는 치명적인 것으로 간주됩니다. 애플리케이션은 백업 조작이 실패했음을 승인하고 백업 조작 핸들을 sqlite3_backup_finish ()에 전달하여 연관된 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F)가 어떤 이유로 인해 실패하고 SQLITE_DESERIALIZE_FREEONCLOSE 비트가 인수 F에 설정된 경우 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 리턴하기 전에 인수 P에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F)가 어떤 이유로 인해 실패하고 SQLITE_DESERIALIZE_FREEONCLOSE 비트가 인수 F에 설정된 경우 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 리턴하기 전에 인수 P에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">루틴 처리 중 (예 : UTF-8에서 UTF-16으로 변환 중) sqlite3_malloc ()이 실패하면 NULL 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">다중 스레드 응용 프로그램에서 sqlite3_unlock_notify ()가 호출되면, sqlite3_unlock_notify ()가 호출 될 때까지 블로킹 연결이 이미 트랜잭션을 종료했을 가능성이 있습니다. 이 경우 sqlite3_unlock_notify ()에 대한 호출 내에서 지정된 콜백이 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">sqlite3rbu_vacuum ()을 호출 할 때 상태 데이터베이스 S가 존재하지 않으면 RBU 진공 상태를 저장하는 데 사용되는 단일 테이블 ( &quot;rbu_state&quot;)이 자동으로 작성되어 채워집니다. 진행중인 RBU 진공이 일시 중단되면이 테이블은 상태 데이터로 채워집니다. 다음에 같은 S 매개 변수로 sqlite3rbu_vacuum ()을 호출하면이 데이터를 감지하고 일시 중단 된 진공 작동을 재개하려고 시도합니다. RBU 진공 작업이 완료되거나 오류가 발생하면 RBU는 rbu_state 테이블의 내용을 자동으로 삭제합니다. 이 경우 sqlite3rbu_vacuum ()에 대한 다음 호출은 완전히 새로운 진공 작업을 처음부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">1 단계가 완료되면 다음을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">성공하면 반전 된 변경 세트를 포함하는 버퍼에 대한 포인터가 * ppOut에 저장되고 동일한 버퍼의 크기가 * pnOut에 저장되며 SQLITE_OK가 리턴됩니다. 오류가 발생하면 * pnOut 및 * ppOut이 모두 0이고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">성공하면이 함수는 SQLITE_OK를 리턴하고 리턴하기 전에 새 sqlite3_changegroup 오브젝트에 대한 포인터로 (* pp)를 채 웁니다. 호출자는 sqlite3changegroup_delete () 호출을 사용하여 반환 된 객체를 해제해야합니다. 오류가 발생하면 SQLite 오류 코드 (예 : SQLITE_NOMEM)가 리턴되고 * pp가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">성공하면이 함수는 * ppValue를 설정하여 현재 충돌 처리기 콜백과 연관된 &quot;충돌 행&quot;의 iVal'th 값을 포함하는 보호 된 sqlite3_value 객체를 가리키고 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">성공하면이 함수는 * ppValue가 UPDATE 또는 INSERT 변경의 일부로 저장된 새 행 값의 벡터에서 iVal'th 값을 포함하는 보호 된 sqlite3_value 오브젝트를 가리 키도록 설정하고 SQLITE_OK를 리턴합니다. 변경이 UPDATE이고 요청 된 열에 대한 새 값을 포함하지 않으면 * ppValue가 NULL로 설정되고 SQLITE_OK가 리턴됩니다. 함수의 이름은 트리거를 업데이트하거나 삭제하는 데 사용할 수있는 &quot;new. *&quot;열과 유사하다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">성공하면이 함수는 * ppValue가 UPDATE 또는 DELETE 변경의 일부로 저장된 원래 행 값의 벡터에서 iVal'th 값을 포함하는 보호 된 sqlite3_value 오브젝트를 가리 키도록 설정하고 SQLITE_OK를 리턴합니다. 함수의 이름은 트리거를 업데이트하거나 삭제하는 데 사용할 수있는 &quot;old. *&quot;열과 유사하다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">성공하면 xCreateFunction ()은 SQLITE_OK를 반환합니다. 그렇지 않으면 SQLite 오류 코드를 반환합니다. 이 경우 xDestroy 함수가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">성공하면 xCreateTokenizer ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 SQLite 오류 코드를 반환합니다. 이 경우 xDestroy 함수가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">이러한 텍스트 조각을 찾을 수 있으면 다음과 같이 수정하여 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;명령에 &quot;-x&quot;인수가 있으면 임시 파일에서 출력을 CSV (Comma-Separated-Values)로 누적하고 CSV 파일을보기위한 기본 시스템 유틸리티를 호출하십시오. 결과에 (보통 스프레드 시트 프로그램). 다음은 쿼리 결과를 스프레드 시트로 전송하여 쉽게 볼 수있는 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;명령에 &quot;-e&quot;인수가 있으면 출력이 임시 파일로 수집되고 해당 텍스트 파일에서 시스템 텍스트 편집기가 호출됩니다. 따라서 &quot;.once -e&quot;명령은 &quot;.once '| open -f'&quot;와 동일한 결과를 얻지 만 모든 시스템에서 이식 가능하다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">&quot;.recover&quot;명령이 데이터베이스 테이블에 속할 수없는 하나 이상의 행을 복구하는 경우 출력 스크립트는 &quot;lost_and_found&quot;테이블을 작성하여 분리 된 행을 저장합니다. lost_and_found 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">&quot;CREATE VIRTUAL TABLE&quot;문이 FTS3이 아닌 모듈 FTS4를 지정하면, &quot;tokenize = *&quot;옵션과 유사한 특수 지시문-FTS4 옵션이 열 이름 대신 나타날 수도 있습니다. FTS4 옵션은 옵션 이름, &quot;=&quot;문자, 옵션 값으로 구성됩니다. 옵션 값은 선택적으로 작은 따옴표 나 큰 따옴표로 묶을 수 있으며, 포함 된 따옴표 문자는 SQL 리터럴과 같은 방식으로 이스케이프됩니다. &quot;=&quot;문자의 양쪽에 공백이 없을 수 있습니다. 예를 들어, &quot;matchinfo&quot;옵션의 값이 &quot;fts3&quot;으로 설정된 FTS4 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">&quot;CREATE&quot;와 &quot;VIEW&quot;사이에 &quot;TEMP&quot;또는 &quot;TEMPORARY&quot;키워드가 발생하면 작성된보기는 해당보기를 작성한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서만 볼 수 있으며 데이터베이스 연결이 닫히면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">&quot;col&quot;열에 값 '*'이 포함 된 경우이 열에는 FTS 테이블의 하나 이상의 인스턴스 (모든 열)를 포함하는 행 수가 포함됩니다. col에 정수 값이 포함 된 경우이 열에는 col 값으로 식별되는 열에 하나 이상의 용어 인스턴스가 포함 된 FTS 테이블의 행 수가 포함됩니다. 일반적으로 FTS 테이블의 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">&quot;col&quot;열에 값 '*'이 포함 된 경우이 열에는 FTS 테이블의 모든 행 (모든 열)에있는 용어의 총 인스턴스 수가 포함됩니다. 그렇지 않으면 col에 정수 값이 포함 된 경우이 열에는 col 값으로 식별되는 FTS 테이블 열에 나타나는 총 용어 인스턴스 수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">&quot;스키마&quot;가 생략되면 기본 데이터베이스 (기본적으로 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME을&lt;/a&gt; 사용하여 이름을 바꾸지 않는 한 'main'이라고 함)로 기본 설정됩니다 . 따라서 다음 두 쿼리는 일반적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">&quot;정렬되지 않은&quot;인수가 있으면 쿼리 플래너는 인덱스가 정렬되지 않은 것으로 가정하고 범위 쿼리 또는 정렬에 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">$ bigstring 변수에 문자열과 &quot;바이트 배열&quot;표현이 모두 있으면 TCL은 값을 문자열로 삽입합니다. &quot;바이트 배열&quot;표현 만있는 경우 값이 BLOB으로 삽입됩니다. 텍스트 표현이있는 경우에도 BLOB로 값을 강제로 삽입하려면 &quot;$&quot;대신 &quot;@&quot;문자를 사용하십시오. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">다음과 같이 % q 대신 % Q 형식 옵션을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">--vtab 옵션이 sqldiff.exe로 전달되면 FTS3, FTS5 또는 rtree 가상 테이블에 속하는 모든 기본 섀도우 테이블을 무시하고 가상 테이블 차이를 직접 포함합니다.</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">두 번째 매개 변수에 실제로 두 개 이상의 SQL 문이 포함 된 경우 첫 번째 명령문 만 컴파일됩니다. (이는 입력 문자열에서 모든 SQL 문을 실행 하는 &lt;b&gt;sqlite_exec&lt;/b&gt; 의 동작과 &lt;b&gt;다릅니다&lt;/b&gt; .) &lt;b&gt;sqlite_compile&lt;/b&gt; 의 세 번째 매개 변수 는 입력에서 SQL의 첫 번째 명령문 끝을 넘어 첫 번째 문자를 가리 키도록 만들어집니다. 두 번째 매개 변수에 단일 SQL 문만 포함 된 경우 세 번째 매개 변수는 두 번째 매개 변수 끝에서 '\ 000'종결자를 가리 키도록 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">sqlite3_exec ()에 대한 두 번째 매개 변수가 NULL 포인터, 빈 문자열에 대한 포인터 또는 공백 및 / 또는 SQL 주석 만 포함 된 포인터 인 경우 SQL 문이 평가되지 않고 데이터베이스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 조합 중 하나가 아닌 다른 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 선택적으로 결합 되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 조합 중 하나가 아닌 다른 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 선택적으로 결합 되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 필수 조합 중 하나가 아닌 경우 선택적으로 다른 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 결합 하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 필수 조합 중 하나가 아닌 경우 선택적으로 다른 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 결합 하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그가 설정되어, 데이터베이스 연결은 멀티 스레드에서 열립니다 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 컴파일 시간 또는 시작 시간이 긴 단일 스레드 모드로하지 않았다 세트로. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그가 설정 되면 컴파일 타임 또는 시작시 단일 스레드를 이전에 선택하지 않은 경우 데이터베이스 연결이 직렬화 된 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 에서 열립니다 . &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE의&lt;/a&gt; 플래그가 데이터베이스 연결을 사용할 자격이됩니다 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드를&lt;/a&gt; 여부에 관계없이 공유 캐시의 사용 활성화, &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache을 ()&lt;/a&gt; . &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;플래그는 데이터베이스 연결 이 사용 가능하더라도 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드에&lt;/a&gt; 참여하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;a href=&quot;#sqlite3_blob&quot;&gt;&lt;/a&gt;첫 번째 인수로 전달 BLOB 핸들 이 쓰기 위해 열리지 않은 경우 ( &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 플래그 매개 변수 가 0 임)이 함수는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">는 IF &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen의&lt;/a&gt; 방법이 아닌 NULL 포인터에 sqlite3_file.pMethods 요소를 설정 한 다음 sqlite3_io_methods.xClose 방법도 경우 호출 할 수 있습니다&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt; sqlite3_vfs.xOpen는&lt;/a&gt; 그것이 실패했다고보고했다. 실패한 다음 xClose에 대한 호출을 방지 할 수있는 유일한 방법 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen은&lt;/a&gt; 입니다 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen이&lt;/a&gt; NULL로 sqlite3_file.pMethods 요소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE의&lt;/a&gt; 연산 코드가 SQLITE_OK를 반환 한 다음 파일 기술자는 이후의 모든 쓰기 작업이 연기하고 다음에 원자 적으로 수행된다는 것을 의미합니다 &quot;일괄 쓰기 모드&quot;에 배치됩니다 &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . 배치 원자 쓰기를 지원하지 않는 시스템은 SQLITE_NOTFOUND를 리턴합니다. 성공적인 SQLITE_FCNTL_BEGIN_ATOMIC_WRITE 전에 마감에 따라 &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 또는 &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite는 같은에는 VFS 인터페이스를 호출 할 것 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file의&lt;/a&gt; xWrite 방법과 함께 xFileControl 방법에 대한 호출을 제외한 파일 설명 &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">는 IF &lt;a href=&quot;../vtab#xcolumn&quot;&gt;Xcolumn에는의&lt;/a&gt; 열이 UPDATE 문에 의해 변경되지 않도록 방법은 sqlite3_vtab_nochange () 및 발견을 호출 한 다음 Xcolumn에는 방법은 선택적 중 하나를 호출하지 않고, 그 결과를 설정하지 않고 반환 할 수 있습니다&lt;a href=&quot;result_blob&quot;&gt; sqlite3_result_xxxxx () 인터페이스&lt;/a&gt; . 이 경우 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 는 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 의 동일한 열에 대해 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt;첫 번째 인수로 전달 이 쓰기 위해 열리지 않은 경우 ( &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 플래그 매개 변수 가 0 임)이 함수는 &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">만약 &lt;a href=&quot;c3ref/create_function&quot;&gt; sqlite3_create_function ()&lt;/a&gt; 인터페이스는 다른 실시하여 글로브 (X, Y) 기능을 대체하는 데 사용되는 다음 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 오퍼레이터는 다른 구현을 호출한다.</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE의&lt;/a&gt; 연산 코드가 SQLITE_OK를 반환 한 다음 파일 기술자는 이후의 모든 쓰기 작업이 연기하고 다음에 원자 적으로 수행된다는 것을 의미합니다 &quot;일괄 쓰기 모드&quot;에 배치됩니다 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . 배치 원자 쓰기를 지원하지 않는 시스템은 SQLITE_NOTFOUND를 리턴합니다. 성공적인 SQLITE_FCNTL_BEGIN_ATOMIC_WRITE 전에 마감에 따라 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 또는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite는 같은에는 VFS 인터페이스를 호출 할 것 &lt;a href=&quot;file&quot;&gt;sqlite3_file의&lt;/a&gt; xWrite 방법과 함께 xFileControl 방법에 대한 호출을 제외한 파일 설명 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그가 설정되어, 데이터베이스 연결은 멀티 스레드에서 열립니다 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 컴파일 시간 또는 시작 시간이 긴 단일 스레드 모드로하지 않았다 세트로. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그가 설정 되면 컴파일 타임 또는 시작시 단일 스레드를 이전에 선택하지 않은 경우 데이터베이스 연결이 직렬화 된 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 에서 열립니다 . &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE의&lt;/a&gt; 플래그가 데이터베이스 연결을 사용할 자격이됩니다 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드를&lt;/a&gt; 여부에 관계없이 공유 캐시의 사용 활성화, &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache을 ()&lt;/a&gt; . &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;플래그는 데이터베이스 연결 이 사용 가능하더라도 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드에&lt;/a&gt; 참여하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; 옵션을 사용하고 SQLite는 8 + 3 파일 이름을 사용 할 수 있지만 기능은 사용할 수 없으며 사용하여 사용하여 각 데이터베이스 연결에 대해 개별적으로 활성화해야합니다 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 때 &lt;a href=&quot;c3ref/open&quot;&gt;개방&lt;/a&gt; 또는 &lt;a href=&quot;lang_attach&quot;&gt;- 보내고 ATTACH&lt;/a&gt; 데이터베이스 파일과 포함 &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; URI의 8_3_names = 1 &quot;쿼리 매개 변수 SQLite가 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; 로 컴파일되면 기본적으로 8 + 3 개의 파일 이름이 활성화 되므로이 단계를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 임시 파일에 대한 컴파일 시간 매개 변수를 지정 디스크에 저장 한 후 대신 그 결정과 사용 메모리 저장 장치를 대체합니다. 그렇지 않으면 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 권장 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 임시 파일에 대한 컴파일 시간 매개 변수를 지정 메모리 저장 후 대신 그 결정과 사용 디스크 스토리지보다 우선합니다. 그렇지 않으면 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 권장 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">만약 &lt;a href=&quot;datatype3#affinity&quot;&gt; 친화&lt;/a&gt; 열이 REAL하며 (값은 더 소수 부분을 포함하지 않고 정수로 표현하기에 너무 크지 않은 경우) 그 열은 정보의 손실없이 정수로 변환 될 수있는 값을 포함 후 컬럼 일 수있다 레코드에 정수로 저장됩니다. SQLite는 레코드에서 값을 추출 할 때 값을 부동 소수점으로 다시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">행 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt; 가 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY에&lt;/a&gt; 의해 별명 지정 되지 않으면 지속적이지 않으며 변경 될 수 있습니다. 특히&lt;a href=&quot;lang_vacuum&quot;&gt; VACUUM&lt;/a&gt; 명령은 INTEGER PRIMARY KEY를 선언하지 않은 테이블의 rowid를 변경합니다. 따라서 응용 프로그램은 일반적으로 rowid에 직접 액세스하지 말고 대신 INTEGER PRIMARY KEY를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn의&lt;/a&gt; 연산 코드가 갱신 동작 동안에 불변 열의 값을 취득하는 데 사용되고, 그 값은 P5 OPFLAG_NOCHNG이다. 그러면 sqlite3_vtab_nochange () 함수가 가상 테이블 구현의 xColumn 메소드 내에서 true를 리턴합니다. P5 열에는 다른 비트 (OPFLAG_LENGTHARG 또는 OPFLAG_TYPEOFARG)도 포함될 수 있지만 해당 비트는 &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn에서&lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">경우 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화가&lt;/a&gt; SELECT 문의 FROM 절에서 서브 쿼리에 사용되며, 그 효과적으로 외부 쿼리에 하위 쿼리를 병합합니다. EXPLAIN QUERY PLAN의 출력은 다음 예와 같이이를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">만약 &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS의&lt;/a&gt; 프라그는 ON으로 설정하고, 쿼리 결과는 다음 콜백 말하면 0 세번째 파라미터 (ARGV) 세트로 한번 호출 공집합이다되고</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">전체 &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;동기화&lt;/a&gt; 플래그가 설정된 후 F_FULLFSYNC 동기화 방법은 모든 동기화 작업에 사용하고 checkpoint_fullfsync 설정은 무관하다.</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names 인&lt;/a&gt; 경우 COLUMN : 프라그가 ON, 결과의 이름은 소스 테이블 이름 접두사가없는 소스 테이블 컬럼의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">는 IF &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen의&lt;/a&gt; 방법이 아닌 NULL 포인터에 sqlite3_file.pMethods 요소를 설정 한 다음 sqlite3_io_methods.xClose 방법은 경우에도 호출 할 수 있습니다&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt; sqlite3_vfs.xOpen는&lt;/a&gt; 그것이 실패했다고보고했다. 실패한 다음 xClose에 대한 호출을 방지 할 수있는 유일한 방법 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen은&lt;/a&gt; 입니다 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen이&lt;/a&gt; NULL로 sqlite3_file.pMethods 요소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">경우] &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는에&lt;/a&gt; 메소드 호출은 열이 UPDATE 문에 의해 변경되지 않도록 sqlite3_vtab_nochange ()를 찾은 후 Xcolumn에는 방법은 선택적으로 임의의 호출하지 않고, 그 결과를 설정하지 않고 반환 할&lt;a href=&quot;#sqlite3_result_blob&quot;&gt; sqlite3_result_xxxxx () 인터페이스&lt;/a&gt; . 이 경우 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 는 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 의 동일한 열에 대해 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드가 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error ()&lt;/a&gt; 를 사용하여 오류 메시지를 리턴하면 내부 생성 메시지보다 해당 오류 메시지 우선 순위를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate의&lt;/a&gt; 방법이 NULL, 다음 &lt;a href=&quot;lang_createvtab&quot;&gt;가상 테이블의 CREATE&lt;/a&gt; 문이 가상 테이블 금지하고, 가상 테이블은 &quot;시조 전용 가상 테이블&quot;입니다. 시상 전용 가상 테이블은 다음과 같이 유용합니다.&lt;a href=&quot;vtab#tabfunc2&quot;&gt; 테이블 반환 함수 합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">는 IF &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; 가상 테이블에 대한 메소드가 정의되고, xFindFunction ()는 때로는 반환하는 경우 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION을&lt;/a&gt; 이상을, 그 제약은 형식이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">경우 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 합니다 (를 통해 사용할 수 있습니다 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode 프라그&lt;/a&gt; )이 pragma는 원인 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 데이터베이스에서 실행하는 작업을</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">경우 &lt;b&gt;헤더&lt;/b&gt; 인수가 true 다음 CSV 파일의 첫 번째 행은 헤더로서가 아닌 데이터로 취급합니다. CSV 파일의 두 번째 줄은 첫 번째 내용 행이됩니다. 는 IF &lt;b&gt;스키마 =&lt;/b&gt; 옵션을 생략 한 다음 CSV 파일의 첫 번째 행은 열 이름을 판단한다.</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">INTEGER PRIMARY KEY 뒤에 AUTOINCREMENT 키워드가 나타나면 데이터베이스 수명 동안 ROWID를 재사용하지 못하도록 자동 ROWID 할당 알고리즘이 변경됩니다. 즉, AUTOINCREMENT의 목적은 이전에 삭제 된 행에서 ROWID를 재사용하지 못하게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU 라이브러리&lt;/a&gt; 의 C 버전 이 사용 가능한 경우 FTS는 정의 된 SQLITE_ENABLE_ICU 전 처리기 매크로로 컴파일 될 수도 있습니다. 이 매크로로 컴파일하면 FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저가&lt;/a&gt; 활성화됩니다 하면 ICU 라이브러리를 사용하여 지정된 언어 및 로캘의 규칙을 사용하여 문서를 용어 (단어)로 분할 를 사용할 .</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 (외래 키 제한 조건을 위반 한 경우에만 발생할 수 있음) 충돌 핸들러 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 DELETE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 (외래 키 제한 조건을 위반 한 경우에만 발생할 수 있음) 충돌 핸들러 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 DELETE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">DELETE 문에 ORDER BY 절이 있으면 LIMIT 절이 없을 때 삭제 될 모든 행이 ORDER BY에 따라 정렬됩니다. 첫번째</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">DELETE 문에 ORDER BY 절이없는 경우 LIMIT 절이 없을 때 삭제 될 모든 행은 LIMIT 및 OFFSET 절을 적용하기 전에 임의의 순서로 어셈블되어 실제로 삭제되는 서브 세트를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">ESCAPE 옵션을 사용하는 경우 ESCAPE 문자는 ASCII이거나 UTF-8의 1 바이트 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="translated">F 매개 변수가 위 중 하나가 아니면 동작이 정의되지 않았으며 바람직하지 않을 수 있습니다. 이전 버전의 SQLite는 최신 버전보다 잘못된 F 매개 변수에 대해 더 관대했습니다.</target>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">FROM 절이 간단한 SELECT 문에서 생략되면 입력 데이터는 암시 적으로 너비가 0 인 단일 행입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">FTS 테이블이 FTS4 테이블 (FTS3 아님) 인 경우 토큰 앞에 &quot;^&quot;문자가 붙을 수도 있습니다. 이 경우 토큰을 일치 시키려면 일치하는 행의 모든 ​​열에서 첫 번째 토큰으로 나타나야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">'세부 사항'옵션을 'col'로 설정하여 FTS5 테이블을 작성하면</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">HAVE_FDATASYNC 컴파일 타임 옵션이 true 인 경우, 유닉스 시스템 의 기본 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 적절한 경우 fsync () 대신 fdatasync ()를 사용하려고 시도합니다. 이 플래그가 없거나 false이면 fsync ()가 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">HAVE_GMTIME_R 옵션이 true이고 &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; 가 true 인 경우 CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP 키워드는 &quot;gmtime ()&quot;대신 스레드 안전 &quot;gmtime_r ()&quot;인터페이스를 사용합니다. &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; 가 정의되지 않았거나 false 인 일반적인 경우 , 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP 키워드를 구현하는 데 사용되며 gmtime_r () 또는 gmtime ()은 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">HAVE_ISNAN 옵션이 true이면 SQLite는 시스템 라이브러리 isnan () 함수를 호출하여 배정 밀도 부동 소수점 값이 NaN인지 판별합니다. HAVE_ISNAN이 정의되지 않았거나 false이면 SQLite는 자체 개발 한 isnan () 구현을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_R 옵션이 true 인 경우 SQLite는 localtime () 대신 스레드 안전 localtime_r () 라이브러리 루틴을 사용 하여 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 에 대해 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정자를&lt;/a&gt; 구현하는 데 도움을줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_S 옵션이 true 인 경우 SQLite는 localtime () 대신 스레드 안전 localtime_s () 라이브러리 루틴을 사용 하여 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 에 대해 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정자를&lt;/a&gt; 구현하는 데 도움을줍니다 .</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZE 옵션이 생략되거나 false 인 경우 SQLite는 시스템 malloc () 및 realloc () 주위의 랩퍼를 사용하여 각 할당을 8 바이트 씩 확대하고 할당 크기를 초기 8 바이트로 기록한 다음 SQLite도 구현합니다. 8 바이트 접두사를 참조하여 할당 크기를 찾는 고유 한 malloc_usable_size () 버전. 이 방법은 효과가 있지만 차선책입니다. 응용 프로그램은 가능할 때마다 HAVE_MALLOC_USABLE_SIZE를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZE 옵션이 true이면 SQLite는 malloc_usable_size () 인터페이스를 사용하여 표준 라이브러리 malloc () 또는 realloc () 루틴에서 얻은 메모리 할당 크기를 찾습니다. 이 옵션은 표준 라이브러리 malloc ()을 사용하는 경우에만 적용 할 수 있습니다. Apple 시스템에서는 &quot;zone malloc&quot;이 대신 사용되므로이 옵션은 적용 할 수 없습니다. 물론 애플리케이션 이 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 을 사용하여 자체 malloc 구현을 제공하는 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">HAVE_STRCHRNUL 옵션이 true이면 SQLite는 strchrnul () 라이브러리 함수를 사용합니다. 이 옵션이 없거나 false이면 SQLite는 자체 개발 한 strchrnul () 구현을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">HAVE_USLEEP 옵션이 true 인 경우, 기본 유닉스 VFS는 usleep () 시스템 호출을 사용하여 xSleep 메소드를 구현합니다. 이 옵션이 정의되지 않거나 false 인 경우 유닉스에서 xSleep은 sleep ()을 사용하여 구현됩니다. 즉 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 은 인수에 관계없이 최소 대기 간격이 1000 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">HAVE_UTIME 옵션이 true 인 경우 내장 된 비표준 &quot;unix-dotfile&quot;VFS는 utimes () 대신 utime () 시스템 호출을 사용하여 잠금 파일의 마지막 액세스 시간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">INTO 절이 포함 된 경우, 원래 데이터베이스 파일은 변경되지 않으며 INTO 절에 대한 인수가 제공 한 파일 이름에 새 데이터베이스가 작성됩니다. 새 데이터베이스에는 원래 데이터베이스와 동일한 논리적 내용이 포함되며 완전히 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">LIMIT 표현식이 음수가 아닌 값으로 평가되는 경우</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">NATURAL 키워드가 join-operator에 있으면 내재 된 USING 절이 join-constraints에 추가됩니다. 내재 된 USING 절에는 왼쪽 및 오른쪽 입력 데이터 세트 모두에 나타나는 각 열 이름이 포함됩니다. 왼쪽 및 오른쪽 입력 데이터 집합에 공통 열 이름이없는 경우 NATURAL 키워드는 조인 결과에 영향을 미치지 않습니다. NATURAL 키워드를 지정하는 조인에 USING 또는 ON 절을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">명령문이 리턴 한 N 번째 컬럼이 표현식 또는 서브 쿼리이고 컬럼 값이 아닌 경우 이러한 모든 함수는 NULL을 리턴합니다. 메모리 할당 오류가 발생하면이 루틴은 NULL을 리턴 할 수도 있습니다. 그렇지 않으면 쿼리 결과 열이 추출 된 연결된 데이터베이스, 테이블 또는 열의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">문에서 반환 된 N 번째 열이 식 또는 하위 쿼리이고 열 값이 아닌 경우 이러한 함수는 모두 NULL을 반환합니다. 이러한 루틴은 메모리 할당 오류가 발생하는 경우 NULL을 반환 할 수도 있습니다. 그렇지 않으면 쿼리 결과 열이 추출 된 연결된 데이터베이스, 테이블 또는 열의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">OPFLAG_AUXDELETE 비트가 P5에 설정된 경우 이는 테이블 행 및 연관된 모든 인덱스 항목 삭제와 연관된 여러 항목 중 하나가 삭제됨을 나타냅니다. 이러한 삭제 중 하나는 &quot;1 차&quot;삭제입니다. 다른 것은 모두 OPFLAG_FORDELETE 커서에 있거나 AUXDELETE 플래그로 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">OPFLAG_ISUPDATE 플래그가 P2에 설정된 경우, P3은 행의 rowid가 갱신에 의해 설정 될 값을 포함하는 메모리 셀의 주소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">OPFLAG_ISUPDATE 플래그가 설정되면이 opcode는 UPDATE 조작의 일부입니다. 그렇지 않으면 (플래그가 명확한 경우)이 opcode는 INSERT 조작의 일부입니다. 차이점은 업데이트 후크에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">OPFLAG_LENGTHARG 및 OPFLAG_TYPEOFARG 비트가 P5에 설정되면 결과는 각각 length () 또는 typeof () 함수의 인수로만 사용되도록 보장됩니다. length ()의 경우 큰 얼룩의로드를 건너 뛸 수 있고 typeof ()의 경우 모든 내용로드를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">P2의 OPFLAG_NCHANGE 플래그 (NB : P2 not P5)가 설정되면 행 변경 계수가 증가합니다 (그렇지 않으면).</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">P5의 OPFLAG_NCHANGE 플래그가 설정되면, 행 변경 계수가 증가합니다 (그렇지 않으면). P5의 OPFLAG_LASTROWID 플래그가 설정되면, sqlite3_last_insert_rowid () 함수에 의한 후속 리턴을 위해 rowid가 저장됩니다 (그렇지 않으면 수정되지 않음).</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">P5 매개 변수의 OPFLAG_SAVEPOSITION 비트가 설정되면 커서는 테이블에서 다음 또는 이전 레코드를 가리 키도록 남습니다. 다음 레코드를 가리키고 있으면 다음 &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 명령어는 작동하지 않습니다. 결과적으로이 경우에는 &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 루프 내에서 레코드를 삭제해도됩니다 . P5의 OPFLAG_SAVEPOSITION 비트가 지워지면 커서는 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">P5의 OPFLAG_USESEEKRESULT 플래그가 설정되면, 커서 P1에 대한 불필요한 탐색을 피함으로써 구현이 더 빠르게 실행될 수 있습니다. 그러나 OPFLAG_USESEEKRESULT 플래그는 커서에 대한 사전 탐색이 없거나 가장 최근 탐색이 P3과 같은 키를 사용한 경우에만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">P5의 OPFLAG_USESEEKRESULT 플래그가 설정되면, 커서 P1에 대한 불필요한 탐색을 피함으로써 구현이 더 빠르게 실행될 수 있습니다. 그러나 OPFLAG_USESEEKRESULT 플래그는 커서에 대한 사전 탐색이 없거나 가장 최근 탐색이 P2와 동등한 키를 사용한 경우에만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">ORDER BY 표현식이 상수 정수 K 인 경우 표현식은 결과 세트의 K 번째 열에 대한 별명으로 간주됩니다 (열은 1부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨 짐).</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">ORDER BY 표현식이 출력 열 중 하나의 별명에 해당하는 식별자 인 경우 표현식은 해당 열의 별명으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">ORDER BY 표현식에 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하여 데이터 정렬 시퀀스가 ​​지정된 경우 지정된 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">P1 커서가 의사 테이블이 아닌 실제 테이블의 유효한 행 (NULL 행이 아님)을 가리켜 야하는 경우.</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 크거나 같은 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 큰 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 작거나 같은 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 작 으면 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">P1 값이 0이 아닌 경우, SQLITE_NULLEQ가 &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 에 설정되어 있어도 NULL 값이 동일하게 비교되지 않도록 MEM_Cleared 플래그도 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">P3 값이 0이 아닌 경우 참조되는 테이블은 intkey 테이블 (인덱스가 아닌 SQL 테이블)이어야합니다. 이 경우, 행 변경 계수는 지워지는 테이블의 행 수만큼 증가합니다. P3이 0보다 크면 레지스터 P3에 저장된 값도 지워지는 테이블의 행 수만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="translated">WITHOUT ROWID 테이블의 PRIMARY KEY가 동일한 배열 순서를 가진 동일한 컬럼을 두 번 이상 사용하는 경우 PRIMARY KEY 정의에서 해당 컬럼의 두 번째 및 후속 발생은 무시됩니다. 예를 들어, 다음 CREATE TABLE 문은 모두 동일한 테이블을 지정하며 디스크에서 정확히 동일한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">REINDEX 키워드 뒤에 데이터 정렬 시퀀스 이름이 있으면 이름 지정된 데이터 정렬 시퀀스를 사용하는 연결된 모든 데이터베이스의 모든 인덱스가 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">REINDEX 키워드 뒤에 데이터 정렬 순서 또는 데이터베이스 오브젝트 ID가 없으면 첨부 된 모든 데이터베이스의 모든 색인이 재 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;집계되지 않은 조회&lt;/b&gt; 인 경우 결과 표현식 목록의 각 표현식은 WHERE 절로 필터링 된 데이터 세트의 각 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;GROUP BY&lt;/b&gt; 절이 &lt;b&gt;있는 집계 쿼리 인 경우 GROUP BY&lt;/b&gt; 절의 일부로 지정된 각 표현식은 데이터 세트의 각 행에 대해 평가됩니다. 그런 다음 각 행은 결과에 따라 &quot;그룹&quot;에 할당됩니다. GROUP BY 표현식 평가 결과가 동일한 행이 동일한 그룹에 지정됩니다. 행을 그룹화하기 위해 NULL 값은 동일한 것으로 간주됩니다. GROUP BY 절에서 표현식을 평가할 때 텍스트 값을 비교할 &lt;a href=&quot;datatype3#collation&quot;&gt;데이터 정렬 순서&lt;/a&gt; 를 선택하는 일반적인 규칙이 적용됩니다. GROUP BY 절의 표현식은 결과에 나타나는 표현식 일 필요는 &lt;em&gt;없습니다&lt;/em&gt; . GROUP BY 절의 표현식은 집계 표현식이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;GROUP BY&lt;/b&gt; 절이 &lt;b&gt;없는 집계 쿼리 인&lt;/b&gt; 경우 결과 집합의 각 집계 식은 전체 데이터 집합에서 한 번 평가됩니다. 결과 집합의 각 집계되지 않은 식은 임의로 선택된 데이터 집합의 행에 대해 한 번 평가됩니다. 각 집계되지 않은 식에 대해 임의로 임의로 선택한 행이 사용됩니다. 또는 데이터 집합에 0 개의 행이 포함 된 경우 집계되지 않은 각 식은 모두 NULL 값으로 구성된 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">CREATE VIRTUAL TABLE 명령의 일부로 지정된 SELECT 문이 5 개의 열을 리턴하면 최종 열은 응용 프로그램 컨텍스트에만 사용됩니다. Swarmvtab은이 값이 &amp;lt;database-name&amp;gt; 다음에 지정된 경우 openclose 및 missing 함수 둘 다에 전달된다는 점을 제외하고는이 값을 전혀 사용하지 않습니다. 즉, 위에서 설명한대로 함수를 호출하는 대신 &quot;컨텍스트&quot;열이 있으면 swarmvtab이 대신 호출합니다.</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">SQL COMMIT 명령이 자동 커미트를 켜고 자동 커미트 논리가 변경을 커미트하려고 시도하지만 다른 프로세스가 SHARED 잠금을 보유하여 실패하면 자동 커미트가 자동으로 다시 꺼집니다. 이를 통해 사용자는 SHARED 잠금이 해제 된 후 나중에 COMMIT를 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">실행중인 SQL 문이 데이터를 리턴하면 호출자가 새 데이터 행을 처리 할 준비가 될 때마다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 가 리턴됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;열 액세스 기능을&lt;/a&gt; 사용하여 값에 액세스 할 수 있습니다 . 다음 데이터 행을 검색하기 위해 sqlite3_step ()이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">실행중인 SQL 문이 데이터를 리턴하면 호출자가 새 데이터 행을 처리 할 준비가 될 때마다 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 가 리턴됩니다. &lt;a href=&quot;column_blob&quot;&gt;열 액세스 기능을&lt;/a&gt; 사용하여 값에 액세스 할 수 있습니다 . 다음 데이터 행을 검색하기 위해 sqlite3_step ()이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQL 문이 현재 유효한 행을 가리 키지 않거나 열 색인이 범위를 벗어나면 결과가 정의되지 않습니다. 이 루틴은 가장 최근에 호출 할 때만 호출 할 수 있습니다.&lt;a href=&quot;#sqlite3_step&quot;&gt; sqlite3_step ()에&lt;/a&gt;&lt;a href=&quot;#SQLITE_ABORT&quot;&gt; SQLITE_ROW&lt;/a&gt; 를 리턴 하고 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 이후에 호출 되지 않은 . &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 이후 또는 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 이외의 것을 리턴 한 후 이러한 루틴이 호출 되면 결과가 정의되지 않습니다. 만약 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는&lt;a href=&quot;#sqlite3_finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt;이 루틴 중 하나가 보류중인 동안 다른 스레드에서 호출 된 후 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQL 문이 현재 유효한 행을 가리 키지 않거나 열 색인이 범위를 벗어나면 결과가 정의되지 않습니다. 이 루틴은 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 를 리턴 한 경우에만 호출 될 수 있습니다. 하지도 및&lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 이후에 호출 되지 . &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 이후 또는 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 이외의 것을 리턴 한 후 이러한 루틴이 호출 되면 결과가 정의되지 않습니다. 만약 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는&lt;a href=&quot;finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt;이 루틴 중 하나가 보류중인 동안 다른 스레드에서 호출 된 후 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE 비트가 F로 설정된 경우, SQLite는 데이터베이스 연결이 닫힐 때 직렬화 버퍼에서 sqlite3_free ()를 호출합니다. SQLITE_DESERIALIZE_RESIZEABLE 비트가 설정되면 SQLite는 sqlite3_realloc64 ()를 사용하여 버퍼 크기를 늘리려 고 시도합니다. 데이터베이스에 쓰면 M 바이트보다 커집니다.</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">P5의 SQLITE_JUMPIFNULL 비트가 설정되고 reg (P1) 또는 reg (P3)이 NULL이면 점프를 수행합니다. SQLITE_JUMPIFNULL 비트가 지워지면 피연산자 중 하나가 NULL이면 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">SQLite 라이브러리가 &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;NDEBUG&lt;/a&gt; 프리 프로세서 매크로없이 컴파일 된 경우 PRAGMA vdbe_trace 는 VDBE가 프로그램 실행을 추적하게합니다. 이 기능은 원래 테스트 및 디버깅을위한 것이었지만 VDBE 작동 방식을 배우는 데 유용 할 수도 있습니다. &quot; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &quot;을 사용하여 추적을 켜고 &quot; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &quot;를 사용하여 추적을 다시 끕니다. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="translated">UNIQUE 키워드가 CREATE와 INDEX 사이에 나타나면 중복 인덱스 항목이 허용되지 않습니다. 중복 항목을 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">CREATE와 INDEX 사이에 UNIQUE 키워드가 나타나면 중복 인덱스 항목이 허용되지 않습니다. 중복 항목을 삽입하려고하면 오류가 발생합니다. 고유 인덱스의 목적으로, 모든 NULL 값은 다른 모든 NULL 값과 다른 것으로 간주되므로 고유합니다. 이것은 SQL-92 표준에 대한 두 가지 가능한 해석 중 하나이며 (표준의 언어는 모호합니다) PostgreSQL, MySQL, Firebird 및 Oracle이 따르는 해석입니다. Informix 및 Microsoft SQL Server는 표준의 다른 해석을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 충돌 처리기 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴 한 후 UPDATE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 충돌 핸들러 함수가 다음과 같이 호출됩니다. &lt;a href=&quot;c_changeset_conflict&quot;&gt;&lt;/a&gt;두 번째 인수로 전달 된 SQLITE_CHANGESET_CONSTRAINT. 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴 한 후 UPDATE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">UPDATE 문에 WHERE 절이 없으면 테이블의 모든 행이 UPDATE에 의해 수정됩니다. 그렇지 않으면 UPDATE는 WHERE 절 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식이 true 인&lt;/a&gt; 행에만 영향을줍니다 . WHERE 절이 테이블의 행에 대해 true로 평가되지 않으면 오류가 아닙니다. 이는 UPDATE 문이 0 개의 행에 영향을 준다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">UPDATE 문에 ORDER BY 절이없는 경우 LIMIT 절이 없을 때 갱신 될 모든 행은 LIMIT 및 OFFSET 절을 적용하기 전에 임의의 순서로 어셈블되어 실제로 갱신되는 행을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">WAL- 인덱스가 메모리 매핑 된 파일로 구현되고 해당 파일이 연결할 첫 번째 스레드에 대해 읽기 전용 인 경우 해당 스레드는 개인 힙 메모리 ersazt WAL- 인덱스를 작성하고 복구 루틴을 실행하여 해당 개인 WAL을 채 웁니다. -인덱스. 동일한 데이터가 생성되지만 공용 공유 메모리 영역에 기록되는 것이 아니라 개인적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">WHERE 절이 FALSE로 평가되면 다음 단계를 건너 뛰고 다음 레코드로 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">WHERE 절이 없으면 테이블의 모든 레코드가 삭제됩니다. WHERE 절이 제공되면 WHERE 절이 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식 인&lt;/a&gt; 행만 이 true 인 삭제됩니다. 표현식이 false이거나 NULL 인 행은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">쿼리의 WHERE 절에 OR 표현식이 포함 된 경우 SQLite는 &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; 전략 ( &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화&lt;/a&gt; 라고도 함)을 사용할 수 있습니다. )을 사용할 수 있습니다. 이 경우 검색을위한 단일 최상위 레코드가 있고 각 색인마다 하나씩 두 개의 하위 레코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">sqlite3_free_filename (Y)에 대한 Y 매개 변수가 NULL 포인터 또는 이전에 sqlite3_create_filename ()에서 획득 한 포인터가 아닌 경우 힙 손상 또는 세그 폴트와 같은 나쁜 일이 발생할 수 있습니다. sqlite3_free_filename (Y)이 호출 된 후에 Y 값을 다시 사용해야합니다. 즉 , VFS 의 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen ()&lt;/a&gt; 메서드가 Y를 사용하여 호출 된 경우 sqlite3_free_filename (Y)을 호출하기 전에 해당 [sqlite3_module.xClose () 메서드도 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">_HAVE_SQLITE_CONFIG_H 매크로가 정의되면 SQLite 소스 코드는 &quot;config.h&quot;라는 파일을 #include 시도합니다. &quot;config.h&quot;파일에는 일반적으로 다른 구성 옵션, 특히 &quot;HAVE_</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">조치 코드가 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; 이고 콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하는 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴 된 경우 읽었던 테이블 컬럼 대신 NULL 값을 대체 하도록 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 명령문이 구성됩니다 . &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 복귀 테이블의 개별 컬럼 신뢰되지 않은 사용자 액세스를 거부 할 수있다. 테이블이 &lt;a href=&quot;lang_select&quot;&gt;SELECT에&lt;/a&gt; 의해 참조 되지만 해당 테이블에서 열 값이 추출되지 않는 경우 (예 : &quot;SELECT count (*) FROM 탭&quot;과 같은 쿼리) &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; 해당 테이블에 대해 열 이름이 권한 부 여기 콜백이 한 번 호출됩니다. 빈 문자열입니다. 조치 코드가 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE 인 경우&lt;/a&gt;콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 반환 하면 &lt;a href=&quot;lang_delete&quot;&gt;DELETE &lt;/a&gt; 조작이 진행되지만&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;자르기 최적화&lt;/a&gt; 가 비활성화되고 모든 행이 개별적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">조치 코드가 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; 이고 콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하는 경우 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴 된 경우 읽었던 테이블 컬럼 대신 NULL 값을 대체 하도록 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 명령문이 구성됩니다 . &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 복귀 테이블의 개별 컬럼 신뢰되지 않은 사용자 액세스를 거부 할 수있다. 테이블이 &lt;a href=&quot;../lang_select&quot;&gt;SELECT에&lt;/a&gt; 의해 참조 되지만 해당 테이블에서 열 값이 추출되지 않는 경우 (예 : &quot;SELECT count (*) FROM 탭&quot;과 같은 쿼리에서) 해당 테이블에 대해 열 이름이 있는 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; 권한 부 여기 콜백이 한 번 호출됩니다. 빈 문자열입니다. 조치 코드가 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE 인 경우&lt;/a&gt;콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하면 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 조작이 진행되지만 &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;절단 최적화&lt;/a&gt; 는 사용 불가능하고 모든 행이 개별적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="translated">애플리케이션이 트리거 또는보기를 사용하지 않는 경우 다음을 사용하여 사용되지 않는 기능을 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">애플리케이션이 트리거 또는보기를 사용하지 않는 경우 다음을 사용하여 사용하지 않는 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">애플리케이션이 트리거 또는 뷰를 사용하는 경우 쿼리를 사용하여 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블 을 스캔하여 트리거 및 뷰가 예상되고, 여분의 트리거 또는 뷰가 없는지, 기존 트리거 및 뷰가 변경되지 않았으며, 기존의 일반 테이블은 악성 뷰로 대체되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="translated">응용 프로그램 에 부작용이 있거나 권한이있는 정보를 유출 할 수 있는 &lt;a href=&quot;appfunc&quot;&gt;사용자 지정 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab#customvtab&quot;&gt;사용자 지정 가상 테이블&lt;/a&gt; 이 포함 된 경우 응용 프로그램은 아래 기술 중 하나 이상을 사용하여 악의적으로 제작 된 데이터베이스 스키마가 해당 SQL 기능을 몰래 실행하지 못하도록 방지해야합니다. 또는 악의적 인 목적을위한 가상 테이블 :</target>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">애플리케이션 이 닫기 전에 데이터베이스 연결에서 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; )을 호출 하면 최종 체크 포인트는 여전히 실행되지만 WAL 및 WAL 색인 파일은 정상적으로 삭제되지 않습니다. 이렇게하면 데이터베이스, WAL 또는 WAL- 인덱스 파일에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스를 읽기 전용으로 열 수있는 상태가됩니다. WAL 및 WAL- 인덱스 파일이 누락 된 경우, &lt;a href=&quot;uri#uriimmutable&quot;&gt;불변 쿼리 매개 변수를&lt;/a&gt; 사용하여 데이터베이스를 불변으로 지정하지 않으면 해당 파일을 작성하고 초기화 할 권한이없는 프로세스는 데이터베이스를 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">응용 프로그램이 작은 조각으로 데이터를 관리하도록 설계된 경우 데이터베이스는 큰 문자열이나 BLOB를 포함해서는 안되므로 위의 요소 1은 요소가되어서는 안됩니다. 데이터베이스에 큰 문자열 또는 BLOB가 포함 된 경우 &lt;a href=&quot;c3ref/blob&quot;&gt;증분 BLOB I / O를&lt;/a&gt; 사용하여 읽어야 하며 큰 문자열 또는 BLOB를 포함하는 행은 &lt;a href=&quot;c3ref/blob&quot;&gt;증분 BLOB I / O&lt;/a&gt; 이외의 다른 방법으로 업데이트해서는 안됩니다 . 그렇지 않으면, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 루틴은 어느 시점에서 전체 행을 연속 메모리로 읽어야하며, 이는 적어도 하나의 큰 메모리 할당을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">트랜잭션이 완료되기 전에 응용 프로그램 또는 호스트 컴퓨터가 충돌하면 롤백 저널 또는 미리 쓰기 로그에는 기본 데이터베이스 파일을 일관된 상태로 복원하는 데 필요한 정보가 포함됩니다. 롤백 저널 또는 미리 쓰기 로그에 데이터베이스 상태를 복구하는 데 필요한 정보가 포함 된 경우이를 &quot;핫 저널&quot;또는 &quot;핫 WAL 파일&quot;이라고합니다. 핫 저널 및 WAL 파일은 오류 복구 시나리오의 한 요인 일 뿐이므로 드문 일이지만 SQLite 데이터베이스 상태의 일부이므로 무시할 수 없습니다. 이 문서는 롤백 저널 및 미리 쓰기 로그 파일의 형식을 정의하지만 주요 데이터베이스 파일에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">애플리케이션 이 부작용이있는 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 를 사용하는 경우 해당 SQL 함수 에서 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그 를 설정하여 트리거 및 뷰에서 사용되지 않도록하는 것이 좋습니다 . 이 플래그의 중요성을 설명하기 위해 SQL 함수 &quot;send_money (...)&quot;를 구현하는 응용 프로그램을 고려하십시오. SQLITE_DIRECTONLY 플래그가 없으면 공격자는 해당 사용자 지정 함수를 사용하는 트리거 또는보기를 추가 한 다음 높은 권한의 응용 프로그램을 속여 악의적 인 트리거 또는보기를 호출하는 무해한 쿼리를 실행할 수 있습니다. SQLITE_DIRECTONLY 플래그는 &quot;send_money ()&quot;함수를 트리거 또는 뷰를 통해 간접적으로 실행하지 않고 애플리케이션에서 직접 호출하도록하여 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">응용 프로그램이 모든 내용을 메모리에 유지하려는 경우 첫 번째 페이지를 그린 후 백그라운드 스레드를 사용하여 다른 페이지를 읽고 구문 분석 할 수 있습니다. 또는 SQLite에서 읽는 것이 매우 효율적이기 때문에 응용 프로그램은 메모리 공간을 줄이고 한 번에 한 슬라이드 만 메모리에 유지하도록 선택할 수 있습니다. 또는 현재 슬라이드와 다음 슬라이드를 메모리에 유지하여 다음 슬라이드로 빠르게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">인수 N이 양수이면 제안 된 캐시 크기는 N으로 설정됩니다. 인수 N이 음수이면 캐시 페이지 수는 대략 abs (N * 1024) 바이트의 메모리를 사용하는 페이지 수로 조정됩니다. 현재 페이지 크기를 기준으로합니다. SQLite는 사용 된 메모리 양이 아니라 페이지 캐시의 페이지 수를 기억합니다. 따라서 음수를 사용하여 캐시 크기를 설정 한 다음 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; 명령을 사용하여 페이지 크기를 변경 하면 최대 캐시 메모리 양이 페이지 크기 변경에 비례하여 증가 또는 감소합니다.</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">인수 N이 0이면 소프트 힙 한계가 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">X ~ json (X) 인수에 중복 레이블이있는 JSON 오브젝트가 포함 된 경우 중복이 보존되는지 여부는 정의되지 않습니다. 현재 구현은 중복을 유지합니다. 그러나이 루틴에 대한 향후 개선 사항은 중복을 자동으로 제거하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">인수가 빈 문자열이면 권한 부여 프로그램이 비활성화됩니다. 인수가 생략되면 현재 권한 부여자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">% Q에 대한 인수가 널 포인터 인 경우 출력은 인용되지 않은 &quot;NULL&quot;입니다. 즉, 널 포인터는 SQL NULL을 생성하고 널이 아닌 포인터는 유효한 SQL 문자열 리터럴을 생성합니다. % q에 대한 인수가 널 포인터이면 출력이 생성되지 않습니다. 따라서 % q에 대한 널 포인터는 빈 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size에&lt;/a&gt; 대한 인수가 가 음수 N이면 페이지 크기에 관계없이 페이지 캐시에 약 -1024 * N 바이트의 메모리를 사용한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">sqlite3_mutex_enter (), sqlite3_mutex_try () 또는 sqlite3_mutex_leave ()에 대한 인수가 NULL 포인터이면 세 루틴 모두 no-ops로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">sqlite3_mutex_held ()에 대한 인수가 NULL 포인터 인 경우 루틴은 1을 리턴해야합니다. 뮤텍스가 존재하지 않으면 명확하게 보유 할 수 없으므로 반 직관적으로 보입니다. 그러나 뮤텍스가 존재하지 않는 이유는 빌드가 뮤텍스를 사용하지 않기 때문입니다. 그리고 sqlite3_mutex_held ()에 대한 호출을 포함하는 assert ()가 실패하는 것을 원하지 않으므로 0이 아닌 리턴이 적절합니다. sqlite3_mutex_notheld () 인터페이스는 NULL 포인터가 주어지면 1을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">배열 변수 이름이 생략되거나 빈 문자열 인 경우 각 열의 값은 열 자체와 이름이 같은 변수에 저장됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">다른 제한 조건 위반 (예 : NOT NULL 또는 UNIQUE)으로 인해 행 삽입 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 INSERT 조작이 재 시도되는 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">다른 제한 조건 위반 (예 : NOT NULL 또는 UNIQUE)으로 인해 행 삽입 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 INSERT 조작이 재 시도되는 경우가 여기에 포함됩니다..</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 동일한 기본 키 값을 가진 행이 이미 포함되어 행을 삽입하려는 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 동일한 기본 키 값을 가진 행이 이미 포함되어 행을 삽입하려는 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">bClear 인수가 0이 아닌 경우이 함수가 리턴되기 전에 보조 데이터가 지워집니다 (NULL로 설정 됨). 이 경우 xDelete가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">백업 프로세스가 충분히 자주 다시 시작되면 완료 될 때까지 실행되지 않으며 backupDb () 함수가 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">기본 표현식이 NULL 인 경우 CASE의 결과는 ELSE 표현식이있는 경우이를 평가 한 결과이며, 그렇지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">기본 창에 ORDER BY 절이 있으면 새 창에 복사됩니다. 이 경우 새 창에 ORDER BY 절을 지정해서는 안됩니다. 기본 창에 ORDER BY 절이 없으면 새 창 정의의 일부로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">닫힌 blob 핸들이 읽기 / 쓰기 액세스를 위해 열려 있고 데이터베이스가 자동 커미트 모드에 있고 다른 열린 읽기 / 쓰기 blob 핸들이나 활성 쓰기 명령문이없는 경우 현재 트랜잭션이 커미트됩니다. 트랜잭션을 커밋하는 동안 오류가 발생하면 오류 코드가 반환되고 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">차단 된 연결이 공유 캐시 테이블에서 쓰기 잠금을 얻으려고 시도하고 있고 하나 이상의 다른 연결이 현재 동일한 테이블에서 읽기 잠금을 보유하는 경우 SQLite는 다른 연결 중 하나를 임의로 차단으로 사용하도록 선택합니다. 연결.</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">58 행에서 &quot;c! = 0&quot;테스트를 구현하는 분기 명령어가 no-op로 변경되면 while 루프는 영원히 반복되며 테스트 스위트는 시간 초과로 실패합니다. 그러나 해당 분기가 무조건 점프로 변경되면 해시 함수는 항상 0을 반환합니다. 문제는 0이 유효한 해시라는 것입니다. 항상 0을 반환하는 해시 함수는 여전히 SQLite가 항상 정답을 얻는다는 의미에서 작동합니다. 테이블 이름 해시 테이블은 링크 된 목록으로 생성되므로 SQL 문을 구문 분석하는 동안 발생하는 테이블 이름 조회는 약간 느려질 수 있지만 최종 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">버퍼에 패치 세트가 포함 된 경우 동일한 변경 그룹 오브젝트에서이 함수에 대한 모든 이전 호출에도 지정된 패치 세트가 있어야합니다. 또는 버퍼에 변경 세트가 포함 된 경우이 함수에 대한 이전 호출이 있어야합니다. 그렇지 않으면 SQLITE_ERROR가 리턴되고 변경 사항이 변경 그룹에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">통화 중 콜백이 NULL이면 잠금이 발생하면 즉시 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 리턴됩니다. 통화 중 콜백이 NULL이 아닌 경우 두 개의 인수를 사용하여 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">통화 중 콜백이 NULL이면 잠금이 발생하면 즉시 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 리턴됩니다. 통화 중 콜백이 NULL이 아닌 경우 두 개의 인수를 사용하여 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">busy 메소드가 인수없이 호출되면 busy 메소드가 마지막으로 설정 한 콜백 프로 시저의 이름이 리턴됩니다. 콜백 프로 시저가 설정되지 않은 경우 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">H35040에서 규정 한 캐시 유효성 검사 절차가 필요하지만</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35140에 의해 요구되는 xAccess () 호출이 실패하면 (IO 오류 또는 이와 유사한 이유로) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490에 필요한 xAccess () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490에 필요한 xAccess () 호출로 저널 파일이 더 이상 파일 시스템에 존재하지 않는 것으로 밝혀지면 SQLite는</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35160에 필요한 xCheckReservedLock () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">H35160에 필요한 xCheckReservedLock () 호출이 다른 것으로 표시되는 경우</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450에 필요한 xDelete () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450에 필요한 xFileSize () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고하는 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35440에 의해 요구되는 xOpen ()에 대한 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려는 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">콜백 함수가 SQLITE_OK 이외의 값을 반환하면 쿼리가 취소되고 xQueryPhrase 함수가 즉시 반환됩니다. 리턴 된 값이 SQLITE_DONE 인 경우 xQueryPhrase는 SQLITE_OK를 리턴합니다. 그렇지 않으면 오류 코드가 위쪽으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()에&lt;/a&gt; 대한 콜백 함수가 0이 아닌 값을 리턴하면 sqlite3_exec ()는 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">테이블 X에 대한 변경 사항이 다른 테이블 또는 인덱스에 영향을 미치거나 트리거가 스키마 내의 뷰인 경우 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 다른 테이블 인덱스 및 뷰도 수정하십시오. 예를 들어 열 이름이 변경되면 해당 열을 참조하는 모든 FOREIGN KEY 제약 조건, 트리거, 인덱스 및 뷰를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">결과 세트의 열 이름이 AS 절로 명명 된 경우 SQLite는 AS 키워드의 오른쪽에있는 식별자를 열 이름으로 사용합니다. 결과 세트가 AS 절을 사용하지 않으면 SQLite는 원하는대로 열 이름을 자유롭게 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">레코드의 압축 방법이 0 또는 8 (아래 참조) 인 경우 압축 파일 항목과 연관된 압축되지 않은 데이터입니다. 또는 압축 방법이 0 또는 8이 아닌 경우이 열에는 NULL 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">내용이 압축되면 이러한 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; 데이터베이스는 동등한 ZIP 아카이브 &lt;a href=&quot;affcase1#smaller&quot;&gt;와 동일한 크기&lt;/a&gt; (&amp;plusmn; 1 %)이며 전체 문서를 다시 쓰지 않고도 개별 &quot;파일&quot;을 업데이트 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">서브 쿼리의 내용을 두 번 이상 방문해야 할 경우, 코 루틴은 데이터를 두 번 이상 계산해야하므로 코 루틴을 사용하는 것은 바람직하지 않습니다. 하위 쿼리를 병합 할 수없는 경우 하위 쿼리를 임시 테이블에 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">contentid 옵션을 languageid 옵션과 함께 사용하는 경우 명명 된 languageid 열이 content = 테이블에 존재해야합니다 (일반 규칙에 따라-쿼리가 내용 테이블을 읽을 필요가없는 경우에는이 제한이 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">이 명령으로 시작된 코 루틴이 &lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Return&quot;&gt;리턴으로&lt;/a&gt; 끝나면 다음 명령으로 계속 진행하십시오. 그러나이 명령어로 실행 된 코 루틴이 &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine으로&lt;/a&gt; 끝나면 다음 명령어를 계속 진행하지 않고 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">커버링 인덱스가 스캔에 사용되면 &quot;과일&quot;열이 올바른 순서로 자연스럽게 나타나지만 같은 과일을 가진 두 개 이상의 행이 있으면 가격이 잘못되었을 수 있습니다. 이런 일이 발생하면 SQLite는 하나의 큰 종류가 아닌 과일의 각 고유 한 가치에 대해 하나의 작은 종류를 많이 수행합니다. 아래의 그림 22는 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">현재 명령문이 명시 적 트랜잭션 ( &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 블록) 내에없는 경우 명령문 실행이 완료되는 즉시 내재적 트랜잭션이 커미트됩니다. 이 경우 지연된 제한 조건은 즉각적인 제한 조건과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">현재 버전의 SQLite가 3.8.2 이상인 경우 추정 행 필드는 제안 된 쿼리 계획에서 리턴 된 행 수의 추정치로 설정 될 수 있습니다. 이 값을 명시 적으로 설정하지 않으면 기본 추정치 25 행이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">SQLite의 현재 버전이 3.9.0 이상인 경우 idxFlags 필드는 SQLITE_INDEX_SCAN_UNIQUE로 설정되어 가상 테이블이 입력 제한 조건이 주어지면 0 개 또는 1 개의 행만 리턴 함을 표시 할 수 있습니다. idxFlags 필드의 추가 비트는 이후 버전의 SQLite에서 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">임시 테이블에서 커서 P1이 이미 열려 있으면 테이블이 지워집니다 (모든 내용이 지워짐).</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 항상 키와 같은 레코드에 도달하거나 즉시 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE의&lt;/a&gt; 연산 코드는이 연산 코드가 성공하면 생략하지만됩니다&lt;a href=&quot;opcode#IdxGE&quot;&gt; IdxGE의&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 항상 키와 같은 레코드에 도달하거나 즉시 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE의&lt;/a&gt; 연산 코드는이 연산 코드가 성공하면 생략하지만됩니다 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 키와 정확히 일치하는 레코드에 도달하거나 그렇지 않으면 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE의&lt;/a&gt; 이 연산 코드가 성공하면 오피 코드는 생략하지만, &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE의&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다. OPFLAG_SEEKEQ 플래그는 이것이 같음 검색임을 알리는 btree 계층에 대한 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 키와 정확히 일치하는 레코드에 도달하거나 그렇지 않으면 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT의&lt;/a&gt; 이 연산 코드가 성공하면 오피 코드는 생략하지만, &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT의&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다. OPFLAG_SEEKEQ 플래그는 이것이 같음 검색임을 알리는 btree 계층에 대한 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">데이터베이스 연결이 완료되지 않은 준비된 명령문 또는 완료되지 않은 sqlite3_backup 오브젝트와 연관된 경우 sqlite3_close ()는 데이터베이스 연결을 열린 상태로두고 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 . sqlite3_close_v2 ()가 완료되지 않은 준비된 명령문 및 / 또는 완료되지 않은 sqlite3_backups와 함께 호출 된 경우, 데이터베이스 연결은 사용할 수없는 &quot;좀비&quot;가되어 마지막 준비된 명령문이 완료되거나 마지막 sqlite3_backup이 완료 될 때 자동으로 할당이 해제됩니다. sqlite3_close_v2 () 인터페이스는 가비지 수집되고 소멸자가 호출되는 순서가 임의 인 호스트 언어와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">데이터베이스 연결이 완료되지 않은 준비된 명령문 또는 완료되지 않은 sqlite3_backup 오브젝트와 연관된 경우 sqlite3_close ()는 데이터베이스 연결을 열린 상태로두고 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 . sqlite3_close_v2 ()가 완료되지 않은 준비된 명령문 및 / 또는 완료되지 않은 sqlite3_backups와 함께 호출 된 경우, 데이터베이스 연결은 사용할 수없는 &quot;좀비&quot;가되어 마지막 준비된 명령문이 완료되거나 마지막 sqlite3_backup이 완료 될 때 자동으로 할당이 해제됩니다. sqlite3_close_v2 () 인터페이스는 가비지 수집되고 소멸자가 호출되는 순서가 임의 인 호스트 언어와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">데이터베이스 연결이 새로 열린 경우 데이터베이스에 대해 일부 쿼리를 준비한 다음 폐기하거나 sqlite3_table_column_metadata ()를 호출하여 오류를 무시하여 데이터베이스 스키마를 읽었는지 확인하십시오. 이 단계는 재설정 전에 WAL 모드에있는 경우 응용 프로그램이 재설정 후 데이터베이스를 WAL 모드로 유지하려는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">데이터베이스 파일에 별명 (하드 또는 소프트 링크)이 있고 저널을 작성하는 데 사용 된 것과 다른 별명으로 파일이 열리면 저널을 찾을 수 없습니다. 이 문제점을 피하려면 SQLite 데이터베이스 파일에 대한 링크를 작성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">데이터베이스 스키마가 변경되면 항상 사용했던대로 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 를 리턴하는 대신 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 SQL 문을 자동으로 다시 컴파일하고 다시 실행하려고합니다. 많은으로 &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY의&lt;/a&gt; ) (재 시도가 sqlite3_step 전에 발생합니다 오류를 포기하고 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">데이터베이스 스키마가 변경되면 항상 사용했던대로 &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 를 리턴하는 대신 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 SQL 문을 자동으로 다시 컴파일하고 다시 실행하려고합니다. 많은으로 &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY의&lt;/a&gt; ) (재 시도가 sqlite3_step 전에 발생합니다 오류를 포기하고 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">데이터베이스 스키마에 식별하기 위해 둘 이상의 테이블 정의를 조사해야하는 외래 키 오류가 포함 된 경우 테이블을 작성할 때 해당 오류가 감지되지 않습니다. 대신 이러한 오류는 응용 프로그램이 외부 키를 사용하는 방식으로 하위 또는 상위 테이블의 컨텐츠를 수정하는 SQL 문을 준비하지 못하게합니다. 내용이 변경 될 때보고 된 오류는 &quot;DML 오류&quot;이고 스키마가 변경 될 때보고되는 오류는 &quot;DDL 오류&quot;입니다. 즉, 자식 및 부모를 모두 확인해야하는 잘못 구성된 외래 키 제약 조건은 DML 오류입니다. 외래 키 DML 오류에 대한 영어 오류 메시지는 일반적으로 &quot;외래 키 불일치&quot;이지만 부모 테이블이없는 경우 &quot;해당 테이블이 없음&quot;일 수도 있습니다. 다음과 같은 경우 외래 키 DML 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">선언 된 유형에 &quot;INT&quot;문자열이 포함되면 INTEGER 선호도가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">열에 선언 된 유형에 문자열 &quot;REAL&quot;, &quot;FLOA&quot;또는 &quot;DOUB&quot;이 포함 된 경우 열에 REAL 선호도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">열에 선언 된 유형에 문자열 &quot;BLOB&quot;이 포함되거나 유형이 지정되지 않으면 열의 선호도가 BLOB입니다.</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">선언 된 유형의 열에 문자열 &quot;CHAR&quot;, &quot;CLOB&quot;또는 &quot;TEXT&quot;가 포함 된 경우 해당 열의 선호도는 TEXT입니다. VARCHAR 유형은 &quot;CHAR&quot;문자열을 포함하므로 TEXT 선호도가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">기본 진입 점 &quot;sqlite3_extension_init&quot;가로드 가능한 확장에없는 경우 진입 점 &quot;sqlite3_X_init&quot;도 시도하십시오. 여기서 &quot;X&quot;는 공유 라이브러리 파일 이름을 기반으로합니다. 이를 통해 모든 확장에 다른 진입 점이있을 수 있으므로 코드 변경없이 정적으로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">열의 기본값이 CURRENT_TIME, CURRENT_DATE 또는 CURRENT_TIMESTAMP 인 경우 새 행에 사용 된 값은 현재 UTC 날짜 및 / 또는 시간의 텍스트 표현입니다. CURRENT_TIME의 경우 값 형식은 &quot;HH : MM : SS&quot;입니다. CURRENT_DATE의 경우 &quot;YYYY-MM-DD&quot; CURRENT_TIMESTAMP의 형식은 &quot;YYYY-MM-DD HH : MM : SS&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">열의 기본값이 괄호 안에있는 표현식 인 경우 삽입 된 각 행과 새 행에 사용 된 결과에 대해 표현식이 한 번 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">열의 기본값이 상수 NULL, 텍스트, 얼룩 또는 부호있는 숫자 값이면 해당 값은 새 행에서 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">detail 옵션이 &lt;b&gt;column&lt;/b&gt; 으로 설정된 경우 각 항에 대해 FTS 인덱스는 항 오프셋 정보를 생략하고 rowid 및 열 번호 만 기록합니다. 결과적으로 다음과 같은 제한이 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">detail 옵션이 &lt;b&gt;none&lt;/b&gt; 으로 설정되면 각 용어에 대해 FTS 인덱스는 rowid 만 저장합니다. 열 및 오프셋 정보는 모두 생략됩니다. detail = column 모드에 대해 위에서 설명한 제한 사항 외에도 다음과 같은 추가 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">파일 크기가 0 바이트가 아니고 페이지 캐시에 데이터베이스의 첫 번째 페이지에 대한 유효한 데이터가 포함되어 있지 않으면 첫 번째 페이지의 데이터를 데이터베이스에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">쉘의 파일 이름 인수가 SQLite 데이터베이스가 아닌 ZIP 아카이브 인 경우 쉘은 &lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블을&lt;/a&gt; 사용하여 해당 ZIP 아카이브를 자동으로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">파일 이름이 &quot;: memory :&quot;이면 연결을위한 개인 임시 인 메모리 데이터베이스가 작성됩니다. 이 인 메모리 데이터베이스는 데이터베이스 연결이 닫히면 사라집니다. 이후 버전의 SQLite는 &quot;:&quot;문자로 시작하는 추가 특수 파일 이름을 사용할 수 있습니다. 데이터베이스 파일 이름이 실제로 &quot;:&quot;문자로 시작하는 경우 모호성을 피하기 위해 파일 이름 앞에 &quot;./&quot;와 같은 경로 이름을 붙여야합니다.</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">파일 이름이 빈 문자열이면 개인용 임시 온 디스크 데이터베이스가 작성됩니다. 이 개인 데이터베이스는 데이터베이스 연결이 종료되는 즉시 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="translated">이 루틴에서 반환 된 파일 이름 포인터가 NULL이 아닌 경우 다음 루틴에 대한 파일 이름 입력 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;파일 이름의 첫 문자가 파이프 기호 ( &quot;|&quot;)이면 나머지 문자는 명령으로 처리되고 출력은 해당 명령으로 전송됩니다. 따라서 쿼리 결과를 다른 프로세스로 쉽게 파이프 할 수 있습니다. 예를 들어, Mac에서 &quot;open -f&quot;명령은 텍스트 편집기를 열어 표준 입력에서 읽은 내용을 표시합니다. 따라서 텍스트 편집기에서 쿼리 결과를 보려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">flags 매개 변수가 0이 아닌 경우 BLOB는 읽기 및 쓰기 액세스를 위해 열립니다. flags 매개 변수가 0이면 BLOB은 읽기 전용 액세스를 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">프레임 유형이 RANGE 또는 GROUPS 인 경우 모든 ORDER BY 표현식에 대해 동일한 값을 가진 행은 &quot;피어&quot;로 간주됩니다. 또는 ORDER BY 용어가 없으면 모든 행이 피어입니다. 동료는 항상 같은 프레임 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">전체 텍스트 인덱스가 테이블의 내용과 일치하면 무결성 검사 명령을 호출하는 데 사용 된 INSERT가 성공합니다. 또는 불일치가 발견되면 &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; 오류 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">sqlite3_collation_needed () API를 사용하여 함수를 등록하면 정의되지 않은 데이터 정렬 시퀀스의 이름이 UTF-8로 인코딩 된 문자열로 전달됩니다. sqlite3_collation_needed16 ()을 사용하는 경우 이름은 머신 기본 바이트 순서로 UTF-16으로 전달됩니다. 두 함수 중 하나를 호출하면 기존 데이터 정렬이 필요한 콜백이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">mmap_size의 하드 상한이 컴파일 시간에 0이 아닌 경우 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; , X, Y) 인터페이스를 사용하여 시작시 여전히 감소하거나 제로화 될 수 있습니다 . X 및 Y 매개 변수는 모두 64 비트 부호있는 정수 여야합니다. X 매개 변수는 프로세스의 기본 mmap_size이고 Y는 새로운 하드 상한입니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE를&lt;/a&gt; 사용하여 컴파일 시간 설정보다 하드 상한을 늘릴 수는 없지만 줄이거 나 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">레지스터 P1의 초기 값이 1보다 작 으면 값이 변경되지 않고 제어가 다음 명령으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">삽입 조작으로 인해 충돌 대상 절로 식별 된 고유성 제한 조건이 실패하면 삽입이 생략되고 DO NOTHING 또는 DO UPDATE 조작이 대신 수행됩니다. 다중 행 삽입의 경우이 결정은 삽입의 각 행에 대해 별도로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">integrity_check pragma가 문제를 발견하면 문제를 설명하는 문자열이 반환됩니다 (행당 단일 열이있는 여러 행). Pragma integrity_check는 최대 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">반복자가 유효한 DELETE 또는 UPDATE 항목을 가리키는 경우, &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old ()&lt;/a&gt; API를 사용하여 변경 페이로드 내에서 old. * 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">반복자가 유효한 INSERT 또는 UPDATE 항목을 가리키는 경우, &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; API를 사용하여 변경 페이로드 내에서 new. * 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">반복자가 유효한 항목을 가리키는 경우 &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op ()&lt;/a&gt; API를 사용하여 반복자가 가리키는 변경 유형 (INSERT, UPDATE 또는 DELETE)을 판별 할 수 있습니다. 또한 동일한 API를 사용하여 변경 사항이 적용되는 테이블 이름과 예상되는 열 수 및 기본 키 열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="translated">대상 테이블과 FROM 절 간의 조인으로 인해 동일한 대상 테이블 행에 대해 여러 출력 행이 생성되는 경우 해당 출력 행 중 하나만 대상 테이블을 업데이트하는 데 사용됩니다. 선택된 출력 행은 임의적이며 SQLite의 한 릴리스에서 다음 릴리스로 또는 한 실행에서 다음 실행으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">조인 연산자가 &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot;또는 쉼표 ( &quot;,&quot;)이고 ON 또는 USING 절이없는 경우 조인 결과는 단순히 왼쪽의 데카르트 곱입니다. 그리고 오른 손잡이 데이터 세트. join-operator에 ON 또는 USING 절이있는 경우 다음 글 머리 기호에 따라 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">조인 연산자가 &quot;LEFT JOIN&quot;또는 &quot;LEFT OUTER JOIN&quot;인 경우 ON 또는 USING 필터링 절을 적용한 후 원래 왼쪽 입력 데이터 세트의 각 행에 대한 출력에 추가 행이 추가됩니다. 복합 데이터 세트에 행이 전혀없는 경우 (있는 경우) 추가 된 행에는 일반적으로 오른쪽 입력 데이터 집합에서 복사 한 값이 포함 된 열에 NULL 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">json_remove (X) 함수가 경로 인수없이 호출되면 초과 공백이 제거 된 상태로 재 입력 된 입력 X를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">마지막 클라이언트가 호출에 의해 아래로 깨끗하게 데이터베이스 닫힌다를 사용하는 경우 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close를 ()&lt;/a&gt; , 다음 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트는&lt;/a&gt; 주요 데이터베이스에 걸쳐 월마트 파일에서 모든 정보를 전송하기 위해 자동으로 실행되고, SHM 파일과 월마트 파일을 모두 연결이 해제된다. 따라서 클라이언트가 데이터베이스를 사용하지 않는 경우 일반적으로 주 데이터베이스 파일 만 디스크에 존재합니다. 그러나 마지막 클라이언트가 종료되기 전에 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 않았 거나 연결을 끊을 마지막 클라이언트가 읽기 전용 클라이언트 인 경우 최종 정리 작업이 수행되지 않고 shm 및 wal 파일이 디스크에 여전히 존재할 수 있습니다 데이터베이스를 사용하지 않는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">데이터베이스에 대한 마지막 연결이 중단 된 경우 데이터베이스를 열기위한 첫 번째 새 연결이 복구 프로세스를 시작합니다. 복구 중에는 독점 잠금이 유지됩니다. 따라서 두 번째 연결이 복구를 실행하는 동안 세 번째 데이터베이스 연결이 점프하여 쿼리를 시도하면 세 번째 연결에 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">이전 화면의 맨 아래 행에있는 성 및 이름이? 1 및? 2에 바인딩 된 경우 위의 쿼리는 다음 7 개의 행을 계산합니다. 또한 적절한 인덱스가 있다고 가정하면 OFFSET보다 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">라이브러리가 UTF-8에 대해 구성되지 않고 Tcl 라이브러리가 내부적으로 UTF-8을 사용하는 최신 라이브러리 중 하나 인 경우, UTF-8에서 iso8859 로의 변환 및 TCL 인터페이스 내부에서 다시 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 저널 모드를&lt;/a&gt; 처음 시작할 때 잠금 모드가 독점 인 경우 WAL 저널 모드 를 종료 한 후에야 잠금 모드를 NORMAL로 변경할 수 없습니다. WAL 저널 모드에 처음 들어갈 때 잠금 모드가 NORMAL이면 잠금 모드는 NORMAL과 EXCLUSIVE 사이에서 변경되었다가 언제라도 WAL 저널 모드를 종료하지 않고도 다시 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">FTS 쿼리의 일치 구문이 지정된 FTS 테이블 열의 데이터 일치로 제한되면 해당 열 내에서 발생하는 구문 일치 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">SQLite 내의 메모리 할당 하위 시스템이 무중단 작동을 위해 구성되었지만 실제 메모리 사용량이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof에&lt;/a&gt; 의해 설정된 설계 한계를 초과하는 경우 SQLite는 일반적으로 계속 정상적으로 작동합니다. &lt;a href=&quot;malloc#pagecache&quot;&gt;페이지 캐시 메모리 할당&lt;/a&gt; 과 &lt;a href=&quot;malloc#lookaside&quot;&gt;색인 (lookaside) 메모리 할당&lt;/a&gt; 을 자동 페일 오버받는 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 범용 메모리 할당. 그리고 일반적으로 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 메모리 할당자는 &lt;b&gt;M&lt;/b&gt; 및 / 또는 &lt;b&gt;n&lt;/b&gt; 이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증거&lt;/a&gt; 에 의해 부과 된 한계를 초과 하더라도 조각화없이 계속 작동 합니다. 그만큼&lt;a href=&quot;malloc#nofrag&quot;&gt; 롭슨 증거&lt;/a&gt;이 상황에서 메모리 할당이 중단되고 실패 할 수 있지만 이러한 실패에는 특히 비열한 할당 및 할당 해제 순서가 필요합니다 (SQLite가 따르지 않는 순서). 따라서 실제로 Robson에 의해 부과 된 한계가 악영향없이 상당한 마진을 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">누락 된 함수가 오류를 리턴하면 데이터베이스가 열리지 않고 오류가 사용자에게 리턴됩니다. openclose 기능이 구성된 경우이 시점에서 이전 &quot;open&quot;과 일치하도록 &quot;close&quot;호출이 발행됩니다. 다음 의사 코드는 구성 요소 데이터베이스를 열 때 누락 및 openclose 기능이 모두 구성된 swarmvtab 인스턴스가 사용하는 프로 시저를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 오류를 표시 한 경우 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 가 S 에서 호출 된 적이없는 경우 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 오류를 표시 한 경우 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 적절한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 가 S 에서 호출 된 적이없는 경우 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 가장 최근의 sqlite3_ * API 호출이 실패한 경우 sqlite3_errcode (D) 인터페이스는 해당 API 호출에 대한 숫자 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 를 리턴합니다 . sqlite3_extended_errcode () 인터페이스는 확장 결과 코드가 비활성화 된 경우에도 항상 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드를&lt;/a&gt; 반환한다는 점을 제외하면 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 가장 최근의 sqlite3_ * API 호출이 실패한 경우 sqlite3_errcode (D) 인터페이스는 해당 API 호출에 대한 숫자 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 를 리턴합니다 . sqlite3_extended_errcode () 인터페이스는 확장 결과 코드가 비활성화 된 경우에도 항상 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드를&lt;/a&gt; 반환한다는 점을 제외하면 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">nByte 인수가 음수이면 zSql은 첫 번째 0 종결 자까지 읽습니다. nByte가 양수이면 zSql에서 읽은 바이트 수입니다. nByte가 0이면 준비된 명령문이 생성되지 않습니다. 호출자가 제공된 문자열이 널 종료됨을 알고 있으면 입력 문자열의 바이트 수인 nByte 매개 변수를 전달하면 약간의 성능 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">데이터베이스 이름이 빈 문자열 인 경우 데이터베이스를 닫을 때 자동으로 삭제되는 임시 파일에서 새 데이터베이스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">새 변경 세트에 변경 그룹에 이미 존재하는 테이블에 대한 변경 사항이 포함 된 경우 테이블의 열 수와 기본 키 열의 위치가 일치해야합니다. 그렇지 않은 경우이 함수는 SQLITE_SCHEMA와 함께 실패합니다. 입력 변경 세트가 손상된 것으로 보이고 손상이 감지되면 SQLITE_CORRUPT가 리턴됩니다. 또는 처리 중에 메모리 부족 조건이 발생하면이 함수는 SQLITE_NOMEM을 리턴합니다. 모든 경우에 오류가 발생하면 변경 그룹의 최종 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="translated">새 변경 집합에 변경 그룹에 이미있는 테이블에 대한 변경 사항이 포함되어있는 경우 테이블에 대한 열 수와 기본 키 열의 위치가 일치해야합니다. 그렇지 않은 경우이 함수는 SQLITE_SCHEMA로 실패합니다. 입력 변경 집합이 손상된 것으로 보이고 손상이 감지되면 SQLITE_CORRUPT가 반환됩니다. 또는 처리 중에 메모리 부족 상태가 발생하면이 함수는 SQLITE_NOMEM을 반환합니다. 모든 경우에 오류가 발생하면 변경 그룹의 최종 내용 상태가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">새 한계가 음수이면 한계는 변경되지 않습니다. 각 제한 범주 SQLITE_LIMIT_에 대해</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">출력 행의 수가 K 인 경우 정렬에 필요한 시간은 KlogK에 비례합니다. K가 작은 경우 정렬 시간은 일반적으로 요인이 아니지만 K == N 인 위와 같은 쿼리에서 정렬에 필요한 시간은 전체 테이블 스캔에 필요한 시간보다 훨씬 클 수 있습니다. 또한 전체 출력은 임시 저장소 (다양한 컴파일 타임 및 런타임 설정에 따라 주 메모리 또는 디스크에있을 수 있음)에 누적되므로 쿼리를 완료하는 데 많은 임시 저장소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">운영 체제가 밀리 초 시간 해상도로 휴면 요청을 지원하지 않으면 시간은 가장 가까운 초로 반올림됩니다. 운영 체제에서 실제로 요청한 대기 시간 (밀리 초)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 공유 메모리의 특정 잠금을 확보하려고 시도하는 동안 운영 체제가 I / O 오류를 리턴하면 SQLite가 캐시를 재설정하지 못하여 후속 쓰기를 시도 할 경우 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">작업이 성공하면 SQLITE_OK가 반환됩니다. 그렇지 않으면 SQLite 오류 코드입니다. 이 경우 인수 pzErrMsg가 NULL이 아니면 * pzErrMsg가 영어 오류 메시지를 포함하는 버퍼를 가리 키도록 설정 될 수 있습니다. sqlite3_free ()를 사용하여이 버퍼를 해제하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">조작이 성공하면 SQLITE_OK가 리턴됩니다. 그렇지 않으면 SQLite 오류 코드입니다. 이 경우 pzErrMsg 인수가 NULL이 아닌 경우 * pzErrMsg는 영어 오류 메시지가 포함 된 버퍼를 가리 키도록 설정 될 수 있습니다. sqlite3_free ()를 사용하여이 버퍼를 해제하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">선택적 ESCAPE 절이 존재하면 ESCAPE 키워드 다음의 표현식은 단일 문자로 구성된 문자열로 평가되어야합니다. 이 문자는 LIKE 패턴에서 리터럴 백분율 또는 밑줄 문자를 포함하는 데 사용될 수 있습니다. 이스케이프 문자 뒤에 백분율 기호 (%), 밑줄 (_) 또는 이스케이프 문자 자체의 두 번째 인스턴스는 각각 리터럴 백분율 기호, 밑줄 또는 단일 이스케이프 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">선택적 IF NOT EXISTS 절이 존재하고 동일한 이름을 가진 다른 색인이 이미 존재하면이 명령은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">외부 쿼리가 집계이면 하위 쿼리에 ORDER BY가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">외부 쿼리가 복합 선택의 일부인 경우 하위 쿼리에 LIMIT 절이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">출력 매개 변수 (ppRebase) 및 (pnRebase)가 NULL이 아니고 입력이 변경 세트 (패치 세트가 아님) 인 경우 sqlite3changeset_apply_v2 ()는 (* ppRebase)가 &quot;rebase&quot;를 가리 키도록 설정할 수 있습니다. sqlite3_rebaser API는 리턴하기 전에 버퍼링합니다. 이 경우 (* pnRebase)는 버퍼 크기 (바이트)로 설정됩니다. sqlite3_free ()를 사용하여 그러한 버퍼를 결국 해제하는 것은 호출자의 책임입니다. 패치 세트를 적용하는 동안 하나 이상의 충돌이 발생한 경우에만 버퍼가 할당되고 채워집니다. 자세한 내용은 sqlite3_rebaser API를 둘러싼 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">매개 변수가 양수이면 B-tree 구조는 다음 중 하나에 해당하는 경우에만 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">매개 변수의 이름이 지정된 경우 해당 이름이 P4에 나타납니다. P4 값은 sqlite3_bind_parameter_name ()에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">매개 변수가 음수이고 FTS 인덱스 내에 둘 이상의 레벨에 B- 트리 구조가있는 경우 병합 조작이 시작되기 전에 모든 B- 트리 구조가 동일한 레벨로 지정됩니다. 또한 매개 변수가 음수이면 usermerge 구성 옵션의 값이 존중되지 않습니다. 같은 수준의 b- 트리가 몇 개나 병합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">경로가 BINARY 조합 순서를 사용하여 정렬되면 셀과 연관된 오버 플로우 페이지가 하위 페이지보다 정렬 순서에서 더 일찍 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">쓰려는 프로세스가 RESERVED 잠금을 확보 할 수없는 경우 다른 프로세스에 이미 RESERVED 잠금이 있음을 의미해야합니다. 이 경우 쓰기 시도가 실패하고 SQLITE_BUSY를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">progress 콜백이 0이 아닌 값을 반환하면 작업이 중단됩니다. 이 기능은 GUI 진행 대화 상자에서 &quot;취소&quot;버튼을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">쿼리에 ORDER BY 절이나 GROUP BY 절이 포함되어 있거나 쿼리에서 DISTINCT 키워드를 사용하는 경우 행을 정렬 된 순서대로 자연스럽게 표시하는 그래프를 통해 경로를 선택하면 별도의 정렬 단계가 필요하지 않습니다. . ORDER BY 절을 자동으로 제거하면 성능이 크게 달라질 수 있으므로 이는 완전한 구현에서 고려해야 할 또 다른 요소입니다.</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">사건없이 쿼리가 완료되면 SQLITE_OK가 반환됩니다. 또는 쿼리가 완료되거나 콜백에 의해 중단되기 전에 오류가 발생하면 SQLite 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">데이터베이스 파일에 쓰는 이유가 메모리 캐시가 가득 찼기 때문에 기록기가 즉시 커밋하지 않습니다. 대신 작성자가 다른 페이지를 계속 변경할 수 있습니다. 후속 변경 사항이 데이터베이스 파일에 기록되기 전에 롤백 저널을 디스크로 다시 플러시해야합니다. 기록기가 데이터베이스에 처음 쓰기 위해 얻은 EXCLUSIVE 잠금은 모든 변경 사항이 커밋 될 때까지 유지되어야합니다. 이는 메모리 캐시가 처음으로 유출 된 시점부터 트랜잭션이 커밋 될 때까지 다른 프로세스가 데이터베이스에 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">레코드에 P2보다 적은 필드가 포함 된 경우 NULL을 추출하십시오. 또는 P4 인수가 P4_MEM 인 경우 P4 인수의 값을 결과로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">복구 된 데이터베이스 스키마에 이미 &quot;lost_and_found&quot;라는 테이블이 포함 된 경우 &quot;.recover&quot;명령은 &quot;lost_and_found0&quot;이라는 이름을 사용합니다. &quot;lost_and_found0&quot;이라는 이름도 이미 사용중인 경우 &quot;lost_and_found1&quot;등입니다. 기본 이름 &quot;lost_and_found&quot;는 --lost-and-found 스위치로 &quot;.recover&quot;를 호출하여 재정의 될 수 있습니다. 예를 들어, 출력 스크립트가 &quot;분리 된 행&quot;테이블을 호출하도록하려면</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">요청 된 페이지가 이미 페이지 캐시에있는 경우 페이지 캐시 구현은 내용이 그대로있는 페이지 버퍼에 대한 포인터를 리턴해야합니다. 요청 된 페이지가 아직 캐시에 없으면 캐시 구현은 createFlag 매개 변수의 값을 사용하여 수행 할 조치를 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-16 문자열 인 경우 sqlite3_column_bytes16 () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-8 문자열 인 경우 sqlite3_column_bytes16 ()은 문자열을 UTF-16으로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes16 ()은 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-16 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes16 ()은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-16 문자열 인 경우 sqlite3_column_bytes16 () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-8 문자열 인 경우 sqlite3_column_bytes16 ()은 문자열을 UTF-16으로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes16 ()은 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-16 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes16 ()은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-8 문자열 인 경우 sqlite3_column_bytes () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-16 문자열 인 경우 sqlite3_column_bytes ()는 문자열을 UTF-8로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes ()는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-8 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes ()는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-8 문자열 인 경우 sqlite3_column_bytes () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-16 문자열 인 경우 sqlite3_column_bytes ()는 문자열을 UTF-8로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes ()는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-8 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes ()는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">결과가 BLOB 또는 TEXT 문자열 인 경우 sqlite3_column_bytes () 또는 sqlite3_column_bytes16 () 인터페이스를 사용하여 해당 BLOB 또는 문자열의 크기를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">결과가 소스 테이블 열의 이름이 아니라 일반 표현식 인 경우 결과 이름은 표현식 텍스트의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">쿼리 결과 집합이 비어 있으면 기본적으로 &lt;b&gt;sqlite_get_table&lt;/b&gt; 은 nrow를 0으로 설정하고 결과 매개 변수는 NULL로 설정합니다. 그러나 EMPTY_RESULT_CALLBACKS pragma가 ON이면 결과 매개 변수는 열 이름으로 만 초기화됩니다. 예를 들어 빈 결과 집합이있는이 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">IN 연산자의 오른쪽이 다음과 같이 값 목록이 될 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">행이 WITHOUT ROWID 테이블에서 오는 경우이 열에는 NULL이 포함됩니다. 그렇지 않으면 행에 대한 64 비트 정수 rowid 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOB 핸들이 가리키는 행이 &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 부작용으로 수정 되면 BLOB 핸들이 &quot;만료 됨&quot;으로 표시됩니다. BLOB 핸들이 열려있는 열 이외의 열을 포함하여 행의 열이 변경된 경우에도 마찬가지입니다. 만료 된 BLOB 핸들에 대한 &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 호출 은 리턴 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 로 실패 합니다. BLOB 만료 전에 BLOB에 기록 된 변경 사항은 BLOB 만료에 의해 롤백되지 않습니다. 트랜잭션이 계속 완료되면 이러한 변경 사항이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOB 핸들이 가리키는 행이 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 부작용으로 수정 되면 BLOB 핸들이 &quot;만료 됨&quot;으로 표시됩니다. BLOB 핸들이 열려있는 열 이외의 열을 포함하여 행의 열이 변경된 경우에도 마찬가지입니다. 만료 된 BLOB 핸들에 대한 &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 호출 은 리턴 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 로 실패 합니다. BLOB 만료 전에 BLOB에 기록 된 변경 사항은 BLOB 만료에 의해 롤백되지 않습니다. 트랜잭션이 계속 완료되면 이러한 변경 사항이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">두 개의 서로 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; ( &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 에 대한 개별 호출로 리턴 된 두 개의 서로 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; 객체)을 사용하여 동일한 데이터베이스를 읽고 쓰는 중이고 두 데이터베이스 연결에 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 가없는 경우 독자는 완결 된 커밋 만 볼 수 있습니다 작가의 거래. 커밋되지 않은 라이터의 부분 변경은 독자에게 보이지 않습니다. 이는 두 데이터베이스 연결이 동일한 스레드, 동일한 프로세스의 다른 스레드 또는 다른 프로세스에 있는지 여부에 관계없이 적용됩니다. 이것은 SQL 데이터베이스 시스템에서 일반적으로 예상되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">RELEASE 명령의 저장 점 이름이 현재 트랜잭션 스택에있는 저장 점과 일치하지 않으면 저장 점이 해제되지 않고 데이터베이스가 변경되지 않으며 RELEASE 명령이 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">두 번째 매개 변수 (zDbName)가 열려있는 데이터베이스 파일의 이름과 일치하지 않으면 SQLITE_ERROR가 리턴됩니다. 이 오류 코드는 기억되지 않으며 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; 의해 호출되지 않습니다 . 기본 xFileControl 메소드는 SQLITE_ERROR를 리턴 할 수도 있습니다. 기본 xFileControl 메소드에서 잘못된 zDbName과 SQLITE_ERROR 리턴을 구별 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">두 번째 매개 변수 (zDbName)가 열려있는 데이터베이스 파일의 이름과 일치하지 않으면 SQLITE_ERROR가 리턴됩니다. 이 오류 코드는 기억되지 않으며 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; 의해 호출되지 않습니다 . 기본 xFileControl 메소드는 SQLITE_ERROR를 리턴 할 수도 있습니다. 기본 xFileControl 메소드에서 잘못된 zDbName과 SQLITE_ERROR 리턴을 구별 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">H35450에 필요한 쿼리에 의해 잠재적으로 핫 저널 파일의 크기가 0 바이트보다 큰 것으로 밝혀지면 SQLite는</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">H35450에 의해 요구되는 쿼리에 의해 잠재적으로 핫 저널 파일의 크기가 0 바이트로 밝혀지면, SQLite는 저널 파일에서 열린 파일 핸들을 닫고 VFS xDelete () 메소드 호출을 사용하여 저널 파일을 삭제해야합니다. 이 경우 SQLite는</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획의 선택에 영향을 줄 수있는 경우, 스키마 변경이 발생한 것처럼 변경 후 첫 번째 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출 에서 명령문이 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 에 . WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 색인화 된 컬럼과 비교되고 &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획의 선택에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획의 선택에 영향을 줄 수있는 경우, 스키마 변경이 발생한 것처럼 변경 후 첫 번째 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출 에서 명령문이 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 에 . WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 색인화 된 컬럼과 비교되고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획의 선택에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절의 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획 선택에 영향을 미칠 수있는 경우, 스키마가 변경된 것처럼 명령문은 다음의 첫 번째 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 으로 변경합니다 . WHERE 절 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 인덱싱 된 열과 비교되고 &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획 선택에 영향을 미칠 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절의 &lt;a href=&quot;lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획 선택에 영향을 미칠 수있는 경우, 스키마가 변경된 것처럼 명령문은 다음의 첫 번째 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 으로 변경합니다 . WHERE 절 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 인덱싱 된 열과 비교되고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획 선택에 영향을 미칠 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">지정된 열이 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;이고 테이블이 &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니고 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열이 명시 적으로 선언 된 경우 명시 적으로 선언 된 열에 대해 출력 매개 변수가 설정됩니다. &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열 이 없으면 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 출력은 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">지정된 열이 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;이고 테이블이 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니고 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열이 명시 적으로 선언 된 경우 명시 적으로 선언 된 열에 대해 출력 매개 변수가 설정됩니다. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열 이 없으면 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 출력은 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">지정된 압축 또는 압축 해제 기능이 없으면 테이블이 여전히 작성 될 수 있습니다. FTS4 테이블을 읽거나 (압축 해제 기능이 존재하지 않는 경우) 존재하지 않는 압축 기능인 경우에는 오류가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">지정된 테이블이 실제로 뷰인 경우 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">지정된 테이블이 실제로 뷰인 경우 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">지정된 값이 정수 (또는 정수처럼 보이는 텍스트)이면 그대로 삽입됩니다. 값이 유효한 UNIX 모드가 아닌 경우 일부 프로그램은 아카이브에서 파일을 추출 할 때 예기치 않게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">지정된보기를 찾을 수없고 IF EXISTS 절이 없으면 오류입니다. 지정된보기를 찾을 수없고 IF EXISTS 절이 DROP VIEW 문에 존재하면 명령문은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange (X) 루틴이 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 내에서 호출 되면 열 값이 변경되지 않는 UPDATE 조작의 일부로 열을 페치하는 경우에만 true를 리턴합니다. 응용 프로그램은이를 사용하여 계산 비용이 덜 들고 해당 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메서드가 &quot;변경 없음&quot;값으로 이해 되는 반환 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange (X) 루틴이 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 내에서 호출 되면 열 값이 변경되지 않는 UPDATE 조작의 일부로 열을 페치하는 경우에만 true를 리턴합니다. 응용 프로그램은이를 사용하여 계산 비용이 덜 들고 해당 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메서드가 &quot;변경 없음&quot;값으로 이해 되는 반환 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">sqlite_stat1.idx 컬럼이 NULL 인 경우, sqlite_stat1.stat 컬럼은 sqlite_stat1.tbl에 의해 식별 된 테이블의 대략적인 행 수인 단일 정수를 포함합니다. sqlite_stat1.idx 열이 sqlite_stat1.tbl 열과 동일한 경우 테이블은 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이고 sqlite_stat1.stat 필드에는 WITHOUT ROWID 테이블을 구현하는 인덱스 btree에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">하위 쿼리가 복합 SELECT 인 경우</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">하위 쿼리가 복합 선택 인 경우 상위의 ORDER by 절의 모든 용어는 하위 쿼리의 열에 대한 간단한 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">부속 조회가 복합 선택 인 경우 ORDER BY 절을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">하위 쿼리가 LEFT JOIN의 오른쪽 피연산자 인 경우</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하는 경우 외부 조회에 WHERE 절이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하는 경우 외부 조회는 DISTINCT가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">테이블에 열이 32 개 이하인 경우 쿼리의 각 구에 대해 단일 부호없는 정수가 출력됩니다. 문구가 열 0에 적어도 한 번 나타날 경우 정수의 최하위 비트가 설정됩니다. 문구가 열 1에 한 번 이상 나타나면 두 번째 최하위 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">테이블에 32 개가 넘는 열이 있으면 추가 32 개 열 또는 그 일부에 대한 각 구의 출력에 추가 정수가 추가됩니다. 같은 문구에 해당하는 정수는 함께 모입니다. 예를 들어, 두 개의 구에 대해 45 개의 열이있는 테이블을 쿼리하면 4 개의 정수가 출력됩니다. 첫 번째는 테이블의 구 0과 열 0-31에 해당합니다. 두 번째 정수에는 구 0과 열 32-44 등의 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">테이블이 또한 내용이없는 테이블 인 경우 xInstCount, xInst, xPhraseFirst 및 xPhraseNext API는 현재 행에 구문이 일치하지 않는 것처럼 동작합니다 (즉, xInstCount ()는 0을 반환 함).</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">테이블이 내용이없는 테이블 인 경우 xPhraseFirstColumn 및 xPhraseNextColumn API는 현재 행에 구문이 일치하지 않는 것처럼 동작합니다 (즉, xPhraseFirstColumn ()은 반복자를 EOF로 설정합니다).</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">테이블이 호환되지 않으면 SQLITE_SCHEMA가 리턴됩니다. 테이블이 호환 가능하지만 PRIMARY KEY 컬럼이없는 경우 오류는 아니지만 세션 오브젝트에 변경 사항이 추가되지 않습니다. 다른 세션 API와 마찬가지로 PRIMARY KEY가없는 테이블은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">대상 데이터베이스 테이블에 INTEGER PRIMARY KEY가 있으면 IPK 열에 NULL 값을 삽입 할 수 없습니다. 이렇게하면 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">대상 데이터베이스 테이블이 가상 테이블이거나 PRIMARY KEY 선언이없는 테이블 인 경우 data_ % 테이블에도 &quot;rbu_rowid&quot;라는 열이 포함되어야합니다. rbu_rowid 컬럼은 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 테이블에 맵핑됩니다 . 예를 들어, 대상 데이터베이스에 다음 중 하나가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">대상 데이터베이스 테이블이 가상 테이블이거나 PRIMARY KEY가없는 테이블 인 경우 rbu_control 값은 rbu_rowid 값에 해당하는 문자를 포함하지 않아야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">텍스트 조각이 열 값의 시작 부분에서 시작되지 않으면 &quot;ellipses&quot;텍스트가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">텍스트 조각이 열 값의 끝에서 끝나지 않으면 &quot;ellipses&quot;텍스트가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">세 번째 매개 변수 (sqlite3_module 객체에 대한 포인터)가 NULL이면 새 모듈이 작성되지 않고 동일한 이름을 가진 기존 모듈이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">두 개의 스냅 샷 핸들이 동일한 데이터베이스 파일과 연관되지 않은 경우 비교 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">값 N이 범위를 벗어 났거나 N 번째 매개 변수에 이름이 없으면 NULL이 리턴됩니다. 이름 지정된 매개 변수가 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 에서 원래 UTF-16으로 지정된 경우에도 리턴 된 문자열은 항상 UTF-8 인코딩 입니다.</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">값 N이 범위를 벗어 났거나 N 번째 매개 변수에 이름이 없으면 NULL이 리턴됩니다. 이름 지정된 매개 변수가 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 에서 원래 UTF-16으로 지정된 경우에도 리턴 된 문자열은 항상 UTF-8 인코딩 입니다.</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">대체되는 값이 너비보다 크면 전체 값이 출력에 추가됩니다. 즉, 너비는 출력에서 ​​렌더링 될 때 값의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">경로 / 값 쌍의 값이 SQLite TEXT 값인 경우 문자열이 유효한 JSON처럼 보이더라도 인용 된 JSON 문자열로 삽입됩니다. 그러나 값이 다른 json1 함수 (예 : &lt;a href=&quot;json1#jmini&quot;&gt;json ()&lt;/a&gt; 또는 &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()&lt;/a&gt; 또는 &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()&lt;/a&gt; )의 결과 인 경우 JSON으로 해석되고 모든 하위 구조를 보유하는 JSON으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">zString 변수의 값이 NULL이면 생성 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">'삭제'명령의 일부로 텍스트 열에 &quot;삽입 된&quot;값이 현재 테이블에 저장된 값과 동일하지 않으면 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">변수에 바이트 배열 표현이 없으면 &quot;@&quot;은 &quot;$&quot;와 같이 작동합니다. &quot;:&quot;는 모든 경우에 &quot;$&quot;와 같이 작동하므로 다음은 동일한 문장을 표현하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">가상 머신이 다른 스레드 또는 프로세스에 의해 잠겨 있기 때문에 데이터베이스 파일을 열 수없는 경우 &lt;b&gt;sqlite_step&lt;/b&gt; 은 SQLITE_BUSY를 리턴합니다. 호출 함수는 잠금을 해제 할 기회를주기 위해 짧은 시간 동안 다른 활동 또는 휴면을 수행 한 다음 &lt;b&gt;sqlite_step을&lt;/b&gt; 다시 호출 해야합니다. 이것은 원하는만큼 반복 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">가상 테이블에 검색 기준과 일치하는 하나 이상의 행이 포함 된 경우 커서는 첫 번째 행에서 왼쪽을 가리켜 야합니다. &lt;a href=&quot;vtab#xeof&quot;&gt;xEof에 대한&lt;/a&gt; 후속 호출 은 false를 반환해야합니다. 일치하는 행이 없으면 &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; 가 true (0이 아님)를 리턴 하는 상태로 커서를 두어야합니다 . SQLite 엔진은 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메서드를 사용하여 해당 행 내용에 액세스합니다. &lt;a href=&quot;vtab#xnext&quot;&gt;Xnext를의&lt;/a&gt; 방법은 다음 행으로 진행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">가상 테이블이 ORDER BY 절에 지정된 순서대로 행을 출력하는 경우 orderByConsumed 플래그가 true로 설정 될 수 있습니다. 출력이 자동으로 올바른 순서가 아닌 경우 orderByConsumed를 기본 false 설정으로 두어야합니다. 이것은 가상 테이블에서 나온 데이터에 대해 별도의 정렬 패스를 수행해야한다는 것을 SQLite 코어에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">너비가 숫자 대신 단일 &quot;*&quot;문자 인 경우 실제 너비 값은 인수 목록에서 정수로 읽습니다. 읽은 값이 음수이면 너비에 절대 값이 사용되고 &quot;-&quot;플래그가있는 것처럼 값이 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">H35490에 의해 요구 된 xAccess () 쿼리가 저널 파일이 여전히 파일 시스템에 있음을 나타내면 SQLite는 저널 파일이</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">xColumn 메소드 구현이 위의 함수를 호출하지 않으면 열 값의 기본값은 SQL NULL입니다.</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">xCreate 메소드가 생략되면 (NULL 포인터로 남음) 가상 테이블은 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 입니다. &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE을&lt;/a&gt; 사용하여 가상 테이블의 새 인스턴스를 작성할 수 없으며 가상 테이블은 해당 모듈 이름을 통해서만 사용할 수 있습니다. 3.9.0 (2015-10-14) 이전의 SQLite 버전은 eponymous-only 가상 테이블을 이해하지 못하며 xCreate 메소드가 검사되지 않았기 때문에 eponymous-only 가상 테이블에서 &lt;a href=&quot;lang_createvtab&quot;&gt;VIRTUAL TABLE&lt;/a&gt; 을 작성하려고 시도하면 segfault가 발생합니다. null의 경우</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">xCreate 메소드가 xConnect 메소드와 정확히 동일한 포인터 인 경우 &lt;a href=&quot;vtab#xconnect&quot;&gt;이는&lt;/a&gt; 가상 테이블이 백업 저장소를 초기화 할 필요가 없음을 나타냅니다. 이러한 가상 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;시상 가상 테이블&lt;/a&gt; 또는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 또는 둘 다를 사용하여 명명 된 가상 테이블 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPoint 루틴에 오류가 발생하면 * pzErrMsg가 적절한 오류 메시지 ( &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻음)를 가리키고 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야 합니다 . SQLite는 xEntryPoint ()를 호출하기 전에 * pzErrMsg가 NULL인지 확인합니다. SQLite는 xEntryPoint ()가 리턴 된 후 * pzErrMsg에서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 합니다. xEntryPoint ()가 오류를 반환하면 xEntryPoint ()를 유발 한 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPoint 루틴에 오류가 발생하면 * pzErrMsg가 적절한 오류 메시지 ( &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻음)를 가리키고 적절한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야 합니다 . SQLite는 xEntryPoint ()를 호출하기 전에 * pzErrMsg가 NULL인지 확인합니다. SQLite는 xEntryPoint ()가 리턴 된 후 * pzErrMsg에서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 합니다. xEntryPoint ()가 오류를 반환하면 xEntryPoint ()를 유발 한 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">xUpdate 메소드가 UPDATE를 수행하는 경우 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 를 사용하여 UPDATE 문에 의해 실제로 수정 된 가상 테이블의 열을 발견 할 수 있습니다. &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 변경하지 않는 열에 대한 진정한 인터페이스로 돌아갑니다. 모든 UPDATE에서 SQLite는 먼저 테이블의 변경되지 않은 각 열에 대해 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn을&lt;/a&gt; 개별적으로 호출 하여 해당 열의 값을 얻습니다. &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는의&lt;/a&gt; 방법은 열이 호출하여 SQL 레벨 그대로 있는지 확인할 수 &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange을 ()&lt;/a&gt; . 경우 &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는이&lt;/a&gt; 열이 수정되지 않는 것을보고, 그 중 하나를 사용하여 결과를 설정하지 않고 리턴한다 &lt;a href=&quot;c3ref/result_blob&quot;&gt;) (을 sqlite3_result_xxxxx&lt;/a&gt;인터페이스. 이 경우에만 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 가 xUpdate 메소드 내에서 true가됩니다. &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 이 하나 이상의 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt; 인터페이스를 호출하는 경우 SQLite 는 xUpdate 내 에서 열 값과 해당 열에 대한 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 호출이 false로 리턴됨을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">xUpdate 메소드가 가상 테이블의 일부 제한 조건을 위반하는 경우 (잘못된 데이터 유형의 값 저장 시도, 너무 크거나 너무 작은 값 저장 시도 또는 읽기 전용 변경 시도 포함) xUpdate는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드로&lt;/a&gt; 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">zString 변수에 &quot;Hello&quot;와 같은 텍스트가 있으면이 명령문이 제대로 작동합니다. 그러나 사용자가 &quot;Hi y'all!&quot;과 같은 문자열을 입력한다고 가정하십시오. 생성 된 SQL 문은 다음과 같이 읽습니다.</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">네트워크를 통해 동일한 데이터베이스로 SQL을 전송하는 클라이언트 프로그램이 많은 경우 SQLite 대신 클라이언트 / 서버 데이터베이스 엔진을 사용하십시오. SQLite는 네트워크 파일 시스템을 통해 작동하지만 대부분의 네트워크 파일 시스템과 관련된 대기 시간으로 인해 성능이 좋지 않습니다. 또한 파일 잠금 로직은 많은 네트워크 파일 시스템 구현에서 유닉스와 Windows 모두에서 버그가 있습니다. 파일 잠금이 제대로 작동하지 않으면 둘 이상의 클라이언트가 동일한 데이터베이스의 동일한 부분을 동시에 수정하려고 시도하여 손상 될 수 있습니다. 이 문제는 기본 파일 시스템 구현의 버그로 인해 발생하므로이를 방지하기 위해 SQLite가 할 수있는 일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">데이터베이스 파일에 대한 여러 (하드 또는 기호) 링크가있는 경우 파일을 여는 링크의 이름을 사용하여 저널이 작성됩니다. 충돌이 발생하고 다른 링크를 사용하여 데이터베이스를 다시 열면 핫 저널이없고 롤백이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">데이터베이스 pDb에서 복사 할 페이지가 여전히 더 있으면이 함수는 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 유틸리티를 사용하여 250 밀리 초 동안 휴면 한 다음 2 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">&quot;examp&quot;테이블의 &quot;two&quot;열을 정수로 맵핑하는 인덱스가있는 경우 SQLite는 해당 인덱스를 사용하여 examp에서 열 2의 값이 50 인 모든 행 또는 모든 행의 정수 키를 찾습니다. 50 미만입니다. 그러나 다음 쿼리는 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">키에 하나 이상의 REPLACE 해상도가있는 경우 REPLACE에 따라 재조정됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">키에 REPLACE 해상도가없는 경우 로컬 변경 세트는 최신 OMIT 해상도에 따라 리베이스됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">USING 절이있는 경우 지정된 각 열 이름이 결합 연산자의 왼쪽과 오른쪽에있는 데이터 세트에 존재해야합니다. 명명 된 열의 각 쌍에 대해 &quot;lhs.X = rhs.X&quot;표현식은 직교 곱의 각 행에 대해 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식으로 평가&lt;/a&gt; 됩니다. 이러한 모든 표현식이 true로 평가되는 행만 결과 세트에 포함됩니다. USING 절의 결과로 값을 비교할 때, 선호도, 조합 순서 및 NULL 값을 처리하기위한 일반 규칙이 적용됩니다. 결합 연산자의 왼쪽에있는 데이터 집합의 열은 데이터 정렬 시퀀스 및 선호도 우선 순위를 위해 비교 연산자의 왼쪽에있는 것으로 간주됩니다 (=).</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">이 함수가 호출 될 때 이미 읽기 트랜잭션이 열려있는 경우 SQLITE_ERROR, SQLITE_BUSY 또는 SQLITE_ERROR_SNAPSHOT이 리턴되면 동일한 읽기 트랜잭션이 동일한 데이터베이스 스냅 샷에서 열린 상태로 유지됩니다. 다른 오류 코드 (예 : SQLITE_PROTOCOL 또는 SQLITE_IOERR 오류 코드)가 리턴되면 읽기 트랜잭션의 최종 상태가 정의되지 않은 것입니다. SQLITE_OK가 리턴되면 이제 데이터베이스 스냅 샷 P에서 읽기 트랜잭션이 열립니다.</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">이 함수가 호출 될 때 보조 데이터 포인터가 이미 있으면 새 포인터로 대체됩니다. 원래 포인터와 함께 xDelete 콜백이 지정된 경우이 시점에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">결과에 AS 절이 있으면 열 이름은 AS 절의 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">ON 절이 있으면 ON 식은 직교 곱의 각 행에 대해 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 식으로 평가&lt;/a&gt; 됩니다. 표현식이 true로 평가되는 행만 데이터 세트에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">호환 가능한 테이블이 없으면 오류가 아니지만 테이블과 관련된 변경 내용이 적용되지 않습니다. 오류 코드 SQLITE_SCHEMA와 함께 sqlite3_log () 메커니즘을 통해 경고 메시지가 발행됩니다. 변경 세트의 각 테이블마다 최대 하나의 이러한 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">명명 된 인덱스가없는 경우</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">자체 테스트 테이블이 없으면 &quot;.selftest&quot;명령은 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check를&lt;/a&gt; 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">FROM 절에 단일 테이블 또는 서브 쿼리 만있는 경우 SELECT 문에서 사용하는 입력 데이터는 이름 지정된 테이블의 컨텐츠입니다. FROM 절에 둘 이상의 테이블 또는 서브 쿼리가있는 경우 모든 테이블 및 / 또는 서브 쿼리의 컨텐츠가 단순 SELECT 문이 작동하도록 단일 데이터 세트에 결합됩니다. 정확하게 데이터를 결합하는 방법은 테이블 또는 하위 쿼리를 함께 연결하는 데 사용되는 특정 &lt;a href=&quot;syntax/join-operator&quot;&gt;조인 연산자&lt;/a&gt; 및 &lt;a href=&quot;syntax/join-constraint&quot;&gt;조인 제약 조건&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">이러한 루틴이 &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; 포인터 를 수신 한 응용 프로그램 정의 함수를 포함하는 것과 다른 스레드 내에서 호출 되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">이러한 루틴이 &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; 포인터 를 수신 한 응용 프로그램 정의 함수를 포함하는 것과 다른 스레드 내에서 호출 되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">이 C 프리 프로세서 매크로를 비활성화에서 &quot;연기 토큰&quot;최적화하면 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; . &quot;지연된 토큰&quot;최적화는 콜렉션의 대부분의 문서에있는 용어에 대해 대규모 게시 목록을로드하지 않고 대신 문서 소스에서 해당 토큰을 스캔합니다. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 는이 최적화 유무에 관계없이 정확히 같은 답을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">이 C 프리 프로세서 매크로가 정의되어 있고 데이터베이스 파일에 대한 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xDeviceCharacteristics 메소드가 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; 비트 중 하나를 통해 파일 시스템이 원자 쓰기를 지원한다고보고하고 트랜잭션이 데이터베이스의 단일 페이지 만 변경하는 경우 파일의 경우 트랜잭션이 데이터베이스의 단일 페이지에 대한 단일 쓰기 요청으로 커밋되고 롤백 저널이 작성되거나 기록되지 않습니다. 원자 적 쓰기를 지원하는 파일 시스템에서이 최적화는 작은 업데이트의 속도를 크게 향상시킬 수 있습니다. 그러나이 기능을 지원하는 파일 시스템은 거의 없으며이 기능을 확인하는 코드 경로는 원자 쓰기 기능이없는 시스템에서 쓰기 성능을 느리게하므로이 기능은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">이 C 전 처리기 매크로가 정의되면 디렉토리 동기화가 비활성화됩니다. SQLite는 일반적으로 파일을 삭제하면 디렉토리 항목이 디스크에서 즉시 업데이트되도록 상위 디렉토리 동기화를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">이 C 전 처리기 매크로가 정의되면 큰 파일 지원이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">이 C 전 처리기 매크로가 정의되면 &lt;a href=&quot;fts3#unicode61&quot;&gt;FTS3&lt;/a&gt; 의 unicode61 토크 나이 &lt;a href=&quot;fts3&quot;&gt;저는&lt;/a&gt; 빌드에서 생략되며 응용 프로그램에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">이 C 전 처리기 매크로가 정의 된 경우 8 개 이상의 파일 이름 만 지원하는 파일 시스템에서 SQLite가 작동 할 수 있도록하는 추가 코드가 포함됩니다. 이 매크로의 값이 1 인 경우 기본 동작은 &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;쿼리 매개 변수 와 함께 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 을 사용하여 데이터베이스 연결이 열린 경우 긴 파일 이름을 계속 사용하고 8 + 3 파일 이름 만 사용하는 것입니다 . 이 매크로의 값이 2이면 8 + 3 파일 이름 사용이 기본값이되지만 &lt;code&gt;8_3_names=0&lt;/code&gt; 쿼리 매개 변수 를 사용하여 사용하지 않도록 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">이 SELECT가 행을 전혀 반환하지 않으면 SQLite는 부모 테이블에서 행을 삭제하면 외래 키 제약 조건을 위반하고 오류를 반환한다고 결론을 내립니다. 부모 키의 내용이 수정되거나 새 행이 부모 테이블에 삽입되면 유사한 쿼리가 실행될 수 있습니다. 이러한 쿼리가 인덱스를 사용할 수없는 경우 전체 자식 테이블에 대한 선형 스캔을 수행해야합니다. 사소하지 않은 데이터베이스에서는 막대한 비용이 소요될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">이 확장이 SQLITE_ENABLE_ICU 프리 프로세서 기호가 정의 된 상태로 컴파일 된 경우 ICU 라이브러리를 사용하여 구현 된 &quot;icu&quot;라는 내장 토크 나이저가 있습니다. 이 토크 나이저의 xCreate () 메소드에 전달 된 첫 번째 인수 (fts3_tokenizer.h 참조)는 ICU 로케일 식별자 일 수 있습니다. 예를 들어 터키에서 사용되는 터키어의 경우 &quot;tr_TR&quot;또는 호주에서 사용되는 영어의 경우 &quot;en_AU&quot;입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">반복자가 유효한 항목을 가리 키지 않을 때이 함수가 호출되면 SQLITE_MISUSE가 리턴되고 출력 변수가 0이됩니다. 그렇지 않으면 SQLITE_OK가 리턴되고 출력 변수가 위에서 설명한대로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">더티 페이지를 디스크로 플러시하기 전에이 기능이 추가 데이터베이스 잠금을 얻어야하는 경우 그렇게합니다. 이러한 잠금을 즉시 얻을 수없고 사용중인 핸들러 콜백이 구성된 경우 일반적인 방식으로 호출됩니다. 필요한 잠금을 여전히 얻을 수 없으면 데이터베이스를 건너 뛰고 다음 (있는 경우) 데이터베이스에 속하는 더티 페이지를 플러시하려고 시도합니다. 잠금을 확보 할 수 없어서 데이터베이스를 건너 뛰지 만 다른 오류가 발생하지 않으면이 함수는 SQLITE_BUSY를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">이 전역 변수가 폴더의 이름 인 문자열 (일명 디렉토리)을 가리 키도록하면, 내장 된 Windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; 를 사용할 때 상대 경로 이름으로 지정되고 SQLite가 작성하거나 액세스 한 모든 데이터베이스 파일 이 해당 디렉토리에 상대적입니다. 이 변수가 NULL 포인터 인 경우 SQLite는 상대 경로 이름으로 지정된 모든 데이터베이스 파일이 프로세스의 현재 디렉토리에 상대적인 것으로 가정합니다. Windows VFS만이이 전역 변수를 사용합니다. 유닉스 VFS에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">이 전역 변수가 폴더의 이름 인 문자열 (일명 디렉토리)을 가리 키도록하면, 내장 된 Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 사용할 때 상대 경로 이름으로 지정되고 SQLite가 작성하거나 액세스 한 모든 데이터베이스 파일 이 해당 디렉토리에 상대적입니다. 이 변수가 NULL 포인터 인 경우 SQLite는 상대 경로 이름으로 지정된 모든 데이터베이스 파일이 프로세스의 현재 디렉토리에 상대적인 것으로 가정합니다. Windows VFS만이이 전역 변수를 사용합니다. 유닉스 VFS에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">이 글로벌 변수가 폴더 (일명 디렉토리)의 이름 인 문자열을 가리 키도록하면 내장 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; 를 사용할 때 SQLite가 작성한 모든 임시 파일 이 해당 디렉토리에 배치됩니다. 이 변수가 NULL 포인터 인 경우 SQLite는 적절한 임시 파일 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">이 글로벌 변수가 폴더 (일명 디렉토리)의 이름 인 문자열을 가리 키도록하면 내장 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 사용할 때 SQLite가 작성한 모든 임시 파일 이 해당 디렉토리에 배치됩니다. 이 변수가 NULL 포인터 인 경우 SQLite는 적절한 임시 파일 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">이 인터페이스가 xConnect 또는 xCreate 가상 테이블 메소드의 컨텍스트 외부에서 호출되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">이 매크로가 양의 정수로 정의 된 경우</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">이 매크로가 정의되면 특수 &quot;$</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">이 옵션을 정의하면 SQLite의 내장 날짜 및 시간 조작 기능이 생략됩니다. 특히 julianday (), date (), time (), datetime () 및 strftime () SQL 함수는 사용할 수 없습니다. 기본 열 값 CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP는 여전히 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">이 옵션이 정의되면 라이브러리는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 을 지원하는 데이터베이스를 작성하거나 쓸 수 없습니다 . &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; 문 실행 은 오류가 아니며 (알 수없는 PRAGMA는 자동으로 무시되므로) 데이터베이스 파일에서 값을 반환하거나 자동 진공 플래그를 수정하지 않습니다. 이 옵션으로 컴파일 된 라이브러리에서 자동 진공을 지원하는 데이터베이스를 열면 읽기 전용 모드로 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 구문이 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">이 옵션이 정의되면 &lt;a href=&quot;gencol&quot;&gt;생성 된 열&lt;/a&gt; 구문이 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 도구를 사용하여 parse.c 파일을 생성 할 때도 정의해야 합니다. 라이브러리가 아니라에서, 소스에서 빌드 할 때이 때문에,이 옵션은 사용할 수 있습니다 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 또는 웹 사이트 플랫폼과 같은 비 유닉스 제공 사전 패키지 C 파일의 컬렉션에서.</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">이 옵션을 사용하면 alloca () 메모리 할당자가 적절한 상황에서 사용됩니다. 이로 인해 약간 작고 빠른 이진이 만들어집니다. SQLITE_USE_ALLOCA 컴파일 타임은 물론 alloca ()를 지원하는 시스템에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="translated">이 옵션을 활성화하면 적절한 몇 가지 상황에서 alloca () 메모리 할당자가 사용됩니다. 이로 인해 약간 더 작고 빠른 바이너리가 생성됩니다. SQLITE_USE_ALLOCA 컴파일 타임은 물론 alloca ()를 지원하는 시스템에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">이 옵션에 0이 아닌 인수가 전달되면 &quot;.expert&quot;명령은 각 데이터베이스 테이블에 현재 저장된 행의 PERCENT 백분율을 기준으로 고려 된 모든 인덱스에 대해 유사한 데이터 분배 통계를 생성합니다. 비정상적인 데이터 배포가있는 데이터베이스의 경우 특히 응용 프로그램에서 ANALYZE를 실행하려는 경우 인덱스 권장 사항이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">이 옵션이 있으면 SQLite는 시스템 수학 라이브러리의 isnan () 함수를 사용합니다. &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; 구성 옵션 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">이 옵션이 있으면 내장 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자는 대소 문자를 구분합니다. &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma를&lt;/a&gt; 사용하면 런타임에 이와 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">이 루틴이 이전에 호출되지 않았거나 이전 호출이 N에 대해 P에 대한 하나 또는 NULL 포인터보다 작은 경우 PRNG는 기본 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xRandomness 메소드에서 얻은 임의성을 사용하여 시드됩니다 . 이 루틴에 대한 이전 호출의 N이 1 이상이고 NULL이 아닌 P 인 경우 의사 난수는 내부적으로 생성되지 않고&lt;a href=&quot;#sqlite3_vfs&quot;&gt; sqlite3_vfs&lt;/a&gt; xRandomness 메소드 .</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">이 루틴이 이전에 호출되지 않았거나 이전 호출이 N에 대해 P에 대한 하나 또는 NULL 포인터보다 작은 경우 PRNG는 기본 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xRandomness 메소드에서 얻은 임의성을 사용하여 시드됩니다 . 이 루틴에 대한 이전 호출의 N이 1 이상이고 NULL이 아닌 P 인 경우 의사 난수는 내부적으로 생성되지 않고&lt;a href=&quot;vfs&quot;&gt; sqlite3_vfs&lt;/a&gt; xRandomness 메소드 .</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">이 값이 리턴되면 지금까지 적용된 모든 변경 사항이 롤백되고 sqlite3changeset_apply ()에 대한 호출은 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">sqlite3_trace () 인터페이스를 통해 추적이 사용 가능한 경우 P4에 포함 된 UTF-8 문자열이 추적 콜백에서 생성됩니다. 또는 P4가 비어 있으면 sqlite3_sql ()에서 반환 한 문자열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">두 개의 데이터베이스 연결이 동일한 캐시를 공유하고 판독기가 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma를&lt;/a&gt; 활성화 한 경우 판독기는 기록기 트랜잭션이 커밋되기 전에 기록기가 변경 한 내용을 볼 수 있습니다. &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 와 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; 의 결합 사용 한 데이터베이스 연결이 다른 데이터베이스 연결에서 커밋되지 않은 변경 사항을 볼 수있는 유일한 방법입니다. 다른 모든 상황에서 별도의 데이터베이스 연결은 서로 완전히 격리됩니다.</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">단일 프로세스에서 둘 이상의 고유하지만 공유 가능한 인 메모리 데이터베이스가 필요한 경우 &lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt; query 매개 변수를 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 과 함께 사용할 수 있습니다 사용하여 명명 된 인 메모리 데이터베이스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">둘 이상의 스레드 가 동일한 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대해 하나 이상의 &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;열 메타 데이터 인터페이스&lt;/a&gt; 를 호출하는 경우 및 결과 열에 하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">두 개 이상의 스레드 가 동일한 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 및 결과 열에 대해 하나 이상의 &lt;a href=&quot;column_database_name&quot;&gt;열 메타 데이터 인터페이스&lt;/a&gt; 를 동시에 호출 하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">둘 이상의 스레드가 동일한 준비된 명령문 및 열에 대해 동시에 하나 이상의 이러한 루틴을 호출하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">두 프로세스가 동일한 데이터베이스 파일에 대한 열린 연결을 가지고 있고 한 프로세스가 해당 연결을 닫고, 파일을 링크 해제 한 다음, 동일한 이름으로 새 데이터베이스 파일을 작성하고 새 파일을 다시 열면 두 프로세스가 서로 다른 대화를합니다 같은 이름의 데이터베이스 파일. (이는 파일을 읽고 쓰기 위해 열려있는 상태에서 파일의 링크를 해제 할 수있는 Posix 및 Posix와 유사한 시스템에서만 가능합니다. Windows에서는이를 수행 할 수 없습니다.) 롤백 저널 및 WAL 파일은 데이터베이스 파일의 이름에 따라 두 개의 서로 다른 데이터베이스 파일은 동일한 롤백 저널 또는 WAL 파일을 공유합니다. 데이터베이스 중 하나에 대한 롤백 또는 복구는 다른 데이터베이스의 컨텐츠를 사용하여 손상 될 수 있습니다.데이터베이스 파일이 열려있는 동안 이름이 바뀌고 새 이름이 이전 이름으로 작성된 경우에도 비슷한 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">MATCH 또는 = 연산자를 사용하는 경우 MATCH 연산자의 왼쪽에있는 표현식은 일반적으로 FTS5 테이블의 이름입니다 (단 &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;, column-filter를 지정할&lt;/a&gt; 때 예외 ). 오른쪽의 표현식은 검색 할 용어를 지정하는 텍스트 값이어야합니다. 테이블 반환 함수 구문의 경우 검색 할 용어가 첫 번째 테이블 인수로 지정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">MinGW 컴파일러를 사용하는 경우 명령 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">amalgamation autoconf 기반 빌드 시스템을 사용하는 경우 'configure'스크립트를 실행하는 동안 CPPFLAGS 환경 변수를 설정하면 이러한 매크로를 쉽게 설정할 수 있습니다. 예를 들어, 다음 명령은</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">라이브러리를로드하려고 할 때 &quot;mach-o,하지만 잘못된 아키텍처&quot;라는 오류 메시지가 표시되면 명령 행 옵션 &quot;-arch i386&quot;또는 &quot;arch x86_64&quot;를 gcc에 추가해야합니다. 애플리케이션 구축 방법</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">감지하는 동안</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">xBestIndex가 반환하는 경우 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT을&lt;/a&gt; , 그 오류를 표시하지 않습니다. 오히려 SQLITE_CONSTRAINT는 지정된 입력 매개 변수 조합이 조회 계획에서 사용되지 않아야 함을 나타냅니다. SQLITE_CONSTRAINT 리턴은 필수 매개 변수가 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;있는 테이블 값 함수에&lt;/a&gt; 유용합니다 . 필수 매개 변수 중 하나에 대해 aConstraint []. usable 필드가 false 인 경우 xBestIndex 메소드는 SQLITE_CONSTRAINT를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">xRead ()가 SQLITE_IOERR_SHORT_READ를 리턴하면 버퍼의 읽지 않은 부분도 0으로 채워야합니다. 짧은 읽기를 0으로 채우지 못하는 VFS가 작동하는 것 같습니다. 그러나 짧은 읽기를 0으로 채우지 못하면 결국 데이터베이스가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">&lt;b&gt;sqlite_step을&lt;/b&gt; 부적절하게 호출하여 라이브러리를 남용하는 경우 SQLITE_MISUSE를 반환하려고 시도합니다. 두 개 이상의 스레드에서 동일한 가상 머신에서 sqlite_step ()을 동시에 호출하거나 SQLITE_DONE 또는 SQLITE_ERROR를 리턴 한 후 sqlite_step ()을 다시 호출하거나 sqlite_step (에 대한 유효하지 않은 가상 머신 포인터를 전달한 경우) ). 오류를 표시하기 위해 SQLITE_MISUSE 리턴 코드에 의존해서는 안됩니다. 인터페이스의 오용이 감지되지 않아 프로그램 충돌이 발생할 수 있습니다. SQLITE_MISUSE는 디버깅에 도움을주기위한 것으로, 사고 전에 잘못된 사용을 감지 할 수 있습니다. 오용 탐지 로직이 모든 경우에 작동하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">패턴 끝에 문자 '*'를 추가하면 접두사 검색이 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">&quot;러시아인&quot;이고 Rust가 이미 위에 나열된 전제 조건을 충족하고 Rust에서 SQLite를 코딩해야한다고 생각되면 SQLite 개발자에게 개인적으로 연락하여 귀하의 사례를 논의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">헌신적 인 Git 사용자 인 경우에도 SQLite에 쉽게 액세스 할 수 있습니다. 이 섹션에서는 그렇게하는 방법에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">여기에 언급되지 않은 SQLite 문제를 우연히 발견 한 SQLite 사용자 인 경우 문제를 문서화 할 수 있도록 이메일을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">별도의 소스 파일을 사용하는 경우 두 개의 병합 소스 파일 대신 모든 소스 파일의 이름을 지정하십시오. 이 작업이 완료되면 다음과 같이 변경 사항을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">많은 데이터를 삭제하고 데이터베이스 파일을 축소하려면 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 실행하십시오 . VACUUM은 데이터베이스를 처음부터 재구성합니다. 이렇게하면 데이터베이스에 빈 여유 목록과 최소 크기의 파일이 남습니다. 그러나 VACUUM을 실행하는 데 시간이 걸릴 수 있으며 실행중인 원본 파일보다 최대 두 배의 임시 디스크 공간을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">삭제하면</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">백업이 없으면 복구가 매우 어렵습니다. 원시 데이터베이스 파일의 이진 덤프에서 부분 문자열 데이터를 찾을 수 있습니다. 우리가 알고있는 도구는 존재하지 않지만 특수 도구를 사용하면 숫자 데이터를 복구 할 수도 있습니다. SQLite는 때때로 삭제 된 모든 내용을 0으로 덮어 쓰는 &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 옵션으로 컴파일 됩니다. 이 경우 복구가 분명히 불가능합니다. 데이터가 삭제 된 후 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행 한 경우에도 복구가 불가능합니다 . SQLITE_SECURE_DELETE가 사용되지 않고 VACUUM이 실행되지 않은 경우 삭제 된 컨텐츠 중 일부는 여전히 재사용이 표시된 영역의 데이터베이스 파일에있을 수 있습니다. 그러나 해당 데이터를 복구하는 데 도움이되는 절차 나 도구는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">웹 브라우저를 사용하여 새 체크인을 보지 않으려면 다음과 같은 명령을 사용하여 명령 줄에서 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">응용 프로그램에 동적 포인터 유형 문자열이 필요하다고 생각되면 포인터 전달 인터페이스를 잘못 사용하고 있음을 나타내는 강력한 지표입니다. 의도 한 사용이 안전하지 않을 수 있습니다. 디자인을 다시 생각하십시오. 먼저 SQL을 통해 포인터를 전달해야하는지 결정하십시오. 또는이 기사에서 설명하는 포인터 전달 인터페이스 이외의 다른 메커니즘을 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">설명서 나 코드에서 오류가 발견되면 언제든지 수정하거나 &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com으로&lt;/a&gt; 저자에게 문의하십시오 . 버그 수정이나 제안은 언제나 환영합니다.</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">데이터베이스 파일의 백업 사본이있는 경우 백업에서 정보를 복구하십시오.</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">큰 BLOB 데이터베이스가있는 경우 전체 BLOB 컨텐츠를 데이터베이스에 직접 저장할 때 더 나은 읽기 성능을 얻습니까? 아니면 각 BLOB를 별도의 파일에 저장하고 해당 파일 이름 만 데이터베이스에 저장하는 것이 더 빠릅니까?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">스크립트가 있고 해당 스크립트의 중간 지점에서 디버깅을 시작하려는 경우 test_breakpoint () 함수에서 gdb (또는 사용중인 디버거)에 중단 점을 설정하고 &quot;.breakpoint&quot;명령을 추가하십시오. 당신이 멈추고 싶은 곳. 첫 번째 중단 점에 도달하면 필요한 변수 추적 인 추가 중단 점을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">이전에 어셈블리 언어 프로그래밍을 수행했거나 어떤 종류의 추상 기계를 사용해 본 적이 있다면 이러한 모든 세부 사항이 익숙해야합니다. 이제 바로 들어가서 코드로 보이도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">이 가상 테이블을 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 테이블 과 함께 사용하여 (검색어의 철자 정정을 위해) &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; 테이블을 사용하여 어휘를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">원래 기준선에서 NL에서 CR-NL로 줄 끝을 변경하거나 공백에서 탭 들여 쓰기를 변경 한 경우 새 소스 파일을 동일하게 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">보유하고있는 SQLite 소스 코드가 정품이며 몇 가지 간단한 명령 줄 도구를 사용하여 수행 할 수있는 방식으로 (아마도 적에 의해) 수정되지 않았는지 확인해야하는 경우. SQLite 소스 트리의 루트에는 &quot;manifest&quot;라는 파일이 있습니다. 매니페스트 파일에는 소스 트리의 다른 모든 파일 이름과 해당 파일의 SHA1 또는 SHA3-256 해시가 포함됩니다. SHA1은 이전 파일에 사용되고 SHA3-256은 최신 파일에 사용됩니다. 이러한 해시를 추출하고 소스 코드 파일과 비교하여 스크립트를 확인할 수 있습니다. 체크인의 해시 이름은 &quot;manifest&quot;파일 자체의 SHA3-256 해시입니다.</target>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="translated">동일한 R-Tree에 대한 복잡한 쿼리를 기반으로 R-Tree를 업데이트해야하는 경우 먼저 복잡한 쿼리를 실행하고 결과를 임시 테이블에 저장 한 다음 저장된 값을 기반으로 R-Tree를 업데이트하는 것이 가장 좋습니다. 임시 테이블에서.</target>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">열 너비를 0으로 지정하면 열 너비는 최대 3 개의 숫자 (10, 머리글 너비 및 첫 번째 데이터 행 너비)로 자동 조정됩니다. 이것은 열 너비를 자동 조정합니다. 모든 열의 기본 너비 설정은이 자동 조정 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">라이브러리 버전 2.6.0 이상을 사용하여 원래 버전 2.5.6 이전에 작성된 데이터베이스 파일을 열면 데이터베이스를 새 형식으로 다시 빌드하려는 시도가 자동으로 수행됩니다. 큰 데이터베이스의 경우 시간이 걸릴 수 있습니다. (UNIX에서 1MB 또는 2MB의 데이터베이스 당 1 초 또는 2 초를 허용합니다. Windows에서는 더 깁니다.)이 형식 변환은 되돌릴 수 없습니다. 되는 &lt;strong&gt;강력&lt;/strong&gt; 할 경우에 대비하여 포맷 변환 논리에 오류가 나중에 라이브러리의 버전 2.6.0 또는 그들을 열기 전에 이전 데이터베이스 파일의 백업 복사본을 만들 것을 제안했다.</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">새 프로젝트를 구성하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">SQLite 라이브러리가 내부적으로 어떻게 작동하는지 알고 싶다면 Virtual Database Engine 또는 VDBE에 대한 이해를 시작해야합니다. VDBE는 처리 스트림의 중간에 발생 하므로 ( &lt;a href=&quot;arch&quot;&gt;아키텍처 다이어그램&lt;/a&gt; 참조 ) 라이브러리의 대부분을 터치하는 것 같습니다. VDBE와 직접 상호 작용하지 않는 코드 부분도 일반적으로 지원 역할을합니다. VDBE는 실제로 SQLite의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">키워드를 이름으로 사용하려면 키워드를 인용해야합니다. SQLite에는 키워드를 인용하는 네 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">각 데이터베이스 연결에 대한 확장 진입 점을 개별적으로 호출하지 않고 애플리케이션에서 여러 데이터베이스 연결을 여는 경우 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 인터페이스를 사용하여 확장을 등록하고 각 확장이 자동으로 시작되도록 할 수 있습니다 데이터베이스 연결이 열립니다. 각 확장명은 한 번만 등록하면되며 main () 루틴의 시작 부분 근처에서 등록 할 수 있습니다. 은 Using &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 당신의 확장을 등록하는 인터페이스 것은 그들이 핵심 SQLite는에 내장 된 것처럼 여러분의 확장 기능이 작동합니다 - 당신은 초기화 할 필요없이 새 데이터베이스 연결을 열 때마다 그들은 자동으로 존재한다. 사용을 위해 필요한 구성을 완료하십시오.&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()가&lt;/a&gt; 때문에, 당신의 확장을 등록하기 전에 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 인터페이스를 암시 적으로 호출 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">데이터가 불편하거나 단일 디스크 파일에 맞지 않는 크기로 커지면 SQLite 이외의 솔루션을 선택해야합니다. SQLite는 140 테라 바이트 파일을 지원하는 디스크 드라이브와 파일 시스템을 찾을 수 있다고 가정하면 최대 140 테라 바이트 크기의 데이터베이스를 지원합니다. 그럼에도 불구하고 컨텐츠의 크기가 테라 바이트 범위에 도달하는 것처럼 보일 경우 중앙 집중식 클라이언트 / 서버 데이터베이스를 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">데이터가 불편하거나 단일 디스크 파일에 들어갈 수없는 크기로 커질 경우 SQLite 이외의 솔루션을 선택해야합니다. SQLite는 최대 281 테라 바이트 크기의 데이터베이스를 지원하며, 282 테라 바이트 파일을 지원하는 디스크 드라이브와 파일 시스템을 찾을 수 있다고 가정합니다. 그럼에도 불구하고 콘텐츠의 크기가 테라 바이트 범위에 속할 것 같으면 중앙 집중식 클라이언트 / 서버 데이터베이스를 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">시스템이 SQLite에 대한 사용자 정의 OS 인터페이스를 정의하거나 문서화되지 않은 &lt;b&gt;sqlite3_os_switch ()를&lt;/b&gt; 사용중인 경우&lt;b&gt;&lt;/b&gt;인터페이스를 사용하려면 SQLite 버전 3.5.0으로 업그레이드하기 위해 수정해야합니다. 언뜻보기에는 고통스러워 보일 수 있습니다. 그러나 자세히 살펴보면 새로운 SQLite 인터페이스를 통해 변경 사항을 더 작고 이해하고 쉽게 관리 할 수 ​​있다는 것을 알게 될 것입니다. 변경 사항은 이제 SQLite 통합으로 원활하게 작동 할 것입니다. 더 이상 코드 SQLite 소스 코드를 변경할 필요가 없습니다. 모든 변경 사항은 응용 프로그램 코드에 의해 영향을받을 수 있으며 수정되지 않은 표준 버전의 SQLite 통합에 연결할 수 있습니다. 또한 이전에 문서화되지 않은 OS 인터페이스 계층은 이제 공식적으로 SQLite에 대한 지원 인터페이스입니다.따라서 이것이 일회성 변경이며 향후 버전의 SQLite에서 새 백엔드가 계속 작동 할 것이라는 확신이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">zipfile ()이 2 개의 인수로 호출되면, 아카이브에 추가 된 항목은 동일한 두 개의 값을 zipfile 가상 테이블의 &quot;name&quot;및 &quot;data&quot;열에 삽입하여 추가 한 것과 동일합니다. 없는. 4 개의 인수로 호출하면 4 개의 값을 &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;및 &quot;data&quot;열에 삽입하는 것과 같습니다. 즉, 다음과 같은 쿼리 쌍이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">만약에,</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">열면</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">&quot;.&quot;끝의 여분의 공백은 무시하십시오. 쉘의 명령.</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">sqlite3changeset_start ()에 의해 반복자가 작성된 직후에는 변경 세트의 변경을 가리 키지 않습니다. 변경 세트가 비어 있지 않다고 가정하면,이 함수를 처음 호출하면 반복자가 변경 세트의 첫 번째 변경을 가리 키도록 진행합니다. 이후의 각 호출은 반복자가 다음 변경 사항 변경 사항 (있는 경우)을 가리 키도록 진행합니다. sqlite3changeset_next () 호출이이를 수행 한 후 오류가 발생하지 않고 반복자가 유효한 변경을 가리키면 SQLITE_ROW가 리턴됩니다. 그렇지 않으면 변경 세트의 모든 변경 사항이 이미 방문한 경우 SQLITE_DONE이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">월 헤더 바로 다음에는 0 개 이상의 프레임이 있습니다. 각 프레임은 24 바이트 프레임 헤더와</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 를 호출 하고 이전 단계에서 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 구조에 대한 포인터를 전달 하는 프로 시저를 구현하십시오 . 이 절차는 VFS를 구현하는 소스 파일에서 내 보낸 유일한 심볼 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">SELECT 문에 &quot;LIMIT ... OFFSET ...&quot;절을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체에 필요한 메소드를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs에&lt;/a&gt; 필요한 다른 메소드를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">파일을 여는 xOpen 메소드를 구현하여 이전 단계 의 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 를 가리 키도록 pMethods 설정을 포함 하여 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">SQLite에 대한 구현 제한</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">집계 SQL 함수의 구현은이 루틴을 사용하여 상태를 저장하기위한 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">사용자 지정 보조 함수를 구현하는 것은 &lt;a href=&quot;appfunc&quot;&gt;스칼라 SQL 함수&lt;/a&gt; 를 구현하는 것과 유사 합니다 . 구현은 다음과 같이 정의 된 fts5_extension_function 유형의 C 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">사용자 정의 보조 기능을 구현하는 것은 &lt;a href=&quot;c3ref/create_function&quot;&gt;스칼라 SQL 함수&lt;/a&gt; 를 구현하는 것과 유사 합니다 . 구현은 다음과 같이 정의 된 fts5_extension_function 유형의 C 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">암시 적 거래와 명시 적 거래</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">중요한 버그 수정 : 왼쪽 또는 오른쪽이 INTEGER PRIMARY KEY에서 파생 된 경우 IN 연산자가 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">힙 크기에 제한을 두다</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">임 포스터 테이블</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">임 포스터 테이블은 분석 및 디버깅 전용입니다. 이것은 대부분의 응용 프로그램 개발자가 이해하거나 알아야 할 기능이 아닙니다. 임 포스터 테이블은 전문가 전용입니다.</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">임 포스터 테이블을 부적절하게 사용하면 인덱스 손상이 발생할 수 있지만 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 이러한 방식으로 작성된 손상을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">오른쪽 테이블이 고유하지만 반드시 NULL이 아닌 것은 아닌 경우에 &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;왼쪽 생략 조인 최적화를&lt;/a&gt; 개선하십시오 .</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">&lt;a href=&quot;optoverview#pushdown&quot;&gt;푸시 다운 최적화를&lt;/a&gt; 개선하여 많은 왼쪽 조인에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 원시 출력 의 형식을 개선하여 쿼리 계획 및 계획의 다양한 구성 요소 사이의 관계에 대한 더 나은 정보를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">OR 연산자와 하나 이상의 보조 fts 기능을 사용하는 fts3 / 4 쿼리의 성능을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">테스트 중에 OSSFuzz 시간 종료를 피하기 위해 메가 바이트 크기 문자열에 대한 대체가 많은 경우 &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace () SQL 함수&lt;/a&gt; 의 성능을 향상 시키십시오 . 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">동시성 향상</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">동시성 향상</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">&quot;long double&quot;을 사용하여 부동 소수점 변환의 정확성이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">ORDER BY와 LIMIT를 사용하여 쿼리를 실행하기위한 알고리즘이 개선되었습니다. 가장 안쪽의 루프 만 자연스럽게 올바른 순서로 행을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">동시성이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">충돌 방지 기능 향상 : 데이터베이스 페이지 크기를 롤백 저널 헤더에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">오른쪽에 집계 쿼리를 사용하여 &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; 문의 열 이름 인용을 개선 했습니다.</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">잘못 사용 된 집계 함수의 오류 감지 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">관련된 두 테이블의 이름을 표시하는 &quot;외부 키 불일치&quot;에 대한 오류 메시지가 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 유효하지 않은 부울 인수에 대한 점 명령에 대한 오류 메시지가 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; 확장의 오류 메시지가 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">발견 된 문제점에 대한 수정 사항으로 데이터베이스 파일의 퍼지 테스트 개선.</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">깊이 중첩 된 쿼리의 이름 확인 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; 연산자의 최적화가 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">하나 또는 다른 피연산자가 상수 일 때 AND 및 OR 연산자의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">복합 쿼리에서 ORDER BY 절의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">집계 쿼리에 포함 된 집계 하위 쿼리의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">집계 min () 또는 max ()를 포함하는 쿼리의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="translated">t (x, y)에 대한 인덱스를 가정하여 &quot;SELECT min (x) FROM t WHERE y IN (?,?,?)&quot;와 같은 쿼리 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">WHERE 절에서 모두 인덱싱 할 수있는 많은 OR 연결 용어로 쿼리 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">configure 스크립트에서 향상된 pthreads 감지.</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">DISTINCT 키워드가있을 때 향상된 쿼리 계획 최적화.</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">응용 프로그램 이 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; 테이블 을 불완전하거나 잘못 수정하여 구피 쿼리 플래너 결정에 대한 내성이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">메모리 부족 오류에 대한 응답 개선</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">손상된 데이터베이스 파일에 대한 견고성 향상</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">Cygwin에 대한 지원이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">winsqlite3.dll에서 STDCALL 호출 규칙 사용에 대한 지원이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">파서의 구문 오류 메시지 개선</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">테스트 범위 개선</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">테스트 범위가 향상되었습니다. 개선 된 테스트에서 발견 된 몇 가지 모호한 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">인덱스의 열을 사용하고 테이블 조회를 수행 할 필요없이 WHERE 절을 포함하는 인덱스 스캔 비용 추정을 개선했습니다. &lt;a href=&quot;#version_3_12_0&quot;&gt;버전 3.12.0에&lt;/a&gt; 도입 된 ORDER BY LIMIT 최적화에 따라 일부 불분명 한 쿼리에 대해 발생한 성능 회귀를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">하나 이상의 분리가 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; , &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; 연산자를 사용하더라도 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화를&lt;/a&gt; 사용할 수 있도록 쿼리 플래너를 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">안티 바이러스 소프트웨어의 간섭으로부터보다 효과적으로 방어 할 수 있도록 Windows VFS를 개선했습니다.</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFS의&lt;/a&gt; 향상된 추적 및 디버깅 기능 .</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Windows 의 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 유니 코드 파일 이름 처리 기능이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; 지원에 대한 개선 및 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; 에서 &quot;점 명령&quot;처리 기능이 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 개선 .</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화를&lt;/a&gt; 위한 비용 추정 개선 .</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#round&quot;&gt;round ()&lt;/a&gt; 함수를 사용하여 이진수를 반올림 한 결과가 십진법으로 생각하는 데 익숙한 사람들이 실제로 기대하는 것과 비슷 하도록 반올림 동작이 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">테스트 범위 개선, 기타 사소한 버그 수정, 메모리 누수 막힘, 코드 리팩토링 및 / 또는 쉽게 읽을 수있는 장소에서 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">&quot;.help&quot;명령이 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">&quot;PRAGMA integrity_check&quot;명령 개선</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 개선 :</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">받는 사람 개선 &lt;a href=&quot;cli#recover&quot;&gt;.recover는 점-명령을&lt;/a&gt; 에서 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 가 손상된 데이터베이스 파일에서 더 많은 콘텐츠를 복구하도록.</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">많은 수의 업데이트가 필요한 전체 텍스트 인덱스의 인덱스 크기를보다 잘 제어 할 수 있도록 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 의 &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge 명령&lt;/a&gt; 이 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너&lt;/a&gt; 개선 :</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;syntaxdiagrams&quot;&gt;구문 버블 다이어그램&lt;/a&gt; 개선</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">VisualStudio에서 사용하는 Makefile 및 빌드 스크립트 개선.</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">모든 기호 앞에 SQLITE_PRIVATE 또는 SQLITE_API가 붙도록 병합 생성기 스크립트가 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN을&lt;/a&gt; 실행할 때 VDBE 바이트 코드 표시의 주석이 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#likely&quot;&gt;possible ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely ()&lt;/a&gt; SQL 힌트 함수 의 효과 및 정확성이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 CSV 입력 처리 개선</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">쿼리 플래너가 개선되어 계획 비용을 더 잘 예측할 수 있으므로 특히 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 를 사용할 때 올바른 계획을 선택하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">windows makefile 및 빌드 프로세스가 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="translated">&quot;열&quot;모드 (또한 &quot;상자&quot;, &quot;표&quot;및 &quot;마크 다운&quot;모드)에서는 열 너비가 자동으로 조정됩니다. 그러나 &quot;.width&quot;명령을 사용하여 각 열에 최소 너비를 제공하여이를 재정의 할 수 있습니다. &quot;.width&quot;에 대한 인수는 각 열에 할당 할 최소 공백 수인 정수입니다. 음수는 오른쪽 정렬을 의미합니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">&quot;라인&quot;모드에서는 데이터베이스 행의 각 열이 한 줄에 표시됩니다. 각 줄은 열 이름, 등호 및 열 데이터로 구성됩니다. 연속적인 레코드는 빈 줄로 구분됩니다. 라인 모드 출력의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">&quot;인용 부호&quot;모드에서 출력은 SQL 리터럴로 형식화됩니다. 문자열은 작은 따옴표로 묶고 내부 작은 따옴표는 두 배로 이스케이프됩니다. Blob은 16 진 Blob 리터럴 표기법으로 표시됩니다 (예 : x'abcd '). 숫자는 ASCII 텍스트로 표시되고 NULL 값은 &quot;NULL&quot;로 표시됩니다. 모든 열은 쉼표로 구분됩니다 (또는 &quot;.separator&quot;를 사용하여 대체 문자를 선택).</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">에서 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; , 다중 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 같은 데이터베이스 파일에 열려있는 각 데이터베이스 파일의 서로 다른 역사적 버전을 읽을 수 있습니다. 때 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 읽기 트랜잭션을 시작하는 트랜잭션이 처음 시작할 때 시점에 대한 존재로, 그 연결은 데이터베이스의 불변의 사본을 본다. 다른 연결에서 데이터베이스에 대한 후속 변경 사항은 새 읽기 트랜잭션이 시작될 때까지 판독기에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">에서는 &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007년 9월 4일), 공유 캐시 모드는 동일한 캐시 프로세스 전체에 걸쳐보다는 단일 스레드 내에서 공유 될 수 있도록 변경되었다. 이 변경 이전에는 스레드간에 데이터베이스 연결을 전달하는 데 제한이있었습니다. 이러한 제한은 3.5.0 업데이트에서 삭제되었습니다. 이 문서는 버전 3.5.0부터 공유 캐시 모드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">에서 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = TRUNCATE의&lt;/a&gt; 모드, 전화 fsync를 () 즉시 저널 파일을 절단 한 후 트랜잭션이 전력 손실에서 내구성이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">에서 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 오류의 결과를 한 번 이상 동일한 데이터베이스 파일을 첨부하려고.</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="translated">에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 작가 충돌과 나뭇잎 경우, &lt;a href=&quot;walformat#shm&quot;&gt;SHM 파일&lt;/a&gt; 일관성 상태를, 후속 트랜잭션이 활성화 읽기 트랜잭션이 경우에도 SHM 파일을 복구 할 수 있습니다. 이 향상 이전에는 shm 파일 복구 시나리오에서 &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , 다중 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 같은 데이터베이스 파일에 열려있는 각 데이터베이스 파일의 서로 다른 역사적 버전을 읽을 수 있습니다. 때 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 읽기 트랜잭션을 시작하는 트랜잭션이 처음 시작할 때 시점에 대한 존재로, 그 연결은 데이터베이스의 불변의 사본을 본다. 다른 연결에서 데이터베이스에 대한 후속 변경 사항은 새 읽기 트랜잭션이 시작될 때까지 판독기에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">동기가 NORMAL (1) 인 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 모드에서 WAL 파일은 각 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 전에 동기화 되고 데이터베이스 파일은 완료된 각 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 후에 동기화 되고 WAL 파일 헤더는 체크 포인트 후에 재사용되기 시작하면 동기화됩니다. 동기화 작업은 대부분의 트랜잭션 중에 발생합니다. WAL 모드에서 synchronous = FULL을 사용하면 각 트랜잭션 커밋 후에 WAL 파일의 추가 동기화 작업이 수행됩니다. 각 트랜잭션 다음에 나오는 추가 WAL 동기화는 전원 손실시 트랜잭션이 지속되도록합니다. 트랜잭션은 synchronous = FULL에서 제공하는 추가 동기화와 함께 또는없이 동기화됩니다. 내구성이 중요하지 않은 경우 일반적으로 WAL 모드에서 synchronous = NORMAL이 모두 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">DDL에서</target>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">DML에서</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">I / O 오류 테스트에서 I / O 오류 시뮬레이션 실패 메커니즘이 비활성화 된 후 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 를 사용하여 데이터베이스를 검사하여 I / O 오류가 데이터베이스 손상을 유발 하지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">레몬에서는 토크 나이저가 파서를 호출합니다. Yacc는 다른 방법으로 작동하며 파서는 토크 나이저를 호출합니다. 레몬 접근 방식은 재진입 및 스레드 안전성을 제공하지만 Yacc는 전역 변수를 사용하므로 둘 다 적용되지 않습니다. 재 입력은 일부 SQL 문이 파서를 재귀 적으로 호출하기 때문에 SQLite에 특히 중요합니다. 예를 들어, CREATE TABLE 문을 구문 분석 할 때 SQLite는 구문 분석기를 재귀 적으로 호출하여 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블 에 새 항목을 작성하기 위해 INSERT 문을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">NORMAL 잠금 모드 ( &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE를&lt;/a&gt; 사용하여 컴파일 타임에 대체되지 않는 한 기본값 )에서 데이터베이스 연결은 각 읽기 또는 쓰기 트랜잭션이 끝날 때 데이터베이스 파일의 잠금을 해제합니다. 잠금 모드가 EXCLUSIVE로 설정되면 데이터베이스 연결은 파일 잠금을 해제하지 않습니다. EXCLUSIVE 모드에서 처음으로 데이터베이스를 읽을 때 공유 잠금이 확보되어 유지됩니다. 데이터베이스가 처음 작성 될 때 독점 잠금이 확보되어 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">SQLite에서</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;버전 3.10.0&lt;/a&gt; (2016-01-06) 이상에서 colUsed 필드는 준비중인 명령문에서 실제로 사용되는 가상 테이블의 필드를 나타내는 데 사용 가능합니다. colUsed의 최하위 비트가 설정되면 첫 번째 열이 사용됨을 의미합니다. 두 번째로 낮은 비트는 두 번째 열에 해당합니다. 기타 등등. colUsed의 최상위 비트가 설정되면 처음 63 개 열 이외의 하나 이상의 열이 사용됨을 의미합니다. &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 에 열 사용 정보가 필요한 경우 필요한 비트를 idxNum 또는 idxStr 출력 필드로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;버전 3.28.0&lt;/a&gt; (2019-04-16)에서 Windows 함수 지원은 EXCLUDE 절, GROUPS 프레임 유형, 창 체인 및 &quot;&amp;lt;expr&amp;gt; PRECEDING&quot;및 &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot;경계 지원을 포함하도록 확장되었습니다. 범위 프레임.</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">SQLite는에서 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;버전 3.6.23.1&lt;/a&gt; (2010-03-26) 및 이전 버전, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 항상 반환하는 데 사용 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 이 이외의 반환 후 다시 호출 된 경우 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW을&lt;/a&gt; 에 개입 호출하지 않고 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . 이로 인해 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 및 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류 반환을 올바르게 처리하지 못하는 잘못 작성된 스마트 폰 응용 프로그램에서 문제가 발생했습니다 . 결함이있는 많은 스마트 폰 애플리케이션을 수정하는 대신 SQLite의 동작이 3.6.23.2에서 변경되어 준비된 명령문을 자동으로 재설정합니다. 그러나 변경으로 인해 실제로 구현하려는 다른 부적절하게 구현 된 응용 프로그램에서 문제가 발생했습니다.&lt;a href=&quot;rescode#misuse&quot;&gt; SQLITE_MISUSE를 했습니다.&lt;/a&gt;쿼리 루프를 종료하려면 리턴하십시오. (응용 프로그램이 SQLite에서 SQLITE_MISUSE 오류 코드를받을 때마다 응용 프로그램이 SQLite 인터페이스를 잘못 사용하여 잘못 구현되었음을 의미합니다.) SQLITE_OMIT_AUTORESET 인터페이스는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;버전 3.7.5&lt;/a&gt; (2011-02-01)에 추가되었습니다. 실제로 응용 프로그램을 수정하지 않고도 모든 (깨진) 응용 프로그램을 다시 작동시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이상 에서 자동 인덱스를 사용하는 명령문을 준비 할 때마다 &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; 메시지가 &lt;a href=&quot;errlog&quot;&gt;오류 로그로&lt;/a&gt; 전송됩니다 . 응용 프로그램 개발자는 이러한 경고를 사용하여 스키마에 새로운 영구 인덱스가 필요한지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">SQLite 버전 3에서</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">SQLite 버전 2에서</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">SQLite 버전 2에서는 많은 프로세스가 데이터베이스에서 읽고있는 경우 활성 리더가없는 시간이 없을 수 있습니다. 그리고 데이터베이스에 항상 하나 이상의 읽기 잠금이있는 경우 쓰기 잠금을 획득 할 수 없기 때문에 데이터베이스를 변경할 수있는 프로세스가 없습니다. 이 상황을 &lt;em&gt;작가 기아&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">SQLite 버전 3에서 sqlite3_exec 루틴은 준비된 명령문 인터페이스 호출에 대한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">SQLite 버전 3.0에서 rowid는 64 비트 부호있는 정수입니다. 이것은 32 비트의 rowid 만 허용하는 SQLite 버전 2.8의 확장입니다.</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">SQLite 버전 3.5.0 및 3.5.1에서는 이러한 루틴의 내장 구현이 생략되도록하는 SQLITE_OMIT_MEMORY_ALLOCATION을 정의 할 수있었습니다. 해당 기능은 더 이상 제공되지 않습니다. 내장 메모리 할당 자만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">공유 캐시 모드가 사용 가능한 SQLite 버전 3.3.0-3.4.2에서 데이터베이스 연결은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이라는 스레드에서만 사용할 수 있습니다. 그리고 연결은 동일한 스레드에서 다른 연결과 만 캐시를 공유 할 수 있습니다. 이러한 제한은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007-09-04) 부터 시작되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">SQLite에서 INTEGER PRIMARY KEY 유형의 열 은 항상 64 비트 부호있는 정수인 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 의 별칭 ( &lt;a href=&quot;withoutrowid&quot;&gt;without ROWID&lt;/a&gt; 테이블 제외 )입니다.</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">SQLite에서 데이터베이스 개체 (테이블, 인덱스, 트리거 또는 뷰)는 개체 이름과 개체가있는 데이터베이스 이름으로 식별됩니다. 데이터베이스 개체는 기본 데이터베이스, 임시 데이터베이스 또는 는 &lt;a href=&quot;lang_attach&quot;&gt;데이터베이스를 부착&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">SQLite에서 테이블 행은 일반적으로 동일한 테이블의 모든 행에서 고유 한 64 비트 부호있는 정수 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 갖습니다. ( &lt;a href=&quot;withoutrowid&quot;&gt;ROWID WITHOUT&lt;/a&gt; 테이블은 예외).</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">SQLite에서 이전 질문에 대한 대답은 &quot;아니오&quot;입니다. 테스트 목적으로 SQLite 소스 코드는 ALWAYS () 및 NEVER ()라는 매크로를 정의합니다. ALWAYS () 매크로는 항상 true로 평가 될 것으로 예상되는 조건을 둘러싸고 NEVER ()는 항상 false로 평가되는 조건을 둘러 쌉니다. 이러한 매크로는 조건이 방어 코드임을 나타내는 주석 역할을합니다. 릴리스 빌드에서 다음 매크로는 통과입니다.</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">SQLite에서 assert (X)가 존재한다는 것은 개발자가 X가 항상 참이라는 증거를 가지고 있음을 의미합니다. 독자들은 코드에 대한 추론을 돕기 위해 X가 참인지에 의존 할 수 있습니다. assert (X)는 X의 진실에 대한 강력한 진술입니다. 의심 할 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">WAL 모드에서는 wal-index를 사용하여 데이터베이스에 대한 변경이 감지되므로 변경 카운터가 필요하지 않습니다. 따라서 WAL 모드에서 각 트랜잭션마다 변경 카운터가 증가하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">A의 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; 문, 표현의 모든 순서는 화합물의 결과 열 중 하나에 대한 별칭으로 처리됩니다. ORDER BY 표현식이 정수 별명이 아닌 경우 SQLite는 위의 두 번째 또는 세 번째 규칙과 일치하는 결과 열을 찾기 위해 화합물에서 가장 왼쪽의 SELECT를 검색합니다. 일치하는 것이 있으면 검색이 중지되고 표현식은 일치하는 결과 열의 별명으로 처리됩니다. 그렇지 않으면 오른쪽의 다음 SELECT가 시도됩니다. 구성 SELECT의 결과 열에서 일치하는 표현식을 찾을 수 없으면 오류입니다. ORDER BY 절의 각 용어는 개별적으로 처리되며 복합에서 다른 SELECT 문의 결과 열과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">A의 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; 문, 마지막 또는 오른쪽 가장 &lt;a href=&quot;lang_select#simpleselect&quot;&gt;간단한 SELECT는&lt;/a&gt; ORDER BY 절을 가질 수있다. 해당 ORDER BY 절은 화합물의 모든 요소에 적용됩니다. &lt;a href=&quot;lang_select#compound&quot;&gt;복합 SELECT&lt;/a&gt; 의 가장 오른쪽 요소 가 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; 절인 경우 해당 명령문에 ORDER BY 절이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">A의 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; , 마지막 또는 오른쪽 가장 &lt;a href=&quot;lang_select#simpleselect&quot;&gt;간단한 SELECT는&lt;/a&gt; 한계 절을 포함 할 수있다. A의 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물 SELECT&lt;/a&gt; 는 LIMIT 절은 전체 화합물뿐만 아니라 최종 선택에 적용됩니다. 가장 &lt;a href=&quot;lang_select#simpleselect&quot;&gt;간단한 SELECT&lt;/a&gt; 가 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES 절&lt;/a&gt; 이면 LIMIT 절이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">기본 표현식이있는 CASE에서 기본 표현식은 한 번만 평가되며 결과는 왼쪽에서 오른쪽으로 각 WHEN 표현식의 평가와 비교됩니다. CASE 표현식의 결과는 비교가 참인 첫 번째 WHEN 표현식에 해당하는 THEN 표현식의 평가입니다. 또는 WHEN 표현식이 기본 표현식과 동일한 값으로 평가되지 않으면 ELSE 표현식을 평가 한 결과가있는 경우 해당 결과입니다. ELSE 표현식이없고 WHEN 표현식이 기본 표현식과 동일한 결과를 생성하지 않으면 전체 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">기본 표현식이없는 CASE에서 각 WHEN 표현식이 평가되고 결과는 가장 왼쪽에서 시작하여 오른쪽으로 계속되는 부울로 처리됩니다. CASE 표현식의 결과는 true로 평가되는 첫 번째 WHEN 표현식에 해당하는 THEN 표현식의 평가입니다. 또는 WHEN 표현식이 true로 평가되지 않으면 ELSE 표현식을 평가 한 결과 (있는 경우)입니다. ELSE 표현식이없고 WHEN 표현식이 모두 없으면 전체 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">복합 SELECT에서 모든 구성 SELECT는 동일한 수의 결과 열을 반환해야합니다. 복합 SELECT의 구성 요소는 단순 SELECT 문이어야하므로 &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; 또는 &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; 절을 포함 할 수 없습니다 . &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; 및 &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; 절은 전체 복합 SELECT의 끝에서만, 그리고 화합물의 최종 요소가 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; 절이 아닌 경우에만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">RBU 애플리케이션에서 정의한 사용자 정의 형식으로.</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">ptrmap 페이지를 사용하는 데이터베이스에서 이전 단락의 계산으로 식별 된 위치의 모든 페이지는 ptrmap 페이지 여야하며 다른 페이지는 ptrmap 페이지가 될 수 없습니다. 바이트 잠금 페이지가 ptrmap 페이지와 동일한 페이지 번호에 해당하는 경우를 제외하고 해당 경우에 대해 ptrmap이 다음 페이지로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">ptrmap 페이지가있는 데이터베이스에서 첫 번째 ptrmap 페이지는 2 페이지입니다. ptrmap 페이지는 5 바이트 항목의 배열로 구성됩니다. J를 사용 가능한 페이지 공간에 맞는 5 바이트 항목 수로 설정하십시오. (즉, J = U / 5) 첫 번째 ptrmap 페이지에는 3에서 J + 2까지의 페이지에 대한 백 포인터 정보가 포함됩니다. 두 번째 포인터 맵 페이지는 J + 3 페이지에 있으며 해당 ptrmap 페이지는 J + 4에서 2 * J + 3까지의 페이지에 대한 포인터 정보를 제공합니다. 전체 데이터베이스 파일에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">일반적인 쿼리에서 종속성은 단일 루프에있을 필요가 없으므로 종속성 매트릭스는 그래프로 표현할 수 없습니다. 예를 들어 WHERE 절 제약 조건 중 하나는 Sa = L.b + Pc 일 수 있습니다. 이는 S 루프가 L과 P의 내부 루프 여야 함을 의미합니다. 이러한 종속성은 두 개 이상의 노드에서 한 번에 시작하도록 호.</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">조인에서 두 개 이상의 테이블이 결합되어 단일 결과를 생성합니다. 결과 테이블은 조인되는 테이블에서 가능한 모든 행 조합으로 구성됩니다. 이것을 구현하는 가장 쉽고 자연스러운 방법은 중첩 루프를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">보다 완전한 빌드에서 SQLite는 malloc () 및 free ()와 같은 라이브러리 루틴과 파일 열기, 읽기, 쓰기 및 닫기를위한 운영 체제 인터페이스도 사용합니다. 그러나 그럼에도 불구하고 종속성의 수는 매우 적습니다. 반면에 다른 &quot;현대&quot;언어는 종종 수천 및 수천 개의 인터페이스가로드 된 멀티 메가 바이트 런타임이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">다중 스레드 응용 프로그램에서 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods에&lt;/a&gt; 대한 액세스 는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 사용 가능한 경우에만 직렬화됩니다 . &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 비활성화 된 경우 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 의 메소드는 자체 직렬화 요구를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">다중 스레드 환경에서 SQLite는 뮤텍스를 사용하여 공유 리소스에 대한 액세스를 직렬화합니다. mutex 하위 시스템은 여러 스레드에서 SQLite에 액세스하는 응용 프로그램에만 필요합니다. 단일 스레드 응용 프로그램 또는 단일 스레드에서 SQLite 만 호출하는 응용 프로그램의 경우 다음 옵션을 사용하여 다시 컴파일하여 mutex 하위 시스템을 완전히 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">일반 인덱스에는 테이블의 행과 해당 테이블과 관련된 각 인덱스의 항목간에 일대일 매핑이 있습니다. 그러나 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 에서 인덱스 b- 트리에는 CREATE INDEX 문의 WHERE 절 표현식이 참인 테이블 행에 해당하는 항목 만 포함됩니다. 인덱스 및 테이블 b- 트리의 해당 행은 동일한 rowid 또는 기본 키 값을 공유하며 모든 인덱스 열에 대해 동일한 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">접두사 검색에서 matchlen은 접두사와 일치하는 문자열의 문자 수입니다. 접두사가 아닌 검색의 경우 length (word)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">올바른 형식의 sqlite_stat3 테이블에서 단일 인덱스의 샘플은 인덱스에서 발생하는 순서와 동일한 순서로 나타나야합니다. 즉, 가장 왼쪽 열 S1이있는 항목이 가장 왼쪽 열 S2가있는 항목보다 인덱스 b- 트리에서 더 이른 경우 sqlite_stat3 테이블에서 샘플 S1은 샘플 S2보다 작은 rowid를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">올바른 형식의 sqlite_stat4 테이블에서 단일 인덱스의 샘플은 인덱스에서 발생하는 순서와 동일한 순서로 나타나야합니다. 즉, 항목 S1이 항목 S2보다 색인 b- 트리에서 더 이른 경우 sqlite_stat4 테이블에서 샘플 S1은 샘플 S2보다 작은 rowid를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">2050 년까지 SQLite를 &quot;지원&quot;하는 것 외에도 개발자는 SQLite &lt;a href=&quot;cintro&quot;&gt;C 언어 API&lt;/a&gt; 및 &lt;a href=&quot;fileformat2&quot;&gt;온 디스크 형식을&lt;/a&gt; 이전 버전과 완전히 호환되도록 약속합니다 . 이는 오늘날 SQLite를 사용하도록 작성된 응용 프로그램은 향후 수십 년 전에 릴리스 된 이후 버전의 SQLite를 연결하고 사용할 수 있어야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">WHERE 절 제약 조건 외에도 SQLite 코어는 xBestIndex 메서드에 ORDER BY 절에 대해 알려줍니다. (집계 쿼리에서 SQLite 코어는 ORDER BY 절 정보 대신 GROUP BY 절 정보를 넣을 수 있지만이 사실은 xBestIndex 메소드와 아무런 차이가 없어야합니다. ORDER BY 절의 모든 용어가 열인 경우 가상 테이블 인 경우 nOrderBy는 ORDER BY 절의 용어 수이고 aOrderBy [] 배열은 각 항목의 열을 order by 절에서 식별하고 해당 열이 ASC인지 DESC인지 여부를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_ABORT 값은 결과 코드 일뿐 아니라 &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 리턴 된 &lt;a href=&quot;c3ref/c_fail&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">이 바이트를 잠그는 것 외에도 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행하는 연결 은 WAL_READ_LOCK (0)을 제외한 다른 모든 WAL 잠금에서 배타적 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">SQLite를 다른 프로젝트에 쉽게 통합 할 수있을뿐만 아니라 합병은 더 빠르게 실행됩니다. 많은 컴파일러는 코드가 단일 번역 단위 (예 : 통합)에 포함되어있을 때 코드를 추가로 최적화 할 수 있습니다. 개별 소스 파일이 아닌 SQLite를 컴파일하기 위해 합병을 사용할 때 5 ~ 10 %의 성능 향상을 측정했습니다. 이것의 단점은 추가 최적화는 종종 결과 이진 이미지의 크기를 더 크게 만드는 경향이있는 함수 인라인 형태를 취하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">FTS는 내장 된 &quot;간단한&quot;, &quot;포터&quot;및 &quot;icu&quot;및 &quot;unicode61&quot;토크 나이저를 제공 할뿐만 아니라 애플리케이션이 C로 작성된 사용자 정의 토크 나이저를 구현하고 등록 할 수있는 인터페이스를 제공합니다. 새로운 인터페이스를 만드는 데 사용되는 인터페이스 토크 나이 저는 fts3_tokenizer.h 소스 파일에 정의되고 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="translated">SQLite 데이터베이스 파일을 읽고 쓰는 것 외에도 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램은 ZIP 아카이브도 읽고 씁니다. 초기 명령 줄 또는 &quot;.open&quot;명령에서 SQLite 데이터베이스 파일 이름 대신 ZIP 아카이브 파일 이름을 지정하기 만하면 &lt;b&gt;sqlite3&lt;/b&gt; 는 파일이 SQLite 데이터베이스 대신 ZIP 아카이브임을 자동으로 감지하여 다음과 같이 엽니 다. 이러한. 이것은 파일 접미사에 관계없이 작동합니다. 따라서 JAR, DOCX 및 ODP 파일과 실제로 ZIP 아카이브 인 기타 파일 형식을 열 수 있으며 SQLite가이를 읽어줍니다.</target>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">네 가지 주요 테스트 도구 외에도 특수 테스트를 구현하는 몇 가지 다른 작은 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">위에 나열된 호환되지 않는 변경 사항 외에도 SQLite 버전 3.6.0에는 다음과 호환되는 변경 사항 및 향상된 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">공식 리포지토리 외에도 개발자는 일반적으로 개인 컴퓨터에 모든 소프트웨어의 완전한 복제본을 유지합니다. 그리고 인터넷에는 셀 수없는 복제품이 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">기본 vdbe.c 소스 코드 파일 외에도 소스 트리에 다른 이름의 도우미 코드 파일이 있으며이 파일의 이름은 모두 &quot;vdbe&quot;로 시작합니다. &quot;Virtual DataBase Engine&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="translated">필수 플래그 외에 다음과 같은 선택적 플래그도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">응용 프로그램 및 / 또는 개발자가 CREATE 문 SQL을 사용하여 작성한 테이블, 인덱스, 뷰 및 트리거 외에도 sqlite_master 테이블에는 0 개 이상의 항목이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="translated">CREATE 문 SQL을 사용하여 응용 프로그램 및 / 또는 개발자가 생성 한 테이블, 인덱스, 뷰 및 트리거 외에도 sqlite_schema 테이블에는 다음에 대한 항목이 0 개 이상 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">세 가지 주요 테스트 장치 외에도 특수 테스트를 구현하는 몇 가지 다른 작은 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">또한 몇 가지 정의 된 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="translated">위의 모든 항목에서 F가 SQLite 코어에서 VFS로 전달 된 데이터베이스, 저널 또는 WAL 파일 이름이 아니고 F가 &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename ()&lt;/a&gt; 에서 반환 값이 아닌 경우 결과는 정의되지 않고 메모리 일 가능성이 높습니다. 액세스 위반.</target>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">위의 모든 전체 텍스트 쿼리에서 MATCH 연산자의 오른쪽 피연산자는 단일 용어로 구성된 문자열입니다. 이 경우, MATCH 표현식은 지정된 단어의 인스턴스가 하나 이상 포함 된 모든 문서 ( &quot;sqlite&quot;, &quot;search&quot;또는 &quot;database&quot;)에 따라 true로 평가됩니다. 단일 용어를 MATCH 연산자의 오른쪽 피연산자로 지정하면 가장 단순하고 가장 일반적인 유형의 전체 텍스트 쿼리가 가능합니다. 그러나 구문 검색, 용어 접두사 검색 및 서로 정의 된 근접성 내에서 발생하는 용어 조합을 포함하는 문서 검색을 포함하여보다 복잡한 쿼리가 가능합니다. 전체 텍스트 인덱스를 쿼리 할 수있는 다양한 방법이 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;아래&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">모든 쓰기 테스트에서 디스크에 직접 성능 테스트를 실행하기 전에 안티 바이러스 소프트웨어를 비활성화해야합니다. 우리는 안티 바이러스 소프트웨어가 디스크에 직접 디스크를 느리게하는 반면 SQLite 쓰기에는 거의 영향을 미치지 않는다는 것을 알았습니다. 디스크에 직접 복사하면 수천 개의 개별 파일이 바이러스 백신으로 검사되어야하는 반면, SQLite는 단일 데이터베이스 파일 만 변경하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">다른 모든 경우에이 함수는 SQLITE_MISUSE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">위의 모든 예제에서 단 하나의 SELECT 문만있었습니다. 쿼리에 하위 선택이 포함 된 경우 외부 SELECT의 하위 항목으로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">에서 &lt;a href=&quot;lang_update&quot;&gt;업데이트&lt;/a&gt; 문 열 이름 목록은 같은 크기의 로우 값으로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식 인덱스의&lt;/a&gt; 일부로 사용되는 표현식 .</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">WITHOUT ROWID 테이블의 인덱스에서 PRIMARY KEY의 열도 인덱스의 열이고 일치하는 배열 순서를 갖는 경우 인덱스 레코드의 끝에서 테이블 키 접미어에서 인덱스 열이 반복되지 않습니다. . 예를 들어, 다음 SQL을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">내부 b- 트리 페이지에서 포인터와 키는 논리적으로 양쪽 끝에 포인터로 바뀝니다. (이전 문장은 개념적으로 이해되어야합니다.-페이지 내의 키와 포인터의 실제 레이아웃은 더 복잡하고 속속에 설명됩니다.) 동일한 페이지 내의 모든 키는 고유하며 논리적으로 왼쪽에서 오름차순으로 구성됩니다 오른쪽으로. (이 순서는 물리적이지 않고 논리적입니다. 페이지 내 키의 실제 위치는 임의적입니다.) 키 X의 경우 X 왼쪽의 포인터는 모든 키가 작거나 같은 b- 트리 페이지를 나타냅니다. X의 오른쪽에있는 포인터는 모든 키가 X보다 큰 페이지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">일반적인 SQLite 테이블에서 PRIMARY KEY는 실제로는 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;고유&lt;/a&gt; 인덱스입니다. 디스크에서 레코드를 조회하는 데 사용되는 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다. 일반 SQLite 테이블 의 특수 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &quot;열 유형은 열이 rowid의 별명이되므로 INTEGER PRIMARY KEY는 실제 PRIMARY KEY입니다. 그러나 &quot;INT PRIMARY KEY&quot;를 포함한 다른 종류의 PRIMARY KEY는 일반 rowid 테이블의 고유 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">단일 인수를 취하는 모든 집계 함수에서 해당 인수 앞에 키워드 DISTINCT가 올 수 있습니다. 이러한 경우 중복 요소는 집계 함수로 전달되기 전에 필터링됩니다. 예를 들어, 함수 &quot;count (distinct X)&quot;는 열 X의 널이 아닌 값의 총 수 대신 열 X의 고유 값 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">ptrmap 페이지를 포함하는 데이터베이스 파일에서 모든 b- 트리 루트 페이지는 루트가 아닌 b- 트리 페이지, 셀 페이로드 오버 플로우 페이지 또는 프리리스트 페이지 앞에 와야합니다. 이 제한은 자동 진공 또는 증분 진공 중에 루트 페이지가 이동되지 않도록합니다. 자동 진공 논리는 sqlite_master 테이블의 root_page 필드를 업데이트하는 방법을 알지 못하므로 sqlite_master 테이블의 무결성을 유지하기 위해 자동 진공 중에 루트 페이지가 이동되는 것을 방지해야합니다. 루트 페이지는 CREATE TABLE, CREATE INDEX, DROP TABLE 및 DROP INDEX 조작으로 데이터베이스 파일의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">ptrmap 페이지를 포함하는 데이터베이스 파일에서 모든 b- 트리 루트 페이지는 루트가 아닌 b- 트리 페이지, 셀 페이로드 오버 플로우 페이지 또는 사용 가능 목록 페이지 앞에 와야합니다. 이 제한은 자동 진공 또는 증분 진공 중에 루트 페이지가 이동되지 않도록합니다. auto-vacuum 로직은 sqlite_schema 테이블의 root_page 필드를 업데이트하는 방법을 알지 못하므로 sqlite_schema 테이블의 무결성을 유지하기 위해 auto-vacuum 중에 루트 페이지가 이동하는 것을 방지해야합니다. 루트 페이지는 CREATE TABLE, CREATE INDEX, DROP TABLE 및 DROP INDEX 작업에 의해 데이터베이스 파일의 시작 부분으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">자동 EXPLAIN QUERY PLAN 모드에서 쉘은 입력 한 각 명령문에 대해 별도의 EXPLAIN QUERY PLAN 쿼리를 자동으로 실행하고 실제로 쿼리를 실행하기 전에 결과를 표시합니다. &quot;.eqp off&quot;명령을 사용하여 자동 EXPLAIN QUERY PLAN 모드를 다시 끄십시오.</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">FTS 테이블이 초기에 많은 수의 INSERT 작업을 사용하여 구축 된 후 추가 변경없이 반복적으로 쿼리되는 배치 모드 작업에서는 마지막 INSERT 후 첫 번째 쿼리 전에 &quot;최적화&quot;를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">두 경우 모두, 분할 대상 병합은 &quot;sqlite3.c&quot;대신 &quot;sqlite3-all.c&quot;를 make 대상으로 대체하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">간단히 말해 sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D의 데이터베이스 X에 대한 &lt;a href=&quot;../wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 의 내용 이 데이터베이스 파일로 전송되고 미리 쓰기 로그가 재설정되도록합니다. 추가 정보 는 &lt;a href=&quot;../wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">간단히 말해 sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D의 데이터베이스 X에 대한 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 의 내용 이 데이터베이스 파일로 전송되고 미리 쓰기 로그가 재설정되도록합니다. 추가 정보 는 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">간단히 말해 SQLite의 CPU 성능은 다음과 같이 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">복잡한 경우 변경 세트를 적용 할 때 발생하는 복잡한 문제는 충돌 해결에 있습니다. 자세한 내용은 위에 링크 된 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">둘 이상의 프레이즈 인스턴스가 겹치는 경우 (하나 이상의 토큰을 공통으로 공유), 겹치는 프레이즈 세트마다 하나의 열기 및 닫기 마커가 삽입됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">열 모드에서 각 레코드는 데이터가 열로 정렬되어 별도의 줄에 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">일반적으로 테라 바이트 크기의 SQLite 데이터베이스는 프로덕션 환경에 존재하는 것으로 알려져 있지만 SQLite 데이터베이스의 크기는 몇 킬로바이트에서 몇 기가 바이트에 이릅니다.</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">반대로 Fossil은 단일 독립 실행 형 바이너리이며 $ PATH에 설치하여 설치됩니다. 하나의 바이너리에는 핵심 Git 및 GitHub 및 / 또는 GitLab의 모든 기능이 포함되어 있습니다. 위키, 버그 추적 및 포럼으로 커뮤니티 서버를 관리하고 추가 소프트웨어없이 소비자, 로그인 관리 등을위한 패키지 다운로드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">반대로 Fossil 사용자는 작업 디렉토리와 작업중인 체크인에 대해서만 생각하면됩니다. 이는 산만도가 60 % 적습니다. 모든 개발자는 한정된 수의 두뇌주기를 가지고 있습니다. 화석은 작동하는 데 더 적은 두뇌주기가 필요하므로 개발중인 소프트웨어에 집중할 수있는 지적 자원을 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">두 경우 모두 SQLite 응용 프로그램에서 성능 문제가 발생 하면 스키마에 하나 또는 두 개의 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 추가하거나 한 번에 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE를&lt;/a&gt; 실행 하여 한 줄의 응용 프로그램 코드를 건드리지 않고도 이러한 문제를 해결할 수 있습니다 . 그러나 성능 문제가 사용자 정의 또는 파일 더미 형식으로 나타나는 경우, 수정 사항은 종종 새로운 색인을 추가 및 유지하거나 다른 알고리즘을 사용하여 정보를 추출하기 위해 응용 프로그램 코드를 광범위하게 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">모든 경우에, 호출기 캐시 크기는 캐시 메모리의 양을 약 2MB로 유지하도록 조정되었다. 예를 들어, 1024 바이트 페이지에는 2000 페이지 캐시가 사용되고 65536 바이트 페이지에는 31 페이지 캐시가 사용되었습니다. BLOB 값을 임의의 순서로 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">극단적 인 경우에는 &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; 옵션을 사용하여 SQLite를 컴파일 한 다음 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; ) 인터페이스 를 통해 힙으로 사용할 고정 된 메모리 청크를 SQLite에 제공하십시오 . 이렇게하면 과도한 양의 메모리를 사용하여 악의적 인 SQL이 서비스 거부 공격을 실행하지 못하게됩니다. SQLite가 사용할 5MB의 메모리가 제공되면, 많은 양이 소비되면 SQLite는 응용 프로그램의 다른 부분에 필요한 메모리를 흡수하지 않고 SQLITE_NOMEM 오류를 반환하기 시작합니다. 또한 SQLite의 메모리를 샌드 박스하여 응용 프로그램의 다른 부분에서 Write-After-Free 오류가 SQLite에 문제를 일으키지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">PostgreSQL과 공평하게이 테스트를 시작했습니다. 지식이 풍부한 관리자는 서버를 약간 조정하고 조정하여 PostgreSQL을 훨씬 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">공평하게, 내장 printf () 구현은 몇 가지 단점이 있습니다. 재치 :</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">첫 번째 양식에서 기본 데이터베이스가 이미 작성된 경우이 pragma는 기본 데이터베이스에서 사용하는 텍스트 인코딩 (UTF-8 ','UTF-16le '(little-endian UTF-16 인코딩) 또는' UTF-16be '(빅 엔디안 UTF-16 인코딩). 기본 데이터베이스가 아직 작성되지 않은 경우 리턴 된 값은이 세션에서 작성된 경우 기본 데이터베이스를 작성하는 데 사용되는 텍스트 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">형식 4, 7, 10에서 소수 초 값 SS.SSS는 소수점 다음에 하나 이상의 숫자를 가질 수 있습니다. 처음 세 자리 숫자 만 결과에 중요하기 때문에 정확한 세 자리 숫자가 예제에 표시되지만 입력 문자열이 세 자리 이하의 숫자를 가질 수 있으며 날짜 / 시간 함수는 여전히 올바르게 작동합니다. 마찬가지로 형식 12는 유효 숫자 10 자리로 표시되지만 날짜 / 시간 함수는 율리우스 일 수를 나타내는 데 필요한만큼의 자릿수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">형식 5-7에서 &quot;T&quot;는 &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601에&lt;/a&gt; 필요한 날짜와 시간을 구분하는 리터럴 문자 입니다. 시간 만 지정하는 형식 8-10은 날짜가 2000-01-01 인 것으로 가정합니다. 'now'문자열 인 형식 11 은 사용중인 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xCurrentTime 메서드에서 얻은 현재 날짜 및 시간으로 변환됩니다 . 날짜 및 시간 함수에 대한 '지금'인수는 항상 동일한 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출 내에서 여러 호출에 대해 정확히 동일한 값을 반환합니다 . &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;UTC (Universal Coordinated Time)&lt;/a&gt; 가 사용됩니다. 형식 12는 부동 소수점 값으로 표시되는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일 수&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 인덱스 나 트리거를 만들 수 없다는 점을 제외하고 일반 테이블로 수행 할 수 있는 가상 테이블로 무엇이든 할 수 있습니다. 일부 가상 테이블 구현에는 추가 제한이 적용될 수 있습니다. 예를 들어 많은 가상 테이블이 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">뒤늦게, 우리는 SQLite가 MySQL 3.x 구문을 받아들이도록 시도해서는 안되며, 큰 따옴표로 묶인 문자열 리터럴을 허용해서는 안됩니다. 그러나 큰 따옴표로 묶인 문자열 리터럴을 사용하는 수많은 응용 프로그램이 있으므로 레거시 중단을 피하기 위해 해당 기능을 계속 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">기본 구성에서 SQLite API 루틴은 30 개의 정수 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; 중 하나를 리턴 합니다. 그러나 경험에 따르면 이러한 결과 코드 중 많은 부분이 너무 거칠게 나타납니다. 프로그래머가 원하는만큼 문제에 대한 많은 정보를 제공하지 않습니다. 이를 해결하기 위해 최신 버전의 SQLite (버전 3.3.8 2006-10-09 이상)에는 오류에 대한보다 자세한 정보를 제공하는 추가 결과 코드에 대한 지원이 포함됩니다. 이러한 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 는 &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; API를 사용하여 데이터베이스 연결별로 활성화 또는 비활성화됩니다 . 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; 를 사용하여 가장 최근의 오류에 대한 확장 코드를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">기본 구성에서 SQLite API 루틴은 30 개의 정수 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; 중 하나를 리턴 합니다. 그러나 경험에 따르면 이러한 결과 코드 중 많은 부분이 너무 거칠게 나타납니다. 프로그래머가 원하는만큼 문제에 대한 많은 정보를 제공하지 않습니다. 이를 해결하기 위해 최신 버전의 SQLite (버전 3.3.8 2006-10-09 이상)에는 오류에 대한보다 자세한 정보를 제공하는 추가 결과 코드에 대한 지원이 포함됩니다. 이러한 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 는 &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; API를 사용하여 데이터베이스 연결별로 활성화 또는 비활성화됩니다 . 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; 를 사용하여 가장 최근의 오류에 대한 확장 코드를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">파일 더미 테마와 관련하여 OpenDocument는 &quot;content.xml&quot;이라는 하나의 큰 XML 파일에 모든 슬라이드 내용을 저장합니다. LibreOffice은 (는)이 첫 번째 슬라이드를 표시하기 위해이 전체 파일을 읽고 구문 분석합니다. LibreOffice는 또한 모든 이미지를 메모리로 읽는 것 같습니다. 사용자가 &quot;파일 / 저장&quot;을 수행 할 때 이미지를 변경하지 않아도 다시 다시 써야한다는 것을 의미합니다. 결과적으로 시동 속도가 느려집니다. OpenDocument 파일을 두 번 클릭하면 첫 번째 슬라이드가 아닌 진행률 표시 줄이 나타납니다. 이것은 나쁜 사용자 경험을 초래합니다. 문서 크기가 커질수록 상황은 더욱 성가 시게됩니다.</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">대부분의 경우 위의 방법 (1)이 최선의 방법입니다. FTS 인덱스에 추가 데이터를 추가하거나 여러 용어를 쿼리하기 위해 FTS5가 필요하지 않으므로 디스크 공간과 쿼리 속도 측면에서 효율적입니다. 그러나 접두사 쿼리를 잘 지원하지 않습니다. 위에서 제안한 것처럼 토큰 &quot;first&quot;가 토크 나이저로 &quot;1st&quot;로 대체되면 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">대부분의 SQL 데이터베이스에서 테이블에 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; 제약 조건이 있고 제약 조건 을 위반 하는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 를 수행하려고 하면 데이터베이스는 진행중인 작업을 중단하고 이전과 관련된 모든 변경 사항을 취소합니다 동일한 UPDATE 또는 INSERT 문을 사용하여 오류를 리턴하십시오. 이것은 SQLite의 기본 동작이지만 SQLite를 사용하면 제약 조건 위반을 처리하는 다른 방법을 정의 할 수도 있습니다. 이 기사에서는 이러한 대안과 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">대부분의 SQL 구현에서 집계 쿼리의 출력 열은 GROUP BY 절에 명명 된 집계 함수 또는 열만 참조 할 수 있습니다. 각 출력 행이 입력 테이블의 둘 이상의 행으로 구성 될 수 있으므로 집계 쿼리에서 일반 열을 참조하는 것은 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">대부분의 응용 프로그램에서 SQLite 내의 데이터베이스 페이지 캐시 하위 시스템은 SQLite의 다른 모든 부분이 결합 된 것보다 더 동적으로 할당 된 메모리를 사용합니다. 데이터베이스 페이지 캐시가 나머지 SQLite를 합친 것보다 10 배 이상 많은 메모리를 소비하는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">대부분의 응용 프로그램에서 열의 수는 적습니다. SQLite 코드 생성기에는 O (N&amp;sup2;) 인 알고리즘을 사용하는 곳이 있습니다. 여기서 N은 열 수입니다. 따라서 SQLITE_MAX_COLUMN을 정말 큰 숫자로 재정의하고 많은 수의 열을 사용하는 SQL을 생성하면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 가 느리게 실행되는 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">대부분의 경우 UNIQUE 및 PRIMARY KEY 제약 조건은 데이터베이스에서 고유 인덱스를 만들어 구현됩니다. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 및 PRIMARY KEY 는 예외 입니다 . 따라서 다음 스키마는 논리적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">대부분의 경우 응용 프로그램에 적합한 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션으로&lt;/a&gt; 위의 기본 명령을 보완하려고 합니다. 일반적으로 사용되는 컴파일 타임 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">대부분의 상황에서 일반 테이블의 특수 &quot;rowid&quot;열을 &quot;oid&quot;또는 &quot;_rowid_&quot;라고도합니다. 그러나 &quot;rowid&quot;만 CREATE TABLE 문에서 키워드로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진에서 데이터 유형은 데이터를 포함하는 데이터를 보유하는 테이블 열과 연관됩니다. SQLite 3.0에서 데이터 유형은 컨테이너가 아닌 데이터 자체와 연결됩니다. 그의 책에서 &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;폴 그레이엄&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">일반적인 경우, WAL 파일이 약 1000 페이지 (따라서 크기가 약 4MB)가되어 체크 포인트가 자동으로 실행되고 WAL 파일이 재활용 될 때까지 새 컨텐츠가 WAL 파일에 추가됩니다. &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; 가 설정되어 있지 않으면 검사 점은 일반적으로 WAL 파일을 자르지 않습니다 . 대신, 단지 SQLite가 처음부터 WAL 파일을 덮어 쓰기 시작합니다. 일반적으로 추가하는 것보다 기존 파일을 덮어 쓰는 것이 더 빠르기 때문에 수행됩니다. 데이터베이스에 대한 마지막 연결이 닫히면 해당 연결은 마지막 검사 점 하나를 수행 한 다음 WAL 및 관련 공유 메모리 파일을 삭제하여 디스크를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">이전 버전의 SQLite에서는 공유 캐시 모드를 가상 테이블과 함께 사용할 수 없습니다. 이 제한은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; (2009-08-10) 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">대규모 전자 메일 집합 (디스크의 1636 MiB)을 인덱싱 한 한 테스트에서 FTS 인덱스는 detail = full 인 디스크의 743MiB, detail = column 인 340MiB, detail = none 인 134MiB입니다.</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">응용 프로그램이 새로운 토크 나이저와 같은 &lt;a href=&quot;fts5#extending_fts5&quot;&gt;FTS5에 새로운 확장&lt;/a&gt; 을 추가 하려면 응용 프로그램에 &quot;fts5_api&quot;개체에 대한 포인터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">위에 표시된 OR-by-UNION 기술을 유용하게 사용하려면 WHERE 절에서 모든 OR 연결 용어를 해결하는 데 도움이되는 색인이 있어야합니다. 단일 OR 연결 용어도 색인화되지 않은 경우 한 용어로 생성 된 행 ID를 찾기 위해 전체 테이블 스캔을 수행해야하며 SQLite가 전체 테이블 스캔을 수행해야하는 경우에도 마찬가지입니다. 통합 테이블과 후속 이진 검색을 망칠 필요없이 원본 테이블에 모든 결과를 한 번에 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">여러 스레드가 동시에 동일한 데이터베이스 연결을 사용하도록하려면 SQLite는 뮤텍스를 광범위하게 사용해야합니다. 그리고 이런 이유로 새로운 뮤텍스 서브 시스템이 추가되었습니다. 다음 인터페이스로서의 mutex 서브 시스템 :</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">이 문제를 피하기 위해 하나의 큰 버퍼 대신 입력이 필요에 따라 점차적으로 입력 데이터를 요청하기 위해 세션 모듈이 호출하는 콜백 함수를 통해 입력이 스트리밍 API 함수로 전달됩니다. 모든 경우에 다음과 같은 API 함수 매개 변수 쌍</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">문서 점수를 계산하기 위해 전체 텍스트 쿼리가 구성 요소 문구로 구분됩니다. 문서의 bm25 점수</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">단일 쿼리에 대한 순위 열의 매핑을 변경하기 위해 다음 중 하나와 유사한 용어가 쿼리의 WHERE 절에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">색인화 된 문서의 사본을 전혀 저장하지 않는 FTS4 테이블을 작성하려면 컨텐츠 옵션을 빈 문자열로 설정해야합니다. 예를 들어 다음 SQL은 &quot;a&quot;, &quot;b&quot;및 &quot;c&quot;라는 세 개의 열이있는 FTS4 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">기존 zip 파일을 작성하거나 수정하려면 데이터베이스 스키마에서 &quot;zipfile&quot;가상 테이블을 작성해야합니다. CREATE VIRTUAL TABLE 문은 zip 파일의 경로를 유일한 인수로 예상합니다. 예를 들어, 현재 디렉토리에서 zip 파일 &quot;test.zip&quot;에 쓰려면 다음을 사용하여 zipfile 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">데이터베이스 파일이 변경되었는지 여부를 판별하기 위해 SQLite는 모든 변경 조작 중에 증분되는 데이터베이스 헤더 (24-27 바이트)의 카운터를 사용합니다. SQLite는 데이터베이스 잠금을 해제하기 전에이 카운터의 사본을 저장합니다. 그런 다음 다음 데이터베이스 잠금을 획득 한 후 저장된 카운터 값을 현재 카운터 값과 비교하고 값이 다른 경우 캐시를 지우거나 동일한 경우 캐시를 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">비동기 IO를 둘러싼 주요 아이디어에 대한 경험을 얻기 위해이 구현은 의도적으로 단순하게 유지됩니다. 추후에 추가 기능이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">데이터베이스 파일이 항상 일관성을 유지하기 위해 SQLite는 운영 체제에 보류중인 모든 쓰기를 영구 저장소에 플러시하도록 요청한 후 해당 플러시가 완료 될 때까지 기다립니다. 이것은 유닉스 에서 &lt;code&gt;fsync()&lt;/code&gt; 시스템 호출을 사용하고 Windows에서 &lt;code&gt;FlushFileBuffers()&lt;/code&gt; 사용하여 수행됩니다 . 보류중인 쓰기의이 플러시를 &quot;동기화&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해이 설정은 기본적으로 ON입니다. 이 기능을 끄면 장점이 있으며 꺼져도 대부분의 응용 프로그램은 영향을받지 않습니다. 따라서 모든 응용 프로그램은 연결이 열리 자마자 모든 데이터베이스 연결에서이 설정을 해제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">레거시 응용 프로그램의 이전 버전과의 호환성을 유지하기 위해 URI 파일 이름 기능은 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;compile#use_uri&quot;&gt;URIITE&lt;/a&gt; 파일 이름은 SQLITE_USE_URI = 1 또는 &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt; 컴파일 타임 옵션을 사용하여 활성화하거나 비활성화 할 수 있습니다. URI 파일 이름의 컴파일 타임 설정은 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 1) 또는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 0) 구성 호출을 사용하여 시작시 변경 될 수 있습니다 . 컴파일 시간 또는 시작 시간 설정에 관계없이 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (N, P, F, V)에&lt;/a&gt; F 매개 변수로 전달 된 비트 세트에 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 비트를 포함시켜 개별 데이터베이스 연결에 URI 파일 이름을 사용할 수 있습니다..</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">SQLite와 다른 데이터베이스 엔진 간의 호환성을 최대화하고 위의 예가 다른 SQL 데이터베이스 엔진에서와 같이 SQLite에서 작동하도록하기 위해 SQLite는 열에서 &quot;타입 선호도&quot;개념을 지원합니다. 열의 선호도는 해당 열에 저장된 데이터에 권장되는 유형입니다. 여기서 중요한 아이디어는 유형이 권장되지만 필수는 아니라는 것입니다. 모든 열은 여전히 ​​모든 유형의 데이터를 저장할 수 있습니다. 선택에 따라 일부 열은 하나의 스토리지 클래스를 다른 스토리지 클래스보다 선호합니다. 열에 대해 선호되는 스토리지 클래스를 &quot;친 화성&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">기본적으로 지원되지 않는 운영 체제 인 새 운영 체제로 SQLite를 이식하려면 응용 프로그램에서 다음을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">데이터베이스의 b- 트리 수가 너무 많아지는 것을 방지하기 위해 (쿼리가 느려짐), 작은 b- 트리는 정기적으로 동일한 데이터를 포함하는 하나의 큰 b- 트리로 병합됩니다. 기본적으로 이는 전체 텍스트 인덱스를 수정하는 INSERT, UPDATE 또는 DELETE 문 내에서 자동으로 발생합니다. 'automerge'매개 변수는 한 번에 몇 개의 작은 b- 트리가 병합되는지를 결정합니다. 작은 값으로 설정하면 쿼리 속도를 높일 수 있지만 (더 적은 수의 b- 트리에서 결과를 쿼리하고 병합해야 함) 데이터베이스에 대한 쓰기 속도가 느려질 수 있습니다 (각 INSERT, UPDATE 또는 DELETE 문은 더 많은 작업을 수행해야 함) 자동 병합 프로세스의 일부로).</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">여러 운영 체제간에 이식성을 제공하기 위해 SQLite는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 라는 추상 개체를 사용합니다 . 각 VFS는 디스크에서 파일을 열고, 읽고, 쓰고, 닫는 방법과 현재 시간을 찾거나 내장 의사 난수 생성기를 초기화하기 위해 임의성을 얻는 것과 같은 다른 OS 관련 작업을위한 방법을 제공합니다. SQLite는 현재 유닉스 ( &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; 파일)와 Windows ( &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; 파일) 를위한 VFS를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">로컬 변경 세트를 리베이스하려면 원격 변경 세트를 sqlite3changeset_apply_v2 () 및 캡처 된 리베이스 정보 버퍼를 사용하여 로컬 데이터베이스에 먼저 적용해야합니다. 그때:</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">예를 들어 SELECT 쿼리의 결과와 같이 데이터베이스에서 사용자에게 데이터를 반환하려면 SQLite는 데이터베이스 파일에서 데이터를 읽어야합니다. 일반적으로 데이터는 데이터베이스 파일에서 정렬 된 블록으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">공간을 절약하기 위해 columnsize 옵션을 0으로 설정하여이 백업 테이블을 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">성공하려면 &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 가 호출 될 때 데이터베이스 연결이 &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;자동 커밋 모드&lt;/a&gt; 에 있어서는 안됩니다 . 스키마 S에 이미 열린 읽기 트랜잭션이있는 경우 데이터베이스 핸들에는 활성 명령문이 없어야합니다 (sqlite3_reset () 또는 sqlite3_finalize ()가 아닌 sqlite3_step ()에 전달 된 SELECT 문). 이러한 조건 중 하나를 위반하거나 스키마 S가 존재하지 않거나 스냅 샷 오브젝트가 유효하지 않은 경우 SQLITE_ERROR가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">성공하려면 &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; 가 호출 될 때 데이터베이스 연결이 &lt;a href=&quot;get_autocommit&quot;&gt;자동 커밋 모드&lt;/a&gt; 에 있어서는 안됩니다 . 스키마 S에 이미 열린 읽기 트랜잭션이있는 경우 데이터베이스 핸들에는 활성 명령문이 없어야합니다 (sqlite3_reset () 또는 sqlite3_finalize ()가 아닌 sqlite3_step ()에 전달 된 SELECT 문). 이러한 조건 중 하나를 위반하거나 스키마 S가 존재하지 않거나 스냅 샷 오브젝트가 유효하지 않은 경우 SQLITE_ERROR가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">FTS3 또는 FTS4 대신 FTS5를 사용하려면 일반적으로 응용 프로그램에서 최소한의 수정이 필요합니다. 이들 중 대부분은 FTS 테이블을 만드는 데 사용되는 CREATE VIRTUAL TABLE 문에 필요한 변경 사항, 테이블에 대해 쿼리를 실행하는 데 사용되는 SELECT 쿼리에 필요한 변경 사항 및 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 함수&lt;/a&gt; 를 사용하는 응용 프로그램에 필요한 변경 사항의 세 가지 범주로 분류됩니다 .</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">SQLite에서 외래 키 제약 조건을 사용하려면 &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; 또는 &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER가&lt;/a&gt; 정의 되지 않은 상태로 라이브러리를 컴파일해야합니다 . SQLITE_OMIT_TRIGGER가 정의되었지만 SQLITE_OMIT_FOREIGN_KEY가 정의되지 않은 경우 SQLite는 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14) 이전과 같이 작동합니다. 외래 키 정의가 구문 분석되고 &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list를&lt;/a&gt; 사용하여 쿼리 될 수 있지만 외래 키 제한 조건은 적용되지 않습니다. &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA의 foreign_keys의&lt;/a&gt; 명령이 구성에서 어떤 조합입니다. OMIT_FOREIGN_KEY가 정의되면 외래 키 정의를 구문 분석 할 수 없습니다 (외래 키 정의를 지정하려고 시도하면 구문 오류가 발생 함).</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">이 명령을 사용하여 행을 삭제하려면 테이블과 이름이 같은 특수 열에 텍스트 값 'delete'를 삽입해야합니다. 삭제할 행의 rowid가 rowid 열에 삽입됩니다. 다른 열에 삽입 된 값은 현재 테이블에 저장된 값과 일치해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">일반 인덱스의 경우 테이블의 모든 행에 대해 인덱스에 정확히 하나의 항목이 있습니다. 부분 인덱스에서는 테이블에있는 행의 일부 하위 집합에만 해당 인덱스 항목이 있습니다. 예를 들어, 부분 인덱스는 인덱스되는 열이 NULL 인 항목을 생략 할 수 있습니다. 신중하게 사용하면 부분 인덱스를 사용하면 데이터베이스 파일이 더 작아지고 쿼리 및 쓰기 성능이 모두 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">다시 말해서, SQLite 데이터베이스는 파일 더미 또는 랩 파일 더미 형식이 할 수있는 모든 작업을 훨씬 더, 그리고 더 명료하게 수행 할 수 있습니다. SQLite 데이터베이스는 키 / 값 파일 시스템 또는 ZIP 아카이브보다 더 다양한 컨테이너입니다. (자세한 예는 &lt;a href=&quot;affcase1&quot;&gt;OpenOffice 사례 연구&lt;/a&gt; 에세이를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">X 사용 쓰기 트랜잭션을 시작하는 경우 즉, &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE를 BEGIN&lt;/a&gt; 하나 이상의 문제 &lt;a href=&quot;lang_update&quot;&gt;UPDATE를&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; , 및 / 또는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT의&lt;/a&gt; 진술을하는 경우, 그 변경 사항은 다음에 볼 수 있습니다 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 데이터베이스 연결 X에서 평가 문 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 다른에 문을 데이터베이스 연결 Y는 X 트랜잭션이 커밋 될 때까지 변경 사항을 표시하지 않습니다. 그러나 X의 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문은 커밋 이전의 변경 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">즉, 마지막 두 매개 변수를 0으로 변경하는 것을 제외하고 동일한 sqlite3_test_control () 호출을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">즉, 둘 이상의 이름을 가진 데이터베이스 파일을 열고 사용하면 정의되지 않은 동작이 발생하고 바람직하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">다시 말해, 전력 안전 덮어 쓰기는 쓰기 중에 전력 손실이 발생할 때 &quot;부수적 손상&quot;이 없음을 의미합니다. 실제로 쓰는 바이트 만 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">다시 말해 2004 년 이후 모든 SQLite 릴리스는 이전 버전과 호환되지만 반드시 이전 버전과 호환되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">즉, 세션 확장은 unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;패치&lt;/a&gt; 유틸리티 프로그램 과 유사한 SQLite 데이터베이스 파일 또는 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; , &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt; 또는 &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; 과 같은 버전 제어 시스템의 &quot;병합&quot;기능 과 유사한 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">즉, 열린 데이터베이스 파일을 연결 해제하거나 이름을 바꾸면 정의되지 않은 동작이 발생하고 바람직하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">즉, sqlite3_column_text (), sqlite3_column_blob () 또는 sqlite3_column_text16 ()을 먼저 호출하여 결과를 원하는 형식으로 강제 한 다음 sqlite3_column_bytes () 또는 sqlite3_column_bytes16 ()을 호출하여 결과 크기를 찾으십시오. sqlite3_column_bytes16 ()에 대한 호출을 sqlite3_column_texts () 또는 sqlite3_column_blob ()에 대한 호출을 혼합하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">실제로 전원 안전 쓰기 속성의 의미는 디스크 컨트롤러가 임박한 전원 손실을 감지하면 헤드를 파킹하기 전에 작업중인 섹터를 모두 기록한다는 것입니다. 즉, 전력 손실이 있더라도 개별 섹터 쓰기가 시작되면 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">실제로, 메타 데이터는 리터럴 값과 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 및 동일하게 구성된 표현식을 포함하여 컴파일 타임 상수 인 함수 매개 변수에 대한 함수 호출간에 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">실제로, 메타 데이터는 리터럴 값과 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 및 동일하게 구성된 표현식을 포함하여 컴파일 타임 상수 인 함수 매개 변수에 대한 함수 호출간에 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">웹 사이트에서 사용 가능한 사전 컴파일 된 SQLite 라이브러리에서 Unix 버전은 THREADSAFE가 해제 된 상태로 컴파일되지만 Windows 버전은 THREADSAFE가 설정된 상태로 컴파일됩니다. 이것과 다른 것이 필요할 경우 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">이전의 논의에서, 각 SQL 문은 한 번 준비되고 평가 된 후 파괴되는 것으로 가정했습니다. 그러나 SQLite를 사용하면 동일한 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 여러 번 평가할 수 있습니다. 이는 다음 루틴을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">위의 쿼리를 처리 할 때 SQLite는 다음과 같이 sumint 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 로 구동되는 쿼리에서는 부분 인덱스 의 WHERE 절에 명명 된 제약 조건에 대한 불필요한 테스트를 피하십시오. 제약 조건은 항상 참이어야한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">롤백 모드에서 SQLite는 데이터베이스 파일을 잠그고 각 쓰기 트랜잭션이 진행되는 동안 다른 데이터베이스 연결에 의한 읽기를 방지하여 격리를 구현합니다. 내용은 디스크로 플러시되기 전에 모든 변경 사항이 기록기의 개인 메모리 공간에 유지되는 동안 쓰기 시작시 판독기를 활성화 할 수 있습니다. 그러나 디스크의 데이터베이스 파일을 변경하기 전에 작성기에 데이터베이스 파일에 대한 독점 액세스 권한을 부여하려면 모든 독자가 (일시적으로) 추방되어야합니다. 따라서 트랜잭션이 디스크에 기록되는 동안 데이터베이스에서 잠겨 있기 때문에 독자는 불완전한 트랜잭션을 볼 수 없습니다. 트랜잭션이 완전히 기록되고 디스크에 동기화되고 커밋 된 후에 만 ​​판독기가 데이터베이스에 다시 허용됩니다.따라서 독자는 부분적으로 작성된 변경 사항을 볼 기회를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">단점에도 불구하고 개발자는 SQLite 내부에 내장 printf () 구현이 긍정적이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">위 절차의 2 단계에서 데이터베이스 파일을 읽기 전에 잠그지 않습니다. 이것은 섹션에 설명 된 잠금 규칙에 대한 유일한 예외입니다</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">요약하면 집계 함수가있는 쿼리는 두 개의 루프로 구현됩니다. 첫 번째 루프는 입력 테이블을 스캔하고 집계 정보를 버킷으로 계산하고 두 번째 루프는 모든 버킷을 통해 스캔하여 최종 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">요약하면,이 에세이의 주장은 SQLite를 OpenDocument와 같은 응용 프로그램 파일 형식의 컨테이너로 사용하고 해당 컨테이너에 많은 작은 객체를 저장하는 것이 몇 개의 큰 객체를 보유하는 ZIP 아카이브를 사용하는 것보다 훨씬 더 효과적이라는 것입니다. 재치 :</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">SQLite 에 대한 &lt;a href=&quot;testing#mcdc&quot;&gt;100 % MC / DC 테스트&lt;/a&gt; 목표를 지원하기 위해 Lemon이 생성 한 파서 코드에는 도달 할 수없는 분기가 없으며 테스트 범위를 측정하는 데 유용한 추가 (컴파일 타임 선택) 계측이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">&quot;화석 델타&quot;형식에서- &lt;a href=&quot;http://fossil-scm.org&quot;&gt;화석 소스 코드 관리 시스템&lt;/a&gt; 에서 블롭 델타에 사용되는 형식 또는</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">왼쪽의 &quot;ANALYZE없이&quot;경우, NN 알고리즘은 4.9가 5.2보다 작기 때문에 루프 P (PLINK)를 외부 루프로 선택하므로 경로 PT는 알고리즘 1입니다. NN은 각 단계에서 하나의 최선의 선택 만 검토하므로 5.2 + 4.4가 4.9 + 4.8보다 약간 저렴한 계획을 작성한다는 사실을 완전히 놓치게됩니다. 그러나 N3 알고리즘은 양방향 조인을위한 5 가지 최상의 경로를 추적하므로 전체 비용이 약간 낮아 경로 TP를 선택하게됩니다. 경로 TP는 알고리즘 -2입니다.</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">에서 &lt;a href=&quot;carray&quot;&gt;CARRAY 확장&lt;/a&gt; , 애플리케이션은 확장을 확장 구현 그 테이블 값 함수에 대한 데이터를 포함하는 C 언어 배열의 위치를 알 필요가있다.</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">에서 &lt;a href=&quot;cli&quot;&gt;명령 라인 쉘&lt;/a&gt; , 그래서 모드 &quot;LINE&quot;, &quot;리스트&quot;, &quot;항목&quot;및 &quot;TCL&quot;에 대한 기본 열과 행 세퍼레이터를 복원하는 &quot;.mode&quot;명령을 향상시킨다.</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">에서 &lt;a href=&quot;fts3&quot;&gt;FTS3의&lt;/a&gt; 확장의 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH 연산자&lt;/a&gt; (전체 텍스트 검색을 수행 있음)에 일치하는 항목의 세부 사항을 통신 할 필요 &lt;a href=&quot;fts3#snippet&quot;&gt;) 조각 (&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋 ()&lt;/a&gt; 와 &lt;a href=&quot;fts3#matchinfo&quot;&gt;() matchinfo&lt;/a&gt; 이러한 기능 경기의 세부 사항을 변환 할 수 있도록 기능을 유용한 출력으로.</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">에서 &lt;a href=&quot;json1&quot;&gt;JSON 확장&lt;/a&gt; , 제대로 문자열 내에서 유효하지 않은 백 슬래시 이스케이프를 거부되도록 JSON 유효성 검사기를 수정.</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">에서 &lt;a href=&quot;rbu&quot;&gt;RBU 확장&lt;/a&gt; , 정전 다음과 같은 손상의 가능성을 방지하기 위해 별도의 동기화 작업을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">에서 &lt;a href=&quot;rtree&quot;&gt;RTREE의&lt;/a&gt; 확장 크게 얻을 바운딩 박스가 발생하는 방향으로 항상 원형 스토리지 32 비트 64 비트 부동 소수점 수를 라운딩 때.</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">에서 &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; , 새로운 데이터베이스 연결 개체를 만드는 데 사용 &quot;sqlite3를&quot;TCL 명령에 -uri 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">에서 &lt;a href=&quot;tclsqlite&quot;&gt;TCL 언어 인터페이스&lt;/a&gt; , &quot;@variable&quot;대신 &quot;$ 변수&quot;항상 덩어리로 결합한다.</target>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">C 프로그래밍 언어에서 &lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt; 및 &lt;b&gt; &lt;code&gt;||&lt;/code&gt; &lt;/b&gt; &quot;단락&quot;연산자, MC / DC 및 분기 범위는 거의 동일합니다. 주요 차이점은 부울 벡터 테스트입니다. 의사 결정의 각 조건이 모든 가능한 결과를 가져야한다는 요구 사항 인 MC / DC의 두 번째 요소가 충족되지 않더라도 비트 벡터에서 여러 비트를 테스트하고 100 % 분기 테스트 적용 범위를 여전히 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">C 프로그래밍 언어에서 &quot;정의되지 않은&quot;또는 &quot;구현 된 정의 된&quot;동작을 가진 코드를 작성하는 것은 매우 쉽습니다. 즉, 개발 중에 코드가 작동하지만 다른 시스템에서 또는 다른 컴파일러 옵션을 사용하여 다시 컴파일 할 때 다른 응답을 제공 할 수 있습니다. ANSI C에서 정의되지 않은 구현 정의 동작의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">COPY 명령에서 백 슬래시를 사용하여 줄 바꿈을 이스케이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">화석 전체 텍스트 검색 시스템, 전체 텍스트 검색에 참여하는 문서 (위키 페이지, 티켓, 체크인, 문서 파일 등)에서 ( &quot;ftsdocs&quot;라는 테이블로 추적 &lt;u&gt;F&lt;/u&gt; ULL &lt;u&gt;t&lt;/u&gt; 내선 &lt;u&gt;S&lt;/u&gt; earch &lt;u&gt;문서&lt;/u&gt; ument &lt;u&gt;의&lt;/u&gt; ). 새 문서가 리포지토리에 추가되면 바로 색인이 생성되지 않습니다. 검색 요청이있을 때까지 인덱싱이 지연됩니다. ftsdocs 테이블에는 &quot;idxed&quot;필드가 포함되는데,이 필드는 문서가 색인화되어 있으면 true이고 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 SQL 문 텍스트 입력 및 해당 변형에서 리터럴은 다음 템플리트 중 하나와 일치 하는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 SQL 문 텍스트 입력 및 해당 변형에서 리터럴은 다음 템플리트 중 하나와 일치 하는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">TCL 테스트 하니스에서 충돌 시뮬레이션은 별도의 프로세스로 수행됩니다. 기본 테스트 프로세스는 일부 SQLite 작업을 실행하고 쓰기 작업 도중 임의의 위치에서 임의로 충돌하는 하위 프로세스를 생성합니다. 특수한 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 비 동기화 된 쓰기 작업을 무작위로 재정렬하고 손상시켜 버퍼 파일 시스템의 효과를 시뮬레이션합니다. 자식이 사망 한 후 원래 테스트 프로세스가 열리고 테스트 데이터베이스를 읽고 자식이 시도한 변경 사항이 성공적으로 완료되었거나 완전히 롤백되었는지 확인합니다. &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA는&lt;/a&gt; 모르겠 음 데이터베이스 손상이 발생하지 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">TPC-H Q8 쿼리에서 설정 비용은 모두 무시할 수 있고 모든 종속성은 개별 노드 사이에 있으며 ORDER BY, GROUP BY 또는 DISTINCT 절이 없습니다. TPC-H Q8의 경우 위의 그래프는 계산해야 할 사항을 합리적으로 나타낸 것입니다. 일반적인 경우에는 많은 추가 합병증이 수반되며,이 기사의 나머지 부분에서는 명확성을 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절에서 .</target>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">독점 잠금을 확보하려는 시도가 실패하면 Windows OS 드라이버에서 SHARED 잠금을 다시 확보하십시오. 티켓 # 2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">위 단락에서 &quot;같음&quot;이라는 용어는 &lt;a href=&quot;datatype3#comparisons&quot;&gt;여기에 지정된&lt;/a&gt; 규칙을 사용하여 값을 비교할 때 동일 함을 의미 합니다 . 다음 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">위의</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">위의 &amp;lt;content&amp;gt;는 컨텐츠 테이블의 이름으로 대체되었습니다. 기본적으로 &amp;lt;content_rowid&amp;gt;는 리터럴 텍스트 &quot;rowid&quot;로 바뀝니다. 또는 &quot;content_rowid&quot;옵션이 CREATE VIRTUAL TABLE 문 내에서 해당 옵션의 값으로 설정된 경우. &amp;lt;cols&amp;gt;는 쉼표로 구분 된 FTS5 테이블 열 이름 목록으로 대체됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">위에서 사용자는 데이터베이스 스키마 (단일 테이블- &quot;x1&quot;)를 만든 다음 &quot;.expert&quot;명령을 사용하여 쿼리를 분석합니다 (이 경우 &quot;SELECT * FROM x1 WHERE a =? AND b&amp;gt;? &quot;. 쉘 도구는 사용자가 새 인덱스 (인덱스 &quot;x1_idx_000123a7&quot;)를 작성하고 쿼리가 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 형식으로 사용할 계획을 출력하도록 권장 합니다. 그런 다음 사용자는 동등한 스키마로 인덱스를 작성하고 동일한 쿼리에서 다시 분석을 실행합니다. 이번에는 셸 도구는 새로운 인덱스를 권장하지 않으며 기존 인덱스가 지정된 경우 SQLite가 쿼리에 사용할 계획을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="translated">CREATE VIRTUAL TABLE 문의 &quot;rtree&quot;에 대한 인수에서 열 이름은 각 인수의 첫 번째 토큰에서 가져옵니다. 각 인수 내의 모든 후속 토큰은 자동으로 무시됩니다. 예를 들어 열에 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 를 부여 하거나 UNIQUE 또는 NOT NULL 또는 DEFAULT와 같은 제약 조건을 열에 추가 하려고하면 이러한 추가 토큰이 유효한 것으로 허용되지만 해당 토큰의 동작은 변경되지 않습니다. rtree. RTREE 가상 테이블에서 첫 번째 열의 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 는 항상 INTEGER이고 다른 모든 데이터 열의 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 는 NUMERIC입니다.</target>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">위의 호출에서 pBuf는 SQLite가 모든 메모리 할당 요구를 충족시키는 데 사용할 크고 연속적인 메모리 공간에 대한 포인터입니다. pBuf는 정적 배열을 가리 키거나 다른 응용 프로그램 별 메커니즘에서 얻은 메모리 일 수 있습니다. szBuf는 pBuf가 가리키는 메모리 공간의 바이트 수인 정수입니다. mnReq는 할당의 최소 크기 인 다른 정수입니다. N이 mnReq보다 작은 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc (N)에 대한&lt;/a&gt; 모든 호출 은 mnReq로 반올림됩니다. mnReq는 2의 거듭 제곱이어야합니다. 나중에 mnReq 매개 변수가 &lt;b&gt;n&lt;/b&gt; 값을 줄이는 데 중요 하므로 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증거&lt;/a&gt; 에서 최소 메모리 크기 요구 사항을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">위의 호출에서 pMem은 응용 프로그램 별 메모리 할당 자에 대한 인터페이스를 정의 하는 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 객체에 대한 포인터 입니다. &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods의&lt;/a&gt; 객체는 정말 다양한 메모리 할당 프리미티브를 구현하는 함수에 대한 포인터를 포함하는 단순한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">sqlite3_vtab_config (D, C, ...) 호출에서 D 매개 변수는 가상 테이블이 생성되고 sqlite3_vtab_config ()를 호출 하는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메서드에 첫 번째 인수로 전달되는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다 . C 매개 변수는 &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;가상 테이블 구성 옵션&lt;/a&gt; 중 하나입니다 . C 다음에 나오는 매개 변수의 존재와 의미 는 사용 되는 &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;가상 테이블 구성 옵션&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">sqlite3_vtab_config (D, C, ...) 호출에서 D 매개 변수는 가상 테이블이 생성되고 sqlite3_vtab_config ()를 호출 하는 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메서드에 첫 번째 인수로 전달되는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다 . C 매개 변수는 &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;가상 테이블 구성 옵션&lt;/a&gt; 중 하나입니다 . C 다음에 나오는 매개 변수의 존재와 의미 는 사용 되는 &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;가상 테이블 구성 옵션&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식에&lt;/a&gt; 대한 색인 의 경우 , 위의 텍스트에서 &quot;열&quot;이라는 단어가 사용될 때마다 &quot;인덱싱 된 표현식&quot;( &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문에 나타나는 표현식의 사본을 의미 함)을 대체 할 수 있으며 모든 것이 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">sqlite3changeset_start_strm ()의 경우 xInput 콜백은 반복기 수명 동안 언제든지 세션 모듈에 의해 호출 될 수 있습니다. 이러한 xInput 콜백이 오류를 리턴하면, 반복자는 오류 상태가되고, 그에 따라 반복자 함수에 대한 모든 후속 호출은 xInput에 의해 리턴 된 것과 동일한 오류 코드로 즉시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">위의 경우 함수가 리턴 한 값은 데이터베이스 파일에 저장된 정보에 영향을줍니다. CHECK 제약 조건의 함수 값은 테이블에 유효한 항목과 부분 인덱스의 WHERE 절 또는 인덱스 b- 트리에 저장된 식 계산 값의 인덱스에있는 함수를 결정합니다. 이러한 함수 중 하나라도 나중에 다른 값을 반환하면 데이터베이스가 더 이상 제대로 구성되지 않은 것일 수 있습니다. 따라서 데이터베이스 손상을 피하기 위해 위의 컨텍스트에서 결정적 기능 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">&quot;.output&quot;명령에 대한 인수의 첫 문자가 &quot;|&quot;이면 명령 행 쉘에서 fopen () 대신 popen ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">현재 SQLite 구현에서 SQL 파서는 UTF-8 텍스트에서만 작동합니다. 따라서 UTF-16 텍스트를 제공하면 변환됩니다. 이것은 구현 문제 일 뿐이며 이후 버전의 SQLite가 UTF-16으로 인코딩 된 SQL을 기본적으로 구문 분석하지 못하도록 막을 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">현재 구현에서 다음 사항이 모두 해당되는 경우에만 테이블이 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">현재 구현에서는 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; 절로 인해 충돌하는 행이 삭제 될 때 업데이트 후크가 호출되지 않습니다 . &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;절단 최적화를&lt;/a&gt; 사용하여 행이 삭제 될 때 업데이트 후크도 호출되지 않습니다 . 이 단락에 정의 된 예외는 향후 SQLite 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">현재 구현에서는 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; 절로 인해 충돌하는 행이 삭제 될 때 업데이트 후크가 호출되지 않습니다 . &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;절단 최적화를&lt;/a&gt; 사용하여 행이 삭제 될 때 업데이트 후크도 호출되지 않습니다 . 이 단락에 정의 된 예외는 향후 SQLite 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">현재 행에서 문구가 열에 나타나는 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">오른쪽 다이어그램에서 잠금을 해제하면 사용자 공간에 보유 된 정보가 지워지는 것을 보여줍니다. 이것은 이전 버전의 SQLite에서 문자 그대로 적용되었습니다. 그러나 최신 버전의 SQLite는 다음 트랜잭션을 시작할 때 다시 필요할 때를 대비하여 사용자 공간 정보를 메모리에 유지합니다. 운영 체제 디스크 캐시에서 정보를 다시 전송하거나 디스크 드라이브에서 정보를 다시 읽는 것보다 이미 로컬 메모리에있는 정보를 재사용하는 것이 더 저렴합니다. 사용자 공간에서 정보를 재사용하기 전에 먼저 공유 잠금을 다시 획득해야하며 잠금을 유지하지 않는 동안 다른 프로세스가 데이터베이스 파일을 수정하지 않았는지 확인해야합니다. 데이터베이스의 첫 페이지에는 데이터베이스 파일이 수정 될 때마다 증가하는 카운터가 있습니다.해당 카운터를 확인하여 다른 프로세스가 데이터베이스를 수정했는지 확인할 수 있습니다. 데이터베이스가 수정 된 경우 사용자 공간 캐시를 지우고 다시 읽어야합니다. 그러나 일반적으로 변경 사항이없고 사용자 공간 캐시를 재사용하여 성능을 크게 절감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">다이어그램에서 조회의 FROM 절에있는 8 개의 테이블 각각은 FROM 절 용어 레이블 N2, S, L, P, O, C, N1 및 R이있는 큰 원으로 식별됩니다. 그래프에서는 원호의 원점이 외부 루프에 있다고 가정하고 각 항을 계산하는 데 드는 추정 비용을 나타냅니다. 예를 들어, S 루프를 L에 대한 내부 루프로 실행하는 비용은 2.30 인 반면 S 루프를 L에 대한 외부 루프로 실행하는 비용은 9.17입니다.</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">운영 체제 또는 정전이 발생하는 경우 사용 가능한 파일 시스템 소프트웨어 및 스토리지 하드웨어의 다양한 조합은 오류 직전 또는 실패 중에 파일 시스템에 기록 된 데이터의 무결성에 대해 다양한 수준의 보증을 제공합니다. 데이터베이스 파일을 안전하게 수정하기 위해 SQLite가 수행해야하는 IO 작업의 정확한 조합은 대상 플랫폼의 정확한 특성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">위의 예에서 각 파티션의 모든 행은 최종 출력으로 그룹화됩니다. PARTITION BY 절이 전체 조회에서 ORDER BY 절의 접 두부이기 때문입니다. 그러나 반드시 그런 것은 아닙니다. 파티션은 결과 집합 내에 우연히 흩어져있는 행으로 구성 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">위의 예에서 각 트리플은 rowid, 열 번호 (열은 왼쪽에서 오른쪽으로 0부터 순차적으로 번호가 매겨 짐) 및 열 값 내 위치 (열 값의 첫 번째 토큰은 0, 두 번째는 1 등입니다). 이 색인을 사용하여 FTS5는 &quot;토큰 'A'를 포함하는 모든 문서 세트 또는&quot;Y Z '시퀀스를 포함하는 모든 문서 세트 &quot;와 같은 쿼리에 적시에 답변을 제공 할 수 있습니다. 단일 토큰과 연관된 인스턴스 목록을 &quot;인스턴스 목록&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">위의 예에서 대부분의 구매 주문에 &quot;부모&quot;구매 주문이 없으면 대부분의 parent_po 값은 NULL입니다. 이는 구매 주문 테이블에있는 행의 작은 서브 세트 만 색인화됨을 의미합니다. 따라서 인덱스는 훨씬 적은 공간을 차지합니다. po_parent 인덱스는 parent_po가 NULL이 아닌 예외 행에 대해서만 업데이트되기 때문에 원래 구매 주문 테이블에 대한 변경 사항이 더 빠르게 실행됩니다. 그러나 인덱스는 여전히 쿼리에 유용합니다. 특히, 특정 구매 주문 &quot;? 1&quot;의 모든 &quot;자식&quot;을 알고 자하는 경우 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">위의 예에서 &quot;.header on&quot;행을 사용하면 열 레이블이 출력의 첫 번째 행으로 인쇄됩니다. 이는 결과 CSV 파일의 첫 번째 행에 열 레이블이 포함됨을 의미합니다. 열 레이블을 원하지 않으면 대신 &quot;.header off&quot;를 설정하십시오. ( &quot;.header off&quot;설정이 기본값이며 헤더를 미리 설정하지 않은 경우 생략 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">위의 예에서 &quot;.headers on&quot;행은 열 레이블이 출력의 첫 번째 행으로 인쇄되도록합니다. 이는 결과 CSV 파일의 첫 번째 행에 열 레이블이 포함됨을 의미합니다. 열 레이블이 필요하지 않으면 대신 &quot;.headers off&quot;를 설정하십시오. ( &quot;.headers off&quot;설정이 기본값이며 이전에 헤더가 켜져 있지 않은 경우 생략 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">위의 예에서 창 프레임은 이전 행 ( &quot;1 PRECEDING&quot;)과 다음 행 ( &quot;1 FOLLOWING&quot;) 사이의 모든 행으로 구성되며, 여기서 행은 window-defn의 ORDER BY 절에 따라 정렬됩니다. (이 경우 &quot;ORDER BY a&quot;). 예를 들어 (a = 3) 인 행의 프레임은 행 (2, 'B', 'two'), (3, 'C', 'three') 및 (4, 'D', 'one으로 구성됩니다. '). 따라서 해당 행에 대한 group_concat (b, '.')의 결과는 'BCD'입니다.</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">위의 쿼리 예에서, 쿼리중인 테이블의 모든 행은 디스크에서로드되어 적은 비율의 행만 결과에 도달하더라도 검사되어야합니다. 큰 테이블에서는 시간이 오래 걸릴 수 있습니다. 작업 속도를 높이기 위해 SQLite는 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">이 예에서는 단일 종류의 7 개 요소 대신 fruit == 'Orange'의 경우 5 개 종류의 요소 1 개와 2 개 요소 1 개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">이 예에서 &quot;term&quot;열의 값은 대소 문자가 혼합 된 테이블 &quot;ft&quot;에 삽입 되었더라도 모두 소문자입니다. fts4aux 테이블에 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 가 문서 텍스트에서 추출한 용어가 포함되어 있기 때문 입니다. 이 경우, 테이블 &quot;ft&quot;는 &lt;a href=&quot;fts3#tokenizer&quot;&gt;단순 토크 나이저를&lt;/a&gt; 사용하므로 모든 용어가 소문자로 접 혔음을 의미합니다. 또한 &quot;term&quot;열이 &quot;apple&quot;로 설정되고 열 &quot;col&quot;이 1로 설정된 행이 없습니다 (1). 열 1에 &quot;apple&quot;이라는 용어의 인스턴스가 없으므로 행에는 없습니다. fts4aux 테이블.</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">위의 예에서</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">위의 예에서 APPCOST 테이블은 편집 거리 계수를 찾기 위해 조사됩니다. 내장 된 편집 거리 함수 대신 editdist3 ()을 사용하는 spellfix1 모듈 이름에 &quot;edit_cost_table =&quot;매개 변수가 있습니다. APPCOST가 빈 문자열이면 내장 Wagner 편집 거리 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;gencol&quot;&gt;생성 된 컬럼&lt;/a&gt; 의 표현식에서 .</target>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 의 표현 .</target>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">색인화되는 열이 PRIMARY KEY의 모든 열을 포함하는 극단적 인 경우 색인은 색인화되는 열만으로 구성됩니다. 위의 ex25acde 예제는이를 보여줍니다. ex25acde 색인의 각 항목은 순서대로 열 a, c, d 및 e로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">첫 번째 경우, 테이블이 이전에 존재하지 않으면 테이블이 자동으로 작성되고 입력 CSV 파일의 첫 번째 행 컨텐츠가 테이블의 모든 열 이름을 판별하는 데 사용됩니다. 즉, 테이블이 이전에 존재하지 않으면 CSV 파일의 첫 번째 행은 열 이름으로 해석되고 실제 데이터는 CSV 파일의 두 번째 행에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">다음 예제에서 각 행의 창 프레임은 현재 행에서 집합의 끝까지 모든 행으로 구성되며 행은 &quot;ORDER BY a&quot;에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">다음 쿼리에서 옵티마이 저는 FROM 절의 테이블을 어쨌든 적합하게 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_blob&quot;&gt;나중에이&lt;/a&gt; 옵션은 다른 부동 소수점 기능 ( 예 : sqlite3_result_double () , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double ()&lt;/a&gt; , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double ()&lt;/a&gt; API 함수 )을 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">후자의 쿼리에서 쿼리 계획은 &lt;a href=&quot;#option2&quot;&gt;옵션 2&lt;/a&gt; 여야합니다 . 테이블 재정렬 최적화를 비활성화하려면 키워드 &quot;CROSS&quot;를 사용해야합니다. INNER JOIN, NATURAL JOIN, JOIN 및 기타 유사한 조합은 옵티마이 저가 적합하게 표를 재정렬 할 수 있다는 점에서 쉼표 조인처럼 작동합니다. (외부 조인에서도 테이블 순서 변경이 비활성화되지만 외부 조인이 연관되거나 정류되지 않기 때문입니다. OUTER JOIN에서 테이블을 재정렬하면 결과가 변경됩니다.)</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">레거시 인터페이스에서 리턴 값은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 입니다. &quot;v2&quot;인터페이스를 사용하면 다른 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 도 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">레거시 인터페이스에서 리턴 값은 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 입니다. &quot;v2&quot;인터페이스를 사용하면 다른 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 도 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">이전 쿼리에서 fruit = 'Peach'제약 조건은 결과를 단일 행으로 좁혔습니다. 그러나 여러 행을 얻는 경우에도 동일한 기술이 작동합니다. 복숭아 대신 오렌지의 가격을 찾았다 고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">이전 섹션에서 ZIP 아카이브로 구현 된 키 / 값 저장소에서 단 3 개의 테이블이있는 간단한 SQLite 데이터베이스로 이동하면 애플리케이션 파일 형식에 상당한 기능을 추가 할 수있는 방법을 살펴 보았습니다. 성능 향상을 위해 추가 된 인덱스, 프로그래밍 편의를위한 트리거 및 뷰, 프로그래밍 오류가 발생하더라도 콘텐츠의 일관성을 유지하기위한 제약 조건을 갖춘 새로운 테이블을 사용하여 스키마를 계속 향상시킬 수 있습니다. 추가 개선 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">이전에는 WHERE 절의 &quot;NOT IN ( 'object', 'array')&quot;용어는 컨테이너를 억제하고 리프 요소 만 통과시킵니다. 이 방법으로 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">위의 쿼리에서 t1과 t2에 모두 대략 N 개의 행이 있으면 인덱스가 없으면 쿼리에 O (N * N) 시간이 필요합니다. 반면, 테이블 t2에 인덱스를 만들려면 O (NlogN) 시간이 필요하며 해당 인덱스를 사용하여 쿼리를 평가하려면 추가 O (NlogN) 시간이 필요합니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 정보 가 없으면 SQLite는 N이 백만이라고 추측하므로 자동 인덱스를 구성하는 것이 더 저렴한 방법이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">위의 쿼리에서 12 번째 구역의 정확한 경계에 대한 이진 BLOB 설명을 &quot;: boundary&quot;매개 변수에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">위의 쿼리에서 &quot;PARTITION BY c&quot;절은 결과 집합을 세 개의 파티션으로 나눕니다. 첫 번째 파티션에는 c == 'one'인 세 개의 행이 있습니다. 두 번째 파티션에는 c == 'three'인 두 개의 행이 있고 세 번째 파티션에는 c == 'two'인 두 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">위의 쿼리에서 &quot;a&quot;열은 GROUP BY 절의 일부이므로 출력의 각 행에는 &quot;a&quot;에 대한 고유 값 중 하나가 포함됩니다. &quot;c&quot;열은 &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum ()&lt;/a&gt; 집계 함수 내에 포함 되므로 출력 열은 &quot;a&quot;에 대해 동일한 값을 갖는 행의 모든 ​​&quot;c&quot;값의 합계입니다. 그러나 맨 열 &quot;b&quot;의 결과는 무엇입니까? 대답은 &quot;b&quot;결과가 집계를 형성하는 입력 행 중 하나에서 &quot;b&quot;의 값이된다는 것입니다. 문제는 일반적으로 &quot;b&quot;를 계산하는 데 어떤 입력 행이 사용되는지 알지 못하기 때문에 많은 경우 &quot;b&quot;의 값이 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">위 쿼리에서 하위 쿼리 &quot;SELECT b FROM ex2&quot;가 평가되고 결과는 간단한 이진 검색을 사용하여 ex2.b 값이 존재하는지 여부를 확인할 수있는 임시 테이블 (실제로 임시 인덱스)에 저장됩니다. 이 테이블이 구성되면 외부 쿼리가 실행되고 각 예상 결과 행에 대해 ex1.a가 임시 테이블에 포함되어 있는지 확인합니다. 점검이 참인 경우에만 행이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">위의 쿼리에서 first_name 및 last_name 열의 값은 max (salary) 조건을 만족 한 행에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">수정 된 쿼리에서 공동 루틴으로 구현 된 하위 쿼리는 &quot;a&quot;에 대한 가장 최근 5 개의 값을 계산합니다. 이 5 개의 값은 응용 프로그램이 관심을 갖는 특정 행에서만 &quot;expensive_function ()&quot;이 호출되는 공동 쿼리에서 외부 쿼리로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">두 번째 예에서 DO UPDATE 절의 표현식은 &quot;excluded.phonenumber&quot;형식입니다. &quot;제외됨&quot; prefix는 &quot;phonenumber&quot;가 충돌이없는 경우 삽입 된 phonenumber의 값을 참조하게합니다. 따라서 upsert의 효과는 Alice의 전화 번호가 없으면 Alice의 전화 번호를 삽입하거나 Alice의 이전 전화 번호를 새 전화 번호로 덮어 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">왼쪽 순서대로 두 번째 인서트가 실패합니다. 이 경우 문자열 '0'및 '0.0'은 숫자 열에 삽입되기 때문에 숫자로 취급되지만 0 == 0.0은 고유성 제약 조건을 위반합니다. 그러나 오른쪽 순서의 두 번째 인서트가 작동합니다. 이 경우 상수 0과 0.0은 문자열로 처리되므로 고유합니다.</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">쉘에서 &lt;b&gt;sqlite_interrupt ()&lt;/b&gt; 는 사용자가 Control-C를 누를 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">spellfix1 알고리즘에서 cFrom은 사용자가 입력 한 텍스트이고 cTo는 데이터베이스에있는 올바른 철자 텍스트입니다. editdist3 알고리즘의 목표는 사용자가 입력 한 텍스트가 사전 텍스트에 얼마나 가까운 지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">sqlite 쉘에서 이제 초기 시작시 버전 번호를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">sqlite 쉘에서 stdout 대신 &quot;데이터베이스 열림 읽기 전용&quot;메시지를 stderr에 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">위의 명령문에서 MATCH 연산자로 생성 된 FTS3 커서 포인터는 의도 된 수신자 snippet () 대신 carray () 테이블 반환 함수로 전송됩니다. carray () 함수는 포인터를 정수 배열에 대한 포인터로 취급하고 각 정수를 하나씩 반환하여 FTS3 커서 객체의 내용을 누출시킵니다. FTS3 커서 객체에는 다른 객체에 대한 포인터가 포함되어 있으므로 위의 설명은 포인터 누출입니다.</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">위의 템플릿에서 NNN은 정수 리터럴을 나타내고 VVV는 영숫자 식별자를 나타냅니다. 이 매개 변수의 값 ( &quot;호스트 매개 변수 이름&quot;또는 &quot;SQL 매개 변수&quot;라고도 함)은 여기에 정의 된 sqlite3_bind _ * () 루틴을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">기본 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 에서 각 rowid는 &lt;a href=&quot;fileformat2#varint&quot;&gt;가변 길이 정수&lt;/a&gt; 로 저장됩니다 . 이는 음이 아닌 작은 rowid 값이 큰 또는 음의 rowid 값보다 적은 디스크 공간을 차지함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">이 경우 aConstraint []. op 값은 FUNCTION에 대해 &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; 에서 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">이 경우 다음과 같이 t2 (c)에 색인을 작성하여 임시 b- 트리 사용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">이 경우 SQLite는 여전히 단일 이진 검색을 수행하여 fruit = 'Orange'인 인덱스의 첫 번째 항목을 찾습니다. 그런 다음 인덱스에서 rowid를 추출하고 해당 rowid를 사용하여 이진 검색을 통해 원래 테이블 항목을 조회하고 원래 테이블의 가격을 출력합니다. 그러나 데이터베이스 엔진은 종료하는 대신 다음 열 행으로 진행하여 다음 fruit = 'Orange'항목에 대한 프로세스를 반복합니다. 다음 행이 현재 행과 동일한 데이터베이스 페이지에 있기 때문에 이진 검색을 수행하는 것보다 인덱스 (또는 테이블)의 다음 행으로 진행하는 것이 훨씬 저렴합니다. 실제로 다음 행으로 이동하는 비용은 이진 검색에 비해 너무 저렴하여 일반적으로 무시합니다. 따라서이 쿼리의 총 비용에 대한 추정치는 3 개의 이진 검색입니다.출력 행 수가 K이고 테이블의 행 수가 N 인 경우 일반적으로 쿼리 수행 비용은 (K + 1) * logN에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">이 차트에서 SQL 문 ( &quot;SELECT v FROM kv WHERE k =? 1&quot;)이 한 번 준비됩니다. 그런 다음 각 Blob에 대해 Blob 키 값이? 1 매개 변수에 바인드되고 명령문이 평가되어 Blob 컨텐츠를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">이 예에서 docs.name이 &quot;report-15&quot;인 항목에 대한 docs.body 필드의 내용이 편집기로 전송됩니다. 편집기가 리턴 된 후 결과는 docs.body 필드에 다시 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">이 예에서 demo_data.boundary 필드는 객체의 정확한 경계에 대한 일종의 이진 표현을 유지하기위한 것입니다. R * Tree 인덱스는 객체에 대해 축으로 정렬 된 사각형 경계 만 유지합니다. R * Tree 경계는 실제 객체 경계의 근사치입니다. 따라서 일반적으로 R * Tree 색인을 사용하여 후보 개체 목록으로 검색 범위를 좁히고 각 후보에 대해보다 상세하고 값 비싼 계산을 수행하여 후보가 검색 기준을 실제로 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">이 예에서 rowid는 연속적이지 않지만 순서가 있습니다. SQLite는 일반적으로 1부터 시작하여 추가 된 각 행마다 하나씩 증가하는 rowid를 만듭니다. 그러나 행이 삭제되면 시퀀스에 공백이 나타날 수 있습니다. 또한 응용 프로그램은 원하는 경우 지정된 행 ID를 제어하여 행이 맨 아래에 반드시 삽입되는 것은 아닙니다. 그러나 어떤 일이 발생하든 rowid는 항상 고유하며 오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">이 예에서 t2 테이블은 하위 쿼리에서 t1.b 열의 값을 변환하는 데 사용됩니다. 각 테이블에 N 개의 행이 포함 된 경우 SQLite는 하위 쿼리가 N 번 실행될 것으로 예상하므로 먼저 t2에 자동 임시 인덱스를 생성 한 다음 해당 인덱스를 사용하여 하위 쿼리의 N 인스턴스를 충족시키는 것이 더 빠르다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">이 마지막 예에서 phonebook2 항목은 새로 삽입 된 값의 validDate가 이미 테이블에있는 항목보다 최신 인 경우에만 업데이트됩니다. 테이블에 이름이 같고 현재 validDate 인 항목이 이미 있으면 WHERE 절로 인해 DO UPDATE가 no-op가됩니다.</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">후자의 표에는 &quot;word&quot;열을 키로 사용하고 &quot;cnt&quot;열을 데이터로 사용하는 단일 B-Tree 만 있습니다. (기술 : 저수준 구현은 실제로 B-Tree의 &quot;키&quot;영역에 &quot;word&quot;와 &quot;cnt&quot;를 모두 저장하지만 데이터베이스 파일의 저수준 바이트 인코딩을보고 있지 않으면 중요하지 않습니다.) 하나의 B-Tree 만 있기 때문에 &quot;word&quot;열의 텍스트는 데이터베이스에 한 번만 저장됩니다. 또한, 특정 &quot;단어&quot;에 대해 &quot;cnt&quot;값을 쿼리 할 때는 기본 B-Tree에 대한 단일 이진 검색 만 포함됩니다. &quot;cnt&quot;값은 첫 번째 검색에서 찾은 레코드에서 직접 검색 할 필요가 없기 때문입니다. rowid에서 두 번째 이진 검색을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">이 쿼리에서 &quot;xaxis&quot;및 &quot;yaxis&quot;CTE는 Mandelbrot 세트가 근사 될 점의 그리드를 정의합니다. &quot;m (iter, cx, cy, x, y)&quot;CTE의 각 행은 &quot;iter&quot;반복 후에 cx, cy에서 시작하는 Mandelbrot 반복이 x, y 지점에 도달했음을 의미합니다. 이 예제의 반복 횟수는 28로 제한됩니다 (이는 계산 해상도를 심각하게 제한하지만 저해상도 ASCII 아트 출력에는 충분합니다). &quot;m2 (iter, cx, cy)&quot;CTE는 cx, cy 지점에서 시작할 때 도달 한 최대 반복 횟수를 보유합니다. 마지막으로, &quot;a (t)&quot;CTE의 각 행에는 출력 ASCII 아트의 한 줄인 문자열이 있습니다. 마지막에있는 SELECT 문은 &quot;a&quot;CTE를 쿼리하여 ASCII 아트의 모든 행을 하나씩 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">이 스키마에서는 프레젠테이션 내에서 순서를 결정하는 페이지 번호가있는 각 슬라이드 대신 각 슬라이드가 순서대로 발생하는 위치와 관련이없는 고유 한 정수 식별자를 갖습니다. 프레젠테이션의 슬라이드 순서는 VERSION 테이블의 MANIFEST 열에 텍스트 문자열로 저장된 slideId 목록으로 결정됩니다. VERSION 테이블에는 여러 항목이 허용되므로 여러 프레젠테이션을 동일한 문서에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">이 시스템에서 곡 테이블의 각 항목은 아티스트와 앨범의 동일한 조합으로 앨범 테이블의 항목에 매핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">이런 식으로 새로운 포인터 전달 인터페이스는 SQLite에서 한 확장에서 다른 확장으로 포인터 값을 전달하는 것과 관련된 모든 보안 문제를 해결하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">네 번째 인수가있는 루틴에서 값은 매개 변수의 바이트 수입니다. 명확하게 : 값은 &lt;u&gt;바이트&lt;/u&gt; 수입니다.&lt;u&gt;&lt;/u&gt;문자 수가 아닌 값으로. sqlite3_bind_text () 또는 sqlite3_bind_text16 ()에 대한 네 번째 매개 변수가 음수이면 문자열의 길이는 첫 번째 0 종결 자까지의 바이트 수입니다. sqlite3_bind_blob ()의 네 번째 매개 변수가 음수이면 동작이 정의되지 않습니다. 음수가 아닌 네 번째 매개 변수가 sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_text64 ()에 제공되는 경우 해당 매개 변수는 문자열이 NUL로 종료되었다고 가정 할 때 NUL 종료자가 발생할 바이트 오프셋이어야합니다. NUL 문자가 네 번째 매개 변수 값보다 작은 바이트 오프셋에서 발생하면 결과 문자열 값에 NUL이 포함됩니다. NUL이 포함 된 문자열과 관련된 표현식의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">네 번째 인수가있는 루틴에서 해당 값은 매개 변수의 바이트 수입니다. 명확하게 말하면 값은 &lt;u&gt;바이트&lt;/u&gt; 수입니다.&lt;u&gt;&lt;/u&gt;문자 수가 아니라 값에 있습니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 ()의 네 번째 매개 변수가 음수이면 문자열의 길이는 첫 번째 0 종결 자까지의 바이트 수입니다. sqlite3_bind_blob ()에 대한 네 번째 매개 변수가 음수이면 동작이 정의되지 않습니다. 음수가 아닌 네 번째 매개 변수가 sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_text64 ()에 제공되면 해당 매개 변수는 문자열이 NUL로 종료되었다고 가정 할 때 NUL 종료자가 발생하는 바이트 오프셋이어야합니다. 네 번째 매개 변수의 값보다 작은 바이트 오프셋에서 NUL 문자가 발생하면 결과 문자열 값에 포함 된 NUL이 포함됩니다. NUL이 포함 된 문자열을 포함하는 표현식의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">저널 모드 자르기에서는 저널 파일을 삭제하지 않고 (삭제 모드에서와 같이) 저널 파일을 길이가 0으로 자르거나 (PERSIST 모드에서와 같이) 헤더를 0 화하여 트랜잭션을 커미트합니다. TRUNCATE 모드는 저널 파일 및 데이터베이스를 포함하는 디렉토리를 업데이트 할 필요가 없다는 PERSIST 모드의 장점을 공유합니다. 따라서 파일을 자르는 것이 파일을 삭제하는 것보다 빠릅니다. TRUNCATE는 변경 사항을 디스크에 동기화하기 위해 시스템 호출 (예 : fsync ())이 뒤 따르지 않는다는 추가 이점이 있습니다. 그렇게하면 더 안전 할 수 있습니다. 그러나 많은 현대 파일 시스템에서 잘림은 원자적이고 동기적인 작업이므로 TRUNCATE는 정전시 일반적으로 안전하다고 생각합니다.TRUNCATE가 파일 시스템에서 동 기적이며 원자 적인지 여부에 대해 확실하지 않은 경우 데이터베이스가 절단 작업 중에 발생하는 전원 손실 또는 운영 체제 충돌에서 살아남는 것이 중요한 경우 다른 저널링 모드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">버전 3.5.9에서 위의 쿼리는 &quot;t1.a&quot;라는 단일 열을 반환합니다. 버전 3.6.0에서 열 이름은 &quot;a&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">이전 버전의 SQLite (버전 3.7.11-2012-03-20 이전)에서 보류중인 쿼리가 있으면 오류 코드 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 와 함께 ROLLBACK이 실패 합니다. 최신 버전의 SQLite에서 ROLLBACK이 진행되고 보류중인 문이 종종 중단되어 &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; 오류가 반환 됩니다. SQLite 버전 3.8.8 (2015-01-16) 이상에서 ROLLBACK이 데이터베이스 스키마를 수정하지 않는 한 보류중인 읽기는 ROLLBACK 후에 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">즉, &quot;one&quot;과 &quot;two&quot;라는 두 개의 데이터 열이있는 &quot;examp&quot;라는 데이터베이스 테이블이 있습니다. 이제이 테이블에 단일 레코드를 삽입하려고한다고 가정하십시오. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">인 메모리 데이터베이스</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">인 메모리 데이터베이스 및 공유 캐시</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">인 메모리 데이터베이스는 &lt;a href=&quot;uri&quot;&gt;URI filename을&lt;/a&gt; 사용하여 열 경우 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 사용할 수 있습니다 . 메모리에없는 데이터베이스를 지정하기 위해 unadorned &quot;: memory :&quot;이름을 사용하는 경우 해당 데이터베이스에는 항상 개인 캐시가 있으며 원래 데이터베이스를 연 데이터베이스 연결에서만 볼 수 있습니다. 그러나 다음과 같이 두 개 이상의 데이터베이스 연결로 동일한 인 메모리 데이터베이스를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">모든 식별자 이름 어딘가에 숫자를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">RCS &quot;ident&quot;명령에 응답하고 라이브러리 버전 번호를 포함하는 정적 문자열을 라이브러리에 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">호환되지 않는 변경 사항은 유지 보수 자와 프로그래머에게 가장 중요하므로 먼저 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE AS와 간단한 SELECT 사이에 결과 집합 열 이름이 일치하지 않습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">A. Rottmann이 LIBTOOL을 사용하도록 makefile 패치를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">잘못된 assert () 문이 제거되었습니다. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">잘못된 열 데이터 유형이보고되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;A8A0D2996A&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">ORDER BY DESC와의 결합에서 올바르지 않은 조회 결과. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">미리 건너 뛰기 최적화가 사용될 때 잘못된 쿼리 결과. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 에서보다 작음 연산자에 대한 결과가 잘못되었습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;F484B65F3D62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 수의 &lt;a href=&quot;limits#max_variable_number&quot;&gt;기본 상한&lt;/a&gt; 을 999에서 32766 으로 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">기본 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 할당 크기를 100에서 128 바이트로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">연결 당 56KB의 추가 메모리 만 추가하는 동시에 더 나은 성능을 제공 하므로 기본 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; 크기를 512,125에서 1200,100으로 늘리십시오 . 메모리에 민감한 응용 프로그램은 컴파일 타임, 시작 시간 또는 런타임에 이전 기본값을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">lookahead 캐시 라인의 기본 크기를 100 바이트에서 128 바이트로 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; 의 기본값 을 50 으로 늘리고 모든 위치에서 스키마 변경으로 인해 명령문이 재 시도되도록 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장자 의 최대 &quot;scope&quot;값을 6에서 30으로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">데이터베이스 페이지의 최대 크기를 32KiB에서 64KiB로 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="translated">데이터베이스 파일의 최대 크기를 281TB로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; 의 최대 값을 30에서 62로 늘리십시오 (기본값은 10 으로 유지됨 ).</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; 의 최대 값을 62에서 125로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; 오류를 발행하기 전에 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 제한 시간 을 1 초에서 10 초로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">악의적으로 손상된 데이터베이스에 대해 실행되는 악성 SQL에 대한 견고성이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;VFS 오브젝트&lt;/a&gt; 의 버전 번호 를 3으로 늘리고 전체 범위 테스트를 수행하는 데 사용되는 새로운 메소드 xSetSysCall, xGetSysCall 및 xNextSysCall을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">P2에 의해 &quot;제한 카운터&quot;를 증가시킵니다 (P2는 음수 또는 양수일 수 있음). P1이 0이 아닌 경우 데이터베이스 제한 조건 카운터가 증가합니다 (지연된 외래 키 제한 조건). 그렇지 않으면 P1이 0이면 명령문 카운터가 증가합니다 (즉각 외래 키 제한 조건).</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X를&lt;/a&gt; 사용하여 스키마 버전 번호를 늘리십시오. 여기서 X는 위의 2 단계에서 찾은 이전 스키마 버전 번호보다 하나 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">한 &lt;a href=&quot;opcode#Once&quot;&gt;번&lt;/a&gt; opcode가이 실행에 대해 처음 평가 될 때 점프 하도록 P1의 값을 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">증분 및 지속적인 업데이트</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">인덱스 B- 트리 내부 셀 (헤더 0x02) :</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">인덱스 B- 트리 리프 셀 (헤더 0x0a) :</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">색인 B 나무 잎 또는 내부 세포 :</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">인덱스 인테리어 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">인덱스 리프 (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">주어진 이름을 가진 매개 변수의 색인</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">식에 대한 색인</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; 명령으로 인덱스를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">인덱스는 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; 및 &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE를&lt;/a&gt; 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">하위 키 열에는 인덱스가 필요하지 않지만 거의 항상 유리합니다. &lt;a href=&quot;#fk_basics&quot;&gt;섹션 1&lt;/a&gt; 의 예제로 돌아가서 애플리케이션이 애플리케이션에서 행을 삭제할 때마다</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">일반 테이블에서 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건 을 구현하는 데 사용되는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름을 가진 인덱스</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 사용하여 작성된 개별 데이터베이스 연결 은 세 번째 매개 변수 인 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 플래그를 사용하여 공유 캐시 모드에 참여하거나 참여하지 않도록 선택할 수 있습니다 . 이 플래그 중 하나를 사용하면 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에&lt;/a&gt; 의해 설정된 글로벌 공유 캐시 모드 설정을 대체합니다 . 하나 이상의 플래그를 사용해야합니다. SQLITE_OPEN_SHAREDCACHE 및 SQLITE_OPEN_PRIVATECACHE 플래그가 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 의 세 번째 인수에 사용 되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">WAL 헤더에서 복사 된 솔트 값을 제외한 shm 헤더의 개별 필드는 호스트 시스템의 기본 바이트 순서에서 부호없는 정수입니다. 솔트 값은 WAL 헤더의 정확한 사본이며 WAL 파일에서 사용하는 바이트 순서에 관계없이 있습니다. 정수의 크기는 8, 16, 32 또는 64 비트 일 수 있습니다. shm 헤더의 개별 필드에 대한 자세한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">개별 하위 용어는 * a = 5 * 또는 * x&amp;gt; y *와 같은 단일 비교식이거나 LIKE 또는 BETWEEN식이거나 하위 연결은 괄호로 묶인 AND 연결 하위 하위 목록 일 수 있습니다. 각 하위 용어는 자체적으로 전체 WHERE 절인 것처럼 분석되어 하위 용어 자체가 색인 가능한지 여부를 확인합니다. 경우 &lt;u&gt;모든&lt;/u&gt; 는 OR 절 subterm 별도로 색인입니다 후 OR 절은 별도의 인덱스는 OR 절의 각 용어를 평가하는 데 사용되도록 코딩 될 수 있습니다. SQLite가 각 OR 절 용어에 대해 별도의 인덱스를 사용하는 방법에 대해 생각하는 한 가지 방법은 WHERE 절이 다음과 같이 다시 작성되었다고 상상하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">개별 가상 테이블 구현은 추가 제한 조건을 부과 할 수 있습니다. 예를 들어, 일부 가상 구현은 읽기 전용 테이블을 제공 할 수 있습니다. 또는 일부 가상 테이블 구현에서는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE를&lt;/a&gt; 허용 하지만 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 는 허용 하지 않을 수 있습니다 . 또는 일부 가상 테이블 구현으로 인해 UPDATE 유형이 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">WHERE 절에서 OR 연산자를 사용하는 UPDATE의 무한 루프. 3.17.0에서 소개 된 문제로 약 1 년 후 메일 링리스트에보고되었습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY 절에 대한 정보는 aOrderBy []에 저장됩니다. aOrderBy의 각 용어는 ORDER BY 절의 열을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">알파 코드의 최초 공개</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">버전 2.0의 초기 릴리스. 라이브러리를 &quot;SQLus&quot;로 이름을 바꾸려는 아이디어는 &quot;SQLite&quot;이름을 유지하고 주요 버전 번호를 부딪히기 위해 포기되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">페이지의 데이터베이스 초기 크기</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 초기화</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">색인 X를 N-200으로 초기화하십시오 (여기서 N은 데이터베이스 페이지의 크기 (바이트)).</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">콜백에 대한 &lt;b&gt;azColumnName []&lt;/b&gt; 배열을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">오프셋 12에서 저널 헤더에있는 체크섬 nonce 값으로 체크섬을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">내부 조인은 자유롭게 재정렬 할 수 있습니다. 그러나 왼쪽 외부 조인은 정식이나 연관성이 없으므로 재정렬되지 않습니다. 옵티마이 저가 유리하다고 생각하지만 외부 조인이 항상 발생 순서대로 평가되면 외부 조인의 왼쪽과 오른쪽에있는 내부 조인이 재정렬 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">해당 단일 행을 재귀 테이블에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">레지스터 P2가 보유한 정수 값을 레지스터 P1에 보유 된 RowSet 오브젝트에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">데이터베이스에 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">LIMIT 절은 별도의 OFFSET 절 대신 쉼표로 구분 된 두 개의 스칼라 식을 지정할 수 있습니다. 이 경우 첫 번째 표현식은 OFFSET 표현식으로 사용되고 두 번째 표현식은 LIMIT 표현식으로 사용됩니다. 이는 OFFSET 절을 사용할 때 두 표현식 중 두 번째 표현식이 OFFSET이고 첫 번째가 LIMIT이므로 직관적이지 않습니다. 이러한 오프셋 및 제한의 반전은 의도적입니다. 다른 SQL 데이터베이스 시스템과의 호환성을 최대화합니다. 그러나 혼동을 피하기 위해 프로그래머는 &quot;OFFSET&quot;키워드를 사용하는 LIMIT 절 형식을 사용하고 쉼표로 구분 된 오프셋으로 LIMIT 절을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">&quot;두&quot;열이 50보다 작은 레코드를 삭제하는 대신이 명령문은 &quot;하나&quot;열을 괄호 안에 넣습니다.이 명령문을 구현하는 VDBE 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">SQLite는 기본적으로 완전한 유니 코드 대 / 소문자 지원을 제공하는 대신 외부 유니 코드 비교 및 ​​변환 루틴에 대한 링크 기능을 제공합니다. 애플리케이션은 내장 &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; 조합 시퀀스 ( &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation () 사용&lt;/a&gt; ) 및 내장 &lt;a href=&quot;lang_corefunc#like&quot;&gt;like ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; 함수 ( &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 사용 )를 오버로드 할 수 있습니다 . SQLite 소스 코드에는 이러한 과부하를 수행하는 &quot;ICU&quot;확장자가 포함되어 있습니다. 또는 개발자는 프로젝트에 이미 포함 된 고유 한 유니 코드 인식 비교 루틴을 기반으로 자체 과부하를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">전체 텍스트 인덱스를 저장하기 위해 디스크에서 단일 데이터 구조를 사용하는 대신 FTS5는 일련의 b- 트리를 사용합니다. 새 트랜잭션이 커밋 될 때마다 커밋 된 트랜잭션의 내용을 포함하는 새 b- 트리가 데이터베이스 파일에 기록됩니다. 전체 텍스트 인덱스를 쿼리 할 때 각 b- 트리를 개별적으로 쿼리하고 결과를 병합하여 사용자에게 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">후행 인수없이 bm25 ()를 사용하는 대신 순위 열에 매핑 된 특정 보조 함수는 쿼리별로 구성하거나 FTS 테이블에 대해 다른 영구 기본값을 설정하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">전체 텍스트 인덱스와 컨텐트 테이블에 별도로 쓰는 대신 일부 사용자는 데이터베이스 트리거를 사용하여 컨텐트 테이블에 저장된 문서 집합과 관련하여 전체 텍스트 인덱스를 최신 상태로 유지할 수 있습니다. 예를 들어, 이전 예제의 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">이 예에서는 명령 1이 특히 중요합니다. 일반적으로 Column 명령어는 SQLite 파일 항목의 데이터에서 더 큰 레코드에서 열 값을 추출합니다. 명령 1은 임시 테이블에 플래그를 설정하여 Column이 대신 SQLite 파일 항목의 키를 데이터 인 것처럼 취급하고 키에서 열 정보를 추출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">명령어 0 ~ 4는 INSERT 예와 같습니다. 기본 및 임시 데이터베이스에 대한 트랜잭션을 시작하고 기본 데이터베이스에 대한 데이터베이스 스키마를 확인한 후 &quot;examp&quot;테이블에서 읽기 커서를 엽니 다. 커서는 쓰기가 아니라 읽기 위해 열립니다. 프로그램의이 단계에서는 테이블을 변경하지 않고 스캔 만 할 것입니다. 우리는 명령 15에서 나중에 쓰기 위해 동일한 테이블을 다시 열 것입니다.</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">명령어 11부터 18까지는 명령어 8에서 가져온 키를 사용하여 모든 인덱스 레코드에 대해 루프를 구현합니다.이 키가있는 모든 인덱스 레코드는 인덱스 테이블에서 연속적이므로 해당 테이블을 통해 해당 테이블 키를 가져옵니다. 인덱스. 그런 다음이 테이블 키는 커서를 테이블의 해당 행으로 이동하는 데 사용됩니다. 루프의 나머지 부분은 인덱싱되지 않은 SELECT 쿼리의 루프와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">인스트럭션 18 내지 23은 인덱스되는 테이블의 모든 행에 루프를 구현한다. 각 테이블 행에 대해 먼저 명령 19의 Recno를 사용하여 해당 행의 정수 키를 추출한 다음 명령 20의 열을 사용하여 &quot;2&quot;열의 값을 가져옵니다. 21 의 &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; 명령은 &quot;2&quot;열의 데이터를 변환합니다 ( 유효한 인덱스 키로) 단일 열의 인덱스의 경우 기본적으로 no-op입니다. 그러나 MakeIdxKey에 대한 P1 피연산자가 하나보다 크면 여러 항목이 스택에서 팝되어 단일 인덱스 키로 변환되었을 것입니다. &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;22의 지시는 실제로 색인 항목을 작성하는 것입니다. IdxPut은 스택에서 두 요소를 팝합니다. 스택의 맨 위는 인덱스 테이블에서 항목을 가져 오기위한 키로 사용됩니다. 그런 다음 스택의 두 번째 정수는 해당 인덱스의 정수 세트에 추가되고 새 레코드는 데이터베이스 파일에 다시 기록됩니다. 두 열에 대해 동일한 값을 가진 두 개 이상의 테이블 항목이있는 경우 동일한 인덱스 항목이 여러 정수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">명령어 19 ~ 25는 기존 레코드를 대체하는 데 사용할 새 데이터베이스 레코드를 구성합니다. 이것은 우리가 INSERT의 설명에서 보았던 것과 같은 종류의 코드이며 더 이상 설명하지 않을 것입니다. 명령어 25가 실행 된 후 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">명령어 2와 3은 쿼리 할 데이터베이스 테이블에서 읽기 커서를 엽니 다. 이것은 커서가 쓰기 대신이 시간 읽기 위해 열린다는 점을 제외하고 INSERT 예제의 OpenWrite 명령어와 동일하게 작동합니다. 명령어 4는 INSERT 예제에서와 같이 데이터베이스 스키마를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android 컴파일 지침은 &lt;a href=&quot;#compile-android&quot;&gt;다음과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">오버플로를 초래 한 정수 산술 연산은 이제 부동 소수점을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">세그먼트 b- 트리 노드의 일부로 저장된 정수 값은 FTS varint 형식을 사용하여 인코딩됩니다. 이 인코딩은 유사한되지만 &lt;b&gt;동일하지 않은&lt;/b&gt; 사람, &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite는 varint 포맷&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="translated">자유 목록의 무결성</target>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">이 메모리 슬롯의 의도 된 사용</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">테이블 b- 트리의 내부 페이지에는 페이로드가 없으므로 엎질러 질 페이로드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">내부 대 외부 BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLite의 내부 대 외부 BLOB</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite가 사용하는 내부 스키마 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">내부 테이블</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">내부적으로 Geopoly는 다각형을 이진 형식 (SQL BLOB)으로 저장합니다. 이진 형식의 세부 사항은 다음과 같습니다. 모든 Geopoly 인터페이스는 GeoJSON 형식 또는 이진 형식의 다각형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM () 함수의 국제화 티켓 # 2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">오프셋 X의 바이트를 페이지의 8 비트 부호없는 정수로 해석하고 해당 정수 값을 체크섬에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">레지스터 P1의 내용을 정수로 해석하십시오. P1 값의 보수를 레지스터 P2에 저장하십시오. P1에 NULL이 있으면 P2에 NULL을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">커서 P1이 가리키는 데이터를 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령을 사용하여 작성된 구조로 해석하십시오 . 데이터 형식에 대한 추가 정보 는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode를 참조하십시오 .이 레코드에서 P2 번째 열을 추출하십시오. 레코드에 그보다 적은 (P2 + 1) 값이 있으면 NULL을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">레지스터 P1의 값을 부울 값으로 해석하십시오. 해당 부울 (0 또는 1)을 레지스터 P2에 저장하십시오. 또는 레지스터 P1의 값이 NULL이면 P3이 레지스터 P2에 저장됩니다. P4가 1이면 답을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">레지스터 P1의 값을 부울 값으로 해석하십시오. 부울 보수를 레지스터 P2에 저장하십시오. 레지스터 P1의 값이 NULL이면 NULL이 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">장기 실행 쿼리 중단</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">확장 오류 코드를 소개하고 다양한 종류의 I / O 오류에 대한 오류 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">SQLite 데이터베이스 파일 ( &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블&lt;/a&gt; ) 의 디스크 내용을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">직관적으로, 우리 인간은 알고리즘 -1이 가장 좋다는 것을 이해합니다. 각 체크인에는 자녀가 거의 없을 것이며 (한 자녀가 가장 흔한 경우) 각 자녀는 로그 시간에 $ trunk 태그를 테스트 할 수 있습니다. 실제로 알고리즘 1이 실제로 가장 빠른 선택입니다. 그러나 NGQP는 직관이 없습니다. NGQP는 하드 수학을 사용해야하며 알고리즘 -2는 수학적으로 약간 더 좋습니다. 다른 정보가 없으면 NGQP는 인덱스 PLINK_I1 및 TAGXREF_I1의 품질이 동일하고 선택적으로 동일하다고 가정해야하기 때문입니다. 알고리즘 -2는 TAGXREF_I1 인덱스의 한 필드와 PLINK_I1 인덱스의 두 필드를 사용하지만 algorithm-1은 각 인덱스의 첫 번째 필드 만 사용합니다. 알고리즘 -2는 더 많은 색인 자료를 사용하므로 NGQP는이를 더 나은 알고리즘으로 판단합니다.점수는 가깝고 알고리즘 2는 알고리즘 1보다 거의 삐걱 거리지 않습니다. 그러나 알고리즘 -2가 실제로 올바른 선택입니다.</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">변경 세트 반전</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">적용하기 전에 변경 세트를 뒤집습니다. 이는 sqlite3changeset_invert ()를 사용하여 변경 세트를 적용하기 전에 반전시키는 것과 같습니다. 패치 세트로이 플래그를 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">반복하면서 체인지 셋을 뒤집습니다. 이는 sqlite3changeset_invert ()를 사용하여 변경 세트를 적용하기 전에 반전시키는 것과 같습니다. 패치 세트로이 플래그를 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="translated">각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 열리 자마자 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; , 0,0)를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 호출제공된 명령문 핸들과 연관된 데이터베이스 연결 핸들에서 를 하여 잠금 해제 알림 콜백에 등록하십시오. unlock_notify () 호출이 SQLITE_LOCKED를 리턴하면이 값을 호출자에게 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 장치에서 가져온 P5 인수를 사용하여 사용자 함수 (P4는 함수를 정의하는 FuncDef 객체에 대한 포인터)를 호출합니다. 기능의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3은 기능 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 장치에서 가져온 P5 인수를 사용하여 사용자 함수 (P4는 실행할 함수에 대한 포인터를 포함하는 sqlite3_context 객체에 대한 포인터)를 호출합니다. 기능의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3은 기능 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 작업에서 가져온 인수를 사용하여 사용자 함수 (P4는 실행할 함수에 대한 포인터를 포함하는 sqlite3_context 개체에 대한 포인터)를 호출합니다. 인수의 수는 P4가 가리키는 sqlite3_context 객체에 있습니다. 함수의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3는 함수 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">매개 변수를 -N으로 설정하고 'merge'명령을 한 번 호출 한 다음</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">매개 변수를 N으로 설정하여 'merge'명령을 0 번 이상 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">결과의 현재 행에 대한 콜백 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">sqlite3rbu 객체 포인터 X에서 sqlite3rbu_step (X) 함수를 한 번 이상 호출하십시오. sqlite3rbu_step ()에 대한 각 호출은 단일 b- 트리 작업을 수행하므로 완전한 업데이트를 적용하려면 수천 번의 호출이 필요할 수 있습니다. 업데이트가 완전히 적용되면 sqlite3rbu_step () 인터페이스는 SQLITE_DONE을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">xValue () 함수를 호출하고 결과를 레지스터 P3에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">NULL 포인터에서 sqlite3_finalize ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">인수로이 pragma를 호출하는 것은 인수에 해당 하는 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;세 번째 매개 변수로 &lt;/a&gt;&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">인수없이이 pragma를 호출하는 것은 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLite는 안전합니까?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">다음으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">격리와 동시성</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">데이터베이스 연결 간 격리</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLite에서 격리</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">문제 &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX의&lt;/a&gt; 온 경고 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG를&lt;/a&gt; 쿼리 플래너가 자동으로 인덱스를 사용 할 때마다.</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴&lt;/a&gt; 을 사용 하는 경우 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에서 SQLITE_WARNING 메시지를 발행하십시오 .</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">sqlite_master 테이블이 손상되어 sqlite_sequence 테이블 루트 페이지가 실제로 btree-index 페이지가되도록 어설 션 오류 또는 널 포인터 역 참조 대신 오류를 발행하십시오. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">데이터베이스 zFrom이 존재하지 않거나 필수 호환 테이블이 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">인 메모리 데이터베이스와 데이터를 복사하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">테이블이나 인덱스를 삭제할 때 발생할 수있는 SQLITE_LOCKED의 특수한 경우를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">스레드 우선 순위를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">존재하고</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">대상 데이터베이스 이름을 기반으로 RBU 진공 상태 데이터베이스 이름을 결정하기위한 규칙을 설정하는 것이 좋습니다. 아래의 예제 코드는 &quot;&amp;lt;target&amp;gt; -vacuum&quot;을 사용합니다. 여기서 &amp;lt;target&amp;gt;은 정리할 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">&lt;b&gt;sqlite_step&lt;/b&gt; 이 SQLITE_DONE을 리턴 하기 전에 가상 머신에서 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출 할 수 있습니다. 그렇게하면 진행중인 작업이 중단됩니다. 실행중인 SQL에서 ON CONFLICT 절을 사용하여 대체 복구 알고리즘을 선택하지 않는 한 부분적으로 완료된 변경 사항이 롤백되고 데이터베이스가 원래 상태로 복원됩니다. &lt;b&gt;sqlite_exec&lt;/b&gt; 의 콜백 함수 가 0이 아닌 값을 반환했습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">&lt;b&gt;sqlite_step에&lt;/b&gt; 한 번도 전달되지 않은 가상 머신에서 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출하는 것도 가능합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">FTS5 용 맞춤형 토크 나이저를 생성 할 수도 있습니다. 이를위한 API &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;는 여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">유니 코드 61이 구분 문자로 취급하는 코드 포인트 세트를 사용자 정의 할 수도 있습니다. &quot;separators =&quot;옵션은 분리 문자로 취급되어야하는 하나 이상의 추가 문자를 지정하는 데 사용될 수 있으며 &quot;tokenchars =&quot;옵션은 대신 토큰의 일부로 처리되어야하는 하나 이상의 추가 문자를 지정하는 데 사용될 수 있습니다. 구분 문자로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="translated">예를 들어, UPDATE 문이 다른 행의 복잡한 쿼리를 기반으로 R- 트리의 한 행 값을 변경하려고하는 경우와 같이 단일 쿼리 내에서 R- 트리에서 이러한 종류의 동시 읽기 및 쓰기를 표현할 수도 있습니다. 동일한 R- 트리의 아마도 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">FTS5 테이블을 작성하는 데 사용 된 CREATE VIRTUAL TABLE 문 에 유형, 제한 조건 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 선언 을 추가하는 것은 오류 입니다. FTS5 테이블을 만든 후에는 다른 테이블과 마찬가지로 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 채울 수 있습니다 . PRIMARY KEY 선언이없는 다른 테이블과 마찬가지로 FTS5 테이블에는 rowid라는 암시 적 INTEGER PRIMARY KEY 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">sz 또는 rawdata 필드를 NULL 이외의 다른 값으로 설정하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">columnsize 옵션을 0 또는 1 이외의 값으로 설정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">xToken ()을 처음 호출 할 때 FTS5_TOKEN_COLOCATED 플래그를 지정하면 오류가 발생합니다. xToken (FTS5_TOKEN_COLOCATED)을 여러 번 호출하여 단일 토큰에 대해 여러 동의어를 지정할 수 있습니다. 단일 토큰에 제공 될 수있는 동의어의 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">커서는 추가 용도로만 사용되므로 커서가 유효하면 커서가 이미 btree의 끝을 가리키고 있어야하므로 커서가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">일련의 순차적 데이터 블록을 파일에 순서대로 쓰는 것이 동일한 블록을 임의의 순서로 쓰는 것보다 빠르다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">sqlite3changegroup_new ()에 대한 호출을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">ZIP 아카이브에서 개별 항목을 업데이트하는 것은 어렵습니다. 업데이트 도중 컴퓨터 전원이 꺼 지거나 충돌하는 경우 전체 문서를 손상시키지 않는 방식으로 ZIP 아카이브의 개별 항목을 업데이트하는 것이 특히 어렵습니다. 이 작업을 수행하는 것은 불가능하지 않지만 실제로는 아무도 그렇게하기가 충분히 어렵습니다. 대신 사용자가 &quot;파일 / 저장&quot;을 선택할 때마다 전체 ZIP 아카이브가 다시 작성됩니다. 따라서 &quot;파일 / 저장&quot;은 특히 오래된 하드웨어의 경우보다 오래 걸립니다. 최신 머신은 더 빠르지 만, 50MB 프레젠테이션에서 단일 문자를 변경하면 SSD에서 50MB의 유한 쓰기 수명이 발생하는 것이 여전히 귀찮습니다.</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1과 P3이 동일한 레지스터 인 것은 불법입니다. P3가 P2와 동일한 레지스터 인 경우 구현시 memcpy ()를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">동일한 데이터베이스 파일에 대한 모든 연결은 동일한 잠금 프로토콜을 사용해야합니다. 한 응용 프로그램이 POSIX 권고 잠금을 사용하고 다른 응용 프로그램이 도트 파일 잠금을 사용하는 경우 두 응용 프로그램은 서로의 잠금을 볼 수 없으며 데이터베이스 액세스를 조정할 수 없으므로 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">SQLite 버전을 변경하면 쿼리 계획이 변경 될 수 있습니다. 동일한 버전의 SQLite는 항상 동일한 쿼리 계획을 선택하지만 다른 버전의 SQLite를 사용하도록 응용 프로그램을 다시 연결하면 쿼리 계획이 변경 될 수 있습니다. 드문 경우이지만 SQLite 버전 변경으로 인해 성능이 저하 될 수 있습니다. 이 때문에 지식이나 제어없이 변경 될 수있는 시스템 전체 SQLite 공유 라이브러리를 사용하는 대신 SQLite에 대해 애플리케이션을 정적으로 링크하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">어느 것을 깨닫는 것이 중요하다 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 도 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()가&lt;/a&gt; 핵심 루틴을 사용하여 수행 할 수없는 아무것도. 실제로 이러한 래퍼는 핵심 루틴 측면에서 순전히 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">섹터를 쓰는 동안 전원 손실로 인한 데이터베이스 손상을 방지하려면 섹터의 모든 페이지를 롤백 저널에 저장하는 것이 중요합니다. 페이지 1, 2, 3 및 4가 모두 섹터 1에 저장되고 페이지 2가 수정되었다고 가정하십시오. 변경 사항을 2 페이지에 쓰려면 하드웨어가 전체 섹터를 작성해야하므로 기본 하드웨어도 1, 3, 4 페이지의 내용을 다시 작성해야합니다. 정전으로 인해이 쓰기 작업이 중단되면 1, 3 또는 4 페이지 중 하나 이상에 잘못된 데이터가 남아있을 수 있습니다. 따라서 데이터베이스의 지속적인 손상을 피하기 위해 모든 해당 페이지의 원본 내용을 롤백 저널에 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">&quot;서버리스&quot;에 대한이 두 가지 정의를 이해하는 것이 중요합니다. 데이터베이스가 &quot;서버리스&quot;라고 주장 할 때는 데이터베이스가 &quot;클래식 서버리스&quot;인지 &quot;네오 서버리스&quot;인지를 식별해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
