<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="2009f584db4b6762c01a87103a205a43fe3cb848" translate="yes" xml:space="preserve">
          <source>Continuing improvements to the test suite and fixes to obscure bugs and inconsistencies that the test suite improvements are uncovering.</source>
          <target state="translated">테스트 스위트에 대한 지속적인 개선 및 테스트 스위트 개선에서 발견 된 버그 및 불일치를 모호하게 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="1ca7bf3d67fb3020228ac37bd4bc93280daba832" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">많은 직관과 달리 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 을 재설정하지 않습니다 . 이 루틴을 사용하여 모든 호스트 매개 변수를 NULL로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cdcbd7d39f460823aca9b9fc7f28e86a6837fad5" translate="yes" xml:space="preserve">
          <source>Contrary to the intuition of many, &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; does not reset the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. Use this routine to reset all host parameters to NULL.</source>
          <target state="translated">많은 직관과 달리 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 은 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 을 재설정하지 않습니다 . 이 루틴을 사용하여 모든 호스트 매개 변수를 NULL로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="56e3d51f494e6dd366ee62fae61ac03a93a7f2a3" translate="yes" xml:space="preserve">
          <source>Controlling Depth-First Versus Breadth-First Search Of a Tree Using ORDER BY</source>
          <target state="translated">ORDER BY를 사용하여 트리의 너비 우선 검색에 대한 깊이 우선 제어</target>
        </trans-unit>
        <trans-unit id="ea782105450bbc3723c1b76880caef4ed08032a7" translate="yes" xml:space="preserve">
          <source>Convenience Routines For Running Queries</source>
          <target state="translated">쿼리 실행을위한 편의 루틴</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="5e7d5a98bcc47f452d8a4ce28a7202d2ed515e6c" translate="yes" xml:space="preserve">
          <source>Conversion Processing</source>
          <target state="translated">변환 처리</target>
        </trans-unit>
        <trans-unit id="d77ae256c17778b6b22cdb6d26f46c01f50b1386" translate="yes" xml:space="preserve">
          <source>Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified. Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be와 UTF-16le 사이의 변환은 항상 제자리에서 수행되며 이전 포인터가 참조하는 버퍼의 내용은 물론 이전 포인터를 무효화하지 않습니다. 다른 종류의 변환은 가능할 때 수행되지만 때로는 불가능할 수도 있으며 이러한 경우 이전 포인터가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="8527a14f28507a486e3c2038fa5167e707f4acec" translate="yes" xml:space="preserve">
          <source>Convert P2 registers beginning with P1 into the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; use as a data record in a database table or as a key in an index. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode can decode the record later.</source>
          <target state="translated">P1로 시작하는 P2 레지스터를 데이터베이스 테이블의 데이터 레코드 또는 인덱스의 키로 사용 하는 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드 형식&lt;/a&gt; 으로 변환하십시오 . &lt;a href=&quot;opcode#Column&quot;&gt;열&lt;/a&gt; 연산 코드는 나중에 기록을 디코딩 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6110d61a4f0b93f4f1786cc181b877ffbc07b6f5" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;#&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%23&lt;/code&gt;&quot;.</source>
          <target state="translated">모든 &quot; &lt;code&gt;#&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;%23&lt;/code&gt; &quot; 으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb7da03590965d6f39aa9b4cc1a3abd9c78729ec" translate="yes" xml:space="preserve">
          <source>Convert all &quot;&lt;code&gt;?&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;%3f&lt;/code&gt;&quot;.</source>
          <target state="translated">모든 &quot; &lt;code&gt;?&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;%3f&lt;/code&gt; &quot; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba96b2a30818bbfb1c821c9fb2ff8c5dd760ffc" translate="yes" xml:space="preserve">
          <source>Convert all sequences of two or more &quot;&lt;code&gt;/&lt;/code&gt;&quot; characters into a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">둘 이상의 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자 의 모든 시퀀스를 단일 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="9218bd4afe759364703b183410a2dc13af3bfd80" translate="yes" xml:space="preserve">
          <source>Convert array constants in the code to have type &quot;const&quot;.</source>
          <target state="translated">코드의 배열 상수를 &quot;const&quot;유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="efad9a1cd6300f3155adba4fdbf6f2272fac9217" translate="yes" xml:space="preserve">
          <source>Convert from integer to float</source>
          <target state="translated">정수에서 부동으로 변환</target>
        </trans-unit>
        <trans-unit id="2d1e75be417c65c8d6a61a4be607d4baf9fd907e" translate="yes" xml:space="preserve">
          <source>Convert the underlying virtual machine to be a register-based machine rather than a stack-based machine. The only user-visible change is in the output of EXPLAIN.</source>
          <target state="translated">기본 가상 머신을 스택 기반 머신이 아닌 레지스터 기반 머신으로 변환하십시오. 사용자가 볼 수있는 유일한 변경은 EXPLAIN의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="293e7888094e60e7ae942b34aacf8692de6ac28c" translate="yes" xml:space="preserve">
          <source>Convert to the new website: http://www.sqlite.org/</source>
          <target state="translated">새 웹 사이트로 변환하십시오 : http://www.sqlite.org/</target>
        </trans-unit>
        <trans-unit id="af74f7c5362aaee985bf8cda3dd75fc80751ce51" translate="yes" xml:space="preserve">
          <source>Copy</source>
          <target state="translated">Copy</target>
        </trans-unit>
        <trans-unit id="62e344ae607b939275b619f121fe73746c0c7f9a" translate="yes" xml:space="preserve">
          <source>Copy And Free SQL Values</source>
          <target state="translated">복사 및 사용 가능한 SQL 값</target>
        </trans-unit>
        <trans-unit id="2a054004f4716fcfdd66797784227739af6ae2e6" translate="yes" xml:space="preserve">
          <source>Copy data</source>
          <target state="translated">데이터 복사</target>
        </trans-unit>
        <trans-unit id="a8edd5c34da27f929be29297a3e1a0b2b7d510c9" translate="yes" xml:space="preserve">
          <source>Copy the contents of all</source>
          <target state="translated">모든 내용을 복사</target>
        </trans-unit>
        <trans-unit id="206ba42d17a054137e160f699cf45b4c2254d889" translate="yes" xml:space="preserve">
          <source>Copy the database file using an external tool (for example the unix 'cp' utility or the DOS 'copy' command).</source>
          <target state="translated">외부 도구를 사용하여 데이터베이스 파일을 복사하십시오 (예 : unix 'cp'유틸리티 또는 DOS 'copy'명령).</target>
        </trans-unit>
        <trans-unit id="c901be66df5ef99ab4f24023bacf5da468cc8855" translate="yes" xml:space="preserve">
          <source>Copying a database file without also copying its journal.</source>
          <target state="translated">저널도 복사하지 않고 데이터베이스 파일을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="9a851d1cd68948a591dc0c34333564d39d950b93" translate="yes" xml:space="preserve">
          <source>Copyright on all code was disclaimed. The library is now in the public domain.</source>
          <target state="translated">모든 코드에 대한 저작권이 부인되었습니다. 라이브러리는 이제 공개 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc488c7530d4abc0197fb3c29656e9202c9e37f" translate="yes" xml:space="preserve">
          <source>Core Functions</source>
          <target state="translated">핵심 기능</target>
        </trans-unit>
        <trans-unit id="c93aea3a25070916d94552b3271d6e2cb60ffbf1" translate="yes" xml:space="preserve">
          <source>Core URI query parameters</source>
          <target state="translated">핵심 URI 쿼리 매개 변수</target>
        </trans-unit>
        <trans-unit id="48e09e45c570a5fc20d51a90faf1c88a9a965b16" translate="yes" xml:space="preserve">
          <source>Correct</source>
          <target state="translated">Correct</target>
        </trans-unit>
        <trans-unit id="ab43f5950b771276d5096eea017224ae40627bd3" translate="yes" xml:space="preserve">
          <source>Correct affinity computations for a SELECT on the RHS of an IN operator. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c&lt;/a&gt;.</source>
          <target state="translated">IN 연산자의 RHS에서 SELECT에 대한 올바른 선호도 계산 티켓 &lt;a href=&quot;https://sqlite.org/src/info/199df4168c&quot;&gt;199df4168c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="0a9b4eee2570183dd2ddac6a6366a16f57f34e60" translate="yes" xml:space="preserve">
          <source>Correct column meta-information returned for aggregate queries</source>
          <target state="translated">집계 쿼리에 대해 올바른 열 메타 정보가 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="27273ddb3178ccf762d7085c22704a1fb0549237" translate="yes" xml:space="preserve">
          <source>Correct handling of columns with redundant unique indexes when those columns are used on the LHS of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 LHS에서 해당 열을 사용할 때 중복 고유 인덱스가있는 열을 올바르게 처리 합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/0eab1ac759&quot;&gt;0eab1ac759에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="cfd7a02e00c8b2f225f8799044d14f56f7302d29" translate="yes" xml:space="preserve">
          <source>Correct handling of integers in SQL expressions that are larger than what can be represented by the machine integer.</source>
          <target state="translated">SQL 표현식에서 기계 정수로 표시 할 수있는 것보다 큰 정수를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cd691a2e765f41b11a9cf96cd3df086682295d23" translate="yes" xml:space="preserve">
          <source>Correct miscounts in the sqlite3_analyzer.exe utility related to WITHOUT ROWID tables.</source>
          <target state="translated">WITHOUT ROWID 테이블과 관련된 sqlite3_analyzer.exe 유틸리티의 잘못된 수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfdca133fa3a4141a30355604a149499e687b80" translate="yes" xml:space="preserve">
          <source>Correctly compute a LEFT OUTER JOINs that is constrained on the left table only</source>
          <target state="translated">왼쪽 테이블에만 제한되는 LEFT OUTER JOIN을 올바르게 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ad24fffac831d94ed1f6d73e123b29057262887e" translate="yes" xml:space="preserve">
          <source>Correctly handle NULL filenames in ATTACH and DETACH</source>
          <target state="translated">ATTACH 및 DETACH에서 NULL 파일 이름을 올바르게 처리</target>
        </trans-unit>
        <trans-unit id="f488953bdefc614e6154ab271713b957ab57b302" translate="yes" xml:space="preserve">
          <source>Correctly handle comparisons between an INTEGER PRIMARY KEY and a floating point number.</source>
          <target state="translated">정수 PRIMARY KEY와 부동 소수점 숫자 간의 비교를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="35c4ec0c87f0e558ee367fb68087e03066aab5fb" translate="yes" xml:space="preserve">
          <source>Correctly handle quoted names in CREATE INDEX statements.</source>
          <target state="translated">CREATE INDEX 문에서 인용 된 이름을 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="352dc237e245240eb4ea083bad4ff8dfb11f6950" translate="yes" xml:space="preserve">
          <source>Correctly handle the integer literal -0x8000000000000000 in the query planner.</source>
          <target state="translated">쿼리 플래너에서 정수 리터럴 -0x8000000000000000을 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="88e07d9ff26fe66b408e72d9ac5048ccb06e2c58" translate="yes" xml:space="preserve">
          <source>Correctly interpret negative &quot;PRAGMA cache_size&quot; values when determining the cache size used for sorting large amounts of data.</source>
          <target state="translated">많은 양의 데이터를 정렬하는 데 사용되는 캐시 크기를 결정할 때 음수 &quot;PRAGMA cache_size&quot;값을 올바르게 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="ee9849f5daa0323fb5d424718df3f8368eafb771" translate="yes" xml:space="preserve">
          <source>Correlated Subqueries</source>
          <target state="translated">상관 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="f13b587e5391fe217559af3492527b67d6307d3d" translate="yes" xml:space="preserve">
          <source>Correlated subqueries</source>
          <target state="translated">상관 서브 쿼리</target>
        </trans-unit>
        <trans-unit id="44355aa8b49da824d97a083ad2a8a3860b7b6f30" translate="yes" xml:space="preserve">
          <source>Corresponds to a puzzle like this:</source>
          <target state="translated">다음과 같은 퍼즐에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9de7bd4ef28516474c07432e4cafa11ec15920ae" translate="yes" xml:space="preserve">
          <source>Corruption to the underlying SQLite database file. (See documentation on &lt;a href=&quot;howtocorrupt&quot;&gt;how to corrupt&lt;/a&gt; and SQLite database for additional information.)</source>
          <target state="translated">기본 SQLite 데이터베이스 파일이 손상되었습니다. 추가 정보는 데이터베이스 &lt;a href=&quot;howtocorrupt&quot;&gt;손상&lt;/a&gt; 및 SQLite 데이터베이스에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="0939fecded0f0c9d546d71641c3908e28d8f44d4" translate="yes" xml:space="preserve">
          <source>Count The Number Of Rows Modified</source>
          <target state="translated">수정 된 행 수 계산</target>
        </trans-unit>
        <trans-unit id="2b8bef37451c2cbce07a23488203e5542d9f4dd1" translate="yes" xml:space="preserve">
          <source>Count the number of CPU cycles consumed using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind를&lt;/a&gt; 사용하여 소비 된 CPU주기 수를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="49d2ca2c89047e9021ce54796bb5abdb2fd3bc0c" translate="yes" xml:space="preserve">
          <source>Countless bug fixes</source>
          <target state="translated">수많은 버그 수정</target>
        </trans-unit>
        <trans-unit id="00252cf377dd27368f8326fbe29b91bd69acc82e" translate="yes" xml:space="preserve">
          <source>Countless minor bug fixes, documentation improvements, new and improved test cases, and code simplifications and cleanups.</source>
          <target state="translated">수많은 사소한 버그 수정, 문서 개선, 새롭고 개선 된 테스트 사례, 코드 단순화 및 정리.</target>
        </trans-unit>
        <trans-unit id="30106347ab7dfc885850c282c1789d99c22c045f" translate="yes" xml:space="preserve">
          <source>Coverage Testing</source>
          <target state="translated">적용 범위 테스트</target>
        </trans-unit>
        <trans-unit id="1c7ccdf4836b4b91d53aaf066e241e1e63bcb54a" translate="yes" xml:space="preserve">
          <source>Covering indexes</source>
          <target state="translated">커버링 인덱스</target>
        </trans-unit>
        <trans-unit id="cf43e93921ba031c40cac261f4d24c6115ca0a3e" translate="yes" xml:space="preserve">
          <source>Covering indices</source>
          <target state="translated">취재 지수</target>
        </trans-unit>
        <trans-unit id="ba58feb4df54a21eed20b23d82daa39d2f414cf2" translate="yes" xml:space="preserve">
          <source>Crash and power loss tests</source>
          <target state="translated">충돌 및 전력 손실 테스트</target>
        </trans-unit>
        <trans-unit id="d1e3f610852d10da5d8935701b8e1938e2ea49d4" translate="yes" xml:space="preserve">
          <source>Crash testing seeks to demonstrate that an SQLite database will not go corrupt if the application or operating system crashes or if there is a power failure in the middle of a database update. A separate white-paper titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit in SQLite&lt;/a&gt; describes the defensive measure SQLite takes to prevent database corruption following a crash. Crash tests strive to verify that those defensive measures are working correctly.</source>
          <target state="translated">충돌 테스트는 응용 프로그램이나 운영 체제가 충돌하거나 데이터베이스 업데이트 도중 정전이 발생해도 SQLite 데이터베이스가 손상되지 않는지 보여줍니다. &lt;a href=&quot;atomiccommit&quot;&gt;SQLite의 Atomic Commit&lt;/a&gt; 이라는 제목의 별도 백서 에서는 충돌 후 데이터베이스 손상을 방지하기 위해 SQLite가 취하는 방어 조치에 대해 설명합니다. 충돌 테스트는 이러한 방어 조치가 올바르게 작동하는지 확인하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="a6531b5d9a390a38e977f855630c550e6d918ac6" translate="yes" xml:space="preserve">
          <source>Crash tests in SQLite use a modified VFS that can simulate the kinds of filesystem damage that occur during a power loss or operating system crash. The crash-test VFS can simulate incomplete sector writes, pages filled with garbage data because a write has not completed, and out of order writes, all occurring at varying points during a test scenario. Crash tests execute transactions over and over, varying the time at which a simulated power loss occurs and the properties of the damage inflicted. Each test then reopens the database after the simulated crash and verifies that the transaction either occurred completely or not at all and that the database is in a completely consistent state.</source>
          <target state="translated">SQLite의 충돌 테스트는 전원 손실 또는 운영 체제 충돌 중에 발생하는 파일 시스템 손상을 시뮬레이션 할 수있는 수정 된 VFS를 사용합니다. 충돌 테스트 VFS는 불완전한 섹터 쓰기, 쓰기가 완료되지 않았기 때문에 가비지 데이터로 채워진 페이지 및 비 순차 쓰기가 모두 테스트 시나리오 동안 다양한 시점에서 발생하는 것을 시뮬레이션 할 수 있습니다. 충돌 테스트는 시뮬레이션 된 전력 손실이 발생하는 시간과 손상의 속성에 따라 다양한 트랜잭션을 반복해서 실행합니다. 그런 다음 각 테스트는 시뮬레이션 충돌 후 데이터베이스를 다시 열고 트랜잭션이 완전히 발생했는지 또는 전혀 발생하지 않았으며 데이터베이스가 완전히 일관된 상태인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b3391e1c037afbc39bd6f7690619a52ba958e865" translate="yes" xml:space="preserve">
          <source>Crash when calling undocumented SQL function sqlite_rename_parent() with NULL parameters. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</source>
          <target state="translated">NULL 매개 변수를 사용하여 문서화되지 않은 SQL 함수 sqlite_rename_parent ()를 호출 할 때 충돌이 발생합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/264b970c4379fd&quot;&gt;264b970c43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbedd1aa577cfa78e4159988e6015e4a622476e7" translate="yes" xml:space="preserve">
          <source>Create A New Changegroup Object</source>
          <target state="translated">새로운 변경 그룹 객체 생성</target>
        </trans-unit>
        <trans-unit id="0eb8a02be6b191c11fc9bb259dafebba87dc4f53" translate="yes" xml:space="preserve">
          <source>Create A New Database</source>
          <target state="translated">새로운 데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="49b9f541df9267a1e81a2e1318c39164b9049cf8" translate="yes" xml:space="preserve">
          <source>Create A New Dynamic String Object</source>
          <target state="translated">새로운 동적 문자열 객체 생성</target>
        </trans-unit>
        <trans-unit id="b6fb0a01eeb8fbfa08db1af0e99f321400dca595" translate="yes" xml:space="preserve">
          <source>Create A New Session Object</source>
          <target state="translated">새로운 세션 객체 생성</target>
        </trans-unit>
        <trans-unit id="b8c295ec5c8d9e2d803be8b00c7291210939416a" translate="yes" xml:space="preserve">
          <source>Create An Iterator To Traverse A Changeset</source>
          <target state="translated">변경 세트를 순회하는 반복자 작성</target>
        </trans-unit>
        <trans-unit id="f738b7c71ee4fcfa212cb684acc179c459d0f67c" translate="yes" xml:space="preserve">
          <source>Create Or Redefine SQL Functions</source>
          <target state="translated">SQL 함수 작성 또는 재정의</target>
        </trans-unit>
        <trans-unit id="fd00ea9a768424e224cb5c7effdeb94d4b4041fe" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9c0f9f8f5c2a818fac05ebd0144409b195c2755" translate="yes" xml:space="preserve">
          <source>Create a Makefile as described in &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일하는 방법에&lt;/a&gt; 설명 된대로 Makefile을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="340fd5cb0d944699f9f2262601f8e8515f6277c0" translate="yes" xml:space="preserve">
          <source>Create a background thread to perform write operations and call sqlite3async_run().</source>
          <target state="translated">쓰기 작업을 수행하고 sqlite3async_run ()을 호출 할 백그라운드 스레드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="af7db7815d1cb1d51e5af0cd7f358563250421b6" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 저 객체 생성</target>
        </trans-unit>
        <trans-unit id="08a7eb180eb01b1b848907571f8cab91fa3fadc5" translate="yes" xml:space="preserve">
          <source>Create a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="43d32b083ccd73d48458a8a788df239ec0749647" translate="yes" xml:space="preserve">
          <source>Create a fossil repository to host the private branch using the following command:</source>
          <target state="translated">다음 명령을 사용하여 개인 브랜치를 호스팅 할 화석 저장소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="020976ba5dc8b4a36c10d54c801ec1a4a89f48ac" translate="yes" xml:space="preserve">
          <source>Create a master-journal. The name of the master-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the master journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">마스터 저널을 작성하십시오. 마스터 저널의 이름은 임의적입니다. (현재 구현에서는 이전에 존재하지 않는 이름을 찾을 때까지 기본 데이터베이스 파일 이름에 임의의 접미 부를 추가합니다.) 모든 개별 저널의 이름으로 마스터 저널을 채우고 해당 컨텐츠를 디스크로 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="da3af537bba9d7121766b2210dfaab8be2fac3f3" translate="yes" xml:space="preserve">
          <source>Create a new archive containing specified files.</source>
          <target state="translated">지정된 파일을 포함하는 새 아카이브를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="afef83edf1b36bb49d450af9b70529ceb53e63d8" translate="yes" xml:space="preserve">
          <source>Create a new archive, overwriting any existing archive (either in the current &quot;main&quot; db or in the file specified by a --file option). Each argument following the options is a file to add to the archive. Directories are imported recursively. See above for examples.</source>
          <target state="translated">기존 아카이브를 덮어 쓰면서 새 아카이브를 만듭니다 (현재 &quot;main&quot;db 또는 --file 옵션으로 지정된 파일에 있음). 옵션 뒤에 오는 각 인수는 아카이브에 추가 할 파일입니다. 디렉토리는 재귀 적으로 가져옵니다. 예는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c399fd2512bbe2d0e4a05efd898526951d10b8a" translate="yes" xml:space="preserve">
          <source>Create a new session object attached to database handle db. If successful, a pointer to the new object is written to *ppSession and SQLITE_OK is returned. If an error occurs, *ppSession is set to NULL and an SQLite error code (e.g. SQLITE_NOMEM) is returned.</source>
          <target state="translated">데이터베이스 핸들 db에 첨부 된 새 세션 오브젝트를 작성하십시오. 성공하면 새 오브젝트에 대한 포인터가 * ppSession에 기록되고 SQLITE_OK가 리턴됩니다. 오류가 발생하면 * ppSession이 NULL로 설정되고 SQLite 오류 코드 (예 : SQLITE_NOMEM)가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef7c8e6020507b3b903b737530a1a743ade6fb2" translate="yes" xml:space="preserve">
          <source>Create a partial index by adding a WHERE clause to the end of an ordinary &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">일반 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문의 끝에 WHERE 절을 추가하여 부분 색인을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="7044aef02f57d684bf1ace2c33f2aa3769b845ad" translate="yes" xml:space="preserve">
          <source>Create a static and constant &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object containing pointers to the methods from the previous step.</source>
          <target state="translated">이전 단계의 메소드에 대한 포인터를 포함 하는 정적 및 상수 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="9927b43b64a34cad4b966d3687a6725b0b51be8b" translate="yes" xml:space="preserve">
          <source>Create a super-journal. The name of the super-journal is arbitrary. (The current implementation appends random suffixes to the name of the main database file until it finds a name that does not previously exist.) Fill the super-journal with the names of all the individual journals and flush its contents to disk.</source>
          <target state="translated">슈퍼 저널을 만드세요. 슈퍼 저널의 이름은 임의적입니다. (현재 구현에서는 이전에 존재하지 않는 이름을 찾을 때까지 기본 데이터베이스 파일의 이름에 임의의 접미사를 추가합니다.) 모든 개별 저널의 이름으로 수퍼 저널을 채우고 그 내용을 디스크에 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="ce77c2b32feacc25a54f9d8046773c75cc6d0f0f" translate="yes" xml:space="preserve">
          <source>Create an instance of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure containing pointers to all the methods from step 1.</source>
          <target state="translated">1 단계의 모든 메소드에 대한 포인터를 포함 하는 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조 의 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a8ad313a3f6f92e33200837c1d1b7d9a66475fb" translate="yes" xml:space="preserve">
          <source>Create an iterator used to iterate through the contents of a changeset. If successful, *pp is set to point to the iterator handle and SQLITE_OK is returned. Otherwise, if an error occurs, *pp is set to zero and an SQLite error code is returned.</source>
          <target state="translated">변경 세트의 내용을 반복하는 데 사용되는 반복자를 작성하십시오. 성공하면 * pp가 반복자 핸들을 가리 키도록 설정되고 SQLITE_OK가 리턴됩니다. 그렇지 않으면 오류가 발생하면 * pp가 0으로 설정되고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="68f3d9400dc4770bb7d1f485473e1cabff22fc1f" translate="yes" xml:space="preserve">
          <source>Create and Destroy VFS Filenames</source>
          <target state="translated">VFS 파일 이름 생성 및 삭제</target>
        </trans-unit>
        <trans-unit id="f282c6f0dcaa864a9b91c1b0857728fb4f3b6cf7" translate="yes" xml:space="preserve">
          <source>Create if does not exist?</source>
          <target state="translated">존재하지 않는 경우 생성 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="a6746bd3f5b981be1960788a63b361beb206e80d" translate="yes" xml:space="preserve">
          <source>Create new table</source>
          <target state="translated">새 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="552737e86fdab069e1553393c32b2d735d03da2b" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 사용하여 준비된 명령문 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3aaf4f3bc8aa8975fba3c24e7982e7ad410e2d3" translate="yes" xml:space="preserve">
          <source>Create the prepared statement object using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 사용하여 준비된 명령문 오브젝트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6cd0fb8dc0636107f3c2eeec94775a363db607d" translate="yes" xml:space="preserve">
          <source>CreateBtree</source>
          <target state="translated">CreateBtree</target>
        </trans-unit>
        <trans-unit id="f6d526ccd323387bacc30fe97239e7bfe08e6f7e" translate="yes" xml:space="preserve">
          <source>Created a new mutex subsystem and made it replicable at compile-time.</source>
          <target state="translated">새로운 mutex 서브 시스템을 작성하고 컴파일시 복제 할 수있게했습니다.</target>
        </trans-unit>
        <trans-unit id="015db039081a96e714bbc870bb70163882fcd0ef" translate="yes" xml:space="preserve">
          <source>Created the &lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; command-line utility.</source>
          <target state="translated">&lt;a href=&quot;dbhash&quot;&gt;dbhash.exe&lt;/a&gt; 명령 행 유틸리티를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="acf789d2331ea2a8bf5399f72dadd8b178eecbe4" translate="yes" xml:space="preserve">
          <source>Creation of a transient imposter table involves a special &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; call. Unlike all other SQLite APIs, &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface is subject to incompatible changes from one release to the next, and so the mechanism described below is not guaranteed to work in future releases of SQLite. The SQLite developers do not consider this a problem because imposter tables should not be used in applications. Imposter tables are for analysis and testing use only.</source>
          <target state="translated">임시 임 포스터 테이블 작성에는 특수 &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 호출이 포함됩니다. 다른 모든 SQLite API와 달리 &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스는 한 릴리스에서 다음 릴리스로 호환되지 않는 변경 사항이 적용되므로 아래에 설명 된 메커니즘이 향후 SQLite 릴리스에서 작동하지 않을 수 있습니다. SQLite 개발자는 임 포스터 테이블을 응용 프로그램에서 사용해서는 안되므로이 문제를 문제로 간주하지 않습니다. 임 포스터 테이블은 분석 및 테스트 용도로만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="f3072cfe38995c94aede1e379bdbc87872e32b2e" translate="yes" xml:space="preserve">
          <source>Cross-Platform</source>
          <target state="translated">Cross-Platform</target>
        </trans-unit>
        <trans-unit id="a84c73487927d0c8de6b6f553d91f81e8f3c67ef" translate="yes" xml:space="preserve">
          <source>Cross-platform: Android, *BSD, iOS, Linux, Mac, Solaris, VxWorks, and Windows (Win32, WinCE, WinRT) are supported out of the box. Easy to port to other systems.</source>
          <target state="translated">크로스 플랫폼 : Android, * BSD, iOS, Linux, Mac, Solaris, VxWorks 및 Windows (Win32, WinCE, WinRT)가 기본적으로 지원됩니다. 다른 시스템으로 쉽게 포팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe50f9415f0538595ee673bee95f6e9b7af30913" translate="yes" xml:space="preserve">
          <source>Currently the asynchronous IO extension is compatible with win32 systems and systems that support the pthreads interface, including Mac OS X, Linux, and other varieties of Unix.</source>
          <target state="translated">현재 비동기 IO 확장은 Mac OS X, Linux 및 기타 다양한 Unix를 포함하여 pthreads 인터페이스를 지원하는 win32 시스템 및 시스템과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="5527dcef9928e4b30b2e113bf906b6aad70626b4" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 contains any NULL value, jump immediately to P2. If all terms of the record are not-NULL then a check is done to determine if any row in the P1 index btree has a matching key prefix. If there are no matches, jump immediately to P2. If there is a match, fall through and leave the P1 cursor pointing to the matching row.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드에 NULL 값이 있으면 즉시 P2로 이동하십시오. 레코드의 모든 용어가 NULL이 아닌 경우 P1 인덱스 btree의 행에 일치하는 키 접두사가 있는지 확인하기 위해 검사가 수행됩니다. 일치하는 항목이 없으면 즉시 P2로 이동하십시오. 일치하는 것이 있으면 넘어져서 P1 커서가 일치하는 행을 가리 키도록 둡니다.</target>
        </trans-unit>
        <trans-unit id="d32c868a8066f0bb0c8cbc2fdacd1dcc4df55aff" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is a prefix of any entry in P1 then a jump is made to P2 and P1 is left pointing at the matching entry.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드가 P1의 항목 접 두부 인 경우 P2로 점프하고 P1은 일치하는 항목을 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4499a408e8cf9ba0a64b6a7abae32a3e8598a9c" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the record identified by P3 and P4 is not the prefix of any entry in P1 then a jump is made to P2. If P1 does contain an entry whose prefix matches the P3/P4 record then control falls through to the next instruction and P1 is left pointing at the matching entry.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. P3 및 P4로 식별 된 레코드가 P1의 항목 접 두부가 아닌 경우 P2로 이동합니다. P1에 접두사가 P3 / P4 레코드와 일치하는 항목이 포함 된 경우 제어는 다음 명령어로 넘어 가고 P1은 일치하는 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="cce417cb09cb0e87ed39f345b9827448814078c5" translate="yes" xml:space="preserve">
          <source>Cursor P1 is on an index btree. If the seekHit flag is set on P1, then this opcode is a no-op. But if the seekHit flag of P1 is clear, then check to see if there is any entry in P1 that matches the prefix identified by P3 and P4. If no entry matches the prefix, jump to P2. Otherwise fall through.</source>
          <target state="translated">커서 P1은 인덱스 btree에 있습니다. seekHit 플래그가 P1에 설정된 경우이 opcode는 작동하지 않습니다. 그러나 P1의 seekHit 플래그가 명확한 경우 P1에 P3 및 P4로 식별 된 접 두부와 일치하는 항목이 있는지 확인하십시오. 접두사와 일치하는 항목이 없으면 P2로 이동하십시오. 그렇지 않으면 넘어집니다.</target>
        </trans-unit>
        <trans-unit id="22ec5d401662b5703126ca0123e136b6c810e79d" translate="yes" xml:space="preserve">
          <source>CursorHint</source>
          <target state="translated">CursorHint</target>
        </trans-unit>
        <trans-unit id="f164c696c942f1b7ba36a19ad9dc745042621e3b" translate="yes" xml:space="preserve">
          <source>CursorLock</source>
          <target state="translated">CursorLock</target>
        </trans-unit>
        <trans-unit id="a11839ff842a324c26003221096de9b6e7ceaccd" translate="yes" xml:space="preserve">
          <source>CursorUnlock</source>
          <target state="translated">CursorUnlock</target>
        </trans-unit>
        <trans-unit id="836bce7485bd48ef5bf35926e3fb08781cfcdae7" translate="yes" xml:space="preserve">
          <source>Custom Builds Of SQLite</source>
          <target state="translated">SQLite의 커스텀 빌드</target>
        </trans-unit>
        <trans-unit id="dfcc51a98311f46893672f2fb6d173d44d66fc77" translate="yes" xml:space="preserve">
          <source>Custom Page Cache Object</source>
          <target state="translated">맞춤 페이지 캐시 객체</target>
        </trans-unit>
        <trans-unit id="076c8e2f21c1b5d23882403c8926d30c1101585d" translate="yes" xml:space="preserve">
          <source>Custom auxiliary functions</source>
          <target state="translated">맞춤형 보조 기능</target>
        </trans-unit>
        <trans-unit id="c77373601428abf208eee7bad389ec98739fcb31" translate="yes" xml:space="preserve">
          <source>Custom r-tree queries</source>
          <target state="translated">사용자 정의 r- 트리 쿼리</target>
        </trans-unit>
        <trans-unit id="7057308b175a54061ae194ee69576ebf4bb75f55" translate="yes" xml:space="preserve">
          <source>Custom tokenizers</source>
          <target state="translated">맞춤형 토크 나이저</target>
        </trans-unit>
        <trans-unit id="c9cb8f8539741bdce4da7c0edbda58f7c8a5bb30" translate="yes" xml:space="preserve">
          <source>Custom tokenizers may also support synonyms. Consider a case in which a user wishes to query for a phrase such as &quot;first place&quot;. Using the built-in tokenizers, the FTS5 query 'first + place' will match instances of &quot;first place&quot; within the document set, but not alternative forms such as &quot;1st place&quot;. In some applications, it would be better to match all instances of &quot;first place&quot; or &quot;1st place&quot; regardless of which form the user specified in the MATCH query text.</source>
          <target state="translated">맞춤형 토크 나이 저는 동의어를 지원할 수도 있습니다. 사용자가 &quot;1 등&quot;과 같은 문구를 쿼리하려는 경우를 고려하십시오. 내장 된 토크 나이저를 사용하면 FTS5 쿼리 'first + place'는 문서 세트 내의 &quot;first place&quot;인스턴스와 일치하지만 &quot;1st place&quot;와 같은 대체 형식은 아닙니다. 일부 응용 프로그램에서는 사용자가 MATCH 쿼리 텍스트에 지정된 형식에 관계없이 &quot;1 위&quot;또는 &quot;1 위&quot;의 모든 인스턴스를 일치시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd763a855efd9c913568b8cd20dab17c4af423" translate="yes" xml:space="preserve">
          <source>Cut over configuration management to a new CVS repository with its own CVSTrac bug tracking system.</source>
          <target state="translated">자체 CVSTrac 버그 추적 시스템을 사용하여 구성 관리를 새로운 CVS 저장소로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="fd5aaa888331e7fdbb9873b0f3118383cbd0f6f2" translate="yes" xml:space="preserve">
          <source>Cut-over to the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; for faster and better query plans.</source>
          <target state="translated">컷 오버에 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 빠르고 더 나은 쿼리 계획에 대한.</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="339588e68f8e2dd5f57cc156ab01c5b4dcaa9da0" translate="yes" xml:space="preserve">
          <source>DATABASE</source>
          <target state="translated">DATABASE</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="6e915cae90d2c29f2358559dc05c3df58595f55d" translate="yes" xml:space="preserve">
          <source>DATETIME</source>
          <target state="translated">DATETIME</target>
        </trans-unit>
        <trans-unit id="e37624f858dc2af6156398ee78609c8c3c886ca3" translate="yes" xml:space="preserve">
          <source>DB2</source>
          <target state="translated">DB2</target>
        </trans-unit>
        <trans-unit id="645f10d83e7588e1eb33d0d2939905688a530e61" translate="yes" xml:space="preserve">
          <source>DB2, SQL Anywhere, and Borland Interbase do not allow NULLs in a UNIQUE column.</source>
          <target state="translated">DB2, SQL Anywhere 및 Borland Interbase는 UNIQUE 열에서 NULL을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbdd0b7d0c739234955599c5455d354e4fae19b3" translate="yes" xml:space="preserve">
          <source>DDDDDDDDDD</source>
          <target state="translated">DDDDDDDDDD</target>
        </trans-unit>
        <trans-unit id="3a98757f7ab109581d6b2954839e6421cda4bacd" translate="yes" xml:space="preserve">
          <source>DECIMAL(10,5)</source>
          <target state="translated">DECIMAL(10,5)</target>
        </trans-unit>
        <trans-unit id="c189207a55da45305c884fe2b50e086fcad4724b" translate="yes" xml:space="preserve">
          <source>DEFAULT</source>
          <target state="translated">DEFAULT</target>
        </trans-unit>
        <trans-unit id="b79011ba88d8043cebb3f51bd20a68d85873c9ee" translate="yes" xml:space="preserve">
          <source>DEFAULT VALUES&quot; form of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement is not supported.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문의 DEFAULT VALUES &quot;형식은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb9fe9e9d3e08f670bce95fe32d00c47dbc6b299" translate="yes" xml:space="preserve">
          <source>DEFERRABLE</source>
          <target state="translated">DEFERRABLE</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="6bdd4912d7dc55fbe1d47cc1e7b6480731d73ff0" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERRED는 데이터베이스에 처음 액세스 할 때까지 트랜잭션이 실제로 시작되지 않음을 의미합니다. 내부적으로 BEGIN DEFERRED 문은 마지막 문이 완료 될 때 일반적으로 발생하는 자동 커밋을 해제하는 플래그를 데이터베이스 연결에 설정하기 만합니다. 이로 인해 자동으로 시작된 트랜잭션은 명시 적 COMMIT 또는 ROLLBACK까지 또는 오류 또는 ON CONFLICT ROLLBACK 절에 의해 롤백이 발생할 때까지 지속됩니다. BEGIN DEFERRED 뒤의 첫 번째 명령문이 SELECT이면 읽기 트랜잭션이 시작됩니다. 후속 쓰기 문은 가능한 경우 트랜잭션을 쓰기 트랜잭션으로 업그레이드하거나 SQLITE_BUSY를 반환합니다. BEGIN DEFERRED 다음의 첫 번째 문이 쓰기 문이면 쓰기 트랜잭션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0190695366a57cfee9ace793fdb8c89b47bb42" translate="yes" xml:space="preserve">
          <source>DEFERRED means that the transaction does not actually start until the database is first accessed. Internally, the BEGIN DEFERRRED statement merely sets a flag on the database connection that turns off the automatic commit that would normally occur when the last statement finishes. This causes the transaction that is automatically started to persist until an explicit COMMIT or ROLLBACK or until a rollback is provoked by an error or an ON CONFLICT ROLLBACK clause. If the first statement after BEGIN DEFERRED is a SELECT, then a read transaction is started. Subsequent write statements will upgrade the transaction to a write transaction if possible, or return SQLITE_BUSY. If the first statement after BEGIN DEFERRED is a write statement, then a write transaction is started.</source>
          <target state="translated">DEFERRED는 데이터베이스에 처음 액세스 할 때까지 트랜잭션이 실제로 시작되지 않음을 의미합니다. 내부적으로 BEGIN DEFERRRED 문은 데이터베이스 연결에서 마지막 명령문이 완료 될 때 일반적으로 발생하는 자동 커밋을 끄는 플래그를 설정하기 만합니다. 이로 인해 명시 적 COMMIT 또는 ROLLBACK까지 또는 오류 또는 ON CONFLICT ROLLBACK 절에 의해 롤백이 발생할 때까지 자동으로 시작된 트랜잭션이 발생합니다. BEGIN DEFERRED 다음의 첫 번째 명령문이 SELECT이면 읽기 트랜잭션이 시작됩니다. 후속 쓰기 명령문은 가능하면 트랜잭션을 쓰기 트랜잭션으로 업그레이드하거나 SQLITE_BUSY를 리턴합니다. BEGIN DEFERRED 다음의 첫 번째 명령문이 쓰기 명령문 인 경우 쓰기 트랜잭션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c44f0fc249bf9f56573cce35739bdbf358753ec9" translate="yes" xml:space="preserve">
          <source>DEFERRED, IMMEDIATE, and EXCLUSIVE transactions</source>
          <target state="translated">지연, 즉시 및 독점 거래</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="ddf5a8b95a67a245ead92340f3a1d492b967db1c" translate="yes" xml:space="preserve">
          <source>DELETE Changes</source>
          <target state="translated">변경 사항 삭제</target>
        </trans-unit>
        <trans-unit id="6d2d8ff5f66968f5a9016744e065d7b055778fa4" translate="yes" xml:space="preserve">
          <source>DELETE FROM t1;</source>
          <target state="translated">t1에서 삭제;</target>
        </trans-unit>
        <trans-unit id="ee62fe04ef6c5b85e13e87e697e2bed7ca49475c" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE a&amp;gt;10 AND a&amp;lt;20000;</source>
          <target state="translated">a&amp;gt; 10 및 a &amp;lt;20000 인 t2로부터 삭제;</target>
        </trans-unit>
        <trans-unit id="a5ebf9c0b02aa24303cdb7fb5cf5371c628bba2a" translate="yes" xml:space="preserve">
          <source>DELETE FROM t2 WHERE c LIKE '%fifty%';</source>
          <target state="translated">'% fifty %'와 같은 위치에서 t2에서 삭제;</target>
        </trans-unit>
        <trans-unit id="b4aac6d0cf9ea3a89dec994c5ddb8ad46701ed40" translate="yes" xml:space="preserve">
          <source>DELETE records consist of the primary key fields only. The original values of other fields are omitted.</source>
          <target state="translated">DELETE 레코드는 기본 키 필드로만 구성됩니다. 다른 필드의 원래 값은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="b5093023417eb749513563ec16d8c0c821aa5aff" translate="yes" xml:space="preserve">
          <source>DESC</source>
          <target state="translated">DESC</target>
        </trans-unit>
        <trans-unit id="a26814be2b9a9bc0d8c52b43abfaf6e5c82a51a4" translate="yes" xml:space="preserve">
          <source>DESC indices</source>
          <target state="translated">DESC 지수</target>
        </trans-unit>
        <trans-unit id="c10fec47e3203a12a4865741f863a30dc8d9e348" translate="yes" xml:space="preserve">
          <source>DETACH</source>
          <target state="translated">DETACH</target>
        </trans-unit>
        <trans-unit id="53dda846085ef522df42849d527936da7055a14d" translate="yes" xml:space="preserve">
          <source>DETACH DATABASE</source>
          <target state="translated">세부 데이터베이스</target>
        </trans-unit>
        <trans-unit id="45b1a3f093ba639c208b0bbbbe6cad9eff65396f" translate="yes" xml:space="preserve">
          <source>DISTINCT</source>
          <target state="translated">DISTINCT</target>
        </trans-unit>
        <trans-unit id="3804145294052baefad623cd8cebfa752f431578" translate="yes" xml:space="preserve">
          <source>DISTINCT, ORDER BY, GROUP BY, HAVING, LIMIT, and OFFSET</source>
          <target state="translated">구별, 주문, 그룹 별, HAVING, LIMIT 및 오프셋</target>
        </trans-unit>
        <trans-unit id="8feb29077a1df95bd8e261f267cf55119b1eac74" translate="yes" xml:space="preserve">
          <source>DO</source>
          <target state="translated">DO</target>
        </trans-unit>
        <trans-unit id="9bf5aa462fedb77794614582aa9cb6f368384112" translate="yes" xml:space="preserve">
          <source>DOC - Word Perfect and Microsoft Office documents</source>
          <target state="translated">DOC-Word Perfect 및 Microsoft Office 문서</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="0282a2e2726b5fdbd89b48e12c5edb38b5d2c29e" translate="yes" xml:space="preserve">
          <source>DOUBLE PRECISION</source>
          <target state="translated">더블 정밀</target>
        </trans-unit>
        <trans-unit id="39514a7a66f0433579dbc23ecfbb8c6c3e079395" translate="yes" xml:space="preserve">
          <source>DROP</source>
          <target state="translated">DROP</target>
        </trans-unit>
        <trans-unit id="383ac905b2bc5cb0e45bdf7ad063398c7f4d0280" translate="yes" xml:space="preserve">
          <source>DROP INDEX</source>
          <target state="translated">드롭 인덱스</target>
        </trans-unit>
        <trans-unit id="ac02c0b871c5f0a59ae432b32af6203946972208" translate="yes" xml:space="preserve">
          <source>DROP TABLE</source>
          <target state="translated">드롭 테이블</target>
        </trans-unit>
        <trans-unit id="1627fd06710bbc68919d746def7dc2f189b53feb" translate="yes" xml:space="preserve">
          <source>DROP TABLE t1;</source>
          <target state="translated">DROP TABLE t1;</target>
        </trans-unit>
        <trans-unit id="d1be8c338ef5a7bcca5157c5203b61e7d14d5f12" translate="yes" xml:space="preserve">
          <source>DROP TABLE t2;</source>
          <target state="translated">DROP TABLE t2;</target>
        </trans-unit>
        <trans-unit id="5771355d686a88f9aec56e2304026908b55bffb4" translate="yes" xml:space="preserve">
          <source>DROP TABLE t3;</source>
          <target state="translated">DROP TABLE t3;</target>
        </trans-unit>
        <trans-unit id="fc6194eca24e844585523f3d0e5cb90acd2f1cd1" translate="yes" xml:space="preserve">
          <source>DROP TRIGGER</source>
          <target state="translated">드롭 트리거</target>
        </trans-unit>
        <trans-unit id="6a23d5fa27b31fab3e560233e685dfb52af23fcc" translate="yes" xml:space="preserve">
          <source>DROP VIEW</source>
          <target state="translated">드롭 뷰</target>
        </trans-unit>
        <trans-unit id="6a98041e1291d5c0fcb8031e8dc6b0f10dbdcd21" translate="yes" xml:space="preserve">
          <source>DWG - AutoCAD drawings</source>
          <target state="translated">DWG-AutoCAD 도면</target>
        </trans-unit>
        <trans-unit id="4b5fe1d0668c6a074a9b45de43a0ab7e93ea3537" translate="yes" xml:space="preserve">
          <source>Daily in your prayers, with tears and sighs, confess your past sins to God, and amend them for the future.</source>
          <target state="translated">눈물과 한숨으로 매일기도하며 과거의 죄를 하나님 께 고백하고 미래를 위해 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="352953a16a74f0790135416ee3270f630371240c" translate="yes" xml:space="preserve">
          <source>Data Change Notification Callbacks</source>
          <target state="translated">데이터 변경 알림 콜백</target>
        </trans-unit>
        <trans-unit id="a073b1a4a370adc09bf5c624ac412d5da3300853" translate="yes" xml:space="preserve">
          <source>Data can be inserted into such an FTS4 table using an INSERT statements. However, unlike ordinary FTS4 tables, the user must supply an explicit integer docid value. For example:</source>
          <target state="translated">INSERT 문을 사용하여 이러한 FTS4 테이블에 데이터를 삽입 할 수 있습니다. 그러나 일반 FTS4 테이블과 달리 사용자는 명시 적 정수 도큐 드 값을 제공해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dd6b7f9a7a5a10b73550e3715829adf5933cc29" translate="yes" xml:space="preserve">
          <source>Data dominates. If you've chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</source>
          <target state="translated">데이터가 지배적입니다. 올바른 데이터 구조를 선택하고 체계적으로 정리 한 경우 알고리즘은 거의 항상 자명합니다. 알고리즘이 아닌 데이터 구조는 프로그래밍의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="7765119a34cb37ce325b7908102a741f5f04decc" translate="yes" xml:space="preserve">
          <source>Data format conversions can invalidate the pointer returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16(). Pointers might be invalided in the following cases:</source>
          <target state="translated">데이터 형식 변환은 sqlite3_column_blob (), sqlite3_column_text () 및 / 또는 sqlite3_column_text16 ()에 대한 이전 호출에서 리턴 된 포인터를 무효화 할 수 있습니다. 다음과 같은 경우 포인터가 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f53192d7efb1f452daf4e4ce9588f68c43c7ab" translate="yes" xml:space="preserve">
          <source>Data read while in the process of opening a read-only transaction (see section</source>
          <target state="translated">읽기 전용 트랜잭션을 여는 과정에서 읽은 데이터 (섹션 참조)</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="c0b1a7d66556ee25336c34353c17486dba3e302f" translate="yes" xml:space="preserve">
          <source>Data-types specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create an FTS table are ignored completely. Instead of the normal rules for applying type &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; to inserted values, all values inserted into FTS table columns (except the special rowid column) are converted to type TEXT before being stored.</source>
          <target state="translated">FTS 테이블을 작성하는 데 사용 된 &quot;CREATE VIRTUAL TABLE&quot;문의 일부로 지정된 데이터 유형은 완전히 무시됩니다. 삽입 된 값에 유형 &lt;a href=&quot;datatype3#affinity&quot;&gt;선호도&lt;/a&gt; 를 적용하는 일반적인 규칙 대신 FTS 테이블 열에 삽입 된 모든 값 (특수 rowid 열 제외)은 저장되기 전에 유형 TEXT로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c196bb9b92e16036aa92c8d07d6256ad34cf47b" translate="yes" xml:space="preserve">
          <source>Database Connection Configuration Options</source>
          <target state="translated">데이터베이스 연결 구성 옵션</target>
        </trans-unit>
        <trans-unit id="87ad120a4ba60c79863260e10eca7015248baadd" translate="yes" xml:space="preserve">
          <source>Database Connection For Functions</source>
          <target state="translated">함수를위한 데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="f77d22fb96d5dfa5073b2fe8ffcf8caa0f1f055f" translate="yes" xml:space="preserve">
          <source>Database Connection Handle</source>
          <target state="translated">데이터베이스 연결 핸들</target>
        </trans-unit>
        <trans-unit id="ed913bb076648fca64b8de1c707bbce02bda0945" translate="yes" xml:space="preserve">
          <source>Database Connection Status</source>
          <target state="translated">데이터베이스 연결 상태</target>
        </trans-unit>
        <trans-unit id="d7a15726be6aee139cc047e8d19aae61e2286733" translate="yes" xml:space="preserve">
          <source>Database Connections</source>
          <target state="translated">데이터베이스 연결</target>
        </trans-unit>
        <trans-unit id="3390636be52618dc7d118d178ce5ea03789b0200" translate="yes" xml:space="preserve">
          <source>Database Corruption Warning</source>
          <target state="translated">데이터베이스 손상 경고</target>
        </trans-unit>
        <trans-unit id="89085c43a43d9dcfe7b225f94c340033a3bf8f40" translate="yes" xml:space="preserve">
          <source>Database File Corresponding To A Journal</source>
          <target state="translated">저널에 해당하는 데이터베이스 파일</target>
        </trans-unit>
        <trans-unit id="e9ab5f94bcd6c1898d03a1e6b8469a59f0ed3a77" translate="yes" xml:space="preserve">
          <source>Database File Format</source>
          <target state="translated">데이터베이스 파일 형식</target>
        </trans-unit>
        <trans-unit id="ff50d56bfc81a7b956e4d1921d6d66d7a383a42b" translate="yes" xml:space="preserve">
          <source>Database Header Format</source>
          <target state="translated">데이터베이스 헤더 형식</target>
        </trans-unit>
        <trans-unit id="a3535d6748b55df8651025dc19ca0f9492aecee6" translate="yes" xml:space="preserve">
          <source>Database Object Name Resolution</source>
          <target state="translated">데이터베이스 객체 이름 확인</target>
        </trans-unit>
        <trans-unit id="bd8632f168d3516aef62fc843146b450c3c26a99" translate="yes" xml:space="preserve">
          <source>Database Page Size</source>
          <target state="translated">데이터베이스 페이지 크기</target>
        </trans-unit>
        <trans-unit id="4f02b6e9702df3600e6e312d593f7caa8819e1dd" translate="yes" xml:space="preserve">
          <source>Database Snapshot</source>
          <target state="translated">데이터베이스 스냅 샷</target>
        </trans-unit>
        <trans-unit id="bd1d5e56dd1e83bbe0ee14778f6008e4f92501fb" translate="yes" xml:space="preserve">
          <source>Database Speed Comparison</source>
          <target state="translated">데이터베이스 속도 비교</target>
        </trans-unit>
        <trans-unit id="a8dad839985eddb5586b8b561fd417de9bc6e759" translate="yes" xml:space="preserve">
          <source>Database URI</source>
          <target state="translated">데이터베이스 URI</target>
        </trans-unit>
        <trans-unit id="2d4c00611e1b6734ce538563059febb504705359" translate="yes" xml:space="preserve">
          <source>Database as object</source>
          <target state="translated">객체로서의 데이터베이스</target>
        </trans-unit>
        <trans-unit id="83a5cb19e95dc1d8b5d7e1441d8c579a45d5724b" translate="yes" xml:space="preserve">
          <source>Database cache can be optionally shared between connections in the same thread</source>
          <target state="translated">동일한 캐시의 연결간에 데이터베이스 캐시를 선택적으로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7de38dba43f0a278e3056a00a39519bfc9b665e" translate="yes" xml:space="preserve">
          <source>Database connections can now be used by multiple threads, not just the thread in which they were created.</source>
          <target state="translated">데이터베이스 연결은 이제 작성된 스레드뿐만 아니라 여러 스레드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212efa9f11c5959aadd0fce19cdf94993470615e" translate="yes" xml:space="preserve">
          <source>Database corruption caused by inconsistent use of 8+3 filenames</source>
          <target state="translated">8 + 3 파일 이름의 일관성없는 사용으로 인한 데이터베이스 손상</target>
        </trans-unit>
        <trans-unit id="053ad514468635665438176cd86a58d603813544" translate="yes" xml:space="preserve">
          <source>Database filename aliasing</source>
          <target state="translated">데이터베이스 파일 이름 별칭</target>
        </trans-unit>
        <trans-unit id="3b7f204e04933e97d6ac68630583c1313b9cb271" translate="yes" xml:space="preserve">
          <source>Database files can now grow to be up to 2^41 bytes. The old limit was 2^31 bytes.</source>
          <target state="translated">데이터베이스 파일은 이제 최대 2 ^ 41 바이트로 증가 할 수 있습니다. 이전 제한은 2 ^ 31 바이트였습니다.</target>
        </trans-unit>
        <trans-unit id="73a52851158627ec8f4a087842d9a7bc471fcd2f" translate="yes" xml:space="preserve">
          <source>Database files that contain partial indices are not readable or writable by versions of SQLite prior to 3.8.0. However, a database file created by SQLite 3.8.0 is still readable and writable by prior versions as long as its schema contains no partial indexes. A database that is unreadable by legacy versions of SQLite can be made readable simply by running &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; on the partial indexes.</source>
          <target state="translated">부분 인덱스가 포함 된 데이터베이스 파일은 3.8.0 이전의 SQLite 버전에서 읽거나 쓸 수 없습니다. 그러나 스키마에 부분 인덱스가없는 한 SQLite 3.8.0으로 작성된 데이터베이스 파일은 여전히 ​​이전 버전에서 읽고 쓸 수 있습니다. 레거시 버전의 SQLite에서 읽을 수없는 데이터베이스 는 부분 인덱스 에서 &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; 를 실행하여 간단히 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78486fa6ae30389540b15aab7739d7ecbc3140a" translate="yes" xml:space="preserve">
          <source>Database header</source>
          <target state="translated">데이터베이스 헤더</target>
        </trans-unit>
        <trans-unit id="d8a9d9190c53a37330666f4da1d52eb4d5397265" translate="yes" xml:space="preserve">
          <source>Database locks obtained by a connection in EXCLUSIVE mode may be released either by closing the database connection, or by setting the locking-mode back to NORMAL using this pragma and then accessing the database file (for read or write). Simply setting the locking-mode to NORMAL is not enough - locks are not released until the next time the database file is accessed.</source>
          <target state="translated">EXCLUSIVE 모드에서 연결하여 얻은 데이터베이스 잠금은 데이터베이스 연결을 닫거나이 pragma를 사용하여 잠금 모드를 다시 NORMAL로 설정 한 다음 데이터베이스 파일에 액세스하여 (읽기 또는 쓰기) 해제 할 수 있습니다. 잠금 모드를 NORMAL로 설정하는 것만으로는 충분하지 않습니다. 다음에 데이터베이스 파일에 액세스 할 때까지 잠금이 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9118c7b06bcc534b6f4c486616838692892faa73" translate="yes" xml:space="preserve">
          <source>Database page size. Example: 1024</source>
          <target state="translated">데이터베이스 페이지 크기 예 : 1024</target>
        </trans-unit>
        <trans-unit id="19e5379d75e917575fd8db9bff227b50947f62a7" translate="yes" xml:space="preserve">
          <source>Database read and write operations, and the way in which they interact with and use the</source>
          <target state="translated">데이터베이스 읽기 및 쓰기 작업과 작업 방식 및 작업 방식</target>
        </trans-unit>
        <trans-unit id="c8a8e97f4d032178ae62a7d1cf0df7f938947c9e" translate="yes" xml:space="preserve">
          <source>Database zDb does not exist,</source>
          <target state="translated">데이터베이스 zDb가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="684ece0a836446078b844add11528674b80daff5" translate="yes" xml:space="preserve">
          <source>Databases are opened using &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; when the --append flag is used on the command line or with the .open command.</source>
          <target state="translated">명령 행에서 --append 플래그를 사용하거나 .open 명령을 사용하면 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS를&lt;/a&gt; 사용하여 데이터베이스가 열립니다 .</target>
        </trans-unit>
        <trans-unit id="537610cacac4e984aff9fc9a16523e33b6616036" translate="yes" xml:space="preserve">
          <source>Databases created by the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command always use the same encoding as the main database. An attempt to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; a database with a different text encoding from the &quot;main&quot; database will fail.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령으로 작성된 데이터베이스는 항상 기본 데이터베이스와 동일한 인코딩을 사용합니다. 시도가하는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 실패합니다 &quot;기본&quot;데이터베이스에서 다른 텍스트 인코딩을 사용하여 데이터베이스를.</target>
        </trans-unit>
        <trans-unit id="3c4ce966e1af83816196cb8a675f0d67e707135b" translate="yes" xml:space="preserve">
          <source>Databases generated with this option enabled are not readable by SQLite version 3.1.6 (2005-03-17) and earlier. Also, databases generated with this option enabled are prone to triggering the &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; bug in the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. For those reasons, this optimization is disabled by default. However, this optimization may be enabled by default in a future release of SQLite.</source>
          <target state="translated">이 옵션을 사용하여 생성 된 데이터베이스는 SQLite 버전 3.1.6 (2005-03-17) 및 이전 버전에서 읽을 수 없습니다. 또한이 옵션을 사용하여 생성 된 데이터베이스 는 &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스 에서 &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46&lt;/a&gt; 버그 를 트리거하는 경향이 있습니다. 이러한 이유로이 최적화는 기본적으로 비활성화되어 있습니다. 그러나이 최적화는 향후 SQLite 릴리스에서 기본적으로 사용 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b3b2437f86ea4a0a8830ee6f8676cb1c3fc7da2" translate="yes" xml:space="preserve">
          <source>Datatype</source>
          <target state="translated">Datatype</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="baca0ff89b200ca165a0e54ccac355e7a923a643" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 2</source>
          <target state="translated">SQLite 버전 2의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1148668ae941abc0a854dc721e03d190e3485da6" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1c55ea91377b3b902abf3a2f501f4ea2f40cdee4" translate="yes" xml:space="preserve">
          <source>Datatypes In SQLite version 2</source>
          <target state="translated">SQLite 버전 2의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="233589836b520dde667809090f43b167594ea046" translate="yes" xml:space="preserve">
          <source>Date And Time Functions</source>
          <target state="translated">날짜 및 시간 함수</target>
        </trans-unit>
        <trans-unit id="6e2d2613130a40dc5bf62f65d270a32aa2b8b643" translate="yes" xml:space="preserve">
          <source>Date and time datatype</source>
          <target state="translated">날짜 및 시간 데이터 유형</target>
        </trans-unit>
        <trans-unit id="75a33d1bae263935cd17a2f9f5d07d057859dce8" translate="yes" xml:space="preserve">
          <source>Dbhash can be used to compare two databases to confirm that they are equivalent, even though their representation on disk is quite different. Dbhash might also be used to verify the content of a remote database without having to transmit the entire content of the remote database over a slow link.</source>
          <target state="translated">Dbhash를 사용하면 두 데이터베이스를 비교하여 디스크에서의 표현이 상당히 다르더라도 동등한 지 확인합니다. Dbhash는 느린 링크를 통해 원격 데이터베이스의 전체 내용을 전송하지 않고도 원격 데이터베이스의 내용을 확인하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bbc93e532fc52d7a861418ae6b728933b34062d" translate="yes" xml:space="preserve">
          <source>Dbhash ignores extraneous formatting details and hashes only the database schema and content. Hence the hash is constant even if the database file is modified by:</source>
          <target state="translated">Dbhash는 불필요한 형식화 세부 사항을 무시하고 데이터베이스 스키마 및 컨텐츠 만 해시합니다. 따라서 데이터베이스 파일이 다음에 의해 수정 되더라도 해시는 일정합니다.</target>
        </trans-unit>
        <trans-unit id="fb601abda7bdb73c50bfb1396b0751c831eb5fce" translate="yes" xml:space="preserve">
          <source>Dbhash is a command-line utility. To run it, type &quot;dbhash&quot; on a command-line prompt followed by the names of one or more SQLite database files that are to be hashed. The database hashes will be displayed on standard output. For example:</source>
          <target state="translated">Dbhash는 명령 줄 유틸리티입니다. 실행하려면 명령 줄 프롬프트에서 &quot;dbhash&quot;를 입력하고 해시 할 하나 이상의 SQLite 데이터베이스 파일 이름을 입력하십시오. 데이터베이스 해시는 표준 출력에 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e18681716fd7987f00ad554ff7f96da73e19fc13" translate="yes" xml:space="preserve">
          <source>Dbhash supports command-line options that can restrict the tables of the database file that are hashed, or restrict the hash to only content or only the schema. Run &quot;dbhash --help&quot; for further information.</source>
          <target state="translated">Dbhash는 해시 된 데이터베이스 파일의 테이블을 제한하거나 해시를 컨텐츠 또는 스키마로만 제한 할 수있는 명령 행 옵션을 지원합니다. 자세한 내용은 &quot;dbhash --help&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4a3882260abac88b66d6979bfd1282ccb93420d4" translate="yes" xml:space="preserve">
          <source>Deactivate the &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; keyword on subqueries on the right-hand side of the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 오른쪽에있는 서브 쿼리에서 &lt;a href=&quot;lang_select#distinct&quot;&gt;DISTINCT&lt;/a&gt; 키워드를 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f6794b197abfdc80b581fdd1340dcd8182be7db" translate="yes" xml:space="preserve">
          <source>Debugging Hints</source>
          <target state="translated">디버깅 힌트</target>
        </trans-unit>
        <trans-unit id="6558db0cb9f4028912366a41e3c7533d49d4b391" translate="yes" xml:space="preserve">
          <source>Debugging memory allocator</source>
          <target state="translated">메모리 할당 자 디버깅</target>
        </trans-unit>
        <trans-unit id="7c281fc0eea49fa90d5204752efe02a46e78181a" translate="yes" xml:space="preserve">
          <source>Debugging mode. Do not actually perform any optimizations but instead return one line of text for each optimization that would have been done. Off by default.</source>
          <target state="translated">디버깅 모드. 실제로 최적화를 수행하지 말고 각 최적화에 대해 한 줄의 텍스트를 반환하십시오. 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c3a2d0cc24a4535ef91791064ffe989cbd382a" translate="yes" xml:space="preserve">
          <source>Decimal</source>
          <target state="translated">Decimal</target>
        </trans-unit>
        <trans-unit id="4884a58f8854eaff9e14e4541fa2bfc15e139d8a" translate="yes" xml:space="preserve">
          <source>Declare The Schema Of A Virtual Table</source>
          <target state="translated">가상 테이블의 스키마 선언</target>
        </trans-unit>
        <trans-unit id="c657d4e9ebee4c198c968bcba7aff6eeab9209c1" translate="yes" xml:space="preserve">
          <source>Declared Datatype Of A Query Result</source>
          <target state="translated">쿼리 결과의 선언 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="52f7f00d0ba2d4f4aaef6d6440932d8183870fe3" translate="yes" xml:space="preserve">
          <source>Decompose the &quot;settings.xml&quot; file into an SQL table that is more easily viewed and edited by separate applications.</source>
          <target state="translated">&quot;settings.xml&quot;파일을 별도의 애플리케이션에서보다 쉽게보고 편집 할 수있는 SQL 테이블로 분해하십시오.</target>
        </trans-unit>
        <trans-unit id="e090288f7922e2e7bbb158d2a90c3c98da108024" translate="yes" xml:space="preserve">
          <source>DecrJumpZero</source>
          <target state="translated">DecrJumpZero</target>
        </trans-unit>
        <trans-unit id="7078198f7cae420890a1abe183a812a6a35f8ed6" translate="yes" xml:space="preserve">
          <source>Default Value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="349c243fc47f07030e17a3729d694bcfe2dadb05" translate="yes" xml:space="preserve">
          <source>Default builds of SQLite contain appropriate &lt;a href=&quot;vfs&quot;&gt;VFS objects&lt;/a&gt; for talking to underlying operating system, and those VFS objects will contain operating system calls such as open(), read(), write(), fsync(), and so forth. All of these interfaces are readily available on most platforms, and custom VFSes can be designed to run SQLite on even the most austere embedded devices.</source>
          <target state="translated">SQLite의 기본 빌드에는 기본 운영 체제와 통신하기위한 적절한 &lt;a href=&quot;vfs&quot;&gt;VFS 개체&lt;/a&gt; 가 포함되며 이러한 VFS 개체에는 open (), read (), write (), fsync () 등과 같은 운영 체제 호출이 포함됩니다. 이러한 모든 인터페이스는 대부분의 플랫폼에서 쉽게 사용할 수 있으며, 가장 엄격한 임베디드 장치에서도 SQLite를 실행하도록 사용자 지정 VFS를 설계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038803a5a725763be7d5665007510dd34ef1f8ce" translate="yes" xml:space="preserve">
          <source>Default memory allocator</source>
          <target state="translated">기본 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="e25af978372277845b3d313829fc8e2e019d17ec" translate="yes" xml:space="preserve">
          <source>Default page cache size.</source>
          <target state="translated">기본 페이지 캐시 크기</target>
        </trans-unit>
        <trans-unit id="bdffe654f8554300a98d2acefcbbf1d894339b2b" translate="yes" xml:space="preserve">
          <source>Default value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="f9d91891053643138161539927c04de3021744dd" translate="yes" xml:space="preserve">
          <source>Defense Against Dark Arts</source>
          <target state="translated">어두운 예술에 대한 방어</target>
        </trans-unit>
        <trans-unit id="c78392ffee2ec805b3bc60c680fa04c8a3bfdd3e" translate="yes" xml:space="preserve">
          <source>DeferredSeek</source>
          <target state="translated">DeferredSeek</target>
        </trans-unit>
        <trans-unit id="2a32a694b454b48f0c6093b3ea95bcc7ae1e63ab" translate="yes" xml:space="preserve">
          <source>Define New Collating Sequences</source>
          <target state="translated">새로운 조합 순서 정의</target>
        </trans-unit>
        <trans-unit id="7a8df33d7a4ee8c98b8a16229139f0094608d9e9" translate="yes" xml:space="preserve">
          <source>Define a static (but not constant) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure that contains pointers to the xOpen method and the other methods and which contains the appropriate values for iVersion, szOsFile, mxPathname, zName, and pAppData.</source>
          <target state="translated">xOpen 메소드 및 기타 메소드에 대한 포인터를 포함하고 iVersion, szOsFile, mxPathname, zName 및 pAppData에 대한 적절한 값을 포함 하는 정적 (정수는 아님) &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 구조를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d00d0274d811a9571e6a7d0d105251d14e6c534a" translate="yes" xml:space="preserve">
          <source>Define an appropriate subclass of the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 적절한 서브 클래스를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eb6b16d370a1014df05c39f19a4497ee0d61573" translate="yes" xml:space="preserve">
          <source>Define the &quot;payload&quot; of a cell to be the arbitrary length section of the cell. For an index b-tree, the key is always arbitrary in length and hence the payload is the key. There are no arbitrary length elements in the cells of interior table b-tree pages and so those cells have no payload. Table b-tree leaf pages contain arbitrary length content and so for cells on those pages the payload is the content.</source>
          <target state="translated">셀의 &quot;페이로드&quot;를 셀의 임의의 길이 섹션으로 정의하십시오. 인덱스 b- 트리의 경우 키의 길이는 항상 임의적이므로 페이로드가 키입니다. 내부 테이블 b- 트리 페이지의 셀에는 임의의 길이 요소가 없으므로 해당 셀에는 페이로드가 없습니다. 표 b- 트리 리프 페이지에는 임의 길이의 컨텐츠가 포함되므로 해당 페이지의 셀에 대한 페이로드는 컨텐츠입니다.</target>
        </trans-unit>
        <trans-unit id="09695710d6ec87af0ba3720c928922e55056227a" translate="yes" xml:space="preserve">
          <source>Define the depth of a leaf b-tree to be 1 and the depth of any interior b-tree to be one more than the maximum depth of any of its children. In a well-formed database, all children of an interior b-tree have the same depth.</source>
          <target state="translated">리프 b- 트리의 깊이를 1로 정의하고 내부 b- 트리의 깊이를 자식의 최대 깊이보다 1 이상 높게 정의하십시오. 올바르게 구성된 데이터베이스에서 내부 b- 트리의 모든 자식의 깊이는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e75225c3111252da2f1b0958f137acf031ed75f2" translate="yes" xml:space="preserve">
          <source>Defining this option causes the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; command to be omitted from the library. Attempting to execute an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; statement will cause a parse error.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령이 라이브러리에서 생략됩니다. &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 문 을 실행하려고 하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95e30519291de496ce9227bf803508402c5b0e39" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying and modifying the database schema version and user version from the build. Specifically, the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMAs are omitted.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 데이터베이스 스키마 버전 및 사용자 버전을 쿼리하고 수정하기위한 실습이 생략됩니다. 특히 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; PRAGMA는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="438bf5a3e905d9e27a03501948a3300c579faa96" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas for querying the database schema from the build.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 데이터베이스 스키마를 쿼리하기위한 실용성이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="fb53b1a942ec49b6ce242dc0903a83562676a9de" translate="yes" xml:space="preserve">
          <source>Defining this option omits pragmas related to the pager subsystem from the build.</source>
          <target state="translated">이 옵션을 정의하면 빌드에서 호출기 서브 시스템과 관련된 pragma가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2296b74c87da37e10da27f66b21bb73a4427d7" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for TRIGGER objects. Neither the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; or &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error. This option also disables enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;, since the code that implements triggers and which is omitted by this option is also used to implement &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 정의하면 TRIGGER 객체에 대한 지원이 생략됩니다. 어느 쪽도 아니는 &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER CREATE 없습니다&lt;/a&gt; 또는 &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; 명령이 경우에 사용할 수 있으며, 구문 분석 오류가 발생합니다 중 하나를 실행하려고 시도. 트리거를 구현하고이 옵션에서 생략 된 코드가 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업&lt;/a&gt; 을 구현하는 데 에도 사용되므로이 옵션은 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건의&lt;/a&gt; 적용을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="15c4cfc354a842ec38f01dc56ced3bf25c4ad5b6" translate="yes" xml:space="preserve">
          <source>Defining this option omits support for VIEW objects. Neither the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; nor the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; commands are available in this case, and attempting to execute either will result in a parse error.</source>
          <target state="translated">이 옵션을 정의하면 VIEW 객체에 대한 지원이 생략됩니다. 이 경우 &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; 명령을 사용할 수 없으며 둘 중 하나를 실행하려고하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8d0bb74e48c16e4de7827a8ffc7d0dc3f87633f" translate="yes" xml:space="preserve">
          <source>Defining this option omits the authorization callback feature from the library. The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">이 옵션을 정의하면 라이브러리에서 권한 부여 콜백 기능이 생략됩니다. &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; API 함수는 라이브러리에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83f644802e49a1cbe2ffeee1f4e6042a39cd0de9" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">정의 : &lt;b&gt;결과 테이블&lt;/b&gt; 은 &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 인터페이스로 작성된 메모리 데이터 구조입니다 . 결과 테이블은 하나 이상의 쿼리의 전체 쿼리 결과를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e259d1f20b6fd6c9ce46ea6e1dc31fde6f204fb8" translate="yes" xml:space="preserve">
          <source>Definition: A &lt;b&gt;result table&lt;/b&gt; is memory data structure created by the &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface. A result table records the complete query results from one or more queries.</source>
          <target state="translated">정의 : &lt;b&gt;결과 테이블&lt;/b&gt; 은 &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 인터페이스로 작성된 메모리 데이터 구조입니다 . 결과 테이블은 하나 이상의 쿼리의 전체 쿼리 결과를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="6ae0a530b1b7677b78998487aadb9d2cadf7f88f" translate="yes" xml:space="preserve">
          <source>Delete A Changegroup Object</source>
          <target state="translated">변경 그룹 객체 삭제</target>
        </trans-unit>
        <trans-unit id="2b620c0b18464aba1294c125c40ed5d238146244" translate="yes" xml:space="preserve">
          <source>Delete A Session Object</source>
          <target state="translated">세션 객체 삭제</target>
        </trans-unit>
        <trans-unit id="12eda7c48435244e864fe35cc6d11a7bc5eebd9b" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 서 객체 삭제</target>
        </trans-unit>
        <trans-unit id="6ccb779f78fa4c2f40b79e1431ac32a6c85e1c13" translate="yes" xml:space="preserve">
          <source>Delete a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="12991bc9bb4a12d326aa6753050041d7a4fabc24" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()를&lt;/a&gt; 사용하여 이전에 할당 된 세션 객체를 삭제하십시오 . 세션 객체가 삭제되면 다른 세션 모듈 함수와 함께 pSession을 사용한 시도 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d762d1040e85482796c9fd4d534519cef24d74ed" translate="yes" xml:space="preserve">
          <source>Delete a session object previously allocated using &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;. Once a session object has been deleted, the results of attempting to use pSession with any other session module function are undefined.</source>
          <target state="translated">&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()를&lt;/a&gt; 사용하여 이전에 할당 된 세션 객체를 삭제하십시오 . 세션 객체가 삭제되면 다른 세션 모듈 함수와 함께 pSession을 사용한 시도 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02512a6317bed133605bfc468e6ef4822f972b23" translate="yes" xml:space="preserve">
          <source>Delete all contents from the ephemeral table or sorter that is open on cursor P1.</source>
          <target state="translated">커서 P1에 열려있는 임시 테이블 또는 분류기에서 모든 컨텐츠를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="aedb82abe0e510f8fa2d29632ac81d5268819e7f" translate="yes" xml:space="preserve">
          <source>Delete all contents of the database table or index whose root page in the database file is given by P1. But, unlike &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;, do not remove the table or index from the database file.</source>
          <target state="translated">데이터베이스 파일의 루트 페이지가 P1에 의해 제공되는 데이터베이스 테이블 또는 인덱스의 모든 내용을 삭제하십시오. 그러나 &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; 와 달리 데이터베이스 파일에서 테이블 또는 인덱스를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f095a0ada2906d2012dfcefd96beaf7902bce51" translate="yes" xml:space="preserve">
          <source>Delete all individual journal files.</source>
          <target state="translated">모든 개별 저널 파일을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1b9b7fadc6e867c3913361047ae2f1e082e237" translate="yes" xml:space="preserve">
          <source>Delete an entire database table or index whose root page in the database file is given by P1.</source>
          <target state="translated">데이터베이스 파일의 루트 페이지가 P1에 의해 제공되는 전체 데이터베이스 테이블 또는 인덱스를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc9013dca7ae3cd28443b3643084c1962bbbebb" translate="yes" xml:space="preserve">
          <source>Delete the changeset rebaser object and all associated resources. There should be one call to this function for each successful invocation of sqlite3rebaser_create().</source>
          <target state="translated">변경 세트 리바 저 오브젝트 및 모든 관련 자원을 삭제하십시오. sqlite3rebaser_create ()를 성공적으로 호출 할 때마다이 함수를 한 번 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="60bf70613708367f728d96356276360d98741581" translate="yes" xml:space="preserve">
          <source>Delete the journal file (or truncate the journal to zero bytes in length if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; is set, or zero the journal header if &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=PERSIST&lt;/a&gt; is set).</source>
          <target state="translated">저널 파일을 삭제하십시오 (또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt; 가 설정된 경우 저널을 0 바이트 길이로 자르 거나 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = PERSIST&lt;/a&gt; 가 설정된 경우 저널 헤더 를 0으로 자르십시오 ).</target>
        </trans-unit>
        <trans-unit id="424c686346d72ee424e3afead9478d41b73e0e95" translate="yes" xml:space="preserve">
          <source>Delete the journal file. (Or if the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is TRUNCATE or PERSIST, truncate the journal file or zero the header of the journal file, respectively.) This is the instant when the changes are committed. Prior to deleting the journal file, if a power failure or crash occurs, the next process to open the database will see that it has a hot journal and will roll the changes back. After the journal is deleted, there will no longer be a hot journal and the changes will persist.</source>
          <target state="translated">저널 파일을 삭제하십시오. (또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; 가 TRUNCATE 또는 PERSIST 인 경우 저널 파일을 잘라내거나 저널 파일의 헤더를 각각 0으로 변경하십시오.) 변경 사항이 커밋 된 순간입니다. 저널 파일을 삭제하기 전에 정전 또는 충돌이 발생하면 데이터베이스를 여는 다음 프로세스에서 데이터베이스에 핫 저널이 있음을 확인하고 변경 사항을 롤백합니다. 저널이 삭제 된 후에는 더 이상 핫 저널이 없으며 변경 사항이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="aae017b3d4b04098148419004c202430e143c042" translate="yes" xml:space="preserve">
          <source>Delete the master journal file if it is safe to do so. This step is optional. It is here only to prevent stale master journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">마스터 저널 파일이 안전한 경우 삭제하십시오. 이 단계는 선택 사항입니다. 오래된 마스터 저널이 디스크 드라이브를 어지럽히는 것을 방지하기 위해서입니다. 자세한 내용은 아래 토론을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e10f41bbb6b9a5c4d90c81334bd806252b81f5b3" translate="yes" xml:space="preserve">
          <source>Delete the master journal file. This is the instant when the changes are committed. Prior to deleting the master journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the master journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">마스터 저널 파일을 삭제하십시오. 변경 사항이 커밋 된 순간입니다. 마스터 저널 파일을 삭제하기 전에 정전 또는 충돌이 발생하면 개별 파일 저널은 핫으로 간주되고 다음 파일을 읽으려고 시도하는 프로세스에 의해 롤백됩니다. 마스터 저널이 삭제 된 후에는 파일 저널이 더 이상 핫으로 간주되지 않으며 변경 사항이 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="29e75bc2e3dd1128b5b5e72142f38e94e6c04b31" translate="yes" xml:space="preserve">
          <source>Delete the record at which the P1 cursor is currently pointing.</source>
          <target state="translated">P1 커서가 현재 가리키는 레코드를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="4fcd91afe095d0c6dacc95e2b6d58ad6d5e14534" translate="yes" xml:space="preserve">
          <source>Delete the super-journal file if it is safe to do so. This step is optional. It is here only to prevent stale super-journals from cluttering up the disk drive. See the discussion below for details.</source>
          <target state="translated">안전한 경우 수퍼 저널 파일을 삭제하십시오. 이 단계는 선택 사항입니다. 부실한 수퍼 저널이 디스크 드라이브를 복잡하게 만드는 것을 방지하기위한 것입니다. 자세한 내용은 아래 토론을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2453d64dea3e074099ee813a3f51329c03660891" translate="yes" xml:space="preserve">
          <source>Delete the super-journal file. This is the instant when the changes are committed. Prior to deleting the super-journal file, if a power failure or crash occurs, the individual file journals will be considered hot and will be rolled back by the next process that attempts to read them. After the super-journal has been deleted, the file journals will no longer be considered hot and the changes will persist.</source>
          <target state="translated">슈퍼 저널 파일을 삭제하십시오. 이것은 변경 사항이 커밋되는 순간입니다. 수퍼 저널 파일을 삭제하기 전에 정전 또는 충돌이 발생하면 개별 파일 저널이 핫 저널로 간주되고이를 읽으려는 다음 프로세스에 의해 롤백됩니다. 수퍼 저널이 삭제 된 후에는 파일 저널이 더 이상 핫 저널로 간주되지 않고 변경 사항이 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="91c899cb9487830103f86062414b65279777c00c" translate="yes" xml:space="preserve">
          <source>Delete triggers fire when rows are removed due to a &lt;a href=&quot;lang_conflict&quot;&gt;REPLACE conflict resolution&lt;/a&gt;. This feature is only enabled when recursive triggers are enabled.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;REPLACE 충돌 해결&lt;/a&gt; 로 인해 행이 제거되면 삭제 트리거가 실행됩니다 . 이 기능은 재귀 트리거가 활성화 된 경우에만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f97f11b2a9d7f4d5cfcb9f5b6bc157b876524629" translate="yes" xml:space="preserve">
          <source>Deleting a file is an expensive operation on many systems. So as an optimization, SQLite can be configured to avoid the delete operation of &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;. Instead of deleting the journal file in order to commit a transaction, the file is either truncated to zero bytes in length or its header is overwritten with zeros. Truncating the file to zero length saves having to make modifications to the directory containing the file since the file is not removed from the directory. Overwriting the header has the additional savings of not having to update the length of the file (in the &quot;inode&quot; on many systems) and not having to deal with newly freed disk sectors. Furthermore, at the next transaction the journal will be created by overwriting existing content rather than appending new content onto the end of a file, and overwriting is often much faster than appending.</source>
          <target state="translated">파일 삭제는 많은 시스템에서 비용이 많이 드는 작업입니다. 따라서 최적화로서 &lt;a href=&quot;#section_3_11&quot;&gt;섹션 3.11&lt;/a&gt; 의 삭제 조작을 피하도록 SQLite를 구성 할 수 있습니다.. 트랜잭션을 커밋하기 위해 저널 파일을 삭제하는 대신 파일 길이가 0 바이트로 잘 리거나 헤더가 0으로 덮어 쓰기됩니다. 파일을 길이가 0으로 자르면 파일이 디렉토리에서 제거되지 않기 때문에 파일이 포함 된 디렉토리를 수정해야합니다. 헤더를 덮어 쓰면 파일 길이를 업데이트 할 필요가없고 (많은 시스템의 &quot;inode&quot;에서) 새로 해제 된 디스크 섹터를 처리하지 않아도되므로 추가 절약이 가능합니다. 또한 다음 트랜잭션에서 파일 끝에 새 내용을 추가하지 않고 기존 내용을 덮어 써서 저널을 만들며, 덮어 쓰기가 추가하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="2696b8d0813903709611732c9e8977b50fd62e40" translate="yes" xml:space="preserve">
          <source>Deleting a file is not really an atomic operation, but it appears to be from the point of view of a user process. A process is always able to ask the operating system &quot;does this file exist?&quot; and the process will get back a yes or no answer. After a power failure that occurs during a transaction commit, SQLite will ask the operating system whether or not the rollback journal file exists. If the answer is &quot;yes&quot; then the transaction is incomplete and is rolled back. If the answer is &quot;no&quot; then it means the transaction did commit.</source>
          <target state="translated">파일을 삭제하는 것은 실제로 원자 작업이 아니지만 사용자 프로세스의 관점에서 볼 수 있습니다. 프로세스는 항상 운영 체제에 &quot;이 파일이 있습니까?&quot;를 요청할 수 있습니다. 프로세스가 예 또는 아니오로 돌아옵니다. 트랜잭션 커밋 중에 발생하는 정전 후 SQLite는 롤백 저널 파일이 존재하는지 여부를 운영 체제에 묻습니다. 대답이 &quot;예&quot;이면 트랜잭션이 불완전하며 롤백됩니다. 대답이 &quot;아니오&quot;이면 트랜잭션이 커밋되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c09fda80ecfdf9e281d56a4afdd3670077682c0b" translate="yes" xml:space="preserve">
          <source>Deleting a hot journal</source>
          <target state="translated">인기 저널 삭제</target>
        </trans-unit>
        <trans-unit id="9d50c7931911f099d06f9c5c9dcef20c05a1a010" translate="yes" xml:space="preserve">
          <source>Deliberately changing out of WAL mode changes the database file format version numbers back to 1 so that older versions of SQLite can once again access the database file.</source>
          <target state="translated">의도적으로 WAL 모드를 변경하면 이전 버전의 SQLite가 데이터베이스 파일에 다시 액세스 할 수 있도록 데이터베이스 파일 형식 버전 번호가 1로 다시 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="94c24d036a23e21672451696acb1226b9371946b" translate="yes" xml:space="preserve">
          <source>Deny oneself in order to follow Christ.</source>
          <target state="translated">그리스도를 따르기 위해 자신을 부인하십시오.</target>
        </trans-unit>
        <trans-unit id="4b72ef41c3b1c98245c65c2469b7a10fdf627d58" translate="yes" xml:space="preserve">
          <source>Depending how badly your database is corrupted, you may be able to recover some of the data by using the CLI to dump the schema and contents to a file and then recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally not possible to put him back together again.</source>
          <target state="translated">데이터베이스가 얼마나 손상되었는지에 따라 CLI를 사용하여 스키마와 내용을 파일로 덤프 한 후 다시 작성하여 일부 데이터를 복구 할 수 있습니다. 불행하게도 일단 험피 덤프가 벽에서 떨어지면 일반적으로 그를 다시 합치는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="5466f1e1c1f4f0fffe016c26643a67d2ad503e26" translate="yes" xml:space="preserve">
          <source>Depending on the query, SQLite might need to materialize the &quot;(SELECT b FROM ex2)&quot; subquery into a temporary table, then perform the join between ex1 and the temporary table. The query optimizer tries to avoid this by &quot;flattening&quot; the query. In the previous example the query can be flattened, and SQLite will automatically transform the query into</source>
          <target state="translated">쿼리에 따라 SQLite는 &quot;(SELECT b FROM ex2)&quot;하위 쿼리를 임시 테이블로 구체화 한 다음 ex1과 임시 테이블간에 조인을 수행해야 할 수 있습니다. 쿼리 최적화 프로그램은 쿼리를 &quot;평 평화&quot;하여이를 피하려고합니다. 앞의 예에서 쿼리를 병합 할 수 있으며 SQLite는 자동으로 쿼리를</target>
        </trans-unit>
        <trans-unit id="886d67dc402c58b18f059201de3cb182bdcca2d0" translate="yes" xml:space="preserve">
          <source>Depending on the type of conflict, a sessions application has a variety of configurable options for dealing with conflicts, ranging from omitting the conflicting change, aborting the entire changeset application or applying the change despite the conflict. For details, refer to the documentation for the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">충돌 유형에 따라 세션 응용 프로그램에는 충돌 변경을 생략하거나 전체 변경 집합 응용 프로그램을 중단하거나 충돌에도 불구하고 변경 사항을 적용하는 등 충돌을 처리하기위한 다양한 구성 가능한 옵션이 있습니다. 자세한 내용은 &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; API 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99099b8d7e1bb8542438e0ec64f4aa03573d7d34" translate="yes" xml:space="preserve">
          <source>Depending on which parameter is being interrogated, one of the VALUE or HIWTR mark measurements might be undefined. For example, only the high-water mark is meaningful for &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt;, and only the current value is meaningful for &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;. For rows where one or the other of VALUE or HIWTR is not meaningful, that value is returned as NULL. the interfaces, with the initial</source>
          <target state="translated">어떤 매개 변수를 조사 하느냐에 따라 VALUE 또는 HIWTR 마크 측정 중 하나가 정의되지 않을 수 있습니다. 예를 들어, 단지 하이 워터 마크에 대한 의미 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmallocsize&quot;&gt;SQLITE_STATUS_MALLOC_SIZE&lt;/a&gt; , 단지 현재 값에 대한 의미 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; . VALUE 또는 HIWTR 중 하나가 의미가없는 행의 경우 해당 값은 NULL로 리턴됩니다. 초기와 인터페이스</target>
        </trans-unit>
        <trans-unit id="3a49085fe4eb15cab436b357201995ee9bf9e4bd" translate="yes" xml:space="preserve">
          <source>Depending on your hardware and operating system, you should see that reads from the test1.db database file are about 35% faster than reads from individual files in the test1.dir or test1.tree folders. Results can vary significantly from one run to the next due to caching, so it is advisable to run tests multiple times and take an average or a worst case or a best case, depending on your requirements.</source>
          <target state="translated">하드웨어 및 운영 체제에 따라 test1.db 데이터베이스 파일의 읽기는 test1.dir 또는 test1.tree 폴더의 개별 파일에서 읽는 것보다 약 35 % 빠릅니다. 캐싱으로 인해 결과가 실행마다 크게 다를 수 있으므로 테스트를 여러 번 실행하고 요구 사항에 따라 평균 또는 최악의 경우 또는 최상의 경우를 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="42a66abe1669ce3ffad7695dbe407c22ed591eb2" translate="yes" xml:space="preserve">
          <source>Deprecated Functions</source>
          <target state="translated">더 이상 사용되지 않는 함수</target>
        </trans-unit>
        <trans-unit id="bfc32553e9a3941dedadb9fb40b33e7008f653d9" translate="yes" xml:space="preserve">
          <source>Deprecated Soft Heap Limit Interface</source>
          <target state="translated">더 이상 사용되지 않는 소프트 힙 제한 인터페이스</target>
        </trans-unit>
        <trans-unit id="3a682fd508565521834d60be19ff2f936a43d34b" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces have been superceded by better methods of accomplishing the same thing and should be avoided in new applications. Deprecated interfaces continue to be supported for the sake of backwards compatibility. At some point in the future, it is possible that deprecated interfaces may be removed.</source>
          <target state="translated">더 이상 사용되지 않는 인터페이스는 동일한 작업을 수행하는 더 나은 방법으로 대체되었으며 새로운 응용 프로그램에서는 피해야합니다. 이전 버전과의 호환성을 위해 더 이상 사용되지 않는 인터페이스가 계속 지원됩니다. 향후 언젠가는 더 이상 사용되지 않는 인터페이스가 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd86ca0936a352d07e01faf8385985c6bcfbe7d" translate="yes" xml:space="preserve">
          <source>Deprecated interfaces should not be used in new code and might be removed in some future release.</source>
          <target state="translated">더 이상 사용되지 않는 인터페이스는 새 코드에서 사용해서는 안되며 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384385f4ecfb14efac5a6de95da0a3708e15bd88" translate="yes" xml:space="preserve">
          <source>Descending indices</source>
          <target state="translated">내림차순 지수</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="4d25e019c14ea4edb8919779e923685a3363cdef" translate="yes" xml:space="preserve">
          <source>Description Of File Format Change</source>
          <target state="translated">파일 형식 변경 설명</target>
        </trans-unit>
        <trans-unit id="cd8429891c87cd83470eecb59eba348d84f2f5d1" translate="yes" xml:space="preserve">
          <source>Deserialize a database</source>
          <target state="translated">데이터베이스 역 직렬화</target>
        </trans-unit>
        <trans-unit id="99d0530263d176ccac0fdc529fd7f2dedfa20826" translate="yes" xml:space="preserve">
          <source>Designing software is hard. It takes a lot of focus. A good version control system should provide the developer with assistance, not frustration. Git has gotten better in this regard over the past decade, but it still has a long way to go.</source>
          <target state="translated">소프트웨어 설계는 어렵습니다. 많은 초점이 필요합니다. 좋은 버전 관리 시스템은 개발자에게 좌절이 아닌 도움을 제공해야합니다. Git은 지난 10 년 동안 이와 관련하여 더 나아졌지 만 여전히 갈 길이 멀다.</target>
        </trans-unit>
        <trans-unit id="a83ebad2040aac26354ce69d33c75a8e23379288" translate="yes" xml:space="preserve">
          <source>Desire eternal life with all the passion of the spirit.</source>
          <target state="translated">영의 모든 열정으로 영생을 소망하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd8f751199e13822ef7d9714c88c6e47db10e8e" translate="yes" xml:space="preserve">
          <source>Despite the name, this function always returns a value between 0.0 and 1.0 equal to (</source>
          <target state="translated">이름에도 불구하고이 함수는 항상 0.0과 1.0 사이의 값을</target>
        </trans-unit>
        <trans-unit id="577ef7dc1516f4b3c43ddbe63327a8a039a0edec" translate="yes" xml:space="preserve">
          <source>Destroy</source>
          <target state="translated">Destroy</target>
        </trans-unit>
        <trans-unit id="839c441dcc29d361bfacf38afa416f18a1637928" translate="yes" xml:space="preserve">
          <source>Destroy A Prepared Statement Object</source>
          <target state="translated">준비된 명령문 오브젝트 삭제</target>
        </trans-unit>
        <trans-unit id="8a43abf112611732f3dfb583fa8f44e2049379d4" translate="yes" xml:space="preserve">
          <source>Destroy a snapshot</source>
          <target state="translated">스냅 샷 파괴</target>
        </trans-unit>
        <trans-unit id="7d83f3ed4b5d324ccef4af3b6f9a3539eb93e67c" translate="yes" xml:space="preserve">
          <source>Destroy the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="c75278c7e28535f5ea9e950ab84092bdea32a614" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 객체를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="64b1ed1f1b53763efdc1c78265116d5fa0da95e8" translate="yes" xml:space="preserve">
          <source>Destroy the object using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 객체를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="5284d7d2a9c5b9dbf72aafe5558f4a26a439739f" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1afb291d062f0484331555f28baeeafd003c3dfa" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be5ef256fde14f27a6be2d2b33459ee64ab4a321" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bc54ba31c2c513271f833dc8e2d60c1be1b1091" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="689b80c76ccc07fa3d2942a087706f3eef81d330" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c105a9f0c702f6cd4ef79cd3b0f385965920de3c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed39236d0e8e7446d0cb599cd5b738b2811bcf10" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d822a3174515e8f21e47ce59b4339bb51f6db978" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f60221cb8d7f3a49adecb2493f31cebddcb5e00c" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e83f5c6e38c161fc2b5c1d7abe156cb9aad8f5f3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;sqlite3changegroup_delete&quot;&gt;sqlite3changegroup_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41e4345992429802aea5872bac2716f7c77be8e3" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6b6c509cccb52d51368c6e4ebb375738475d8f0" translate="yes" xml:space="preserve">
          <source>Destructor: &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="359201cc8ce5eb69bceb0fd81af7a37ed2f96a48" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e0b565701116b40edb353da662ba766f93f65b1" translate="yes" xml:space="preserve">
          <source>Destructors: &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;, &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;</source>
          <target state="translated">소멸자 : &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; , &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="3ee5fd57c6234479272be39f53b7a756c8fad2c3" translate="yes" xml:space="preserve">
          <source>Details of the low-level B-tree format used in SQLite version 3.0 can be found in header comments to the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; source file and in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation.</source>
          <target state="translated">SQLite 버전 3.0에서 사용되는 하위 수준의 B- 트리 형식에 대한 자세한 내용은 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/btreeInt.h&quot;&gt;btreeInt.h&lt;/a&gt; 소스 파일 에 대한 헤더 주석 및 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057c54e32daecfe5f3f91aea6c17b8880637989a" translate="yes" xml:space="preserve">
          <source>Detect integer overflow in abs().</source>
          <target state="translated">abs ()에서 정수 오버플로를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="0cb93bae74fdeaac6fc236f4e82d733ebb774f3f" translate="yes" xml:space="preserve">
          <source>Determine If A Prepared Statement Has Been Reset</source>
          <target state="translated">준비된 명령문이 재설정되었는지 판별</target>
        </trans-unit>
        <trans-unit id="db966195ad1f618275836e22992513b99d0a007c" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Is Complete</source>
          <target state="translated">SQL 문이 완전한지 판별</target>
        </trans-unit>
        <trans-unit id="625d5f335e20e089846651b3578340604a6b4c2f" translate="yes" xml:space="preserve">
          <source>Determine If An SQL Statement Writes The Database</source>
          <target state="translated">SQL 문이 데이터베이스를 작성하는지 확인</target>
        </trans-unit>
        <trans-unit id="eb26a9bebe8d2e098f033d011256a86267629d8a" translate="yes" xml:space="preserve">
          <source>Determine If Virtual Table Column Access Is For UPDATE</source>
          <target state="translated">가상 테이블 열 액세스가 UPDATE인지 확인</target>
        </trans-unit>
        <trans-unit id="5ad12b059791066c3ea756f7418d5b987aa492a2" translate="yes" xml:space="preserve">
          <source>Determine The Collation For a Virtual Table Constraint</source>
          <target state="translated">가상 테이블 제약 조건에 대한 데이터 정렬 결정</target>
        </trans-unit>
        <trans-unit id="c8aa46b4240b68859dbf6ca40dcc17adbb0b5d9d" translate="yes" xml:space="preserve">
          <source>Determine The Number Of Foreign Key Constraint Violations</source>
          <target state="translated">외래 키 제약 조건 위반 수 결정</target>
        </trans-unit>
        <trans-unit id="3e28f586fecd10c20cfef343cf0e0a2554afa731" translate="yes" xml:space="preserve">
          <source>Determine The Virtual Table Conflict Policy</source>
          <target state="translated">가상 테이블 충돌 정책 결정</target>
        </trans-unit>
        <trans-unit id="378e53b0c9705af12aa3d20a3dfea2de180d3964" translate="yes" xml:space="preserve">
          <source>Determine if a database is read-only</source>
          <target state="translated">데이터베이스가 읽기 전용인지 확인</target>
        </trans-unit>
        <trans-unit id="ec9ead520b9e56d263fd7de0b9b24771183e3061" translate="yes" xml:space="preserve">
          <source>Deterministic SQL Functions</source>
          <target state="translated">결정적 SQL 함수</target>
        </trans-unit>
        <trans-unit id="96de162ae9388387b4d27ffd24dfdaec4b72faef" translate="yes" xml:space="preserve">
          <source>Developers report that SQLite is often faster than a client/server SQL database engine in this scenario. Database requests are serialized by the server, so concurrency is not an issue. Concurrency is also improved by &quot;database sharding&quot;: using separate database files for different subdomains. For example, the server might have a separate SQLite database for each user, so that the server can handle hundreds or thousands of simultaneous connections, but each SQLite database is only used by one connection.</source>
          <target state="translated">개발자들은이 시나리오에서 SQLite가 종종 클라이언트 / 서버 SQL 데이터베이스 엔진보다 빠르다고보고합니다. 데이터베이스 요청은 서버에 의해 직렬화되므로 동시성은 문제가되지 않습니다. &quot;데이터베이스 샤딩&quot;을 통해 동시성이 향상되었습니다. 하위 도메인마다 별도의 데이터베이스 파일을 사용합니다. 예를 들어, 서버는 각 사용자마다 별도의 SQLite 데이터베이스를 가질 수 있으므로 서버는 수백 또는 수천 개의 동시 연결을 처리 할 수 ​​있지만 각 SQLite 데이터베이스는 하나의 연결에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b17665b2663239e18f10a989ee4b32e6490c33f2" translate="yes" xml:space="preserve">
          <source>Developers sometimes experience trouble debugging the 185,000-line-long amalgamation source file because some debuggers are only able to handle source code line numbers less than 32,768. The amalgamation source code runs fine. One just cannot single-step through it in a debugger.</source>
          <target state="translated">일부 디버거는 32,768 미만의 소스 코드 라인 번호 만 처리 할 수 ​​있기 때문에 개발자는 때때로 185,000 줄 길이의 아말감 화 소스 파일을 디버깅하는 데 문제가 있습니다. 합병 소스 코드가 제대로 실행됩니다. 디버거에서 단일 단계를 통과 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="db23e94c152c3c70f28ce4fd2250cf8e7e90d0ef" translate="yes" xml:space="preserve">
          <source>Device Characteristics</source>
          <target state="translated">장치 특성</target>
        </trans-unit>
        <trans-unit id="10fe8e0881142639bc54f8ec9a79de4f49557439" translate="yes" xml:space="preserve">
          <source>Devote yourself frequently to prayer.</source>
          <target state="translated">기도에 자주 헌신하십시오.</target>
        </trans-unit>
        <trans-unit id="d2bfc098e435319899700359a7c7ade5b2cceea5" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;../vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vtab#xshadowname&quot;&gt;새도우 테이블에&lt;/a&gt; 직접 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3ea4196b155e79b0ed2d425b768b9f76a1de7e8d" translate="yes" xml:space="preserve">
          <source>Direct writes to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블에&lt;/a&gt; 직접 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d9d75aac27ba7c6d07be6644243da8087e5f97b8" translate="yes" xml:space="preserve">
          <source>Disable schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF를&lt;/a&gt; 사용하여 스키마 편집을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="d741b71f5f87bb5b09855b9b7b964ab4719c4656" translate="yes" xml:space="preserve">
          <source>Disable the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; while reparsing the schema.</source>
          <target state="translated">스키마를 재분석하는 동안 &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자 콜백&lt;/a&gt; 을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="48c40051997047e6342e6473938090c8ad6cd8b6" translate="yes" xml:space="preserve">
          <source>Disable the surreptitious use of custom SQL functions and virtual tables by setting the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on all custom SQL functions and the &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt; flag on all custom virtual tables.</source>
          <target state="translated">설정에 따라 사용자 정의 SQL 함수 및 가상 테이블의 은밀한 사용을 해제 &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 모든 사용자 정의 SQL 기능과에 플래그를 &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY의&lt;/a&gt; 모든 사용자 정의 가상 테이블에 대한 플래그.</target>
        </trans-unit>
        <trans-unit id="2b94299f848122e7aa2027a43aba54a8bdf1eb66" translate="yes" xml:space="preserve">
          <source>Disable the use of posix_fallocate() on all (unix) systems unless the HAVE_POSIX_FALLOCATE compile-time option is used.</source>
          <target state="translated">HAVE_POSIX_FALLOCATE 컴파일 타임 옵션을 사용하지 않으면 모든 (유닉스) 시스템에서 posix_fallocate () 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="dc4409d907665c9eda9e8c714ab538568a93fe4c" translate="yes" xml:space="preserve">
          <source>Disable the use of the strchrnul() C-library routine unless it is specifically enabled using the -DHAVE_STRCHRNULL compile-time option.</source>
          <target state="translated">-DHAVE_STRCHRNULL 컴파일 타임 옵션을 사용하여 특별히 활성화되지 않은 경우 strchrnul () C 라이브러리 루틴 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="44313c14bb780bbf9fd9d83b8ed923886b89675b" translate="yes" xml:space="preserve">
          <source>Disabled optimization tests</source>
          <target state="translated">비활성화 된 최적화 테스트</target>
        </trans-unit>
        <trans-unit id="801e1c0ae6276f6c1470108fe61a442d30ca4372" translate="yes" xml:space="preserve">
          <source>Disabling mutexes at run-time is not as effective as disabling them at compile-time since SQLite still must do a test of a boolean variable to see if mutexes are enabled or disabled at each point where a mutex might be required. But there is still a performance advantage for disabling mutexes at run-time.</source>
          <target state="translated">SQLite는 여전히 뮤텍스가 필요한 각 지점에서 뮤텍스가 활성화 또는 비활성화되었는지 확인하기 위해 부울 변수를 테스트해야하기 때문에 런타임에 뮤텍스를 비활성화하는 것은 컴파일 타임에 뮤텍스를 비활성화하는 것만 큼 효과적이지 않습니다. 그러나 런타임에 뮤텍스를 비활성화하면 여전히 성능 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="db38b8db0ff11ad2083b7f6905b27367bbd64018" translate="yes" xml:space="preserve">
          <source>Disallow &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; in the &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt; of triggers and views. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</source>
          <target state="translated">트리거 및 뷰 의 &lt;a href=&quot;lang_with&quot;&gt;WITH 절&lt;/a&gt; 에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 허용하지 않습니다 . 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/b918d4b4e546d&quot;&gt;b918d4b4e546d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a4f5b6881f751cbf37ca7be8a10d5fc1ce5e931" translate="yes" xml:space="preserve">
          <source>Disallow control characters inside of strings in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551&lt;/a&gt;.</source>
          <target state="translated">JSON에서 문자열 내부의 제어 문자를 허용하지 않습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6c9b5514077fed34551&quot;&gt;6c9b5514077fed34551에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="4fbe5a75e7ecac67d383efc523453d8ca0e96ce9" translate="yes" xml:space="preserve">
          <source>Disallow leading zeros in numeric constants in JSON. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt;.</source>
          <target state="translated">JSON에서 숫자 상수에서 선행 0을 허용하지 않습니다. &lt;a href=&quot;https://www.sqlite.org/src/info/b93be8729a895a528e2&quot;&gt;b93be8729a895a528e2&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="2630cbc2f1d0549bdb067048921921ca0d31c770" translate="yes" xml:space="preserve">
          <source>Disallow temporary indices on permanent tables.</source>
          <target state="translated">영구 테이블에서 임시 인덱스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5acb0a0adde49aba96e6fc288d48b3950eb87672" translate="yes" xml:space="preserve">
          <source>Disallow the use of &quot;rowid&quot; in &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에서 &quot;rowid&quot;를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="664d42cee9dc2838800ae0429fea3975df123ee1" translate="yes" xml:space="preserve">
          <source>Disallow the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; in the recursive part of a CTE. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</source>
          <target state="translated">CTE의 재귀 부분에서 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 을 사용할 수 없습니다 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/e8275b415a2f03bee&quot;&gt;e8275b415a2f03bee&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="268c696f729a3bb7208ee6e45627908c164ce6fd" translate="yes" xml:space="preserve">
          <source>Disclose wrongful thoughts to your spiritual mentor.</source>
          <target state="translated">영적 멘토에게 잘못된 생각을 공개하십시오.</target>
        </trans-unit>
        <trans-unit id="df353315b1ac203fbf0fbde5acfa1d6dd139f099" translate="yes" xml:space="preserve">
          <source>Discontinue the use of posix_fallocate() on unix, as it does not work on all filesystems.</source>
          <target state="translated">모든 파일 시스템에서 작동하지 않으므로 유닉스에서 posix_fallocate () 사용을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="630ed0127b8c49cb6701137391eeab0c764d29db" translate="yes" xml:space="preserve">
          <source>Discontinue the use of thread-specific data for out-of-memory exception handling</source>
          <target state="translated">메모리 부족 예외 처리에 스레드 특정 데이터 사용 중단</target>
        </trans-unit>
        <trans-unit id="dc4ca73be659333abaa3afecb8d712a96bb9f569" translate="yes" xml:space="preserve">
          <source>Disk I/O operations tends to be more sequential using WAL.</source>
          <target state="translated">디스크 I / O 작업은 WAL을 사용하여보다 순차적 인 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="875cf7c3c58abcb6b2af3c59e6f41f8c4ce9ca26" translate="yes" xml:space="preserve">
          <source>Distinctive Features Of SQLite</source>
          <target state="translated">SQLite의 특징</target>
        </trans-unit>
        <trans-unit id="f327b00a868bc2fc77c6168d0e2d509cf7d8a51a" translate="yes" xml:space="preserve">
          <source>Diverse content which might otherwise be stored as a &quot;pile-of-files&quot; is encapsulated into a single disk file for simpler transport via scp/ftp, USB stick, and/or email attachment.</source>
          <target state="translated">&quot;파일의 파일&quot;로 저장 될 수있는 다양한 컨텐츠는 scp / ftp, USB 스틱 및 / 또는 이메일 첨부 파일을 통한보다 간단한 전송을 위해 단일 디스크 파일로 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="104ed7c21cfc9b8ba11824e5729cef81f421e172" translate="yes" xml:space="preserve">
          <source>Divide</source>
          <target state="translated">Divide</target>
        </trans-unit>
        <trans-unit id="6a4bfffd32ff9d65b9739b01f6b92d5a2a406ec8" translate="yes" xml:space="preserve">
          <source>Divide the value in register P1 by the value in register P2 and store the result in register P3 (P3=P2/P1). If the value in register P1 is zero, then the result is NULL. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값을 레지스터 P2의 값으로 나누고 결과를 레지스터 P3에 저장합니다 (P3 = P2 / P1). 레지스터 P1의 값이 0이면 결과는 NULL입니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="45a5d54bca163767dafad34692c5f65f7f63e81e" translate="yes" xml:space="preserve">
          <source>Do a better job of detecting missing, incomplete, and/or dodgy &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; data and generates good query plans in spite of the misinformation.</source>
          <target state="translated">누락, 불완전 및 / 또는 잘못된 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; 데이터를 더 잘 감지 하고 잘못된 정보에도 불구하고 좋은 쿼리 계획을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4bd6c15a025907299e44072515501d69283cf065" translate="yes" xml:space="preserve">
          <source>Do an analysis of the currently open database. Store in register P1 the text of an error message describing any problems. If no problems are found, store a NULL in register P1.</source>
          <target state="translated">현재 열려있는 데이터베이스를 분석하십시오. 문제를 설명하는 오류 메시지의 텍스트를 레지스터 P1에 저장하십시오. 문제가 없으면 레지스터 P1에 NULL을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="b58dc41668bbf2d2a5ac0f7843e60d1fd0b29a30" translate="yes" xml:space="preserve">
          <source>Do full-table scans using covering indices when possible, under the theory that an index will be smaller and hence can be scanned with less I/O.</source>
          <target state="translated">인덱스가 더 작아서 적은 I / O로 스캔 할 수 있다는 이론 하에서 가능하면 커버링 인덱스를 사용하여 전체 테이블 스캔을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d61e75c7c6aa57e44ccfb36bea2e0d2cd4826003" translate="yes" xml:space="preserve">
          <source>Do no wrong to anyone, and bear patiently wrongs done to yourself.</source>
          <target state="translated">누구에게도 잘못하지 말고, 자신에게 행한 참을성있는 잘못을 감당하십시오.</target>
        </trans-unit>
        <trans-unit id="c7acd87886221e65424bf1acce3086f3655acf30" translate="yes" xml:space="preserve">
          <source>Do not allocate a new page. Return NULL.</source>
          <target state="translated">새 페이지를 할당하지 마십시오. NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1baafbd29f15f73b5db2bd55006fe595ca88606" translate="yes" xml:space="preserve">
          <source>Do not allow dot-commands of the command-line shell to occur in the middle of a real SQL command.</source>
          <target state="translated">실제 SQL 명령 중에 명령 행 쉘의 도트 명령이 발생하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="722464d20a4d3822872080ca5426f1791b661a71" translate="yes" xml:space="preserve">
          <source>Do not apply the WHERE-clause pushdown optimization on terms that originate in the ON or USING clause of a LEFT JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN의 ON 또는 USING 절에서 시작된 용어에 대해서는 WHERE 절 푸시 다운 최적화를 적용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c2a19d81652f40568c&quot;&gt;c2a19d81652f40568c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="9e626f7dec3803cf39b9ed3c8d4b8ddd26aa3a01" translate="yes" xml:space="preserve">
          <source>Do not apply the flattening optimization if the outer query is an aggregate and the inner query contains ORDER BY. (Ticket #2943)</source>
          <target state="translated">외부 쿼리가 집계이고 내부 쿼리에 ORDER BY가 포함 된 경우 병합 최적화를 적용하지 마십시오. (티켓 # 2943)</target>
        </trans-unit>
        <trans-unit id="47f951dc04aa5e685ae032b56eb35642da21ee4e" translate="yes" xml:space="preserve">
          <source>Do not attempt to use terms from the WHERE clause to enable indexed lookup of the right-hand table of a LEFT JOIN. Ticket &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</source>
          <target state="translated">LEFT JOIN의 오른쪽 테이블을 인덱스로 조회 할 수 있도록 WHERE 절에서 용어를 사용하지 마십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/4ba5abf65c5b0f9a96a7a&quot;&gt;4ba5abf65c5b0f9a96a7a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb440372f32dec89b9398b09a9e6e2779b9db126" translate="yes" xml:space="preserve">
          <source>Do not attempt to use the strchrnul() function from the standard C library unless the HAVE_STRCHRNULL compile-time option is set.</source>
          <target state="translated">HAVE_STRCHRNULL 컴파일 시간 옵션이 설정되어 있지 않으면 표준 C 라이브러리에서 strchrnul () 함수를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b64adffd7b86aaa3092ff02c70021235bc894300" translate="yes" xml:space="preserve">
          <source>Do not be afraid to explore and experiment. Without a log-in you won't be able to push back any changes you make, so you cannot damage the project.</source>
          <target state="translated">탐험하고 실험하는 것을 두려워하지 마십시오. 로그인하지 않으면 변경 사항을 되돌릴 수 없으므로 프로젝트를 손상시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d05159095924dcadc1e25110c5f5f929ebba2a2a" translate="yes" xml:space="preserve">
          <source>Do not be confused by the fact that a column might have a &quot;numeric&quot; datatype. This does not mean that the column can contain only numbers. It merely means that if the column does contain a number, that number will sort in numerical order.</source>
          <target state="translated">열에 &quot;숫자&quot;데이터 유형이있을 수 있으므로 혼동하지 마십시오. 이것은 열에 숫자 만 포함될 수 있음을 의미하지는 않습니다. 이는 열에 숫자가 포함 된 경우 해당 숫자가 숫자 순서로 정렬됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b5c9cbefc6ca63f2b182857e9018d39b28c3534" translate="yes" xml:space="preserve">
          <source>Do not be misled by the &quot;Lite&quot; in the name. SQLite has a full-featured SQL implementation, including:</source>
          <target state="translated">이름에서 &quot;Lite&quot;로 오해하지 마십시오. SQLite에는 다음을 포함한 모든 기능을 갖춘 SQL 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ad576ed2750422c0fb9b979bec85d0e4fc99e1" translate="yes" xml:space="preserve">
          <source>Do not bear false witness.</source>
          <target state="translated">거짓 증거를하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dc340a536129d864cf116ede217fe057492374c8" translate="yes" xml:space="preserve">
          <source>Do not become attached to pleasures.</source>
          <target state="translated">즐거움에 집착하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="47541d37d26b95f8c181a2dc345a039022162ef4" translate="yes" xml:space="preserve">
          <source>Do not commit adultery.</source>
          <target state="translated">간음하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0527e2ce52914545d104d45569846431699a53a2" translate="yes" xml:space="preserve">
          <source>Do not confuse automatic indexes with the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; (having names like &quot;sqlite_autoindex_</source>
          <target state="translated">자동 색인과 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 색인을&lt;/a&gt; 혼동하지 마십시오 (예 : &quot;sqlite_autoindex_</target>
        </trans-unit>
        <trans-unit id="5b87dbbc2f82f39fe5e094dea4061b8791b8238e" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그를 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = NORMAL 및 &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = FULL 설정 과 혼동하지 마십시오 . &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;동기 프라그는&lt;/a&gt; xSync VFS 메소드 호출이 발생할 때 결정하고, 모든 플랫폼에 걸쳐 균일하게 적용된다. SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그는 동기화 작업이 얼마나 활기차고 엄격하거나 강력한 지 결정하며 기본 SQLite 코드에 대해 Mac OSX에서만 차이를 만듭니다. (타사 VFS 구현은 SQLITE_SYNC_NORMAL과 SQLITE_SYNC_FULL을 구별 할 수도 있지만 SQLite가 기본적으로 지원하는 운영 체제 중에서는 Mac OSX 만 차이에 신경을 씁니다.)</target>
        </trans-unit>
        <trans-unit id="002e1751e184528adf8c6f1d702e80e85446806a" translate="yes" xml:space="preserve">
          <source>Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=NORMAL and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt;=FULL settings. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt; determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)</source>
          <target state="translated">SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그를 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = NORMAL 및 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; = FULL 설정 과 혼동하지 마십시오 . &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;동기 프라그는&lt;/a&gt; xSync VFS 메소드 호출이 발생할 때 결정하고, 모든 플랫폼에 걸쳐 균일하게 적용된다. SQLITE_SYNC_NORMAL 및 SQLITE_SYNC_FULL 플래그는 동기화 작업이 얼마나 활기차고 엄격하거나 강력한 지 결정하며 기본 SQLite 코드에 대해 Mac OSX에서만 차이를 만듭니다. (타사 VFS 구현은 SQLITE_SYNC_NORMAL과 SQLITE_SYNC_FULL을 구별 할 수도 있지만 SQLite가 기본적으로 지원하는 운영 체제 중에서는 Mac OSX 만 차이에 신경을 씁니다.)</target>
        </trans-unit>
        <trans-unit id="ad2017a368e4acba6381b0a256f7226272260dc0" translate="yes" xml:space="preserve">
          <source>Do not count rows where the IGNORE conflict resolution occurs in the row count.</source>
          <target state="translated">행 수에서 IGNORE 충돌 해결이 발생한 행은 계산하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b7c755ee6b849cdf60ae59e908ab1fc867a27494" translate="yes" xml:space="preserve">
          <source>Do not covet.</source>
          <target state="translated">탐 내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="db62bb840a97eee5b8883ebcef3e582e3e673f43" translate="yes" xml:space="preserve">
          <source>Do not curse those who curse you, but rather bless them.</source>
          <target state="translated">당신을 저주하는 사람들을 저주하지 말고 축복하십시오.</target>
        </trans-unit>
        <trans-unit id="2d234151c3e9c3911335b0f3da32177b2942f1e3" translate="yes" xml:space="preserve">
          <source>Do not do to another what you would not have done to yourself.</source>
          <target state="translated">자신에게하지 않았던 일을 다른 사람에게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="acd5314ee2a0e4064ce9351ca89b05b07641e78e" translate="yes" xml:space="preserve">
          <source>Do not enable memory-mapped I/O. In other words, make sure that &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size=0&lt;/a&gt;.</source>
          <target state="translated">메모리 매핑 된 I / O를 활성화하지 마십시오. 즉, &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size = 0&lt;/a&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="034edd930627c1bd6308a4139c12b6665fcb2787" translate="yes" xml:space="preserve">
          <source>Do not entertain deceit in your heart.</source>
          <target state="translated">당신의 마음 속에 속임수를 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="81fd74cab483c5a336f294ba599bad0042897a37" translate="yes" xml:space="preserve">
          <source>Do not escape the backslash '\' character in the output of the &lt;b&gt;sqlite&lt;/b&gt; command-line access program.</source>
          <target state="translated">&lt;b&gt;sqlite&lt;/b&gt; 명령 행 액세스 프로그램 의 출력에서 ​​백 슬래시 '\'문자를 이스케이프하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c890cde5441c19e16767be21e8b596d667fd4a4d" translate="yes" xml:space="preserve">
          <source>Do not even call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on a database connection from a child process if the connection was opened in the parent. It is safe to close the underlying file descriptor, but the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; interface might invoke cleanup activities that will delete content out from under the parent, leading to errors and perhaps even database corruption.</source>
          <target state="translated">부모에서 연결이 열린 경우 자식 프로세스의 데이터베이스 연결에서 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 마십시오 . 기본 파일 디스크립터를 닫는 것이 안전하지만 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 인터페이스는 정리 활동을 호출하여 상위에서 컨텐츠를 삭제하여 오류 및 데이터베이스 손상을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9842d9ca1b62003346b1050ca3868a78c6e6df5b" translate="yes" xml:space="preserve">
          <source>Do not flush the page cache (and thus avoiding a cache refill) unless another process changes the underlying database file.</source>
          <target state="translated">다른 프로세스가 기본 데이터베이스 파일을 변경하지 않는 한 페이지 캐시를 플러시 (캐시 리필하지 않도록)하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2176e7264952425c2f250491ec533bbb7089a674" translate="yes" xml:space="preserve">
          <source>Do not forsake charity.</source>
          <target state="translated">자선 단체를 버리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bca45f5adbe0136828b61d27215211c39ce6b83c" translate="yes" xml:space="preserve">
          <source>Do not give a false peace.</source>
          <target state="translated">거짓 평화를주지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0fe47eb7b363d5a152896bf66373bc2d500a51a8" translate="yes" xml:space="preserve">
          <source>Do not give way to anger.</source>
          <target state="translated">화를 내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3d1cede4ac2a286b898864b92bb8c0cd08137e3b" translate="yes" xml:space="preserve">
          <source>Do not love much or boisterous laughter.</source>
          <target state="translated">많은 웃음을 사랑하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3c45d126a4940542085bf1e96a3ac522f5385ee4" translate="yes" xml:space="preserve">
          <source>Do not love much talking.</source>
          <target state="translated">많은 말을 좋아하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="68cc3d30139a8559e135cd4c8f558235d11abccb" translate="yes" xml:space="preserve">
          <source>Do not love quarreling.</source>
          <target state="translated">다툼을 좋아하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="629a7228998a89704c92b419f13085418997b310" translate="yes" xml:space="preserve">
          <source>Do not misunderstand: There is nothing technically wrong with displaying the error logger messages to end users. The messages do not contain sensitive or private information that must be protected from unauthorized viewing. Rather the messages are technical in nature and are not useful or meaningful to the typical end user. The messages coming from the error logger are intended for database geeks. Display them accordingly.</source>
          <target state="translated">오해하지 마십시오. 최종 사용자에게 오류 로거 메시지를 표시하는 데 기술적으로 잘못된 것은 없습니다. 메시지에는 무단으로 보지 않도록 보호해야하는 민감한 정보 나 개인 정보가 포함되어 있지 않습니다. 오히려 메시지는 기술적 인 것이며 일반적인 최종 사용자에게는 유용하지 않습니다. 오류 로거에서 오는 메시지는 데이터베이스 전문가를위한 것입니다. 그에 따라 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8f8ddbae63c42651d375c0bd04cebf3413348f90" translate="yes" xml:space="preserve">
          <source>Do not murder.</source>
          <target state="translated">살인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1f35225b21f15dae6087ed7eeacb7e2fc8285c86" translate="yes" xml:space="preserve">
          <source>Do not nurse a grudge.</source>
          <target state="translated">원한을 간호하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0a1c640222a0771668990edc889cc0113169d8ac" translate="yes" xml:space="preserve">
          <source>Do not open an SQLite database connection, then fork(), then try to use that database connection in the child process. All kinds of locking problems will result and you can easily end up with a corrupt database. SQLite is not designed to support that kind of behavior. Any database connection that is used in a child process must be opened in the child process, not inherited from the parent.</source>
          <target state="translated">SQLite 데이터베이스 연결을 연 다음 fork ()를 사용하지 말고 하위 프로세스에서 해당 데이터베이스 연결을 사용하십시오. 모든 종류의 잠금 문제가 발생하여 데이터베이스가 손상 될 수 있습니다. SQLite는 이러한 종류의 동작을 지원하도록 설계되지 않았습니다. 하위 프로세스에서 사용되는 모든 데이터베이스 연결은 상위 프로세스에서 상속되지 않고 하위 프로세스에서 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="3df8aad94da73f8e621cafc5e1cbb5ccbe166028" translate="yes" xml:space="preserve">
          <source>Do not put write locks on the file used to hold TEMP tables.</source>
          <target state="translated">TEMP 테이블을 보유하는 데 사용되는 파일에 쓰기 잠금을 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="167222828b6a7323e00470f04ccff91439f97f91" translate="yes" xml:space="preserve">
          <source>Do not read in the (meaningless) content of pages extracted from the freelist.</source>
          <target state="translated">자유 목록에서 추출 된 페이지의 (의미없는) 내용을 읽지 마십시오.</target>
        </trans-unit>
        <trans-unit id="88443743067599e18c7d1c7b495b0aed7fcc56ac" translate="yes" xml:space="preserve">
          <source>Do not read the last page of an overflow chain when deleting the row - just add that page to the freelist.</source>
          <target state="translated">행을 삭제할 때 오버 플로우 체인의 마지막 페이지를 읽지 말고 해당 페이지를 자유 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a7d06580230b34d6f8a726d493bee6f3225055ed" translate="yes" xml:space="preserve">
          <source>Do not require commas between constraints in CREATE TABLE statements.</source>
          <target state="translated">CREATE TABLE 문에서 제한 조건 사이에 쉼표가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fc4941b3cd021627fe69bb109677c3c3d923f4e" translate="yes" xml:space="preserve">
          <source>Do not return evil for evil.</source>
          <target state="translated">악을 악으로 돌려 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="21dd78a660444cf8065985daa16f5a53b2b94b26" translate="yes" xml:space="preserve">
          <source>Do not steal.</source>
          <target state="translated">훔치지 마.</target>
        </trans-unit>
        <trans-unit id="ad5e34ebf9599545e50b3a0dc2ba3f44f88168b2" translate="yes" xml:space="preserve">
          <source>Do not store pages being deleted in the rollback journal.</source>
          <target state="translated">롤백 저널에서 삭제중인 페이지를 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4db470ddd81b2b754811d69f10c92e79bba57171" translate="yes" xml:space="preserve">
          <source>Do not swear, for fear of perjuring yourself.</source>
          <target state="translated">자신을 다치게 할까봐 맹세하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ec7cd9078e5c61634a562846d1cb709ab20d0358" translate="yes" xml:space="preserve">
          <source>Do not use a partial index to do a table scan on an IN operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt;.</source>
          <target state="translated">IN 연산자에서 테이블 스캔을 수행하기 위해 부분 인덱스를 사용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/1d958d90596593a774&quot;&gt;1d958d90596593a774&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20680b9a624f1f557a55b0811ddc984091848e37" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; for a sub-query on the RHS of a LEFT JOIN if that subquery reads data from a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; as doing so prevents the query planner from creating &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the results of the sub-query, which can slow down the query.</source>
          <target state="translated">하위 쿼리가 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 데이터를 읽을 때 쿼리 플래너 가 하위 쿼리의 결과에 대해 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱스&lt;/a&gt; 를 작성하지 못하게하는 경우 하위 쿼리의 RHS에서 하위 쿼리에 대한 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 를 사용하지 마십시오. 검색어를</target>
        </trans-unit>
        <trans-unit id="f5a36cf13f2d75f5b1d063cbaf3e6dabed9e5e96" translate="yes" xml:space="preserve">
          <source>Do not wish to be called holy before one is holy; but first to be holy, that you may be truly so called.</source>
          <target state="translated">거룩하기 전에 거룩하게되기를 원하지 마십시오. 그러나 먼저 거룩 해져서 진정으로 그렇게 부름받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5969cbceed42549abcad3776ee3d2a22161ed52f" translate="yes" xml:space="preserve">
          <source>Do not write changes to standard output. Instead, write a (binary) changeset file into FILE. The changeset can be interpreted using the sessions extension to SQLite.</source>
          <target state="translated">표준 출력에 변경 사항을 쓰지 마십시오. 대신 (이진) 변경 세트 파일을 FILE에 작성하십시오. 변경 세트는 세션 확장을 SQLite로 사용하여 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab50d236c22af4547ec015790d6040a4642e45e" translate="yes" xml:space="preserve">
          <source>Do nothing. This instruction is often useful as a jump destination.</source>
          <target state="translated">아무것도하지 마세요. 이 명령어는 종종 점프 대상으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19eb9de9fe2776c399eac9b123129daec5f5dd94" translate="yes" xml:space="preserve">
          <source>Document Lists And Indexes</source>
          <target state="translated">문서 목록 및 색인</target>
        </trans-unit>
        <trans-unit id="8c461e6b3d5184a9059cf94be86da7dbc747e4cf" translate="yes" xml:space="preserve">
          <source>Document Structure</source>
          <target state="translated">문서 구조</target>
        </trans-unit>
        <trans-unit id="3a469072b5974a6ac1b0b86818461b57cc048dea" translate="yes" xml:space="preserve">
          <source>Document the hazards of type conversions in &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt; and related APIs. Fix unnecessary type conversions. Ticket #2321.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_blob ()&lt;/a&gt; 및 관련 API 에서 유형 변환의 위험성을 문서화하십시오 . 불필요한 유형 변환을 수정하십시오. 티켓 # 2321.</target>
        </trans-unit>
        <trans-unit id="28ddcac222be4dd54f888cc20f015c092a5e040c" translate="yes" xml:space="preserve">
          <source>Document versioning</source>
          <target state="translated">문서 버전 관리</target>
        </trans-unit>
        <trans-unit id="fe7304ab51248437db8b4b66ad9ad43f8b781a02" translate="yes" xml:space="preserve">
          <source>Documentation updates</source>
          <target state="translated">설명서 업데이트</target>
        </trans-unit>
        <trans-unit id="e7eabf63bf0b622355ee7928fc5a397625e241a7" translate="yes" xml:space="preserve">
          <source>Documentation updates and typo fixes</source>
          <target state="translated">설명서 업데이트 및 오타 수정</target>
        </trans-unit>
        <trans-unit id="b3606774842986999d74ead8587f30081f764162" translate="yes" xml:space="preserve">
          <source>Documentation updates.</source>
          <target state="translated">설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="b4f8a8a7e46cd0f4bef297d6b523710d4bbf11e1" translate="yes" xml:space="preserve">
          <source>Documentation updates. Mostly fixing of typos and spelling errors.</source>
          <target state="translated">설명서 업데이트. 대부분 오타 및 철자 오류 수정.</target>
        </trans-unit>
        <trans-unit id="2014de1c64e4558d3e684536a5eead31d8646480" translate="yes" xml:space="preserve">
          <source>Documented support for the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt;. This feature has actually been in the code since &lt;a href=&quot;#version_3_7_9&quot;&gt;version 3.7.9&lt;/a&gt; but is only now considered to be officially supported.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 컨텐츠 옵션에&lt;/a&gt; 대한 문서화 된 지원 . 이 기능은 실제로 &lt;a href=&quot;#version_3_7_9&quot;&gt;버전 3.7.9&lt;/a&gt; 부터 코드에 포함 되었지만 현재 공식적으로 지원되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1141953a3cac893e565c0cb7afc09130be28d815" translate="yes" xml:space="preserve">
          <source>Does SQLite support a BLOB type?</source>
          <target state="translated">SQLite는 BLOB 유형을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="d7ac8ab68849b9ef0f13b08bdcc3c9b49215d5ba" translate="yes" xml:space="preserve">
          <source>Does SQLite support foreign keys?</source>
          <target state="translated">SQLite는 외래 키를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="e2a8b45f99cb6f35744147d23ba67820b9196a7e" translate="yes" xml:space="preserve">
          <source>Does not support ZIP archives that span multiple files.</source>
          <target state="translated">여러 파일에 걸쳐있는 ZIP 아카이브는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f67d427a021b49d829af064322fcd164d0d520fe" translate="yes" xml:space="preserve">
          <source>Does not support encryption.</source>
          <target state="translated">암호화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a182c94fa152e112192c0491165a8fdd3fd894bc" translate="yes" xml:space="preserve">
          <source>Does not support zip64 extensions.</source>
          <target state="translated">zip64 확장자를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="266906722673b9d89a70b9366dca968b0e3c9bf4" translate="yes" xml:space="preserve">
          <source>Dot-commands do not recognize comments.</source>
          <target state="translated">점 명령은 주석을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8a31aee94d3aa206ec99f016bf029e559e48bfac" translate="yes" xml:space="preserve">
          <source>Dot-file locking style. This locking style is used when neither flock nor POSIX locking styles are supported by the file system. Database locks are obtained by creating and entry in the file-system at a well-known location relative to the database file (a &quot;dot-file&quot;) and relinquished by deleting the same file.</source>
          <target state="translated">도트 파일 잠금 스타일. 이 잠금 스타일은 파일 시스템에서 무리 또는 POSIX 잠금 스타일을 지원하지 않을 때 사용됩니다. 데이터베이스 잠금은 데이터베이스 파일과 관련하여 잘 알려진 위치 ( &quot;도트 파일&quot;)에서 파일 시스템을 작성하고 항목을 입력하여 얻어지며 동일한 파일을 삭제하여 포기합니다.</target>
        </trans-unit>
        <trans-unit id="5886a74b53398ec47ad06e2d60de33d78d94131a" translate="yes" xml:space="preserve">
          <source>Double-Quoted Strings Allowed</source>
          <target state="translated">이중 인용 문자열 허용</target>
        </trans-unit>
        <trans-unit id="9527eaee4dc6adf69520b29f63dfd254ba6893eb" translate="yes" xml:space="preserve">
          <source>Double-quoted strings interpreted as column names not text literals.</source>
          <target state="translated">큰 따옴표로 묶인 문자열은 텍스트 리터럴이 아닌 열 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ffe7363e8f5e47f6d5cff2a021a49b0ba15973c3" translate="yes" xml:space="preserve">
          <source>Download The Code</source>
          <target state="translated">코드 다운로드</target>
        </trans-unit>
        <trans-unit id="2bf81ffb06a97ae87b64f9122c76cd7ce2c19062" translate="yes" xml:space="preserve">
          <source>Download the self-contained Fossil executable from &lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; and put the executable somewhere on your $PATH.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/fossil/uv/download.html&quot;&gt;https://fossil-scm.org/fossil/uv/download.html&lt;/a&gt; 에서 자체 포함 된 Fossil 실행 파일을 다운로드 하여 $ PATH의 어딘가에 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="bf164a21eb062e18af9a991c052f3c70484a26df" translate="yes" xml:space="preserve">
          <source>Dozens of minor bug fixes</source>
          <target state="translated">수십 가지 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="a929098ee87888960431567bedaf2f19daf292b0" translate="yes" xml:space="preserve">
          <source>Drop all support for the &lt;a href=&quot;malloc#memsysx&quot;&gt;experimental memory allocators&lt;/a&gt; memsys4 and memsys6.</source>
          <target state="translated">&lt;a href=&quot;malloc#memsysx&quot;&gt;실험 메모리 할당 자&lt;/a&gt; memsys4 및 memsys6에 대한 모든 지원을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="1f3f7deb8c2edee3371b95381860beff36c9b366" translate="yes" xml:space="preserve">
          <source>Drop built-in support for OS/2. If you need to upgrade an OS/2 application to use this or a later version of SQLite, then add an application-defined &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface. The code removed in this release can serve as a baseline for the application-defined VFS.</source>
          <target state="translated">OS / 2에 대한 기본 제공 지원. 이 버전 또는 이후 버전의 SQLite를 사용하기 위해 OS / 2 애플리케이션을 업그레이드해야하는 경우 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 애플리케이션 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 추가하십시오 . 이 릴리스에서 제거 된 코드는 응용 프로그램 정의 VFS의 기준으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e9878b7430ec40bb0aac87c5455cd33a663347" translate="yes" xml:space="preserve">
          <source>Drop old table</source>
          <target state="translated">이전 테이블 삭제</target>
        </trans-unit>
        <trans-unit id="831cee7fe7313360794c461d24e27019d0aa0fa8" translate="yes" xml:space="preserve">
          <source>Drop support for SQLITE_ENABLE_TREE_EXPLAIN. The SELECTTRACE mechanism provides more useful diagnostics information.</source>
          <target state="translated">SQLITE_ENABLE_TREE_EXPLAIN에 대한 삭제 지원. SELECTTRACE 메커니즘은보다 유용한 진단 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0bd2f0f029e99d0a73743bc173e5b08aa4ae2984" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks but retain the SHARED lock.</source>
          <target state="translated">독점 잠금 및 보류 잠금을 제거하고 공유 잠금을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="cece823a856676f78f4a41646b3bcd314a06e9ba" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from all database files.</source>
          <target state="translated">모든 데이터베이스 파일에서 독점 및 보류 잠금을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="41ede7277f5fa3c98b30f351e4b2a0728bbb7eac" translate="yes" xml:space="preserve">
          <source>Drop the EXCLUSIVE and PENDING locks from the database file.</source>
          <target state="translated">데이터베이스 파일에서 EXCLUSIVE 및 PENDING 잠금을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="daced6c943d50569fdbed0b8c852df4819f96d8b" translate="yes" xml:space="preserve">
          <source>Drop the old table X: &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X&lt;/a&gt;.</source>
          <target state="translated">이전 테이블 X : &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE X를&lt;/a&gt; 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e57de85bbf5c15a59892ff50c8f7c01032ec317" translate="yes" xml:space="preserve">
          <source>DropIndex</source>
          <target state="translated">DropIndex</target>
        </trans-unit>
        <trans-unit id="4a8749bce90b847b8afa8914da8c1204a28e572c" translate="yes" xml:space="preserve">
          <source>DropTable</source>
          <target state="translated">DropTable</target>
        </trans-unit>
        <trans-unit id="5194da2ad6f6b74ff6082f247ce4ac8437a9ce02" translate="yes" xml:space="preserve">
          <source>DropTrigger</source>
          <target state="translated">DropTrigger</target>
        </trans-unit>
        <trans-unit id="e5c413032a9c5e630e19fe262e62d7fb21ec3a73" translate="yes" xml:space="preserve">
          <source>Dropped support for the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 컴파일 타임 옵션에 대한 지원이 중단되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3d8ac8b86a476ff206c2f789a4c49e5873137fba" translate="yes" xml:space="preserve">
          <source>Due to an historical oversight, columns named in the &quot;UPDATE OF&quot; clause do not actually have to exist in the table being updated. Unrecognized column names are silently ignored. It would be more helpful if SQLite would fail the CREATE TRIGGER statement if any of the names in the &quot;UPDATE OF&quot; clause are not columns in the table. However, as this problem was discovered many years after SQLite was widely deployed, we have resisted fixing the problem for fear of breaking legacy applications.</source>
          <target state="translated">과거의 감독으로 인해 &quot;UPDATE OF&quot;절에 명명 된 열이 실제로 업데이트되는 테이블에 존재할 필요는 없습니다. 인식 할 수없는 열 이름은 자동으로 무시됩니다. &quot;UPDATE OF&quot;절의 이름이 테이블의 열이 아닌 경우 SQLite가 CREATE TRIGGER 문에 실패하면 더 유용합니다. 그러나이 문제는 SQLite가 널리 배포 된 지 수년 후에 발견 되었기 때문에 레거시 응용 프로그램이 손상 될 수 있다는 두려움 때문에 문제 해결에 저항했습니다.</target>
        </trans-unit>
        <trans-unit id="13fc6ee3a5aa40fdb0e1d5ecf732cd2ab210b40a" translate="yes" xml:space="preserve">
          <source>Duplicate ephemeral cursors are used for self-joins of materialized views.</source>
          <target state="translated">중복 된 임시 커서는 구체화 된 뷰의 자체 조인에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22bb6bc640d9e76642a03f301228df50bc0c544a" translate="yes" xml:space="preserve">
          <source>Duplicate row returned on a query against a table with more than 16 indices, each on a separate column, and all used via OR-connected constraints. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</source>
          <target state="translated">16 개 이상의 인덱스 (각각 별도 열에 있음)가있는 테이블에 대해 쿼리에서 중복 행이 반환되었으며 모두 OR 연결 제약 조건을 통해 사용되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/10fb063b11&quot;&gt;10fb063b11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93d7730f8826a2d54d04e212d85d32152f0ff3ce" translate="yes" xml:space="preserve">
          <source>During a transaction, SQLite stores additional information in a second file called the &quot;rollback journal&quot;, or if SQLite is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, a write-ahead log file.</source>
          <target state="translated">트랜잭션 중에 SQLite는 추가 정보를 &quot;롤백 저널&quot;이라는 두 번째 파일에 저장하거나 SQLite가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 인 경우 미리 쓰기 로그 파일입니다.</target>
        </trans-unit>
        <trans-unit id="d30f21585fed5c23f99fb922e9805bc00a1eabdf" translate="yes" xml:space="preserve">
          <source>During a transaction, some of the data written to an FTS table may be cached in memory and written to the database only when the transaction is committed. However the implementation of the fts4aux module is only able to read data from the database. In practice this means that if an fts4aux table is queried from within a transaction in which the associated FTS table has been modified, the results of the query are likely to reflect only a (possibly empty) subset of the changes made.</source>
          <target state="translated">트랜잭션 중에 FTS 테이블에 기록 된 일부 데이터는 트랜잭션이 커밋 된 경우에만 메모리에 캐시되고 데이터베이스에 기록 될 수 있습니다. 그러나 fts4aux 모듈의 구현은 데이터베이스에서 데이터를 읽을 수만 있습니다. 실제로 이는 관련 FTS 테이블이 수정 된 트랜잭션 내에서 fts4aux 테이블을 쿼리하면 쿼리 결과에 변경 사항 중 일부만 반영 될 가능성이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad42e3b2740327c2dba977f94946673b656caef3" translate="yes" xml:space="preserve">
          <source>During most testing, however, these macros will throw an assertion fault if their argument does not have the expected truth value. This alerts the developers quickly to incorrect design assumptions.</source>
          <target state="translated">그러나 대부분의 테스트 중에 이러한 매크로는 인수에 예상되는 진리 값이 없으면 어설 션 오류가 발생합니다. 이는 개발자에게 잘못된 설계 가정을 신속하게 알립니다.</target>
        </trans-unit>
        <trans-unit id="12f7d01f7aef91494af4f6f7a834f78084a02691" translate="yes" xml:space="preserve">
          <source>During part of SQLite's INSERT and SELECT processing, the complete content of each row in the database is encoded as a single BLOB. So the SQLITE_MAX_LENGTH parameter also determines the maximum number of bytes in a row.</source>
          <target state="translated">SQLite의 INSERT 및 SELECT 처리 중에 데이터베이스에있는 각 행의 전체 내용이 단일 BLOB으로 인코딩됩니다. 따라서 SQLITE_MAX_LENGTH 매개 변수는 행의 최대 바이트 수를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="11df476623628b473251d2d86924a52d99a7ec80" translate="yes" xml:space="preserve">
          <source>During recovery of the global shared-memory WAL-index, exclusive locks are held on WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK, and WAL_READ_LOCK(1) through WAL_READ_LOCK(4). In other words, all locks associated with the WAL-index except for WAL_READ_LOCK(0) are held exclusively. This prevents any other thread from writing the database and from reading any transactions that are held in the WAL, until the recovery is complete.</source>
          <target state="translated">글로벌 공유 메모리 WAL 인덱스를 복구하는 동안 배타적 잠금은 WAL_WRITE_LOCK, WAL_CKPT_LOCK, WAL_RECOVER_LOCK 및 WAL_READ_LOCK (1)에서 WAL_READ_LOCK (4)까지 유지됩니다. 즉, WAL_READ_LOCK (0)을 제외한 WAL- 인덱스와 관련된 모든 잠금은 독점적으로 유지됩니다. 이렇게하면 복구가 완료 될 때까지 다른 스레드가 데이터베이스를 쓰거나 WAL에 보유 된 트랜잭션을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1358f8df690459d3328e508cecf523a429f80164" translate="yes" xml:space="preserve">
          <source>During testing, the SQLite library is compiled with special instrumentation that allows the test scripts to simulate a wide variety of failures in order to verify that SQLite recovers correctly. Memory allocation is carefully tracked and no memory leaks occur, even following memory allocation failures. A custom VFS layer is used to simulate operating system crashes and power failures in order to ensure that transactions are atomic across these events. A mechanism for deliberately injecting I/O errors shows that SQLite is resilient to such malfunctions. (As an experiment, try inducing these kinds of errors on other SQL database engines and see what happens!)</source>
          <target state="translated">테스트 중에 SQLite 라이브러리는 특수 계측으로 컴파일되어 SQLite가 올바르게 복구되는지 테스트 스크립트가 다양한 실패를 시뮬레이션 할 수 있도록합니다. 메모리 할당은 신중하게 추적되며 메모리 할당 실패 후에도 메모리 누수가 발생하지 않습니다. 사용자 지정 VFS 계층은 이러한 이벤트에서 트랜잭션이 원 자성을 갖도록 운영 체제 충돌 및 정전을 시뮬레이션하는 데 사용됩니다. 의도적으로 I / O 오류를 주입하는 메커니즘은 SQLite가 이러한 오작동에 대해 탄력적이라는 것을 보여줍니다. 실험으로 다른 SQL 데이터베이스 엔진에서 이러한 종류의 오류를 유도하고 어떻게되는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="083eeb3cf3761acd0b9b1944cd026822ab96a1ec" translate="yes" xml:space="preserve">
          <source>During the 250 ms sleep in step 3 above, no read-lock is held on the database file and the mutex associated with pDb is not held. This allows other threads to use &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pDb and other connections to write to the underlying database file.</source>
          <target state="translated">위의 3 단계에서 250ms 절전 동안 데이터베이스 파일에 대한 읽기 잠금이 유지되지 않고 pDb와 관련된 뮤텍스가 유지되지 않습니다. 이것은 다른 스레드가 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pDb 를 사용 하고 다른 연결이 기본 데이터베이스 파일에 쓸 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5bc5d8e5dea4ffc98e00ec0c1ec074dd1e7d3ff2" translate="yes" xml:space="preserve">
          <source>During the conclusion of a</source>
          <target state="translated">의 결론 동안</target>
        </trans-unit>
        <trans-unit id="fe8ce31db6eecdb3f85f2298aa1ab49d66128d02" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation</source>
          <target state="translated">동적 메모리 할당</target>
        </trans-unit>
        <trans-unit id="720d5bb7b021bd57042c2b5aa6c65c1226f1ffcd" translate="yes" xml:space="preserve">
          <source>Dynamic Memory Allocation In SQLite</source>
          <target state="translated">SQLite의 동적 메모리 할당</target>
        </trans-unit>
        <trans-unit id="6a1ec417f9656bfa58ac913f9a623361c31817a1" translate="yes" xml:space="preserve">
          <source>Dynamic String Object</source>
          <target state="translated">동적 문자열 객체</target>
        </trans-unit>
        <trans-unit id="75da5571b32189815fa4662789976e48c0ca6b04" translate="yes" xml:space="preserve">
          <source>Dynamic analysis refers to internal and external checks on the SQLite code which are performed while the code is live and running. Dynamic analysis has proven to be a great help in maintaining the quality of SQLite.</source>
          <target state="translated">동적 분석은 코드가 작동하고 실행되는 동안 수행되는 SQLite 코드의 내부 및 외부 검사를 말합니다. 동적 분석은 SQLite의 품질을 유지하는 데 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a5cb0906656acf2bda3bc32fbfc18bd37f772de3" translate="yes" xml:space="preserve">
          <source>Dynamic and static analysis of the code</source>
          <target state="translated">코드의 동적 및 정적 분석</target>
        </trans-unit>
        <trans-unit id="758e372147a13eab85e0e2348816aeca5a5cf87b" translate="yes" xml:space="preserve">
          <source>Dynamically Typed Value Object</source>
          <target state="translated">동적으로 입력 된 값 개체</target>
        </trans-unit>
        <trans-unit id="dd5afbce0893bc1f40078bd68b471379645389da" translate="yes" xml:space="preserve">
          <source>EACH</source>
          <target state="translated">EACH</target>
        </trans-unit>
        <trans-unit id="bf4cc46f7f1441b1500c1ac4cef239d17020ff30" translate="yes" xml:space="preserve">
          <source>ELSE</source>
          <target state="translated">ELSE</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="79e27d141723fbb1d4275c9dc81bef88d08e1858" translate="yes" xml:space="preserve">
          <source>END TRANSACTION</source>
          <target state="translated">거래 종료</target>
        </trans-unit>
        <trans-unit id="4351e320e43aa32eebed42b35b21b2097a23c049" translate="yes" xml:space="preserve">
          <source>END TRANSACTION is an alias for COMMIT.</source>
          <target state="translated">END TRANSACTION은 COMMIT의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="01dce0e5ecf8d5b17ab6b7c1ca9a8662e220cefd" translate="yes" xml:space="preserve">
          <source>EPUB - The Electronic Publication format used by non-Kindle eBooks</source>
          <target state="translated">EPUB-Kindle 이외의 전자 책에서 사용하는 전자 출판 형식</target>
        </trans-unit>
        <trans-unit id="ac47189c9768197d8574c8f14988b8ef7e5d8f6d" translate="yes" xml:space="preserve">
          <source>ESCAPE</source>
          <target state="translated">ESCAPE</target>
        </trans-unit>
        <trans-unit id="c23142c6f147963dd2685f230238ef6772802e99" translate="yes" xml:space="preserve">
          <source>EXCEPT</source>
          <target state="translated">EXCEPT</target>
        </trans-unit>
        <trans-unit id="9cb33cc90a8a55873e7bc639c8e97e85186cc428" translate="yes" xml:space="preserve">
          <source>EXCLUDE</source>
          <target state="translated">EXCLUDE</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="e374cc411cf56ba9d22e8a8dfb723b4ab3e4424c" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE is similar to IMMEDIATE in that a write transaction is started immediately. EXCLUSIVE and IMMEDIATE are the same in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, but in other journaling modes, EXCLUSIVE prevents other database connections from reading the database while the transaction is underway.</source>
          <target state="translated">EXCLUSIVE는 쓰기 트랜잭션이 즉시 시작된다는 점에서 IMMEDIATE와 유사합니다. EXCLUSIVE와 IMMEDIATE는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서는 동일 하지만 다른 저널링 모드에서는 EXCLUSIVE는 트랜잭션이 진행되는 동안 다른 데이터베이스 연결이 데이터베이스를 읽지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="2fbf78b206db15c2139a66a9634e3bf1d2176ccc" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN</source>
          <target state="translated">쿼리 계획 설명</target>
        </trans-unit>
        <trans-unit id="38addf8721d2c74e08b308b7b8b2dd7a72f15eb2" translate="yes" xml:space="preserve">
          <source>EXPLAIN QUERY PLAN is most useful on a SELECT statement, but may also appear with other statements that read data from database tables (e.g. UPDATE, DELETE, INSERT INTO ... SELECT).</source>
          <target state="translated">EXPLAIN QUERY PLAN은 SELECT 문에서 가장 유용하지만 데이터베이스 테이블에서 데이터를 읽는 다른 문과 함께 나타날 수도 있습니다 (예 : UPDATE, DELETE, INSERT INTO ... SELECT).</target>
        </trans-unit>
        <trans-unit id="8e9da9a85266351f71e77f3e9609cc22715ef94e" translate="yes" xml:space="preserve">
          <source>EXPLAIN operates at run-time, not at prepare-time</source>
          <target state="translated">EXPLAIN은 준비 시간이 아닌 런타임에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="18fd69d15aa01be81ef0e1d97815be761eb30270" translate="yes" xml:space="preserve">
          <source>EXTRA synchronous is like FULL with the addition that the directory containing a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; is synced after that journal is unlinked to commit a transaction in DELETE mode. EXTRA provides additional durability if the commit is followed closely by a power loss.</source>
          <target state="translated">EXTRA 동기는 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널을&lt;/a&gt; 포함하는 디렉토리가 DELETE 모드에서 트랜잭션을 커미트하기 위해 링크 해제 된 후에 롤백 저널을 포함하는 디렉토리 가 동기화 된다는 점에서 FULL과 비슷 합니다. EXTRA는 커밋 뒤에 전력 손실이 발생할 경우 추가적인 내구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="483d2106efe09daa894eea6a0c9033d9a67cc38c" translate="yes" xml:space="preserve">
          <source>Each 5-byte entry on a ptrmap page provides back-link information about one of the pages that immediately follow the pointer map. If page B is a ptrmap page then back-link information about page B+1 is provided by the first entry on the pointer map. Information about page B+2 is provided by the second entry. And so forth.</source>
          <target state="translated">ptrmap 페이지의 각 5 바이트 항목은 포인터 맵 바로 뒤에 오는 페이지 중 하나에 대한 백 링크 정보를 제공합니다. 페이지 B가 ptrmap 페이지 인 경우 페이지 B + 1에 대한 백 링크 정보는 포인터 맵의 첫 번째 항목에 의해 제공됩니다. B + 2 페이지에 대한 정보는 두 번째 항목에 의해 제공됩니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="1aabd87ca95da90a5c129eaf9247506c8bd66646" translate="yes" xml:space="preserve">
          <source>Each 5-byte ptrmap entry consists of one byte of &quot;page type&quot; information followed by a 4-byte big-endian page number. Five page types are recognized:</source>
          <target state="translated">각 5 바이트 ptrmap 항목은 1 바이트의 &quot;페이지 유형&quot;정보와 4 바이트 빅 엔디안 페이지 번호로 구성됩니다. 5 가지 페이지 유형이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="9a01146dc5470d97274ce8927b43f8fec82d7371" translate="yes" xml:space="preserve">
          <source>Each DELETE change is changed to an INSERT, and</source>
          <target state="translated">각 DELETE 변경이 INSERT로 변경되고</target>
        </trans-unit>
        <trans-unit id="eeb9033e1e45a2bbbcad76e978600d892c37b372" translate="yes" xml:space="preserve">
          <source>Each INSERT change is changed to a DELETE, and</source>
          <target state="translated">각 INSERT 변경 사항은 DELETE로 변경되고</target>
        </trans-unit>
        <trans-unit id="7b99091b54756df2ed9f1a0564ab23ebb66063ec" translate="yes" xml:space="preserve">
          <source>Each ORDER BY expression is processed as follows:</source>
          <target state="translated">각 ORDER BY 표현식은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="90ec8a858058608d92c79ea2b4e9e7b9bbccd9eb" translate="yes" xml:space="preserve">
          <source>Each SQL index, whether explicitly declared via a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implied by a UNIQUE or PRIMARY KEY constraint, corresponds to an index b-tree in the database file. Each entry in the index b-tree corresponds to a single row in the associated SQL table. The key to an index b-tree is a record composed of the columns that are being indexed followed by the key of the corresponding table row. For ordinary tables, the row key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, and for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables the row key is the PRIMARY KEY. Because every row in the table has a unique row key, all keys in an index are unique.</source>
          <target state="translated">&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 통해 명시 적으로 선언 되었거나 UNIQUE 또는 PRIMARY KEY 제한 조건에 의해 암시 된 각 SQL 인덱스 는 데이터베이스 파일의 인덱스 b- 트리에 해당합니다. 인덱스 b- 트리의 각 항목은 연관된 SQL 테이블의 단일 행에 해당합니다. 인덱스 b- 트리의 키는 색인을 생성하는 열과 해당 테이블 행의 키로 구성된 레코드입니다. 일반 테이블의 경우 행 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 이고 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 경우 행 키는 PRIMARY KEY입니다. 테이블의 모든 행에는 고유 한 행 키가 있으므로 인덱스의 모든 키는 고유합니다.</target>
        </trans-unit>
        <trans-unit id="972d3bbdff7b7be08051158b4855057f49ea49cd" translate="yes" xml:space="preserve">
          <source>Each SQL statement in the statement list is an instance of the following:</source>
          <target state="translated">명령문 목록의 각 SQL 문은 다음의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="8780624428063f8d9d37cbf9ecae097671b04573" translate="yes" xml:space="preserve">
          <source>Each SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; records cases when the query planner would benefit from having accurate results of ANALYZE at hand. These records are held in memory and accumulate over the life of a database connection. The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command looks at those records and runs ANALYZE on only those tables for which new or updated ANALYZE data seems likely to be useful. In most cases &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; will not run ANALYZE, but it will occasionally do so either for tables that have never before been analyzed, or for tables that have grown significantly since they were last analyzed.</source>
          <target state="translated">각 SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 쿼리 플래너가 정확한 ANALYZE 결과를 얻을 수있는 경우를 기록합니다. 이러한 레코드는 메모리에 보관되며 데이터베이스 연결 수명 동안 누적됩니다. &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA 최적화&lt;/a&gt; 레코드 및 실행에서 명령 외모는 신규 또는 ANALYZE 업데이트 된 데이터가 유용 할 것으로 보인다있는 테이블 만에 분석 할 수 있습니다. 대부분의 경우 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 는 ANALYZE를 실행하지 않지만, 이전에 분석 한 적이없는 테이블 또는 마지막 분석 이후 크게 성장한 테이블에 대해 때때로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="830748b5154094e00d6f1556c43a3fc63fc4833c" translate="yes" xml:space="preserve">
          <source>Each VFS implementation will subclass the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; by adding additional fields at the end to hold whatever information the VFS needs to know about an open file. It does not matter what information is stored as long as the total size of the structure does not exceed the szOsFile value recorded in the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">각 VFS 구현은 VFS가 열린 파일에 대해 알아야하는 정보를 보유하기 위해 끝에 추가 필드를 추가 하여 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 을 서브 클래 싱 합니다. 구조의 전체 크기가 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트에 기록 된 szOsFile 값을 초과하지 않는 한 어떤 정보가 저장되는지는 중요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="096a69c85e04b646e0b565d9908edc0c892b7052" translate="yes" xml:space="preserve">
          <source>Each argument specified as part of a &quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot; statement is either a column declaration or a configuration option. A &lt;b&gt;column declaration&lt;/b&gt; consists of one or more whitespace separated FTS5 barewords or string literals quoted in any manner acceptable to SQLite.</source>
          <target state="translated">&quot;CREATE VIRTUAL TABLE ... USING fts5 ...&quot;문의 일부로 지정된 각 인수는 열 선언 또는 구성 옵션입니다. &lt;b&gt;열 선언&lt;/b&gt; SQLite는 받아 들일 수있는 방식으로 인용 FTS5 barewords 또는 문자열 리터럴 분리 공백 하나 이상의 구성.</target>
        </trans-unit>
        <trans-unit id="c100bec1aacd96fc583726f3228e69edd0918c29" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; affects subsequent database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Database connections that already exist are unaffected. Each call to &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; overrides all previous calls within the same process.</source>
          <target state="translated">를 호출 할 때마다 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache은 ()&lt;/a&gt; 이후의 데이터베이스 사용하여 작성된 연결에 영향을 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16를 ()&lt;/a&gt; , 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2을 ()&lt;/a&gt; . 이미 존재하는 데이터베이스 연결에는 영향을 미치지 않습니다. &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에 대한&lt;/a&gt; 각 호출 은 동일한 프로세스 내의 모든 이전 호출을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f53a6a65a1ce3426676e4e3e0eefc393f32a825e" translate="yes" xml:space="preserve">
          <source>Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().</source>
          <target state="translated">sqlite3_trace () 또는 sqlite3_trace_v2 ()에 대한 각 호출은 sqlite3_trace () 또는 sqlite3_trace_v2 ()에 대한 이전 호출을 대체합니다 (취소).</target>
        </trans-unit>
        <trans-unit id="210d7d62dedd7b7a03aaed5a472bf17f4f31c5cb" translate="yes" xml:space="preserve">
          <source>Each call to sqlite3rbu_step() does a small amount of work towards completing the vacuum operation. Depending on the size of the database, a single vacuum may require thousands of calls to sqlite3rbu_step(). sqlite3rbu_step() returns SQLITE_DONE if the vacuum operation has finished, SQLITE_OK if the vacuum operation has not finished but no error has occurred, and an SQLite error code if an error is encountered. If an error does occur, all subsequent calls to sqlite3rbu_step() immediately return the same error code.</source>
          <target state="translated">sqlite3rbu_step ()에 대한 각 호출은 진공 작업을 완료하기 위해 소량의 작업을 수행합니다. 데이터베이스의 크기에 따라 단일 진공에서 sqlite3rbu_step ()에 대한 수천 번의 호출이 필요할 수 있습니다. sqlite3rbu_step ()은 진공 작업이 완료된 경우 SQLITE_DONE, 진공 작업이 완료되지 않았지만 오류가 발생하지 않은 경우 SQLITE_OK, 오류가 발생한 경우 SQLite 오류 코드를 리턴합니다. 오류가 발생하면 sqlite3rbu_step ()에 대한 모든 후속 호출은 즉시 동일한 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="945385f146c601eb7773bb4497e85e560cda1868" translate="yes" xml:space="preserve">
          <source>Each call to xUpdate will fall into one of cases shown below. Not that references to &lt;b&gt;argv[i]&lt;/b&gt; mean the SQL value held within the argv[i] object, not the argv[i] object itself.</source>
          <target state="translated">xUpdate에 대한 각 호출은 아래 표시된 경우 중 하나에 해당합니다. &lt;b&gt;argv [i]에&lt;/b&gt; 대한 참조가 argv [i] 오브젝트 자체가 아니라 argv [i] 오브젝트 내에 보유 된 SQL 값을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc164ad4bbc60e4e26ece4689029d1fc885eb00a" translate="yes" xml:space="preserve">
          <source>Each change recorded by a session object is marked as either direct or indirect. A change is marked as indirect if either:</source>
          <target state="translated">세션 개체에 의해 기록 된 각 변경 사항은 직접 또는 간접으로 표시됩니다. 다음 중 하나에 해당하면 변경이 간접적 인 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="23f47a6b73c8dc551b62d8a4d686a08cd0fe7e37" translate="yes" xml:space="preserve">
          <source>Each column in an SQLite 3 database is assigned one of the following type affinities:</source>
          <target state="translated">SQLite 3 데이터베이스의 각 열에는 다음 유형 선호도 중 하나가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="b225a6098d76a95e7290e27ffd041b5076929def" translate="yes" xml:space="preserve">
          <source>Each column name or expression can be followed by one of the &quot;ASC&quot; or &quot;DESC&quot; keywords to indicate sort order. The sort order may or may not be ignored depending on the database file format, and in particular the &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt;. The &quot;legacy&quot; schema format (1) ignores index sort order. The descending index schema format (4) takes index sort order into account. Only versions of SQLite 3.3.0 (2006-01-11) and later are able to understand the descending index format. For compatibility, version of SQLite between 3.3.0 and 3.7.9 use the legacy schema format by default. The newer schema format is used by default in version 3.7.10 (2012-01-16) and later. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to change set the specific behavior for any version of SQLite.</source>
          <target state="translated">각 열 이름 또는 표현식 뒤에는 &quot;ASC&quot;또는 &quot;DESC&quot;키워드 중 하나가 정렬 순서를 나타냅니다. 정렬 순서는 데이터베이스 파일 형식, 특히 &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식 번호에&lt;/a&gt; 따라 무시되거나 무시되지 않을 수 있습니다 . &quot;레거시&quot;스키마 형식 (1)은 인덱스 정렬 순서를 무시합니다. 내림차순 색인 스키마 형식 (4)은 색인 정렬 순서를 고려합니다. SQLite 3.3.0 (2006-01-11) 이상의 버전 만 내림차순 인덱스 형식을 이해할 수 있습니다. 호환성을 위해 3.3.0과 3.7.9 사이의 SQLite 버전은 기본적으로 레거시 스키마 형식을 사용합니다. 최신 스키마 형식은 기본적으로 버전 3.7.10 (2012-01-16) 이상에서 사용됩니다. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그는&lt;/a&gt; SQLite는 모든 버전에 대한 특정 동작을 설정 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49f9ccaac189604c31d61c6229cff4580f28bbe6" translate="yes" xml:space="preserve">
          <source>Each component query of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; (UNION, UNION ALL, EXCEPT or INTERSECT) is assigned computed separately and is given its own line in the EXPLAIN QUERY PLAN output.</source>
          <target state="translated">&lt;a href=&quot;lang_select#compound&quot;&gt;복합 조회&lt;/a&gt; (UNION, UNION ALL, EXCEPT 또는 INTERSECT) 의 각 구성 요소 조회는 별도로 계산되어 할당되며 EXPLAIN QUERY PLAN 출력에 고유 한 행이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a75cebae36bdcbe0495a4d634fceea0a434ea48a" translate="yes" xml:space="preserve">
          <source>Each condition in a decision is shown to independently affect the outcome of the decision.</source>
          <target state="translated">결정의 각 조건은 결정의 결과에 독립적으로 영향을 미치는 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="eda97b5c1428b06749d7192d2daf361d1e6b41f6" translate="yes" xml:space="preserve">
          <source>Each condition in a decision takes on every possible outcome.</source>
          <target state="translated">결정의 각 조건은 가능한 모든 결과를 취합니다.</target>
        </trans-unit>
        <trans-unit id="672a397b8caf80d825496d9e4addec34b7e37369" translate="yes" xml:space="preserve">
          <source>Each constraint will usually correspond to a term in the WHERE clause or in a USING or ON clause that is of the form</source>
          <target state="translated">각 제약 조건은 일반적으로 WHERE 절 또는 USING 또는 ON 절의 용어에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f6b6e4c189b9effbef953c5009fced4ccf9808f2" translate="yes" xml:space="preserve">
          <source>Each contiguous run of one or more token characters is considered to be a token. The tokenizer is case-insensitive according to the rules defined by Unicode 6.1.</source>
          <target state="translated">하나 이상의 토큰 문자의 각 연속 실행은 토큰으로 간주됩니다. 토큰 화기는 유니 코드 6.1에 의해 정의 된 규칙에 따라 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0c15694bfecc642469801a997c362ec50ff854e" translate="yes" xml:space="preserve">
          <source>Each database connection can only have a single &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy handler&lt;/a&gt;. This PRAGMA sets the busy handler for the process, possibly overwriting any previously set busy handler.</source>
          <target state="translated">각 데이터베이스 연결에는 하나의 사용 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;중인 핸들러&lt;/a&gt; 만있을 수 있습니다 . 이 PRAGMA는 프로세스의 사용 중 핸들러를 설정하여 이전에 설정 한 사용 중 핸들러를 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7265aba95bac18bc11991bd9aa22402abe89a0a4" translate="yes" xml:space="preserve">
          <source>Each decision tries every possible outcome.</source>
          <target state="translated">각 결정은 가능한 모든 결과를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f26f253bc3ab871e59787a1a1782281f2039ee4f" translate="yes" xml:space="preserve">
          <source>Each entry and exit point is invoked.</source>
          <target state="translated">각 시작 및 종료 지점이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b70891edf39568734c049868720f59bea931ef9" translate="yes" xml:space="preserve">
          <source>Each entry in a table b-tree consists of a 64-bit signed integer key and up to 2147483647 bytes of arbitrary data. (The key of a table b-tree corresponds to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table that the b-tree implements.) Interior table b-trees hold only keys and pointers to children. All data is contained in the table b-tree leaves.</source>
          <target state="translated">테이블 b- 트리의 각 항목은 64 비트 부호있는 정수 키와 최대 2147483647 바이트의 임의 데이터로 구성됩니다. 테이블 b- 트리의 키는 b- 트리가 구현하는 SQL 테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 에 해당합니다 . 내부 테이블 b- 트리는 키와 자식에 대한 포인터 만 보유합니다. 모든 데이터는 테이블 b- 트리 잎에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c3f1f6e5f1d0cee7e536d0dc65315194aa51a9" translate="yes" xml:space="preserve">
          <source>Each entry in an index b-tree consists of an arbitrary key of up to 2147483647 bytes in length and no data.</source>
          <target state="translated">인덱스 b- 트리의 각 항목은 최대 2147483647 바이트의 임의 키로 구성되며 데이터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="24437abe274be0540b142250bde8d16bab60708f" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외한 대부분의 SQLite 테이블의 각 항목 에는 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt; 라는 고유 한 64 비트 부호있는 정수 키가 있습니다. rowid는 명시 적으로 선언 된 열에 의해 사용되지 않는 한 ROWID, OID 또는 _ROWID_라는 선언되지 않은 열로 항상 사용 가능합니다. 테이블에 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 컬럼이있는 경우 해당 컬럼은 rowid의 다른 별명입니다.</target>
        </trans-unit>
        <trans-unit id="d1943964848547ccdd4634c64ac1256e964eb11b" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외한 대부분의 SQLite 테이블의 각 항목 에는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt; 라는 고유 한 64 비트 부호있는 정수 키가 있습니다. rowid는 명시 적으로 선언 된 열에 의해 사용되지 않는 한 ROWID, OID 또는 _ROWID_라는 선언되지 않은 열로 항상 사용 가능합니다. 테이블에 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 컬럼이있는 경우 해당 컬럼은 rowid의 다른 별명입니다.</target>
        </trans-unit>
        <trans-unit id="901d9854ab50278bb04e1634932e0c3162943701" translate="yes" xml:space="preserve">
          <source>Each entry in the aPgno array has a single corresponding entry in the aHash array. There are more available slots in aHash than there are in aPgno. The unused slots in aHash are filled with zero. And since there are guaranteed to be unused slots in aHash, that means the loop that computes X is guaranteed to terminate. The expected size of X is less than 2. The worst case is that X will be the same as the number of entries in aPgno, in which case the algorithm runs at about the same speed as a linear scan of aPgno. But that worst case performance is exceedingly rare. Usually, the size of X will be small and the use of the aHash array allows one to compute FindFrame(P,M) much faster.</source>
          <target state="translated">aPgno 배열의 각 항목에는 aHash 배열에 해당하는 단일 항목이 있습니다. aPgno에있는 것보다 aHash에 사용 가능한 슬롯이 더 있습니다. 해시에서 사용되지 않는 슬롯은 0으로 채워집니다. 그리고 aHash에는 사용되지 않는 슬롯이 보장되므로 X를 계산하는 루프가 종료됩니다. X의 예상 크기는 2보다 작습니다. 최악의 경우 X는 aPgno의 항목 수와 동일하며이 경우 알고리즘은 aPgno의 선형 스캔과 거의 같은 속도로 실행됩니다. 그러나 최악의 성능은 매우 드 rare니다. 일반적으로 X의 크기는 작고 aHash 배열을 사용하면 FindFrame (P, M)을 훨씬 빠르게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcf88c184067656c86b627d1a59f0fe0f8cb79f" translate="yes" xml:space="preserve">
          <source>Each entry in the account_change table records a deposit or a withdrawal into an account. Deposits have a positive &quot;amt&quot; and withdrawals have a negative &quot;amt&quot;.</source>
          <target state="translated">account_change 테이블의 각 항목은 예금 또는 계좌 출금을 기록합니다. 예금은 긍정적 인 &quot;amt&quot;를 가지고, 인출은 부정적인 &quot;amt&quot;를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a6062c6a4e671adbb7f1cae985fca6efdd1bcc95" translate="yes" xml:space="preserve">
          <source>Each entry in the spellfix1 virtual table is associated with a particular language, identified by the integer &quot;langid&quot; column. The default langid is 0 and if no other actions are taken, the entire vocabulary is a part of the 0 language. But if your application needs to operate in multiple languages, then you can specify different vocabulary items for each language by specifying the langid field when populating the table. For example:</source>
          <target state="translated">spellfix1 가상 테이블의 각 항목은 정수 &quot;langid&quot;열로 식별되는 특정 언어와 연관됩니다. 기본 langid는 0이며 다른 조치를 취하지 않으면 전체 어휘는 0 언어의 일부입니다. 그러나 애플리케이션이 여러 언어로 작동해야하는 경우 테이블을 채울 때 langid 필드를 지정하여 각 언어에 대해 다른 어휘 항목을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fac2cc29010afaae6cb51cb626533541baf3f7b" translate="yes" xml:space="preserve">
          <source>Each expression in the result-set is then evaluated once for each group of rows. If the expression is an aggregate expression, it is evaluated across all rows in the group. Otherwise, it is evaluated against a single arbitrarily chosen row from within the group. If there is more than one non-aggregate expression in the result-set, then all such expressions are evaluated for the same row.</source>
          <target state="translated">그런 다음 결과 집합의 각 표현식은 각 행 그룹에 대해 한 번 평가됩니다. 표현식이 집계 표현식 인 경우 그룹의 모든 행에서 평가됩니다. 그렇지 않으면 그룹 내에서 임의로 선택된 단일 행에 대해 평가됩니다. 결과 집합에 둘 이상의 집계되지 않은식이 있으면 이러한 모든식이 동일한 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6438047b3d0359d4736da15419bdcf6543fd0081" translate="yes" xml:space="preserve">
          <source>Each extension function is allocated a single auxiliary data slot for each FTS query (MATCH expression). If the extension function is invoked more than once for a single FTS query, then all invocations share a single auxiliary data context.</source>
          <target state="translated">각 확장 기능에는 각 FTS 쿼리 (MATCH 식)에 대해 단일 보조 데이터 슬롯이 할당됩니다. 단일 FTS 쿼리에 대해 확장 기능이 두 번 이상 호출되면 모든 호출이 단일 보조 데이터 컨텍스트를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="d33d8aa62c5b61bac293e45f756797b6cb85d50a" translate="yes" xml:space="preserve">
          <source>Each foreign key constraint in SQLite is classified as either immediate or deferred. Foreign key constraints are immediate by default. All the foreign key examples presented so far have been of immediate foreign key constraints.</source>
          <target state="translated">SQLite의 각 외래 키 제약 조건은 즉시 또는 지연으로 분류됩니다. 외래 키 제약 조건은 기본적으로 즉시 적용됩니다. 지금까지 제시된 모든 외래 키 예제에는 즉각적인 외래 키 제약이있었습니다.</target>
        </trans-unit>
        <trans-unit id="6a1805543360f1e22766e2854c401aca860aeb6b" translate="yes" xml:space="preserve">
          <source>Each fts5vocab table is associated with a single FTS5 table. An fts5vocab table is usually created by specifying two arguments in place of column names in the CREATE VIRTUAL TABLE statement - the name of the associated FTS5 table and the type of fts5vocab table. Currently there are three types of fts5vocab table; &quot;row&quot;, &quot;col&quot; and &quot;instance&quot;. Unless the fts5vocab table is created within the &quot;temp&quot; database, it must be part of the same database as the associated FTS5 table.</source>
          <target state="translated">각 fts5vocab 테이블은 단일 FTS5 테이블과 연관됩니다. fts5vocab 테이블은 일반적으로 CREATE VIRTUAL TABLE 문에서 열 이름 대신 두 개의 인수 (관련된 FTS5 테이블의 이름 및 fts5vocab 테이블의 유형)를 지정하여 작성됩니다. 현재 fts5vocab 테이블에는 세 가지 유형이 있습니다. &quot;행&quot;, &quot;콜&quot;및 &quot;인스턴스&quot;. fts5vocab 테이블이 &quot;temp&quot;데이터베이스 내에 작성되지 않으면 테이블은 연관된 FTS5 테이블과 동일한 데이터베이스의 일부 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e745e43219ffcc55c78ef25c933503a8941d7638" translate="yes" xml:space="preserve">
          <source>Each group of input dataset rows contributes a single row to the set of result rows. Subject to filtering associated with the DISTINCT keyword, the number of rows returned by an aggregate query with a GROUP BY clause is the same as the number of groups of rows produced by applying the GROUP BY and HAVING clauses to the filtered input dataset.</source>
          <target state="translated">각 입력 데이터 세트 행 그룹은 단일 행을 결과 행 세트에 제공합니다. DISTINCT 키워드와 연관된 필터링에 따라 GROUP BY 절이있는 집계 쿼리에서 리턴되는 행 수는 GROUP BY 및 HAVING 절을 필터링 된 입력 데이터 세트에 적용하여 생성 된 행 그룹 수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7843ace013d2f4a1d502e5350d480fd1304c50c8" translate="yes" xml:space="preserve">
          <source>Each host parameter in an SQLite statement is assigned a number. The numbers normally begin with 1 and increase by one with each new parameter. However, when the &quot;?123&quot; form is used, the host parameter number is the number that follows the question mark.</source>
          <target state="translated">SQLite 문의 각 호스트 매개 변수에는 숫자가 할당됩니다. 숫자는 일반적으로 1로 시작하고 새 매개 변수마다 하나씩 증가합니다. 그러나 &quot;? 123&quot;형식을 사용하는 경우 호스트 매개 변수 번호는 물음표 뒤에 오는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="aa86db673d2e11cfb16c97d7614715b23b7a434b" translate="yes" xml:space="preserve">
          <source>Each individual test module might contain dozens, hundreds, or thousands of separate tests. The test modules can be written in C or as scripts of SQL or a mixture of the two. About two-thirds of the existing test modules are written in pure SQL with the remainder either in pure C or a combination of C and SQL.</source>
          <target state="translated">각 개별 테스트 모듈에는 수십, 수백 또는 수천 개의 개별 테스트가 포함될 수 있습니다. 테스트 모듈은 C로 작성하거나 SQL 스크립트 또는이 둘을 혼합하여 작성할 수 있습니다. 기존 테스트 모듈의 약 3 분의 2가 순수 SQL로 작성되고 나머지는 순수 C 또는 C와 SQL의 조합으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6f71e4dfef9dffaef271af8b4c7b3a147f1117" translate="yes" xml:space="preserve">
          <source>Each inserted row must be accompanied by an explicitly specified rowid value. If a contentless table is configured with columnsize=0, attempting to insert a NULL value into the rowid is an SQLITE_MISMATCH error.</source>
          <target state="translated">삽입 된 각 행에는 명시 적으로 지정된 rowid 값이 있어야합니다. contentless 테이블이 columnsize = 0으로 구성된 경우, rowid에 NULL 값을 삽입하려고하면 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="899a2acd85a7e060ed04cbcbd2e9466f80cde441" translate="yes" xml:space="preserve">
          <source>Each instruction of the VDBE language contains an opcode and three operands labeled P1, P2, and P3. Operand P1 is an arbitrary integer. P2 is a non-negative integer. P3 is a pointer to a data structure or null-terminated string, possibly null. Only a few VDBE instructions use all three operands. Many instructions use only one or two operands. A significant number of instructions use no operands at all but instead take their data and store their results on the execution stack. The details of what each instruction does and which operands it uses are described in the separate &lt;a href=&quot;opcode&quot;&gt;opcode description&lt;/a&gt; document.</source>
          <target state="translated">VDBE 언어의 각 명령어에는 opcode와 P1, P2 및 P3이라는 세 개의 피연산자가 포함되어 있습니다. 피연산자 P1은 임의의 정수입니다. P2는 음이 아닌 정수입니다. P3은 데이터 구조 또는 널 (null)로 끝나는 문자열에 대한 포인터이며 가능하면 널입니다. 소수의 VDBE 명령어 만 세 피연산자를 모두 사용합니다. 많은 명령어는 하나 또는 두 개의 피연산자 만 사용합니다. 많은 수의 명령어는 피연산자를 전혀 사용하지 않고 대신 데이터를 가져 와서 결과를 실행 스택에 저장합니다. 각 명령어의 기능과 사용하는 피연산자에 대한 자세한 내용은 별도의 &lt;a href=&quot;opcode&quot;&gt;opcode 설명&lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76b1f05c7f0ee24d16c42b081d0c67e73247f0e" translate="yes" xml:space="preserve">
          <source>Each instruction of the VDBE language contains an opcode and three operands labeled P1, P2, and P3. Operand P1 is an arbitrary integer. P2 is a non-negative integer. P3 is a pointer to a data structure or zero-terminated string, possibly null. Only a few VDBE instructions use all three operands. Many instructions use only one or two operands. A significant number of instructions use no operands at all but instead take their data and store their results on the execution stack. The details of what each instruction does and which operands it uses are described in the separate &lt;a href=&quot;opcode&quot;&gt;opcode description&lt;/a&gt; document.</source>
          <target state="translated">VDBE 언어의 각 명령어에는 opcode와 P1, P2 및 P3 레이블이 지정된 세 개의 피연산자가 포함되어 있습니다. 피연산자 P1은 임의의 정수입니다. P2는 음이 아닌 정수입니다. P3은 데이터 구조 또는 0으로 끝나는 문자열에 대한 포인터이며 null 일 수 있습니다. 소수의 VDBE 명령어 만 세 피연산자를 모두 사용합니다. 대부분의 명령어는 하나 또는 두 개의 피연산자 만 사용합니다. 상당수의 명령어는 피연산자를 전혀 사용하지 않고 대신 데이터를 가져와 실행 스택에 결과를 저장합니다. 각 명령어가 수행하는 작업과 사용하는 피연산자에 대한 자세한 내용은 별도의 &lt;a href=&quot;opcode&quot;&gt;opcode 설명&lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66fd5c0b46cc5a181a71fe28426b2f8ae830bb14" translate="yes" xml:space="preserve">
          <source>Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt; returns an integer code that indicates what happened during that step. This code may be SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE, SQLITE_ERROR, or SQLITE_MISUSE.</source>
          <target state="translated">&lt;b&gt;sqlite_step을&lt;/b&gt; 호출 할 때마다 해당 단계에서 발생한 사항을 나타내는 정수 코드가 리턴됩니다. 이 코드는 SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE, SQLITE_ERROR 또는 SQLITE_MISUSE 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda57e5707a682202e3ea3669b23018d0d5aa983" translate="yes" xml:space="preserve">
          <source>Each local changeset is rebased by calling sqlite3rebaser_rebase().</source>
          <target state="translated">각 로컬 변경 세트는 sqlite3rebaser_rebase ()를 호출하여 리베이스됩니다.</target>
        </trans-unit>
        <trans-unit id="77c7956712463753fdecca1cf0561681966682aa" translate="yes" xml:space="preserve">
          <source>Each of the b-trees that make up the full-text index is assigned to a &quot;level&quot; based on its size. Level-0 b-trees are the smallest, as they contain the contents of a single transaction. Higher level b-trees are the result of merging two or more level-0 b-trees together and so they are larger. FTS5 begins to merge b-trees together once there exist</source>
          <target state="translated">전체 텍스트 인덱스를 구성하는 각 b- 트리는 크기에 따라 &quot;레벨&quot;에 할당됩니다. 레벨 0 b- 트리는 단일 트랜잭션의 내용을 포함하므로 가장 작습니다. 높은 수준의 b- 트리는 둘 이상의 level-0 b- 트리를 함께 병합하여 더 커집니다. FTS5가 존재하면 B- 트리를 병합하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a769a3ad4df79c7cb38d60dba3f3bf7d78452a22" translate="yes" xml:space="preserve">
          <source>Each of these points will be described in more detail below, after first considering more closely the meaning of &quot;application file format&quot;. See also the &lt;a href=&quot;aff_short&quot;&gt;short version&lt;/a&gt; of this whitepaper.</source>
          <target state="translated">이러한 점들 각각은 &quot;애플리케이션 파일 형식&quot;의 의미를 더 자세히 고려한 후에 아래에서 더 상세히 설명 될 것이다. 이 백서 의 &lt;a href=&quot;aff_short&quot;&gt;짧은 버전&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5b3811f86b94838c4eb44ef8dbbc1bed6e5053e" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">열려있는 각 SQLite 데이터베이스는 &quot;sqlite3&quot;이라는 불투명 구조의 인스턴스에 대한 포인터로 표시됩니다. sqlite3 포인터를 객체로 생각하면 유용합니다. &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스는 생성자이며 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 ()는&lt;/a&gt; 그 파괴자이다. 많은 다른 인터페이스가있다 (예 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()는&lt;/a&gt; 이름 그러나 셋을)를 sqlite3를 객체 메소드 있음.</target>
        </trans-unit>
        <trans-unit id="92b7576547952b019821d8e7929a16a6e6b6d4ff" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">열려있는 각 SQLite 데이터베이스는 &quot;sqlite3&quot;이라는 불투명 구조의 인스턴스에 대한 포인터로 표시됩니다. sqlite3 포인터를 객체로 생각하면 유용합니다. &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스는 생성자이며 &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; 및 &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 ()는&lt;/a&gt; 그 파괴자이다. 많은 다른 인터페이스가있다 (예 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; , &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()는&lt;/a&gt; 이름 그러나 셋을)를 sqlite3를 객체 메소드 있음.</target>
        </trans-unit>
        <trans-unit id="ee894daabc7121702b3448691c905adb7d440b29" translate="yes" xml:space="preserve">
          <source>Each ordinary SQL table in the database schema is represented on-disk by a table b-tree. Each entry in the table b-tree corresponds to a row of the SQL table. The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table is the 64-bit signed integer key for each entry in the table b-tree.</source>
          <target state="translated">데이터베이스 스키마의 각 일반 SQL 테이블은 디스크에서 테이블 b- 트리로 표시됩니다. 테이블 b- 트리의 각 항목은 SQL 테이블의 행에 해당합니다. SQL 테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 는 테이블 b- 트리의 각 항목에 대한 64 비트 부호있는 정수 키입니다.</target>
        </trans-unit>
        <trans-unit id="74ebddba931d62de6d9b53e43959c1987854ff78" translate="yes" xml:space="preserve">
          <source>Each polygon in the Geopoly module can be associated with an arbitrary number of auxiliary data fields.</source>
          <target state="translated">Geopoly 모듈의 각 다각형은 임의의 수의 보조 데이터 필드와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a000525bb8067810fd906490555a5fd20fbf3f0a" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">준비된 각 문 은 특정 작업을 수행 한 횟수를 측정하는 다양한 &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 유지 관리 합니다. 이 카운터는 준비된 문의 성능 특성을 모니터링하는 데 사용할 수 있습니다. 예를 들어, 테이블 단계 수가 테이블 검색 또는 결과 행 수를 크게 초과하면 준비된 명령문이 인덱스가 아닌 전체 테이블 스캔을 사용하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0107ece90b86e808837320ac7220432f2669eb1d" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">준비된 각 문 은 특정 작업을 수행 한 횟수를 측정하는 다양한 &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 유지 관리 합니다. 이 카운터는 준비된 문의 성능 특성을 모니터링하는 데 사용할 수 있습니다. 예를 들어, 테이블 단계 수가 테이블 검색 또는 결과 행 수를 크게 초과하면 준비된 명령문이 인덱스가 아닌 전체 테이블 스캔을 사용하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="999331a91fda475fee950bbc880e18a160954827" translate="yes" xml:space="preserve">
          <source>Each read lock byte corresponds to one of the five 32-bit read-mark integers located in bytes 100 through 119 of the WAL-index header, as follows:</source>
          <target state="translated">각 읽기 잠금 바이트는 다음과 같이 WAL- 색인 헤더의 바이트 100-119에있는 5 개의 32 비트 읽기 표시 정수 중 하나에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="fd4a538875dcd8a3da92631d9e514ff489421f3d" translate="yes" xml:space="preserve">
          <source>Each row in a table with a primary key must have a unique combination of values in its primary key columns. For the purposes of determining the uniqueness of primary key values, NULL values are considered distinct from all other values, including other NULLs. If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement attempts to modify the table content so that two or more rows have identical primary key values, that is a constraint violation.</source>
          <target state="translated">기본 키가있는 테이블의 각 행에는 기본 키 열에 고유 한 값 조합이 있어야합니다. 기본 키 값의 고유성을 결정하기 위해 NULL 값은 다른 NULL을 포함하여 다른 모든 값과 다른 것으로 간주됩니다. 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE의&lt;/a&gt; 문 시도 테이블 내용을 수정할 수 있도록 두 개 이상의 행이 제약 조건 위반입니다, 동일한 기본 키 값이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c5fe898fae0731eeb92ba7918d3cd1096012e142" translate="yes" xml:space="preserve">
          <source>Each row in ex25ae contains five columns: a, e, d, c, a. The &quot;a&quot; column is repeated since the first occurrence of &quot;a&quot; has a collating function of &quot;nocase&quot; and the second has a collating sequence of &quot;binary&quot;. If the &quot;a&quot; column is not repeated and if the table contains two or more entries with the same &quot;e&quot; value and where &quot;a&quot; differs only in case, then all of those table entries would correspond to a single entry in the index, which would break the one-to-one correspondence between the table and the index.</source>
          <target state="translated">ex25ae의 각 행에는 a, e, d, c, a의 5 개 열이 있습니다. &quot;a&quot;의 첫 번째 발생은 &quot;nocase&quot;의 조합 기능을 갖고 두 번째는 &quot;binary&quot;의 조합 순서를 갖기 때문에 &quot;a&quot;열이 반복됩니다. &quot;a&quot;열이 반복되지 않고 테이블에 동일한 &quot;e&quot;값을 가진 두 개 이상의 항목이 포함되어 있고 &quot;a&quot;가 대소 문자 만 다른 경우 모든 테이블 항목은 인덱스의 단일 항목에 해당합니다. , 테이블과 인덱스 간의 일대일 대응을 깨뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6d65e1c2c837dfdc0a485f823d815f1cb8af08" translate="yes" xml:space="preserve">
          <source>Each row in ex25ae contains five columns: c, e, d, c, a. The c column is repeated since the first occurrence of c has a collating function of &quot;nocase&quot; and the second has a collating sequence of &quot;binary&quot;. If the c column is not repeated and if the table contains two or more entries with the same e value and where c differs only in case, then all of those table entries would correspond to a single entry in the index, which would break the one-to-one correspondence between the table and the index.</source>
          <target state="translated">ex25ae의 각 행에는 c, e, d, c, a의 5 개 열이 있습니다. c의 첫 번째 발생이 &quot;nocase&quot;의 조합 기능을 갖고 두 번째 발생이 &quot;이진&quot;의 조합 순서를 갖기 때문에 c 컬럼이 반복됩니다. c 열이 반복되지 않고 테이블에 동일한 e 값을 가진 두 개 이상의 항목이 포함되어 있고 c가 경우에만 다른 경우, 해당 테이블 항목은 모두 색인의 단일 항목에 해당하므로 하나를 중단합니다. 테이블과 인덱스 간의 일대일 대응.</target>
        </trans-unit>
        <trans-unit id="f36fe249b41449ff09e1c30c002890daff1cad55" translate="yes" xml:space="preserve">
          <source>Each row in the ex25ce index is a record with these columns: c, e, d, a. The first two columns are the columns being indexed, c and e. The remaining columns are the primary key of the corresponding table row. Normally, the primary key would be columns d, c, and a, but because column c already appears earlier in the index, it is omitted from the key suffix.</source>
          <target state="translated">ex25ce 인덱스의 각 행은 c, e, d, a 열이있는 레코드입니다. 처음 두 열은 색인을 생성하는 열 c와 e입니다. 나머지 열은 해당 테이블 행의 기본 키입니다. 일반적으로 기본 키는 열 d, c 및 a이지만, 열 c가 인덱스의 앞부분에 이미 나타나므로 키 접미사에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="cab24ffbbc0f1bf68fc2e07923e9d56fc10203eb" translate="yes" xml:space="preserve">
          <source>Each row in the spellfix1 virtual table has a unique rowid with seven columns plus five extra hidden columns. The columns are as follows:</source>
          <target state="translated">spellfix1 가상 테이블의 각 행에는 7 개의 열과 5 개의 추가 숨겨진 열이있는 고유 한 rowid가 있습니다. 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b6636128d8303465a6612a171949922d9167128" translate="yes" xml:space="preserve">
          <source>Each row of the SQLAR table holds the content of a single file. The filename (the full pathname relative to the root of the archive) is in the &quot;name&quot; field. The &quot;mode&quot; field is an integer which is the unix-style access permissions for the file. &quot;mtime&quot; is the modification time of the file in seconds since 1970. &quot;sz&quot; is the original uncompressed size of the file. The &quot;data&quot; field contains the file content. The content is usually compressed using &lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate&lt;/a&gt;, though not always. If the &quot;sz&quot; field is equal to the size of the &quot;data&quot; field, then the content is stored uncompressed.</source>
          <target state="translated">SQLAR 테이블의 각 행은 단일 파일의 내용을 보유합니다. 파일 이름 (아카이브 루트에 상대적인 전체 경로 이름)은 &quot;이름&quot;필드에 있습니다. &quot;mode&quot;필드는 파일에 대한 유닉스 스타일 액세스 권한 인 정수입니다. &quot;mtime&quot;은 1970 년 이후의 파일 수정 시간 (초)입니다. &quot;sz&quot;는 파일의 원래 압축되지 않은 크기입니다. &quot;데이터&quot;필드는 파일 내용을 포함합니다. 내용은 항상 &lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate를&lt;/a&gt; 사용하여 압축 되지만 항상 그런 것은 아닙니다. &quot;sz&quot;필드가 &quot;data&quot;필드의 크기와 같으면 컨텐츠는 압축되지 않은 상태로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b6165a221a3e4a38199edcd68a8e62b04991c252" translate="yes" xml:space="preserve">
          <source>Each row of the SQLITE_MEMSTAT table corresponds to a single call to one of the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; or &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces. The NAME column of the row identifies which &quot;verb&quot; was passed to those interfaces. For example, if &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;, then the NAME column is 'MEMORY_USED'. Or if &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;, then the NAME column is &quot;DB_CACHE_USED&quot;.</source>
          <target state="translated">SQLITE_MEMSTAT 테이블의 각 행은 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스 중 하나에 대한 단일 호출에 해당합니다 . 행의 NAME 열은 해당 인터페이스로 전달 된 &quot;동사&quot;를 식별합니다. 예를 들어, &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()가&lt;/a&gt; 호출된다 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; 다음 NAME 열은 'MEMORY_USED'는이다. 또는 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 가 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; 로 호출 된 경우 NAME 열은 &quot;DB_CACHE_USED&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="997a34331755f5f92b0f76283ad7cb1a20992bfb" translate="yes" xml:space="preserve">
          <source>Each small sort is run independently, meaning that much less information needs to be kept in temporary storage at any one time.</source>
          <target state="translated">각각의 작은 정렬은 독립적으로 실행되므로 한 번에 임시 저장 공간에 훨씬 적은 정보를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b0b5952e142633475481798bf66c99ae914842" translate="yes" xml:space="preserve">
          <source>Each subsequent string or bareword in a column declaration is a column option that modifies the behaviour of that column. Column options are case-independent. Unlike the SQLite core, FTS5 considers unrecognized column options to be errors. Currently, the only option recognized is &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&quot;UNINDEXED&quot; (see below)&lt;/a&gt;.</source>
          <target state="translated">열 선언에서 각 후속 문자열 또는 베어 워드는 해당 열의 동작을 수정하는 열 옵션입니다. 열 옵션은 대소 문자를 구분하지 않습니다. SQLite 코어와 달리 FTS5는 인식 할 수없는 열 옵션을 오류로 간주합니다. 현재 인식되는 유일한 옵션은 &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&quot;UNINDEXED&quot;입니다 (아래 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818d5604974790264ec0e5e9c61bfb95c5744c47" translate="yes" xml:space="preserve">
          <source>Each table and each index in SQLite is stored in a separate b-tree in the database file. Each b-tree is identified by its root page number. The root page number for any index or table can be found by querying the &quot;rootpage&quot; column of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. See the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; and the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further background on this design.</source>
          <target state="translated">SQLite의 각 테이블과 각 인덱스는 데이터베이스 파일에서 별도의 b- 트리에 저장됩니다. 각 b- 트리는 루트 페이지 번호로 식별됩니다. &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 의 &quot;rootpage&quot;열을 쿼리하여 인덱스 또는 테이블의 루트 페이지 번호를 찾을 수 있습니다 . 이 디자인에 대한 추가 배경 지식을 &lt;a href=&quot;queryplanner&quot;&gt;얻으&lt;/a&gt; 려면 인덱싱 자습서 및 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4807a7d80bff2589aaa09c4b3fda6efeec4f7456" translate="yes" xml:space="preserve">
          <source>Each table and each index in SQLite is stored in a separate b-tree in the database file. Each b-tree is identified by its root page number. The root page number for any index or table can be found by querying the &quot;rootpage&quot; column of the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. See the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; and the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further background on this design.</source>
          <target state="translated">SQLite의 각 테이블과 각 인덱스는 데이터베이스 파일의 개별 b- 트리에 저장됩니다. 각 b- 트리는 루트 페이지 번호로 식별됩니다. 인덱스 또는 테이블의 루트 페이지 번호는 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블&lt;/a&gt; 의 &quot;rootpage&quot;열을 쿼리하여 찾을 수 있습니다 . 이 디자인에 대한 자세한 배경 정보 는 &lt;a href=&quot;queryplanner&quot;&gt;인덱싱 자습서&lt;/a&gt; 및 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ce016ce4a1263a1e308f54a333440722a399bac" translate="yes" xml:space="preserve">
          <source>Each table and index requires at least one page in the database file. An &quot;index&quot; in the previous sentence means an index created explicitly using a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implicit indices created by UNIQUE and PRIMARY KEY constraints. Since the maximum number of pages in a database file is 2147483646 (a little over 2 billion) this is also then an upper bound on the number of tables and indices in a schema.</source>
          <target state="translated">각 테이블과 인덱스는 데이터베이스 파일에 하나 이상의 페이지가 필요합니다. 이전 문장에서 &quot;인덱스&quot;는 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 사용하여 명시 적으로 생성 된 인덱스 또는 UNIQUE 및 PRIMARY KEY 제약 조건으로 생성 된 암시 적 인덱스를 의미합니다 . 데이터베이스 파일의 최대 페이지 수는 2147483646 (약 20 억 개)이므로 스키마의 테이블 및 인덱스 수의 상한이기도합니다.</target>
        </trans-unit>
        <trans-unit id="7fd6452e149193b7e1151a0184d1459cf1e10a68" translate="yes" xml:space="preserve">
          <source>Each table in SQLite may have at most one &lt;b&gt;PRIMARY KEY&lt;/b&gt;. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">SQLite의 각 테이블에는 최대 하나의 &lt;b&gt;PRIMARY KEY&lt;/b&gt; 가있을 수 있습니다 . 키워드 PRIMARY KEY가 열 정의에 추가되면 테이블의 기본 키는 해당 단일 열로 구성됩니다. 또는 PRIMARY KEY 절이 &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; 로 지정된 경우 테이블 의 기본 키는 PRIMARY KEY 절의 일부로 지정된 열 목록으로 구성됩니다. PRIMARY KEY 절은 열 이름 만 포함해야합니다. PRIMARY KEY의 &lt;a href=&quot;syntax/indexed-column&quot;&gt;색인 열&lt;/a&gt; 에서 표현식 사용은 지원되지 않습니다. CREATE TABLE 문에 둘 이상의 PRIMARY KEY 절이 나타나면 오류가 발생합니다. PRIMARY KEY는 일반 테이블의 경우 선택 사항이지만 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 경우 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ae4ff650538e5636d95dba9544b5db7a50ea2e27" translate="yes" xml:space="preserve">
          <source>Each table in SQLite may have at most one PRIMARY KEY. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">SQLite의 각 테이블에는 최대 하나의 PRIMARY KEY가있을 수 있습니다. 키워드 PRIMARY KEY가 열 정의에 추가되면 테이블의 기본 키는 해당 단일 열로 구성됩니다. 또는 PRIMARY KEY 절이 &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; 로 지정된 경우 테이블 의 기본 키는 PRIMARY KEY 절의 일부로 지정된 열 목록으로 구성됩니다. PRIMARY KEY 절은 열 이름 만 포함해야합니다. PRIMARY KEY의 &lt;a href=&quot;syntax/indexed-column&quot;&gt;인덱싱 된 열&lt;/a&gt; 에서 식을 사용하는 것은 지원되지 않습니다. 둘 이상의 PRIMARY KEY 절이 CREATE TABLE 문에 나타나면 오류가 발생합니다. PRIMARY KEY는 일반 테이블의 경우 선택 사항이지만 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에는 필수입니다 .</target>
        </trans-unit>
        <trans-unit id="da7220645d88bb24fc93c16ec387c215924ce8f1" translate="yes" xml:space="preserve">
          <source>Each table in the FROM clause of a query can use at most one index (except when the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; comes into play) and SQLite strives to use at least one index on each table. Sometimes, two or more indices might be candidates for use on a single table. For example:</source>
          <target state="translated">쿼리의 FROM 절에있는 각 테이블은 최대 하나의 인덱스를 사용할 수 있으며 ( &lt;a href=&quot;#or_opt&quot;&gt;OR 절 최적화&lt;/a&gt; 가 실행되는 경우 제외 ) SQLite는 각 테이블에서 하나 이상의 인덱스를 사용하려고합니다. 때로는 두 개 이상의 인덱스가 단일 테이블에서 사용하기위한 후보 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d5f5bbc1c1dec038bbb126443a4f518b5530436" translate="yes" xml:space="preserve">
          <source>Each temporary table and index is given its own page cache which can store a maximum number of database pages determined by the SQLITE_DEFAULT_TEMP_CACHE_SIZE compile-time parameter. (The default value is 500 pages.) The maximum number of database pages in the page cache is the same for every temporary table and index. The value cannot be changed at run-time or on a per-table or per-index basis. Each temporary file gets its own private page cache with its own SQLITE_DEFAULT_TEMP_CACHE_SIZE page limit.</source>
          <target state="translated">각 임시 테이블 및 인덱스에는 SQLITE_DEFAULT_TEMP_CACHE_SIZE 컴파일 타임 매개 변수로 판별 된 최대 데이터베이스 페이지 수를 저장할 수있는 자체 페이지 캐시가 제공됩니다. (기본값은 500 페이지입니다.) 페이지 캐시의 최대 데이터베이스 페이지 수는 모든 임시 테이블 및 인덱스에 대해 동일합니다. 런타임시 또는 테이블 또는 인덱스별로 값을 변경할 수 없습니다. 각 임시 파일은 자체 SQLITE_DEFAULT_TEMP_CACHE_SIZE 페이지 제한이있는 자체 개인 페이지 캐시를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="396be9e68045d4b494141a2b61767c3d988f291c" translate="yes" xml:space="preserve">
          <source>Each test module file contains a header which describes the circumstances under which the test is valid. For a particular configuration, only those modules that are compatible with the configuration are run.</source>
          <target state="translated">각 테스트 모듈 파일에는 테스트가 유효한 환경을 설명하는 헤더가 포함되어 있습니다. 특정 구성의 경우 구성과 호환되는 모듈 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="82839803e7b91a3d746402c43f4f5e99695c5aff" translate="yes" xml:space="preserve">
          <source>Each time a row is inserted into the table by an INSERT statement that does not provide explicit values for all table columns the values stored in the new row are determined by their default values, as follows:</source>
          <target state="translated">모든 테이블 컬럼에 대해 명시적인 값을 제공하지 않는 INSERT 문으로 테이블에 행을 삽입 할 때마다 새 행에 저장된 값은 다음과 같이 기본값에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="821f4ad950cccc21cbff55f2ebad926da59331c6" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">충돌 핸들러 함수가 호출 될 때마다 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; 중 하나를 리턴해야합니다 . 충돌 핸들러에 전달 된 두 번째 인수가 SQLITE_CHANGESET_DATA 또는 SQLITE_CHANGESET_CONFLICT 인 경우에만 SQLITE_CHANGESET_REPLACE가 리턴 될 수 있습니다. 충돌 처리기가 잘못된 값을 반환하면 이미 변경 한 내용이 모두 롤백되고 sqlite3changeset_apply () 호출이 SQLITE_MISUSE를 반환합니다. 충돌 처리기 함수를 호출 할 때마다 반환되는 값에 따라 sqlite3changeset_apply ()가 다른 작업을 수행합니다. 자세한 내용은 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;사용 가능한&lt;/a&gt; 세 가지 반환 값에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fdebc8e16d47a197b7a842f6a3967c8187697b" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;c_changeset_abort&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">충돌 핸들러 함수가 호출 될 때마다 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt; , &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; 중 하나를 리턴해야합니다 . 충돌 핸들러에 전달 된 두 번째 인수가 SQLITE_CHANGESET_DATA 또는 SQLITE_CHANGESET_CONFLICT 인 경우에만 SQLITE_CHANGESET_REPLACE가 리턴 될 수 있습니다. 충돌 처리기가 잘못된 값을 반환하면 이미 변경 한 내용이 모두 롤백되고 sqlite3changeset_apply () 호출이 SQLITE_MISUSE를 반환합니다. 충돌 처리기 함수를 호출 할 때마다 반환되는 값에 따라 sqlite3changeset_apply ()가 다른 작업을 수행합니다. 자세한 내용은 &lt;a href=&quot;c_changeset_abort&quot;&gt;사용 가능한&lt;/a&gt; 세 가지 반환 값에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8d207a3340b7e4a9461110fe5af6c49d7e816b35" translate="yes" xml:space="preserve">
          <source>Each time the xInput callback is invoked by the sessions module, the first argument passed is a copy of the supplied pIn context pointer. The second argument, pData, points to a buffer (*pnData) bytes in size. Assuming no error occurs the xInput method should copy up to (*pnData) bytes of data into the buffer and set (*pnData) to the actual number of bytes copied before returning SQLITE_OK. If the input is completely exhausted, (*pnData) should be set to zero to indicate this. Or, if an error occurs, an SQLite error code should be returned. In all cases, if an xInput callback returns an error, all processing is abandoned and the streaming API function returns a copy of the error code to the caller.</source>
          <target state="translated">세션 모듈이 xInput 콜백을 호출 할 때마다 전달 된 첫 번째 인수는 제공된 pIn 컨텍스트 포인터의 사본입니다. 두 번째 인수 인 pData는 크기가 버퍼 (* pnData) 바이트를 가리 킵니다. 오류가 발생하지 않는다고 가정하면 xInput 메소드는 최대 (* pnData) 바이트의 데이터를 버퍼에 복사하고 SQLITE_OK를 리턴하기 전에 복사 된 실제 바이트 수로 (* pnData)를 설정해야합니다. 입력이 완전히 소진 된 경우이를 나타내려면 (* pnData)를 0으로 설정해야합니다. 또는 오류가 발생하면 SQLite 오류 코드가 리턴되어야합니다. 모든 경우에, xInput 콜백이 오류를 반환하면 모든 처리가 중단되고 스트리밍 API 함수는 오류 코드 사본을 호출자에게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23d4a49b5fad6a5cff3892e56560d6b2467c05f2" translate="yes" xml:space="preserve">
          <source>Each transaction can be committed by overwriting the rollback journal header with zeros rather than deleting the journal file. This avoids having to modify the directory entry for the journal file and it avoids having to deallocate disk sectors associated with the journal. Furthermore, the next transaction will overwrite existing journal file content rather than append new content and on most systems overwriting is much faster than appending.</source>
          <target state="translated">저널 파일을 삭제하지 않고 롤백 저널 헤더를 0으로 겹쳐 써서 각 트랜잭션을 커밋 할 수 있습니다. 이렇게하면 저널 파일의 디렉토리 항목을 수정하지 않아도되고 저널과 연관된 디스크 섹터를 할당 해제하지 않아도됩니다. 또한 다음 트랜잭션에서는 새 내용을 추가하는 대신 기존 저널 파일 내용을 덮어 쓰게되며 대부분의 시스템에서는 덮어 쓰기가 추가하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="159aa0e59fdea8a05c775d6b054f429c0df2af88" translate="yes" xml:space="preserve">
          <source>Each transient index is stored in its own temporary file. The temporary file for a transient index is automatically deleted at the end of the statement that uses it.</source>
          <target state="translated">각 임시 색인은 자체 임시 파일에 저장됩니다. 임시 색인의 임시 파일은이를 사용하는 명령문의 끝에서 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ffcf7118e5b3afe3526ba81a60229a24d4e643bd" translate="yes" xml:space="preserve">
          <source>Each trigger must specify that it will fire for one of the following operations: &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The trigger fires once for each row that is deleted, inserted, or updated. If the &quot;UPDATE OF column-name&quot; syntax is used, then the trigger will only fire if column-name appears on the left-hand side of one of the terms in the SET clause of the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">각 트리거는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 작업 중 하나에 대해 실행되도록 지정해야합니다 . 트리거는 삭제, 삽입 또는 업데이트 된 각 행에 대해 한 번씩 실행됩니다. &quot;UPDATE OF column-name&quot;구문을 사용하는 경우 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문의 SET 절에있는 용어 중 하나의 왼쪽에 column-name이 나타나는 경우에만 트리거가 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="fca57b0c6d20c7ecd27ccd8ad15ef9f43027716b" translate="yes" xml:space="preserve">
          <source>Each value stored in an SQLite database (or manipulated by the database engine) has one of the following storage classes:</source>
          <target state="translated">SQLite 데이터베이스에 저장된 (또는 데이터베이스 엔진으로 조작 된) 각 값에는 다음 스토리지 클래스 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e662adf0f870371f71f9ee7e2791e8f09589bff" translate="yes" xml:space="preserve">
          <source>Each virtual table instance is represented by an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure. The sqlite3_vtab structure looks like this:</source>
          <target state="translated">각 가상 테이블 인스턴스는 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조로 표시됩니다 . sqlite3_vtab 구조는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="e3984e1960f4cb3742e6adde6b1867fad529f949" translate="yes" xml:space="preserve">
          <source>Easily Extensible</source>
          <target state="translated">쉽게 확장 가능</target>
        </trans-unit>
        <trans-unit id="441046fa5ffdde9809362069e6548a3082c7a725" translate="yes" xml:space="preserve">
          <source>Edits occurs sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순차적으로 편집이 수행됩니다. 이전 편집으로 인한 변경은 후속 편집의 경로 검색에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0dfbd71d0c98711cf3c97133105aec44ca6de76" translate="yes" xml:space="preserve">
          <source>Eight bytes of space are set aside in the header to support file locking using the xShmLock() method in the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object. These eight bytes are never read nor written by SQLite since some VFSes (ex: Windows) might implement locks using mandatory file locks.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xShmLock () 메서드를 사용하여 파일 잠금을 지원하기 위해 헤더에 8 바이트의 공간이 별도로 설정되어 있습니다 . 일부 VFS (예 : Windows)는 필수 파일 잠금을 사용하여 잠금을 구현할 수 있으므로이 8 바이트는 SQLite에서 읽거나 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ace11e5b34a13ed99fabf311ff93445f3668386e" translate="yes" xml:space="preserve">
          <source>Either of the following input table schemas may be used:</source>
          <target state="translated">다음 입력 테이블 스키마 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d37f85cf0de81fb27668a49df7ae8937fb1c1d" translate="yes" xml:space="preserve">
          <source>Either the query is DISTINCT or else the ON or USING clause on the LEFT JOIN constrains the join such that it matches only a single row</source>
          <target state="translated">쿼리가 DISTINCT이거나 LEFT JOIN의 ON 또는 USING 절이 단일 행과 일치하도록 조인을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4728cde333d59654162b98fb2f80035a1df0e676" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is ASC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;gt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">그렇지 않으면 ORDER BY가 ASC이면 경계는 X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;gt; = X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 의 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="299837df5991cc66f1e3ca4e6217b98091245afa" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is DESC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;lt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">그렇지 않으면 ORDER BY가 DESC이면 경계는 X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;lt;= X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 의 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="ec4efc66414e2d0acccb9c6dda956e43ccfc0932" translate="yes" xml:space="preserve">
          <source>ElseNotEq</source>
          <target state="translated">ElseNotEq</target>
        </trans-unit>
        <trans-unit id="742075f0a90a29b1298aa6bdc53785796a5215d5" translate="yes" xml:space="preserve">
          <source>Embedded applications may wish to provide their own mutex implementation. If SQLite is compiled with the -DSQLITE_MUTEX_APPDEF=1 compile-time flag then the SQLite core provides no mutex subsystem and a mutex subsystem that matches the interface described above must be provided by the application that links against SQLite.</source>
          <target state="translated">임베디드 애플리케이션은 자체 뮤텍스 구현을 제공하고자 할 수 있습니다. SQLite가 -DSQLITE_MUTEX_APPDEF = 1 컴파일 타임 플래그로 컴파일 된 경우 SQLite 코어는 뮤텍스 서브 시스템을 제공하지 않으며 위에서 설명한 인터페이스와 일치하는 뮤텍스 서브 시스템은 SQLite와 링크되는 애플리케이션에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5634a9969e757fb962e238b6f317c641fe0f639" translate="yes" xml:space="preserve">
          <source>Embedded integers can be of arbitrary length. Comparison is not limited to integers that can be expressed as a 64-bit machine integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53320e0cd9a6276b0d7615514d5e92e35c47d10" translate="yes" xml:space="preserve">
          <source>Enable Or Disable A Session Object</source>
          <target state="translated">세션 객체 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="47209fc977a3d6844b590f95a2e890da8c62a167" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extended Result Codes</source>
          <target state="translated">확장 결과 코드 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="2ae5828f55ab597198616d5a6a29272c5472108b" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extension Loading</source>
          <target state="translated">확장 로딩 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="4f3889a08ab86ec8ddcc4be30913885c66215716" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Shared Pager Cache</source>
          <target state="translated">공유 호출기 캐시 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="9ea1888b42850afab6ed8b09793199ea8c9bea55" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">세션 객체에 의한 변경 기록을 활성화 또는 비활성화합니다. 사용 가능한 경우 세션 오브젝트는 데이터베이스의 변경 사항을 기록합니다. 비활성화되면 그렇지 않습니다. 새로 작성된 세션 오브젝트가 사용 가능합니다. 세션 객체 활성화 및 비활성화가 최종 변경 세트에 미치는 영향에 대한 자세한 내용은 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17f9b9420a663ed4c76c71c9c8073e9fc9710b0f" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">세션 객체에 의한 변경 기록을 활성화 또는 비활성화합니다. 사용 가능한 경우 세션 오브젝트는 데이터베이스의 변경 사항을 기록합니다. 비활성화되면 그렇지 않습니다. 새로 작성된 세션 오브젝트가 사용 가능합니다. 세션 객체 활성화 및 비활성화가 최종 변경 세트에 미치는 영향에 대한 자세한 내용은 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4dfbc50e373163a24f20145d89cc661c7f9016f" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the ESCAPE keyword is present and &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; is on.</source>
          <target state="translated">ESCAPE 키워드가 있고 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; 가 설정된 경우 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38bd8aad51460f777742311f6118d4753c58ac85" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check=ON&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check = ON&lt;/a&gt; 설정을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9de93a7abfad3451907ee76c7e8380b3e2a12e38" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR optimization&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대한 &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR 최적화&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="139b97f174f99845864a6e58fe92ec54c44c22d0" translate="yes" xml:space="preserve">
          <source>Enable the code the implements the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rbu&quot;&gt;RBU 확장을&lt;/a&gt; 구현하는 코드를 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a4b947c5d7c94485590879fd68adb16381cb913" translate="yes" xml:space="preserve">
          <source>Enabled &lt;a href=&quot;loadext#persist&quot;&gt;persistent loadable extensions&lt;/a&gt; using the new &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; return code from the extension entry point.</source>
          <target state="translated">사용 &lt;a href=&quot;loadext#persist&quot;&gt;지속로드 가능한 확장&lt;/a&gt; 새로운를 사용하여이 &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; 확장 진입 점에서 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ea330e39a61763b4ace4d9831f5c3c48035f13c" translate="yes" xml:space="preserve">
          <source>Enabling SQL manipulation of data in statistics packages like R</source>
          <target state="translated">R과 같은 통계 패키지에서 데이터의 SQL 조작 사용</target>
        </trans-unit>
        <trans-unit id="658589b85baec8128d8a55f7bca7bc8f71c38156" translate="yes" xml:space="preserve">
          <source>Enabling mutexes incurs a measurable performance penalty. So if speed is of utmost importance, it makes sense to disable the mutexes. But for maximum safety, mutexes should be enabled. The default behavior is for mutexes to be enabled.</source>
          <target state="translated">뮤텍스를 활성화하면 측정 가능한 성능 저하가 발생합니다. 따라서 속도가 가장 중요한 경우 뮤텍스를 비활성화하는 것이 좋습니다. 그러나 최대한의 안전을 위해 뮤텍스를 활성화해야합니다. 기본 동작은 뮤텍스를 활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2894e6ce65268ab410ea576f81be8b800728595" translate="yes" xml:space="preserve">
          <source>Enabling shared-cache for an in-memory database allows two or more database connections in the same process to have access to the same in-memory database. An in-memory database in shared cache is automatically deleted and memory is reclaimed when the last connection to that database closes.</source>
          <target state="translated">인 메모리 데이터베이스에 대해 공유 캐시를 활성화하면 동일한 프로세스에서 둘 이상의 데이터베이스 연결이 동일한 인 메모리 데이터베이스에 액세스 할 수 있습니다. 공유 캐시의 메모리 내 데이터베이스는 자동으로 삭제되고 해당 데이터베이스에 대한 마지막 연결이 닫히면 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="e9d959f1da0d822e6e152768cadbd40ebe86ec7f" translate="yes" xml:space="preserve">
          <source>Encoded Representation</source>
          <target state="translated">인코딩 된 표현</target>
        </trans-unit>
        <trans-unit id="ce95e3947ec272a5e059c01e37e860b0eadf0f49" translate="yes" xml:space="preserve">
          <source>EndCoroutine</source>
          <target state="translated">EndCoroutine</target>
        </trans-unit>
        <trans-unit id="227897f6614bd1979b06a47b741b2b7b86d2c18a" translate="yes" xml:space="preserve">
          <source>Ending a Read-only Transaction</source>
          <target state="translated">읽기 전용 트랜잭션 종료</target>
        </trans-unit>
        <trans-unit id="66d638205095ec32694e8e53496ae104a46818bd" translate="yes" xml:space="preserve">
          <source>Enhance &quot;&lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt;&quot; so that it shows the schema names for all attached if the name is anything other than &quot;main&quot;.</source>
          <target state="translated">이름이 &quot;main&quot;이외의 이름 인 경우 첨부 된 모든 스키마 이름을 표시하도록 &quot; &lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt; &quot;를 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="86691e1c27add4aa9b223b839c80106c74dae104" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2(TRUNCATE)&lt;/a&gt; interface so that it truncates the WAL file even if there is no checkpoint work to be done.</source>
          <target state="translated">검사 점 작업이 없어도 WAL 파일을 자르도록 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 (TRUNCATE)&lt;/a&gt; 인터페이스를 향상 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a80638ab16814f00dc09b0caf66656e977b1595" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; to avoid using excess stack space when there are a huge number of terms on the right-hand side of the MATCH operator. A side-effect of this change is that the MATCH operator can only accommodate 12 NEAR operators at a time.</source>
          <target state="translated">MATCH 연산자의 오른쪽에 많은 수의 용어가있을 때 초과 스택 공간을 사용하지 않도록 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 을 향상 시키십시오 . 이 변경의 부작용은 MATCH 운영자가 한 번에 12 명의 NEAR 운영자 만 수용 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9e7233e0df128965e10fbf74799b90510b5e89b" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; so that it recognizes &quot;true&quot; and &quot;false&quot; as valid arguments to DEFAULT.</source>
          <target state="translated">&quot;참&quot;및 &quot;거짓&quot;을 DEFAULT의 유효한 인수로 인식하도록 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="adabac8599a55ec6de7c3ac30be20a3119f8f411" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they verify &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 을 확인하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check을&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="536fdd0657f2b3142f09507f33c8fdf8c4fc486c" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; so that it identifies tables that have two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">동일한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 가진 둘 이상의 행이있는 테이블을 식별하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check를&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="6c8ab102b2516f5a84e5ee68a4f1dbbb2f643256" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; so that it provides information about &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;동일한 &lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 에 대한 정보를 제공하도록 PRAGMA table_info를 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="0ba1f90920b2bd9339636a57ccf3fdacffa95fd7" translate="yes" xml:space="preserve">
          <source>Enhance IN operator processing to make use of indices with numeric affinities.</source>
          <target state="translated">숫자 친화도가있는 인덱스를 사용하도록 IN 연산자 처리를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="38025365863e59085f7f2a503fa8e731d8d8f915" translate="yes" xml:space="preserve">
          <source>Enhance sqlite3_set_authorizer() to provide notification of calls to SQL functions.</source>
          <target state="translated">SQL 함수에 대한 호출 알림을 제공하도록 sqlite3_set_authorizer ()를 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="4c0c2336da07f0e2529ec9f7395eaa4d63613663" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;.lint fkey-indexes&quot; command so that it works with &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 과 함께 작동하도록 &quot;.lint fkey-indexes&quot;명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="f112cd8de55589eb0d44900a6dc12bd6545e1a14" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;&lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt;&quot; command to show the schema of all attached databases.</source>
          <target state="translated">&quot; &lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt; &quot;명령을 향상시켜 연결된 모든 데이터베이스의 스키마를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1450749989600a2169e792f923ae3be06e80b2a3" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;deserialize&quot; command of the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; to give it new &quot;--maxsize N&quot; and &quot;--readonly BOOLEAN&quot; options.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 의 &quot;직렬화 해제&quot;명령을 강화하여 새로운 &quot;--maxsize N&quot;및 &quot;--readonly BOOLEAN&quot;옵션을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="bc34eefa1c910b5c9ea20b6e33d4506c020abe02" translate="yes" xml:space="preserve">
          <source>Enhance the .filectrl command to support the --schema option.</source>
          <target state="translated">--schema 옵션을 지원하도록 .filectrl 명령을 개선하십시오.</target>
        </trans-unit>
        <trans-unit id="e9d52f4b3f406b97743f08bc0e546085a24804d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; interface so that it can be used to determine if SQLITE_DONE has been seen on the prepared statement.</source>
          <target state="translated">&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; 인터페이스를 개선하여 준비된 명령문에서 SQLITE_DONE이 있는지 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c405bef651c9af2e88b5ab4ee422e433b81082a5" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of interfaces and the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL function&lt;/a&gt; to put comma separators at the thousands marks for integers, if the &quot;,&quot; format modifier is used in between the &quot;%&quot; and the &quot;d&quot; (example: &quot;%,d&quot;).</source>
          <target state="translated">&quot;%&quot;와 &quot;d&quot;사이에 &quot;,&quot;형식 수정자가 사용되는 경우 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 인터페이스 인터페이스 및 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL 함수&lt;/a&gt; 를 개선하여 정수에 대한 수천 개의 표시에 쉼표 구분 기호를 배치하십시오 (예 : &quot;%, 디&quot;).</target>
        </trans-unit>
        <trans-unit id="ecc927d861dbadc6775d2c50454d6230fe66defe" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; mechanism so that nested SQL statements such as might be generated by virtual tables are shown but are shown in comments and without parameter expansion. This greatly improves tracing output when using the FTS3/4 and/or RTREE virtual tables.</source>
          <target state="translated">가상 테이블에 의해 생성 될 수있는 중첩 SQL 문이 표시되지만 주석과 매개 변수 확장없이 표시되도록 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 메커니즘을 향상 시키십시오 . 이는 FTS3 / 4 및 / 또는 RTREE 가상 테이블을 사용할 때 추적 출력을 크게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="cea177cb2c536b15d2be8672b409ec45ad8edd94" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that a non-zero argument to the &quot;.exit&quot; command causes the shell to exit immediately without cleanly shutting down the database connection.</source>
          <target state="translated">&quot;.exit&quot;명령에 대한 0이 아닌 인수로 인해 데이터베이스 연결을 완전히 종료하지 않고 쉘이 즉시 종료되도록 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘을&lt;/a&gt; 향상 시키 십시오.</target>
        </trans-unit>
        <trans-unit id="772c4e5a177463139498eb947b87f718df183bb0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; option so that it works in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; as long as the pages being read are not in the WAL file.</source>
          <target state="translated">읽고있는 페이지가 WAL 파일에없는 한 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 작동하도록 &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 옵션을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="a2b293874fb33d8df6143b9bdce0ba562527728b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option so that it works for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대해 작동하도록 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 타임 옵션을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="5fc1b69a4cc0c897120d80264056737d7bc2f24c" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; virtual table so that it can be a TEMP table.</source>
          <target state="translated">TEMP 테이블이 될 수 있도록 &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="cbfa3ac4fe2276010370af97ef50f174cd9f6489" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; query syntax so that &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filters&lt;/a&gt; may be applied to arbitrary expressions.</source>
          <target state="translated">&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;열 필터&lt;/a&gt; 가 임의의 표현식에 적용될 수 있도록 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 쿼리 구문을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac4e55168d2c25c1939a1629c34937f2515a40d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; virtual table to handle &quot;ORDER BY term&quot; efficiently.</source>
          <target state="translated">&quot;ORDER BY term&quot;을 효율적으로 처리 하도록 &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8e95c6938845927220cf396e7f0c74146b449c86" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;json1#jex&quot;&gt;json_extract()&lt;/a&gt; function to cache and reuse parses of JSON input text.</source>
          <target state="translated">&lt;a href=&quot;json1#jex&quot;&gt;json_extract ()&lt;/a&gt; 함수를 향상시켜 JSON 입력 텍스트의 구문 분석을 캐시하고 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0da54e01b930ee69209e9bd5617e79e614dba785" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to support the name of an index as its argument, in order to analyze just that one index.</source>
          <target state="translated">하나의 인덱스 만 분석하려면 인덱스 이름을 인수로 지원 하도록 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d919d17746299ff0de59c9893d2b29b08bd6e5c1" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command to support the IF NOT EXISTS clause.</source>
          <target state="translated">IF NOT EXISTS 절을 지원 하도록 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4351170db4e47371fac160f7e790286a7669ec9d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that the 'unixepoch' modifier works for the full span of supported dates.</source>
          <target state="translated">'unixepoch'수정자가 지원되는 모든 날짜 범위에서 작동하도록 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 기능을&lt;/a&gt; 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="98c955efd33e3f668b175fbbc0bf42eb02234928" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc' modifier&lt;/a&gt; in the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that it is a no-op if the date/time is known to already be in UTC. (This is not a compatibility break since the behavior has long been documented as &quot;undefined&quot; in that case.)</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간&lt;/a&gt; 이 이미 UTC로 알려진 경우 날짜 및 시간 함수 에서 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc'수정자를&lt;/a&gt; 향상 시키지 마십시오. (이 경우 동작이 오랫동안 &quot;정의되지 않음&quot;으로 문서화 되었기 때문에 호환성 문제가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="ba8fa245aa7effdf69df893d75d48b052b4da271" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; syntax to allow multiple rows to be inserted via the VALUES clause.</source>
          <target state="translated">VALUES 절을 통해 여러 행을 삽입 할 수 있도록 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 구문을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="39f00e6685deaa75aceff3c6d176c2d609bfced0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command so that pending queries are allowed to continue as long as the schema is unchanged. Formerly, a ROLLBACK would cause all pending queries to fail with an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. That error is still returned if the ROLLBACK modifies the schema.</source>
          <target state="translated">스키마가 변경되지 않는 한 보류중인 쿼리를 계속 사용할 수 있도록 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령을 향상 시키십시오 . 이전에는 ROLLBACK으로 인해 보류중인 모든 쿼리가 &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; 오류 와 함께 실패했습니다 . ROLLBACK이 스키마를 수정하면 해당 오류가 계속 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ae47128c1a762921f457e8e1bfe678e897d057" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it can store the parser object as a stack variable rather than allocating space from the heap and make use of that enhancement in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기를&lt;/a&gt; 향상시켜 파서 객체를 힙에서 공간을 할당하는 대신 스택 변수로 저장할 수 있고 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 에서 그 기능을 활용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0f666e6813fb5c4fe717347ffd40771c1d7b80b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; mechanism to be more flexible (while still maintaining backwards compatibility) in two ways:</source>
          <target state="translated">다음 과 같은 두 가지 방법으로 &lt;a href=&quot;loadext&quot;&gt;확장 로딩&lt;/a&gt; 메커니즘을보다 유연하게 (여전히 호환성을 유지하면서) 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="abd36cf21afd6f7d8bfb48fcbea3c10187ce565b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that it is able to flatten views on the right-hand side of a LEFT JOIN.</source>
          <target state="translated">왼쪽 결합의 오른쪽에서보기를 병합 할 수 있도록 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화를&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="897318b35a6a9404b9601809620b672a31ea4c74" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works for arbitrary expressions on the left-hand side as long as the LIKE pattern on the right-hand side does not begin with a digit or minus sign.</source>
          <target state="translated">오른쪽의 LIKE 패턴이 숫자 또는 빼기 부호로 시작하지 않는 한 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화가&lt;/a&gt; 향상되어 왼쪽에서 임의의 표현식에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48de942fdbd65dcbd99636658f1be1df7651f0d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan&lt;/a&gt; optimization so that it is able to skip index terms that occur in the middle of the index, not just as the left-hand side of the index.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔&lt;/a&gt; 최적화를 향상시켜 인덱스의 왼쪽뿐만 아니라 인덱스의 중간에서 발생하는 인덱스 용어를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2a8ec267addf3f625f62574683688a31353a8e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt; statement to accept a 32-bit integer parameter which is the threshold below which cache spilling is prohibited.</source>
          <target state="translated">캐시 유출이 금지되는 임계 값 이하인 32 비트 정수 매개 변수를 승인 하도록 &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt; 문을 향상 시키 십시오.</target>
        </trans-unit>
        <trans-unit id="6af9f76eeba6bbc6beb0d63968ad71854f553990" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;function_list pragma&lt;/a&gt; to show the number of arguments on each function, the type of function (scalar, aggregate, window), and the function property flags &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;, &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;, and/or &lt;a href=&quot;c3ref/c_deterministic#sqlitesubtype&quot;&gt;SQLITE_SUBTYPE&lt;/a&gt;.</source>
          <target state="translated">의 Enhance &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;function_list 프라그&lt;/a&gt; 각 기능에 대한 인수의 수, 기능 (스칼라, 집계, 윈도우)의 유형 및 기능 속성 플래그 보여 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; , &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; , &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; 및 / 또는 &lt;a href=&quot;c3ref/c_deterministic#sqlitesubtype&quot;&gt;SQLITE_SUBTYPE을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7925d1322092ec92042d18a4d3bf644989f4dd6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command for improved detection of problems on the page freelist.</source>
          <target state="translated">의 Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA의 integrity_check의&lt;/a&gt; 페이지 가능리스트에 문제의 개선 검출 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="219b1962c9f3fd940e59a7c4455cdb5d4fd58474" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to use much less memory when processing multi-gigabyte databases.</source>
          <target state="translated">멀티 기가 바이트 데이터베이스를 처리 할 때 훨씬 적은 메모리를 사용 하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="8df03990bad246d4ae7e8d5ff6f0df49f2131cd4" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; command so that the &quot;pk&quot; column is an increasing integer to show the order of columns in the primary key.</source>
          <target state="translated">&quot;pk&quot;열이 기본 키의 열 순서를 표시하기 위해 증가하는 정수가되도록 &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="467321e371cfce36156fc492790ccfffef995b05" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension to support &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;식에서 인덱스&lt;/a&gt; 를 지원 하도록 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="231b7b233c891814a3929090a78107d20ccb49c0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; interface so that it is hardened against attacks from deliberately corrupted &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 인터페이스를 향상시켜 의도적으로 손상된 &lt;a href=&quot;sessionintro#changeset&quot;&gt;변경 세트&lt;/a&gt; 객체의 공격에 대비하여 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d859c94c8aab395c8d624a4d2e4d798aac099e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt; to support &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 을 지원 하도록 &lt;a href=&quot;sessionintro&quot;&gt;세션 확장&lt;/a&gt; 을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="8752b22acf88cad45a773b2eaf772abcc4d468b3" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension so that the edit distance cost table can be changed at runtime by inserting a string like 'edit_cost_table=TABLE' into the &quot;command&quot; field.</source>
          <target state="translated">&quot;command_&quot;필드에 'edit_cost_table = TABLE'과 같은 문자열을 삽입하여 런타임에 편집 거리 비용 테이블을 변경할 수 있도록 &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8b13a66a5bb583f4d677f5f0eca1ac21ccbb9fa6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절 을 지원 하도록 &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9847e0191d05131d0f627947fd7ce04c0efa7b0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; virtual table so that it can search efficiently by rowid.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;rowfix로&lt;/a&gt; 효율적으로 검색 할 수 있도록 spellfix1 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="2aab8554cf986b2fcf65f02990aae7c32a2d4293" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program so that it shows the number of bytes of metadata on btree pages.</source>
          <target state="translated">btree 페이지에서 메타 데이터의 바이트 수를 표시하도록 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="9c1a0bc76cd9728f28938754bb61c49141b278e1" translate="yes" xml:space="preserve">
          <source>Enhance the Windows OS layer to provide detailed error codes</source>
          <target state="translated">자세한 오류 코드를 제공하도록 Windows OS 계층 향상</target>
        </trans-unit>
        <trans-unit id="28df058400861b985faef942373bae5431c24f4a" translate="yes" xml:space="preserve">
          <source>Enhance the page cache so that it can preallocate a block of memory to use for the initial set page cache lines. Set the default preallocation to 100 pages. Yields about a 5% performance increase on common workloads.</source>
          <target state="translated">초기 설정 페이지 캐시 라인에 사용할 메모리 블록을 사전 할당 할 수 있도록 페이지 캐시를 향상 시키십시오. 기본 사전 할당을 100 페이지로 설정하십시오. 일반 워크로드에서 약 5 %의 성능 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f43e9f09e30e90da585a7e2f997499c318811db5" translate="yes" xml:space="preserve">
          <source>Enhance the presentation concept beyond the simple linear sequence of slides to allow for side-tracks and excursions to be taken depending on how the audience is responding.</source>
          <target state="translated">간단한 선형 선형 슬라이드 시퀀스를 넘어서 프레젠테이션 개념을 향상시켜 청중의 반응에 따라 사이드 트랙 및 여행을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0cc6e91ac3090a90fc5fc0536b586ecd051561" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer so that ORDER BY clauses are more aggressively optimized, especially in joins where various terms of the ORDER BY clause come from separate tables of the join.</source>
          <target state="translated">ORDER BY 절의 다양한 용어가 별도의 조인 테이블에서 나오는 조인에서 ORDER BY 절이보다 적극적으로 최적화되도록 쿼리 최적화 프로그램을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="cb820f0118ef79630d408199d7422e6f8fb9737c" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer to exploit transitive join constraints.</source>
          <target state="translated">전 이적 조인 제약 조건을 활용하도록 쿼리 최적화 프로그램을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="e627de0a427baf27ab64042414ff38a649039427" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it always prefers an index that uses a superset of WHERE clause terms relative to some other index.</source>
          <target state="translated">쿼리 플래너가 다른 인덱스와 비교하여 WHERE 절 용어의 상위 세트를 사용하는 인덱스를 항상 선호하도록 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="d0052283e64299690870842cb9d496fab1611f5c" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it will try to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; on queries that make use of &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt;.</source>
          <target state="translated">쿼리 플래너를 향상시켜 쿼리를 사용 &lt;a href=&quot;optoverview#or_opt&quot;&gt;하거나 최적화&lt;/a&gt; 하는 쿼리에 적용 &lt;a href=&quot;queryplanner#covidx&quot;&gt;인덱스&lt;/a&gt; 를 사용하도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1d5782317135d4e9e1b715596bb2a96d2101b89" translate="yes" xml:space="preserve">
          <source>Enhance the query planner to permit &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; on FROM-clause subqueries that are implemented by co-routine.</source>
          <target state="translated">동시 루틴으로 구현되는 FROM- 절 서브 쿼리에서 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인 작성&lt;/a&gt; 을 허용하도록 쿼리 플래너를 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="40575878eee4f99d3db668f19cca94585d78c781" translate="yes" xml:space="preserve">
          <source>Enhance the query plans for joins to detect empty tables early and halt without doing unnecessary work.</source>
          <target state="translated">빈 테이블을 조기에 감지하고 불필요한 작업을 수행하지 않고 중지하도록 조인 쿼리 계획을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e270b8357535bbb251d02aee12541124f9d7c3b" translate="yes" xml:space="preserve">
          <source>Enhance virtual tables so that they can potentially use an index when the WHERE clause contains the IN operator.</source>
          <target state="translated">WHERE 절에 IN 연산자가 포함 된 경우 인덱스를 사용할 수 있도록 가상 테이블을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="64b37213a97e0883e534b3385cdb0e0b6f843807" translate="yes" xml:space="preserve">
          <source>Enhanced &quot;WHERE x NOT NULL&quot; &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; so that they are usable if the &quot;x&quot; column appears in a LIKE or GLOB operator.</source>
          <target state="translated">&quot;x&quot;열이 LIKE 또는 GLOB 연산자에 나타나는 경우 사용할 수 있도록 &quot;WHERE x NOT NULL&quot; &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="a53735f6ffe5602297bc4654161d4607e891ee5a" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; so that it interrupts &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations that are in process.</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()를&lt;/a&gt; 향상 시켜 처리중인 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 작업을 중단 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d9ce2a6349e3a16f7d2da3b2d327d63134ac2a74" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; so that it works for read-only databases.</source>
          <target state="translated">읽기 전용 데이터베이스에서 작동하도록 &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO가&lt;/a&gt; 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="d58eb320cd88342fcb6b05fb5333e1bcd0a48413" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to detect obscure row corruption that they were formerly missing. Also update both pragmas so that they return error text rather than SQLITE_CORRUPT when encountering corruption in &lt;a href=&quot;fileformat2#record_format&quot;&gt;records&lt;/a&gt;.</source>
          <target state="translated">향상된 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check을&lt;/a&gt; 그들이 이전에 없어진 것을 모호한 행 손상을 감지 할 수 있습니다. 또한 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드&lt;/a&gt; 가 손상 될 때 SQLITE_CORRUPT 대신 오류 텍스트를 반환하도록 두 pragma를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="02e341c795f6d9f53e59131ad36a699c4ff420f9" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; so that it works efficiently with transactions that are larger than the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;.</source>
          <target state="translated">강화 된 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 는보다 큰 거래를 효율적으로 작동하도록 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="938e043ef3afc8ac9c960dfd817d79b316b06aa6" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;:</source>
          <target state="translated">향상된 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7660b18630bc2b632af83f376ef82bda6bdc2e58" translate="yes" xml:space="preserve">
          <source>Enhanced Query Syntax Precedence</source>
          <target state="translated">향상된 쿼리 구문 우선 순위</target>
        </trans-unit>
        <trans-unit id="8bcd37976631ed421f835c87d3d23437e964c0a6" translate="yes" xml:space="preserve">
          <source>Enhanced output from EXPLAIN QUERY PLAN</source>
          <target state="translated">EXPLAIN QUERY PLAN의 향상된 출력</target>
        </trans-unit>
        <trans-unit id="1c6f13fb6731d5f1314775333c356324516fd9b6" translate="yes" xml:space="preserve">
          <source>Enhanced query syntax</source>
          <target state="translated">향상된 쿼리 구문</target>
        </trans-unit>
        <trans-unit id="dc0f782772ac6cdd040a571e5d1cd41d9b2afc70" translate="yes" xml:space="preserve">
          <source>Enhanced robustness against corrupt database files</source>
          <target state="translated">손상된 데이터베이스 파일에 대한 향상된 견고성</target>
        </trans-unit>
        <trans-unit id="9e2446878f5c7a8d27e1c2936004a6080d4f4b4a" translate="yes" xml:space="preserve">
          <source>Enhanced support for QNX.</source>
          <target state="translated">QNX에 대한 향상된 지원.</target>
        </trans-unit>
        <trans-unit id="0223b7b5ad2a577e9f0cf5bf1f244664a462bf07" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.explain&quot; output formatting of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that loops are indented to better show the structure of the program.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 &quot;.explain&quot;출력 형식이 향상되어 프로그램 구조를보다 잘 보여주기 위해 루프가 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="94edddbbf9619d5825cd24602cf6d956452cf785" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.stats&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to show more information about I/O performance obtained from /proc, when available.</source>
          <target state="translated">사용 가능한 경우 / proc에서 얻은 I / O 성능에 대한 자세한 정보를 표시 하도록 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 &quot;.stats&quot;명령이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="2aa8aa5b2dc44e64f3c9062e559b9b8c4adaf741" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.timer&quot; feature of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it shows wall-clock time in addition to system and user times.</source>
          <target state="translated">시스템 및 사용자 시간과 함께 벽시계 시간을 표시하도록 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 &quot;.timer&quot;기능이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9eedfea42ccb52b08d5d71e48835b1549173842" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;PRAGMA integrity_check&quot; command to verify indices.</source>
          <target state="translated">색인을 확인하기 위해 &quot;PRAGMA integrity_check&quot;명령이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb3be9ff58724d11d359ec60b1f2bdd37d420981" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; so that it accepts the last row of input if the final new-line character is missing.</source>
          <target state="translated">최종 개행 문자가 누락 된 경우 마지막 입력 행을 허용하도록 &lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블을&lt;/a&gt; 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="03045a32dbdfe87bdfc9bebef5d2e3a25bb91ada" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; so that it can be used as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; where the argument is the schema to be analyzed.</source>
          <target state="translated">인수가 분석 할 스키마 인 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 로 사용할 수 있도록 &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블을&lt;/a&gt; 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="ad6a5655675e95781c7a9176042eb4c49edd8c22" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; matching algorithm to be faster for cases when the pattern contains multiple wildcards.</source>
          <target state="translated">향상된 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 패턴이 여러 와일드 카드가 포함 된 경우 매칭 알고리즘은 빠른 경우에 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9c97dd68b6c9f22cde01203cef9708636a363e9d" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; so that it is able to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; as part of the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 플래닝의&lt;/a&gt; 일부로 &lt;a href=&quot;queryplanner#covidx&quot;&gt;포함 인덱스&lt;/a&gt; 를 사용할 수 있도록 &lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너가&lt;/a&gt; 향상 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="256c4a1bf22f495e02d25767299c762ded55fdd3" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works with an &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; 절 과 함께 작동하도록 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화가&lt;/a&gt; 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bde313d13aaa9fdf420067e179b8337b3404aa95" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to detect &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violations.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 명령이 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 제약 조건 위반 을 감지하도록 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7c51abaf51ff7f2df08f11da95255ddde7c74fef" translate="yes" xml:space="preserve">
          <source>Enhanced the comments that are inserted into &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 컴파일 타임 옵션이 활성화 될 때 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력에 삽입되는 주석이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="dff3454f906eefe264d191aaa218dcd2cf753166" translate="yes" xml:space="preserve">
          <source>Enhanced the default memory allocator to make use of _msize() on windows, malloc_size() on Mac, and malloc_usable_size() on Linux.</source>
          <target state="translated">Windows의 _msize (), Mac의 malloc_size () 및 Linux의 malloc_usable_size ()를 사용하도록 기본 메모리 할당자를 향상 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="8dccfbae6b585eff24791000050934f841f040bd" translate="yes" xml:space="preserve">
          <source>Enhanced the internal text-to-numeric conversion routines so that they work with UTF8 or UTF16, thereby avoiding some UTF16-to-UTF8 text conversions.</source>
          <target state="translated">내부 텍스트를 숫자로 변환하는 루틴을 향상시켜 UTF8 또는 UTF16에서 작동하므로 UTF16에서 UTFF8 로의 텍스트 변환을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6609f817a6cdf7acf014351660bd59875dbce83c" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; are able to make use of OR and IN operators in the WHERE clause.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 이 WHERE 절에서 OR 및 IN 연산자를 사용할 수 있도록 쿼리 최적화 프로그램이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8bc09d2f6561ee38b5b8b664bf1d3480673895a" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that it is able to use multiple indices to efficiently process &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR-connected constraints&lt;/a&gt; in a WHERE clause.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 연결 제약 조건&lt;/a&gt; 을 효율적으로 처리하기 위해 여러 인덱스를 사용할 수 있도록 쿼리 최적화 프로그램이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cbc1ad5cd7bef1c364230feb92b6f22c6fc43de9" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner flattening logic to allow UNION ALL compounds to be promoted upwards to replace a simple wrapper SELECT even if the compounds are joins.</source>
          <target state="translated">쿼리 플래너 병합 논리를 향상시켜 화합물이 결합 된 경우에도 UNION ALL 화합물을 위로 올리면 간단한 래퍼 SELECT를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4282b314fce027a8694a86f4759e991c3a4226cf" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that it can factor terms in and out of OR expressions in the WHERE clause in an effort to find better indices.</source>
          <target state="translated">더 나은 색인을 찾기 위해 WHERE 절에서 OR 표현식의 내부 및 외부로 용어를 인수 분해 할 수 있도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="c87a7d0685fbf2f5e8470e67e88964a89110390d" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that the xfer optimization can be used with INTEGER PRIMARY KEY ON CONFLICT as long as the destination table is initially empty.</source>
          <target state="translated">대상 테이블이 초기에 비어있는 한 INTEGER PRIMARY KEY ON CONFLICT와 함께 xfer 최적화를 사용할 수 있도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="930e0780c36ad4d8952bea14bbd67981a9f86931" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner to support index queries with range constraints on the rowid.</source>
          <target state="translated">rowid에 범위 제한이있는 인덱스 쿼리를 지원하도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6066357831db7e4ebf2e25439868067d246d8025" translate="yes" xml:space="preserve">
          <source>Enhanced the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; so that all system calls can be overridden using the xSetSystemCall interface.</source>
          <target state="translated">xSetSystemCall 인터페이스를 사용하여 모든 시스템 호출을 무시할 수 있도록 Windows &lt;a href=&quot;vfs&quot;&gt;VFS를&lt;/a&gt; 향상 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="cb3a978152b2c95d938f4ec5dfecdfd4dc03a088" translate="yes" xml:space="preserve">
          <source>Enhanced triggers so that they can use &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that exist in schemas other than the schema where the trigger is defined.</source>
          <target state="translated">트리거가 정의 된 스키마 이외의 스키마에 존재 하는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 를 사용할 수 있도록 향상된 트리거</target>
        </trans-unit>
        <trans-unit id="297f948f999cfb4c21e3fe30f5e217f38826c758" translate="yes" xml:space="preserve">
          <source>Enhancements the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f946c53a255ba7d27e70b7ff3738d27f161850fa" translate="yes" xml:space="preserve">
          <source>Enhancements the command-line shell:</source>
          <target state="translated">명령 행 쉘을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="e09172df6aacada6ccbcf1a3a11e6a3c3af4636e" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;QUERY PLAN 설명&lt;/a&gt; 개선 .</target>
        </trans-unit>
        <trans-unit id="db4d9e44ef71d40ff1e7e4dbe80b15d3513543b3" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;, so that it generates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 기능이 향상되어 더 빠른 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ef9855917607b6442c695951a3f7754c39d33b47" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they can optionally check just a single attached database instead of all attached databases.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 기능이 향상되어 연결된 모든 데이터베이스 대신 연결된 단일 데이터베이스 만 선택적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e60f213182ea7cd574f070de9a038e0287e1d3a" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; processing that ensure that at least one valid read-mark is available at all times, so that read-only processes can always read the database.</source>
          <target state="translated">읽기 전용 프로세스가 항상 데이터베이스를 읽을 수 있도록 하나 이상의 유효한 읽기 표시를 항상 사용할 수 있도록하는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 처리 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="088c949064c93e6690dd186376b133008579ec58" translate="yes" xml:space="preserve">
          <source>Enhancements to FTS4:</source>
          <target state="translated">FTS4의 향상된 기능 :</target>
        </trans-unit>
        <trans-unit id="4b227272818268b73b926c2192e43b3603222a58" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interface:</source>
          <target state="translated">&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 인터페이스 의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="b9dd3ac79af68e2372047ab33b4b26d154857e4a" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, mostly to support testing and debugging of the SQLite library itself:</source>
          <target state="translated">주로 SQLite 라이브러리 자체의 테스트 및 디버깅을 지원 하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="fa6f25098613c466df6cb1b3c3e2f32bf515195d" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="9316eb92f3fb8393c8d086dc09173f0ba01a3c1c" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="f3b9e87c6fa6f39266403ab6cc48cf4b6737e704" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; for working with IEEE 754 binary64 numbers.</source>
          <target state="translated">IEEE 754 binary64 숫자 작업을위한 &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 확장&lt;/a&gt; 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a5c7ab4a0f809431a8ff58a35ffa041e958442f1" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;geopoly&quot;&gt;geopoly&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;geopoly&quot;&gt;지오 폴리&lt;/a&gt; 확장 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="e5b6cb44cb4a567950e71ad422f75b3ca4e22c90" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it creates a smaller and faster SQL parser.</source>
          <target state="translated">더 작고 빠른 SQL 파서를 &lt;a href=&quot;lemon&quot;&gt;생성&lt;/a&gt; 하도록 레몬 파서 생성기의 기능 향상</target>
        </trans-unit>
        <trans-unit id="15944ac14355213e9f3cb2cebd5dc54b91adbbac" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the left-hand side column has numeric affinity.</source>
          <target state="translated">왼쪽 열에 숫자 선호도가있는 경우 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화&lt;/a&gt; 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="adcb27ea2162302878492824ccdd337602297736" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 확장 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="08a98f05f116677a58ecae89a193381dca3467a0" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 향상 :</target>
        </trans-unit>
        <trans-unit id="edf69de137296726150f431f3016d8e1e1082416" translate="yes" xml:space="preserve">
          <source>Enhancements to the query planner:</source>
          <target state="translated">쿼리 플래너의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="887cd62dcf1fd561060a7f3820e302dbe0e7e1de" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program to provide size information separately for each individual index of a table, in addition to the aggregate size.</source>
          <target state="translated">sqlite3_analyzer 유틸리티 프로그램이 향상되어 집계 크기 외에 테이블의 각 개별 인덱스에 대해 크기 정보를 별도로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d0b79f3e5d56b3b3ee7240cd85a024ed61c576ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program, including the --pageinfo and --stats options and support for multiplexed databases.</source>
          <target state="translated">--pageinfo 및 --stats 옵션 및 다중화 된 데이터베이스 지원을 포함하여 sqlite3_analyzer 유틸리티 프로그램의 개선 사항.</target>
        </trans-unit>
        <trans-unit id="37973a2aab5304ee633b9d20aeca0be76434d6ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c extension to support stdio-like interfaces with quotas.</source>
          <target state="translated">할당량으로 stdio 같은 인터페이스를 지원하도록 test_quota.c 확장 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="a1ba10f45054081b97f16d5bc6e667a78fce6d45" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c module so that it can track preexisting files.</source>
          <target state="translated">기존 파일을 추적 할 수 있도록 test_quota.c 모듈이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="071262c4e43816b952c8af7674854fa203027685" translate="yes" xml:space="preserve">
          <source>Ensure durability following a power loss with &quot;PRAGMA journal_mode=TRUNCATE&quot; by calling fsync() right after truncating the journal file.</source>
          <target state="translated">저널 파일을 자른 직후 fsync ()를 호출하여 &quot;PRAGMA journal_mode = TRUNCATE&quot;로 전원 손실에 따른 내구성을 보장하십시오.</target>
        </trans-unit>
        <trans-unit id="763267566a8b7c92a18ab7a9852c919207037954" translate="yes" xml:space="preserve">
          <source>Ensure that ALTER TABLE modifies table and column names embedded in WITH clauses that are part of views and triggers.</source>
          <target state="translated">ALTER TABLE이 뷰 및 트리거의 일부인 WITH 절에 포함 된 테이블 및 컬럼 이름을 수정하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6f4e25c9d19972ec4e16af218b9ac640575e4282" translate="yes" xml:space="preserve">
          <source>Ensure that floating point values are preserved exactly when reconstructing a database from the output of the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 &quot;.dump&quot;명령 출력에서 ​​데이터베이스를 재구성 할 때 부동 소수점 값이 정확하게 유지되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f3d6acbe6809d0d4b5ba59e3106dfa722b6856" translate="yes" xml:space="preserve">
          <source>Ensure that indexed expressions with collating sequences are handled correctly. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5&lt;/a&gt;.</source>
          <target state="translated">조합 순서가있는 색인화 된 표현식이 올바르게 처리되는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="320fb77964ce8dd238dcf51a0d55555931872f7c" translate="yes" xml:space="preserve">
          <source>Ensure that prepared statements automatically reset on extended error codes of SQLITE_BUSY and SQLITE_LOCKED even when compiled using &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;.</source>
          <target state="translated">SQLITE_OMIT_AUTORESET을 사용하여 컴파일 된 경우에도 준비된 명령문이 SQLITE_BUSY 및 SQLITE_LOCKED의 확장 오류 코드에서 자동으로 재설정 &lt;a href=&quot;compile#omit_autoreset&quot;&gt;되는지 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73ff9e87e31a6b30accfec1ac5b07289b8ed1a4a" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; counters in the sqlite_sequence table are initialized doing &quot;Xfer Optimization&quot; on &quot;INSERT ... SELECT&quot; statements. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c&lt;/a&gt;.</source>
          <target state="translated">sqlite_sequence 테이블 의 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 카운터가 &quot;INSERT ... SELECT&quot;문에서 &quot;Xfer Optimization&quot;을 수행하여 초기화 되었는지 확인하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="1edcdd81c8138145ea48433a6dac68321ba6e0c9" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface can correctly handle short rows. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스가 짧은 행을 올바르게 처리 할 수 있는지 확인하십시오 . &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="f2b0dfe3853d12157319b6b0f40a3e7dfe9eef04" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner knows that any column of a &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; LEFT JOIN can be NULL even if that column is labeled with &quot;NOT NULL&quot;. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;.</source>
          <target state="translated">열에 &quot;NOT NULL&quot;로 레이블이 지정되어 있어도 &lt;a href=&quot;optoverview#flattening&quot;&gt;플랫 화 된&lt;/a&gt; LEFT JOIN의 열이 NULL 일 수 있다는 것을 쿼리 플래너가 알고 있는지 확인하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="4d45306d706d54fdd9fd4abd095a83e5c593f770" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner never tries to use a self-made transient index in place of a schema-defined index.</source>
          <target state="translated">쿼리 플래너가 스키마 정의 인덱스 대신 자체 만든 임시 인덱스를 사용하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="c4719004d8e5511993396b7647b091764d35ec35" translate="yes" xml:space="preserve">
          <source>Ensuring that</source>
          <target state="translated">그것을 보장</target>
        </trans-unit>
        <trans-unit id="8b17ecadc249ae5820d4616f49592537cf85eaca" translate="yes" xml:space="preserve">
          <source>Enter SQL commands at the prompt to create and populate the new database.</source>
          <target state="translated">프롬프트에서 SQL 명령을 입력하여 새 데이터베이스를 작성하고 채우십시오.</target>
        </trans-unit>
        <trans-unit id="083f743b36c02cef28d51a51219ba95b2ec6026d" translate="yes" xml:space="preserve">
          <source>Enterprise-class client/server SQL database engines do not normally make this guarantee. In client/server SQL database engines, the server keeps track of statistics on the sizes of tables and on the quality of indexes and the query planner uses those statistics to help select the best plans. As content is added, deleted, or changed in the database, the statistics will evolve and may cause the query planner to begin using a different query plan for some particular query. Usually the new plan will be better for the evolving structure of the data. But sometimes the new query plan will cause a performance reduction. With a client/server database engine, there is typically a Database Administrator (DBA) on hand to deal with these rare problems as they come up. But DBAs are not available to fix problems in an embedded database like SQLite, and hence SQLite is careful to ensure that plans do not change unexpectedly after deployment.</source>
          <target state="translated">엔터프라이즈 급 클라이언트 / 서버 SQL 데이터베이스 엔진은 일반적으로이 보장을하지 않습니다. 클라이언트 / 서버 SQL 데이터베이스 엔진에서 서버는 테이블 크기 및 인덱스 품질에 대한 통계를 추적하며 쿼리 플래너는 이러한 통계를 사용하여 최상의 계획을 선택합니다. 데이터베이스에서 컨텐츠가 추가, 삭제 또는 변경되면 통계가 발전하여 쿼리 플래너가 특정 쿼리에 대해 다른 쿼리 계획을 사용하기 시작할 수 있습니다. 일반적으로 새로운 계획은 진화하는 데이터 구조에 적합합니다. 그러나 때때로 새로운 쿼리 계획으로 인해 성능이 저하 될 수 있습니다. 클라이언트 / 서버 데이터베이스 엔진을 사용하면 이러한 드문 문제가 발생할 때이를 처리하기 위해 일반적으로 데이터베이스 관리자 (DBA)가 있습니다. 그러나 DBA는 SQLite와 같은 임베디드 데이터베이스에서 문제를 해결하는 데 사용할 수 없습니다.따라서 SQLite는 배포 후 계획이 예기치 않게 변경되지 않도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="016d284bc7fd185fb86cbef4e6f410ad531ec41f" translate="yes" xml:space="preserve">
          <source>Entries may be added to a zip archive by inserting new rows. The easiest way to do this is to specify values for the &quot;name&quot; and &quot;data&quot; columns only and have zipfile fill in sensible defaults for other fields. To insert a directory into the archive, set the &quot;data&quot; column to NULL. For example, to add the directory &quot;dir1&quot; and the file &quot;m.txt&quot; containing the text &quot;abcdefghi&quot; to zip archive &quot;test.zip&quot;:</source>
          <target state="translated">새 행을 삽입하여 Zip 아카이브에 항목을 추가 할 수 있습니다. 가장 쉬운 방법은 &quot;name&quot;및 &quot;data&quot;열의 값만 지정하고 zipfile이 다른 필드의 기본 값을 채우도록하는 것입니다. 아카이브에 디렉토리를 삽입하려면 &quot;data&quot;열을 NULL로 설정하십시오. 예를 들어, &quot;dir1&quot;디렉토리와 &quot;abcdefghi&quot;텍스트를 포함하는 &quot;m.txt&quot;파일을 zip 아카이브 &quot;test.zip&quot;에 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e2f64a45118887196b8716103b9556bdce2656b8" translate="yes" xml:space="preserve">
          <source>Entries within a doclist are sorted by docid. Positions within a doclist entry are stored in ascending order.</source>
          <target state="translated">doclist 내의 항목은 docid별로 정렬됩니다. doclist 항목 내의 위치는 오름차순으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8bffcbc21c3bf69becb564637d592afa3a71b0f7" translate="yes" xml:space="preserve">
          <source>Eponymous virtual table</source>
          <target state="translated">시조 가상 테이블</target>
        </trans-unit>
        <trans-unit id="afcfba63ae8c7c116df2f46471e75a3359724931" translate="yes" xml:space="preserve">
          <source>Eq</source>
          <target state="translated">Eq</target>
        </trans-unit>
        <trans-unit id="4b4a2f957af622a456d578794d868743c5030e6f" translate="yes" xml:space="preserve">
          <source>Equivalent sqlite3.exe Command</source>
          <target state="translated">동등한 sqlite3.exe 명령</target>
        </trans-unit>
        <trans-unit id="c73f93f4b9a02f4e5a949fd11052e3a166c6f2ac" translate="yes" xml:space="preserve">
          <source>Error Codes And Messages</source>
          <target state="translated">오류 코드 및 메시지</target>
        </trans-unit>
        <trans-unit id="7fc353a0378a6af6e63cb4e746bbbbd0e56d46cc" translate="yes" xml:space="preserve">
          <source>Error Logging Interface</source>
          <target state="translated">오류 로깅 인터페이스</target>
        </trans-unit>
        <trans-unit id="e124b3535d5c4804fddcec1bfc75b893589b726b" translate="yes" xml:space="preserve">
          <source>Errors related to attempting to retrieve column values other than docid are runtime errors that occur within sqlite3_step(). In some cases, for example if the MATCH expression in a SELECT query matches zero rows, there may be no error at all even if a statement does refer to column values other than docid.</source>
          <target state="translated">docid 이외의 열 값 검색 시도와 관련된 오류는 sqlite3_step () 내에서 발생하는 런타임 오류입니다. 예를 들어 SELECT 쿼리의 MATCH식이 0 개의 행과 일치하는 경우 명령문이 docid 이외의 열 값을 참조하더라도 오류가 전혀 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2037e33c6466adf8969b72c11fda6491583b0bfa" translate="yes" xml:space="preserve">
          <source>Errors returned by &quot;close&quot; invocations are always ignored.</source>
          <target state="translated">&quot;close&quot;호출에 의해 리턴 된 오류는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba0ca62e050a94c881b9cbcdd137fb7152c40f3" translate="yes" xml:space="preserve">
          <source>Escape control characters in JSON strings. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt;.</source>
          <target state="translated">JSON 문자열에서 제어 문자를 이스케이프하십시오. &lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="1cb7d33bba7989feceb4f470ecd1849be76ca550" translate="yes" xml:space="preserve">
          <source>Establish a shared lock on the database file using the SQLite API (i.e. the shell tool).</source>
          <target state="translated">SQLite API (즉, 셸 도구)를 사용하여 데이터베이스 파일에 공유 잠금을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acdfd966a90117b3a07f2283d0066679d289a192" translate="yes" xml:space="preserve">
          <source>Established a Git mirror of the offical SQLite source tree. The canonical sources for SQLite are maintained using the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; at &lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt;. The Git mirror can be seen at &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt;.</source>
          <target state="translated">공식 SQLite 소스 트리의 Git 미러를 설정했습니다. SQLite의 표준 소스 는 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt; 의 &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; 를 사용하여 유지됩니다 . Git 미러는 &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfac7c251d7e73e29a463cec3912b52bd890b9a8" translate="yes" xml:space="preserve">
          <source>Estimate the number of rows in the table P1. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if that estimate is less than approximately 2**(0.1*P3).</source>
          <target state="translated">테이블 P1의 행 수를 추정하십시오. 추정치가 약 2 ** (0.1 * P3)보다 작 으면 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f07e6ba2d9a77c57620b0b92e2928b26dca79a5c" translate="yes" xml:space="preserve">
          <source>Estimate the sizes of table and index rows and use the smallest applicable B-Tree for full scans and &quot;count(*)&quot; operations.</source>
          <target state="translated">테이블 및 인덱스 행의 크기를 추정하고 전체 스캔 및 &quot;count (*)&quot;작업에 적용 가능한 가장 작은 B-Tree를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8465fee9c60fa18c66485376de57ad47eb492b1" translate="yes" xml:space="preserve">
          <source>Evaluate An SQL Statement</source>
          <target state="translated">SQL 문 평가</target>
        </trans-unit>
        <trans-unit id="494757b93d645c3ec03e2cb39c698d02501c9269" translate="yes" xml:space="preserve">
          <source>Evaluate WHERE clause constraints involving correlated subqueries last, in the hope that they never have be evaluated at all.</source>
          <target state="translated">상관 하위 쿼리가 포함 된 WHERE 절 제약 조건은 마지막으로 평가 된 적이 없기 때문에 마지막에 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="f5f8716393fff4c33fd231cf4a1b3dfd35e3ce79" translate="yes" xml:space="preserve">
          <source>Evaluate terms of the WHERE clause that only involve columns from the first table. If any term is false (meaning that the whole WHERE clause must be false) then skip the rest of this loop and continue to the next record.</source>
          <target state="translated">첫 번째 테이블의 열만 포함하는 WHERE 절의 용어를 평가하십시오. 용어가 거짓이면 (전체 WHERE 절이 거짓이어야 함을 의미)이 루프의 나머지 부분을 건너 뛰고 다음 레코드로 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="e98cbf4cf1877f0ce5b5cb8101d45d36a7f1c8d6" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; by calling &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; one or more times.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 한 번 이상 호출 하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 평가하십시오 .</target>
        </trans-unit>
        <trans-unit id="afc24d20b1189859f163127fa057eee2672ebd26" translate="yes" xml:space="preserve">
          <source>Even after the original data of a database page has been written into the journal file using calls to the journal file file-handle xWrite method (section</source>
          <target state="translated">저널 파일 file-handle xWrite 메소드에 대한 호출을 사용하여 데이터베이스 페이지의 원래 데이터가 저널 파일에 기록 된 후에도 (섹션</target>
        </trans-unit>
        <trans-unit id="5499799ae4809c21043cab7ce18584b7a12c2dc6" translate="yes" xml:space="preserve">
          <source>Even if an application or system failure does not occur while a</source>
          <target state="translated">응용 프로그램 또는 시스템 오류가 발생하지 않은 경우에도</target>
        </trans-unit>
        <trans-unit id="02ed13066a4e0b144f34e2ad6070e86a20374570" translate="yes" xml:space="preserve">
          <source>Even if the application does not deliberately accept database files from untrusted sources, beware of attacks in which a local database file is altered. For best security, any database file which might have ever been writable by an agent in a different security domain should be treated as suspect.</source>
          <target state="translated">응용 프로그램이 신뢰할 수없는 소스의 데이터베이스 파일을 고의로 받아들이지 않더라도 로컬 데이터베이스 파일이 변경되는 공격에주의하십시오. 최상의 보안을 위해 다른 보안 도메인의 에이전트가 쓸 수 있었던 모든 데이터베이스 파일은 의심스러운 파일로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="680fadd60094a533809d5b7446aadfd1591e54a1" translate="yes" xml:space="preserve">
          <source>Even if the application does not deliberately accept database files from untrusted sources, beware of attacks in which a local database file is surreptitiously altered to contain harmful content.</source>
          <target state="translated">응용 프로그램이 신뢰할 수없는 소스의 데이터베이스 파일을 고의로 받아들이지 않더라도 로컬 데이터베이스 파일이 유해한 내용을 포함하도록 명백하게 변경되는 공격에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="c9ba37d0d3bee815cbbaa36b0c20151324c7ee1f" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">이 함수가 0을 리턴하더라도 세션 핸들에서 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 을 호출 하면 변경 사항이없는 변경 세트를 계속 리턴 할 수 있습니다. 연결된 테이블의 행이 수정 된 후 나중에 원래 값이 복원 될 때 발생할 수 있습니다. 그러나이 함수가 0이 아닌 값을 반환하면 sqlite3session_changeset ()을 호출하면 변경 사항이 0이 아닌 변경 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50ed987259f75ac65d7652aac78952559c72c7f6" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">이 함수가 0을 리턴하더라도 세션 핸들에서 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 을 호출 하면 변경 사항이없는 변경 세트를 계속 리턴 할 수 있습니다. 연결된 테이블의 행이 수정 된 후 나중에 원래 값이 복원 될 때 발생할 수 있습니다. 그러나이 함수가 0이 아닌 값을 반환하면 sqlite3session_changeset ()을 호출하면 변경 사항이 0이 아닌 변경 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="400a8e0a43afcabf1ad09a38d392479429277735" translate="yes" xml:space="preserve">
          <source>Even in the JOIN form, the query can be made clearer through the use of row values:</source>
          <target state="translated">JOIN 양식에서도 행 값을 사용하여 쿼리를보다 명확하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5632548c0bc2270c52cd3517d4c2d3312ffda6" translate="yes" xml:space="preserve">
          <source>Even though SQLite allows the datatype to be omitted, it is still a good idea to include it in your CREATE TABLE statements, since the data type often serves as a good hint to other programmers about what you intend to put in the column. And if you ever port your code to another database engine, that other engine will probably require a datatype of some kind. SQLite accepts all the usual datatypes. For example:</source>
          <target state="translated">SQLite에서 데이터 유형을 생략 할 수는 있지만 CREATE TABLE 문에 포함하는 것이 좋습니다. 데이터 유형은 종종 다른 프로그래머에게 열에 넣을 대상에 대한 좋은 힌트로 사용되기 때문입니다. 그리고 코드를 다른 데이터베이스 엔진으로 이식 한 경우 다른 엔진에 일종의 데이터 유형이 필요할 수 있습니다. SQLite는 모든 일반적인 데이터 유형을 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ba77bb0cea9f5158d237371e94228e6f6766570" translate="yes" xml:space="preserve">
          <source>Even though a disk file is allocated for each temporary database, in practice the temporary database usually resides in the in-memory pager cache and hence is very little difference between a pure in-memory database created by &quot;:memory:&quot; and a temporary database created by an empty filename. The sole difference is that a &quot;:memory:&quot; database must remain in memory at all times whereas parts of a temporary database might be flushed to disk if database becomes large or if SQLite comes under memory pressure.</source>
          <target state="translated">디스크 파일이 각 임시 데이터베이스에 할당 되더라도 실제로 임시 데이터베이스는 일반적으로 메모리 내 호출기 캐시에 상주하므로 &quot;: memory :&quot;에 의해 생성 된 순수한 메모리 내 데이터베이스와 임시 데이터베이스 간에는 거의 차이가 없습니다. 빈 파일 이름으로 생성됩니다. 유일한 차이점은 &quot;: memory :&quot;데이터베이스는 항상 메모리에 남아 있어야하지만 데이터베이스가 커지거나 SQLite가 메모리 부족 상태에있는 경우 임시 데이터베이스의 일부가 디스크로 플러시 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30543192e192dd4d27222f9a28b926a35b6f7b01" translate="yes" xml:space="preserve">
          <source>Even though it is possible to open a read-only WAL-mode database, it is good practice to converted to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=DELETE&lt;/a&gt; prior to burning an SQLite database image onto read-only media.</source>
          <target state="translated">읽기 전용 WAL 모드 데이터베이스를 열 수는 있지만 SQLite 데이터베이스 이미지를 읽기 전용 미디어에 굽기 전에 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = DELETE&lt;/a&gt; 로 변환하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0c6df707f631d9b02f87ed26337109bf5dac9246" translate="yes" xml:space="preserve">
          <source>Even though it may not be possible to attribute the row to a specific database table, it may be part of a tree structure within the database file. In this case, the root page number of that tree structure is stored in this column. Or, if the page the row was found on is not part of a tree structure, this column stores a copy of the value in column &quot;pgno&quot; - the page number of the page the row was found on. In many, although not all, cases, all rows in the lost_and_found table with the same value in this column belong to the same table.</source>
          <target state="translated">행을 특정 데이터베이스 테이블에 지정하지 못할 수도 있지만 데이터베이스 파일 내 트리 구조의 일부일 수 있습니다. 이 경우 해당 트리 구조의 루트 페이지 번호가이 열에 저장됩니다. 또는 행을 찾은 페이지가 트리 구조의 일부가 아닌 경우이 열은 &quot;pgno&quot;열에 값의 사본을 저장합니다 (행이 발견 된 페이지의 페이지 번호). 전부는 아니지만 많은 경우에이 열에서 같은 값을 가진 lost_and_found 테이블의 모든 행은 같은 테이블에 속합니다.</target>
        </trans-unit>
        <trans-unit id="1d9b26bf7bc27f4c82b4fef5ddd5b50d847ddf5d" translate="yes" xml:space="preserve">
          <source>Even though open-source users do not have direct access to TH3, all users of SQLite benefit from TH3 indirectly since each version of SQLite is validated running TH3 on multiple platforms (Linux, Windows, WinRT, Mac, OpenBSD) prior to release. So anyone using an official release of SQLite can deploy their application with the confidence of knowing that it has been tested using TH3. They simply cannot rerun those tests themselves without purchasing a TH3 license.</source>
          <target state="translated">오픈 소스 사용자는 TH3에 직접 액세스 할 수 없지만 SQLite의 모든 버전은 릴리스 전에 여러 플랫폼 (Linux, Windows, WinRT, Mac, OpenBSD)에서 TH3을 실행하는 것으로 검증되므로 모든 SQLite 사용자는 TH3을 간접적으로 활용할 수 있습니다. 따라서 공식 SQLite 릴리스를 사용하는 사람은 TH3을 사용하여 테스트되었음을 ​​알면서 자신의 응용 프로그램을 배포 할 수 있습니다. TH3 라이센스를 구매하지 않고서는 테스트를 스스로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="022ac40cfda55e83a99de9e911e78bfc09ab9640" translate="yes" xml:space="preserve">
          <source>Even though sqlite_stat1 does not have a PRIMARY KEY, changes are recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes are recorded for rows for which (idx IS NULL) is true. However, for such rows a zero-length blob (SQL value X'') is stored in the changeset or patchset instead of a NULL value. This allows such changesets to be manipulated by legacy implementations of sqlite3changeset_invert(), concat() and similar.</source>
          <target state="translated">sqlite_stat1에 PRIMARY KEY가 없더라도 PRIMARY KEY가 (tbl, idx) 인 것처럼 변경 사항이 기록됩니다. 또한 (idx IS NULL)에 해당하는 행에 대한 변경 사항이 기록됩니다. 그러나 이러한 행의 경우 길이가 0 인 블롭 (SQL 값 X '')이 NULL 값 대신 변경 세트 또는 패치 세트에 저장됩니다. 이를 통해 sqlite3changeset_invert (), concat () 및 이와 유사한 레거시 구현을 통해 이러한 변경 세트를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9461afee379ce7062d22cecc827bf8826de4bdca" translate="yes" xml:space="preserve">
          <source>Even though the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; function only allows the caller to specify a single user-context pointer, an unlock-notify callback is passed an array of such context pointers. This is because if when a blocking connection concludes its transaction, if there is more than one unlock-notify registered to call the same C function, the context-pointers are marshaled into an array and a single callback issued. If each thread were assigned a priority, then instead of just signaling the threads in arbitrary order as this implementation does, higher priority threads could be signaled before lower priority threads.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 함수는 호출자가 단일 사용자 컨텍스트 포인터를 지정할 수 있도록 허용 하지만 잠금 해제 알림 콜백에는 이러한 컨텍스트 포인터의 배열이 전달됩니다. 이는 차단 연결이 트랜잭션을 완료 할 때 동일한 C 함수를 호출하도록 등록 된 하나 이상의 잠금 해제 알림이있는 경우 컨텍스트 포인터가 배열로 마샬링되고 단일 콜백이 발행되기 때문입니다. 각 스레드에 우선 순위가 할당 된 경우,이 구현에서와 같이 임의의 순서로 스레드에 신호를 보내는 대신 우선 순위가 높은 스레드보다 우선 순위가 높은 스레드에 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef242512e741cb13f0a9ba0e8d336abee8249668" translate="yes" xml:space="preserve">
          <source>Even though the database</source>
          <target state="translated">비록 데이터베이스가</target>
        </trans-unit>
        <trans-unit id="31dfaf84589e564bfee1b65ff3c5d7573077d711" translate="yes" xml:space="preserve">
          <source>Even though the function prototype shows that xEntryPoint() takes no arguments and returns void, SQLite invokes xEntryPoint() with three arguments and expects an integer result as if the signature of the entry point where as follows:</source>
          <target state="translated">함수 프로토 타입에서 xEntryPoint ()가 인수를 사용하지 않고 void를 리턴하는 것으로 표시하더라도 SQLite는 세 개의 인수로 xEntryPoint ()를 호출하고 다음과 같이 진입 점의 서명처럼 정수 결과를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="4b42b7e22dd2091056535ea5f248d0c4a2e55603" translate="yes" xml:space="preserve">
          <source>Even when the SQLITE_ENABLE_SORTER_REFERENCES compile-time option is on, sorter references are still disabled by default. To use sorter references, the application must set a sorter reference size threshold using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt;) interface at start-time.</source>
          <target state="translated">SQLITE_ENABLE_SORTER_REFERENCES 컴파일 타임 옵션이 켜져 있어도 정렬 기 참조는 기본적으로 여전히 사용 불가능합니다. 분류기 참조를 사용하려면 응용 프로그램은 시작시 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt; ) 인터페이스를 사용하여 분류기 참조 크기 임계 값을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9faf17aed220247be5c3b4b3c5ce1890f9062f4" translate="yes" xml:space="preserve">
          <source>Eventually, the writing process will want to update the database file, either because its memory cache has filled up or because it is ready to commit its changes. Before this happens, the writer must make sure no other process is reading the database and that the rollback journal data is safely on the disk surface so that it can be used to rollback incomplete changes in the event of a power failure. The steps are as follows:</source>
          <target state="translated">결국 쓰기 프로세스는 메모리 캐시가 가득 찼거나 변경 사항을 커밋 할 준비가 되었기 때문에 데이터베이스 파일을 업데이트하려고합니다. 이 작업을 수행하기 전에 기록기는 다른 프로세스가 데이터베이스를 읽고 있지 않아야하며 롤백 저널 데이터가 디스크 표면에 안전하게 있어야 전원 장애시 불완전한 변경을 롤백하는 데 사용할 수 있습니다. 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89e7b1ca2d523bd7c0cba8f71e13245a8608c1a8" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">모든 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은 다음 구조의 서브 클래스를 사용하여 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 가리키고 가상 테이블 을 반복하는 데 사용되는 커서를 설명 합니다. 커서는 모듈 의 &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; 메소드를 사용하여 작성되며 xClose 메소드에 의해 &lt;a href=&quot;vtab#xclose&quot;&gt;제거&lt;/a&gt; 됩니다. 커서는 모듈 의 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; , &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; , &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메소드에서 사용됩니다. 각 모듈 구현은 자체 요구에 맞게 커서 구조의 내용을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="736f9f0cc1331d7eb8b3f3146d63e9ed826e6bf1" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">모든 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은이 개체의 서브 클래스를 사용하여 가상 테이블 의 특정 인스턴스를 설명 &lt;a href=&quot;vtab&quot;&gt;합니다&lt;/a&gt; . 각 서브 클래스는 모듈 구현의 특정 요구에 맞게 조정됩니다. 이 슈퍼 클래스의 목적은 모든 모듈 구현에 공통적 인 특정 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97f4ee6ffc1e6119472d334b08a9eb970b87d195" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;../vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;../vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">모든 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은 다음 구조의 서브 클래스를 사용하여 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 가리키고 가상 테이블 을 반복하는 데 사용되는 커서를 설명 합니다. 커서는 모듈 의 &lt;a href=&quot;../vtab#xopen&quot;&gt;xOpen&lt;/a&gt; 메소드를 사용하여 작성되며 xClose 메소드에 의해 &lt;a href=&quot;../vtab#xclose&quot;&gt;제거&lt;/a&gt; 됩니다. 커서는 모듈 의 &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; , &lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt; , &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메소드에서 사용됩니다. 각 모듈 구현은 자체 요구에 맞게 커서 구조의 내용을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4a7edaa14334e8a1c0b858598b1fb6dee8c4645f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">모든 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은이 개체의 서브 클래스를 사용하여 가상 테이블 의 특정 인스턴스를 설명 &lt;a href=&quot;../vtab&quot;&gt;합니다&lt;/a&gt; . 각 서브 클래스는 모듈 구현의 특정 요구에 맞게 조정됩니다. 이 슈퍼 클래스의 목적은 모든 모듈 구현에 공통적 인 특정 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f5bf4a9e3a3b1713480df787f65c0a1a83ce231" translate="yes" xml:space="preserve">
          <source>Every CREATE TABLE statement must specify a name for the new table. Table names that begin with &quot;sqlite_&quot; are reserved for internal use. It is an error to attempt to create a table with a name that starts with &quot;sqlite_&quot;.</source>
          <target state="translated">모든 CREATE TABLE 문은 새 테이블의 이름을 지정해야합니다. &quot;sqlite_&quot;로 시작하는 테이블 이름은 내부 용으로 예약되어 있습니다. &quot;sqlite_&quot;로 시작하는 이름을 가진 테이블을 작성하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c09016ba5ad82dc79c272414a45cdfd7263b163c" translate="yes" xml:space="preserve">
          <source>Every FTS table has a &lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;hidden column&lt;/a&gt; with the same name as the table itself. The value contained in each row for the hidden column is a blob that is only useful as the left operand of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operator, or as the left-most argument to one of the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">모든 FTS 테이블에는 테이블 자체와 이름이 같은 &lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 있습니다. 숨겨진 열의 각 행에 포함 된 값은 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; 연산자 의 왼쪽 피연산자 또는 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 함수&lt;/a&gt; 중 하나의 가장 왼쪽 인수 로만 유용한 블롭입니다 .</target>
        </trans-unit>
        <trans-unit id="993c036bb5f364557a67f157a0c471a9889968ba" translate="yes" xml:space="preserve">
          <source>Every SQL database engine compiles each SQL statement into some kind of internal data structure which is then used to carry out the work of the statement. But in most SQL engines that internal data structure is a complex web of interlinked structures and objects. In SQLite, the compiled form of statements is a short program in a machine-language like representation. Users of the database can view this &lt;a href=&quot;opcode&quot;&gt;virtual machine language&lt;/a&gt; by prepending the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; keyword to a query.</source>
          <target state="translated">모든 SQL 데이터베이스 엔진은 각 SQL 문을 일종의 내부 데이터 구조로 컴파일 한 다음 명령문의 작업을 수행하는 데 사용됩니다. 그러나 대부분의 SQL 엔진에서 내부 데이터 구조는 상호 연결된 구조와 개체의 복잡한 웹입니다. SQLite에서 컴파일 된 명령문 형식은 기계 언어와 유사한 표현의 짧은 프로그램입니다. 데이터베이스 사용자는 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 키워드를 쿼리 앞에 추가 하여이 &lt;a href=&quot;opcode&quot;&gt;가상 머신 언어&lt;/a&gt; 를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="127b4b3b406ae503f3997bc734ac5e49c93499f4" translate="yes" xml:space="preserve">
          <source>Every SQL statement that SQLite interprets results in a program for the virtual machine. But if the SQL statement begins with the keyword &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; the virtual machine will not execute the program. Instead, the instructions of the program will be returned, one instruction per row, like a query result. This feature is useful for debugging and for learning how the virtual machine operates. For example:</source>
          <target state="translated">SQLite가 해석하는 모든 SQL 문은 가상 머신에 대한 프로그램을 생성합니다. 그러나 SQL 문이 키워드 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN으로&lt;/a&gt; 시작 하면 가상 머신은 프로그램을 실행하지 않습니다. 대신 프로그램 결과가 쿼리 결과처럼 행당 하나의 명령으로 반환됩니다. 이 기능은 디버깅 및 가상 머신 작동 방식을 학습하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c76ae55ded832cccc106e5cddd7373805f7aff24" translate="yes" xml:space="preserve">
          <source>Every SQLite database contains a single &quot;schema table&quot; that stores the schema for that database. The schema for a database is a description of all of the other tables, indexes, triggers, and views that are contained within the database. The schema table looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05725310bea32a87080c57a7b88490274c131486" translate="yes" xml:space="preserve">
          <source>Every WITHOUT ROWID table must have a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. An error is raised if a CREATE TABLE statement with the WITHOUT ROWID clause lacks a PRIMARY KEY.</source>
          <target state="translated">모든 WITHOUT ROWID 테이블에는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 가 있어야합니다 . WITHOUT ROWID 절이있는 CREATE TABLE 문에 PRIMARY KEY가 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a2a07182d50aca4f020b64628bbefdfb26b38c35" translate="yes" xml:space="preserve">
          <source>Every argv entry will have a non-NULL value in C but may contain the SQL value NULL. In other words, it is always true that &lt;code&gt;argv[i]!=0&lt;/code&gt; for &lt;b&gt;i&lt;/b&gt; between 0 and &lt;code&gt;argc-1&lt;/code&gt;. However, it might be the case that &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt;.</source>
          <target state="translated">모든 argv 항목은 C에서 NULL이 아닌 값을 가지지 만 SQL 값 NULL을 포함 할 수 있습니다. 즉, 항상 사실이다 &lt;code&gt;argv[i]!=0&lt;/code&gt; 에 대한 &lt;b&gt;I&lt;/b&gt; 0 내지 &lt;code&gt;argc-1&lt;/code&gt; . 그러나 &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f0b85ad6b7e5f1d163dd080cc52ed9499f5b4a" translate="yes" xml:space="preserve">
          <source>Every b-tree page has at most one parent b-tree page. A b-tree page without a parent is called a root page. A root b-tree page together with the closure of its children form a complete b-tree. It is possible (and in fact rather common) to have a complete b-tree that consists of a single page that is both a leaf and the root. Because there are pointers from parents to children, every page of a complete b-tree can be located if only the root page is known. Hence, b-trees are identified by their root page number.</source>
          <target state="translated">모든 b- 트리 페이지에는 최대 하나의 부모 b- 트리 페이지가 있습니다. 부모가없는 b- 트리 페이지를 루트 페이지라고합니다. 루트 b- 트리 페이지와 자식 폐쇄와 함께 완전한 b- 트리가 형성됩니다. 리프와 루트 인 단일 페이지로 구성된 완전한 b- 트리를 가질 수 있습니다 (실제로는 다소 일반적 임). 부모로부터 자식에 대한 포인터가 있기 때문에 루트 페이지 만 알려진 경우 전체 b- 트리의 모든 페이지를 찾을 수 있습니다. 따라서 b- 트리는 루트 페이지 번호로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="55a99fde5c029672563046825e6673a5103f75ad" translate="yes" xml:space="preserve">
          <source>Every bytecode program has a fixed (but potentially large) number of registers. A single register can hold a variety of objects:</source>
          <target state="translated">모든 바이트 코드 프로그램에는 고정 된 (그러나 잠재적으로 큰) 수의 레지스터가 있습니다. 단일 레지스터는 다양한 객체를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87fc7f1f92913eaea5a702a31bf26215c9004f47" translate="yes" xml:space="preserve">
          <source>Every column of every table has an associated collating function. If no collating function is explicitly defined, then the collating function defaults to BINARY. The COLLATE clause of the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt; is used to define alternative collating functions for a column.</source>
          <target state="translated">모든 테이블의 모든 열에는 연관된 조합 기능이 있습니다. 조합 기능이 명시 적으로 정의되지 않은 경우 조합 기능의 기본값은 BINARY입니다. &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;열 정의&lt;/a&gt; 의 COLLATE 절은 열에 대한 대체 조합 함수를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3214d30b9335d3698a80d09df52d21c7f7db6f83" translate="yes" xml:space="preserve">
          <source>Every database consists of one or more &quot;pages&quot;. Within a single database, every page is the same size, but different database can have page sizes that are powers of two between 512 and 65536, inclusive. The maximum size of a database file is 2147483646 pages. At the maximum page size of 65536 bytes, this translates into a maximum database size of approximately 1.4e+14 bytes (140 terabytes, or 128 tebibytes, or 140,000 gigabytes or 128,000 gibibytes).</source>
          <target state="translated">모든 데이터베이스는 하나 이상의 &quot;페이지&quot;로 구성됩니다. 단일 데이터베이스 내에서 모든 페이지의 크기는 동일하지만 다른 데이터베이스는 512에서 65536 사이의 2의 제곱 인 페이지 크기를 가질 수 있습니다. 데이터베이스 파일의 최대 크기는 2147483646 페이지입니다. 65536 바이트의 최대 페이지 크기에서 이는 약 1.4e + 14 바이트 (140 테라 바이트 또는 128 바이트 또는 140,000 기가 바이트 또는 128,000 기가 바이트)의 최대 데이터베이스 크기로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c2e6403515f1bf32ac4e648a9caa0419f6afeca1" translate="yes" xml:space="preserve">
          <source>Every database consists of one or more &quot;pages&quot;. Within a single database, every page is the same size, but different database can have page sizes that are powers of two between 512 and 65536, inclusive. The maximum size of a database file is 4294967294 pages. At the maximum page size of 65536 bytes, this translates into a maximum database size of approximately 1.4e+14 bytes (281 terabytes, or 256 tebibytes, or 281474 gigabytes or 256,000 gibibytes).</source>
          <target state="translated">모든 데이터베이스는 하나 이상의 &quot;페이지&quot;로 구성됩니다. 단일 데이터베이스 내에서 모든 페이지의 크기는 동일하지만 서로 다른 데이터베이스는 512에서 65536 (포함) 사이의 두 제곱 인 페이지 크기를 가질 수 있습니다. 데이터베이스 파일의 최대 크기는 4294967294 페이지입니다. 65536 바이트의 최대 페이지 크기에서 이는 약 1.4e + 14 바이트 (281 테라 바이트 또는 256 테비 바이트 또는 281474 기가 바이트 또는 256,000 기가 바이트)의 최대 데이터베이스 크기로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="492468356f24318b48960ab6726d183969622442" translate="yes" xml:space="preserve">
          <source>Every effort has been made to ensure that the various combinations of compilation options work harmoniously and produce a working library. Nevertheless, it is strongly recommended that the SQLite test-suite be executed to check for errors before using an SQLite library built with non-standard compilation options.</source>
          <target state="translated">다양한 컴파일 옵션 조합이 조화롭게 작동하고 작업 라이브러리를 생성하기 위해 모든 노력을 기울였습니다. 그럼에도 불구하고 비표준 컴파일 옵션으로 빌드 된 SQLite 라이브러리를 사용하기 전에 오류를 확인하기 위해 SQLite 테스트 스위트를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="851c55d70f2242d9f00006ba4265653d3268a46b" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드로 열린 모든 파일 은 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 (또는보다 일반적으로 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 서브 클래스 )를이 오브젝트의 인스턴스에 대한 포인터로 채 웁니다 . 이 오브젝트는 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트가 나타내는 열린 파일에 대해 다양한 조작을 수행하는 데 사용되는 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="acba6a710579420286ddba1b5725059065fac3c6" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드로 열린 모든 파일 은 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 (또는보다 일반적으로 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 서브 클래스 )를이 오브젝트의 인스턴스에 대한 포인터로 채 웁니다 . 이 오브젝트는 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트가 나타내는 열린 파일에 대해 다양한 조작을 수행하는 데 사용되는 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="41db9f975be9405dd8cb84bdb860cef93b013806" translate="yes" xml:space="preserve">
          <source>Every leaf entry and node (subtree) within the R*Tree has an integer &quot;level&quot;. The leaves have a level of 0. The first containing subtree of the leaves has a level of 1. The root of the R*Tree has the largest level value. The mxLevel entry in the sqlite3_rtree_query_info structure is the level value for the root of the R*Tree. The iLevel entry in sqlite3_rtree_query_info gives the level for the object being interrogated.</source>
          <target state="translated">R * Tree 내의 모든 리프 항목과 노드 (하위 트리)에는 정수 &quot;레벨&quot;이 있습니다. 잎의 레벨은 0입니다. 잎의 첫 번째 포함 하위 트리의 레벨은 1입니다. R * Tree의 루트는 가장 큰 레벨 값을 갖습니다. sqlite3_rtree_query_info 구조의 mxLevel 항목은 R * Tree 루트의 레벨 값입니다. sqlite3_rtree_query_info의 iLevel 항목은 심문중인 오브젝트의 레벨을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b83b5bef3193f9d71b5510c871842564bded152b" translate="yes" xml:space="preserve">
          <source>Every member in the organization has a name, and most members have a single boss. (The head of the whole organization has a NULL &quot;boss&quot; field.) The rows of the &quot;org&quot; table form a tree.</source>
          <target state="translated">조직의 모든 구성원은 이름을 가지며 대부분의 구성원은 단일 보스를 갖습니다. 전체 조직의 헤드에는 NULL &quot;보스&quot;필드가 있습니다. &quot;org&quot;테이블의 행은 트리를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="8f03f228f31451b11bb432dc265147274d2ce013" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">모든 새 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결은&lt;/a&gt; 기본적으로 임계 값 1000 또는 &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 페이지로 자동 검사 점이 사용되도록 설정됩니다 . 기본 설정이 특정 응용 프로그램에 적합하지 않은 경우에만이 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7af72a8a5bd73c0f21a3d8802bbfe1036436982" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">모든 새 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결은&lt;/a&gt; 기본적으로 임계 값 1000 또는 &lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 페이지로 자동 검사 점이 사용되도록 설정됩니다 . 기본 설정이 특정 응용 프로그램에 적합하지 않은 경우에만이 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="690c0362c23abb50bf57905b3d0de565bf19cc04" translate="yes" xml:space="preserve">
          <source>Every now and then someone discovers a new failure mode for the atomic commit mechanism in SQLite and the developers have to put in a patch. This is happening less and less and the failure modes are becoming more and more obscure. But it would still be foolish to suppose that the atomic commit logic of SQLite is entirely bug-free. The developers are committed to fixing these bugs as quickly as they might be found.</source>
          <target state="translated">때때로 누군가는 SQLite에서 원자 커밋 메커니즘에 대한 새로운 실패 모드를 발견하고 개발자는 패치를 넣어야합니다. 이것은 점점 줄어들고 있으며 실패 모드는 점점 더 모호 해지고 있습니다. 그러나 SQLite의 원자 커밋 로직에 완전히 버그가 없다고 가정하는 것은 여전히 ​​어리석은 일입니다. 개발자는 이러한 버그를 발견 할 수있는 한 빨리 해결하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f4785ec886c54cc0fadcbaced75cf5fb546955b" translate="yes" xml:space="preserve">
          <source>Every row of a table has a unique rowid. If the table defines a column with the type &quot;INTEGER PRIMARY KEY&quot; then that column becomes an alias for the rowid. But with or without an INTEGER PRIMARY KEY column, every row still has a rowid.</source>
          <target state="translated">테이블의 모든 행에는 고유 한 rowid가 있습니다. 테이블이 &quot;INTEGER PRIMARY KEY&quot;유형의 컬럼을 정의하면 해당 컬럼은 rowid의 별명이됩니다. 그러나 INTEGER PRIMARY KEY 열 유무에 관계없이 모든 행에는 여전히 rowid가 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c2c192e2c163c4bc5aa39b793ee2331ee10eba" translate="yes" xml:space="preserve">
          <source>Every row of an SQLite table has a unique integer key. If the table has a column labeled INTEGER PRIMARY KEY, then that column serves as the key. If there is no INTEGER PRIMARY KEY column then the key is a unique integer. The key for a row can be accessed in a SELECT statement or used in a WHERE or ORDER BY clause using any of the names &quot;ROWID&quot;, &quot;OID&quot;, or &quot;_ROWID_&quot;.</source>
          <target state="translated">SQLite 테이블의 모든 행에는 고유 한 정수 키가 있습니다. 테이블에 INTEGER PRIMARY KEY로 레이블 된 열이 있으면 해당 열이 키로 사용됩니다. INTEGER PRIMARY KEY 열이 없으면 키는 고유 한 정수입니다. 행의 키는 SELECT 문에서 액세스하거나 &quot;ROWID&quot;, &quot;OID&quot;또는 &quot;_ROWID_&quot;이름을 사용하여 WHERE 또는 ORDER BY 절에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523f1beb41c9b6ccdf7d3e8baf9a9fab841b07a9" translate="yes" xml:space="preserve">
          <source>Every table (except the &quot;sqlite_master&quot; table itself) and every named index in an SQLite database has an entry in the sqlite_master table. You can query this table using a SELECT statement just like any other table. But you are not allowed to directly change the table using UPDATE, INSERT, or DELETE. Changes to sqlite_master have to occur using the CREATE and DROP commands because SQLite also has to update some of its internal data structures when tables and indices are added or destroyed.</source>
          <target state="translated">모든 테이블 ( &quot;sqlite_master&quot;테이블 자체 제외)과 SQLite 데이터베이스의 모든 명명 된 인덱스에는 sqlite_master 테이블에 항목이 있습니다. 다른 테이블과 마찬가지로 SELECT 문을 사용하여이 테이블을 쿼리 할 수 ​​있습니다. 그러나 UPDATE, INSERT 또는 DELETE를 사용하여 테이블을 직접 변경할 수 없습니다. SQLite는 테이블과 인덱스를 추가하거나 제거 할 때 내부 데이터 구조 중 일부를 업데이트해야하기 때문에 CREATE 및 DROP 명령을 사용하여 sqlite_master를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee8f8904135a756c4539e015e36cc2347848e522" translate="yes" xml:space="preserve">
          <source>Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do no necessarily have an affinity.</source>
          <target state="translated">모든 테이블 열은 선호도 유형 (BLOB, TEXT, INTEGER, REAL 또는 NUMERIC 중 하나)을 갖지만 표현식에는 반드시 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f32098850bf86d28dad50eda2ef7aba6cca6adf4" translate="yes" xml:space="preserve">
          <source>Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do not necessarily have an affinity.</source>
          <target state="translated">모든 테이블 열에는 유형 선호도 (BLOB, TEXT, INTEGER, REAL 또는 NUMERIC 중 하나)가 있지만 표현식에 반드시 선호도가있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ed8a6fcdde7fff586bbaf9d083a7c2eda68dd03" translate="yes" xml:space="preserve">
          <source>Every table must have at least one non-generated column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b08058b164391fddf9b32eae0d934e211c5565" translate="yes" xml:space="preserve">
          <source>Every union-vtab must be in the TEMP namespace. Hence, the &quot;&lt;b&gt;temp.&lt;/b&gt;&quot; prior to</source>
          <target state="translated">모든 union-vtab은 TEMP 네임 스페이스에 있어야합니다. 따라서 이전 의 &quot; &lt;b&gt;온도&lt;/b&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="07d98b3ee8d9544f097098f5c8c00f7db4bddabb" translate="yes" xml:space="preserve">
          <source>Every valid SQLite database file begins with the following 16 bytes (in hex): 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00. This byte sequence corresponds to the UTF-8 string &quot;SQLite format 3&quot; including the nul terminator character at the end.</source>
          <target state="translated">유효한 모든 SQLite 데이터베이스 파일은 다음 16 바이트 (16 진수)로 시작합니다. 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00.이 바이트 시퀀스는 UTF-8 문자열 &quot;SQLite 형식 3&quot;에 해당합니다. 끝에 널 종료 문자.</target>
        </trans-unit>
        <trans-unit id="3fb9e9a96d68ea92a8c52ca6ed6ad8f58a99797f" translate="yes" xml:space="preserve">
          <source>Every value in SQLite has one of five fundamental datatypes:</source>
          <target state="translated">SQLite의 모든 값에는 5 가지 기본 데이터 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfeeeccf4fe9e729f75c5da5ce8becce10cd642f" translate="yes" xml:space="preserve">
          <source>Every virtual machine that &lt;b&gt;sqlite_compile&lt;/b&gt; creates should eventually be handed to &lt;b&gt;sqlite_finalize&lt;/b&gt;. The sqlite_finalize() procedure deallocates the memory and other resources that the virtual machine uses. Failure to call sqlite_finalize() will result in resource leaks in your program.</source>
          <target state="translated">&lt;b&gt;sqlite_compile이&lt;/b&gt; 생성 하는 모든 가상 머신 은 결국 &lt;b&gt;sqlite_finalize&lt;/b&gt; 로 전달되어야합니다 . sqlite_finalize () 프로시 저는 가상 머신이 사용하는 메모리 및 기타 자원을 할당 해제합니다. sqlite_finalize ()를 호출하지 않으면 프로그램에서 리소스가 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="441d9ec48f064dd7fdb10449b684859c580c29d7" translate="yes" xml:space="preserve">
          <source>Everything works correctly if any of the following are true:</source>
          <target state="translated">다음 중 하나라도 해당되면 모든 것이 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8604e6b6fdb1f3b4989ca256181c53477f03dab5" translate="yes" xml:space="preserve">
          <source>Exactly how a constraint violation is dealt with is determined by the &lt;a href=&quot;lang_conflict&quot;&gt;constraint conflict resolution algorithm&lt;/a&gt;. Each PRIMARY KEY, UNIQUE, NOT NULL and CHECK constraint has a default conflict resolution algorithm. PRIMARY KEY, UNIQUE and NOT NULL constraints may be explicitly assigned a default conflict resolution algorithm by including a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; in their definitions. Or, if a constraint definition does not include a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; or it is a CHECK constraint, the default conflict resolution algorithm is ABORT. Different constraints within the same table may have different default conflict resolution algorithms. See the section titled &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; for additional information.</source>
          <target state="translated">제약 조건 위반을 처리하는 방법은 제약 &lt;a href=&quot;lang_conflict&quot;&gt;조건 충돌 해결 알고리즘에&lt;/a&gt; 의해 결정됩니다 . 각 PRIMARY KEY, UNIQUE, NOT NULL 및 CHECK 제약 조건에는 기본 충돌 해결 알고리즘이 있습니다. PRIMARY KEY, UNIQUE 및 NOT NULL 제약 조건에는 정의에 &lt;a href=&quot;syntax/conflict-clause&quot;&gt;충돌 절&lt;/a&gt; 을 포함시켜 기본 충돌 해결 알고리즘이 명시 적으로 할당 될 수 있습니다 . 또는 제약 조건 정의에 &lt;a href=&quot;syntax/conflict-clause&quot;&gt;충돌 절이&lt;/a&gt; 포함되어 있지 않거나 CHECK 제약 조건 인 경우 기본 충돌 해결 알고리즘은 ABORT입니다. 동일한 테이블 내에서 서로 다른 제약 조건에는 기본 충돌 해결 알고리즘이 다를 수 있습니다. 추가 정보는 &lt;a href=&quot;lang_conflict&quot;&gt;충돌시&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea502dec1cc13ee575d4e1a550b73652d77d9edc" translate="yes" xml:space="preserve">
          <source>Exactly how such a potential race-condition is handled depends on the threads and synchronization primitives interface used by the application. This example uses pthreads, the interface provided by modern UNIX-like systems, including Linux.</source>
          <target state="translated">이러한 잠재적 경쟁 조건이 처리되는 방식은 응용 프로그램에서 사용하는 스레드 및 동기화 기본 인터페이스에 따라 다릅니다. 이 예제는 Linux를 포함한 최신 UNIX 유사 시스템에서 제공하는 인터페이스 인 pthread를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8bb56a9e102b28af62ab0fa87c8a54e2b7c186a7" translate="yes" xml:space="preserve">
          <source>Example 1: Loading and Saving In-Memory Databases</source>
          <target state="translated">예 1 : 메모리 내 데이터베이스로드 및 저장</target>
        </trans-unit>
        <trans-unit id="51937c8938bd2ebee4b2832c7cafa5f90c5d7f5e" translate="yes" xml:space="preserve">
          <source>Example 2: Online Backup of a Running Database</source>
          <target state="translated">예 2 : 실행중인 데이터베이스의 온라인 백업</target>
        </trans-unit>
        <trans-unit id="422445b132a0ddb86add309db860ce13ab867af6" translate="yes" xml:space="preserve">
          <source>Example Code</source>
          <target state="translated">예제 코드</target>
        </trans-unit>
        <trans-unit id="4899b03c6613d4db35e464f13d4310eba09ed242" translate="yes" xml:space="preserve">
          <source>Example Typenames From The</source>
          <target state="translated">의 유형 이름 예</target>
        </trans-unit>
        <trans-unit id="c6f5f53793eadfd32dbab5c6aaa82a0136b96344" translate="yes" xml:space="preserve">
          <source>Example illustrating the difference between the &quot;simple&quot; and &quot;porter&quot; tokenizers:</source>
          <target state="translated">&quot;단순&quot;및 &quot;포터&quot;토크 나이저의 차이점을 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ef9725acb0b6336e45af3212bad902a609b4a04c" translate="yes" xml:space="preserve">
          <source>Example: Let the index be</source>
          <target state="translated">예 : 인덱스를</target>
        </trans-unit>
        <trans-unit id="e401b272925dcc99ebcfccff32208c1de26ee958" translate="yes" xml:space="preserve">
          <source>Example: To verify that an R*Tree named &quot;demo_index&quot; is well-formed and internally consistent, run:</source>
          <target state="translated">예 : 이름이 &quot;demo_index&quot;인 R * Tree가 올바르게 구성되어 있고 내부적으로 일관성이 있는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a2d6c3cd648514e93054fc43de972ef1a1395513" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, all rows within SQLite tables have a 64-bit signed integer key that uniquely identifies the row within its table. This integer is usually called the &quot;rowid&quot;. The rowid value can be accessed using one of the special case-independent names &quot;rowid&quot;, &quot;oid&quot;, or &quot;_rowid_&quot; in place of a column name. If a table contains a user defined column named &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot;, then that name always refers the explicitly declared column and cannot be used to retrieve the integer rowid value.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외하고 SQLite 테이블 내의 모든 행에는 테이블 내의 행을 고유하게 식별하는 64 비트 부호있는 정수 키가 있습니다. 이 정수는 보통 &quot;rowid&quot;라고합니다. rowid 값은 열 이름 대신 대소 문자를 구분하지 않는 특수 이름 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;중 하나를 사용하여 액세스 할 수 있습니다. 테이블에 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;라는 사용자 정의 열이 포함 된 경우 해당 이름은 항상 명시 적으로 선언 된 열을 나타내며 정수 rowid 값을 검색하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="248eb9944419f3599ba80de676ca2d1922746437" translate="yes" xml:space="preserve">
          <source>Except for the WHERE clause, the structure of the program for this example is very much like the prior example, just with an extra column. There are now 3 columns, instead of 2 as before, and there are three ColumnName instructions. A cursor is opened using the OpenRead instruction, just like in the prior example. The Rewind instruction at address 6 and the Next at address 17 form a loop over all records of the table. The Close instruction at the end is there to give the Rewind instruction something to jump to when it is done. All of this is just like in the first query demonstration.</source>
          <target state="translated">WHERE 절을 제외하고이 예제의 프로그램 구조는 추가 열이있는 이전 예제와 매우 유사합니다. 이전과 같이 2가 아니라 3 개의 열이 있으며 3 개의 ColumnName 명령어가 있습니다. 이전 예에서와 같이 OpenRead 명령어를 사용하여 커서가 열립니다. 주소 6의 되감기 명령과 주소 17의 다음 되감기 명령은 테이블의 모든 레코드에 대해 루프를 형성합니다. 마지막에 닫기 명령은 되감기 명령이 완료되면 바로 이동할 수 있도록합니다. 이 모든 것은 첫 번째 쿼리 데모와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7141d556020acb770b395a3f91e4943886944cf0" translate="yes" xml:space="preserve">
          <source>Except for the read operation required by H35070 and those reads made as part of opening a read-only transaction, SQLite shall ensure that a</source>
          <target state="translated">H35070에 필요한 읽기 작업과 읽기 전용 트랜잭션을 여는 과정에서 작성된 읽기를 제외하고 SQLite는</target>
        </trans-unit>
        <trans-unit id="daf367d9a62995933815a1367ba71ebafe36cdd3" translate="yes" xml:space="preserve">
          <source>Except in the case of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections with &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; turned on, all transactions in SQLite show &quot;serializable&quot; isolation. SQLite implements serializable transactions by actually serializing the writes. There can only be a single writer at a time to an SQLite database. There can be multiple database connections open at the same time, and all of those database connections can write to the database file, but they have to take turns. SQLite uses locks to serialization of the writes automatically; this is not something that the applications using SQLite need to worry with.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; 가 설정된 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 데이터베이스 연결 의 경우를 제외하고 SQLite의 모든 트랜잭션에는 &quot;직렬화 가능&quot;격리가 표시됩니다. SQLite는 실제로 쓰기를 직렬화하여 직렬화 가능한 트랜잭션을 구현합니다. SQLite 데이터베이스에는 한 번에 하나의 작성자 만있을 수 있습니다. 동시에 여러 개의 데이터베이스 연결이 열릴 수 있으며 모든 해당 데이터베이스 연결은 데이터베이스 파일에 쓸 수 있지만 차례를 바꿔야합니다. SQLite는 잠금을 사용하여 쓰기의 직렬화를 자동으로 수행합니다. 이것은 SQLite를 사용하는 응용 프로그램이 걱정해야 할 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="375d2d4de08327323baabaae8fa05d31e96227c2" translate="yes" xml:space="preserve">
          <source>Except that the M and E are replaced by the mantissa and exponent of the floating point number. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e17a55270022b0935203eb1ff65bd637b9eb0b" translate="yes" xml:space="preserve">
          <source>Except, the statement above does not work, thanks to pointer types. The pointer generated by the MATCH operator has a type of &quot;fts3cursor&quot; but the carray() function expects to receives a pointer of type &quot;carray&quot;. Because the pointer type on the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; does not match the pointer type on the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; call, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; returns NULL in carray() and thus signals the CARRAY extension that it has been passed an invalid pointer.</source>
          <target state="translated">단, 포인터 유형으로 인해 위의 명령문이 작동하지 않습니다. MATCH 연산자에 의해 생성 된 포인터에는 &quot;fts3cursor&quot;유형이 있지만 carray () 함수는 &quot;carray&quot;유형의 포인터를받을 것으로 예상합니다. 상의 포인터 형 때문에 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer은 ()&lt;/a&gt; 상의 포인터 유형과 일치하지 않습니다 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 호출, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 따라서 반환 carray에 NULL ()과는 유효하지 않은 포인터를 통과되었다는 CARRAY 확장 신호를 보낸다.</target>
        </trans-unit>
        <trans-unit id="0829c4066912f266e388974fa121b62d34c08be6" translate="yes" xml:space="preserve">
          <source>Exclude clause</source>
          <target state="translated">제외 조항</target>
        </trans-unit>
        <trans-unit id="6898c23bf064b43d330b025080e2f7ca1c663675" translate="yes" xml:space="preserve">
          <source>Execute applicable AFTER trigger programs.</source>
          <target state="translated">적용 가능한 AFTER 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c543e4bf2eac6c17a5bcafecd505a60bc0758ff2" translate="yes" xml:space="preserve">
          <source>Execute applicable BEFORE trigger programs,</source>
          <target state="translated">해당 BEFORE 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dc88af1c57b78a22fe3c05896efc419ad226673e" translate="yes" xml:space="preserve">
          <source>Execute the trigger program passed as P4 (type P4_SUBPROGRAM).</source>
          <target state="translated">P4 (유형 P4_SUBPROGRAM)로 전달 된 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="92e0a28a0ba14dbc0f9870c2587f7dd1fa43da35" translate="yes" xml:space="preserve">
          <source>Execute the xInverse function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xInverse 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="8e826ee24e5eaa789db2ffc2c5ffba3d2ef490ea" translate="yes" xml:space="preserve">
          <source>Execute the xStep (if P1==0) or xInverse (if P1!=0) function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xStep (P1 == 0 인 경우) 또는 xInverse (P1! = 0 인 경우) 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="d25e5f6cc8e8e8f6df2982b8a71bbe3109ad8777" translate="yes" xml:space="preserve">
          <source>Execute the xStep function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xStep 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="3abcc2cf0440581468341c7211f2946754168feb" translate="yes" xml:space="preserve">
          <source>Executive Summary</source>
          <target state="translated">행정상 개요</target>
        </trans-unit>
        <trans-unit id="23225800cd0002edfbed8ad40f888fff569bdb43" translate="yes" xml:space="preserve">
          <source>Existing Change</source>
          <target state="translated">기존 변경</target>
        </trans-unit>
        <trans-unit id="c6a4c238411feb293bac6b4620c00bdb61a3fa23" translate="yes" xml:space="preserve">
          <source>Existing zip archive entries may be modified using UPDATE statements.</source>
          <target state="translated">기존 zip 아카이브 항목은 UPDATE 문을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b42835fb01a0646614ba4e81e2b65a9cff9bdf" translate="yes" xml:space="preserve">
          <source>Exit immediately. All open cursors, etc are closed automatically.</source>
          <target state="translated">즉시 종료하십시오. 열려있는 모든 커서 등이 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="9be8055dafdd8df7dd5ded321f98b5d4a3c23849" translate="yes" xml:space="preserve">
          <source>Experimental And Deprecated Interfaces</source>
          <target state="translated">실험적이고 사용되지 않는 인터페이스</target>
        </trans-unit>
        <trans-unit id="7fea72449d921c55e0065d056e69bc920823d9b0" translate="yes" xml:space="preserve">
          <source>Experimental FTS2 module added</source>
          <target state="translated">실험용 FTS2 모듈 추가</target>
        </trans-unit>
        <trans-unit id="3fdb876749dabb65b0a863fa4088f5b7655056a5" translate="yes" xml:space="preserve">
          <source>Experimental Interfaces</source>
          <target state="translated">실험적인 인터페이스</target>
        </trans-unit>
        <trans-unit id="e4bb6c1ea9830afec3b0ef3a107b2b9f3dde8942" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions added.</source>
          <target state="translated">실험 날짜 / 시간 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="358e8b7fb082176243da08a7a31fe5a4d1333969" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions revised.</source>
          <target state="translated">실험 날짜 / 시간 기능이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="7eb10f0095483031f4d115113847c4183b77a491" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change and/or removal at any time.</source>
          <target state="translated">실험 인터페이스는 언제든지 변경 및 / 또는 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8727cd9638a0f2713c26e6983da8bcb851353a9" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change. Applications that use experimental interfaces may need to be modified when upgrading to a newer SQLite release, though this is rare. When new interfaces are added to SQLite, they generally begin as experimental interfaces. After an interface has been in use for a while and the developers are confident that the design of the interface is sound and worthy of long-term support, the interface is marked as stable.</source>
          <target state="translated">실험적인 인터페이스는 변경 될 수 있습니다. 새로운 SQLite 릴리스로 업그레이드 할 때 실험적인 인터페이스를 사용하는 응용 프로그램을 수정해야 할 수도 있습니다. 새로운 인터페이스가 SQLite에 추가되면 일반적으로 실험적인 인터페이스로 시작됩니다. 인터페이스를 한동안 사용하고 개발자가 인터페이스 디자인이 건전하고 장기적으로 지원할 가치가 있다고 확신하면 인터페이스가 안정적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a20b1cb075c4a00d0abbf8e26207c972c09680bb" translate="yes" xml:space="preserve">
          <source>Experimental memory allocators</source>
          <target state="translated">실험 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="ef394d562795d87e8981a3ef0b747f4f8415b4e8" translate="yes" xml:space="preserve">
          <source>Experimental sqlite_last_statement_changes() API added. Fixed the last_insert_rowid() function so that it works correctly with triggers.</source>
          <target state="translated">실험적인 sqlite_last_statement_changes () API가 추가되었습니다. last_insert_rowid () 함수가 트리거와 올바르게 작동하도록 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="3da5d6c17cd08f8fd17c037a2c324328332c9e1f" translate="yes" xml:space="preserve">
          <source>Expire</source>
          <target state="translated">Expire</target>
        </trans-unit>
        <trans-unit id="3491713fb12e8a067f41197ec08bfafa31b9fad4" translate="yes" xml:space="preserve">
          <source>Export the sqlite_changes() function from Windows DLLs.</source>
          <target state="translated">Windows DLL에서 sqlite_changes () 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1cdccf3f2c55fca61416f93409d6573cd4ec6636" translate="yes" xml:space="preserve">
          <source>Export the sqlite_function_type() API function in the Windows DLL</source>
          <target state="translated">Windows DLL에서 sqlite_function_type () API 함수 내보내기</target>
        </trans-unit>
        <trans-unit id="d5fbd7523567abe11b73fcd31b6d3a54394db40c" translate="yes" xml:space="preserve">
          <source>Export to excel</source>
          <target state="translated">엑셀로 내보내기</target>
        </trans-unit>
        <trans-unit id="d3564717c402a8a051ea3b35dc177cb473a37b25" translate="yes" xml:space="preserve">
          <source>Expose SQLite's internal pseudo-random number generator (PRNG) via the &lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness()&lt;/a&gt; interface</source>
          <target state="translated">&lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness ()&lt;/a&gt; 인터페이스 를 통해 SQLite의 내부 의사 난수 생성기 (PRNG) 노출</target>
        </trans-unit>
        <trans-unit id="ae70d9011360d64f28a8a35dd90c8da3ddd3466d" translate="yes" xml:space="preserve">
          <source>Expose the &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; interface for use by extensions and applications.</source>
          <target state="translated">확장 및 응용 프로그램에서 사용할 &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 인터페이스를 노출하십시오 .</target>
        </trans-unit>
        <trans-unit id="43a8bde69f1d5429f321700a30e06b249b531dc6" translate="yes" xml:space="preserve">
          <source>Expression Affinity</source>
          <target state="translated">발현 친 화성</target>
        </trans-unit>
        <trans-unit id="2dd84143cc8f5bbd9454bf39088a896b30eb6b90" translate="yes" xml:space="preserve">
          <source>Expression affinity</source>
          <target state="translated">발현 친화력</target>
        </trans-unit>
        <trans-unit id="3d1f752f9df92f5925b4848ce31d612b54cbf2eb" translate="yes" xml:space="preserve">
          <source>Expression affinity is determined by the following rules:</source>
          <target state="translated">발현 친화도는 다음 규칙에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="59d2facf767d8cd997d901649d83987ad43a4414" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may contain function calls, but only to functions whose output is always determined completely by its input parameters (a.k.a.: &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;). Obviously, functions like &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; will not work well in an index. But also functions like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;, though they are constant across any one database connection, are not constant across the life of the underlying database file, and hence may not be used in a CREATE INDEX statement.</source>
          <target state="translated">CREATE INDEX 문의 표현식에는 함수 호출이 포함될 수 있지만 출력이 항상 입력 매개 변수 (일명 &lt;a href=&quot;deterministic&quot;&gt;결정적 함수&lt;/a&gt; )에 의해 완전히 결정되는 함수에 대한 함수 호출 만 포함 할 수 있습니다 . 분명히 &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; 과 같은 함수 는 인덱스에서 제대로 작동하지 않습니다. 그러나 &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같은 함수 는 하나의 데이터베이스 연결에서 일정하지만 기본 데이터베이스 파일의 수명 동안 일정하지 않으므로 CREATE INDEX 문에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19a6e91fe10c5674eb13c2fd762a7021fa8a05d5" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may not use subqueries.</source>
          <target state="translated">CREATE INDEX 문의 표현식은 서브 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cfe3f417ef1d8d91b4195c28077dbb7d62d18f6" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may only refer to columns of the table being indexed, not to columns in other tables.</source>
          <target state="translated">CREATE INDEX 문의 표현식은 다른 테이블의 열이 아니라 인덱싱중인 테이블의 열만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c8785ad9b4a9d7dc1446ae294e913645b75702" translate="yes" xml:space="preserve">
          <source>Expressions in an index may not reference other tables and may not use subqueries nor functions whose result might change (ex: &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;). Expressions in an index may only refer to columns in the table that is being indexed. Indexes on expression will not work with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). See the &lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt; document for additional information about using general expressions in CREATE INDEX statements.</source>
          <target state="translated">인덱스의 표현식은 다른 테이블을 참조 할 수 없으며 결과가 변경 될 수있는 하위 쿼리 나 함수 (예 : &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; )를 사용할 수 없습니다 . 인덱스의 표현식은 인덱스되는 테이블의 열만 참조 할 수 있습니다. 식에 대한 인덱스는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 이전의 SQLite 버전에서는 작동하지 않습니다 . CREATE INDEX 문에서 일반 표현식 사용에 대한 추가 정보 는 &lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c735d025b09f54040c918a48c63f4553312abde0" translate="yes" xml:space="preserve">
          <source>Expressions may only be used in CREATE INDEX statements, not within &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints within the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">식은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 내의 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건이 아닌 CREATE INDEX 문에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16ba9ffc3e58ab67f2eeb64637e9739a29beccda" translate="yes" xml:space="preserve">
          <source>Extend the expression syntax to support &quot;expr NOT NULL&quot; (with a space between the &quot;NOT&quot; and the &quot;NULL&quot;) in addition to &quot;expr NOTNULL&quot; (with no space).</source>
          <target state="translated">&quot;expr NOTNULL&quot;(공백 없음) 외에 &quot;expr NOT NULL&quot;( &quot;NOT&quot;와 &quot;NULL&quot;사이에 공백이 있음)을 지원하도록 표현식 구문을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="6d86bea998341375770658644790ac8289ea0fef" translate="yes" xml:space="preserve">
          <source>Extended Result Codes</source>
          <target state="translated">확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="09d1c9addf77edc2a7d8092f6e72ee640d2e255e" translate="yes" xml:space="preserve">
          <source>Extended result code</source>
          <target state="translated">확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="432cee7e4f965361237e9452306378119ba23eec" translate="yes" xml:space="preserve">
          <source>Extended the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; statement so that it can optionally be limited to verifying just a single table and its indexes, rather than the entire database file.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 문을 확장하여 전체 데이터베이스 파일이 아닌 단일 테이블과 해당 인덱스 만 확인하도록 선택적으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61badc5a87beafb6593c6e7cfe212f92bad7bbcd" translate="yes" xml:space="preserve">
          <source>Extended the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface, and in particular the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; object to allow a virtual table to report its estimate on the number of rows that will be returned by a query.</source>
          <target state="translated">확장 된 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 인터페이스를하고, 특히 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 객체는 가상 테이블이 쿼리에 의해 반환 될 행의 수의 견적을보고 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="e46597fb97bef96ee5f73107f8febfe136670bc8" translate="yes" xml:space="preserve">
          <source>Extending FTS5</source>
          <target state="translated">FTS5 확장</target>
        </trans-unit>
        <trans-unit id="a0ff53d7fc1bead66589841e525ef8e976444aff" translate="yes" xml:space="preserve">
          <source>Extension loading is off by default. Call the sqlite3_enable_load_extension() routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.</source>
          <target state="translated">확장 프로그램로드는 기본적으로 해제되어 있습니다. 확장로드를 켜려면 sqlite3_enable_load_extension () 루틴을 onoff == 1로 호출하고 다시 끄려면 onoff == 0으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="46936b46e05c0cd15e06014bbbef567350675181" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">이 API를 호출하기 전에 &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL)를 사용하여 확장로드를 사용 가능하게해야합니다 . 그렇지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1dcae90e84eec9a78eefca273aa7a82ae9fd130" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">이 API를 호출하기 전에 &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 또는 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL)를 사용하여 확장로드를 사용 가능하게해야합니다 . 그렇지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="114e41de65bbb502416914ca4249318756eb8953" translate="yes" xml:space="preserve">
          <source>Extension loading supported added to WinCE</source>
          <target state="translated">WinCE에 추가 ​​된 확장 로딩</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="439b09ab192ef3f4c9a45dd3f23cf364759dd991" translate="yes" xml:space="preserve">
          <source>Extensions can also be statically linked with the application. The code template shown below will work just as well as a statically linked extension as it does as a run-time loadable extension except that you should give the entry point function (&quot;sqlite3_extension_init&quot;) a different name to avoid name collisions if your application contains two or more extensions.</source>
          <target state="translated">확장은 응용 프로그램과 정적으로 연결될 수도 있습니다. 아래에 표시된 코드 템플릿은 응용 프로그램에 포함 된 경우 이름 충돌을 피하기 위해 진입 점 함수 ( &quot;sqlite3_extension_init&quot;)에 다른 이름을 지정해야한다는 점을 제외하고는 런타임로드 가능 확장과 마찬가지로 정적으로 링크 된 확장과 마찬가지로 작동합니다. 둘 이상의 확장.</target>
        </trans-unit>
        <trans-unit id="a4e4d34ecd0944488461a920456725f4890a8840" translate="yes" xml:space="preserve">
          <source>Extensive use of assert() and run-time checks</source>
          <target state="translated">assert () 및 런타임 검사의 광범위한 사용</target>
        </trans-unit>
        <trans-unit id="b4ced57f2686552cf070ac8fb509a5077ec27fda" translate="yes" xml:space="preserve">
          <source>External content fts4 tables</source>
          <target state="translated">외부 컨텐츠 fts4 테이블</target>
        </trans-unit>
        <trans-unit id="47b818c2e14f39f43b217d0ea891f065e303f7e1" translate="yes" xml:space="preserve">
          <source>Externally, from the point of view of another process or thread, two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using a shared-cache appear as a single connection. The locking protocol used to arbitrate between multiple shared-caches or regular database users is described elsewhere.</source>
          <target state="translated">외부 적으로, 다른 프로세스 나 스레드의 관점 에서 공유 캐시를 사용하는 둘 이상의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 단일 연결로 나타납니다. 여러 공유 캐시 또는 일반 데이터베이스 사용자 간의 중재에 사용되는 잠금 프로토콜은 다른 곳에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="45e62225b6f82210cf1454638e84d31967235d1d" translate="yes" xml:space="preserve">
          <source>Extra sanity checking added to ALTER TABLE in the 3.25.0 release sometimes raises a false-positive when the table being modified has a trigger that updates a virtual table. The false-positive caused the ALTER TABLE to rollback, thus leaving the schema unchanged. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt;.</source>
          <target state="translated">3.25.0 릴리스의 ALTER TABLE에 추가 ​​된 정상 상태 점검은 수정중인 테이블에 가상 테이블을 업데이트하는 트리거가있는 경우 거짓 양성을 발생시킵니다. 위양성으로 인해 ALTER TABLE이 롤백되어 스키마가 변경되지 않았습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">테이블 열에 대한 메타 데이터 추출</target>
        </trans-unit>
        <trans-unit id="40f3078b8961fbdb3a6f635e86be2acec27a1a53" translate="yes" xml:space="preserve">
          <source>Extract a single row from the queue.</source>
          <target state="translated">큐에서 단일 행을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="b4ae32f698bcf0fdc018ba41b1247fb34c34af21" translate="yes" xml:space="preserve">
          <source>Extract an entry from the SQLite Archive using code like this:</source>
          <target state="translated">다음과 같은 코드를 사용하여 SQLite Archive에서 항목을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="3e003c081f655906879284f1f4c7714e31b1d65b" translate="yes" xml:space="preserve">
          <source>Extract files from the archive (either to the current working directory or to the directory specified by a --directory option). If there are no arguments following the options all files are extracted from the archive. Or, if there are arguments, they are the names of files to extract from the archive. Any specified directories are extracted recursively. It is an error if any specified files are not part of the archive.</source>
          <target state="translated">아카이브에서 파일을 추출하십시오 (현재 작업 디렉토리 또는 --directory 옵션으로 지정된 디렉토리로). 옵션 뒤에 인수가 없으면 모든 파일이 아카이브에서 추출됩니다. 또는 인수가 있으면 아카이브에서 추출 할 파일 이름입니다. 지정된 디렉토리는 재귀 적으로 추출됩니다. 지정된 파일이 아카이브의 일부가 아닌 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="baa0742d96de2a24f07eed1535bac071a9075c95" translate="yes" xml:space="preserve">
          <source>Extract specified files from archive.</source>
          <target state="translated">아카이브에서 지정된 파일을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="eb5c6d1fcf0a608f318e463de8632f84451eaf7b" translate="yes" xml:space="preserve">
          <source>Extract the smallest value from the RowSet object in P1 and put that value into register P3. Or, if RowSet object P1 is initially empty, leave P3 unchanged and jump to instruction P2.</source>
          <target state="translated">P1의 RowSet 객체에서 가장 작은 값을 추출하고 해당 값을 레지스터 P3에 넣습니다. 또는 RowSet 오브젝트 P1이 초기에 비어있는 경우 P3을 변경하지 않고 명령 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="cb48b3c8d042e92b7e20ea89ce79dc8cd5654367" translate="yes" xml:space="preserve">
          <source>F = M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6a5ecb0c6d5148842ac5a363fcb56a58341f32" translate="yes" xml:space="preserve">
          <source>FAIL</source>
          <target state="translated">FAIL</target>
        </trans-unit>
        <trans-unit id="c4aa9e5944607518b7369e543fb9270849797108" translate="yes" xml:space="preserve">
          <source>FILENAME</source>
          <target state="translated">FILENAME</target>
        </trans-unit>
        <trans-unit id="edc5934c34a6fd02ae10fbbb8d31675eb97581a4" translate="yes" xml:space="preserve">
          <source>FILTER</source>
          <target state="translated">FILTER</target>
        </trans-unit>
        <trans-unit id="7af1ca696458c2f9d5d612be97316bdd154f68d5" translate="yes" xml:space="preserve">
          <source>FILTER clause on aggregate functions</source>
          <target state="translated">집계 함수에 대한 FILTER 절</target>
        </trans-unit>
        <trans-unit id="2f20f7ce5f89c0638962299aea08b6280742c461" translate="yes" xml:space="preserve">
          <source>FIRST</source>
          <target state="translated">FIRST</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="f0de6c8aaa3f89b4cf230209af3f19827539e319" translate="yes" xml:space="preserve">
          <source>FOLLOWING</source>
          <target state="translated">FOLLOWING</target>
        </trans-unit>
        <trans-unit id="cffc20d5a5a0383f3e7092a7ee2056120936485b" translate="yes" xml:space="preserve">
          <source>FOR</source>
          <target state="translated">FOR</target>
        </trans-unit>
        <trans-unit id="2042a19d7f5fa71037019431093347e65589675e" translate="yes" xml:space="preserve">
          <source>FOR EACH ROW triggers are supported but not FOR EACH STATEMENT triggers.</source>
          <target state="translated">FOR EACH ROW 트리거는 지원되지만 FOR EACH STATEMENT 트리거는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b1916dfa796728075ee31b5fa8961f1bc7e880d" translate="yes" xml:space="preserve">
          <source>FOREIGN</source>
          <target state="translated">FOREIGN</target>
        </trans-unit>
        <trans-unit id="8e7f00cffd27676bd86f7a41b4fecf304cf6d5a6" translate="yes" xml:space="preserve">
          <source>FROM</source>
          <target state="translated">FROM</target>
        </trans-unit>
        <trans-unit id="2f6d94dfca2abdb4f6ae16ec59fb3d9a744ddcf9" translate="yes" xml:space="preserve">
          <source>FROM clause</source>
          <target state="translated">FROM 절</target>
        </trans-unit>
        <trans-unit id="c3523014e1653c50ece1aec52c268066744db929" translate="yes" xml:space="preserve">
          <source>FTS Doclist Entry Format</source>
          <target state="translated">FTS Doclist Entry 형식</target>
        </trans-unit>
        <trans-unit id="08c36c5cc18ab85c9bd2f90b127a0b924d5fe23e" translate="yes" xml:space="preserve">
          <source>FTS MATCH</source>
          <target state="translated">FTS 경기</target>
        </trans-unit>
        <trans-unit id="394841e4a088a4ee61fc03c94e00b990fb5862ce" translate="yes" xml:space="preserve">
          <source>FTS does not expose a C-function that users call to register new tokenizer types with a database handle. Instead, the pointer must be encoded as an SQL blob value and passed to FTS through the SQL engine by evaluating a special scalar function, &quot;fts3_tokenizer()&quot;. The fts3_tokenizer() function may be called with one or two arguments, as follows:</source>
          <target state="translated">FTS는 사용자가 데이터베이스 핸들을 사용하여 새 토크 나이저 유형을 등록하기 위해 호출하는 C 기능을 노출하지 않습니다. 대신, 포인터는 SQL Blob 값으로 인코딩되고 특수 스칼라 함수 &quot;fts3_tokenizer ()&quot;를 평가하여 SQL 엔진을 통해 FTS에 전달되어야합니다. fts3_tokenizer () 함수는 다음과 같이 하나 또는 두 개의 인수와 함께 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="871df7406acd230826350d29ce0b56fe491442c2" translate="yes" xml:space="preserve">
          <source>FTS hidden column</source>
          <target state="translated">FTS 숨겨진 열</target>
        </trans-unit>
        <trans-unit id="9610893255d0800ca1fe04deb4a339e0ca00a5ac" translate="yes" xml:space="preserve">
          <source>FTS is primarily designed to support Boolean full-text queries - queries to find the set of documents that match a specified criteria. However, many (most?) search applications require that results are somehow ranked in order of &quot;relevance&quot;, where &quot;relevance&quot; is defined as the likelihood that the user who performed the search is interested in a specific element of the returned set of documents. When using a search engine to find documents on the world wide web, the user expects that the most useful, or &quot;relevant&quot;, documents will be returned as the first page of results, and that each subsequent page contains progressively less relevant results. Exactly how a machine can determine document relevance based on a users query is a complicated problem and the subject of much ongoing research.</source>
          <target state="translated">FTS는 기본적으로 부울 전체 텍스트 쿼리 (지정된 조건과 일치하는 문서 집합을 찾기위한 쿼리)를 지원하도록 설계되었습니다. 그러나 많은 (대부분의) 검색 응용 프로그램에서는 결과가 &quot;관련성&quot;순서로 순위가 매겨 져야합니다. 여기서 &quot;관련성&quot;은 검색을 수행 한 사용자가 반환 된 문서 집합의 특정 요소에 관심이있을 가능성으로 정의됩니다. . 검색 엔진을 사용하여 월드 와이드 웹에서 문서를 찾을 때 사용자는 가장 유용하거나 &quot;관련된&quot;문서가 결과의 첫 번째 페이지로 리턴되며 이후의 각 페이지에는 관련성이 낮은 결과가 포함됩니다. 기계가 사용자 쿼리를 기반으로 문서 관련성을 어떻게 정확하게 결정할 수 있는지는 복잡한 문제이며 많은 연구가 진행되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3731cc0c94681dc32e8f394a102a540e99e93832" translate="yes" xml:space="preserve">
          <source>FTS queries are made up of &lt;b&gt;phrases&lt;/b&gt;. A phrase is an ordered list of one or more tokens. A string is transformed into a phrase by passing it to the FTS table tokenizer. Two phrases can be concatenated into a single large phrase using the &quot;+&quot; operator. For example, assuming the tokenizer module being used tokenizes the input &quot;one.two.three&quot; to three separate tokens, the following four queries all specify the same phrase:</source>
          <target state="translated">FTS 쿼리는 &lt;b&gt;문구로 구성&lt;/b&gt; 됩니다. 문구는 하나 이상의 토큰으로 정렬 된 목록입니다. 문자열은 FTS 테이블 토크 나이저에 전달하여 구문으로 변환됩니다. &quot;+&quot;연산자를 사용하여 두 개의 문구를 하나의 큰 문구로 연결할 수 있습니다. 예를 들어, 사용중인 토크 나이저 모듈이 입력 &quot;one.two.three&quot;를 3 개의 개별 토큰으로 토큰 화한다고 가정하면 다음 4 개의 쿼리는 모두 같은 구를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6821ce9a3c01802eb530b20fed455de131a72213" translate="yes" xml:space="preserve">
          <source>FTS query set operations using the standard query syntax are similar, but not identical, to set operations with the enhanced query syntax. There are four differences, as follows:</source>
          <target state="translated">표준 쿼리 구문을 사용하는 FTS 쿼리 세트 작업은 향상된 쿼리 구문을 사용하여 작업을 설정하는 것과 유사하지만 동일하지는 않습니다. 다음과 같은 네 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5ddc324f0381333b7d8ab01fe249ad01bbcbd2" translate="yes" xml:space="preserve">
          <source>FTS shadow tables</source>
          <target state="translated">FTS 새도우 테이블</target>
        </trans-unit>
        <trans-unit id="61a39fa7b32dd985e153046de08304dc64e8d6b3" translate="yes" xml:space="preserve">
          <source>FTS tables are populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements in the same way as ordinary SQLite tables are.</source>
          <target state="translated">FTS 테이블은 일반 SQLite 테이블과 동일한 방식으로 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="bc9a6013954064cd8ee09b12f022677a1b34ded3" translate="yes" xml:space="preserve">
          <source>FTS tables can be queried efficiently using SELECT statements of two different forms:</source>
          <target state="translated">FTS 테이블은 서로 다른 두 가지 형식의 SELECT 문을 사용하여 효율적으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b3449cd4ca843dc92a8fce9d9f69a617812f743d" translate="yes" xml:space="preserve">
          <source>FTS tables may be dropped from the database using an ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">FTS 테이블은 일반적인 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 사용하여 데이터베이스에서 삭제 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2700f1653c678e15c1bd610ec75cb2942cb94697" translate="yes" xml:space="preserve">
          <source>FTS tables permit the special alias &quot;docid&quot; to be used to refer to the rowid column supported by all &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">FTS 테이블은 특수 별칭 &quot;docid&quot;를 사용하여 모든 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에서&lt;/a&gt; 지원하는 rowid 열을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf9928f2d9fa4acc06aa91c08ff21df91f62f1a4" translate="yes" xml:space="preserve">
          <source>FTS tables support three basic query types:</source>
          <target state="translated">FTS 테이블은 세 가지 기본 쿼리 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8b6242cfa0a61ee3e024d8795a95dd14b9db1c27" translate="yes" xml:space="preserve">
          <source>FTS varints, where</source>
          <target state="translated">FTS varints, 어디서</target>
        </trans-unit>
        <trans-unit id="f3461ddc90d1b1bb49207af48336b7bdd5813a5d" translate="yes" xml:space="preserve">
          <source>FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known issues with these older modules and their use should be avoided. Portions of the original FTS3 code were contributed to the SQLite project by Scott Hess of &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;. It is now developed and maintained as part of SQLite.</source>
          <target state="translated">FTS1 및 FTS2는 SQLite에 사용되지 않는 전체 텍스트 검색 모듈입니다. 이러한 구형 모듈에는 알려진 문제가 있으므로 사용을 피해야합니다. 원래 FTS3 코드의 일부는 &lt;a href=&quot;http://www.google.com&quot;&gt;Google의&lt;/a&gt; Scott Hess가 SQLite 프로젝트에 기여했습니다 . 이제 SQLite의 일부로 개발 및 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="1227d1d0e63a5f4033dc141b8e43a11fd703a6d3" translate="yes" xml:space="preserve">
          <source>FTS3 Doclist Format</source>
          <target state="translated">FTS3 Doclist 형식</target>
        </trans-unit>
        <trans-unit id="bd1845e541762d35542373f8b784685a38b78c4a" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are SQLite virtual table modules that allows users to perform full-text searches on a set of documents. The most common (and effective) way to describe full-text searches is &quot;what Google, Yahoo, and Bing do with documents placed on the World Wide Web&quot;. Users input a term, or series of terms, perhaps connected by a binary operator or grouped together into a phrase, and the full-text query system finds the set of documents that best matches those terms considering the operators and groupings the user has specified. This article describes the deployment and usage of FTS3 and FTS4.</source>
          <target state="translated">FTS3 및 FTS4는 사용자가 일련의 문서에서 전체 텍스트 검색을 수행 할 수있는 SQLite 가상 테이블 모듈입니다. 전체 텍스트 검색을 설명하는 가장 일반적이고 효과적인 방법은 &quot;World Wide Web에있는 문서로 Google, Yahoo 및 Bing이하는 일&quot;입니다. 사용자는 이진 연산자로 연결되거나 구로 그룹화되는 용어 또는 일련의 용어를 입력하고 전체 텍스트 쿼리 시스템은 사용자가 지정한 연산자 및 그룹화를 고려하여 해당 용어와 가장 일치하는 문서 집합을 찾습니다. 이 문서에서는 FTS3 및 FTS4의 배포 및 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2683586e321c0b59cc4d1a5e41224dd20c9ed2e6" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are nearly identical. They share most of their code in common, and their interfaces are the same. The differences are:</source>
          <target state="translated">FTS3과 FTS4는 거의 동일합니다. 그들은 대부분의 코드를 공통으로 공유하며 인터페이스는 동일합니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e0f1a099853f641286d63551373f3ebb76f4701" translate="yes" xml:space="preserve">
          <source>FTS3 now uses the SQLite memory allocator exclusively. The FTS3 amalgamation can now be appended to the SQLite amalgamation to generate a super-amalgamation containing both.</source>
          <target state="translated">FTS3는 이제 SQLite 메모리 할당자를 독점적으로 사용합니다. FTS3 통합은 이제 SQLite 통합에 추가되어 둘 다를 포함하는 슈퍼 통합을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb71b9894746fceb2a158c4dac52d9809ff6d0b7" translate="yes" xml:space="preserve">
          <source>FTS3/4 searches for matches in column &quot;b&quot;. However, FTS5 always returns zero rows, as results are first filtered for column &quot;b&quot;, then for column &quot;a&quot;, leaving no results. In other words, in FTS3/4 the inner filter overrides the outer, in FTS5 both filters are applied.</source>
          <target state="translated">FTS3 / 4는 &quot;b&quot;열에서 일치하는 항목을 검색합니다. 그러나 결과가 먼저 &quot;b&quot;열에 대해 필터링 된 다음 &quot;a&quot;열에 대해 필터링되므로 결과는 남기지 않으므로 FTS5는 항상 제로 행을 반환합니다. 다시 말해, FTS3 / 4에서는 내부 필터가 외부 필터보다 우선하고 FTS5에서는 두 필터가 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ccbc625cc55863d7fe3ac35f55545f99e8b1be2a" translate="yes" xml:space="preserve">
          <source>FTS4</source>
          <target state="translated">FTS4</target>
        </trans-unit>
        <trans-unit id="8786db1911020bf22ede0fe9cbdf66389f4b98ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;automerge&amp;quot; command</source>
          <target state="translated">FTS4 &quot;자동 병합&quot;명령</target>
        </trans-unit>
        <trans-unit id="aac4be036956f48255e0d6a56b2b96b9a3a7bf30" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;integrity-check&amp;quot; command</source>
          <target state="translated">FTS4 &quot;무결성 검사&quot;명령</target>
        </trans-unit>
        <trans-unit id="3e393440930d32160e1b70d7854d6b3e86395412" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;merge&amp;quot; command</source>
          <target state="translated">FTS4 &quot;병합&quot;명령</target>
        </trans-unit>
        <trans-unit id="2f19e99c766323f7614141b53880d300ea6c45ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;optimize&amp;quot; command</source>
          <target state="translated">FTS4 &quot;최적화&quot;명령</target>
        </trans-unit>
        <trans-unit id="16282f5426f5b372e11b86b4a630da10231c0bdc" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;rebuild&amp;quot; command</source>
          <target state="translated">FTS4 &quot;재 구축&quot;명령</target>
        </trans-unit>
        <trans-unit id="5b2494033f24cbb7e8c72c46a490b02e62651c82" translate="yes" xml:space="preserve">
          <source>FTS4 commands</source>
          <target state="translated">FTS4 명령</target>
        </trans-unit>
        <trans-unit id="0c1d30cc05eabb84e3570704f5ba49de5062577f" translate="yes" xml:space="preserve">
          <source>FTS4 contains query performance optimizations that may significantly improve the performance of full-text queries that contain terms that are very common (present in a large percentage of table rows).</source>
          <target state="translated">FTS4에는 쿼리 성능 최적화가 포함되어있어 매우 일반적인 용어 (대부분의 테이블 행에 있음)가 포함 된 전체 텍스트 쿼리의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8950f7d9a329b6960f5d82c8a9a9464deeb6901" translate="yes" xml:space="preserve">
          <source>FTS4 content option</source>
          <target state="translated">FTS4 컨텐츠 옵션</target>
        </trans-unit>
        <trans-unit id="554686d6fd7046880b40fd6cb96c9c17cf19ab25" translate="yes" xml:space="preserve">
          <source>FTS4 currently supports the following options:</source>
          <target state="translated">FTS4는 현재 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="eb472151c42f03d5056f225e17206b4a82d9df17" translate="yes" xml:space="preserve">
          <source>FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04) The enhancements for FTS4 were added with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07).</source>
          <target state="translated">FTS4는 FTS3의 향상된 기능입니다. FTS3는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007-09-04) 부터 사용 가능 합니다. FTS4의 향상된 기능은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;버전 3.7.4&lt;/a&gt; (2010-12-07) 와 함께 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5a6f7ed8cfe09bc9d715086a316aa5b99dca8f26" translate="yes" xml:space="preserve">
          <source>FTS4 matchinfo option</source>
          <target state="translated">FTS4 matchinfo 옵션</target>
        </trans-unit>
        <trans-unit id="ec86c19747f79c1717c8a28fff23b033761dd3af" translate="yes" xml:space="preserve">
          <source>FTS4 notindexed option</source>
          <target state="translated">FTS4 색인화되지 않은 옵션</target>
        </trans-unit>
        <trans-unit id="3e921ff34e95c42951dd8942a87973c753d70b40" translate="yes" xml:space="preserve">
          <source>FTS4 options</source>
          <target state="translated">FTS4 옵션</target>
        </trans-unit>
        <trans-unit id="a8e5f2af307655877187a150141826300d8144ef" translate="yes" xml:space="preserve">
          <source>FTS4 order option</source>
          <target state="translated">FTS4 주문 옵션</target>
        </trans-unit>
        <trans-unit id="0fcb2dc93f56e71321e87c9db23359db95b4597d" translate="yes" xml:space="preserve">
          <source>FTS4 prefix option</source>
          <target state="translated">FTS4 접두사 옵션</target>
        </trans-unit>
        <trans-unit id="9f408dd4fbd9084cc1391c0787ebb851e43d8032" translate="yes" xml:space="preserve">
          <source>FTS4 provides hooks (the compress and uncompress &lt;a href=&quot;fts3#fts4_options&quot;&gt;options&lt;/a&gt;) allowing data to be stored in a compressed form, reducing disk usage and IO.</source>
          <target state="translated">FTS4는 데이터를 압축 된 형태로 저장하여 디스크 사용량과 IO를 줄일 수 있는 후크 (압축 및 압축 해제 &lt;a href=&quot;fts3#fts4_options&quot;&gt;옵션&lt;/a&gt; )를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49e9a9493f878486091dc5a71a19bcb1643da350" translate="yes" xml:space="preserve">
          <source>FTS4 supports some additional options that may used with the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function.</source>
          <target state="translated">FTS4는 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수 와 함께 사용할 수있는 몇 가지 추가 옵션을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c68e145499981bd93dd9ae5117fc5a005e534" translate="yes" xml:space="preserve">
          <source>FTS5 CREATE TABLE Options</source>
          <target state="translated">FTS5 CREATE TABLE 옵션</target>
        </trans-unit>
        <trans-unit id="d1c8affa7e60f64c262e7fdd55ec797b1bab87fd" translate="yes" xml:space="preserve">
          <source>FTS5 NEAR queries</source>
          <target state="translated">FTS5 NEAR 쿼리</target>
        </trans-unit>
        <trans-unit id="d7ec5657125d3bf4aacc13991c9460fc5d972d0a" translate="yes" xml:space="preserve">
          <source>FTS5 Phrases</source>
          <target state="translated">FTS5 문구</target>
        </trans-unit>
        <trans-unit id="87402b926513de360c56f04763fc517af198769a" translate="yes" xml:space="preserve">
          <source>FTS5 Strings</source>
          <target state="translated">FTS5 문자열</target>
        </trans-unit>
        <trans-unit id="25a9630f6e782a26d91f9d01bab6d7816eedadf3" translate="yes" xml:space="preserve">
          <source>FTS5 assumes the xToken() callback is invoked for each token in the order that they occur within the input text.</source>
          <target state="translated">FTS5는 xToken () 콜백이 입력 텍스트 내에서 발생하는 순서대로 각 토큰에 대해 호출된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ee357a064955e82ef52a7f67451c8f96221cc76" translate="yes" xml:space="preserve">
          <source>FTS5 automerge option</source>
          <target state="translated">FTS5 자동 병합 옵션</target>
        </trans-unit>
        <trans-unit id="8b00066098ce68d28b3e4f3e2eea468156ce3b4a" translate="yes" xml:space="preserve">
          <source>FTS5 auxiliary functions</source>
          <target state="translated">FTS5 보조 기능</target>
        </trans-unit>
        <trans-unit id="f636824fff3c89108bb6a6caaee243fe0ae7c3de" translate="yes" xml:space="preserve">
          <source>FTS5 bm25</source>
          <target state="translated">FTS5 bm25</target>
        </trans-unit>
        <trans-unit id="3e8211ca81e9935211f036b4875d83e57947df67" translate="yes" xml:space="preserve">
          <source>FTS5 boolean operators</source>
          <target state="translated">FTS5 부울 연산자</target>
        </trans-unit>
        <trans-unit id="8eea6a235e1824fe97bdfc433bcbc6776c8b413a" translate="yes" xml:space="preserve">
          <source>FTS5 building</source>
          <target state="translated">FTS5 빌딩</target>
        </trans-unit>
        <trans-unit id="201e3277761032e31d737c13966e94ec59b4d709" translate="yes" xml:space="preserve">
          <source>FTS5 column filters</source>
          <target state="translated">FTS5 컬럼 필터</target>
        </trans-unit>
        <trans-unit id="8b51c99cf722e03849ae872d3bdcf8914350160e" translate="yes" xml:space="preserve">
          <source>FTS5 columnsize option</source>
          <target state="translated">FTS5 열화 옵션</target>
        </trans-unit>
        <trans-unit id="2a3bc16c2e24994a713981c1e36673961773504f" translate="yes" xml:space="preserve">
          <source>FTS5 content option</source>
          <target state="translated">FTS5 컨텐츠 옵션</target>
        </trans-unit>
        <trans-unit id="9da11bdeb5ddec8fb2dc657759b537387eb1a485" translate="yes" xml:space="preserve">
          <source>FTS5 contentless tables</source>
          <target state="translated">FTS5 컨텐츠리스 테이블</target>
        </trans-unit>
        <trans-unit id="0a96f4a3d0cdf45a1dbfb08a0f7e83e739c0cadb" translate="yes" xml:space="preserve">
          <source>FTS5 creates the following shadow tables. In each case the actual table name is based on the name of the FTS5 virtual table (in the following table, replace &amp;lt;name&amp;gt; with the name of the virtual table to find the actual shadow table name).</source>
          <target state="translated">FTS5는 다음 새도우 테이블을 작성합니다. 각 경우에 실제 테이블 이름은 FTS5 가상 테이블의 이름을 기준으로합니다 (다음 테이블에서 &amp;lt;name&amp;gt;을 가상 테이블 이름으로 바꾸어 실제 새도우 테이블 이름을 찾으십시오).</target>
        </trans-unit>
        <trans-unit id="3c4abdc52bf6e849d3002e382b92df797ff1ab0b" translate="yes" xml:space="preserve">
          <source>FTS5 custom auxiliary functions</source>
          <target state="translated">FTS5 맞춤형 보조 기능</target>
        </trans-unit>
        <trans-unit id="f3a9fa0f7b5a65182346584a71270e7b4709456d" translate="yes" xml:space="preserve">
          <source>FTS5 delete command</source>
          <target state="translated">FTS5 삭제 명령</target>
        </trans-unit>
        <trans-unit id="de949a81f2d5b9c5a7a688724578dc7fdd75bc6d" translate="yes" xml:space="preserve">
          <source>FTS5 delete-all command</source>
          <target state="translated">FTS5 전체 삭제 명령</target>
        </trans-unit>
        <trans-unit id="adeb29e0c699543c103b6fb895630a33d9731d1c" translate="yes" xml:space="preserve">
          <source>FTS5 detail option</source>
          <target state="translated">FTS5 세부 옵션</target>
        </trans-unit>
        <trans-unit id="e2ac950517e98e9c43a54ed519912d5bd79b58f7" translate="yes" xml:space="preserve">
          <source>FTS5 external content tables</source>
          <target state="translated">FTS5 외부 컨텐츠 테이블</target>
        </trans-unit>
        <trans-unit id="e0c1249bfb2f56baeacb4cde9dabe2ee955a0b16" translate="yes" xml:space="preserve">
          <source>FTS5 features APIs allowing it to be extended by:</source>
          <target state="translated">FTS5는 다음과 같은 방법으로 API를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bd5d1681b612815e17fb206b574b31c2a015b2" translate="yes" xml:space="preserve">
          <source>FTS5 features an API allowing users to create custom auxiliary functions for advanced ranking and text processing applications. The special &quot;rank&quot; column may be mapped to a custom auxiliary function so that adding &quot;ORDER BY rank&quot; to a query works as expected.</source>
          <target state="translated">FTS5에는 API가있어 사용자가 고급 순위 및 텍스트 처리 응용 프로그램을위한 사용자 지정 보조 기능을 만들 수 있습니다. 쿼리에 &quot;ORDER BY rank&quot;를 추가하면 특수한 &quot;rank&quot;열이 사용자 지정 보조 기능에 매핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4cd24096e0f7f16f8d144ea2b9d21bbd9f59b7" translate="yes" xml:space="preserve">
          <source>FTS5 features three built-in tokenizer modules, described in subsequent sections:</source>
          <target state="translated">FTS5에는 다음 섹션에서 설명하는 세 가지 내장 토크 나이저 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2889e6384a3c8e1420d76ca5051341eea0da68" translate="yes" xml:space="preserve">
          <source>FTS5 has no matchinfo() or offsets() function, and the snippet() function is not as fully-featured as in FTS3/4. However, since FTS5 does provide an API allowing applications to create &lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;custom auxiliary functions&lt;/a&gt;, any required functionality may be implemented within the application code.</source>
          <target state="translated">FTS5에는 matchinfo () 또는 offsets () 함수가 없으며 snippet () 함수는 FTS3 / 4에서와 같이 완전히 기능하지 않습니다. 그러나 FTS5는 애플리케이션이 &lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;사용자 정의 보조 기능&lt;/a&gt; 을 생성 할 수있는 API를 제공하므로 애플리케이션 코드 내에서 필요한 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2430fd05563889b52091adbdad5f91fa066de359" translate="yes" xml:space="preserve">
          <source>FTS5 highlight</source>
          <target state="translated">FTS5 하이라이트</target>
        </trans-unit>
        <trans-unit id="b07e20076c08544369fcb149755dcf6772db3bb0" translate="yes" xml:space="preserve">
          <source>FTS5 initial token</source>
          <target state="translated">FTS5 초기 토큰</target>
        </trans-unit>
        <trans-unit id="10930556ab62d8a86d41116bc36d163e953e4188" translate="yes" xml:space="preserve">
          <source>FTS5 initial token queries</source>
          <target state="translated">FTS5 초기 토큰 쿼리</target>
        </trans-unit>
        <trans-unit id="ce2ec7726aba85424bd14c5bd9d4baeef31bcd11" translate="yes" xml:space="preserve">
          <source>FTS5 is able to load instance-lists into memory incrementally in order to reduce memory usage and peak allocation size. FTS3/4 very often loads entire instance-lists into memory.</source>
          <target state="translated">FTS5는 메모리 사용량과 최대 할당 크기를 줄이기 위해 인스턴스 목록을 메모리에 점진적으로로드 할 수 있습니다. FTS3 / 4는 종종 전체 인스턴스 목록을 메모리에로드합니다.</target>
        </trans-unit>
        <trans-unit id="24a7aee460cc3d419d5ebe70c577eedfa6e8a962" translate="yes" xml:space="preserve">
          <source>FTS5 is an SQLite &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt; that provides &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;full-text search&lt;/a&gt; functionality to database applications. In their most elementary form, full-text search engines allow the user to efficiently search a large collection of documents for the subset that contain one or more instances of a search term. The search functionality provided to world wide web users by &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; is, among other things, a full-text search engine, as it allows users to search for all documents on the web that contain, for example, the term &quot;fts5&quot;.</source>
          <target state="translated">FTS5는 데이터베이스 응용 프로그램에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;전체 텍스트 검색&lt;/a&gt; 기능을 제공 하는 SQLite &lt;a href=&quot;c3ref/module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 입니다 . 가장 기본적인 형태로, 전체 텍스트 검색 엔진을 사용하면 하나 이상의 검색어 인스턴스를 포함하는 하위 집합에 대한 대규모 문서 모음을 효율적으로 검색 할 수 있습니다. &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; 이 전 세계 웹 사용자에게 제공하는 검색 기능 은 무엇보다도 사용자가 &quot;fts5&quot;라는 용어가 포함 된 웹의 모든 문서를 검색 할 수 있도록하는 전체 텍스트 검색 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="4b943e17490b34630708f8d92456b4e737500a29" translate="yes" xml:space="preserve">
          <source>FTS5 is similar to FTS3/4 in that the primary task of each is to maintain an index mapping from each unique token to a list of instances of that token within a set of documents, where each instance is identified by the document in which it appears and its position within that document. For example:</source>
          <target state="translated">FTS5는 FTS3 / 4와 유사합니다. 각각의 주요 작업은 문서 집합 내에서 각 고유 토큰에서 해당 토큰의 인스턴스 목록으로의 인덱스 매핑을 유지 관리한다는 점에서 각 인스턴스가 나타나는 문서로 식별됩니다. 문서 내에서의 위치. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28789443285151cf93711bf777483eb22fd17981" translate="yes" xml:space="preserve">
          <source>FTS5 merge command</source>
          <target state="translated">FTS5 병합 명령</target>
        </trans-unit>
        <trans-unit id="615a85fe47554c2ae2e2da14f5e902ed33d73731" translate="yes" xml:space="preserve">
          <source>FTS5 optimize command</source>
          <target state="translated">FTS5 최적화 명령</target>
        </trans-unit>
        <trans-unit id="0ce341b86f3ce708df224781d2c7103f5bb5cb9f" translate="yes" xml:space="preserve">
          <source>FTS5 pgsz option</source>
          <target state="translated">FTS5 pgsz 옵션</target>
        </trans-unit>
        <trans-unit id="69f712ff2bf8e4e1182aeec1e88d322127cc20b1" translate="yes" xml:space="preserve">
          <source>FTS5 prefix indexes</source>
          <target state="translated">FTS5 접두사 인덱스</target>
        </trans-unit>
        <trans-unit id="d94afa813a3fa1122708228da577f46e957ec4ac" translate="yes" xml:space="preserve">
          <source>FTS5 prefix queries</source>
          <target state="translated">FTS5 접두사 쿼리</target>
        </trans-unit>
        <trans-unit id="0810946526a1ee798bc7d04dda47aae0cf4f5bff" translate="yes" xml:space="preserve">
          <source>FTS5 provides three built-in auxiliary functions:</source>
          <target state="translated">FTS5는 세 가지 내장 보조 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ee68dd31a5ed538aa8658c76a53f216b8b87606d" translate="yes" xml:space="preserve">
          <source>FTS5 query syntax</source>
          <target state="translated">FTS5 쿼리 구문</target>
        </trans-unit>
        <trans-unit id="bc64d420a66889ad745e1a7998f24fa51307a32d" translate="yes" xml:space="preserve">
          <source>FTS5 rank configuration option</source>
          <target state="translated">FTS5 등급 구성 옵션</target>
        </trans-unit>
        <trans-unit id="29f161e2893c38b239a94eada76933f8fd836ec6" translate="yes" xml:space="preserve">
          <source>FTS5 rebuild command</source>
          <target state="translated">FTS5 재 구축 명령</target>
        </trans-unit>
        <trans-unit id="71972928748ce21ebd6e0c8734df3ca11afc7431" translate="yes" xml:space="preserve">
          <source>FTS5 recognizes unicode separator characters and case equivalence by default. This is also possible using FTS3/4, but must be explicitly enabled.</source>
          <target state="translated">FTS5는 기본적으로 유니 코드 구분 기호 문자와 대소 문자를 인식합니다. FTS3 / 4를 사용하여 가능하지만 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5d20fca7e87996d8a27e365e915ea0b186b5b3d" translate="yes" xml:space="preserve">
          <source>FTS5 snippet</source>
          <target state="translated">FTS5 스 니펫</target>
        </trans-unit>
        <trans-unit id="6aaed4eadfc76dccddf726837795395ef54278b6" translate="yes" xml:space="preserve">
          <source>FTS5 supports &quot;ORDER BY rank&quot; for returning results in order of decreasing relevancy.</source>
          <target state="translated">FTS5는 &quot;ORDER BY rank&quot;를 지원하여 관련성 감소 순서로 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36651526ac3e1214a373d0abfdc9f70652ada481" translate="yes" xml:space="preserve">
          <source>FTS5 tokenizers</source>
          <target state="translated">FTS5 토크 나이저</target>
        </trans-unit>
        <trans-unit id="8341dd226aacac05e80dcb41438a608e9db2f1da" translate="yes" xml:space="preserve">
          <source>FTS5 usermerge option</source>
          <target state="translated">FTS5 사용자 병합 옵션</target>
        </trans-unit>
        <trans-unit id="cc0a745dcfb4d3d66417f75affb8f4b428e7e18f" translate="yes" xml:space="preserve">
          <source>FULL</source>
          <target state="translated">FULL</target>
        </trans-unit>
        <trans-unit id="e0c9bbc8c02d4f1e95081807f3b26672caeb6804" translate="yes" xml:space="preserve">
          <source>FUNCTION( column, EXPR)</source>
          <target state="translated">기능 (열, EXPR)</target>
        </trans-unit>
        <trans-unit id="7c2813bf7bc45de9a6c2f51c171413c9b3b7a03d" translate="yes" xml:space="preserve">
          <source>Factor constant subexpressions in inner loops out to the initialization code in prepared statements.</source>
          <target state="translated">내부 루프의 상수 하위 표현식을 준비된 명령문의 초기화 코드로 인수 분해합니다.</target>
        </trans-unit>
        <trans-unit id="7437a8ac9a8406d5a28deac54292a2ceb4305a26" translate="yes" xml:space="preserve">
          <source>Factor out identifier resolution procedures into separate files.</source>
          <target state="translated">식별자 확인 절차를 별도의 파일로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="23a5e3f76b07073c425aca79699c202f18528c62" translate="yes" xml:space="preserve">
          <source>Failed attempts to open new read-transactions return SQLITE_LOCKED to the caller. If the caller then calls &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; to register for an unlock-notify callback, the blocking connection is the connection that currently has an open write-transaction on the shared-cache. This prevents writer-starvation since if no new read-transactions may be opened and assuming all existing read-transactions are eventually concluded, the writer will eventually have an opportunity to obtain the required write-lock.</source>
          <target state="translated">새 읽기 트랜잭션을 열지 못하면 SQLITE_LOCKED가 호출자에게 리턴됩니다. 그런 다음 호출자가 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 를 호출 하여 잠금 해제 알림 콜백을 등록하면 차단 연결은 현재 공유 캐시에서 열린 쓰기 트랜잭션이있는 연결입니다. 새로운 읽기 트랜잭션이 열리지 않고 기존의 모든 읽기 트랜잭션이 최종적으로 완료되었다고 가정 할 경우 라이터는 필요한 쓰기 잠금을 얻을 수있는 기회를 가지기 때문에 라이터 기아를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45820057fbefcc63da006715ab061339bc73301e" translate="yes" xml:space="preserve">
          <source>Failing to obtain the lock on database file zFilename (an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error) could be handled, and</source>
          <target state="translated">데이터베이스 파일 zFilename에 대한 잠금 획득 실패 ( &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류)를 처리 할 수 ​​있으며</target>
        </trans-unit>
        <trans-unit id="1678e559c36d96e0e24b4bf5c5d0bd9f149e7c92" translate="yes" xml:space="preserve">
          <source>Failure Related Assumption Details</source>
          <target state="translated">실패 관련 가정 세부 사항</target>
        </trans-unit>
        <trans-unit id="ba06062b405462213e6604c055442e995f85ca44" translate="yes" xml:space="preserve">
          <source>Failure to specify the schema name on the target table could result in the TEMP trigger being reattached to a table with the same name in another database whenever any schema change occurs.</source>
          <target state="translated">목표 테이블에 스키마 이름을 지정하지 않으면 스키마 변경이 발생할 때마다 TEMP 트리거가 다른 데이터베이스의 동일한 이름을 가진 테이블에 다시 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895d510880d653fd769826cbd799948f90030c9e" translate="yes" xml:space="preserve">
          <source>Fall through to next instruction if the two records compare equal to each other. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if they are different.</source>
          <target state="translated">두 레코드가 서로 동일한 경우 다음 명령어로 넘어갑니다. 다른 경우 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff9f81a83e1ed8b26c152684da1b756c9d34df23" translate="yes" xml:space="preserve">
          <source>Fall through to the next instruction the first time this opcode is encountered on each invocation of the byte-code program. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 on the second and all subsequent encounters during the same invocation.</source>
          <target state="translated">바이트 코드 프로그램을 호출 할 때마다이 opcode가 처음 발생할 때 다음 명령어로 넘어갑니다. 동일한 호출 동안 두 번째 및 이후의 모든 만남에서 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="4825fc22947a286ddae403117f576f82370ef403" translate="yes" xml:space="preserve">
          <source>Fast: In some cases, SQLite is &lt;a href=&quot;fasterthanfs&quot;&gt;faster than direct filesystem I/O&lt;/a&gt;</source>
          <target state="translated">빠름 : 경우에 따라 SQLite가 &lt;a href=&quot;fasterthanfs&quot;&gt;직접 파일 시스템 I / O보다 빠릅니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1334839ab66bd155133d078aded782ef422dd14" translate="yes" xml:space="preserve">
          <source>Faster :memory: databases</source>
          <target state="translated">빠른 : 메모리 : 데이터베이스</target>
        </trans-unit>
        <trans-unit id="6e8eee224def4d229de11ee50227cab6e1bdb960" translate="yes" xml:space="preserve">
          <source>Faster File/Save times</source>
          <target state="translated">빠른 파일 / 저장 시간</target>
        </trans-unit>
        <trans-unit id="af9f30a3eb7e4943da2c701a139b322bec0ba86e" translate="yes" xml:space="preserve">
          <source>Faster response to &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()에&lt;/a&gt; 대한 더 빠른 응답 .</target>
        </trans-unit>
        <trans-unit id="edc218e97488ebdb256b1041d5517e07adce2150" translate="yes" xml:space="preserve">
          <source>Faster startup times</source>
          <target state="translated">빠른 시작 시간</target>
        </trans-unit>
        <trans-unit id="da9010a26d80b6d161eaff2cb859c264dae9c0df" translate="yes" xml:space="preserve">
          <source>Fear the Day of Judgment.</source>
          <target state="translated">심판의 날을 두려워하십시오.</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="9e2b53b61c236af80dd718fde93d4b9af8e005d4" translate="yes" xml:space="preserve">
          <source>Features Of SQLite</source>
          <target state="translated">SQLite의 특징</target>
        </trans-unit>
        <trans-unit id="3ce33d56c9e73c091a03d2b7bb8be75cf523ee79" translate="yes" xml:space="preserve">
          <source>Few real-world applications meet either of these preconditions, and hence few real-world applications are vulnerable, even if they use older and unpatched versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7734fa2f4379d4b84b96b38bcc052442966db7ae" translate="yes" xml:space="preserve">
          <source>Fewer &quot;stat()&quot; system calls issued by the unix VFS.</source>
          <target state="translated">유닉스 VFS가 발행 한 &quot;stat ()&quot;시스템 호출이 적습니다.</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="ffe01d11556dbe8fb0084465da7b06965d66e721" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Header Format</source>
          <target state="translated">그림-저널 헤더 형식</target>
        </trans-unit>
        <trans-unit id="6dd00e92177e26bc00059a7fff1dc42d87cc45a9" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Record Format</source>
          <target state="translated">그림-저널 레코드 형식</target>
        </trans-unit>
        <trans-unit id="714f8199965743ce58b8c530d296fe8dcfb36f8a" translate="yes" xml:space="preserve">
          <source>Figure  - Master Journal Pointer Format</source>
          <target state="translated">그림-마스터 저널 포인터 형식</target>
        </trans-unit>
        <trans-unit id="246929a593cb90f02eac87b3dc7c028c9874b4e7" translate="yes" xml:space="preserve">
          <source>Figure  - Virtual File System (VFS) Adaptor</source>
          <target state="translated">그림-가상 파일 시스템 (VFS) 어댑터</target>
        </trans-unit>
        <trans-unit id="ef3c148391912886e200c8da65ce231cc75c34aa" translate="yes" xml:space="preserve">
          <source>Figure 1</source>
          <target state="translated">그림 1</target>
        </trans-unit>
        <trans-unit id="e68cc6e58a7e19aad2d3433eb96a9f19c166acb7" translate="yes" xml:space="preserve">
          <source>Figure 1 depicts an example runtime configuration where three database connections have been established. Connection 1 is a normal SQLite database connection. Connections 2 and 3 share a cache The normal locking protocol is used to serialize database access between connection 1 and the shared cache. The internal protocol used to serialize (or not, see &quot;Read-Uncommitted Isolation Mode&quot; below) access to the shared-cache by connections 2 and 3 is described in the remainder of this section.</source>
          <target state="translated">그림 1은 세 개의 데이터베이스 연결이 설정된 런타임 구성 예를 보여줍니다. 연결 1은 일반적인 SQLite 데이터베이스 연결입니다. 연결 2와 3은 캐시를 공유합니다. 일반 잠금 프로토콜은 연결 1과 공유 캐시 사이의 데이터베이스 액세스를 직렬화하는 데 사용됩니다. 연결 2와 3을 통해 공유 캐시에 대한 액세스를 직렬화 (또는 &quot;읽지 않은 커밋되지 않은 격리 모드&quot;참조)하는 데 사용되는 내부 프로토콜은이 섹션의 나머지 부분에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b584f16a8fb3cbea584ae7660b5b6f5a1f97be" translate="yes" xml:space="preserve">
          <source>Figure 11: Lookup Using A Two-Column Index</source>
          <target state="translated">그림 11 : 2 열 색인을 사용한 조회</target>
        </trans-unit>
        <trans-unit id="afbf37b6ddde714b1aee4d493a305e7aec4b7955" translate="yes" xml:space="preserve">
          <source>Figure 12: Single-Column Lookup On A Multi-Column Index</source>
          <target state="translated">그림 12 : 다중 열 인덱스에서 단일 열 조회</target>
        </trans-unit>
        <trans-unit id="bfe311ddb5bb13bd814b1479a18292b808e35f4e" translate="yes" xml:space="preserve">
          <source>Figure 13: A Covering Index</source>
          <target state="translated">그림 13 : 취재 지수</target>
        </trans-unit>
        <trans-unit id="0f9e51f13e0722b260820ee18156800089697691" translate="yes" xml:space="preserve">
          <source>Figure 14: Query Using A Covering Index</source>
          <target state="translated">그림 14 : 포함 인덱스를 사용한 쿼리</target>
        </trans-unit>
        <trans-unit id="2ef4e6f6f7129fc9eb3442eaf5e3eb7840ee5ed8" translate="yes" xml:space="preserve">
          <source>Figure 15: Query With OR Constraints</source>
          <target state="translated">그림 15 : OR 제약 조건이있는 쿼리</target>
        </trans-unit>
        <trans-unit id="9dbf47b46e66a5e14af2bbf54935aa2349fe876c" translate="yes" xml:space="preserve">
          <source>Figure 16: Sorting Without An Index</source>
          <target state="translated">그림 16 : 인덱스없이 정렬</target>
        </trans-unit>
        <trans-unit id="8a9044fcbca9b5d94795e41004b37d420b391046" translate="yes" xml:space="preserve">
          <source>Figure 17: Sorting By Rowid</source>
          <target state="translated">그림 17 : Rowid 별 정렬</target>
        </trans-unit>
        <trans-unit id="ad71a17d48a17e81b6db9cdde1ddbd164b95a57f" translate="yes" xml:space="preserve">
          <source>Figure 18: Sorting With An Index</source>
          <target state="translated">그림 18 : 인덱스를 사용한 정렬</target>
        </trans-unit>
        <trans-unit id="83303d63b04c50c35fd21eb87917f7a1e0531bb0" translate="yes" xml:space="preserve">
          <source>Figure 19: Sorting With A Covering Index</source>
          <target state="translated">그림 19 : 커버링 인덱스를 사용한 정렬</target>
        </trans-unit>
        <trans-unit id="1eb023f1f91c9b2ae1bfb426a8d21e82d3676214" translate="yes" xml:space="preserve">
          <source>Figure 1: A Two-Column Index</source>
          <target state="translated">그림 1 : 2 열 색인</target>
        </trans-unit>
        <trans-unit id="f2ec4384a71d1b2a7bf7e591672d01dfa91b2162" translate="yes" xml:space="preserve">
          <source>Figure 1: Logical Layout Of Table &quot;FruitsForSale&quot;</source>
          <target state="translated">그림 1 : &quot;FruitsForSale&quot;테이블의 논리적 레이아웃</target>
        </trans-unit>
        <trans-unit id="3115657a64816c0a2981b799ec021faf2a045c40" translate="yes" xml:space="preserve">
          <source>Figure 20: Search And Sort By Multi-Column Index</source>
          <target state="translated">그림 20 : 다중 열 인덱스를 기준으로 검색 및 정렬</target>
        </trans-unit>
        <trans-unit id="ca0d5e8c58a01b4bec0a2aa6734f55660d0f996c" translate="yes" xml:space="preserve">
          <source>Figure 21: Search And Sort By Covering Index</source>
          <target state="translated">그림 21 : 커버링 인덱스를 기준으로 검색 및 정렬</target>
        </trans-unit>
        <trans-unit id="bf1fef781061b6dd79cd2df384db7483037947d7" translate="yes" xml:space="preserve">
          <source>Figure 22: Partial Sort By Index</source>
          <target state="translated">그림 22 : 인덱스 별 부분 정렬</target>
        </trans-unit>
        <trans-unit id="3dfec33f32a225432d9d762a93ef2ded86f5829e" translate="yes" xml:space="preserve">
          <source>Figure 2: Full Table Scan</source>
          <target state="translated">그림 2 : 전체 테이블 스캔</target>
        </trans-unit>
        <trans-unit id="b5b1774246aed49a8ebf5fcffbb1777db907fc2a" translate="yes" xml:space="preserve">
          <source>Figure 3: Lookup By Rowid</source>
          <target state="translated">그림 3 : Rowid 별 조회</target>
        </trans-unit>
        <trans-unit id="f4281cc98081d9724bc4fbb0552509706b21eb97" translate="yes" xml:space="preserve">
          <source>Figure 4: An Index On The Fruit Column</source>
          <target state="translated">그림 4 : 과일 칼럼의 색인</target>
        </trans-unit>
        <trans-unit id="bbeb4d21244b30dfdb1099da94e7d4dd047e2c7a" translate="yes" xml:space="preserve">
          <source>Figure 5: Indexed Lookup For The Price Of Peaches</source>
          <target state="translated">복숭아의 가격을위한 색인 된 조회</target>
        </trans-unit>
        <trans-unit id="6a315683f4774663431b2a906642f3e76145398c" translate="yes" xml:space="preserve">
          <source>Figure 6: Indexed Lookup For The Price Of Oranges</source>
          <target state="translated">그림 6 : 오렌지 가격에 대한 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="dfdf259371133aceb6bd0b874516d463fa04f42d" translate="yes" xml:space="preserve">
          <source>Figure 7: Indexed Lookup Of California Oranges</source>
          <target state="translated">그림 7 : 캘리포니아 오렌지의 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="92a03063612532a1d589fdacb42ff17999f75c21" translate="yes" xml:space="preserve">
          <source>Figure 8: Index On The State Column</source>
          <target state="translated">그림 8 : 상태 열의 색인</target>
        </trans-unit>
        <trans-unit id="a53d9c7f8b5017e0dc6c43dacf62cc0f65431691" translate="yes" xml:space="preserve">
          <source>Figure 9: Indexed Lookup Of California Oranges</source>
          <target state="translated">그림 9 : 캘리포니아 오렌지의 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="45f5aee1359a1f0a38b0b02e4a511dce99e49684" translate="yes" xml:space="preserve">
          <source>File Format Changes in SQLite</source>
          <target state="translated">SQLite의 파일 형식 변경</target>
        </trans-unit>
        <trans-unit id="997dfbd003e85872d78fb79873d52c3f6038b0bf" translate="yes" xml:space="preserve">
          <source>File Format Requirements Document.</source>
          <target state="translated">파일 형식 요구 사항 문서.</target>
        </trans-unit>
        <trans-unit id="893d9354b59056d10fe8938361fc3dad5acc8613" translate="yes" xml:space="preserve">
          <source>File I/O functions</source>
          <target state="translated">파일 I / O 기능</target>
        </trans-unit>
        <trans-unit id="83b27b5146777b1e521f460dd5156dedea19d489" translate="yes" xml:space="preserve">
          <source>File Locking And Concurrency In SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 파일 잠금 및 동시성</target>
        </trans-unit>
        <trans-unit id="e6d2f4a1bd6f8ec04bd3bff2e90651e6dff9e651" translate="yes" xml:space="preserve">
          <source>File Locking Levels</source>
          <target state="translated">파일 잠금 수준</target>
        </trans-unit>
        <trans-unit id="b4b1a33b7414dd35f3915ec557e071d0004461f4" translate="yes" xml:space="preserve">
          <source>File change counter.</source>
          <target state="translated">파일 변경 카운터</target>
        </trans-unit>
        <trans-unit id="273f16fa62df833bbd05d3addaa12db905e02445" translate="yes" xml:space="preserve">
          <source>File format changed back to what it was for alpha-1</source>
          <target state="translated">알파 -1 형식으로 파일 형식이 다시 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea05c62c22362e1dcec83363ef37fc1782a17fc0" translate="yes" xml:space="preserve">
          <source>File format read version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">파일 형식 읽기 버전. 레거시의 경우 1; &lt;a href=&quot;wal&quot;&gt;WAL의 경우&lt;/a&gt; 2입니다 .</target>
        </trans-unit>
        <trans-unit id="cf2b8a30295b32fb0155c82d480f8bc862559e2b" translate="yes" xml:space="preserve">
          <source>File format version number was being stored in sqlite_master.tcl multiple times. This was harmless, but unnecessary. It is now fixed.</source>
          <target state="translated">파일 형식 버전 번호가 sqlite_master.tcl에 여러 번 저장되었습니다. 이것은 무해했지만 불필요했습니다. 이제 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="982769b547928ee3535e252a5941715d91d57b18" translate="yes" xml:space="preserve">
          <source>File format version numbers</source>
          <target state="translated">파일 형식 버전 번호</target>
        </trans-unit>
        <trans-unit id="0b3c4b00be4af4f91b01dd7144c1c1ec467e2e45" translate="yes" xml:space="preserve">
          <source>File format version. Currently 3007000.</source>
          <target state="translated">파일 형식 버전. 현재 3007000입니다.</target>
        </trans-unit>
        <trans-unit id="56015cfe642c5b994cf8d2813e8f1eb0075f0f7d" translate="yes" xml:space="preserve">
          <source>File format write version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">파일 형식 쓰기 버전. 레거시의 경우 1; &lt;a href=&quot;wal&quot;&gt;WAL의 경우&lt;/a&gt; 2입니다 .</target>
        </trans-unit>
        <trans-unit id="cc8f9db86cdc23665fd1d6d5d0232d3c76fe3eae" translate="yes" xml:space="preserve">
          <source>File locking states</source>
          <target state="translated">파일 잠금 상태</target>
        </trans-unit>
        <trans-unit id="faefc7760d28988aa893bf9bd1d51b407d9db702" translate="yes" xml:space="preserve">
          <source>File name/path for the zip file record.</source>
          <target state="translated">zip 파일 레코드의 파일 이름 / 경로</target>
        </trans-unit>
        <trans-unit id="8b246c552e3af3ea9fddc5a1ee446e8ed647f009" translate="yes" xml:space="preserve">
          <source>File-locking may be disabled at runtime using the sqlite3async_control() API (see below). This may improve performance when an NFS or other network file-system, as the synchronous round-trips to the server be required to establish file locks are avoided. However, if multiple connections attempt to access the same database file when file-locking is disabled, application crashes and database corruption is a likely outcome.</source>
          <target state="translated">sqlite3async_control () API를 사용하여 런타임시 파일 잠금을 비활성화 할 수 있습니다 (아래 참조). 이는 파일 잠금을 설정하기 위해 서버에 대한 동기 왕복이 필요하지 않으므로 NFS 또는 다른 네트워크 파일 시스템 인 경우 성능을 향상시킬 수 있습니다. 그러나 파일 잠금이 비활성화 된 상태에서 여러 연결이 동일한 데이터베이스 파일에 액세스하려고하면 응용 프로그램이 충돌하고 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe8dc7f14d4a14002d5ac56394cd98f360d2487" translate="yes" xml:space="preserve">
          <source>Files in the &quot;src/&quot; folder of the source tree whose names begin with &lt;b&gt;test&lt;/b&gt; are for testing only and are not included in a standard build of the library.</source>
          <target state="translated">이름이 &lt;b&gt;test&lt;/b&gt; 로 시작하는 소스 트리의 &quot;src /&quot;폴더에있는 파일은 &lt;b&gt;테스트&lt;/b&gt; 용이며 표준 라이브러리 빌드에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54710e28b3c95eb3ec7f0c24ed47099f7d873d00" translate="yes" xml:space="preserve">
          <source>Filesystem corruption</source>
          <target state="translated">파일 시스템 손상</target>
        </trans-unit>
        <trans-unit id="ae3cccd1ea022e8c58ec99f097af4626efe1d332" translate="yes" xml:space="preserve">
          <source>Filesystem corruption following a power failure might cause the journal to be renamed or deleted.</source>
          <target state="translated">정전 후 파일 시스템이 손상되면 저널 이름이 바뀌거나 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="570dc6b1cc29b82976bf6615ecf9b8e4538664c3" translate="yes" xml:space="preserve">
          <source>Finalize A Changeset Iterator</source>
          <target state="translated">변경 세트 반복자 마무리</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">동적 문자열 마무리</target>
        </trans-unit>
        <trans-unit id="9fb3423ac93edd814553ea43b04e3501220dde99" translate="yes" xml:space="preserve">
          <source>Finally use &quot;adb shell&quot; to get a shell prompt on the Android device, cd into the /data/local/tmp directory, and begin running the tests as with any other unix host.</source>
          <target state="translated">마지막으로 &quot;adb shell&quot;을 사용하여 Android 장치에서 쉘 프롬프트를 가져 와서 / data / local / tmp 디렉토리로 cd 한 후 다른 유닉스 호스트와 마찬가지로 테스트를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c3292d9cdfaf21af565aba3eaafc880851d476eb" translate="yes" xml:space="preserve">
          <source>Finally, a column filter for a single column may be specified by using the column name as the LHS of a MATCH operator (instead of the usual table name). For example:</source>
          <target state="translated">마지막으로 열 이름을 일반 테이블 이름 대신 MATCH 연산자의 LHS로 사용하여 단일 열에 대한 열 필터를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ff8d306702ac4434540ba1522c8c4827f58460b" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; have been enabled, then the alternative VFS can be specified using the &quot;vfs=&quot; parameter on the URI. This technique works with &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and when a new database is &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to an existing database connection. For example:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 이 활성화 된 경우 URI 에서 &quot;vfs =&quot;매개 변수를 사용하여 대체 VFS를 지정할 수 있습니다. 이 기술은 작동 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;) sqlite3_open_v2 (&lt;/a&gt; 새 데이터베이스가 될 때, 그리고 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 기존 데이터베이스 연결에 -ed. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91a5114fdd772d39d541271854872b37789c9cfc" translate="yes" xml:space="preserve">
          <source>Finally, if the value specified for this column is not an integer or a NULL, then it is assumed to be a UNIX permissions string similar to those output by the &quot;ls -l&quot; command (e.g. &quot;-rw-r--r--&quot;, &quot;drwxr-xr-x&quot; etc.). In this case, if the string cannot be parsed it is an error.</source>
          <target state="translated">마지막으로이 열에 지정된 값이 정수 또는 NULL이 아닌 경우 &quot;ls -l&quot;명령의 출력과 유사한 UNIX 권한 문자열 (예 : &quot;-rw-r--r- - &quot;,&quot;drwxr-xr-x &quot;등). 이 경우 문자열을 구문 분석 할 수 없으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d4cbf63195ca844a0574b0b67606533ae4726399" translate="yes" xml:space="preserve">
          <source>Finally, let us reiterate that this essay is a thought experiment. The OpenDocument format is well-established and already well-designed. Nobody really believes that OpenDocument should be changed to use SQLite as its container instead of ZIP. Nor is this article a criticism of OpenDocument for not choosing SQLite as its container since OpenDocument predates SQLite. Rather, the point of this article is to use OpenDocument as a concrete example of how SQLite can be used to build better application file formats for future projects.</source>
          <target state="translated">마지막으로,이 에세이가 사고 실험이라는 점을 다시 한 번 말씀 드리겠습니다. OpenDocument 형식은 잘 정립되어 있으며 이미 잘 설계되어 있습니다. 아무도 ZIP 대신 SQLite를 컨테이너로 사용하도록 OpenDocument를 변경해야한다고 생각하지 않습니다. 이 문서는 OpenDocument가 SQLite보다 오래 되었기 때문에 SQLite를 컨테이너로 선택하지 않았다는 OpenDocument에 대한 비판도 아닙니다. 오히려이 기사의 요점은 OpenDocument를 향후 프로젝트를 위해 더 나은 애플리케이션 파일 형식을 빌드하는 데 SQLite를 사용하는 방법에 대한 구체적인 예제로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="073894d80c5b6bf878448685b3b14eeafe3f2f87" translate="yes" xml:space="preserve">
          <source>Finally, sqlite3rbu_close() is called to close the RBU handle. If the application stopped calling sqlite3rbu_step() before either the vacuum finished or an error occurred, the state of the vacuum is saved in the state database so that it may be resumed later on.</source>
          <target state="translated">마지막으로 sqlite3rbu_close ()가 호출되어 RBU 핸들을 닫습니다. 진공이 완료되거나 오류가 발생하기 전에 애플리케이션이 sqlite3rbu_step () 호출을 중지 한 경우 진공 상태는 나중에 다시 시작할 수 있도록 상태 데이터베이스에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4a29ee7b183a9cf65e440601eae0ebf5e26ecb" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value; the same value stored in the first 8 bytes of a</source>
          <target state="translated">마지막으로 &lt;b&gt;저널 매직&lt;/b&gt; 필드에는 항상 잘 알려진 8 바이트 문자열 값이 포함됩니다. a의 첫 8 바이트에 저장된 동일한 값</target>
        </trans-unit>
        <trans-unit id="4ff8914525afcbdf833ba762265c55d01cd645be" translate="yes" xml:space="preserve">
          <source>Finally, the decimal extension provides the &quot;decimal&quot; collating sequences that compares decimal text strings in numeric order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8605914ae34d83e606a255958e7dd2026ebd2652" translate="yes" xml:space="preserve">
          <source>Finally, the following requirements describe step 5 of the above procedure in more detail.</source>
          <target state="translated">마지막으로, 다음 요구 사항은 위 절차의 5 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a60f2db9df368ccf37180701e9147b70fddeaf82" translate="yes" xml:space="preserve">
          <source>Finally, we observe that the instrumented memory allocator and the memory leak detector both work over the entire SQLite test suite and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; provides over 99% statement test coverage and that the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness provides &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; with no leak leaks. This is strong evidence that dynamic memory allocation is used correctly everywhere within SQLite.</source>
          <target state="translated">마지막으로, 인스트루먼트 된 메모리 할당 자와 메모리 누출 감지기는 전체 SQLite 테스트 스위트에서 작동하며 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트&lt;/a&gt; 는 99 % 이상의 명령문 테스트 범위를 제공 하며 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 테스트 하니스는 누출 누출없이 &lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 범위&lt;/a&gt; 를 제공합니다. . 이는 동적 메모리 할당이 SQLite 내 어디에서나 올바르게 사용된다는 강력한 증거입니다.</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">준비된 명령문의 데이터베이스 핸들 찾기</target>
        </trans-unit>
        <trans-unit id="7a1eb68de891c44654407116abb98e458fc1bd5d" translate="yes" xml:space="preserve">
          <source>Find all check-ins with the $trunk tag and test each one to see if it is a child of $ckid.</source>
          <target state="translated">$ trunk 태그를 사용하여 모든 체크인을 찾아 각 태그를 테스트하여 $ ckid의 하위인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ed342ba1f36533ca8947f53603f475b54647d31" translate="yes" xml:space="preserve">
          <source>Find all children of check-in $ckid and test each one to see if it has the $trunk tag.</source>
          <target state="translated">체크인 $ ckid의 모든 하위 항목을 찾아 각 하위 항목에 $ trunk 태그가 있는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e070eff936a49d2ff08648583ffdfb004cab42c4" translate="yes" xml:space="preserve">
          <source>Find the name of every customer whose account number is an even multiple of 100 between 10000 and 20000.</source>
          <target state="translated">계정 번호가 10000에서 20000 사이의 100의 배수 인 모든 고객의 이름을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="da3dcd15d290d67e8d58f666d8051f5d819612a5" translate="yes" xml:space="preserve">
          <source>Find the next available sequence number for cursor P1. Write the sequence number into register P2. The sequence number on the cursor is incremented after this instruction.</source>
          <target state="translated">커서 P1에 사용 가능한 다음 시퀀스 번호를 찾으십시오. 시퀀스 번호를 레지스터 P2에 씁니다. 이 명령어 후에 커서의 시퀀스 번호가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="241d2c67f0e7de4a78cfc1411341e1cf4add0d41" translate="yes" xml:space="preserve">
          <source>Find the next prepared statement</source>
          <target state="translated">다음에 준비된 진술을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6b89ff41f23972efdb7d4d4d2879439750317194" translate="yes" xml:space="preserve">
          <source>FindFrame(P,M): Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">FindFrame (P, M) : 페이지 번호 P와 최대 WAL 프레임 인덱스 M이 주어지면 M을 초과하지 않는 페이지 P에 대해 가장 큰 WAL 프레임 인덱스를 반환하거나 페이지 P에 대해 초과하지 않는 프레임이 없으면 NULL을 반환합니다. 미디엄.</target>
        </trans-unit>
        <trans-unit id="8c22258580b7042e2985fb2531773f63cce4fbd9" translate="yes" xml:space="preserve">
          <source>Finding The Subtype Of SQL Values</source>
          <target state="translated">SQL 값의 하위 유형 찾기</target>
        </trans-unit>
        <trans-unit id="66cbda77dfc7ac64a5cc57c477b9363b8fe8ac68" translate="yes" xml:space="preserve">
          <source>Finish the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">마침 &lt;a href=&quot;vdbe&quot;&gt;VDBE 자습서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db0389416175cfda557f294261cdfae0b0e04b4e" translate="yes" xml:space="preserve">
          <source>FinishSeek</source>
          <target state="translated">FinishSeek</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
