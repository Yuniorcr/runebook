<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="eda97b5c1428b06749d7192d2daf361d1e6b41f6" translate="yes" xml:space="preserve">
          <source>Each condition in a decision takes on every possible outcome.</source>
          <target state="translated">결정의 각 조건은 가능한 모든 결과를 취합니다.</target>
        </trans-unit>
        <trans-unit id="672a397b8caf80d825496d9e4addec34b7e37369" translate="yes" xml:space="preserve">
          <source>Each constraint will usually correspond to a term in the WHERE clause or in a USING or ON clause that is of the form</source>
          <target state="translated">각 제약 조건은 일반적으로 WHERE 절 또는 USING 또는 ON 절의 용어에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f6b6e4c189b9effbef953c5009fced4ccf9808f2" translate="yes" xml:space="preserve">
          <source>Each contiguous run of one or more token characters is considered to be a token. The tokenizer is case-insensitive according to the rules defined by Unicode 6.1.</source>
          <target state="translated">하나 이상의 토큰 문자의 각 연속 실행은 토큰으로 간주됩니다. 토큰 화기는 유니 코드 6.1에 의해 정의 된 규칙에 따라 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0c15694bfecc642469801a997c362ec50ff854e" translate="yes" xml:space="preserve">
          <source>Each database connection can only have a single &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy handler&lt;/a&gt;. This PRAGMA sets the busy handler for the process, possibly overwriting any previously set busy handler.</source>
          <target state="translated">각 데이터베이스 연결에는 하나의 사용 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;중인 핸들러&lt;/a&gt; 만있을 수 있습니다 . 이 PRAGMA는 프로세스의 사용 중 핸들러를 설정하여 이전에 설정 한 사용 중 핸들러를 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7265aba95bac18bc11991bd9aa22402abe89a0a4" translate="yes" xml:space="preserve">
          <source>Each decision tries every possible outcome.</source>
          <target state="translated">각 결정은 가능한 모든 결과를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f26f253bc3ab871e59787a1a1782281f2039ee4f" translate="yes" xml:space="preserve">
          <source>Each entry and exit point is invoked.</source>
          <target state="translated">각 시작 및 종료 지점이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b70891edf39568734c049868720f59bea931ef9" translate="yes" xml:space="preserve">
          <source>Each entry in a table b-tree consists of a 64-bit signed integer key and up to 2147483647 bytes of arbitrary data. (The key of a table b-tree corresponds to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table that the b-tree implements.) Interior table b-trees hold only keys and pointers to children. All data is contained in the table b-tree leaves.</source>
          <target state="translated">테이블 b- 트리의 각 항목은 64 비트 부호있는 정수 키와 최대 2147483647 바이트의 임의 데이터로 구성됩니다. 테이블 b- 트리의 키는 b- 트리가 구현하는 SQL 테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 에 해당합니다 . 내부 테이블 b- 트리는 키와 자식에 대한 포인터 만 보유합니다. 모든 데이터는 테이블 b- 트리 잎에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c3f1f6e5f1d0cee7e536d0dc65315194aa51a9" translate="yes" xml:space="preserve">
          <source>Each entry in an index b-tree consists of an arbitrary key of up to 2147483647 bytes in length and no data.</source>
          <target state="translated">인덱스 b- 트리의 각 항목은 최대 2147483647 바이트의 임의 키로 구성되며 데이터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="24437abe274be0540b142250bde8d16bab60708f" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외한 대부분의 SQLite 테이블의 각 항목 에는 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt; 라는 고유 한 64 비트 부호있는 정수 키가 있습니다. rowid는 명시 적으로 선언 된 열에 의해 사용되지 않는 한 ROWID, OID 또는 _ROWID_라는 선언되지 않은 열로 항상 사용 가능합니다. 테이블에 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 컬럼이있는 경우 해당 컬럼은 rowid의 다른 별명입니다.</target>
        </trans-unit>
        <trans-unit id="d1943964848547ccdd4634c64ac1256e964eb11b" translate="yes" xml:space="preserve">
          <source>Each entry in most SQLite tables (except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) has a unique 64-bit signed integer key called the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt;. The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then that column is another alias for the rowid.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외한 대부분의 SQLite 테이블의 각 항목 에는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;&quot;rowid&quot;&lt;/a&gt; 라는 고유 한 64 비트 부호있는 정수 키가 있습니다. rowid는 명시 적으로 선언 된 열에 의해 사용되지 않는 한 ROWID, OID 또는 _ROWID_라는 선언되지 않은 열로 항상 사용 가능합니다. 테이블에 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 컬럼이있는 경우 해당 컬럼은 rowid의 다른 별명입니다.</target>
        </trans-unit>
        <trans-unit id="901d9854ab50278bb04e1634932e0c3162943701" translate="yes" xml:space="preserve">
          <source>Each entry in the aPgno array has a single corresponding entry in the aHash array. There are more available slots in aHash than there are in aPgno. The unused slots in aHash are filled with zero. And since there are guaranteed to be unused slots in aHash, that means the loop that computes X is guaranteed to terminate. The expected size of X is less than 2. The worst case is that X will be the same as the number of entries in aPgno, in which case the algorithm runs at about the same speed as a linear scan of aPgno. But that worst case performance is exceedingly rare. Usually, the size of X will be small and the use of the aHash array allows one to compute FindFrame(P,M) much faster.</source>
          <target state="translated">aPgno 배열의 각 항목에는 aHash 배열에 해당하는 단일 항목이 있습니다. aPgno에있는 것보다 aHash에 사용 가능한 슬롯이 더 있습니다. 해시에서 사용되지 않는 슬롯은 0으로 채워집니다. 그리고 aHash에는 사용되지 않는 슬롯이 보장되므로 X를 계산하는 루프가 종료됩니다. X의 예상 크기는 2보다 작습니다. 최악의 경우 X는 aPgno의 항목 수와 동일하며이 경우 알고리즘은 aPgno의 선형 스캔과 거의 같은 속도로 실행됩니다. 그러나 최악의 성능은 매우 드 rare니다. 일반적으로 X의 크기는 작고 aHash 배열을 사용하면 FindFrame (P, M)을 훨씬 빠르게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcf88c184067656c86b627d1a59f0fe0f8cb79f" translate="yes" xml:space="preserve">
          <source>Each entry in the account_change table records a deposit or a withdrawal into an account. Deposits have a positive &quot;amt&quot; and withdrawals have a negative &quot;amt&quot;.</source>
          <target state="translated">account_change 테이블의 각 항목은 예금 또는 계좌 출금을 기록합니다. 예금은 긍정적 인 &quot;amt&quot;를 가지고, 인출은 부정적인 &quot;amt&quot;를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a6062c6a4e671adbb7f1cae985fca6efdd1bcc95" translate="yes" xml:space="preserve">
          <source>Each entry in the spellfix1 virtual table is associated with a particular language, identified by the integer &quot;langid&quot; column. The default langid is 0 and if no other actions are taken, the entire vocabulary is a part of the 0 language. But if your application needs to operate in multiple languages, then you can specify different vocabulary items for each language by specifying the langid field when populating the table. For example:</source>
          <target state="translated">spellfix1 가상 테이블의 각 항목은 정수 &quot;langid&quot;열로 식별되는 특정 언어와 연관됩니다. 기본 langid는 0이며 다른 조치를 취하지 않으면 전체 어휘는 0 언어의 일부입니다. 그러나 애플리케이션이 여러 언어로 작동해야하는 경우 테이블을 채울 때 langid 필드를 지정하여 각 언어에 대해 다른 어휘 항목을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fac2cc29010afaae6cb51cb626533541baf3f7b" translate="yes" xml:space="preserve">
          <source>Each expression in the result-set is then evaluated once for each group of rows. If the expression is an aggregate expression, it is evaluated across all rows in the group. Otherwise, it is evaluated against a single arbitrarily chosen row from within the group. If there is more than one non-aggregate expression in the result-set, then all such expressions are evaluated for the same row.</source>
          <target state="translated">그런 다음 결과 집합의 각 표현식은 각 행 그룹에 대해 한 번 평가됩니다. 표현식이 집계 표현식 인 경우 그룹의 모든 행에서 평가됩니다. 그렇지 않으면 그룹 내에서 임의로 선택된 단일 행에 대해 평가됩니다. 결과 집합에 둘 이상의 집계되지 않은식이 있으면 이러한 모든식이 동일한 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6438047b3d0359d4736da15419bdcf6543fd0081" translate="yes" xml:space="preserve">
          <source>Each extension function is allocated a single auxiliary data slot for each FTS query (MATCH expression). If the extension function is invoked more than once for a single FTS query, then all invocations share a single auxiliary data context.</source>
          <target state="translated">각 확장 기능에는 각 FTS 쿼리 (MATCH 식)에 대해 단일 보조 데이터 슬롯이 할당됩니다. 단일 FTS 쿼리에 대해 확장 기능이 두 번 이상 호출되면 모든 호출이 단일 보조 데이터 컨텍스트를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="d33d8aa62c5b61bac293e45f756797b6cb85d50a" translate="yes" xml:space="preserve">
          <source>Each foreign key constraint in SQLite is classified as either immediate or deferred. Foreign key constraints are immediate by default. All the foreign key examples presented so far have been of immediate foreign key constraints.</source>
          <target state="translated">SQLite의 각 외래 키 제약 조건은 즉시 또는 지연으로 분류됩니다. 외래 키 제약 조건은 기본적으로 즉시 적용됩니다. 지금까지 제시된 모든 외래 키 예제에는 즉각적인 외래 키 제약이있었습니다.</target>
        </trans-unit>
        <trans-unit id="6a1805543360f1e22766e2854c401aca860aeb6b" translate="yes" xml:space="preserve">
          <source>Each fts5vocab table is associated with a single FTS5 table. An fts5vocab table is usually created by specifying two arguments in place of column names in the CREATE VIRTUAL TABLE statement - the name of the associated FTS5 table and the type of fts5vocab table. Currently there are three types of fts5vocab table; &quot;row&quot;, &quot;col&quot; and &quot;instance&quot;. Unless the fts5vocab table is created within the &quot;temp&quot; database, it must be part of the same database as the associated FTS5 table.</source>
          <target state="translated">각 fts5vocab 테이블은 단일 FTS5 테이블과 연관됩니다. fts5vocab 테이블은 일반적으로 CREATE VIRTUAL TABLE 문에서 열 이름 대신 두 개의 인수 (관련된 FTS5 테이블의 이름 및 fts5vocab 테이블의 유형)를 지정하여 작성됩니다. 현재 fts5vocab 테이블에는 세 가지 유형이 있습니다. &quot;행&quot;, &quot;콜&quot;및 &quot;인스턴스&quot;. fts5vocab 테이블이 &quot;temp&quot;데이터베이스 내에 작성되지 않으면 테이블은 연관된 FTS5 테이블과 동일한 데이터베이스의 일부 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e745e43219ffcc55c78ef25c933503a8941d7638" translate="yes" xml:space="preserve">
          <source>Each group of input dataset rows contributes a single row to the set of result rows. Subject to filtering associated with the DISTINCT keyword, the number of rows returned by an aggregate query with a GROUP BY clause is the same as the number of groups of rows produced by applying the GROUP BY and HAVING clauses to the filtered input dataset.</source>
          <target state="translated">각 입력 데이터 세트 행 그룹은 단일 행을 결과 행 세트에 제공합니다. DISTINCT 키워드와 연관된 필터링에 따라 GROUP BY 절이있는 집계 쿼리에서 리턴되는 행 수는 GROUP BY 및 HAVING 절을 필터링 된 입력 데이터 세트에 적용하여 생성 된 행 그룹 수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7843ace013d2f4a1d502e5350d480fd1304c50c8" translate="yes" xml:space="preserve">
          <source>Each host parameter in an SQLite statement is assigned a number. The numbers normally begin with 1 and increase by one with each new parameter. However, when the &quot;?123&quot; form is used, the host parameter number is the number that follows the question mark.</source>
          <target state="translated">SQLite 문의 각 호스트 매개 변수에는 숫자가 할당됩니다. 숫자는 일반적으로 1로 시작하고 새 매개 변수마다 하나씩 증가합니다. 그러나 &quot;? 123&quot;형식을 사용하는 경우 호스트 매개 변수 번호는 물음표 뒤에 오는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="aa86db673d2e11cfb16c97d7614715b23b7a434b" translate="yes" xml:space="preserve">
          <source>Each individual test module might contain dozens, hundreds, or thousands of separate tests. The test modules can be written in C or as scripts of SQL or a mixture of the two. About two-thirds of the existing test modules are written in pure SQL with the remainder either in pure C or a combination of C and SQL.</source>
          <target state="translated">각 개별 테스트 모듈에는 수십, 수백 또는 수천 개의 개별 테스트가 포함될 수 있습니다. 테스트 모듈은 C로 작성하거나 SQL 스크립트 또는이 둘을 혼합하여 작성할 수 있습니다. 기존 테스트 모듈의 약 3 분의 2가 순수 SQL로 작성되고 나머지는 순수 C 또는 C와 SQL의 조합으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6f71e4dfef9dffaef271af8b4c7b3a147f1117" translate="yes" xml:space="preserve">
          <source>Each inserted row must be accompanied by an explicitly specified rowid value. If a contentless table is configured with columnsize=0, attempting to insert a NULL value into the rowid is an SQLITE_MISMATCH error.</source>
          <target state="translated">삽입 된 각 행에는 명시 적으로 지정된 rowid 값이 있어야합니다. contentless 테이블이 columnsize = 0으로 구성된 경우, rowid에 NULL 값을 삽입하려고하면 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="899a2acd85a7e060ed04cbcbd2e9466f80cde441" translate="yes" xml:space="preserve">
          <source>Each instruction of the VDBE language contains an opcode and three operands labeled P1, P2, and P3. Operand P1 is an arbitrary integer. P2 is a non-negative integer. P3 is a pointer to a data structure or null-terminated string, possibly null. Only a few VDBE instructions use all three operands. Many instructions use only one or two operands. A significant number of instructions use no operands at all but instead take their data and store their results on the execution stack. The details of what each instruction does and which operands it uses are described in the separate &lt;a href=&quot;opcode&quot;&gt;opcode description&lt;/a&gt; document.</source>
          <target state="translated">VDBE 언어의 각 명령어에는 opcode와 P1, P2 및 P3이라는 세 개의 피연산자가 포함되어 있습니다. 피연산자 P1은 임의의 정수입니다. P2는 음이 아닌 정수입니다. P3은 데이터 구조 또는 널 (null)로 끝나는 문자열에 대한 포인터이며 가능하면 널입니다. 소수의 VDBE 명령어 만 세 피연산자를 모두 사용합니다. 많은 명령어는 하나 또는 두 개의 피연산자 만 사용합니다. 많은 수의 명령어는 피연산자를 전혀 사용하지 않고 대신 데이터를 가져 와서 결과를 실행 스택에 저장합니다. 각 명령어의 기능과 사용하는 피연산자에 대한 자세한 내용은 별도의 &lt;a href=&quot;opcode&quot;&gt;opcode 설명&lt;/a&gt; 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66fd5c0b46cc5a181a71fe28426b2f8ae830bb14" translate="yes" xml:space="preserve">
          <source>Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt; returns an integer code that indicates what happened during that step. This code may be SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE, SQLITE_ERROR, or SQLITE_MISUSE.</source>
          <target state="translated">&lt;b&gt;sqlite_step을&lt;/b&gt; 호출 할 때마다 해당 단계에서 발생한 사항을 나타내는 정수 코드가 리턴됩니다. 이 코드는 SQLITE_BUSY, SQLITE_ROW, SQLITE_DONE, SQLITE_ERROR 또는 SQLITE_MISUSE 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda57e5707a682202e3ea3669b23018d0d5aa983" translate="yes" xml:space="preserve">
          <source>Each local changeset is rebased by calling sqlite3rebaser_rebase().</source>
          <target state="translated">각 로컬 변경 세트는 sqlite3rebaser_rebase ()를 호출하여 리베이스됩니다.</target>
        </trans-unit>
        <trans-unit id="77c7956712463753fdecca1cf0561681966682aa" translate="yes" xml:space="preserve">
          <source>Each of the b-trees that make up the full-text index is assigned to a &quot;level&quot; based on its size. Level-0 b-trees are the smallest, as they contain the contents of a single transaction. Higher level b-trees are the result of merging two or more level-0 b-trees together and so they are larger. FTS5 begins to merge b-trees together once there exist</source>
          <target state="translated">전체 텍스트 인덱스를 구성하는 각 b- 트리는 크기에 따라 &quot;레벨&quot;에 할당됩니다. 레벨 0 b- 트리는 단일 트랜잭션의 내용을 포함하므로 가장 작습니다. 높은 수준의 b- 트리는 둘 이상의 level-0 b- 트리를 함께 병합하여 더 커집니다. FTS5가 존재하면 B- 트리를 병합하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a769a3ad4df79c7cb38d60dba3f3bf7d78452a22" translate="yes" xml:space="preserve">
          <source>Each of these points will be described in more detail below, after first considering more closely the meaning of &quot;application file format&quot;. See also the &lt;a href=&quot;aff_short&quot;&gt;short version&lt;/a&gt; of this whitepaper.</source>
          <target state="translated">이러한 점들 각각은 &quot;애플리케이션 파일 형식&quot;의 의미를 더 자세히 고려한 후에 아래에서 더 상세히 설명 될 것이다. 이 백서 의 &lt;a href=&quot;aff_short&quot;&gt;짧은 버전&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5b3811f86b94838c4eb44ef8dbbc1bed6e5053e" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">열려있는 각 SQLite 데이터베이스는 &quot;sqlite3&quot;이라는 불투명 구조의 인스턴스에 대한 포인터로 표시됩니다. sqlite3 포인터를 객체로 생각하면 유용합니다. &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스는 생성자이며 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 ()는&lt;/a&gt; 그 파괴자이다. 많은 다른 인터페이스가있다 (예 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()는&lt;/a&gt; 이름 그러나 셋을)를 sqlite3를 객체 메소드 있음.</target>
        </trans-unit>
        <trans-unit id="92b7576547952b019821d8e7929a16a6e6b6d4ff" translate="yes" xml:space="preserve">
          <source>Each open SQLite database is represented by a pointer to an instance of the opaque structure named &quot;sqlite3&quot;. It is useful to think of an sqlite3 pointer as an object. The &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces are its constructors, and &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; are its destructors. There are many other interfaces (such as &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, and &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; to name but three) that are methods on an sqlite3 object.</source>
          <target state="translated">열려있는 각 SQLite 데이터베이스는 &quot;sqlite3&quot;이라는 불투명 구조의 인스턴스에 대한 포인터로 표시됩니다. sqlite3 포인터를 객체로 생각하면 유용합니다. &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스는 생성자이며 &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; 및 &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 ()는&lt;/a&gt; 그 파괴자이다. 많은 다른 인터페이스가있다 (예 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; , &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()는&lt;/a&gt; 이름 그러나 셋을)를 sqlite3를 객체 메소드 있음.</target>
        </trans-unit>
        <trans-unit id="ee894daabc7121702b3448691c905adb7d440b29" translate="yes" xml:space="preserve">
          <source>Each ordinary SQL table in the database schema is represented on-disk by a table b-tree. Each entry in the table b-tree corresponds to a row of the SQL table. The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the SQL table is the 64-bit signed integer key for each entry in the table b-tree.</source>
          <target state="translated">데이터베이스 스키마의 각 일반 SQL 테이블은 디스크에서 테이블 b- 트리로 표시됩니다. 테이블 b- 트리의 각 항목은 SQL 테이블의 행에 해당합니다. SQL 테이블 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 는 테이블 b- 트리의 각 항목에 대한 64 비트 부호있는 정수 키입니다.</target>
        </trans-unit>
        <trans-unit id="74ebddba931d62de6d9b53e43959c1987854ff78" translate="yes" xml:space="preserve">
          <source>Each polygon in the Geopoly module can be associated with an arbitrary number of auxiliary data fields.</source>
          <target state="translated">Geopoly 모듈의 각 다각형은 임의의 수의 보조 데이터 필드와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a000525bb8067810fd906490555a5fd20fbf3f0a" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">준비된 각 문 은 특정 작업을 수행 한 횟수를 측정하는 다양한 &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 유지 관리 합니다. 이 카운터는 준비된 문의 성능 특성을 모니터링하는 데 사용할 수 있습니다. 예를 들어, 테이블 단계 수가 테이블 검색 또는 결과 행 수를 크게 초과하면 준비된 명령문이 인덱스가 아닌 전체 테이블 스캔을 사용하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0107ece90b86e808837320ac7220432f2669eb1d" translate="yes" xml:space="preserve">
          <source>Each prepared statement maintains various &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counters&lt;/a&gt; that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.</source>
          <target state="translated">준비된 각 문 은 특정 작업을 수행 한 횟수를 측정하는 다양한 &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 유지 관리 합니다. 이 카운터는 준비된 문의 성능 특성을 모니터링하는 데 사용할 수 있습니다. 예를 들어, 테이블 단계 수가 테이블 검색 또는 결과 행 수를 크게 초과하면 준비된 명령문이 인덱스가 아닌 전체 테이블 스캔을 사용하고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="999331a91fda475fee950bbc880e18a160954827" translate="yes" xml:space="preserve">
          <source>Each read lock byte corresponds to one of the five 32-bit read-mark integers located in bytes 100 through 119 of the WAL-index header, as follows:</source>
          <target state="translated">각 읽기 잠금 바이트는 다음과 같이 WAL- 색인 헤더의 바이트 100-119에있는 5 개의 32 비트 읽기 표시 정수 중 하나에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="fd4a538875dcd8a3da92631d9e514ff489421f3d" translate="yes" xml:space="preserve">
          <source>Each row in a table with a primary key must have a unique combination of values in its primary key columns. For the purposes of determining the uniqueness of primary key values, NULL values are considered distinct from all other values, including other NULLs. If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement attempts to modify the table content so that two or more rows have identical primary key values, that is a constraint violation.</source>
          <target state="translated">기본 키가있는 테이블의 각 행에는 기본 키 열에 고유 한 값 조합이 있어야합니다. 기본 키 값의 고유성을 결정하기 위해 NULL 값은 다른 NULL을 포함하여 다른 모든 값과 다른 것으로 간주됩니다. 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE의&lt;/a&gt; 문 시도 테이블 내용을 수정할 수 있도록 두 개 이상의 행이 제약 조건 위반입니다, 동일한 기본 키 값이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6d65e1c2c837dfdc0a485f823d815f1cb8af08" translate="yes" xml:space="preserve">
          <source>Each row in ex25ae contains five columns: c, e, d, c, a. The c column is repeated since the first occurrence of c has a collating function of &quot;nocase&quot; and the second has a collating sequence of &quot;binary&quot;. If the c column is not repeated and if the table contains two or more entries with the same e value and where c differs only in case, then all of those table entries would correspond to a single entry in the index, which would break the one-to-one correspondence between the table and the index.</source>
          <target state="translated">ex25ae의 각 행에는 c, e, d, c, a의 5 개 열이 있습니다. c의 첫 번째 발생이 &quot;nocase&quot;의 조합 기능을 갖고 두 번째 발생이 &quot;이진&quot;의 조합 순서를 갖기 때문에 c 컬럼이 반복됩니다. c 열이 반복되지 않고 테이블에 동일한 e 값을 가진 두 개 이상의 항목이 포함되어 있고 c가 경우에만 다른 경우, 해당 테이블 항목은 모두 색인의 단일 항목에 해당하므로 하나를 중단합니다. 테이블과 인덱스 간의 일대일 대응.</target>
        </trans-unit>
        <trans-unit id="f36fe249b41449ff09e1c30c002890daff1cad55" translate="yes" xml:space="preserve">
          <source>Each row in the ex25ce index is a record with these columns: c, e, d, a. The first two columns are the columns being indexed, c and e. The remaining columns are the primary key of the corresponding table row. Normally, the primary key would be columns d, c, and a, but because column c already appears earlier in the index, it is omitted from the key suffix.</source>
          <target state="translated">ex25ce 인덱스의 각 행은 c, e, d, a 열이있는 레코드입니다. 처음 두 열은 색인을 생성하는 열 c와 e입니다. 나머지 열은 해당 테이블 행의 기본 키입니다. 일반적으로 기본 키는 열 d, c 및 a이지만, 열 c가 인덱스의 앞부분에 이미 나타나므로 키 접미사에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="cab24ffbbc0f1bf68fc2e07923e9d56fc10203eb" translate="yes" xml:space="preserve">
          <source>Each row in the spellfix1 virtual table has a unique rowid with seven columns plus five extra hidden columns. The columns are as follows:</source>
          <target state="translated">spellfix1 가상 테이블의 각 행에는 7 개의 열과 5 개의 추가 숨겨진 열이있는 고유 한 rowid가 있습니다. 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b6636128d8303465a6612a171949922d9167128" translate="yes" xml:space="preserve">
          <source>Each row of the SQLAR table holds the content of a single file. The filename (the full pathname relative to the root of the archive) is in the &quot;name&quot; field. The &quot;mode&quot; field is an integer which is the unix-style access permissions for the file. &quot;mtime&quot; is the modification time of the file in seconds since 1970. &quot;sz&quot; is the original uncompressed size of the file. The &quot;data&quot; field contains the file content. The content is usually compressed using &lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate&lt;/a&gt;, though not always. If the &quot;sz&quot; field is equal to the size of the &quot;data&quot; field, then the content is stored uncompressed.</source>
          <target state="translated">SQLAR 테이블의 각 행은 단일 파일의 내용을 보유합니다. 파일 이름 (아카이브 루트에 상대적인 전체 경로 이름)은 &quot;이름&quot;필드에 있습니다. &quot;mode&quot;필드는 파일에 대한 유닉스 스타일 액세스 권한 인 정수입니다. &quot;mtime&quot;은 1970 년 이후의 파일 수정 시간 (초)입니다. &quot;sz&quot;는 파일의 원래 압축되지 않은 크기입니다. &quot;데이터&quot;필드는 파일 내용을 포함합니다. 내용은 항상 &lt;a href=&quot;http://zlib.net/&quot;&gt;Deflate를&lt;/a&gt; 사용하여 압축 되지만 항상 그런 것은 아닙니다. &quot;sz&quot;필드가 &quot;data&quot;필드의 크기와 같으면 컨텐츠는 압축되지 않은 상태로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b6165a221a3e4a38199edcd68a8e62b04991c252" translate="yes" xml:space="preserve">
          <source>Each row of the SQLITE_MEMSTAT table corresponds to a single call to one of the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; or &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces. The NAME column of the row identifies which &quot;verb&quot; was passed to those interfaces. For example, if &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;, then the NAME column is 'MEMORY_USED'. Or if &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; is invoked with &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt;, then the NAME column is &quot;DB_CACHE_USED&quot;.</source>
          <target state="translated">SQLITE_MEMSTAT 테이블의 각 행은 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스 중 하나에 대한 단일 호출에 해당합니다 . 행의 NAME 열은 해당 인터페이스로 전달 된 &quot;동사&quot;를 식별합니다. 예를 들어, &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()가&lt;/a&gt; 호출된다 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; 다음 NAME 열은 'MEMORY_USED'는이다. 또는 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 가 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; 로 호출 된 경우 NAME 열은 &quot;DB_CACHE_USED&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="997a34331755f5f92b0f76283ad7cb1a20992bfb" translate="yes" xml:space="preserve">
          <source>Each small sort is run independently, meaning that much less information needs to be kept in temporary storage at any one time.</source>
          <target state="translated">각각의 작은 정렬은 독립적으로 실행되므로 한 번에 임시 저장 공간에 훨씬 적은 정보를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b0b5952e142633475481798bf66c99ae914842" translate="yes" xml:space="preserve">
          <source>Each subsequent string or bareword in a column declaration is a column option that modifies the behaviour of that column. Column options are case-independent. Unlike the SQLite core, FTS5 considers unrecognized column options to be errors. Currently, the only option recognized is &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&quot;UNINDEXED&quot; (see below)&lt;/a&gt;.</source>
          <target state="translated">열 선언에서 각 후속 문자열 또는 베어 워드는 해당 열의 동작을 수정하는 열 옵션입니다. 열 옵션은 대소 문자를 구분하지 않습니다. SQLite 코어와 달리 FTS5는 인식 할 수없는 열 옵션을 오류로 간주합니다. 현재 인식되는 유일한 옵션은 &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;&quot;UNINDEXED&quot;입니다 (아래 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818d5604974790264ec0e5e9c61bfb95c5744c47" translate="yes" xml:space="preserve">
          <source>Each table and each index in SQLite is stored in a separate b-tree in the database file. Each b-tree is identified by its root page number. The root page number for any index or table can be found by querying the &quot;rootpage&quot; column of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. See the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; and the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further background on this design.</source>
          <target state="translated">SQLite의 각 테이블과 각 인덱스는 데이터베이스 파일에서 별도의 b- 트리에 저장됩니다. 각 b- 트리는 루트 페이지 번호로 식별됩니다. &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 의 &quot;rootpage&quot;열을 쿼리하여 인덱스 또는 테이블의 루트 페이지 번호를 찾을 수 있습니다 . 이 디자인에 대한 추가 배경 지식을 &lt;a href=&quot;queryplanner&quot;&gt;얻으&lt;/a&gt; 려면 인덱싱 자습서 및 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ce016ce4a1263a1e308f54a333440722a399bac" translate="yes" xml:space="preserve">
          <source>Each table and index requires at least one page in the database file. An &quot;index&quot; in the previous sentence means an index created explicitly using a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement or implicit indices created by UNIQUE and PRIMARY KEY constraints. Since the maximum number of pages in a database file is 2147483646 (a little over 2 billion) this is also then an upper bound on the number of tables and indices in a schema.</source>
          <target state="translated">각 테이블과 인덱스는 데이터베이스 파일에 하나 이상의 페이지가 필요합니다. 이전 문장에서 &quot;인덱스&quot;는 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 사용하여 명시 적으로 생성 된 인덱스 또는 UNIQUE 및 PRIMARY KEY 제약 조건으로 생성 된 암시 적 인덱스를 의미합니다 . 데이터베이스 파일의 최대 페이지 수는 2147483646 (약 20 억 개)이므로 스키마의 테이블 및 인덱스 수의 상한이기도합니다.</target>
        </trans-unit>
        <trans-unit id="7fd6452e149193b7e1151a0184d1459cf1e10a68" translate="yes" xml:space="preserve">
          <source>Each table in SQLite may have at most one &lt;b&gt;PRIMARY KEY&lt;/b&gt;. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt;, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">SQLite의 각 테이블에는 최대 하나의 &lt;b&gt;PRIMARY KEY&lt;/b&gt; 가있을 수 있습니다 . 키워드 PRIMARY KEY가 열 정의에 추가되면 테이블의 기본 키는 해당 단일 열로 구성됩니다. 또는 PRIMARY KEY 절이 &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; 로 지정된 경우 테이블 의 기본 키는 PRIMARY KEY 절의 일부로 지정된 열 목록으로 구성됩니다. PRIMARY KEY 절은 열 이름 만 포함해야합니다. PRIMARY KEY의 &lt;a href=&quot;syntax/indexed-column&quot;&gt;색인 열&lt;/a&gt; 에서 표현식 사용은 지원되지 않습니다. CREATE TABLE 문에 둘 이상의 PRIMARY KEY 절이 나타나면 오류가 발생합니다. PRIMARY KEY는 일반 테이블의 경우 선택 사항이지만 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 경우 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="da7220645d88bb24fc93c16ec387c215924ce8f1" translate="yes" xml:space="preserve">
          <source>Each table in the FROM clause of a query can use at most one index (except when the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; comes into play) and SQLite strives to use at least one index on each table. Sometimes, two or more indices might be candidates for use on a single table. For example:</source>
          <target state="translated">쿼리의 FROM 절에있는 각 테이블은 최대 하나의 인덱스를 사용할 수 있으며 ( &lt;a href=&quot;#or_opt&quot;&gt;OR 절 최적화&lt;/a&gt; 가 실행되는 경우 제외 ) SQLite는 각 테이블에서 하나 이상의 인덱스를 사용하려고합니다. 때로는 두 개 이상의 인덱스가 단일 테이블에서 사용하기위한 후보 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d5f5bbc1c1dec038bbb126443a4f518b5530436" translate="yes" xml:space="preserve">
          <source>Each temporary table and index is given its own page cache which can store a maximum number of database pages determined by the SQLITE_DEFAULT_TEMP_CACHE_SIZE compile-time parameter. (The default value is 500 pages.) The maximum number of database pages in the page cache is the same for every temporary table and index. The value cannot be changed at run-time or on a per-table or per-index basis. Each temporary file gets its own private page cache with its own SQLITE_DEFAULT_TEMP_CACHE_SIZE page limit.</source>
          <target state="translated">각 임시 테이블 및 인덱스에는 SQLITE_DEFAULT_TEMP_CACHE_SIZE 컴파일 타임 매개 변수로 판별 된 최대 데이터베이스 페이지 수를 저장할 수있는 자체 페이지 캐시가 제공됩니다. (기본값은 500 페이지입니다.) 페이지 캐시의 최대 데이터베이스 페이지 수는 모든 임시 테이블 및 인덱스에 대해 동일합니다. 런타임시 또는 테이블 또는 인덱스별로 값을 변경할 수 없습니다. 각 임시 파일은 자체 SQLITE_DEFAULT_TEMP_CACHE_SIZE 페이지 제한이있는 자체 개인 페이지 캐시를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="396be9e68045d4b494141a2b61767c3d988f291c" translate="yes" xml:space="preserve">
          <source>Each test module file contains a header which describes the circumstances under which the test is valid. For a particular configuration, only those modules that are compatible with the configuration are run.</source>
          <target state="translated">각 테스트 모듈 파일에는 테스트가 유효한 환경을 설명하는 헤더가 포함되어 있습니다. 특정 구성의 경우 구성과 호환되는 모듈 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="82839803e7b91a3d746402c43f4f5e99695c5aff" translate="yes" xml:space="preserve">
          <source>Each time a row is inserted into the table by an INSERT statement that does not provide explicit values for all table columns the values stored in the new row are determined by their default values, as follows:</source>
          <target state="translated">모든 테이블 컬럼에 대해 명시적인 값을 제공하지 않는 INSERT 문으로 테이블에 행을 삽입 할 때마다 새 행에 저장된 값은 다음과 같이 기본값에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="821f4ad950cccc21cbff55f2ebad926da59331c6" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">충돌 핸들러 함수가 호출 될 때마다 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; 중 하나를 리턴해야합니다 . 충돌 핸들러에 전달 된 두 번째 인수가 SQLITE_CHANGESET_DATA 또는 SQLITE_CHANGESET_CONFLICT 인 경우에만 SQLITE_CHANGESET_REPLACE가 리턴 될 수 있습니다. 충돌 처리기가 잘못된 값을 반환하면 이미 변경 한 내용이 모두 롤백되고 sqlite3changeset_apply () 호출이 SQLITE_MISUSE를 반환합니다. 충돌 처리기 함수를 호출 할 때마다 반환되는 값에 따라 sqlite3changeset_apply ()가 다른 작업을 수행합니다. 자세한 내용은 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;사용 가능한&lt;/a&gt; 세 가지 반환 값에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fdebc8e16d47a197b7a842f6a3967c8187697b" translate="yes" xml:space="preserve">
          <source>Each time the conflict handler function is invoked, it must return one of &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt;, &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; or &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;. SQLITE_CHANGESET_REPLACE may only be returned if the second argument passed to the conflict handler is either SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler returns an illegal value, any changes already made are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different actions are taken by sqlite3changeset_apply() depending on the value returned by each invocation of the conflict-handler function. Refer to the documentation for the three &lt;a href=&quot;c_changeset_abort&quot;&gt;available return values&lt;/a&gt; for details.</source>
          <target state="translated">충돌 핸들러 함수가 호출 될 때마다 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_OMIT&lt;/a&gt; , &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; 중 하나를 리턴해야합니다 . 충돌 핸들러에 전달 된 두 번째 인수가 SQLITE_CHANGESET_DATA 또는 SQLITE_CHANGESET_CONFLICT 인 경우에만 SQLITE_CHANGESET_REPLACE가 리턴 될 수 있습니다. 충돌 처리기가 잘못된 값을 반환하면 이미 변경 한 내용이 모두 롤백되고 sqlite3changeset_apply () 호출이 SQLITE_MISUSE를 반환합니다. 충돌 처리기 함수를 호출 할 때마다 반환되는 값에 따라 sqlite3changeset_apply ()가 다른 작업을 수행합니다. 자세한 내용은 &lt;a href=&quot;c_changeset_abort&quot;&gt;사용 가능한&lt;/a&gt; 세 가지 반환 값에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8d207a3340b7e4a9461110fe5af6c49d7e816b35" translate="yes" xml:space="preserve">
          <source>Each time the xInput callback is invoked by the sessions module, the first argument passed is a copy of the supplied pIn context pointer. The second argument, pData, points to a buffer (*pnData) bytes in size. Assuming no error occurs the xInput method should copy up to (*pnData) bytes of data into the buffer and set (*pnData) to the actual number of bytes copied before returning SQLITE_OK. If the input is completely exhausted, (*pnData) should be set to zero to indicate this. Or, if an error occurs, an SQLite error code should be returned. In all cases, if an xInput callback returns an error, all processing is abandoned and the streaming API function returns a copy of the error code to the caller.</source>
          <target state="translated">세션 모듈이 xInput 콜백을 호출 할 때마다 전달 된 첫 번째 인수는 제공된 pIn 컨텍스트 포인터의 사본입니다. 두 번째 인수 인 pData는 크기가 버퍼 (* pnData) 바이트를 가리 킵니다. 오류가 발생하지 않는다고 가정하면 xInput 메소드는 최대 (* pnData) 바이트의 데이터를 버퍼에 복사하고 SQLITE_OK를 리턴하기 전에 복사 된 실제 바이트 수로 (* pnData)를 설정해야합니다. 입력이 완전히 소진 된 경우이를 나타내려면 (* pnData)를 0으로 설정해야합니다. 또는 오류가 발생하면 SQLite 오류 코드가 리턴되어야합니다. 모든 경우에, xInput 콜백이 오류를 반환하면 모든 처리가 중단되고 스트리밍 API 함수는 오류 코드 사본을 호출자에게 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23d4a49b5fad6a5cff3892e56560d6b2467c05f2" translate="yes" xml:space="preserve">
          <source>Each transaction can be committed by overwriting the rollback journal header with zeros rather than deleting the journal file. This avoids having to modify the directory entry for the journal file and it avoids having to deallocate disk sectors associated with the journal. Furthermore, the next transaction will overwrite existing journal file content rather than append new content and on most systems overwriting is much faster than appending.</source>
          <target state="translated">저널 파일을 삭제하지 않고 롤백 저널 헤더를 0으로 겹쳐 써서 각 트랜잭션을 커밋 할 수 있습니다. 이렇게하면 저널 파일의 디렉토리 항목을 수정하지 않아도되고 저널과 연관된 디스크 섹터를 할당 해제하지 않아도됩니다. 또한 다음 트랜잭션에서는 새 내용을 추가하는 대신 기존 저널 파일 내용을 덮어 쓰게되며 대부분의 시스템에서는 덮어 쓰기가 추가하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="159aa0e59fdea8a05c775d6b054f429c0df2af88" translate="yes" xml:space="preserve">
          <source>Each transient index is stored in its own temporary file. The temporary file for a transient index is automatically deleted at the end of the statement that uses it.</source>
          <target state="translated">각 임시 색인은 자체 임시 파일에 저장됩니다. 임시 색인의 임시 파일은이를 사용하는 명령문의 끝에서 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="fca57b0c6d20c7ecd27ccd8ad15ef9f43027716b" translate="yes" xml:space="preserve">
          <source>Each value stored in an SQLite database (or manipulated by the database engine) has one of the following storage classes:</source>
          <target state="translated">SQLite 데이터베이스에 저장된 (또는 데이터베이스 엔진으로 조작 된) 각 값에는 다음 스토리지 클래스 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e662adf0f870371f71f9ee7e2791e8f09589bff" translate="yes" xml:space="preserve">
          <source>Each virtual table instance is represented by an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure. The sqlite3_vtab structure looks like this:</source>
          <target state="translated">각 가상 테이블 인스턴스는 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조로 표시됩니다 . sqlite3_vtab 구조는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="e3984e1960f4cb3742e6adde6b1867fad529f949" translate="yes" xml:space="preserve">
          <source>Easily Extensible</source>
          <target state="translated">쉽게 확장 가능</target>
        </trans-unit>
        <trans-unit id="441046fa5ffdde9809362069e6548a3082c7a725" translate="yes" xml:space="preserve">
          <source>Edits occurs sequentially from left to right. Changes caused by prior edits can affect the path search for subsequent edits.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순차적으로 편집이 수행됩니다. 이전 편집으로 인한 변경은 후속 편집의 경로 검색에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0dfbd71d0c98711cf3c97133105aec44ca6de76" translate="yes" xml:space="preserve">
          <source>Eight bytes of space are set aside in the header to support file locking using the xShmLock() method in the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object. These eight bytes are never read nor written by SQLite since some VFSes (ex: Windows) might implement locks using mandatory file locks.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xShmLock () 메서드를 사용하여 파일 잠금을 지원하기 위해 헤더에 8 바이트의 공간이 별도로 설정되어 있습니다 . 일부 VFS (예 : Windows)는 필수 파일 잠금을 사용하여 잠금을 구현할 수 있으므로이 8 바이트는 SQLite에서 읽거나 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ace11e5b34a13ed99fabf311ff93445f3668386e" translate="yes" xml:space="preserve">
          <source>Either of the following input table schemas may be used:</source>
          <target state="translated">다음 입력 테이블 스키마 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d37f85cf0de81fb27668a49df7ae8937fb1c1d" translate="yes" xml:space="preserve">
          <source>Either the query is DISTINCT or else the ON or USING clause on the LEFT JOIN constrains the join such that it matches only a single row</source>
          <target state="translated">쿼리가 DISTINCT이거나 LEFT JOIN의 ON 또는 USING 절이 단일 행과 일치하도록 조인을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4728cde333d59654162b98fb2f80035a1df0e676" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is ASC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;gt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">그렇지 않으면 ORDER BY가 ASC이면 경계는 X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;gt; = X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 의 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="299837df5991cc66f1e3ca4e6217b98091245afa" translate="yes" xml:space="preserve">
          <source>Else if the ORDER BY is DESC then the boundary is the first row for which X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;&amp;lt;=X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;-&amp;lt;expr&amp;gt;.</source>
          <target state="translated">그렇지 않으면 ORDER BY가 DESC이면 경계는 X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; &amp;lt;= X &lt;sub&gt;&lt;small&gt;c-&lt;/small&gt;&lt;/sub&gt; &amp;lt;expr&amp;gt; 의 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="ec4efc66414e2d0acccb9c6dda956e43ccfc0932" translate="yes" xml:space="preserve">
          <source>ElseNotEq</source>
          <target state="translated">ElseNotEq</target>
        </trans-unit>
        <trans-unit id="742075f0a90a29b1298aa6bdc53785796a5215d5" translate="yes" xml:space="preserve">
          <source>Embedded applications may wish to provide their own mutex implementation. If SQLite is compiled with the -DSQLITE_MUTEX_APPDEF=1 compile-time flag then the SQLite core provides no mutex subsystem and a mutex subsystem that matches the interface described above must be provided by the application that links against SQLite.</source>
          <target state="translated">임베디드 애플리케이션은 자체 뮤텍스 구현을 제공하고자 할 수 있습니다. SQLite가 -DSQLITE_MUTEX_APPDEF = 1 컴파일 타임 플래그로 컴파일 된 경우 SQLite 코어는 뮤텍스 서브 시스템을 제공하지 않으며 위에서 설명한 인터페이스와 일치하는 뮤텍스 서브 시스템은 SQLite와 링크되는 애플리케이션에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c53320e0cd9a6276b0d7615514d5e92e35c47d10" translate="yes" xml:space="preserve">
          <source>Enable Or Disable A Session Object</source>
          <target state="translated">세션 객체 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="47209fc977a3d6844b590f95a2e890da8c62a167" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extended Result Codes</source>
          <target state="translated">확장 결과 코드 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="2ae5828f55ab597198616d5a6a29272c5472108b" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Extension Loading</source>
          <target state="translated">확장 로딩 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="4f3889a08ab86ec8ddcc4be30913885c66215716" translate="yes" xml:space="preserve">
          <source>Enable Or Disable Shared Pager Cache</source>
          <target state="translated">공유 호출기 캐시 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="9ea1888b42850afab6ed8b09793199ea8c9bea55" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">세션 객체에 의한 변경 기록을 활성화 또는 비활성화합니다. 사용 가능한 경우 세션 오브젝트는 데이터베이스의 변경 사항을 기록합니다. 비활성화되면 그렇지 않습니다. 새로 작성된 세션 오브젝트가 사용 가능합니다. 세션 객체 활성화 및 비활성화가 최종 변경 세트에 미치는 영향에 대한 자세한 내용은 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17f9b9420a663ed4c76c71c9c8073e9fc9710b0f" translate="yes" xml:space="preserve">
          <source>Enable or disable the recording of changes by a session object. When enabled, a session object records changes made to the database. When disabled - it does not. A newly created session object is enabled. Refer to the documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details regarding how enabling and disabling a session object affects the eventual changesets.</source>
          <target state="translated">세션 객체에 의한 변경 기록을 활성화 또는 비활성화합니다. 사용 가능한 경우 세션 오브젝트는 데이터베이스의 변경 사항을 기록합니다. 비활성화되면 그렇지 않습니다. 새로 작성된 세션 오브젝트가 사용 가능합니다. 세션 객체 활성화 및 비활성화가 최종 변경 세트에 미치는 영향에 대한 자세한 내용은 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4dfbc50e373163a24f20145d89cc661c7f9016f" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the ESCAPE keyword is present and &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; is on.</source>
          <target state="translated">ESCAPE 키워드가 있고 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; 가 설정된 경우 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38bd8aad51460f777742311f6118d4753c58ac85" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check=ON&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check = ON&lt;/a&gt; 설정을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9de93a7abfad3451907ee76c7e8380b3e2a12e38" translate="yes" xml:space="preserve">
          <source>Enable the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR optimization&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대한 &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;OR 최적화&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="139b97f174f99845864a6e58fe92ec54c44c22d0" translate="yes" xml:space="preserve">
          <source>Enable the code the implements the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rbu&quot;&gt;RBU 확장을&lt;/a&gt; 구현하는 코드를 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a4b947c5d7c94485590879fd68adb16381cb913" translate="yes" xml:space="preserve">
          <source>Enabled &lt;a href=&quot;loadext#persist&quot;&gt;persistent loadable extensions&lt;/a&gt; using the new &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; return code from the extension entry point.</source>
          <target state="translated">사용 &lt;a href=&quot;loadext#persist&quot;&gt;지속로드 가능한 확장&lt;/a&gt; 새로운를 사용하여이 &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; 확장 진입 점에서 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ea330e39a61763b4ace4d9831f5c3c48035f13c" translate="yes" xml:space="preserve">
          <source>Enabling SQL manipulation of data in statistics packages like R</source>
          <target state="translated">R과 같은 통계 패키지에서 데이터의 SQL 조작 사용</target>
        </trans-unit>
        <trans-unit id="658589b85baec8128d8a55f7bca7bc8f71c38156" translate="yes" xml:space="preserve">
          <source>Enabling mutexes incurs a measurable performance penalty. So if speed is of utmost importance, it makes sense to disable the mutexes. But for maximum safety, mutexes should be enabled. The default behavior is for mutexes to be enabled.</source>
          <target state="translated">뮤텍스를 활성화하면 측정 가능한 성능 저하가 발생합니다. 따라서 속도가 가장 중요한 경우 뮤텍스를 비활성화하는 것이 좋습니다. 그러나 최대한의 안전을 위해 뮤텍스를 활성화해야합니다. 기본 동작은 뮤텍스를 활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2894e6ce65268ab410ea576f81be8b800728595" translate="yes" xml:space="preserve">
          <source>Enabling shared-cache for an in-memory database allows two or more database connections in the same process to have access to the same in-memory database. An in-memory database in shared cache is automatically deleted and memory is reclaimed when the last connection to that database closes.</source>
          <target state="translated">인 메모리 데이터베이스에 대해 공유 캐시를 활성화하면 동일한 프로세스에서 둘 이상의 데이터베이스 연결이 동일한 인 메모리 데이터베이스에 액세스 할 수 있습니다. 공유 캐시의 메모리 내 데이터베이스는 자동으로 삭제되고 해당 데이터베이스에 대한 마지막 연결이 닫히면 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="e9d959f1da0d822e6e152768cadbd40ebe86ec7f" translate="yes" xml:space="preserve">
          <source>Encoded Representation</source>
          <target state="translated">인코딩 된 표현</target>
        </trans-unit>
        <trans-unit id="ce95e3947ec272a5e059c01e37e860b0eadf0f49" translate="yes" xml:space="preserve">
          <source>EndCoroutine</source>
          <target state="translated">EndCoroutine</target>
        </trans-unit>
        <trans-unit id="227897f6614bd1979b06a47b741b2b7b86d2c18a" translate="yes" xml:space="preserve">
          <source>Ending a Read-only Transaction</source>
          <target state="translated">읽기 전용 트랜잭션 종료</target>
        </trans-unit>
        <trans-unit id="66d638205095ec32694e8e53496ae104a46818bd" translate="yes" xml:space="preserve">
          <source>Enhance &quot;&lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt;&quot; so that it shows the schema names for all attached if the name is anything other than &quot;main&quot;.</source>
          <target state="translated">이름이 &quot;main&quot;이외의 이름 인 경우 첨부 된 모든 스키마 이름을 표시하도록 &quot; &lt;a href=&quot;cli#dtables&quot;&gt;.tables&lt;/a&gt; &quot;를 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="86691e1c27add4aa9b223b839c80106c74dae104" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2(TRUNCATE)&lt;/a&gt; interface so that it truncates the WAL file even if there is no checkpoint work to be done.</source>
          <target state="translated">검사 점 작업이 없어도 WAL 파일을 자르도록 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 (TRUNCATE)&lt;/a&gt; 인터페이스를 향상 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a80638ab16814f00dc09b0caf66656e977b1595" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; to avoid using excess stack space when there are a huge number of terms on the right-hand side of the MATCH operator. A side-effect of this change is that the MATCH operator can only accommodate 12 NEAR operators at a time.</source>
          <target state="translated">MATCH 연산자의 오른쪽에 많은 수의 용어가있을 때 초과 스택 공간을 사용하지 않도록 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 을 향상 시키십시오 . 이 변경의 부작용은 MATCH 운영자가 한 번에 12 명의 NEAR 운영자 만 수용 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9e7233e0df128965e10fbf74799b90510b5e89b" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; so that it recognizes &quot;true&quot; and &quot;false&quot; as valid arguments to DEFAULT.</source>
          <target state="translated">&quot;참&quot;및 &quot;거짓&quot;을 DEFAULT의 유효한 인수로 인식하도록 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE을&lt;/a&gt; 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="adabac8599a55ec6de7c3ac30be20a3119f8f411" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they verify &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 을 확인하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check을&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="536fdd0657f2b3142f09507f33c8fdf8c4fc486c" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; so that it identifies tables that have two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">동일한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 가진 둘 이상의 행이있는 테이블을 식별하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check를&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="6c8ab102b2516f5a84e5ee68a4f1dbbb2f643256" translate="yes" xml:space="preserve">
          <source>Enhance &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; so that it provides information about &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;동일한 &lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 에 대한 정보를 제공하도록 PRAGMA table_info를 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="0ba1f90920b2bd9339636a57ccf3fdacffa95fd7" translate="yes" xml:space="preserve">
          <source>Enhance IN operator processing to make use of indices with numeric affinities.</source>
          <target state="translated">숫자 친화도가있는 인덱스를 사용하도록 IN 연산자 처리를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="38025365863e59085f7f2a503fa8e731d8d8f915" translate="yes" xml:space="preserve">
          <source>Enhance sqlite3_set_authorizer() to provide notification of calls to SQL functions.</source>
          <target state="translated">SQL 함수에 대한 호출 알림을 제공하도록 sqlite3_set_authorizer ()를 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="4c0c2336da07f0e2529ec9f7395eaa4d63613663" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;.lint fkey-indexes&quot; command so that it works with &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 과 함께 작동하도록 &quot;.lint fkey-indexes&quot;명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="f112cd8de55589eb0d44900a6dc12bd6545e1a14" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;&lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt;&quot; command to show the schema of all attached databases.</source>
          <target state="translated">&quot; &lt;a href=&quot;cli#dschema&quot;&gt;.schema&lt;/a&gt; &quot;명령을 향상시켜 연결된 모든 데이터베이스의 스키마를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1450749989600a2169e792f923ae3be06e80b2a3" translate="yes" xml:space="preserve">
          <source>Enhance the &quot;deserialize&quot; command of the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; to give it new &quot;--maxsize N&quot; and &quot;--readonly BOOLEAN&quot; options.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 의 &quot;직렬화 해제&quot;명령을 강화하여 새로운 &quot;--maxsize N&quot;및 &quot;--readonly BOOLEAN&quot;옵션을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e9d52f4b3f406b97743f08bc0e546085a24804d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; interface so that it can be used to determine if SQLITE_DONE has been seen on the prepared statement.</source>
          <target state="translated">&lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; 인터페이스를 개선하여 준비된 명령문에서 SQLITE_DONE이 있는지 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c405bef651c9af2e88b5ab4ee422e433b81082a5" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of interfaces and the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL function&lt;/a&gt; to put comma separators at the thousands marks for integers, if the &quot;,&quot; format modifier is used in between the &quot;%&quot; and the &quot;d&quot; (example: &quot;%,d&quot;).</source>
          <target state="translated">&quot;%&quot;와 &quot;d&quot;사이에 &quot;,&quot;형식 수정자가 사용되는 경우 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 인터페이스 인터페이스 및 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf SQL 함수&lt;/a&gt; 를 개선하여 정수에 대한 수천 개의 표시에 쉼표 구분 기호를 배치하십시오 (예 : &quot;%, 디&quot;).</target>
        </trans-unit>
        <trans-unit id="ecc927d861dbadc6775d2c50454d6230fe66defe" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; mechanism so that nested SQL statements such as might be generated by virtual tables are shown but are shown in comments and without parameter expansion. This greatly improves tracing output when using the FTS3/4 and/or RTREE virtual tables.</source>
          <target state="translated">가상 테이블에 의해 생성 될 수있는 중첩 SQL 문이 표시되지만 주석과 매개 변수 확장없이 표시되도록 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 메커니즘을 향상 시키십시오 . 이는 FTS3 / 4 및 / 또는 RTREE 가상 테이블을 사용할 때 추적 출력을 크게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="cea177cb2c536b15d2be8672b409ec45ad8edd94" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that a non-zero argument to the &quot;.exit&quot; command causes the shell to exit immediately without cleanly shutting down the database connection.</source>
          <target state="translated">&quot;.exit&quot;명령에 대한 0이 아닌 인수로 인해 데이터베이스 연결을 완전히 종료하지 않고 쉘이 즉시 종료되도록 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘을&lt;/a&gt; 향상 시키 십시오.</target>
        </trans-unit>
        <trans-unit id="772c4e5a177463139498eb947b87f718df183bb0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; option so that it works in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; as long as the pages being read are not in the WAL file.</source>
          <target state="translated">읽고있는 페이지가 WAL 파일에없는 한 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 작동하도록 &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 옵션을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="a2b293874fb33d8df6143b9bdce0ba562527728b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option so that it works for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대해 작동하도록 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 타임 옵션을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="5fc1b69a4cc0c897120d80264056737d7bc2f24c" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; virtual table so that it can be a TEMP table.</source>
          <target state="translated">TEMP 테이블이 될 수 있도록 &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="cbfa3ac4fe2276010370af97ef50f174cd9f6489" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; query syntax so that &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filters&lt;/a&gt; may be applied to arbitrary expressions.</source>
          <target state="translated">&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;열 필터&lt;/a&gt; 가 임의의 표현식에 적용될 수 있도록 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 쿼리 구문을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac4e55168d2c25c1939a1629c34937f2515a40d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; virtual table to handle &quot;ORDER BY term&quot; efficiently.</source>
          <target state="translated">&quot;ORDER BY term&quot;을 효율적으로 처리 하도록 &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8e95c6938845927220cf396e7f0c74146b449c86" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;json1#jex&quot;&gt;json_extract()&lt;/a&gt; function to cache and reuse parses of JSON input text.</source>
          <target state="translated">&lt;a href=&quot;json1#jex&quot;&gt;json_extract ()&lt;/a&gt; 함수를 향상시켜 JSON 입력 텍스트의 구문 분석을 캐시하고 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0da54e01b930ee69209e9bd5617e79e614dba785" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to support the name of an index as its argument, in order to analyze just that one index.</source>
          <target state="translated">하나의 인덱스 만 분석하려면 인덱스 이름을 인수로 지원 하도록 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d919d17746299ff0de59c9893d2b29b08bd6e5c1" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command to support the IF NOT EXISTS clause.</source>
          <target state="translated">IF NOT EXISTS 절을 지원 하도록 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4351170db4e47371fac160f7e790286a7669ec9d" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that the 'unixepoch' modifier works for the full span of supported dates.</source>
          <target state="translated">'unixepoch'수정자가 지원되는 모든 날짜 범위에서 작동하도록 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 기능을&lt;/a&gt; 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="98c955efd33e3f668b175fbbc0bf42eb02234928" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc' modifier&lt;/a&gt; in the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; so that it is a no-op if the date/time is known to already be in UTC. (This is not a compatibility break since the behavior has long been documented as &quot;undefined&quot; in that case.)</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간&lt;/a&gt; 이 이미 UTC로 알려진 경우 날짜 및 시간 함수 에서 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;'utc'수정자를&lt;/a&gt; 향상 시키지 마십시오. (이 경우 동작이 오랫동안 &quot;정의되지 않음&quot;으로 문서화 되었기 때문에 호환성 문제가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="ba8fa245aa7effdf69df893d75d48b052b4da271" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; syntax to allow multiple rows to be inserted via the VALUES clause.</source>
          <target state="translated">VALUES 절을 통해 여러 행을 삽입 할 수 있도록 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 구문을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="39f00e6685deaa75aceff3c6d176c2d609bfced0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command so that pending queries are allowed to continue as long as the schema is unchanged. Formerly, a ROLLBACK would cause all pending queries to fail with an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. That error is still returned if the ROLLBACK modifies the schema.</source>
          <target state="translated">스키마가 변경되지 않는 한 보류중인 쿼리를 계속 사용할 수 있도록 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령을 향상 시키십시오 . 이전에는 ROLLBACK으로 인해 보류중인 모든 쿼리가 &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; 오류 와 함께 실패했습니다 . ROLLBACK이 스키마를 수정하면 해당 오류가 계속 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ae47128c1a762921f457e8e1bfe678e897d057" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it can store the parser object as a stack variable rather than allocating space from the heap and make use of that enhancement in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기를&lt;/a&gt; 향상시켜 파서 객체를 힙에서 공간을 할당하는 대신 스택 변수로 저장할 수 있고 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 에서 그 기능을 활용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0f666e6813fb5c4fe717347ffd40771c1d7b80b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; mechanism to be more flexible (while still maintaining backwards compatibility) in two ways:</source>
          <target state="translated">다음 과 같은 두 가지 방법으로 &lt;a href=&quot;loadext&quot;&gt;확장 로딩&lt;/a&gt; 메커니즘을보다 유연하게 (여전히 호환성을 유지하면서) 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="abd36cf21afd6f7d8bfb48fcbea3c10187ce565b" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that it is able to flatten views on the right-hand side of a LEFT JOIN.</source>
          <target state="translated">왼쪽 결합의 오른쪽에서보기를 병합 할 수 있도록 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화를&lt;/a&gt; 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="897318b35a6a9404b9601809620b672a31ea4c74" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works for arbitrary expressions on the left-hand side as long as the LIKE pattern on the right-hand side does not begin with a digit or minus sign.</source>
          <target state="translated">오른쪽의 LIKE 패턴이 숫자 또는 빼기 부호로 시작하지 않는 한 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화가&lt;/a&gt; 향상되어 왼쪽에서 임의의 표현식에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48de942fdbd65dcbd99636658f1be1df7651f0d2" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan&lt;/a&gt; optimization so that it is able to skip index terms that occur in the middle of the index, not just as the left-hand side of the index.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔&lt;/a&gt; 최적화를 향상시켜 인덱스의 왼쪽뿐만 아니라 인덱스의 중간에서 발생하는 인덱스 용어를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2a8ec267addf3f625f62574683688a31353a8e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt; statement to accept a 32-bit integer parameter which is the threshold below which cache spilling is prohibited.</source>
          <target state="translated">캐시 유출이 금지되는 임계 값 이하인 32 비트 정수 매개 변수를 승인 하도록 &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;PRAGMA cache_spill&lt;/a&gt; 문을 향상 시키 십시오.</target>
        </trans-unit>
        <trans-unit id="a7925d1322092ec92042d18a4d3bf644989f4dd6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command for improved detection of problems on the page freelist.</source>
          <target state="translated">의 Enhance &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA의 integrity_check의&lt;/a&gt; 페이지 가능리스트에 문제의 개선 검출 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="219b1962c9f3fd940e59a7c4455cdb5d4fd58474" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to use much less memory when processing multi-gigabyte databases.</source>
          <target state="translated">멀티 기가 바이트 데이터베이스를 처리 할 때 훨씬 적은 메모리를 사용 하도록 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="8df03990bad246d4ae7e8d5ff6f0df49f2131cd4" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; command so that the &quot;pk&quot; column is an increasing integer to show the order of columns in the primary key.</source>
          <target state="translated">&quot;pk&quot;열이 기본 키의 열 순서를 표시하기 위해 증가하는 정수가되도록 &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; 명령을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="467321e371cfce36156fc492790ccfffef995b05" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension to support &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;식에서 인덱스&lt;/a&gt; 를 지원 하도록 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="231b7b233c891814a3929090a78107d20ccb49c0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; interface so that it is hardened against attacks from deliberately corrupted &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 인터페이스를 향상시켜 의도적으로 손상된 &lt;a href=&quot;sessionintro#changeset&quot;&gt;변경 세트&lt;/a&gt; 객체의 공격에 대비하여 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d859c94c8aab395c8d624a4d2e4d798aac099e" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt; to support &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 을 지원 하도록 &lt;a href=&quot;sessionintro&quot;&gt;세션 확장&lt;/a&gt; 을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="8752b22acf88cad45a773b2eaf772abcc4d468b3" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension so that the edit distance cost table can be changed at runtime by inserting a string like 'edit_cost_table=TABLE' into the &quot;command&quot; field.</source>
          <target state="translated">&quot;command_&quot;필드에 'edit_cost_table = TABLE'과 같은 문자열을 삽입하여 런타임에 편집 거리 비용 테이블을 변경할 수 있도록 &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="8b13a66a5bb583f4d677f5f0eca1ac21ccbb9fa6" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절 을 지원 하도록 &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장을 강화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9847e0191d05131d0f627947fd7ce04c0efa7b0" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; virtual table so that it can search efficiently by rowid.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;rowfix로&lt;/a&gt; 효율적으로 검색 할 수 있도록 spellfix1 가상 테이블을 향상 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="2aab8554cf986b2fcf65f02990aae7c32a2d4293" translate="yes" xml:space="preserve">
          <source>Enhance the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program so that it shows the number of bytes of metadata on btree pages.</source>
          <target state="translated">btree 페이지에서 메타 데이터의 바이트 수를 표시하도록 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램을 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="9c1a0bc76cd9728f28938754bb61c49141b278e1" translate="yes" xml:space="preserve">
          <source>Enhance the Windows OS layer to provide detailed error codes</source>
          <target state="translated">자세한 오류 코드를 제공하도록 Windows OS 계층 향상</target>
        </trans-unit>
        <trans-unit id="28df058400861b985faef942373bae5431c24f4a" translate="yes" xml:space="preserve">
          <source>Enhance the page cache so that it can preallocate a block of memory to use for the initial set page cache lines. Set the default preallocation to 100 pages. Yields about a 5% performance increase on common workloads.</source>
          <target state="translated">초기 설정 페이지 캐시 라인에 사용할 메모리 블록을 사전 할당 할 수 있도록 페이지 캐시를 향상 시키십시오. 기본 사전 할당을 100 페이지로 설정하십시오. 일반 워크로드에서 약 5 %의 성능 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f43e9f09e30e90da585a7e2f997499c318811db5" translate="yes" xml:space="preserve">
          <source>Enhance the presentation concept beyond the simple linear sequence of slides to allow for side-tracks and excursions to be taken depending on how the audience is responding.</source>
          <target state="translated">간단한 선형 선형 슬라이드 시퀀스를 넘어서 프레젠테이션 개념을 향상시켜 청중의 반응에 따라 사이드 트랙 및 여행을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0cc6e91ac3090a90fc5fc0536b586ecd051561" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer so that ORDER BY clauses are more aggressively optimized, especially in joins where various terms of the ORDER BY clause come from separate tables of the join.</source>
          <target state="translated">ORDER BY 절의 다양한 용어가 별도의 조인 테이블에서 나오는 조인에서 ORDER BY 절이보다 적극적으로 최적화되도록 쿼리 최적화 프로그램을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="cb820f0118ef79630d408199d7422e6f8fb9737c" translate="yes" xml:space="preserve">
          <source>Enhance the query optimizer to exploit transitive join constraints.</source>
          <target state="translated">전 이적 조인 제약 조건을 활용하도록 쿼리 최적화 프로그램을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="e627de0a427baf27ab64042414ff38a649039427" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it always prefers an index that uses a superset of WHERE clause terms relative to some other index.</source>
          <target state="translated">쿼리 플래너가 다른 인덱스와 비교하여 WHERE 절 용어의 상위 세트를 사용하는 인덱스를 항상 선호하도록 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="d0052283e64299690870842cb9d496fab1611f5c" translate="yes" xml:space="preserve">
          <source>Enhance the query planner so that it will try to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; on queries that make use of &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt;.</source>
          <target state="translated">쿼리 플래너를 향상시켜 쿼리를 사용 &lt;a href=&quot;optoverview#or_opt&quot;&gt;하거나 최적화&lt;/a&gt; 하는 쿼리에 적용 &lt;a href=&quot;queryplanner#covidx&quot;&gt;인덱스&lt;/a&gt; 를 사용하도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1d5782317135d4e9e1b715596bb2a96d2101b89" translate="yes" xml:space="preserve">
          <source>Enhance the query planner to permit &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; on FROM-clause subqueries that are implemented by co-routine.</source>
          <target state="translated">동시 루틴으로 구현되는 FROM- 절 서브 쿼리에서 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인 작성&lt;/a&gt; 을 허용하도록 쿼리 플래너를 향상 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="40575878eee4f99d3db668f19cca94585d78c781" translate="yes" xml:space="preserve">
          <source>Enhance the query plans for joins to detect empty tables early and halt without doing unnecessary work.</source>
          <target state="translated">빈 테이블을 조기에 감지하고 불필요한 작업을 수행하지 않고 중지하도록 조인 쿼리 계획을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e270b8357535bbb251d02aee12541124f9d7c3b" translate="yes" xml:space="preserve">
          <source>Enhance virtual tables so that they can potentially use an index when the WHERE clause contains the IN operator.</source>
          <target state="translated">WHERE 절에 IN 연산자가 포함 된 경우 인덱스를 사용할 수 있도록 가상 테이블을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="64b37213a97e0883e534b3385cdb0e0b6f843807" translate="yes" xml:space="preserve">
          <source>Enhanced &quot;WHERE x NOT NULL&quot; &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; so that they are usable if the &quot;x&quot; column appears in a LIKE or GLOB operator.</source>
          <target state="translated">&quot;x&quot;열이 LIKE 또는 GLOB 연산자에 나타나는 경우 사용할 수 있도록 &quot;WHERE x NOT NULL&quot; &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="a53735f6ffe5602297bc4654161d4607e891ee5a" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; so that it interrupts &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations that are in process.</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()를&lt;/a&gt; 향상 시켜 처리중인 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 작업을 중단 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d9ce2a6349e3a16f7d2da3b2d327d63134ac2a74" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; so that it works for read-only databases.</source>
          <target state="translated">읽기 전용 데이터베이스에서 작동하도록 &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO가&lt;/a&gt; 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="d58eb320cd88342fcb6b05fb5333e1bcd0a48413" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to detect obscure row corruption that they were formerly missing. Also update both pragmas so that they return error text rather than SQLITE_CORRUPT when encountering corruption in &lt;a href=&quot;fileformat2#record_format&quot;&gt;records&lt;/a&gt;.</source>
          <target state="translated">향상된 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check을&lt;/a&gt; 그들이 이전에 없어진 것을 모호한 행 손상을 감지 할 수 있습니다. 또한 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드&lt;/a&gt; 가 손상 될 때 SQLITE_CORRUPT 대신 오류 텍스트를 반환하도록 두 pragma를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="02e341c795f6d9f53e59131ad36a699c4ff420f9" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; so that it works efficiently with transactions that are larger than the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;.</source>
          <target state="translated">강화 된 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 는보다 큰 거래를 효율적으로 작동하도록 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="938e043ef3afc8ac9c960dfd817d79b316b06aa6" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;:</source>
          <target state="translated">향상된 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7660b18630bc2b632af83f376ef82bda6bdc2e58" translate="yes" xml:space="preserve">
          <source>Enhanced Query Syntax Precedence</source>
          <target state="translated">향상된 쿼리 구문 우선 순위</target>
        </trans-unit>
        <trans-unit id="8bcd37976631ed421f835c87d3d23437e964c0a6" translate="yes" xml:space="preserve">
          <source>Enhanced output from EXPLAIN QUERY PLAN</source>
          <target state="translated">EXPLAIN QUERY PLAN의 향상된 출력</target>
        </trans-unit>
        <trans-unit id="1c6f13fb6731d5f1314775333c356324516fd9b6" translate="yes" xml:space="preserve">
          <source>Enhanced query syntax</source>
          <target state="translated">향상된 쿼리 구문</target>
        </trans-unit>
        <trans-unit id="dc0f782772ac6cdd040a571e5d1cd41d9b2afc70" translate="yes" xml:space="preserve">
          <source>Enhanced robustness against corrupt database files</source>
          <target state="translated">손상된 데이터베이스 파일에 대한 향상된 견고성</target>
        </trans-unit>
        <trans-unit id="9e2446878f5c7a8d27e1c2936004a6080d4f4b4a" translate="yes" xml:space="preserve">
          <source>Enhanced support for QNX.</source>
          <target state="translated">QNX에 대한 향상된 지원.</target>
        </trans-unit>
        <trans-unit id="0223b7b5ad2a577e9f0cf5bf1f244664a462bf07" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.explain&quot; output formatting of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that loops are indented to better show the structure of the program.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 &quot;.explain&quot;출력 형식이 향상되어 프로그램 구조를보다 잘 보여주기 위해 루프가 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="94edddbbf9619d5825cd24602cf6d956452cf785" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.stats&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to show more information about I/O performance obtained from /proc, when available.</source>
          <target state="translated">사용 가능한 경우 / proc에서 얻은 I / O 성능에 대한 자세한 정보를 표시 하도록 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 &quot;.stats&quot;명령이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="2aa8aa5b2dc44e64f3c9062e559b9b8c4adaf741" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;.timer&quot; feature of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it shows wall-clock time in addition to system and user times.</source>
          <target state="translated">시스템 및 사용자 시간과 함께 벽시계 시간을 표시하도록 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 &quot;.timer&quot;기능이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9eedfea42ccb52b08d5d71e48835b1549173842" translate="yes" xml:space="preserve">
          <source>Enhanced the &quot;PRAGMA integrity_check&quot; command to verify indices.</source>
          <target state="translated">색인을 확인하기 위해 &quot;PRAGMA integrity_check&quot;명령이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb3be9ff58724d11d359ec60b1f2bdd37d420981" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; so that it accepts the last row of input if the final new-line character is missing.</source>
          <target state="translated">최종 개행 문자가 누락 된 경우 마지막 입력 행을 허용하도록 &lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블을&lt;/a&gt; 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="03045a32dbdfe87bdfc9bebef5d2e3a25bb91ada" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; so that it can be used as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; where the argument is the schema to be analyzed.</source>
          <target state="translated">인수가 분석 할 스키마 인 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 로 사용할 수 있도록 &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블을&lt;/a&gt; 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="ad6a5655675e95781c7a9176042eb4c49edd8c22" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; matching algorithm to be faster for cases when the pattern contains multiple wildcards.</source>
          <target state="translated">향상된 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 패턴이 여러 와일드 카드가 포함 된 경우 매칭 알고리즘은 빠른 경우에 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9c97dd68b6c9f22cde01203cef9708636a363e9d" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; so that it is able to use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; as part of the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 플래닝의&lt;/a&gt; 일부로 &lt;a href=&quot;queryplanner#covidx&quot;&gt;포함 인덱스&lt;/a&gt; 를 사용할 수 있도록 &lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너가&lt;/a&gt; 향상 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="256c4a1bf22f495e02d25767299c762ded55fdd3" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; so that it works with an &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; 절 과 함께 작동하도록 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화가&lt;/a&gt; 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bde313d13aaa9fdf420067e179b8337b3404aa95" translate="yes" xml:space="preserve">
          <source>Enhanced the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; command to detect &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violations.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 명령이 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 제약 조건 위반 을 감지하도록 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7c51abaf51ff7f2df08f11da95255ddde7c74fef" translate="yes" xml:space="preserve">
          <source>Enhanced the comments that are inserted into &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 컴파일 타임 옵션이 활성화 될 때 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력에 삽입되는 주석이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="dff3454f906eefe264d191aaa218dcd2cf753166" translate="yes" xml:space="preserve">
          <source>Enhanced the default memory allocator to make use of _msize() on windows, malloc_size() on Mac, and malloc_usable_size() on Linux.</source>
          <target state="translated">Windows의 _msize (), Mac의 malloc_size () 및 Linux의 malloc_usable_size ()를 사용하도록 기본 메모리 할당자를 향상 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="8dccfbae6b585eff24791000050934f841f040bd" translate="yes" xml:space="preserve">
          <source>Enhanced the internal text-to-numeric conversion routines so that they work with UTF8 or UTF16, thereby avoiding some UTF16-to-UTF8 text conversions.</source>
          <target state="translated">내부 텍스트를 숫자로 변환하는 루틴을 향상시켜 UTF8 또는 UTF16에서 작동하므로 UTF16에서 UTFF8 로의 텍스트 변환을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6609f817a6cdf7acf014351660bd59875dbce83c" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; are able to make use of OR and IN operators in the WHERE clause.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 이 WHERE 절에서 OR 및 IN 연산자를 사용할 수 있도록 쿼리 최적화 프로그램이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8bc09d2f6561ee38b5b8b664bf1d3480673895a" translate="yes" xml:space="preserve">
          <source>Enhanced the query optimizer so that it is able to use multiple indices to efficiently process &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR-connected constraints&lt;/a&gt; in a WHERE clause.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 연결 제약 조건&lt;/a&gt; 을 효율적으로 처리하기 위해 여러 인덱스를 사용할 수 있도록 쿼리 최적화 프로그램이 향상 되었습니다.</target>
        </trans-unit>
        <trans-unit id="cbc1ad5cd7bef1c364230feb92b6f22c6fc43de9" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner flattening logic to allow UNION ALL compounds to be promoted upwards to replace a simple wrapper SELECT even if the compounds are joins.</source>
          <target state="translated">쿼리 플래너 병합 논리를 향상시켜 화합물이 결합 된 경우에도 UNION ALL 화합물을 위로 올리면 간단한 래퍼 SELECT를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4282b314fce027a8694a86f4759e991c3a4226cf" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that it can factor terms in and out of OR expressions in the WHERE clause in an effort to find better indices.</source>
          <target state="translated">더 나은 색인을 찾기 위해 WHERE 절에서 OR 표현식의 내부 및 외부로 용어를 인수 분해 할 수 있도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="c87a7d0685fbf2f5e8470e67e88964a89110390d" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner so that the xfer optimization can be used with INTEGER PRIMARY KEY ON CONFLICT as long as the destination table is initially empty.</source>
          <target state="translated">대상 테이블이 초기에 비어있는 한 INTEGER PRIMARY KEY ON CONFLICT와 함께 xfer 최적화를 사용할 수 있도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="930e0780c36ad4d8952bea14bbd67981a9f86931" translate="yes" xml:space="preserve">
          <source>Enhanced the query planner to support index queries with range constraints on the rowid.</source>
          <target state="translated">rowid에 범위 제한이있는 인덱스 쿼리를 지원하도록 쿼리 플래너가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6066357831db7e4ebf2e25439868067d246d8025" translate="yes" xml:space="preserve">
          <source>Enhanced the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; so that all system calls can be overridden using the xSetSystemCall interface.</source>
          <target state="translated">xSetSystemCall 인터페이스를 사용하여 모든 시스템 호출을 무시할 수 있도록 Windows &lt;a href=&quot;vfs&quot;&gt;VFS를&lt;/a&gt; 향상 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="cb3a978152b2c95d938f4ec5dfecdfd4dc03a088" translate="yes" xml:space="preserve">
          <source>Enhanced triggers so that they can use &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that exist in schemas other than the schema where the trigger is defined.</source>
          <target state="translated">트리거가 정의 된 스키마 이외의 스키마에 존재 하는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 를 사용할 수 있도록 향상된 트리거</target>
        </trans-unit>
        <trans-unit id="297f948f999cfb4c21e3fe30f5e217f38826c758" translate="yes" xml:space="preserve">
          <source>Enhancements the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f946c53a255ba7d27e70b7ff3738d27f161850fa" translate="yes" xml:space="preserve">
          <source>Enhancements the command-line shell:</source>
          <target state="translated">명령 행 쉘을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="e09172df6aacada6ccbcf1a3a11e6a3c3af4636e" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;QUERY PLAN 설명&lt;/a&gt; 개선 .</target>
        </trans-unit>
        <trans-unit id="db4d9e44ef71d40ff1e7e4dbe80b15d3513543b3" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;, so that it generates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 기능이 향상되어 더 빠른 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ef9855917607b6442c695951a3f7754c39d33b47" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; so that they can optionally check just a single attached database instead of all attached databases.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 기능이 향상되어 연결된 모든 데이터베이스 대신 연결된 단일 데이터베이스 만 선택적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e60f213182ea7cd574f070de9a038e0287e1d3a" translate="yes" xml:space="preserve">
          <source>Enhancements to &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; processing that ensure that at least one valid read-mark is available at all times, so that read-only processes can always read the database.</source>
          <target state="translated">읽기 전용 프로세스가 항상 데이터베이스를 읽을 수 있도록 하나 이상의 유효한 읽기 표시를 항상 사용할 수 있도록하는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 처리 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="088c949064c93e6690dd186376b133008579ec58" translate="yes" xml:space="preserve">
          <source>Enhancements to FTS4:</source>
          <target state="translated">FTS4의 향상된 기능 :</target>
        </trans-unit>
        <trans-unit id="4b227272818268b73b926c2192e43b3603222a58" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interface:</source>
          <target state="translated">&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 인터페이스 의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="b9dd3ac79af68e2372047ab33b4b26d154857e4a" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, mostly to support testing and debugging of the SQLite library itself:</source>
          <target state="translated">주로 SQLite 라이브러리 자체의 테스트 및 디버깅을 지원 하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="fa6f25098613c466df6cb1b3c3e2f32bf515195d" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="9316eb92f3fb8393c8d086dc09173f0ba01a3c1c" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="a5c7ab4a0f809431a8ff58a35ffa041e958442f1" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;geopoly&quot;&gt;geopoly&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;geopoly&quot;&gt;지오 폴리&lt;/a&gt; 확장 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="e5b6cb44cb4a567950e71ad422f75b3ca4e22c90" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that it creates a smaller and faster SQL parser.</source>
          <target state="translated">더 작고 빠른 SQL 파서를 &lt;a href=&quot;lemon&quot;&gt;생성&lt;/a&gt; 하도록 레몬 파서 생성기의 기능 향상</target>
        </trans-unit>
        <trans-unit id="15944ac14355213e9f3cb2cebd5dc54b91adbbac" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; for cases when the left-hand side column has numeric affinity.</source>
          <target state="translated">왼쪽 열에 숫자 선호도가있는 경우 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화&lt;/a&gt; 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="adcb27ea2162302878492824ccdd337602297736" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 확장 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="08a98f05f116677a58ecae89a193381dca3467a0" translate="yes" xml:space="preserve">
          <source>Enhancements to the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 향상 :</target>
        </trans-unit>
        <trans-unit id="edf69de137296726150f431f3016d8e1e1082416" translate="yes" xml:space="preserve">
          <source>Enhancements to the query planner:</source>
          <target state="translated">쿼리 플래너의 개선 사항 :</target>
        </trans-unit>
        <trans-unit id="887cd62dcf1fd561060a7f3820e302dbe0e7e1de" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program to provide size information separately for each individual index of a table, in addition to the aggregate size.</source>
          <target state="translated">sqlite3_analyzer 유틸리티 프로그램이 향상되어 집계 크기 외에 테이블의 각 개별 인덱스에 대해 크기 정보를 별도로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d0b79f3e5d56b3b3ee7240cd85a024ed61c576ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the sqlite3_analyzer utility program, including the --pageinfo and --stats options and support for multiplexed databases.</source>
          <target state="translated">--pageinfo 및 --stats 옵션 및 다중화 된 데이터베이스 지원을 포함하여 sqlite3_analyzer 유틸리티 프로그램의 개선 사항.</target>
        </trans-unit>
        <trans-unit id="37973a2aab5304ee633b9d20aeca0be76434d6ed" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c extension to support stdio-like interfaces with quotas.</source>
          <target state="translated">할당량으로 stdio 같은 인터페이스를 지원하도록 test_quota.c 확장 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="a1ba10f45054081b97f16d5bc6e667a78fce6d45" translate="yes" xml:space="preserve">
          <source>Enhancements to the test_quota.c module so that it can track preexisting files.</source>
          <target state="translated">기존 파일을 추적 할 수 있도록 test_quota.c 모듈이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="071262c4e43816b952c8af7674854fa203027685" translate="yes" xml:space="preserve">
          <source>Ensure durability following a power loss with &quot;PRAGMA journal_mode=TRUNCATE&quot; by calling fsync() right after truncating the journal file.</source>
          <target state="translated">저널 파일을 자른 직후 fsync ()를 호출하여 &quot;PRAGMA journal_mode = TRUNCATE&quot;로 전원 손실에 따른 내구성을 보장하십시오.</target>
        </trans-unit>
        <trans-unit id="763267566a8b7c92a18ab7a9852c919207037954" translate="yes" xml:space="preserve">
          <source>Ensure that ALTER TABLE modifies table and column names embedded in WITH clauses that are part of views and triggers.</source>
          <target state="translated">ALTER TABLE이 뷰 및 트리거의 일부인 WITH 절에 포함 된 테이블 및 컬럼 이름을 수정하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6f4e25c9d19972ec4e16af218b9ac640575e4282" translate="yes" xml:space="preserve">
          <source>Ensure that floating point values are preserved exactly when reconstructing a database from the output of the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 &quot;.dump&quot;명령 출력에서 ​​데이터베이스를 재구성 할 때 부동 소수점 값이 정확하게 유지되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f3d6acbe6809d0d4b5ba59e3106dfa722b6856" translate="yes" xml:space="preserve">
          <source>Ensure that indexed expressions with collating sequences are handled correctly. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5&lt;/a&gt;.</source>
          <target state="translated">조합 순서가있는 색인화 된 표현식이 올바르게 처리되는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/eb703ba7b50c1a5&quot;&gt;eb703ba7b50c1a5에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="320fb77964ce8dd238dcf51a0d55555931872f7c" translate="yes" xml:space="preserve">
          <source>Ensure that prepared statements automatically reset on extended error codes of SQLITE_BUSY and SQLITE_LOCKED even when compiled using &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;.</source>
          <target state="translated">SQLITE_OMIT_AUTORESET을 사용하여 컴파일 된 경우에도 준비된 명령문이 SQLITE_BUSY 및 SQLITE_LOCKED의 확장 오류 코드에서 자동으로 재설정 &lt;a href=&quot;compile#omit_autoreset&quot;&gt;되는지 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73ff9e87e31a6b30accfec1ac5b07289b8ed1a4a" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; counters in the sqlite_sequence table are initialized doing &quot;Xfer Optimization&quot; on &quot;INSERT ... SELECT&quot; statements. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c&lt;/a&gt;.</source>
          <target state="translated">sqlite_sequence 테이블 의 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 카운터가 &quot;INSERT ... SELECT&quot;문에서 &quot;Xfer Optimization&quot;을 수행하여 초기화 되었는지 확인하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7b3328086a5c116c&quot;&gt;7b3328086a5c116c에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="1edcdd81c8138145ea48433a6dac68321ba6e0c9" translate="yes" xml:space="preserve">
          <source>Ensure that the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface can correctly handle short rows. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스가 짧은 행을 올바르게 처리 할 수 있는지 확인하십시오 . &lt;a href=&quot;https://www.sqlite.org/src/info/e6e962d6b0f06f46e&quot;&gt;e6e962d6b0f06f46e&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="f2b0dfe3853d12157319b6b0f40a3e7dfe9eef04" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner knows that any column of a &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; LEFT JOIN can be NULL even if that column is labeled with &quot;NOT NULL&quot;. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;.</source>
          <target state="translated">열에 &quot;NOT NULL&quot;로 레이블이 지정되어 있어도 &lt;a href=&quot;optoverview#flattening&quot;&gt;플랫 화 된&lt;/a&gt; LEFT JOIN의 열이 NULL 일 수 있다는 것을 쿼리 플래너가 알고 있는지 확인하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="4d45306d706d54fdd9fd4abd095a83e5c593f770" translate="yes" xml:space="preserve">
          <source>Ensure that the query planner never tries to use a self-made transient index in place of a schema-defined index.</source>
          <target state="translated">쿼리 플래너가 스키마 정의 인덱스 대신 자체 만든 임시 인덱스를 사용하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="c4719004d8e5511993396b7647b091764d35ec35" translate="yes" xml:space="preserve">
          <source>Ensuring that</source>
          <target state="translated">그것을 보장</target>
        </trans-unit>
        <trans-unit id="8b17ecadc249ae5820d4616f49592537cf85eaca" translate="yes" xml:space="preserve">
          <source>Enter SQL commands at the prompt to create and populate the new database.</source>
          <target state="translated">프롬프트에서 SQL 명령을 입력하여 새 데이터베이스를 작성하고 채우십시오.</target>
        </trans-unit>
        <trans-unit id="083f743b36c02cef28d51a51219ba95b2ec6026d" translate="yes" xml:space="preserve">
          <source>Enterprise-class client/server SQL database engines do not normally make this guarantee. In client/server SQL database engines, the server keeps track of statistics on the sizes of tables and on the quality of indexes and the query planner uses those statistics to help select the best plans. As content is added, deleted, or changed in the database, the statistics will evolve and may cause the query planner to begin using a different query plan for some particular query. Usually the new plan will be better for the evolving structure of the data. But sometimes the new query plan will cause a performance reduction. With a client/server database engine, there is typically a Database Administrator (DBA) on hand to deal with these rare problems as they come up. But DBAs are not available to fix problems in an embedded database like SQLite, and hence SQLite is careful to ensure that plans do not change unexpectedly after deployment.</source>
          <target state="translated">엔터프라이즈 급 클라이언트 / 서버 SQL 데이터베이스 엔진은 일반적으로이 보장을하지 않습니다. 클라이언트 / 서버 SQL 데이터베이스 엔진에서 서버는 테이블 크기 및 인덱스 품질에 대한 통계를 추적하며 쿼리 플래너는 이러한 통계를 사용하여 최상의 계획을 선택합니다. 데이터베이스에서 컨텐츠가 추가, 삭제 또는 변경되면 통계가 발전하여 쿼리 플래너가 특정 쿼리에 대해 다른 쿼리 계획을 사용하기 시작할 수 있습니다. 일반적으로 새로운 계획은 진화하는 데이터 구조에 적합합니다. 그러나 때때로 새로운 쿼리 계획으로 인해 성능이 저하 될 수 있습니다. 클라이언트 / 서버 데이터베이스 엔진을 사용하면 이러한 드문 문제가 발생할 때이를 처리하기 위해 일반적으로 데이터베이스 관리자 (DBA)가 있습니다. 그러나 DBA는 SQLite와 같은 임베디드 데이터베이스에서 문제를 해결하는 데 사용할 수 없습니다.따라서 SQLite는 배포 후 계획이 예기치 않게 변경되지 않도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="016d284bc7fd185fb86cbef4e6f410ad531ec41f" translate="yes" xml:space="preserve">
          <source>Entries may be added to a zip archive by inserting new rows. The easiest way to do this is to specify values for the &quot;name&quot; and &quot;data&quot; columns only and have zipfile fill in sensible defaults for other fields. To insert a directory into the archive, set the &quot;data&quot; column to NULL. For example, to add the directory &quot;dir1&quot; and the file &quot;m.txt&quot; containing the text &quot;abcdefghi&quot; to zip archive &quot;test.zip&quot;:</source>
          <target state="translated">새 행을 삽입하여 Zip 아카이브에 항목을 추가 할 수 있습니다. 가장 쉬운 방법은 &quot;name&quot;및 &quot;data&quot;열의 값만 지정하고 zipfile이 다른 필드의 기본 값을 채우도록하는 것입니다. 아카이브에 디렉토리를 삽입하려면 &quot;data&quot;열을 NULL로 설정하십시오. 예를 들어, &quot;dir1&quot;디렉토리와 &quot;abcdefghi&quot;텍스트를 포함하는 &quot;m.txt&quot;파일을 zip 아카이브 &quot;test.zip&quot;에 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e2f64a45118887196b8716103b9556bdce2656b8" translate="yes" xml:space="preserve">
          <source>Entries within a doclist are sorted by docid. Positions within a doclist entry are stored in ascending order.</source>
          <target state="translated">doclist 내의 항목은 docid별로 정렬됩니다. doclist 항목 내의 위치는 오름차순으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8bffcbc21c3bf69becb564637d592afa3a71b0f7" translate="yes" xml:space="preserve">
          <source>Eponymous virtual table</source>
          <target state="translated">시조 가상 테이블</target>
        </trans-unit>
        <trans-unit id="afcfba63ae8c7c116df2f46471e75a3359724931" translate="yes" xml:space="preserve">
          <source>Eq</source>
          <target state="translated">Eq</target>
        </trans-unit>
        <trans-unit id="4b4a2f957af622a456d578794d868743c5030e6f" translate="yes" xml:space="preserve">
          <source>Equivalent sqlite3.exe Command</source>
          <target state="translated">동등한 sqlite3.exe 명령</target>
        </trans-unit>
        <trans-unit id="c73f93f4b9a02f4e5a949fd11052e3a166c6f2ac" translate="yes" xml:space="preserve">
          <source>Error Codes And Messages</source>
          <target state="translated">오류 코드 및 메시지</target>
        </trans-unit>
        <trans-unit id="7fc353a0378a6af6e63cb4e746bbbbd0e56d46cc" translate="yes" xml:space="preserve">
          <source>Error Logging Interface</source>
          <target state="translated">오류 로깅 인터페이스</target>
        </trans-unit>
        <trans-unit id="e124b3535d5c4804fddcec1bfc75b893589b726b" translate="yes" xml:space="preserve">
          <source>Errors related to attempting to retrieve column values other than docid are runtime errors that occur within sqlite3_step(). In some cases, for example if the MATCH expression in a SELECT query matches zero rows, there may be no error at all even if a statement does refer to column values other than docid.</source>
          <target state="translated">docid 이외의 열 값 검색 시도와 관련된 오류는 sqlite3_step () 내에서 발생하는 런타임 오류입니다. 예를 들어 SELECT 쿼리의 MATCH식이 0 개의 행과 일치하는 경우 명령문이 docid 이외의 열 값을 참조하더라도 오류가 전혀 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2037e33c6466adf8969b72c11fda6491583b0bfa" translate="yes" xml:space="preserve">
          <source>Errors returned by &quot;close&quot; invocations are always ignored.</source>
          <target state="translated">&quot;close&quot;호출에 의해 리턴 된 오류는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba0ca62e050a94c881b9cbcdd137fb7152c40f3" translate="yes" xml:space="preserve">
          <source>Escape control characters in JSON strings. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt;.</source>
          <target state="translated">JSON 문자열에서 제어 문자를 이스케이프하십시오. &lt;a href=&quot;https://www.sqlite.org/src/info/ad2559db380abf8&quot;&gt;ad2559db380abf8&lt;/a&gt; 티켓 수정 .</target>
        </trans-unit>
        <trans-unit id="1cb7d33bba7989feceb4f470ecd1849be76ca550" translate="yes" xml:space="preserve">
          <source>Establish a shared lock on the database file using the SQLite API (i.e. the shell tool).</source>
          <target state="translated">SQLite API (즉, 셸 도구)를 사용하여 데이터베이스 파일에 공유 잠금을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acdfd966a90117b3a07f2283d0066679d289a192" translate="yes" xml:space="preserve">
          <source>Established a Git mirror of the offical SQLite source tree. The canonical sources for SQLite are maintained using the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; at &lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt;. The Git mirror can be seen at &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt;.</source>
          <target state="translated">공식 SQLite 소스 트리의 Git 미러를 설정했습니다. SQLite의 표준 소스 는 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;https://sqlite.org/src&lt;/a&gt; 의 &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; 를 사용하여 유지됩니다 . Git 미러는 &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;https://github.com/sqlite/sqlite&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfac7c251d7e73e29a463cec3912b52bd890b9a8" translate="yes" xml:space="preserve">
          <source>Estimate the number of rows in the table P1. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if that estimate is less than approximately 2**(0.1*P3).</source>
          <target state="translated">테이블 P1의 행 수를 추정하십시오. 추정치가 약 2 ** (0.1 * P3)보다 작 으면 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f07e6ba2d9a77c57620b0b92e2928b26dca79a5c" translate="yes" xml:space="preserve">
          <source>Estimate the sizes of table and index rows and use the smallest applicable B-Tree for full scans and &quot;count(*)&quot; operations.</source>
          <target state="translated">테이블 및 인덱스 행의 크기를 추정하고 전체 스캔 및 &quot;count (*)&quot;작업에 적용 가능한 가장 작은 B-Tree를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8465fee9c60fa18c66485376de57ad47eb492b1" translate="yes" xml:space="preserve">
          <source>Evaluate An SQL Statement</source>
          <target state="translated">SQL 문 평가</target>
        </trans-unit>
        <trans-unit id="494757b93d645c3ec03e2cb39c698d02501c9269" translate="yes" xml:space="preserve">
          <source>Evaluate WHERE clause constraints involving correlated subqueries last, in the hope that they never have be evaluated at all.</source>
          <target state="translated">상관 하위 쿼리가 포함 된 WHERE 절 제약 조건은 마지막으로 평가 된 적이 없기 때문에 마지막에 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="f5f8716393fff4c33fd231cf4a1b3dfd35e3ce79" translate="yes" xml:space="preserve">
          <source>Evaluate terms of the WHERE clause that only involve columns from the first table. If any term is false (meaning that the whole WHERE clause must be false) then skip the rest of this loop and continue to the next record.</source>
          <target state="translated">첫 번째 테이블의 열만 포함하는 WHERE 절의 용어를 평가하십시오. 용어가 거짓이면 (전체 WHERE 절이 거짓이어야 함을 의미)이 루프의 나머지 부분을 건너 뛰고 다음 레코드로 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="e98cbf4cf1877f0ce5b5cb8101d45d36a7f1c8d6" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; by calling &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; one or more times.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 한 번 이상 호출 하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 평가하십시오 .</target>
        </trans-unit>
        <trans-unit id="afc24d20b1189859f163127fa057eee2672ebd26" translate="yes" xml:space="preserve">
          <source>Even after the original data of a database page has been written into the journal file using calls to the journal file file-handle xWrite method (section</source>
          <target state="translated">저널 파일 file-handle xWrite 메소드에 대한 호출을 사용하여 데이터베이스 페이지의 원래 데이터가 저널 파일에 기록 된 후에도 (섹션</target>
        </trans-unit>
        <trans-unit id="5499799ae4809c21043cab7ce18584b7a12c2dc6" translate="yes" xml:space="preserve">
          <source>Even if an application or system failure does not occur while a</source>
          <target state="translated">응용 프로그램 또는 시스템 오류가 발생하지 않은 경우에도</target>
        </trans-unit>
        <trans-unit id="680fadd60094a533809d5b7446aadfd1591e54a1" translate="yes" xml:space="preserve">
          <source>Even if the application does not deliberately accept database files from untrusted sources, beware of attacks in which a local database file is surreptitiously altered to contain harmful content.</source>
          <target state="translated">응용 프로그램이 신뢰할 수없는 소스의 데이터베이스 파일을 고의로 받아들이지 않더라도 로컬 데이터베이스 파일이 유해한 내용을 포함하도록 명백하게 변경되는 공격에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="c9ba37d0d3bee815cbbaa36b0c20151324c7ee1f" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">이 함수가 0을 리턴하더라도 세션 핸들에서 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 을 호출 하면 변경 사항이없는 변경 세트를 계속 리턴 할 수 있습니다. 연결된 테이블의 행이 수정 된 후 나중에 원래 값이 복원 될 때 발생할 수 있습니다. 그러나이 함수가 0이 아닌 값을 반환하면 sqlite3session_changeset ()을 호출하면 변경 사항이 0이 아닌 변경 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50ed987259f75ac65d7652aac78952559c72c7f6" translate="yes" xml:space="preserve">
          <source>Even if this function returns zero, it is possible that calling &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; on the session handle may still return a changeset that contains no changes. This can happen when a row in an attached table is modified and then later on the original values are restored. However, if this function returns non-zero, then it is guaranteed that a call to sqlite3session_changeset() will return a changeset containing zero changes.</source>
          <target state="translated">이 함수가 0을 리턴하더라도 세션 핸들에서 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 을 호출 하면 변경 사항이없는 변경 세트를 계속 리턴 할 수 있습니다. 연결된 테이블의 행이 수정 된 후 나중에 원래 값이 복원 될 때 발생할 수 있습니다. 그러나이 함수가 0이 아닌 값을 반환하면 sqlite3session_changeset ()을 호출하면 변경 사항이 0이 아닌 변경 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="400a8e0a43afcabf1ad09a38d392479429277735" translate="yes" xml:space="preserve">
          <source>Even in the JOIN form, the query can be made clearer through the use of row values:</source>
          <target state="translated">JOIN 양식에서도 행 값을 사용하여 쿼리를보다 명확하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5632548c0bc2270c52cd3517d4c2d3312ffda6" translate="yes" xml:space="preserve">
          <source>Even though SQLite allows the datatype to be omitted, it is still a good idea to include it in your CREATE TABLE statements, since the data type often serves as a good hint to other programmers about what you intend to put in the column. And if you ever port your code to another database engine, that other engine will probably require a datatype of some kind. SQLite accepts all the usual datatypes. For example:</source>
          <target state="translated">SQLite에서 데이터 유형을 생략 할 수는 있지만 CREATE TABLE 문에 포함하는 것이 좋습니다. 데이터 유형은 종종 다른 프로그래머에게 열에 넣을 대상에 대한 좋은 힌트로 사용되기 때문입니다. 그리고 코드를 다른 데이터베이스 엔진으로 이식 한 경우 다른 엔진에 일종의 데이터 유형이 필요할 수 있습니다. SQLite는 모든 일반적인 데이터 유형을 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ba77bb0cea9f5158d237371e94228e6f6766570" translate="yes" xml:space="preserve">
          <source>Even though a disk file is allocated for each temporary database, in practice the temporary database usually resides in the in-memory pager cache and hence is very little difference between a pure in-memory database created by &quot;:memory:&quot; and a temporary database created by an empty filename. The sole difference is that a &quot;:memory:&quot; database must remain in memory at all times whereas parts of a temporary database might be flushed to disk if database becomes large or if SQLite comes under memory pressure.</source>
          <target state="translated">디스크 파일이 각 임시 데이터베이스에 할당 되더라도 실제로 임시 데이터베이스는 일반적으로 메모리 내 호출기 캐시에 상주하므로 &quot;: memory :&quot;에 의해 생성 된 순수한 메모리 내 데이터베이스와 임시 데이터베이스 간에는 거의 차이가 없습니다. 빈 파일 이름으로 생성됩니다. 유일한 차이점은 &quot;: memory :&quot;데이터베이스는 항상 메모리에 남아 있어야하지만 데이터베이스가 커지거나 SQLite가 메모리 부족 상태에있는 경우 임시 데이터베이스의 일부가 디스크로 플러시 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30543192e192dd4d27222f9a28b926a35b6f7b01" translate="yes" xml:space="preserve">
          <source>Even though it is possible to open a read-only WAL-mode database, it is good practice to converted to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=DELETE&lt;/a&gt; prior to burning an SQLite database image onto read-only media.</source>
          <target state="translated">읽기 전용 WAL 모드 데이터베이스를 열 수는 있지만 SQLite 데이터베이스 이미지를 읽기 전용 미디어에 굽기 전에 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = DELETE&lt;/a&gt; 로 변환하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0c6df707f631d9b02f87ed26337109bf5dac9246" translate="yes" xml:space="preserve">
          <source>Even though it may not be possible to attribute the row to a specific database table, it may be part of a tree structure within the database file. In this case, the root page number of that tree structure is stored in this column. Or, if the page the row was found on is not part of a tree structure, this column stores a copy of the value in column &quot;pgno&quot; - the page number of the page the row was found on. In many, although not all, cases, all rows in the lost_and_found table with the same value in this column belong to the same table.</source>
          <target state="translated">행을 특정 데이터베이스 테이블에 지정하지 못할 수도 있지만 데이터베이스 파일 내 트리 구조의 일부일 수 있습니다. 이 경우 해당 트리 구조의 루트 페이지 번호가이 열에 저장됩니다. 또는 행을 찾은 페이지가 트리 구조의 일부가 아닌 경우이 열은 &quot;pgno&quot;열에 값의 사본을 저장합니다 (행이 발견 된 페이지의 페이지 번호). 전부는 아니지만 많은 경우에이 열에서 같은 값을 가진 lost_and_found 테이블의 모든 행은 같은 테이블에 속합니다.</target>
        </trans-unit>
        <trans-unit id="1d9b26bf7bc27f4c82b4fef5ddd5b50d847ddf5d" translate="yes" xml:space="preserve">
          <source>Even though open-source users do not have direct access to TH3, all users of SQLite benefit from TH3 indirectly since each version of SQLite is validated running TH3 on multiple platforms (Linux, Windows, WinRT, Mac, OpenBSD) prior to release. So anyone using an official release of SQLite can deploy their application with the confidence of knowing that it has been tested using TH3. They simply cannot rerun those tests themselves without purchasing a TH3 license.</source>
          <target state="translated">오픈 소스 사용자는 TH3에 직접 액세스 할 수 없지만 SQLite의 모든 버전은 릴리스 전에 여러 플랫폼 (Linux, Windows, WinRT, Mac, OpenBSD)에서 TH3을 실행하는 것으로 검증되므로 모든 SQLite 사용자는 TH3을 간접적으로 활용할 수 있습니다. 따라서 공식 SQLite 릴리스를 사용하는 사람은 TH3을 사용하여 테스트되었음을 ​​알면서 자신의 응용 프로그램을 배포 할 수 있습니다. TH3 라이센스를 구매하지 않고서는 테스트를 스스로 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="022ac40cfda55e83a99de9e911e78bfc09ab9640" translate="yes" xml:space="preserve">
          <source>Even though sqlite_stat1 does not have a PRIMARY KEY, changes are recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes are recorded for rows for which (idx IS NULL) is true. However, for such rows a zero-length blob (SQL value X'') is stored in the changeset or patchset instead of a NULL value. This allows such changesets to be manipulated by legacy implementations of sqlite3changeset_invert(), concat() and similar.</source>
          <target state="translated">sqlite_stat1에 PRIMARY KEY가 없더라도 PRIMARY KEY가 (tbl, idx) 인 것처럼 변경 사항이 기록됩니다. 또한 (idx IS NULL)에 해당하는 행에 대한 변경 사항이 기록됩니다. 그러나 이러한 행의 경우 길이가 0 인 블롭 (SQL 값 X '')이 NULL 값 대신 변경 세트 또는 패치 세트에 저장됩니다. 이를 통해 sqlite3changeset_invert (), concat () 및 이와 유사한 레거시 구현을 통해 이러한 변경 세트를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9461afee379ce7062d22cecc827bf8826de4bdca" translate="yes" xml:space="preserve">
          <source>Even though the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; function only allows the caller to specify a single user-context pointer, an unlock-notify callback is passed an array of such context pointers. This is because if when a blocking connection concludes its transaction, if there is more than one unlock-notify registered to call the same C function, the context-pointers are marshaled into an array and a single callback issued. If each thread were assigned a priority, then instead of just signaling the threads in arbitrary order as this implementation does, higher priority threads could be signaled before lower priority threads.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 함수는 호출자가 단일 사용자 컨텍스트 포인터를 지정할 수 있도록 허용 하지만 잠금 해제 알림 콜백에는 이러한 컨텍스트 포인터의 배열이 전달됩니다. 이는 차단 연결이 트랜잭션을 완료 할 때 동일한 C 함수를 호출하도록 등록 된 하나 이상의 잠금 해제 알림이있는 경우 컨텍스트 포인터가 배열로 마샬링되고 단일 콜백이 발행되기 때문입니다. 각 스레드에 우선 순위가 할당 된 경우,이 구현에서와 같이 임의의 순서로 스레드에 신호를 보내는 대신 우선 순위가 높은 스레드보다 우선 순위가 높은 스레드에 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef242512e741cb13f0a9ba0e8d336abee8249668" translate="yes" xml:space="preserve">
          <source>Even though the database</source>
          <target state="translated">비록 데이터베이스가</target>
        </trans-unit>
        <trans-unit id="31dfaf84589e564bfee1b65ff3c5d7573077d711" translate="yes" xml:space="preserve">
          <source>Even though the function prototype shows that xEntryPoint() takes no arguments and returns void, SQLite invokes xEntryPoint() with three arguments and expects an integer result as if the signature of the entry point where as follows:</source>
          <target state="translated">함수 프로토 타입에서 xEntryPoint ()가 인수를 사용하지 않고 void를 리턴하는 것으로 표시하더라도 SQLite는 세 개의 인수로 xEntryPoint ()를 호출하고 다음과 같이 진입 점의 서명처럼 정수 결과를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="4b42b7e22dd2091056535ea5f248d0c4a2e55603" translate="yes" xml:space="preserve">
          <source>Even when the SQLITE_ENABLE_SORTER_REFERENCES compile-time option is on, sorter references are still disabled by default. To use sorter references, the application must set a sorter reference size threshold using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt;) interface at start-time.</source>
          <target state="translated">SQLITE_ENABLE_SORTER_REFERENCES 컴파일 타임 옵션이 켜져 있어도 정렬 기 참조는 기본적으로 여전히 사용 불가능합니다. 분류기 참조를 사용하려면 응용 프로그램은 시작시 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsorterrefsize&quot;&gt;SQLITE_CONFIG_SORTERREF_SIZE&lt;/a&gt; ) 인터페이스를 사용하여 분류기 참조 크기 임계 값을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9faf17aed220247be5c3b4b3c5ce1890f9062f4" translate="yes" xml:space="preserve">
          <source>Eventually, the writing process will want to update the database file, either because its memory cache has filled up or because it is ready to commit its changes. Before this happens, the writer must make sure no other process is reading the database and that the rollback journal data is safely on the disk surface so that it can be used to rollback incomplete changes in the event of a power failure. The steps are as follows:</source>
          <target state="translated">결국 쓰기 프로세스는 메모리 캐시가 가득 찼거나 변경 사항을 커밋 할 준비가 되었기 때문에 데이터베이스 파일을 업데이트하려고합니다. 이 작업을 수행하기 전에 기록기는 다른 프로세스가 데이터베이스를 읽고 있지 않아야하며 롤백 저널 데이터가 디스크 표면에 안전하게 있어야 전원 장애시 불완전한 변경을 롤백하는 데 사용할 수 있습니다. 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89e7b1ca2d523bd7c0cba8f71e13245a8608c1a8" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">모든 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은 다음 구조의 서브 클래스를 사용하여 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 가리키고 가상 테이블 을 반복하는 데 사용되는 커서를 설명 합니다. 커서는 모듈 의 &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; 메소드를 사용하여 작성되며 xClose 메소드에 의해 &lt;a href=&quot;vtab#xclose&quot;&gt;제거&lt;/a&gt; 됩니다. 커서는 모듈 의 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; , &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; , &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메소드에서 사용됩니다. 각 모듈 구현은 자체 요구에 맞게 커서 구조의 내용을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="736f9f0cc1331d7eb8b3f3146d63e9ed826e6bf1" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">모든 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은이 개체의 서브 클래스를 사용하여 가상 테이블 의 특정 인스턴스를 설명 &lt;a href=&quot;vtab&quot;&gt;합니다&lt;/a&gt; . 각 서브 클래스는 모듈 구현의 특정 요구에 맞게 조정됩니다. 이 슈퍼 클래스의 목적은 모든 모듈 구현에 공통적 인 특정 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97f4ee6ffc1e6119472d334b08a9eb970b87d195" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of the following structure to describe cursors that point into the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; and are used to loop through the virtual table. Cursors are created using the &lt;a href=&quot;../vtab#xopen&quot;&gt;xOpen&lt;/a&gt; method of the module and are destroyed by the &lt;a href=&quot;../vtab#xclose&quot;&gt;xClose&lt;/a&gt; method. Cursors are used by the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;, &lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt;, &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;, and &lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods of the module. Each module implementation will define the content of a cursor structure to suit its own needs.</source>
          <target state="translated">모든 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은 다음 구조의 서브 클래스를 사용하여 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 가리키고 가상 테이블 을 반복하는 데 사용되는 커서를 설명 합니다. 커서는 모듈 의 &lt;a href=&quot;../vtab#xopen&quot;&gt;xOpen&lt;/a&gt; 메소드를 사용하여 작성되며 xClose 메소드에 의해 &lt;a href=&quot;../vtab#xclose&quot;&gt;제거&lt;/a&gt; 됩니다. 커서는 모듈 의 &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; , &lt;a href=&quot;../vtab#xeof&quot;&gt;xEof&lt;/a&gt; , &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;../vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메소드에서 사용됩니다. 각 모듈 구현은 자체 요구에 맞게 커서 구조의 내용을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4a7edaa14334e8a1c0b858598b1fb6dee8c4645f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; implementation uses a subclass of this object to describe a particular instance of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.</source>
          <target state="translated">모든 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 구현은이 개체의 서브 클래스를 사용하여 가상 테이블 의 특정 인스턴스를 설명 &lt;a href=&quot;../vtab&quot;&gt;합니다&lt;/a&gt; . 각 서브 클래스는 모듈 구현의 특정 요구에 맞게 조정됩니다. 이 슈퍼 클래스의 목적은 모든 모듈 구현에 공통적 인 특정 필드를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f5bf4a9e3a3b1713480df787f65c0a1a83ce231" translate="yes" xml:space="preserve">
          <source>Every CREATE TABLE statement must specify a name for the new table. Table names that begin with &quot;sqlite_&quot; are reserved for internal use. It is an error to attempt to create a table with a name that starts with &quot;sqlite_&quot;.</source>
          <target state="translated">모든 CREATE TABLE 문은 새 테이블의 이름을 지정해야합니다. &quot;sqlite_&quot;로 시작하는 테이블 이름은 내부 용으로 예약되어 있습니다. &quot;sqlite_&quot;로 시작하는 이름을 가진 테이블을 작성하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c09016ba5ad82dc79c272414a45cdfd7263b163c" translate="yes" xml:space="preserve">
          <source>Every FTS table has a &lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;hidden column&lt;/a&gt; with the same name as the table itself. The value contained in each row for the hidden column is a blob that is only useful as the left operand of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operator, or as the left-most argument to one of the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">모든 FTS 테이블에는 테이블 자체와 이름이 같은 &lt;a href=&quot;vtab#hiddencol&quot; id=&quot;hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 있습니다. 숨겨진 열의 각 행에 포함 된 값은 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; 연산자 의 왼쪽 피연산자 또는 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 함수&lt;/a&gt; 중 하나의 가장 왼쪽 인수 로만 유용한 블롭입니다 .</target>
        </trans-unit>
        <trans-unit id="993c036bb5f364557a67f157a0c471a9889968ba" translate="yes" xml:space="preserve">
          <source>Every SQL database engine compiles each SQL statement into some kind of internal data structure which is then used to carry out the work of the statement. But in most SQL engines that internal data structure is a complex web of interlinked structures and objects. In SQLite, the compiled form of statements is a short program in a machine-language like representation. Users of the database can view this &lt;a href=&quot;opcode&quot;&gt;virtual machine language&lt;/a&gt; by prepending the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; keyword to a query.</source>
          <target state="translated">모든 SQL 데이터베이스 엔진은 각 SQL 문을 일종의 내부 데이터 구조로 컴파일 한 다음 명령문의 작업을 수행하는 데 사용됩니다. 그러나 대부분의 SQL 엔진에서 내부 데이터 구조는 상호 연결된 구조와 개체의 복잡한 웹입니다. SQLite에서 컴파일 된 명령문 형식은 기계 언어와 유사한 표현의 짧은 프로그램입니다. 데이터베이스 사용자는 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 키워드를 쿼리 앞에 추가 하여이 &lt;a href=&quot;opcode&quot;&gt;가상 머신 언어&lt;/a&gt; 를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="127b4b3b406ae503f3997bc734ac5e49c93499f4" translate="yes" xml:space="preserve">
          <source>Every SQL statement that SQLite interprets results in a program for the virtual machine. But if the SQL statement begins with the keyword &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; the virtual machine will not execute the program. Instead, the instructions of the program will be returned, one instruction per row, like a query result. This feature is useful for debugging and for learning how the virtual machine operates. For example:</source>
          <target state="translated">SQLite가 해석하는 모든 SQL 문은 가상 머신에 대한 프로그램을 생성합니다. 그러나 SQL 문이 키워드 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN으로&lt;/a&gt; 시작 하면 가상 머신은 프로그램을 실행하지 않습니다. 대신 프로그램 결과가 쿼리 결과처럼 행당 하나의 명령으로 반환됩니다. 이 기능은 디버깅 및 가상 머신 작동 방식을 학습하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05725310bea32a87080c57a7b88490274c131486" translate="yes" xml:space="preserve">
          <source>Every WITHOUT ROWID table must have a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. An error is raised if a CREATE TABLE statement with the WITHOUT ROWID clause lacks a PRIMARY KEY.</source>
          <target state="translated">모든 WITHOUT ROWID 테이블에는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 가 있어야합니다 . WITHOUT ROWID 절이있는 CREATE TABLE 문에 PRIMARY KEY가 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a2a07182d50aca4f020b64628bbefdfb26b38c35" translate="yes" xml:space="preserve">
          <source>Every argv entry will have a non-NULL value in C but may contain the SQL value NULL. In other words, it is always true that &lt;code&gt;argv[i]!=0&lt;/code&gt; for &lt;b&gt;i&lt;/b&gt; between 0 and &lt;code&gt;argc-1&lt;/code&gt;. However, it might be the case that &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt;.</source>
          <target state="translated">모든 argv 항목은 C에서 NULL이 아닌 값을 가지지 만 SQL 값 NULL을 포함 할 수 있습니다. 즉, 항상 사실이다 &lt;code&gt;argv[i]!=0&lt;/code&gt; 에 대한 &lt;b&gt;I&lt;/b&gt; 0 내지 &lt;code&gt;argc-1&lt;/code&gt; . 그러나 &lt;code&gt;sqlite3_value_type(argv[i])==SQLITE_NULL&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f0b85ad6b7e5f1d163dd080cc52ed9499f5b4a" translate="yes" xml:space="preserve">
          <source>Every b-tree page has at most one parent b-tree page. A b-tree page without a parent is called a root page. A root b-tree page together with the closure of its children form a complete b-tree. It is possible (and in fact rather common) to have a complete b-tree that consists of a single page that is both a leaf and the root. Because there are pointers from parents to children, every page of a complete b-tree can be located if only the root page is known. Hence, b-trees are identified by their root page number.</source>
          <target state="translated">모든 b- 트리 페이지에는 최대 하나의 부모 b- 트리 페이지가 있습니다. 부모가없는 b- 트리 페이지를 루트 페이지라고합니다. 루트 b- 트리 페이지와 자식 폐쇄와 함께 완전한 b- 트리가 형성됩니다. 리프와 루트 인 단일 페이지로 구성된 완전한 b- 트리를 가질 수 있습니다 (실제로는 다소 일반적 임). 부모로부터 자식에 대한 포인터가 있기 때문에 루트 페이지 만 알려진 경우 전체 b- 트리의 모든 페이지를 찾을 수 있습니다. 따라서 b- 트리는 루트 페이지 번호로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="55a99fde5c029672563046825e6673a5103f75ad" translate="yes" xml:space="preserve">
          <source>Every bytecode program has a fixed (but potentially large) number of registers. A single register can hold a variety of objects:</source>
          <target state="translated">모든 바이트 코드 프로그램에는 고정 된 (그러나 잠재적으로 큰) 수의 레지스터가 있습니다. 단일 레지스터는 다양한 객체를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87fc7f1f92913eaea5a702a31bf26215c9004f47" translate="yes" xml:space="preserve">
          <source>Every column of every table has an associated collating function. If no collating function is explicitly defined, then the collating function defaults to BINARY. The COLLATE clause of the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt; is used to define alternative collating functions for a column.</source>
          <target state="translated">모든 테이블의 모든 열에는 연관된 조합 기능이 있습니다. 조합 기능이 명시 적으로 정의되지 않은 경우 조합 기능의 기본값은 BINARY입니다. &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;열 정의&lt;/a&gt; 의 COLLATE 절은 열에 대한 대체 조합 함수를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3214d30b9335d3698a80d09df52d21c7f7db6f83" translate="yes" xml:space="preserve">
          <source>Every database consists of one or more &quot;pages&quot;. Within a single database, every page is the same size, but different database can have page sizes that are powers of two between 512 and 65536, inclusive. The maximum size of a database file is 2147483646 pages. At the maximum page size of 65536 bytes, this translates into a maximum database size of approximately 1.4e+14 bytes (140 terabytes, or 128 tebibytes, or 140,000 gigabytes or 128,000 gibibytes).</source>
          <target state="translated">모든 데이터베이스는 하나 이상의 &quot;페이지&quot;로 구성됩니다. 단일 데이터베이스 내에서 모든 페이지의 크기는 동일하지만 다른 데이터베이스는 512에서 65536 사이의 2의 제곱 인 페이지 크기를 가질 수 있습니다. 데이터베이스 파일의 최대 크기는 2147483646 페이지입니다. 65536 바이트의 최대 페이지 크기에서 이는 약 1.4e + 14 바이트 (140 테라 바이트 또는 128 바이트 또는 140,000 기가 바이트 또는 128,000 기가 바이트)의 최대 데이터베이스 크기로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="492468356f24318b48960ab6726d183969622442" translate="yes" xml:space="preserve">
          <source>Every effort has been made to ensure that the various combinations of compilation options work harmoniously and produce a working library. Nevertheless, it is strongly recommended that the SQLite test-suite be executed to check for errors before using an SQLite library built with non-standard compilation options.</source>
          <target state="translated">다양한 컴파일 옵션 조합이 조화롭게 작동하고 작업 라이브러리를 생성하기 위해 모든 노력을 기울였습니다. 그럼에도 불구하고 비표준 컴파일 옵션으로 빌드 된 SQLite 라이브러리를 사용하기 전에 오류를 확인하기 위해 SQLite 테스트 스위트를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="851c55d70f2242d9f00006ba4265653d3268a46b" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드로 열린 모든 파일 은 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 (또는보다 일반적으로 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 서브 클래스 )를이 오브젝트의 인스턴스에 대한 포인터로 채 웁니다 . 이 오브젝트는 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트가 나타내는 열린 파일에 대해 다양한 조작을 수행하는 데 사용되는 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="acba6a710579420286ddba1b5725059065fac3c6" translate="yes" xml:space="preserve">
          <source>Every file opened by the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method populates an &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object (or, more commonly, a subclass of the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드로 열린 모든 파일 은 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 (또는보다 일반적으로 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트 의 서브 클래스 )를이 오브젝트의 인스턴스에 대한 포인터로 채 웁니다 . 이 오브젝트는 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트가 나타내는 열린 파일에 대해 다양한 조작을 수행하는 데 사용되는 메소드를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="41db9f975be9405dd8cb84bdb860cef93b013806" translate="yes" xml:space="preserve">
          <source>Every leaf entry and node (subtree) within the R*Tree has an integer &quot;level&quot;. The leaves have a level of 0. The first containing subtree of the leaves has a level of 1. The root of the R*Tree has the largest level value. The mxLevel entry in the sqlite3_rtree_query_info structure is the level value for the root of the R*Tree. The iLevel entry in sqlite3_rtree_query_info gives the level for the object being interrogated.</source>
          <target state="translated">R * Tree 내의 모든 리프 항목과 노드 (하위 트리)에는 정수 &quot;레벨&quot;이 있습니다. 잎의 레벨은 0입니다. 잎의 첫 번째 포함 하위 트리의 레벨은 1입니다. R * Tree의 루트는 가장 큰 레벨 값을 갖습니다. sqlite3_rtree_query_info 구조의 mxLevel 항목은 R * Tree 루트의 레벨 값입니다. sqlite3_rtree_query_info의 iLevel 항목은 심문중인 오브젝트의 레벨을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b83b5bef3193f9d71b5510c871842564bded152b" translate="yes" xml:space="preserve">
          <source>Every member in the organization has a name, and most members have a single boss. (The head of the whole organization has a NULL &quot;boss&quot; field.) The rows of the &quot;org&quot; table form a tree.</source>
          <target state="translated">조직의 모든 구성원은 이름을 가지며 대부분의 구성원은 단일 보스를 갖습니다. 전체 조직의 헤드에는 NULL &quot;보스&quot;필드가 있습니다. &quot;org&quot;테이블의 행은 트리를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="8f03f228f31451b11bb432dc265147274d2ce013" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">모든 새 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결은&lt;/a&gt; 기본적으로 임계 값 1000 또는 &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 페이지로 자동 검사 점이 사용되도록 설정됩니다 . 기본 설정이 특정 응용 프로그램에 적합하지 않은 경우에만이 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7af72a8a5bd73c0f21a3d8802bbfe1036436982" translate="yes" xml:space="preserve">
          <source>Every new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; defaults to having the auto-checkpoint enabled with a threshold of 1000 or &lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.</source>
          <target state="translated">모든 새 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결은&lt;/a&gt; 기본적으로 임계 값 1000 또는 &lt;a href=&quot;../compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 페이지로 자동 검사 점이 사용되도록 설정됩니다 . 기본 설정이 특정 응용 프로그램에 적합하지 않은 경우에만이 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="690c0362c23abb50bf57905b3d0de565bf19cc04" translate="yes" xml:space="preserve">
          <source>Every now and then someone discovers a new failure mode for the atomic commit mechanism in SQLite and the developers have to put in a patch. This is happening less and less and the failure modes are becoming more and more obscure. But it would still be foolish to suppose that the atomic commit logic of SQLite is entirely bug-free. The developers are committed to fixing these bugs as quickly as they might be found.</source>
          <target state="translated">때때로 누군가는 SQLite에서 원자 커밋 메커니즘에 대한 새로운 실패 모드를 발견하고 개발자는 패치를 넣어야합니다. 이것은 점점 줄어들고 있으며 실패 모드는 점점 더 모호 해지고 있습니다. 그러나 SQLite의 원자 커밋 로직에 완전히 버그가 없다고 가정하는 것은 여전히 ​​어리석은 일입니다. 개발자는 이러한 버그를 발견 할 수있는 한 빨리 해결하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f4785ec886c54cc0fadcbaced75cf5fb546955b" translate="yes" xml:space="preserve">
          <source>Every row of a table has a unique rowid. If the table defines a column with the type &quot;INTEGER PRIMARY KEY&quot; then that column becomes an alias for the rowid. But with or without an INTEGER PRIMARY KEY column, every row still has a rowid.</source>
          <target state="translated">테이블의 모든 행에는 고유 한 rowid가 있습니다. 테이블이 &quot;INTEGER PRIMARY KEY&quot;유형의 컬럼을 정의하면 해당 컬럼은 rowid의 별명이됩니다. 그러나 INTEGER PRIMARY KEY 열 유무에 관계없이 모든 행에는 여전히 rowid가 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c2c192e2c163c4bc5aa39b793ee2331ee10eba" translate="yes" xml:space="preserve">
          <source>Every row of an SQLite table has a unique integer key. If the table has a column labeled INTEGER PRIMARY KEY, then that column serves as the key. If there is no INTEGER PRIMARY KEY column then the key is a unique integer. The key for a row can be accessed in a SELECT statement or used in a WHERE or ORDER BY clause using any of the names &quot;ROWID&quot;, &quot;OID&quot;, or &quot;_ROWID_&quot;.</source>
          <target state="translated">SQLite 테이블의 모든 행에는 고유 한 정수 키가 있습니다. 테이블에 INTEGER PRIMARY KEY로 레이블 된 열이 있으면 해당 열이 키로 사용됩니다. INTEGER PRIMARY KEY 열이 없으면 키는 고유 한 정수입니다. 행의 키는 SELECT 문에서 액세스하거나 &quot;ROWID&quot;, &quot;OID&quot;또는 &quot;_ROWID_&quot;이름을 사용하여 WHERE 또는 ORDER BY 절에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523f1beb41c9b6ccdf7d3e8baf9a9fab841b07a9" translate="yes" xml:space="preserve">
          <source>Every table (except the &quot;sqlite_master&quot; table itself) and every named index in an SQLite database has an entry in the sqlite_master table. You can query this table using a SELECT statement just like any other table. But you are not allowed to directly change the table using UPDATE, INSERT, or DELETE. Changes to sqlite_master have to occur using the CREATE and DROP commands because SQLite also has to update some of its internal data structures when tables and indices are added or destroyed.</source>
          <target state="translated">모든 테이블 ( &quot;sqlite_master&quot;테이블 자체 제외)과 SQLite 데이터베이스의 모든 명명 된 인덱스에는 sqlite_master 테이블에 항목이 있습니다. 다른 테이블과 마찬가지로 SELECT 문을 사용하여이 테이블을 쿼리 할 수 ​​있습니다. 그러나 UPDATE, INSERT 또는 DELETE를 사용하여 테이블을 직접 변경할 수 없습니다. SQLite는 테이블과 인덱스를 추가하거나 제거 할 때 내부 데이터 구조 중 일부를 업데이트해야하기 때문에 CREATE 및 DROP 명령을 사용하여 sqlite_master를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee8f8904135a756c4539e015e36cc2347848e522" translate="yes" xml:space="preserve">
          <source>Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do no necessarily have an affinity.</source>
          <target state="translated">모든 테이블 열은 선호도 유형 (BLOB, TEXT, INTEGER, REAL 또는 NUMERIC 중 하나)을 갖지만 표현식에는 반드시 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4b08058b164391fddf9b32eae0d934e211c5565" translate="yes" xml:space="preserve">
          <source>Every union-vtab must be in the TEMP namespace. Hence, the &quot;&lt;b&gt;temp.&lt;/b&gt;&quot; prior to</source>
          <target state="translated">모든 union-vtab은 TEMP 네임 스페이스에 있어야합니다. 따라서 이전 의 &quot; &lt;b&gt;온도&lt;/b&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="07d98b3ee8d9544f097098f5c8c00f7db4bddabb" translate="yes" xml:space="preserve">
          <source>Every valid SQLite database file begins with the following 16 bytes (in hex): 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00. This byte sequence corresponds to the UTF-8 string &quot;SQLite format 3&quot; including the nul terminator character at the end.</source>
          <target state="translated">유효한 모든 SQLite 데이터베이스 파일은 다음 16 바이트 (16 진수)로 시작합니다. 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00.이 바이트 시퀀스는 UTF-8 문자열 &quot;SQLite 형식 3&quot;에 해당합니다. 끝에 널 종료 문자.</target>
        </trans-unit>
        <trans-unit id="3fb9e9a96d68ea92a8c52ca6ed6ad8f58a99797f" translate="yes" xml:space="preserve">
          <source>Every value in SQLite has one of five fundamental datatypes:</source>
          <target state="translated">SQLite의 모든 값에는 5 가지 기본 데이터 유형 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfeeeccf4fe9e729f75c5da5ce8becce10cd642f" translate="yes" xml:space="preserve">
          <source>Every virtual machine that &lt;b&gt;sqlite_compile&lt;/b&gt; creates should eventually be handed to &lt;b&gt;sqlite_finalize&lt;/b&gt;. The sqlite_finalize() procedure deallocates the memory and other resources that the virtual machine uses. Failure to call sqlite_finalize() will result in resource leaks in your program.</source>
          <target state="translated">&lt;b&gt;sqlite_compile이&lt;/b&gt; 생성 하는 모든 가상 머신 은 결국 &lt;b&gt;sqlite_finalize&lt;/b&gt; 로 전달되어야합니다 . sqlite_finalize () 프로시 저는 가상 머신이 사용하는 메모리 및 기타 자원을 할당 해제합니다. sqlite_finalize ()를 호출하지 않으면 프로그램에서 리소스가 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="8604e6b6fdb1f3b4989ca256181c53477f03dab5" translate="yes" xml:space="preserve">
          <source>Exactly how a constraint violation is dealt with is determined by the &lt;a href=&quot;lang_conflict&quot;&gt;constraint conflict resolution algorithm&lt;/a&gt;. Each PRIMARY KEY, UNIQUE, NOT NULL and CHECK constraint has a default conflict resolution algorithm. PRIMARY KEY, UNIQUE and NOT NULL constraints may be explicitly assigned a default conflict resolution algorithm by including a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; in their definitions. Or, if a constraint definition does not include a &lt;a href=&quot;syntax/conflict-clause&quot;&gt;conflict-clause&lt;/a&gt; or it is a CHECK constraint, the default conflict resolution algorithm is ABORT. Different constraints within the same table may have different default conflict resolution algorithms. See the section titled &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; for additional information.</source>
          <target state="translated">제약 조건 위반을 처리하는 방법은 제약 &lt;a href=&quot;lang_conflict&quot;&gt;조건 충돌 해결 알고리즘에&lt;/a&gt; 의해 결정됩니다 . 각 PRIMARY KEY, UNIQUE, NOT NULL 및 CHECK 제약 조건에는 기본 충돌 해결 알고리즘이 있습니다. PRIMARY KEY, UNIQUE 및 NOT NULL 제약 조건에는 정의에 &lt;a href=&quot;syntax/conflict-clause&quot;&gt;충돌 절&lt;/a&gt; 을 포함시켜 기본 충돌 해결 알고리즘이 명시 적으로 할당 될 수 있습니다 . 또는 제약 조건 정의에 &lt;a href=&quot;syntax/conflict-clause&quot;&gt;충돌 절이&lt;/a&gt; 포함되어 있지 않거나 CHECK 제약 조건 인 경우 기본 충돌 해결 알고리즘은 ABORT입니다. 동일한 테이블 내에서 서로 다른 제약 조건에는 기본 충돌 해결 알고리즘이 다를 수 있습니다. 추가 정보는 &lt;a href=&quot;lang_conflict&quot;&gt;충돌시&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea502dec1cc13ee575d4e1a550b73652d77d9edc" translate="yes" xml:space="preserve">
          <source>Exactly how such a potential race-condition is handled depends on the threads and synchronization primitives interface used by the application. This example uses pthreads, the interface provided by modern UNIX-like systems, including Linux.</source>
          <target state="translated">이러한 잠재적 경쟁 조건이 처리되는 방식은 응용 프로그램에서 사용하는 스레드 및 동기화 기본 인터페이스에 따라 다릅니다. 이 예제는 Linux를 포함한 최신 UNIX 유사 시스템에서 제공하는 인터페이스 인 pthread를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8bb56a9e102b28af62ab0fa87c8a54e2b7c186a7" translate="yes" xml:space="preserve">
          <source>Example 1: Loading and Saving In-Memory Databases</source>
          <target state="translated">예 1 : 메모리 내 데이터베이스로드 및 저장</target>
        </trans-unit>
        <trans-unit id="51937c8938bd2ebee4b2832c7cafa5f90c5d7f5e" translate="yes" xml:space="preserve">
          <source>Example 2: Online Backup of a Running Database</source>
          <target state="translated">예 2 : 실행중인 데이터베이스의 온라인 백업</target>
        </trans-unit>
        <trans-unit id="422445b132a0ddb86add309db860ce13ab867af6" translate="yes" xml:space="preserve">
          <source>Example Code</source>
          <target state="translated">예제 코드</target>
        </trans-unit>
        <trans-unit id="4899b03c6613d4db35e464f13d4310eba09ed242" translate="yes" xml:space="preserve">
          <source>Example Typenames From The</source>
          <target state="translated">의 유형 이름 예</target>
        </trans-unit>
        <trans-unit id="c6f5f53793eadfd32dbab5c6aaa82a0136b96344" translate="yes" xml:space="preserve">
          <source>Example illustrating the difference between the &quot;simple&quot; and &quot;porter&quot; tokenizers:</source>
          <target state="translated">&quot;단순&quot;및 &quot;포터&quot;토크 나이저의 차이점을 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="ef9725acb0b6336e45af3212bad902a609b4a04c" translate="yes" xml:space="preserve">
          <source>Example: Let the index be</source>
          <target state="translated">예 : 인덱스를</target>
        </trans-unit>
        <trans-unit id="e401b272925dcc99ebcfccff32208c1de26ee958" translate="yes" xml:space="preserve">
          <source>Example: To verify that an R*Tree named &quot;demo_index&quot; is well-formed and internally consistent, run:</source>
          <target state="translated">예 : 이름이 &quot;demo_index&quot;인 R * Tree가 올바르게 구성되어 있고 내부적으로 일관성이 있는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a2d6c3cd648514e93054fc43de972ef1a1395513" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, all rows within SQLite tables have a 64-bit signed integer key that uniquely identifies the row within its table. This integer is usually called the &quot;rowid&quot;. The rowid value can be accessed using one of the special case-independent names &quot;rowid&quot;, &quot;oid&quot;, or &quot;_rowid_&quot; in place of a column name. If a table contains a user defined column named &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot;, then that name always refers the explicitly declared column and cannot be used to retrieve the integer rowid value.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블을 제외하고 SQLite 테이블 내의 모든 행에는 테이블 내의 행을 고유하게 식별하는 64 비트 부호있는 정수 키가 있습니다. 이 정수는 보통 &quot;rowid&quot;라고합니다. rowid 값은 열 이름 대신 대소 문자를 구분하지 않는 특수 이름 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;중 하나를 사용하여 액세스 할 수 있습니다. 테이블에 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;라는 사용자 정의 열이 포함 된 경우 해당 이름은 항상 명시 적으로 선언 된 열을 나타내며 정수 rowid 값을 검색하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="248eb9944419f3599ba80de676ca2d1922746437" translate="yes" xml:space="preserve">
          <source>Except for the WHERE clause, the structure of the program for this example is very much like the prior example, just with an extra column. There are now 3 columns, instead of 2 as before, and there are three ColumnName instructions. A cursor is opened using the OpenRead instruction, just like in the prior example. The Rewind instruction at address 6 and the Next at address 17 form a loop over all records of the table. The Close instruction at the end is there to give the Rewind instruction something to jump to when it is done. All of this is just like in the first query demonstration.</source>
          <target state="translated">WHERE 절을 제외하고이 예제의 프로그램 구조는 추가 열이있는 이전 예제와 매우 유사합니다. 이전과 같이 2가 아니라 3 개의 열이 있으며 3 개의 ColumnName 명령어가 있습니다. 이전 예에서와 같이 OpenRead 명령어를 사용하여 커서가 열립니다. 주소 6의 되감기 명령과 주소 17의 다음 되감기 명령은 테이블의 모든 레코드에 대해 루프를 형성합니다. 마지막에 닫기 명령은 되감기 명령이 완료되면 바로 이동할 수 있도록합니다. 이 모든 것은 첫 번째 쿼리 데모와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7141d556020acb770b395a3f91e4943886944cf0" translate="yes" xml:space="preserve">
          <source>Except for the read operation required by H35070 and those reads made as part of opening a read-only transaction, SQLite shall ensure that a</source>
          <target state="translated">H35070에 필요한 읽기 작업과 읽기 전용 트랜잭션을 여는 과정에서 작성된 읽기를 제외하고 SQLite는</target>
        </trans-unit>
        <trans-unit id="daf367d9a62995933815a1367ba71ebafe36cdd3" translate="yes" xml:space="preserve">
          <source>Except in the case of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections with &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; turned on, all transactions in SQLite show &quot;serializable&quot; isolation. SQLite implements serializable transactions by actually serializing the writes. There can only be a single writer at a time to an SQLite database. There can be multiple database connections open at the same time, and all of those database connections can write to the database file, but they have to take turns. SQLite uses locks to serialization of the writes automatically; this is not something that the applications using SQLite need to worry with.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; 가 설정된 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 데이터베이스 연결 의 경우를 제외하고 SQLite의 모든 트랜잭션에는 &quot;직렬화 가능&quot;격리가 표시됩니다. SQLite는 실제로 쓰기를 직렬화하여 직렬화 가능한 트랜잭션을 구현합니다. SQLite 데이터베이스에는 한 번에 하나의 작성자 만있을 수 있습니다. 동시에 여러 개의 데이터베이스 연결이 열릴 수 있으며 모든 해당 데이터베이스 연결은 데이터베이스 파일에 쓸 수 있지만 차례를 바꿔야합니다. SQLite는 잠금을 사용하여 쓰기의 직렬화를 자동으로 수행합니다. 이것은 SQLite를 사용하는 응용 프로그램이 걱정해야 할 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="05e17a55270022b0935203eb1ff65bd637b9eb0b" translate="yes" xml:space="preserve">
          <source>Except, the statement above does not work, thanks to pointer types. The pointer generated by the MATCH operator has a type of &quot;fts3cursor&quot; but the carray() function expects to receives a pointer of type &quot;carray&quot;. Because the pointer type on the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; does not match the pointer type on the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; call, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; returns NULL in carray() and thus signals the CARRAY extension that it has been passed an invalid pointer.</source>
          <target state="translated">단, 포인터 유형으로 인해 위의 명령문이 작동하지 않습니다. MATCH 연산자에 의해 생성 된 포인터에는 &quot;fts3cursor&quot;유형이 있지만 carray () 함수는 &quot;carray&quot;유형의 포인터를받을 것으로 예상합니다. 상의 포인터 형 때문에 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer은 ()&lt;/a&gt; 상의 포인터 유형과 일치하지 않습니다 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 호출, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 따라서 반환 carray에 NULL ()과는 유효하지 않은 포인터를 통과되었다는 CARRAY 확장 신호를 보낸다.</target>
        </trans-unit>
        <trans-unit id="0829c4066912f266e388974fa121b62d34c08be6" translate="yes" xml:space="preserve">
          <source>Exclude clause</source>
          <target state="translated">제외 조항</target>
        </trans-unit>
        <trans-unit id="6898c23bf064b43d330b025080e2f7ca1c663675" translate="yes" xml:space="preserve">
          <source>Execute applicable AFTER trigger programs.</source>
          <target state="translated">적용 가능한 AFTER 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c543e4bf2eac6c17a5bcafecd505a60bc0758ff2" translate="yes" xml:space="preserve">
          <source>Execute applicable BEFORE trigger programs,</source>
          <target state="translated">해당 BEFORE 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dc88af1c57b78a22fe3c05896efc419ad226673e" translate="yes" xml:space="preserve">
          <source>Execute the trigger program passed as P4 (type P4_SUBPROGRAM).</source>
          <target state="translated">P4 (유형 P4_SUBPROGRAM)로 전달 된 트리거 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="92e0a28a0ba14dbc0f9870c2587f7dd1fa43da35" translate="yes" xml:space="preserve">
          <source>Execute the xInverse function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xInverse 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="8e826ee24e5eaa789db2ffc2c5ffba3d2ef490ea" translate="yes" xml:space="preserve">
          <source>Execute the xStep (if P1==0) or xInverse (if P1!=0) function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xStep (P1 == 0 인 경우) 또는 xInverse (P1! = 0 인 경우) 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="d25e5f6cc8e8e8f6df2982b8a71bbe3109ad8777" translate="yes" xml:space="preserve">
          <source>Execute the xStep function for an aggregate. The function has P5 arguments. P4 is a pointer to the FuncDef structure that specifies the function. Register P3 is the accumulator.</source>
          <target state="translated">집계에 대해 xStep 함수를 실행하십시오. 이 함수에는 P5 인수가 있습니다. P4는 함수를 지정하는 FuncDef 구조에 대한 포인터입니다. 레지스터 P3은 누산기입니다.</target>
        </trans-unit>
        <trans-unit id="3abcc2cf0440581468341c7211f2946754168feb" translate="yes" xml:space="preserve">
          <source>Executive Summary</source>
          <target state="translated">행정상 개요</target>
        </trans-unit>
        <trans-unit id="23225800cd0002edfbed8ad40f888fff569bdb43" translate="yes" xml:space="preserve">
          <source>Existing Change</source>
          <target state="translated">기존 변경</target>
        </trans-unit>
        <trans-unit id="c6a4c238411feb293bac6b4620c00bdb61a3fa23" translate="yes" xml:space="preserve">
          <source>Existing zip archive entries may be modified using UPDATE statements.</source>
          <target state="translated">기존 zip 아카이브 항목은 UPDATE 문을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b42835fb01a0646614ba4e81e2b65a9cff9bdf" translate="yes" xml:space="preserve">
          <source>Exit immediately. All open cursors, etc are closed automatically.</source>
          <target state="translated">즉시 종료하십시오. 열려있는 모든 커서 등이 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="9be8055dafdd8df7dd5ded321f98b5d4a3c23849" translate="yes" xml:space="preserve">
          <source>Experimental And Deprecated Interfaces</source>
          <target state="translated">실험적이고 사용되지 않는 인터페이스</target>
        </trans-unit>
        <trans-unit id="7fea72449d921c55e0065d056e69bc920823d9b0" translate="yes" xml:space="preserve">
          <source>Experimental FTS2 module added</source>
          <target state="translated">실험용 FTS2 모듈 추가</target>
        </trans-unit>
        <trans-unit id="3fdb876749dabb65b0a863fa4088f5b7655056a5" translate="yes" xml:space="preserve">
          <source>Experimental Interfaces</source>
          <target state="translated">실험적인 인터페이스</target>
        </trans-unit>
        <trans-unit id="e4bb6c1ea9830afec3b0ef3a107b2b9f3dde8942" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions added.</source>
          <target state="translated">실험 날짜 / 시간 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="358e8b7fb082176243da08a7a31fe5a4d1333969" translate="yes" xml:space="preserve">
          <source>Experimental date/time functions revised.</source>
          <target state="translated">실험 날짜 / 시간 기능이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="7eb10f0095483031f4d115113847c4183b77a491" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change and/or removal at any time.</source>
          <target state="translated">실험 인터페이스는 언제든지 변경 및 / 또는 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8727cd9638a0f2713c26e6983da8bcb851353a9" translate="yes" xml:space="preserve">
          <source>Experimental interfaces are subject to change. Applications that use experimental interfaces may need to be modified when upgrading to a newer SQLite release, though this is rare. When new interfaces are added to SQLite, they generally begin as experimental interfaces. After an interface has been in use for a while and the developers are confident that the design of the interface is sound and worthy of long-term support, the interface is marked as stable.</source>
          <target state="translated">실험적인 인터페이스는 변경 될 수 있습니다. 새로운 SQLite 릴리스로 업그레이드 할 때 실험적인 인터페이스를 사용하는 응용 프로그램을 수정해야 할 수도 있습니다. 새로운 인터페이스가 SQLite에 추가되면 일반적으로 실험적인 인터페이스로 시작됩니다. 인터페이스를 한동안 사용하고 개발자가 인터페이스 디자인이 건전하고 장기적으로 지원할 가치가 있다고 확신하면 인터페이스가 안정적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a20b1cb075c4a00d0abbf8e26207c972c09680bb" translate="yes" xml:space="preserve">
          <source>Experimental memory allocators</source>
          <target state="translated">실험 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="ef394d562795d87e8981a3ef0b747f4f8415b4e8" translate="yes" xml:space="preserve">
          <source>Experimental sqlite_last_statement_changes() API added. Fixed the last_insert_rowid() function so that it works correctly with triggers.</source>
          <target state="translated">실험적인 sqlite_last_statement_changes () API가 추가되었습니다. last_insert_rowid () 함수가 트리거와 올바르게 작동하도록 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="3da5d6c17cd08f8fd17c037a2c324328332c9e1f" translate="yes" xml:space="preserve">
          <source>Expire</source>
          <target state="translated">Expire</target>
        </trans-unit>
        <trans-unit id="3491713fb12e8a067f41197ec08bfafa31b9fad4" translate="yes" xml:space="preserve">
          <source>Export the sqlite_changes() function from Windows DLLs.</source>
          <target state="translated">Windows DLL에서 sqlite_changes () 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1cdccf3f2c55fca61416f93409d6573cd4ec6636" translate="yes" xml:space="preserve">
          <source>Export the sqlite_function_type() API function in the Windows DLL</source>
          <target state="translated">Windows DLL에서 sqlite_function_type () API 함수 내보내기</target>
        </trans-unit>
        <trans-unit id="d5fbd7523567abe11b73fcd31b6d3a54394db40c" translate="yes" xml:space="preserve">
          <source>Export to excel</source>
          <target state="translated">엑셀로 내보내기</target>
        </trans-unit>
        <trans-unit id="d3564717c402a8a051ea3b35dc177cb473a37b25" translate="yes" xml:space="preserve">
          <source>Expose SQLite's internal pseudo-random number generator (PRNG) via the &lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness()&lt;/a&gt; interface</source>
          <target state="translated">&lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness ()&lt;/a&gt; 인터페이스 를 통해 SQLite의 내부 의사 난수 생성기 (PRNG) 노출</target>
        </trans-unit>
        <trans-unit id="ae70d9011360d64f28a8a35dd90c8da3ddd3466d" translate="yes" xml:space="preserve">
          <source>Expose the &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; interface for use by extensions and applications.</source>
          <target state="translated">확장 및 응용 프로그램에서 사용할 &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 인터페이스를 노출하십시오 .</target>
        </trans-unit>
        <trans-unit id="43a8bde69f1d5429f321700a30e06b249b531dc6" translate="yes" xml:space="preserve">
          <source>Expression Affinity</source>
          <target state="translated">발현 친 화성</target>
        </trans-unit>
        <trans-unit id="2dd84143cc8f5bbd9454bf39088a896b30eb6b90" translate="yes" xml:space="preserve">
          <source>Expression affinity</source>
          <target state="translated">발현 친화력</target>
        </trans-unit>
        <trans-unit id="3d1f752f9df92f5925b4848ce31d612b54cbf2eb" translate="yes" xml:space="preserve">
          <source>Expression affinity is determined by the following rules:</source>
          <target state="translated">발현 친화도는 다음 규칙에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="59d2facf767d8cd997d901649d83987ad43a4414" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may contain function calls, but only to functions whose output is always determined completely by its input parameters (a.k.a.: &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;). Obviously, functions like &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; will not work well in an index. But also functions like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;, though they are constant across any one database connection, are not constant across the life of the underlying database file, and hence may not be used in a CREATE INDEX statement.</source>
          <target state="translated">CREATE INDEX 문의 표현식에는 함수 호출이 포함될 수 있지만 출력이 항상 입력 매개 변수 (일명 &lt;a href=&quot;deterministic&quot;&gt;결정적 함수&lt;/a&gt; )에 의해 완전히 결정되는 함수에 대한 함수 호출 만 포함 할 수 있습니다 . 분명히 &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; 과 같은 함수 는 인덱스에서 제대로 작동하지 않습니다. 그러나 &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같은 함수 는 하나의 데이터베이스 연결에서 일정하지만 기본 데이터베이스 파일의 수명 동안 일정하지 않으므로 CREATE INDEX 문에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19a6e91fe10c5674eb13c2fd762a7021fa8a05d5" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may not use subqueries.</source>
          <target state="translated">CREATE INDEX 문의 표현식은 서브 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cfe3f417ef1d8d91b4195c28077dbb7d62d18f6" translate="yes" xml:space="preserve">
          <source>Expressions in CREATE INDEX statements may only refer to columns of the table being indexed, not to columns in other tables.</source>
          <target state="translated">CREATE INDEX 문의 표현식은 다른 테이블의 열이 아니라 인덱싱중인 테이블의 열만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c8785ad9b4a9d7dc1446ae294e913645b75702" translate="yes" xml:space="preserve">
          <source>Expressions in an index may not reference other tables and may not use subqueries nor functions whose result might change (ex: &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;). Expressions in an index may only refer to columns in the table that is being indexed. Indexes on expression will not work with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). See the &lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt; document for additional information about using general expressions in CREATE INDEX statements.</source>
          <target state="translated">인덱스의 표현식은 다른 테이블을 참조 할 수 없으며 결과가 변경 될 수있는 하위 쿼리 나 함수 (예 : &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; )를 사용할 수 없습니다 . 인덱스의 표현식은 인덱스되는 테이블의 열만 참조 할 수 있습니다. 식에 대한 인덱스는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 이전의 SQLite 버전에서는 작동하지 않습니다 . CREATE INDEX 문에서 일반 표현식 사용에 대한 추가 정보 는 &lt;a href=&quot;expridx&quot;&gt;Indexes On Expressions&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c735d025b09f54040c918a48c63f4553312abde0" translate="yes" xml:space="preserve">
          <source>Expressions may only be used in CREATE INDEX statements, not within &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints within the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">식은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 내의 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건이 아닌 CREATE INDEX 문에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16ba9ffc3e58ab67f2eeb64637e9739a29beccda" translate="yes" xml:space="preserve">
          <source>Extend the expression syntax to support &quot;expr NOT NULL&quot; (with a space between the &quot;NOT&quot; and the &quot;NULL&quot;) in addition to &quot;expr NOTNULL&quot; (with no space).</source>
          <target state="translated">&quot;expr NOTNULL&quot;(공백 없음) 외에 &quot;expr NOT NULL&quot;( &quot;NOT&quot;와 &quot;NULL&quot;사이에 공백이 있음)을 지원하도록 표현식 구문을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="6d86bea998341375770658644790ac8289ea0fef" translate="yes" xml:space="preserve">
          <source>Extended Result Codes</source>
          <target state="translated">확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="09d1c9addf77edc2a7d8092f6e72ee640d2e255e" translate="yes" xml:space="preserve">
          <source>Extended result code</source>
          <target state="translated">확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="61badc5a87beafb6593c6e7cfe212f92bad7bbcd" translate="yes" xml:space="preserve">
          <source>Extended the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface, and in particular the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; object to allow a virtual table to report its estimate on the number of rows that will be returned by a query.</source>
          <target state="translated">확장 된 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 인터페이스를하고, 특히 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 객체는 가상 테이블이 쿼리에 의해 반환 될 행의 수의 견적을보고 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="e46597fb97bef96ee5f73107f8febfe136670bc8" translate="yes" xml:space="preserve">
          <source>Extending FTS5</source>
          <target state="translated">FTS5 확장</target>
        </trans-unit>
        <trans-unit id="a0ff53d7fc1bead66589841e525ef8e976444aff" translate="yes" xml:space="preserve">
          <source>Extension loading is off by default. Call the sqlite3_enable_load_extension() routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.</source>
          <target state="translated">확장 프로그램로드는 기본적으로 해제되어 있습니다. 확장로드를 켜려면 sqlite3_enable_load_extension () 루틴을 onoff == 1로 호출하고 다시 끄려면 onoff == 0으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="46936b46e05c0cd15e06014bbbef567350675181" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">이 API를 호출하기 전에 &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL)를 사용하여 확장로드를 사용 가능하게해야합니다 . 그렇지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1dcae90e84eec9a78eefca273aa7a82ae9fd130" translate="yes" xml:space="preserve">
          <source>Extension loading must be enabled using &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; or &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) prior to calling this API, otherwise an error will be returned.</source>
          <target state="translated">이 API를 호출하기 전에 &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 또는 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL)를 사용하여 확장로드를 사용 가능하게해야합니다 . 그렇지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="114e41de65bbb502416914ca4249318756eb8953" translate="yes" xml:space="preserve">
          <source>Extension loading supported added to WinCE</source>
          <target state="translated">WinCE에 추가 ​​된 확장 로딩</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="439b09ab192ef3f4c9a45dd3f23cf364759dd991" translate="yes" xml:space="preserve">
          <source>Extensions can also be statically linked with the application. The code template shown below will work just as well as a statically linked extension as it does as a run-time loadable extension except that you should give the entry point function (&quot;sqlite3_extension_init&quot;) a different name to avoid name collisions if your application contains two or more extensions.</source>
          <target state="translated">확장은 응용 프로그램과 정적으로 연결될 수도 있습니다. 아래에 표시된 코드 템플릿은 응용 프로그램에 포함 된 경우 이름 충돌을 피하기 위해 진입 점 함수 ( &quot;sqlite3_extension_init&quot;)에 다른 이름을 지정해야한다는 점을 제외하고는 런타임로드 가능 확장과 마찬가지로 정적으로 링크 된 확장과 마찬가지로 작동합니다. 둘 이상의 확장.</target>
        </trans-unit>
        <trans-unit id="a4e4d34ecd0944488461a920456725f4890a8840" translate="yes" xml:space="preserve">
          <source>Extensive use of assert() and run-time checks</source>
          <target state="translated">assert () 및 런타임 검사의 광범위한 사용</target>
        </trans-unit>
        <trans-unit id="b4ced57f2686552cf070ac8fb509a5077ec27fda" translate="yes" xml:space="preserve">
          <source>External content fts4 tables</source>
          <target state="translated">외부 컨텐츠 fts4 테이블</target>
        </trans-unit>
        <trans-unit id="47b818c2e14f39f43b217d0ea891f065e303f7e1" translate="yes" xml:space="preserve">
          <source>Externally, from the point of view of another process or thread, two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using a shared-cache appear as a single connection. The locking protocol used to arbitrate between multiple shared-caches or regular database users is described elsewhere.</source>
          <target state="translated">외부 적으로, 다른 프로세스 나 스레드의 관점 에서 공유 캐시를 사용하는 둘 이상의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 단일 연결로 나타납니다. 여러 공유 캐시 또는 일반 데이터베이스 사용자 간의 중재에 사용되는 잠금 프로토콜은 다른 곳에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="45e62225b6f82210cf1454638e84d31967235d1d" translate="yes" xml:space="preserve">
          <source>Extra sanity checking added to ALTER TABLE in the 3.25.0 release sometimes raises a false-positive when the table being modified has a trigger that updates a virtual table. The false-positive caused the ALTER TABLE to rollback, thus leaving the schema unchanged. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt;.</source>
          <target state="translated">3.25.0 릴리스의 ALTER TABLE에 추가 ​​된 정상 상태 점검은 수정중인 테이블에 가상 테이블을 업데이트하는 트리거가있는 경우 거짓 양성을 발생시킵니다. 위양성으로 인해 ALTER TABLE이 롤백되어 스키마가 변경되지 않았습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/b41031ea2b537237&quot;&gt;b41031ea2b537237&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">테이블 열에 대한 메타 데이터 추출</target>
        </trans-unit>
        <trans-unit id="40f3078b8961fbdb3a6f635e86be2acec27a1a53" translate="yes" xml:space="preserve">
          <source>Extract a single row from the queue.</source>
          <target state="translated">큐에서 단일 행을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="b4ae32f698bcf0fdc018ba41b1247fb34c34af21" translate="yes" xml:space="preserve">
          <source>Extract an entry from the SQLite Archive using code like this:</source>
          <target state="translated">다음과 같은 코드를 사용하여 SQLite Archive에서 항목을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="3e003c081f655906879284f1f4c7714e31b1d65b" translate="yes" xml:space="preserve">
          <source>Extract files from the archive (either to the current working directory or to the directory specified by a --directory option). If there are no arguments following the options all files are extracted from the archive. Or, if there are arguments, they are the names of files to extract from the archive. Any specified directories are extracted recursively. It is an error if any specified files are not part of the archive.</source>
          <target state="translated">아카이브에서 파일을 추출하십시오 (현재 작업 디렉토리 또는 --directory 옵션으로 지정된 디렉토리로). 옵션 뒤에 인수가 없으면 모든 파일이 아카이브에서 추출됩니다. 또는 인수가 있으면 아카이브에서 추출 할 파일 이름입니다. 지정된 디렉토리는 재귀 적으로 추출됩니다. 지정된 파일이 아카이브의 일부가 아닌 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="baa0742d96de2a24f07eed1535bac071a9075c95" translate="yes" xml:space="preserve">
          <source>Extract specified files from archive.</source>
          <target state="translated">아카이브에서 지정된 파일을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="eb5c6d1fcf0a608f318e463de8632f84451eaf7b" translate="yes" xml:space="preserve">
          <source>Extract the smallest value from the RowSet object in P1 and put that value into register P3. Or, if RowSet object P1 is initially empty, leave P3 unchanged and jump to instruction P2.</source>
          <target state="translated">P1의 RowSet 객체에서 가장 작은 값을 추출하고 해당 값을 레지스터 P3에 넣습니다. 또는 RowSet 오브젝트 P1이 초기에 비어있는 경우 P3을 변경하지 않고 명령 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6a5ecb0c6d5148842ac5a363fcb56a58341f32" translate="yes" xml:space="preserve">
          <source>FAIL</source>
          <target state="translated">FAIL</target>
        </trans-unit>
        <trans-unit id="c4aa9e5944607518b7369e543fb9270849797108" translate="yes" xml:space="preserve">
          <source>FILENAME</source>
          <target state="translated">FILENAME</target>
        </trans-unit>
        <trans-unit id="edc5934c34a6fd02ae10fbbb8d31675eb97581a4" translate="yes" xml:space="preserve">
          <source>FILTER</source>
          <target state="translated">FILTER</target>
        </trans-unit>
        <trans-unit id="7af1ca696458c2f9d5d612be97316bdd154f68d5" translate="yes" xml:space="preserve">
          <source>FILTER clause on aggregate functions</source>
          <target state="translated">집계 함수에 대한 FILTER 절</target>
        </trans-unit>
        <trans-unit id="2f20f7ce5f89c0638962299aea08b6280742c461" translate="yes" xml:space="preserve">
          <source>FIRST</source>
          <target state="translated">FIRST</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="f0de6c8aaa3f89b4cf230209af3f19827539e319" translate="yes" xml:space="preserve">
          <source>FOLLOWING</source>
          <target state="translated">FOLLOWING</target>
        </trans-unit>
        <trans-unit id="cffc20d5a5a0383f3e7092a7ee2056120936485b" translate="yes" xml:space="preserve">
          <source>FOR</source>
          <target state="translated">FOR</target>
        </trans-unit>
        <trans-unit id="2042a19d7f5fa71037019431093347e65589675e" translate="yes" xml:space="preserve">
          <source>FOR EACH ROW triggers are supported but not FOR EACH STATEMENT triggers.</source>
          <target state="translated">FOR EACH ROW 트리거는 지원되지만 FOR EACH STATEMENT 트리거는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b1916dfa796728075ee31b5fa8961f1bc7e880d" translate="yes" xml:space="preserve">
          <source>FOREIGN</source>
          <target state="translated">FOREIGN</target>
        </trans-unit>
        <trans-unit id="8e7f00cffd27676bd86f7a41b4fecf304cf6d5a6" translate="yes" xml:space="preserve">
          <source>FROM</source>
          <target state="translated">FROM</target>
        </trans-unit>
        <trans-unit id="2f6d94dfca2abdb4f6ae16ec59fb3d9a744ddcf9" translate="yes" xml:space="preserve">
          <source>FROM clause</source>
          <target state="translated">FROM 절</target>
        </trans-unit>
        <trans-unit id="c3523014e1653c50ece1aec52c268066744db929" translate="yes" xml:space="preserve">
          <source>FTS Doclist Entry Format</source>
          <target state="translated">FTS Doclist Entry 형식</target>
        </trans-unit>
        <trans-unit id="08c36c5cc18ab85c9bd2f90b127a0b924d5fe23e" translate="yes" xml:space="preserve">
          <source>FTS MATCH</source>
          <target state="translated">FTS 경기</target>
        </trans-unit>
        <trans-unit id="394841e4a088a4ee61fc03c94e00b990fb5862ce" translate="yes" xml:space="preserve">
          <source>FTS does not expose a C-function that users call to register new tokenizer types with a database handle. Instead, the pointer must be encoded as an SQL blob value and passed to FTS through the SQL engine by evaluating a special scalar function, &quot;fts3_tokenizer()&quot;. The fts3_tokenizer() function may be called with one or two arguments, as follows:</source>
          <target state="translated">FTS는 사용자가 데이터베이스 핸들을 사용하여 새 토크 나이저 유형을 등록하기 위해 호출하는 C 기능을 노출하지 않습니다. 대신, 포인터는 SQL Blob 값으로 인코딩되고 특수 스칼라 함수 &quot;fts3_tokenizer ()&quot;를 평가하여 SQL 엔진을 통해 FTS에 전달되어야합니다. fts3_tokenizer () 함수는 다음과 같이 하나 또는 두 개의 인수와 함께 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="871df7406acd230826350d29ce0b56fe491442c2" translate="yes" xml:space="preserve">
          <source>FTS hidden column</source>
          <target state="translated">FTS 숨겨진 열</target>
        </trans-unit>
        <trans-unit id="9610893255d0800ca1fe04deb4a339e0ca00a5ac" translate="yes" xml:space="preserve">
          <source>FTS is primarily designed to support Boolean full-text queries - queries to find the set of documents that match a specified criteria. However, many (most?) search applications require that results are somehow ranked in order of &quot;relevance&quot;, where &quot;relevance&quot; is defined as the likelihood that the user who performed the search is interested in a specific element of the returned set of documents. When using a search engine to find documents on the world wide web, the user expects that the most useful, or &quot;relevant&quot;, documents will be returned as the first page of results, and that each subsequent page contains progressively less relevant results. Exactly how a machine can determine document relevance based on a users query is a complicated problem and the subject of much ongoing research.</source>
          <target state="translated">FTS는 기본적으로 부울 전체 텍스트 쿼리 (지정된 조건과 일치하는 문서 집합을 찾기위한 쿼리)를 지원하도록 설계되었습니다. 그러나 많은 (대부분의) 검색 응용 프로그램에서는 결과가 &quot;관련성&quot;순서로 순위가 매겨 져야합니다. 여기서 &quot;관련성&quot;은 검색을 수행 한 사용자가 반환 된 문서 집합의 특정 요소에 관심이있을 가능성으로 정의됩니다. . 검색 엔진을 사용하여 월드 와이드 웹에서 문서를 찾을 때 사용자는 가장 유용하거나 &quot;관련된&quot;문서가 결과의 첫 번째 페이지로 리턴되며 이후의 각 페이지에는 관련성이 낮은 결과가 포함됩니다. 기계가 사용자 쿼리를 기반으로 문서 관련성을 어떻게 정확하게 결정할 수 있는지는 복잡한 문제이며 많은 연구가 진행되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3731cc0c94681dc32e8f394a102a540e99e93832" translate="yes" xml:space="preserve">
          <source>FTS queries are made up of &lt;b&gt;phrases&lt;/b&gt;. A phrase is an ordered list of one or more tokens. A string is transformed into a phrase by passing it to the FTS table tokenizer. Two phrases can be concatenated into a single large phrase using the &quot;+&quot; operator. For example, assuming the tokenizer module being used tokenizes the input &quot;one.two.three&quot; to three separate tokens, the following four queries all specify the same phrase:</source>
          <target state="translated">FTS 쿼리는 &lt;b&gt;문구로 구성&lt;/b&gt; 됩니다. 문구는 하나 이상의 토큰으로 정렬 된 목록입니다. 문자열은 FTS 테이블 토크 나이저에 전달하여 구문으로 변환됩니다. &quot;+&quot;연산자를 사용하여 두 개의 문구를 하나의 큰 문구로 연결할 수 있습니다. 예를 들어, 사용중인 토크 나이저 모듈이 입력 &quot;one.two.three&quot;를 3 개의 개별 토큰으로 토큰 화한다고 가정하면 다음 4 개의 쿼리는 모두 같은 구를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6821ce9a3c01802eb530b20fed455de131a72213" translate="yes" xml:space="preserve">
          <source>FTS query set operations using the standard query syntax are similar, but not identical, to set operations with the enhanced query syntax. There are four differences, as follows:</source>
          <target state="translated">표준 쿼리 구문을 사용하는 FTS 쿼리 세트 작업은 향상된 쿼리 구문을 사용하여 작업을 설정하는 것과 유사하지만 동일하지는 않습니다. 다음과 같은 네 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5ddc324f0381333b7d8ab01fe249ad01bbcbd2" translate="yes" xml:space="preserve">
          <source>FTS shadow tables</source>
          <target state="translated">FTS 새도우 테이블</target>
        </trans-unit>
        <trans-unit id="61a39fa7b32dd985e153046de08304dc64e8d6b3" translate="yes" xml:space="preserve">
          <source>FTS tables are populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements in the same way as ordinary SQLite tables are.</source>
          <target state="translated">FTS 테이블은 일반 SQLite 테이블과 동일한 방식으로 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="bc9a6013954064cd8ee09b12f022677a1b34ded3" translate="yes" xml:space="preserve">
          <source>FTS tables can be queried efficiently using SELECT statements of two different forms:</source>
          <target state="translated">FTS 테이블은 서로 다른 두 가지 형식의 SELECT 문을 사용하여 효율적으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b3449cd4ca843dc92a8fce9d9f69a617812f743d" translate="yes" xml:space="preserve">
          <source>FTS tables may be dropped from the database using an ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">FTS 테이블은 일반적인 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 사용하여 데이터베이스에서 삭제 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2700f1653c678e15c1bd610ec75cb2942cb94697" translate="yes" xml:space="preserve">
          <source>FTS tables permit the special alias &quot;docid&quot; to be used to refer to the rowid column supported by all &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">FTS 테이블은 특수 별칭 &quot;docid&quot;를 사용하여 모든 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에서&lt;/a&gt; 지원하는 rowid 열을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf9928f2d9fa4acc06aa91c08ff21df91f62f1a4" translate="yes" xml:space="preserve">
          <source>FTS tables support three basic query types:</source>
          <target state="translated">FTS 테이블은 세 가지 기본 쿼리 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8b6242cfa0a61ee3e024d8795a95dd14b9db1c27" translate="yes" xml:space="preserve">
          <source>FTS varints, where</source>
          <target state="translated">FTS varints, 어디서</target>
        </trans-unit>
        <trans-unit id="f3461ddc90d1b1bb49207af48336b7bdd5813a5d" translate="yes" xml:space="preserve">
          <source>FTS1 and FTS2 are obsolete full-text search modules for SQLite. There are known issues with these older modules and their use should be avoided. Portions of the original FTS3 code were contributed to the SQLite project by Scott Hess of &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;. It is now developed and maintained as part of SQLite.</source>
          <target state="translated">FTS1 및 FTS2는 SQLite에 사용되지 않는 전체 텍스트 검색 모듈입니다. 이러한 구형 모듈에는 알려진 문제가 있으므로 사용을 피해야합니다. 원래 FTS3 코드의 일부는 &lt;a href=&quot;http://www.google.com&quot;&gt;Google의&lt;/a&gt; Scott Hess가 SQLite 프로젝트에 기여했습니다 . 이제 SQLite의 일부로 개발 및 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="1227d1d0e63a5f4033dc141b8e43a11fd703a6d3" translate="yes" xml:space="preserve">
          <source>FTS3 Doclist Format</source>
          <target state="translated">FTS3 Doclist 형식</target>
        </trans-unit>
        <trans-unit id="bd1845e541762d35542373f8b784685a38b78c4a" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are SQLite virtual table modules that allows users to perform full-text searches on a set of documents. The most common (and effective) way to describe full-text searches is &quot;what Google, Yahoo, and Bing do with documents placed on the World Wide Web&quot;. Users input a term, or series of terms, perhaps connected by a binary operator or grouped together into a phrase, and the full-text query system finds the set of documents that best matches those terms considering the operators and groupings the user has specified. This article describes the deployment and usage of FTS3 and FTS4.</source>
          <target state="translated">FTS3 및 FTS4는 사용자가 일련의 문서에서 전체 텍스트 검색을 수행 할 수있는 SQLite 가상 테이블 모듈입니다. 전체 텍스트 검색을 설명하는 가장 일반적이고 효과적인 방법은 &quot;World Wide Web에있는 문서로 Google, Yahoo 및 Bing이하는 일&quot;입니다. 사용자는 이진 연산자로 연결되거나 구로 그룹화되는 용어 또는 일련의 용어를 입력하고 전체 텍스트 쿼리 시스템은 사용자가 지정한 연산자 및 그룹화를 고려하여 해당 용어와 가장 일치하는 문서 집합을 찾습니다. 이 문서에서는 FTS3 및 FTS4의 배포 및 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2683586e321c0b59cc4d1a5e41224dd20c9ed2e6" translate="yes" xml:space="preserve">
          <source>FTS3 and FTS4 are nearly identical. They share most of their code in common, and their interfaces are the same. The differences are:</source>
          <target state="translated">FTS3과 FTS4는 거의 동일합니다. 그들은 대부분의 코드를 공통으로 공유하며 인터페이스는 동일합니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e0f1a099853f641286d63551373f3ebb76f4701" translate="yes" xml:space="preserve">
          <source>FTS3 now uses the SQLite memory allocator exclusively. The FTS3 amalgamation can now be appended to the SQLite amalgamation to generate a super-amalgamation containing both.</source>
          <target state="translated">FTS3는 이제 SQLite 메모리 할당자를 독점적으로 사용합니다. FTS3 통합은 이제 SQLite 통합에 추가되어 둘 다를 포함하는 슈퍼 통합을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb71b9894746fceb2a158c4dac52d9809ff6d0b7" translate="yes" xml:space="preserve">
          <source>FTS3/4 searches for matches in column &quot;b&quot;. However, FTS5 always returns zero rows, as results are first filtered for column &quot;b&quot;, then for column &quot;a&quot;, leaving no results. In other words, in FTS3/4 the inner filter overrides the outer, in FTS5 both filters are applied.</source>
          <target state="translated">FTS3 / 4는 &quot;b&quot;열에서 일치하는 항목을 검색합니다. 그러나 결과가 먼저 &quot;b&quot;열에 대해 필터링 된 다음 &quot;a&quot;열에 대해 필터링되므로 결과는 남기지 않으므로 FTS5는 항상 제로 행을 반환합니다. 다시 말해, FTS3 / 4에서는 내부 필터가 외부 필터보다 우선하고 FTS5에서는 두 필터가 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ccbc625cc55863d7fe3ac35f55545f99e8b1be2a" translate="yes" xml:space="preserve">
          <source>FTS4</source>
          <target state="translated">FTS4</target>
        </trans-unit>
        <trans-unit id="8786db1911020bf22ede0fe9cbdf66389f4b98ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;automerge&amp;quot; command</source>
          <target state="translated">FTS4 &quot;자동 병합&quot;명령</target>
        </trans-unit>
        <trans-unit id="aac4be036956f48255e0d6a56b2b96b9a3a7bf30" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;integrity-check&amp;quot; command</source>
          <target state="translated">FTS4 &quot;무결성 검사&quot;명령</target>
        </trans-unit>
        <trans-unit id="3e393440930d32160e1b70d7854d6b3e86395412" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;merge&amp;quot; command</source>
          <target state="translated">FTS4 &quot;병합&quot;명령</target>
        </trans-unit>
        <trans-unit id="2f19e99c766323f7614141b53880d300ea6c45ba" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;optimize&amp;quot; command</source>
          <target state="translated">FTS4 &quot;최적화&quot;명령</target>
        </trans-unit>
        <trans-unit id="16282f5426f5b372e11b86b4a630da10231c0bdc" translate="yes" xml:space="preserve">
          <source>FTS4 &amp;quot;rebuild&amp;quot; command</source>
          <target state="translated">FTS4 &quot;재 구축&quot;명령</target>
        </trans-unit>
        <trans-unit id="5b2494033f24cbb7e8c72c46a490b02e62651c82" translate="yes" xml:space="preserve">
          <source>FTS4 commands</source>
          <target state="translated">FTS4 명령</target>
        </trans-unit>
        <trans-unit id="0c1d30cc05eabb84e3570704f5ba49de5062577f" translate="yes" xml:space="preserve">
          <source>FTS4 contains query performance optimizations that may significantly improve the performance of full-text queries that contain terms that are very common (present in a large percentage of table rows).</source>
          <target state="translated">FTS4에는 쿼리 성능 최적화가 포함되어있어 매우 일반적인 용어 (대부분의 테이블 행에 있음)가 포함 된 전체 텍스트 쿼리의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8950f7d9a329b6960f5d82c8a9a9464deeb6901" translate="yes" xml:space="preserve">
          <source>FTS4 content option</source>
          <target state="translated">FTS4 컨텐츠 옵션</target>
        </trans-unit>
        <trans-unit id="554686d6fd7046880b40fd6cb96c9c17cf19ab25" translate="yes" xml:space="preserve">
          <source>FTS4 currently supports the following options:</source>
          <target state="translated">FTS4는 현재 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="eb472151c42f03d5056f225e17206b4a82d9df17" translate="yes" xml:space="preserve">
          <source>FTS4 is an enhancement to FTS3. FTS3 has been available since SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04) The enhancements for FTS4 were added with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07).</source>
          <target state="translated">FTS4는 FTS3의 향상된 기능입니다. FTS3는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007-09-04) 부터 사용 가능 합니다. FTS4의 향상된 기능은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;버전 3.7.4&lt;/a&gt; (2010-12-07) 와 함께 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5a6f7ed8cfe09bc9d715086a316aa5b99dca8f26" translate="yes" xml:space="preserve">
          <source>FTS4 matchinfo option</source>
          <target state="translated">FTS4 matchinfo 옵션</target>
        </trans-unit>
        <trans-unit id="ec86c19747f79c1717c8a28fff23b033761dd3af" translate="yes" xml:space="preserve">
          <source>FTS4 notindexed option</source>
          <target state="translated">FTS4 색인화되지 않은 옵션</target>
        </trans-unit>
        <trans-unit id="3e921ff34e95c42951dd8942a87973c753d70b40" translate="yes" xml:space="preserve">
          <source>FTS4 options</source>
          <target state="translated">FTS4 옵션</target>
        </trans-unit>
        <trans-unit id="a8e5f2af307655877187a150141826300d8144ef" translate="yes" xml:space="preserve">
          <source>FTS4 order option</source>
          <target state="translated">FTS4 주문 옵션</target>
        </trans-unit>
        <trans-unit id="0fcb2dc93f56e71321e87c9db23359db95b4597d" translate="yes" xml:space="preserve">
          <source>FTS4 prefix option</source>
          <target state="translated">FTS4 접두사 옵션</target>
        </trans-unit>
        <trans-unit id="9f408dd4fbd9084cc1391c0787ebb851e43d8032" translate="yes" xml:space="preserve">
          <source>FTS4 provides hooks (the compress and uncompress &lt;a href=&quot;fts3#fts4_options&quot;&gt;options&lt;/a&gt;) allowing data to be stored in a compressed form, reducing disk usage and IO.</source>
          <target state="translated">FTS4는 데이터를 압축 된 형태로 저장하여 디스크 사용량과 IO를 줄일 수 있는 후크 (압축 및 압축 해제 &lt;a href=&quot;fts3#fts4_options&quot;&gt;옵션&lt;/a&gt; )를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49e9a9493f878486091dc5a71a19bcb1643da350" translate="yes" xml:space="preserve">
          <source>FTS4 supports some additional options that may used with the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function.</source>
          <target state="translated">FTS4는 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수 와 함께 사용할 수있는 몇 가지 추가 옵션을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c68e145499981bd93dd9ae5117fc5a005e534" translate="yes" xml:space="preserve">
          <source>FTS5 CREATE TABLE Options</source>
          <target state="translated">FTS5 CREATE TABLE 옵션</target>
        </trans-unit>
        <trans-unit id="d1c8affa7e60f64c262e7fdd55ec797b1bab87fd" translate="yes" xml:space="preserve">
          <source>FTS5 NEAR queries</source>
          <target state="translated">FTS5 NEAR 쿼리</target>
        </trans-unit>
        <trans-unit id="d7ec5657125d3bf4aacc13991c9460fc5d972d0a" translate="yes" xml:space="preserve">
          <source>FTS5 Phrases</source>
          <target state="translated">FTS5 문구</target>
        </trans-unit>
        <trans-unit id="87402b926513de360c56f04763fc517af198769a" translate="yes" xml:space="preserve">
          <source>FTS5 Strings</source>
          <target state="translated">FTS5 문자열</target>
        </trans-unit>
        <trans-unit id="25a9630f6e782a26d91f9d01bab6d7816eedadf3" translate="yes" xml:space="preserve">
          <source>FTS5 assumes the xToken() callback is invoked for each token in the order that they occur within the input text.</source>
          <target state="translated">FTS5는 xToken () 콜백이 입력 텍스트 내에서 발생하는 순서대로 각 토큰에 대해 호출된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ee357a064955e82ef52a7f67451c8f96221cc76" translate="yes" xml:space="preserve">
          <source>FTS5 automerge option</source>
          <target state="translated">FTS5 자동 병합 옵션</target>
        </trans-unit>
        <trans-unit id="8b00066098ce68d28b3e4f3e2eea468156ce3b4a" translate="yes" xml:space="preserve">
          <source>FTS5 auxiliary functions</source>
          <target state="translated">FTS5 보조 기능</target>
        </trans-unit>
        <trans-unit id="f636824fff3c89108bb6a6caaee243fe0ae7c3de" translate="yes" xml:space="preserve">
          <source>FTS5 bm25</source>
          <target state="translated">FTS5 bm25</target>
        </trans-unit>
        <trans-unit id="3e8211ca81e9935211f036b4875d83e57947df67" translate="yes" xml:space="preserve">
          <source>FTS5 boolean operators</source>
          <target state="translated">FTS5 부울 연산자</target>
        </trans-unit>
        <trans-unit id="8eea6a235e1824fe97bdfc433bcbc6776c8b413a" translate="yes" xml:space="preserve">
          <source>FTS5 building</source>
          <target state="translated">FTS5 빌딩</target>
        </trans-unit>
        <trans-unit id="201e3277761032e31d737c13966e94ec59b4d709" translate="yes" xml:space="preserve">
          <source>FTS5 column filters</source>
          <target state="translated">FTS5 컬럼 필터</target>
        </trans-unit>
        <trans-unit id="8b51c99cf722e03849ae872d3bdcf8914350160e" translate="yes" xml:space="preserve">
          <source>FTS5 columnsize option</source>
          <target state="translated">FTS5 열화 옵션</target>
        </trans-unit>
        <trans-unit id="2a3bc16c2e24994a713981c1e36673961773504f" translate="yes" xml:space="preserve">
          <source>FTS5 content option</source>
          <target state="translated">FTS5 컨텐츠 옵션</target>
        </trans-unit>
        <trans-unit id="9da11bdeb5ddec8fb2dc657759b537387eb1a485" translate="yes" xml:space="preserve">
          <source>FTS5 contentless tables</source>
          <target state="translated">FTS5 컨텐츠리스 테이블</target>
        </trans-unit>
        <trans-unit id="0a96f4a3d0cdf45a1dbfb08a0f7e83e739c0cadb" translate="yes" xml:space="preserve">
          <source>FTS5 creates the following shadow tables. In each case the actual table name is based on the name of the FTS5 virtual table (in the following table, replace &amp;lt;name&amp;gt; with the name of the virtual table to find the actual shadow table name).</source>
          <target state="translated">FTS5는 다음 새도우 테이블을 작성합니다. 각 경우에 실제 테이블 이름은 FTS5 가상 테이블의 이름을 기준으로합니다 (다음 테이블에서 &amp;lt;name&amp;gt;을 가상 테이블 이름으로 바꾸어 실제 새도우 테이블 이름을 찾으십시오).</target>
        </trans-unit>
        <trans-unit id="3c4abdc52bf6e849d3002e382b92df797ff1ab0b" translate="yes" xml:space="preserve">
          <source>FTS5 custom auxiliary functions</source>
          <target state="translated">FTS5 맞춤형 보조 기능</target>
        </trans-unit>
        <trans-unit id="f3a9fa0f7b5a65182346584a71270e7b4709456d" translate="yes" xml:space="preserve">
          <source>FTS5 delete command</source>
          <target state="translated">FTS5 삭제 명령</target>
        </trans-unit>
        <trans-unit id="de949a81f2d5b9c5a7a688724578dc7fdd75bc6d" translate="yes" xml:space="preserve">
          <source>FTS5 delete-all command</source>
          <target state="translated">FTS5 전체 삭제 명령</target>
        </trans-unit>
        <trans-unit id="adeb29e0c699543c103b6fb895630a33d9731d1c" translate="yes" xml:space="preserve">
          <source>FTS5 detail option</source>
          <target state="translated">FTS5 세부 옵션</target>
        </trans-unit>
        <trans-unit id="e2ac950517e98e9c43a54ed519912d5bd79b58f7" translate="yes" xml:space="preserve">
          <source>FTS5 external content tables</source>
          <target state="translated">FTS5 외부 컨텐츠 테이블</target>
        </trans-unit>
        <trans-unit id="e0c1249bfb2f56baeacb4cde9dabe2ee955a0b16" translate="yes" xml:space="preserve">
          <source>FTS5 features APIs allowing it to be extended by:</source>
          <target state="translated">FTS5는 다음과 같은 방법으로 API를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bd5d1681b612815e17fb206b574b31c2a015b2" translate="yes" xml:space="preserve">
          <source>FTS5 features an API allowing users to create custom auxiliary functions for advanced ranking and text processing applications. The special &quot;rank&quot; column may be mapped to a custom auxiliary function so that adding &quot;ORDER BY rank&quot; to a query works as expected.</source>
          <target state="translated">FTS5에는 API가있어 사용자가 고급 순위 및 텍스트 처리 응용 프로그램을위한 사용자 지정 보조 기능을 만들 수 있습니다. 쿼리에 &quot;ORDER BY rank&quot;를 추가하면 특수한 &quot;rank&quot;열이 사용자 지정 보조 기능에 매핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4cd24096e0f7f16f8d144ea2b9d21bbd9f59b7" translate="yes" xml:space="preserve">
          <source>FTS5 features three built-in tokenizer modules, described in subsequent sections:</source>
          <target state="translated">FTS5에는 다음 섹션에서 설명하는 세 가지 내장 토크 나이저 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2889e6384a3c8e1420d76ca5051341eea0da68" translate="yes" xml:space="preserve">
          <source>FTS5 has no matchinfo() or offsets() function, and the snippet() function is not as fully-featured as in FTS3/4. However, since FTS5 does provide an API allowing applications to create &lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;custom auxiliary functions&lt;/a&gt;, any required functionality may be implemented within the application code.</source>
          <target state="translated">FTS5에는 matchinfo () 또는 offsets () 함수가 없으며 snippet () 함수는 FTS3 / 4에서와 같이 완전히 기능하지 않습니다. 그러나 FTS5는 애플리케이션이 &lt;a href=&quot;fts5#_custom_auxiliary_functions_api_reference_&quot;&gt;사용자 정의 보조 기능&lt;/a&gt; 을 생성 할 수있는 API를 제공하므로 애플리케이션 코드 내에서 필요한 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2430fd05563889b52091adbdad5f91fa066de359" translate="yes" xml:space="preserve">
          <source>FTS5 highlight</source>
          <target state="translated">FTS5 하이라이트</target>
        </trans-unit>
        <trans-unit id="b07e20076c08544369fcb149755dcf6772db3bb0" translate="yes" xml:space="preserve">
          <source>FTS5 initial token</source>
          <target state="translated">FTS5 초기 토큰</target>
        </trans-unit>
        <trans-unit id="10930556ab62d8a86d41116bc36d163e953e4188" translate="yes" xml:space="preserve">
          <source>FTS5 initial token queries</source>
          <target state="translated">FTS5 초기 토큰 쿼리</target>
        </trans-unit>
        <trans-unit id="ce2ec7726aba85424bd14c5bd9d4baeef31bcd11" translate="yes" xml:space="preserve">
          <source>FTS5 is able to load instance-lists into memory incrementally in order to reduce memory usage and peak allocation size. FTS3/4 very often loads entire instance-lists into memory.</source>
          <target state="translated">FTS5는 메모리 사용량과 최대 할당 크기를 줄이기 위해 인스턴스 목록을 메모리에 점진적으로로드 할 수 있습니다. FTS3 / 4는 종종 전체 인스턴스 목록을 메모리에로드합니다.</target>
        </trans-unit>
        <trans-unit id="24a7aee460cc3d419d5ebe70c577eedfa6e8a962" translate="yes" xml:space="preserve">
          <source>FTS5 is an SQLite &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt; that provides &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;full-text search&lt;/a&gt; functionality to database applications. In their most elementary form, full-text search engines allow the user to efficiently search a large collection of documents for the subset that contain one or more instances of a search term. The search functionality provided to world wide web users by &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; is, among other things, a full-text search engine, as it allows users to search for all documents on the web that contain, for example, the term &quot;fts5&quot;.</source>
          <target state="translated">FTS5는 데이터베이스 응용 프로그램에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;전체 텍스트 검색&lt;/a&gt; 기능을 제공 하는 SQLite &lt;a href=&quot;c3ref/module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 입니다 . 가장 기본적인 형태로, 전체 텍스트 검색 엔진을 사용하면 하나 이상의 검색어 인스턴스를 포함하는 하위 집합에 대한 대규모 문서 모음을 효율적으로 검색 할 수 있습니다. &lt;a href=&quot;https://sqlite.org/www.google.com&quot;&gt;Google&lt;/a&gt; 이 전 세계 웹 사용자에게 제공하는 검색 기능 은 무엇보다도 사용자가 &quot;fts5&quot;라는 용어가 포함 된 웹의 모든 문서를 검색 할 수 있도록하는 전체 텍스트 검색 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="4b943e17490b34630708f8d92456b4e737500a29" translate="yes" xml:space="preserve">
          <source>FTS5 is similar to FTS3/4 in that the primary task of each is to maintain an index mapping from each unique token to a list of instances of that token within a set of documents, where each instance is identified by the document in which it appears and its position within that document. For example:</source>
          <target state="translated">FTS5는 FTS3 / 4와 유사합니다. 각각의 주요 작업은 문서 집합 내에서 각 고유 토큰에서 해당 토큰의 인스턴스 목록으로의 인덱스 매핑을 유지 관리한다는 점에서 각 인스턴스가 나타나는 문서로 식별됩니다. 문서 내에서의 위치. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28789443285151cf93711bf777483eb22fd17981" translate="yes" xml:space="preserve">
          <source>FTS5 merge command</source>
          <target state="translated">FTS5 병합 명령</target>
        </trans-unit>
        <trans-unit id="615a85fe47554c2ae2e2da14f5e902ed33d73731" translate="yes" xml:space="preserve">
          <source>FTS5 optimize command</source>
          <target state="translated">FTS5 최적화 명령</target>
        </trans-unit>
        <trans-unit id="0ce341b86f3ce708df224781d2c7103f5bb5cb9f" translate="yes" xml:space="preserve">
          <source>FTS5 pgsz option</source>
          <target state="translated">FTS5 pgsz 옵션</target>
        </trans-unit>
        <trans-unit id="69f712ff2bf8e4e1182aeec1e88d322127cc20b1" translate="yes" xml:space="preserve">
          <source>FTS5 prefix indexes</source>
          <target state="translated">FTS5 접두사 인덱스</target>
        </trans-unit>
        <trans-unit id="d94afa813a3fa1122708228da577f46e957ec4ac" translate="yes" xml:space="preserve">
          <source>FTS5 prefix queries</source>
          <target state="translated">FTS5 접두사 쿼리</target>
        </trans-unit>
        <trans-unit id="0810946526a1ee798bc7d04dda47aae0cf4f5bff" translate="yes" xml:space="preserve">
          <source>FTS5 provides three built-in auxiliary functions:</source>
          <target state="translated">FTS5는 세 가지 내장 보조 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ee68dd31a5ed538aa8658c76a53f216b8b87606d" translate="yes" xml:space="preserve">
          <source>FTS5 query syntax</source>
          <target state="translated">FTS5 쿼리 구문</target>
        </trans-unit>
        <trans-unit id="bc64d420a66889ad745e1a7998f24fa51307a32d" translate="yes" xml:space="preserve">
          <source>FTS5 rank configuration option</source>
          <target state="translated">FTS5 등급 구성 옵션</target>
        </trans-unit>
        <trans-unit id="29f161e2893c38b239a94eada76933f8fd836ec6" translate="yes" xml:space="preserve">
          <source>FTS5 rebuild command</source>
          <target state="translated">FTS5 재 구축 명령</target>
        </trans-unit>
        <trans-unit id="71972928748ce21ebd6e0c8734df3ca11afc7431" translate="yes" xml:space="preserve">
          <source>FTS5 recognizes unicode separator characters and case equivalence by default. This is also possible using FTS3/4, but must be explicitly enabled.</source>
          <target state="translated">FTS5는 기본적으로 유니 코드 구분 기호 문자와 대소 문자를 인식합니다. FTS3 / 4를 사용하여 가능하지만 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5d20fca7e87996d8a27e365e915ea0b186b5b3d" translate="yes" xml:space="preserve">
          <source>FTS5 snippet</source>
          <target state="translated">FTS5 스 니펫</target>
        </trans-unit>
        <trans-unit id="6aaed4eadfc76dccddf726837795395ef54278b6" translate="yes" xml:space="preserve">
          <source>FTS5 supports &quot;ORDER BY rank&quot; for returning results in order of decreasing relevancy.</source>
          <target state="translated">FTS5는 &quot;ORDER BY rank&quot;를 지원하여 관련성 감소 순서로 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36651526ac3e1214a373d0abfdc9f70652ada481" translate="yes" xml:space="preserve">
          <source>FTS5 tokenizers</source>
          <target state="translated">FTS5 토크 나이저</target>
        </trans-unit>
        <trans-unit id="8341dd226aacac05e80dcb41438a608e9db2f1da" translate="yes" xml:space="preserve">
          <source>FTS5 usermerge option</source>
          <target state="translated">FTS5 사용자 병합 옵션</target>
        </trans-unit>
        <trans-unit id="cc0a745dcfb4d3d66417f75affb8f4b428e7e18f" translate="yes" xml:space="preserve">
          <source>FULL</source>
          <target state="translated">FULL</target>
        </trans-unit>
        <trans-unit id="e0c9bbc8c02d4f1e95081807f3b26672caeb6804" translate="yes" xml:space="preserve">
          <source>FUNCTION( column, EXPR)</source>
          <target state="translated">기능 (열, EXPR)</target>
        </trans-unit>
        <trans-unit id="7c2813bf7bc45de9a6c2f51c171413c9b3b7a03d" translate="yes" xml:space="preserve">
          <source>Factor constant subexpressions in inner loops out to the initialization code in prepared statements.</source>
          <target state="translated">내부 루프의 상수 하위 표현식을 준비된 명령문의 초기화 코드로 인수 분해합니다.</target>
        </trans-unit>
        <trans-unit id="7437a8ac9a8406d5a28deac54292a2ceb4305a26" translate="yes" xml:space="preserve">
          <source>Factor out identifier resolution procedures into separate files.</source>
          <target state="translated">식별자 확인 절차를 별도의 파일로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="23a5e3f76b07073c425aca79699c202f18528c62" translate="yes" xml:space="preserve">
          <source>Failed attempts to open new read-transactions return SQLITE_LOCKED to the caller. If the caller then calls &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; to register for an unlock-notify callback, the blocking connection is the connection that currently has an open write-transaction on the shared-cache. This prevents writer-starvation since if no new read-transactions may be opened and assuming all existing read-transactions are eventually concluded, the writer will eventually have an opportunity to obtain the required write-lock.</source>
          <target state="translated">새 읽기 트랜잭션을 열지 못하면 SQLITE_LOCKED가 호출자에게 리턴됩니다. 그런 다음 호출자가 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 를 호출 하여 잠금 해제 알림 콜백을 등록하면 차단 연결은 현재 공유 캐시에서 열린 쓰기 트랜잭션이있는 연결입니다. 새로운 읽기 트랜잭션이 열리지 않고 기존의 모든 읽기 트랜잭션이 최종적으로 완료되었다고 가정 할 경우 라이터는 필요한 쓰기 잠금을 얻을 수있는 기회를 가지기 때문에 라이터 기아를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45820057fbefcc63da006715ab061339bc73301e" translate="yes" xml:space="preserve">
          <source>Failing to obtain the lock on database file zFilename (an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error) could be handled, and</source>
          <target state="translated">데이터베이스 파일 zFilename에 대한 잠금 획득 실패 ( &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류)를 처리 할 수 ​​있으며</target>
        </trans-unit>
        <trans-unit id="1678e559c36d96e0e24b4bf5c5d0bd9f149e7c92" translate="yes" xml:space="preserve">
          <source>Failure Related Assumption Details</source>
          <target state="translated">실패 관련 가정 세부 사항</target>
        </trans-unit>
        <trans-unit id="ba06062b405462213e6604c055442e995f85ca44" translate="yes" xml:space="preserve">
          <source>Failure to specify the schema name on the target table could result in the TEMP trigger being reattached to a table with the same name in another database whenever any schema change occurs.</source>
          <target state="translated">목표 테이블에 스키마 이름을 지정하지 않으면 스키마 변경이 발생할 때마다 TEMP 트리거가 다른 데이터베이스의 동일한 이름을 가진 테이블에 다시 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895d510880d653fd769826cbd799948f90030c9e" translate="yes" xml:space="preserve">
          <source>Fall through to next instruction if the two records compare equal to each other. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if they are different.</source>
          <target state="translated">두 레코드가 서로 동일한 경우 다음 명령어로 넘어갑니다. 다른 경우 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff9f81a83e1ed8b26c152684da1b756c9d34df23" translate="yes" xml:space="preserve">
          <source>Fall through to the next instruction the first time this opcode is encountered on each invocation of the byte-code program. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 on the second and all subsequent encounters during the same invocation.</source>
          <target state="translated">바이트 코드 프로그램을 호출 할 때마다이 opcode가 처음 발생할 때 다음 명령어로 넘어갑니다. 동일한 호출 동안 두 번째 및 이후의 모든 만남에서 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="4825fc22947a286ddae403117f576f82370ef403" translate="yes" xml:space="preserve">
          <source>Fast: In some cases, SQLite is &lt;a href=&quot;fasterthanfs&quot;&gt;faster than direct filesystem I/O&lt;/a&gt;</source>
          <target state="translated">빠름 : 경우에 따라 SQLite가 &lt;a href=&quot;fasterthanfs&quot;&gt;직접 파일 시스템 I / O보다 빠릅니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1334839ab66bd155133d078aded782ef422dd14" translate="yes" xml:space="preserve">
          <source>Faster :memory: databases</source>
          <target state="translated">빠른 : 메모리 : 데이터베이스</target>
        </trans-unit>
        <trans-unit id="6e8eee224def4d229de11ee50227cab6e1bdb960" translate="yes" xml:space="preserve">
          <source>Faster File/Save times</source>
          <target state="translated">빠른 파일 / 저장 시간</target>
        </trans-unit>
        <trans-unit id="edc218e97488ebdb256b1041d5517e07adce2150" translate="yes" xml:space="preserve">
          <source>Faster startup times</source>
          <target state="translated">빠른 시작 시간</target>
        </trans-unit>
        <trans-unit id="da9010a26d80b6d161eaff2cb859c264dae9c0df" translate="yes" xml:space="preserve">
          <source>Fear the Day of Judgment.</source>
          <target state="translated">심판의 날을 두려워하십시오.</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="9e2b53b61c236af80dd718fde93d4b9af8e005d4" translate="yes" xml:space="preserve">
          <source>Features Of SQLite</source>
          <target state="translated">SQLite의 특징</target>
        </trans-unit>
        <trans-unit id="7734fa2f4379d4b84b96b38bcc052442966db7ae" translate="yes" xml:space="preserve">
          <source>Fewer &quot;stat()&quot; system calls issued by the unix VFS.</source>
          <target state="translated">유닉스 VFS가 발행 한 &quot;stat ()&quot;시스템 호출이 적습니다.</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="ffe01d11556dbe8fb0084465da7b06965d66e721" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Header Format</source>
          <target state="translated">그림-저널 헤더 형식</target>
        </trans-unit>
        <trans-unit id="6dd00e92177e26bc00059a7fff1dc42d87cc45a9" translate="yes" xml:space="preserve">
          <source>Figure  - Journal Record Format</source>
          <target state="translated">그림-저널 레코드 형식</target>
        </trans-unit>
        <trans-unit id="714f8199965743ce58b8c530d296fe8dcfb36f8a" translate="yes" xml:space="preserve">
          <source>Figure  - Master Journal Pointer Format</source>
          <target state="translated">그림-마스터 저널 포인터 형식</target>
        </trans-unit>
        <trans-unit id="246929a593cb90f02eac87b3dc7c028c9874b4e7" translate="yes" xml:space="preserve">
          <source>Figure  - Virtual File System (VFS) Adaptor</source>
          <target state="translated">그림-가상 파일 시스템 (VFS) 어댑터</target>
        </trans-unit>
        <trans-unit id="ef3c148391912886e200c8da65ce231cc75c34aa" translate="yes" xml:space="preserve">
          <source>Figure 1</source>
          <target state="translated">그림 1</target>
        </trans-unit>
        <trans-unit id="e68cc6e58a7e19aad2d3433eb96a9f19c166acb7" translate="yes" xml:space="preserve">
          <source>Figure 1 depicts an example runtime configuration where three database connections have been established. Connection 1 is a normal SQLite database connection. Connections 2 and 3 share a cache The normal locking protocol is used to serialize database access between connection 1 and the shared cache. The internal protocol used to serialize (or not, see &quot;Read-Uncommitted Isolation Mode&quot; below) access to the shared-cache by connections 2 and 3 is described in the remainder of this section.</source>
          <target state="translated">그림 1은 세 개의 데이터베이스 연결이 설정된 런타임 구성 예를 보여줍니다. 연결 1은 일반적인 SQLite 데이터베이스 연결입니다. 연결 2와 3은 캐시를 공유합니다. 일반 잠금 프로토콜은 연결 1과 공유 캐시 사이의 데이터베이스 액세스를 직렬화하는 데 사용됩니다. 연결 2와 3을 통해 공유 캐시에 대한 액세스를 직렬화 (또는 &quot;읽지 않은 커밋되지 않은 격리 모드&quot;참조)하는 데 사용되는 내부 프로토콜은이 섹션의 나머지 부분에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b584f16a8fb3cbea584ae7660b5b6f5a1f97be" translate="yes" xml:space="preserve">
          <source>Figure 11: Lookup Using A Two-Column Index</source>
          <target state="translated">그림 11 : 2 열 색인을 사용한 조회</target>
        </trans-unit>
        <trans-unit id="afbf37b6ddde714b1aee4d493a305e7aec4b7955" translate="yes" xml:space="preserve">
          <source>Figure 12: Single-Column Lookup On A Multi-Column Index</source>
          <target state="translated">그림 12 : 다중 열 인덱스에서 단일 열 조회</target>
        </trans-unit>
        <trans-unit id="bfe311ddb5bb13bd814b1479a18292b808e35f4e" translate="yes" xml:space="preserve">
          <source>Figure 13: A Covering Index</source>
          <target state="translated">그림 13 : 취재 지수</target>
        </trans-unit>
        <trans-unit id="0f9e51f13e0722b260820ee18156800089697691" translate="yes" xml:space="preserve">
          <source>Figure 14: Query Using A Covering Index</source>
          <target state="translated">그림 14 : 포함 인덱스를 사용한 쿼리</target>
        </trans-unit>
        <trans-unit id="2ef4e6f6f7129fc9eb3442eaf5e3eb7840ee5ed8" translate="yes" xml:space="preserve">
          <source>Figure 15: Query With OR Constraints</source>
          <target state="translated">그림 15 : OR 제약 조건이있는 쿼리</target>
        </trans-unit>
        <trans-unit id="9dbf47b46e66a5e14af2bbf54935aa2349fe876c" translate="yes" xml:space="preserve">
          <source>Figure 16: Sorting Without An Index</source>
          <target state="translated">그림 16 : 인덱스없이 정렬</target>
        </trans-unit>
        <trans-unit id="8a9044fcbca9b5d94795e41004b37d420b391046" translate="yes" xml:space="preserve">
          <source>Figure 17: Sorting By Rowid</source>
          <target state="translated">그림 17 : Rowid 별 정렬</target>
        </trans-unit>
        <trans-unit id="ad71a17d48a17e81b6db9cdde1ddbd164b95a57f" translate="yes" xml:space="preserve">
          <source>Figure 18: Sorting With An Index</source>
          <target state="translated">그림 18 : 인덱스를 사용한 정렬</target>
        </trans-unit>
        <trans-unit id="83303d63b04c50c35fd21eb87917f7a1e0531bb0" translate="yes" xml:space="preserve">
          <source>Figure 19: Sorting With A Covering Index</source>
          <target state="translated">그림 19 : 커버링 인덱스를 사용한 정렬</target>
        </trans-unit>
        <trans-unit id="1eb023f1f91c9b2ae1bfb426a8d21e82d3676214" translate="yes" xml:space="preserve">
          <source>Figure 1: A Two-Column Index</source>
          <target state="translated">그림 1 : 2 열 색인</target>
        </trans-unit>
        <trans-unit id="f2ec4384a71d1b2a7bf7e591672d01dfa91b2162" translate="yes" xml:space="preserve">
          <source>Figure 1: Logical Layout Of Table &quot;FruitsForSale&quot;</source>
          <target state="translated">그림 1 : &quot;FruitsForSale&quot;테이블의 논리적 레이아웃</target>
        </trans-unit>
        <trans-unit id="3115657a64816c0a2981b799ec021faf2a045c40" translate="yes" xml:space="preserve">
          <source>Figure 20: Search And Sort By Multi-Column Index</source>
          <target state="translated">그림 20 : 다중 열 인덱스를 기준으로 검색 및 정렬</target>
        </trans-unit>
        <trans-unit id="ca0d5e8c58a01b4bec0a2aa6734f55660d0f996c" translate="yes" xml:space="preserve">
          <source>Figure 21: Search And Sort By Covering Index</source>
          <target state="translated">그림 21 : 커버링 인덱스를 기준으로 검색 및 정렬</target>
        </trans-unit>
        <trans-unit id="bf1fef781061b6dd79cd2df384db7483037947d7" translate="yes" xml:space="preserve">
          <source>Figure 22: Partial Sort By Index</source>
          <target state="translated">그림 22 : 인덱스 별 부분 정렬</target>
        </trans-unit>
        <trans-unit id="3dfec33f32a225432d9d762a93ef2ded86f5829e" translate="yes" xml:space="preserve">
          <source>Figure 2: Full Table Scan</source>
          <target state="translated">그림 2 : 전체 테이블 스캔</target>
        </trans-unit>
        <trans-unit id="b5b1774246aed49a8ebf5fcffbb1777db907fc2a" translate="yes" xml:space="preserve">
          <source>Figure 3: Lookup By Rowid</source>
          <target state="translated">그림 3 : Rowid 별 조회</target>
        </trans-unit>
        <trans-unit id="f4281cc98081d9724bc4fbb0552509706b21eb97" translate="yes" xml:space="preserve">
          <source>Figure 4: An Index On The Fruit Column</source>
          <target state="translated">그림 4 : 과일 칼럼의 색인</target>
        </trans-unit>
        <trans-unit id="bbeb4d21244b30dfdb1099da94e7d4dd047e2c7a" translate="yes" xml:space="preserve">
          <source>Figure 5: Indexed Lookup For The Price Of Peaches</source>
          <target state="translated">복숭아의 가격을위한 색인 된 조회</target>
        </trans-unit>
        <trans-unit id="6a315683f4774663431b2a906642f3e76145398c" translate="yes" xml:space="preserve">
          <source>Figure 6: Indexed Lookup For The Price Of Oranges</source>
          <target state="translated">그림 6 : 오렌지 가격에 대한 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="dfdf259371133aceb6bd0b874516d463fa04f42d" translate="yes" xml:space="preserve">
          <source>Figure 7: Indexed Lookup Of California Oranges</source>
          <target state="translated">그림 7 : 캘리포니아 오렌지의 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="92a03063612532a1d589fdacb42ff17999f75c21" translate="yes" xml:space="preserve">
          <source>Figure 8: Index On The State Column</source>
          <target state="translated">그림 8 : 상태 열의 색인</target>
        </trans-unit>
        <trans-unit id="a53d9c7f8b5017e0dc6c43dacf62cc0f65431691" translate="yes" xml:space="preserve">
          <source>Figure 9: Indexed Lookup Of California Oranges</source>
          <target state="translated">그림 9 : 캘리포니아 오렌지의 인덱스 조회</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="45f5aee1359a1f0a38b0b02e4a511dce99e49684" translate="yes" xml:space="preserve">
          <source>File Format Changes in SQLite</source>
          <target state="translated">SQLite의 파일 형식 변경</target>
        </trans-unit>
        <trans-unit id="997dfbd003e85872d78fb79873d52c3f6038b0bf" translate="yes" xml:space="preserve">
          <source>File Format Requirements Document.</source>
          <target state="translated">파일 형식 요구 사항 문서.</target>
        </trans-unit>
        <trans-unit id="893d9354b59056d10fe8938361fc3dad5acc8613" translate="yes" xml:space="preserve">
          <source>File I/O functions</source>
          <target state="translated">파일 I / O 기능</target>
        </trans-unit>
        <trans-unit id="83b27b5146777b1e521f460dd5156dedea19d489" translate="yes" xml:space="preserve">
          <source>File Locking And Concurrency In SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 파일 잠금 및 동시성</target>
        </trans-unit>
        <trans-unit id="e6d2f4a1bd6f8ec04bd3bff2e90651e6dff9e651" translate="yes" xml:space="preserve">
          <source>File Locking Levels</source>
          <target state="translated">파일 잠금 수준</target>
        </trans-unit>
        <trans-unit id="b4b1a33b7414dd35f3915ec557e071d0004461f4" translate="yes" xml:space="preserve">
          <source>File change counter.</source>
          <target state="translated">파일 변경 카운터</target>
        </trans-unit>
        <trans-unit id="273f16fa62df833bbd05d3addaa12db905e02445" translate="yes" xml:space="preserve">
          <source>File format changed back to what it was for alpha-1</source>
          <target state="translated">알파 -1 형식으로 파일 형식이 다시 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea05c62c22362e1dcec83363ef37fc1782a17fc0" translate="yes" xml:space="preserve">
          <source>File format read version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">파일 형식 읽기 버전. 레거시의 경우 1; &lt;a href=&quot;wal&quot;&gt;WAL의 경우&lt;/a&gt; 2입니다 .</target>
        </trans-unit>
        <trans-unit id="cf2b8a30295b32fb0155c82d480f8bc862559e2b" translate="yes" xml:space="preserve">
          <source>File format version number was being stored in sqlite_master.tcl multiple times. This was harmless, but unnecessary. It is now fixed.</source>
          <target state="translated">파일 형식 버전 번호가 sqlite_master.tcl에 여러 번 저장되었습니다. 이것은 무해했지만 불필요했습니다. 이제 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="982769b547928ee3535e252a5941715d91d57b18" translate="yes" xml:space="preserve">
          <source>File format version numbers</source>
          <target state="translated">파일 형식 버전 번호</target>
        </trans-unit>
        <trans-unit id="0b3c4b00be4af4f91b01dd7144c1c1ec467e2e45" translate="yes" xml:space="preserve">
          <source>File format version. Currently 3007000.</source>
          <target state="translated">파일 형식 버전. 현재 3007000입니다.</target>
        </trans-unit>
        <trans-unit id="56015cfe642c5b994cf8d2813e8f1eb0075f0f7d" translate="yes" xml:space="preserve">
          <source>File format write version. 1 for legacy; 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;.</source>
          <target state="translated">파일 형식 쓰기 버전. 레거시의 경우 1; &lt;a href=&quot;wal&quot;&gt;WAL의 경우&lt;/a&gt; 2입니다 .</target>
        </trans-unit>
        <trans-unit id="cc8f9db86cdc23665fd1d6d5d0232d3c76fe3eae" translate="yes" xml:space="preserve">
          <source>File locking states</source>
          <target state="translated">파일 잠금 상태</target>
        </trans-unit>
        <trans-unit id="faefc7760d28988aa893bf9bd1d51b407d9db702" translate="yes" xml:space="preserve">
          <source>File name/path for the zip file record.</source>
          <target state="translated">zip 파일 레코드의 파일 이름 / 경로</target>
        </trans-unit>
        <trans-unit id="8b246c552e3af3ea9fddc5a1ee446e8ed647f009" translate="yes" xml:space="preserve">
          <source>File-locking may be disabled at runtime using the sqlite3async_control() API (see below). This may improve performance when an NFS or other network file-system, as the synchronous round-trips to the server be required to establish file locks are avoided. However, if multiple connections attempt to access the same database file when file-locking is disabled, application crashes and database corruption is a likely outcome.</source>
          <target state="translated">sqlite3async_control () API를 사용하여 런타임시 파일 잠금을 비활성화 할 수 있습니다 (아래 참조). 이는 파일 잠금을 설정하기 위해 서버에 대한 동기 왕복이 필요하지 않으므로 NFS 또는 다른 네트워크 파일 시스템 인 경우 성능을 향상시킬 수 있습니다. 그러나 파일 잠금이 비활성화 된 상태에서 여러 연결이 동일한 데이터베이스 파일에 액세스하려고하면 응용 프로그램이 충돌하고 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe8dc7f14d4a14002d5ac56394cd98f360d2487" translate="yes" xml:space="preserve">
          <source>Files in the &quot;src/&quot; folder of the source tree whose names begin with &lt;b&gt;test&lt;/b&gt; are for testing only and are not included in a standard build of the library.</source>
          <target state="translated">이름이 &lt;b&gt;test&lt;/b&gt; 로 시작하는 소스 트리의 &quot;src /&quot;폴더에있는 파일은 &lt;b&gt;테스트&lt;/b&gt; 용이며 표준 라이브러리 빌드에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54710e28b3c95eb3ec7f0c24ed47099f7d873d00" translate="yes" xml:space="preserve">
          <source>Filesystem corruption</source>
          <target state="translated">파일 시스템 손상</target>
        </trans-unit>
        <trans-unit id="ae3cccd1ea022e8c58ec99f097af4626efe1d332" translate="yes" xml:space="preserve">
          <source>Filesystem corruption following a power failure might cause the journal to be renamed or deleted.</source>
          <target state="translated">정전 후 파일 시스템이 손상되면 저널 이름이 바뀌거나 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="570dc6b1cc29b82976bf6615ecf9b8e4538664c3" translate="yes" xml:space="preserve">
          <source>Finalize A Changeset Iterator</source>
          <target state="translated">변경 세트 반복자 마무리</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">동적 문자열 마무리</target>
        </trans-unit>
        <trans-unit id="9fb3423ac93edd814553ea43b04e3501220dde99" translate="yes" xml:space="preserve">
          <source>Finally use &quot;adb shell&quot; to get a shell prompt on the Android device, cd into the /data/local/tmp directory, and begin running the tests as with any other unix host.</source>
          <target state="translated">마지막으로 &quot;adb shell&quot;을 사용하여 Android 장치에서 쉘 프롬프트를 가져 와서 / data / local / tmp 디렉토리로 cd 한 후 다른 유닉스 호스트와 마찬가지로 테스트를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c3292d9cdfaf21af565aba3eaafc880851d476eb" translate="yes" xml:space="preserve">
          <source>Finally, a column filter for a single column may be specified by using the column name as the LHS of a MATCH operator (instead of the usual table name). For example:</source>
          <target state="translated">마지막으로 열 이름을 일반 테이블 이름 대신 MATCH 연산자의 LHS로 사용하여 단일 열에 대한 열 필터를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ff8d306702ac4434540ba1522c8c4827f58460b" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; have been enabled, then the alternative VFS can be specified using the &quot;vfs=&quot; parameter on the URI. This technique works with &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and when a new database is &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to an existing database connection. For example:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 이 활성화 된 경우 URI 에서 &quot;vfs =&quot;매개 변수를 사용하여 대체 VFS를 지정할 수 있습니다. 이 기술은 작동 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;) sqlite3_open_v2 (&lt;/a&gt; 새 데이터베이스가 될 때, 그리고 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 기존 데이터베이스 연결에 -ed. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91a5114fdd772d39d541271854872b37789c9cfc" translate="yes" xml:space="preserve">
          <source>Finally, if the value specified for this column is not an integer or a NULL, then it is assumed to be a UNIX permissions string similar to those output by the &quot;ls -l&quot; command (e.g. &quot;-rw-r--r--&quot;, &quot;drwxr-xr-x&quot; etc.). In this case, if the string cannot be parsed it is an error.</source>
          <target state="translated">마지막으로이 열에 지정된 값이 정수 또는 NULL이 아닌 경우 &quot;ls -l&quot;명령의 출력과 유사한 UNIX 권한 문자열 (예 : &quot;-rw-r--r- - &quot;,&quot;drwxr-xr-x &quot;등). 이 경우 문자열을 구문 분석 할 수 없으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d4cbf63195ca844a0574b0b67606533ae4726399" translate="yes" xml:space="preserve">
          <source>Finally, let us reiterate that this essay is a thought experiment. The OpenDocument format is well-established and already well-designed. Nobody really believes that OpenDocument should be changed to use SQLite as its container instead of ZIP. Nor is this article a criticism of OpenDocument for not choosing SQLite as its container since OpenDocument predates SQLite. Rather, the point of this article is to use OpenDocument as a concrete example of how SQLite can be used to build better application file formats for future projects.</source>
          <target state="translated">마지막으로,이 에세이가 사고 실험이라는 점을 다시 한 번 말씀 드리겠습니다. OpenDocument 형식은 잘 정립되어 있으며 이미 잘 설계되어 있습니다. 아무도 ZIP 대신 SQLite를 컨테이너로 사용하도록 OpenDocument를 변경해야한다고 생각하지 않습니다. 이 문서는 OpenDocument가 SQLite보다 오래 되었기 때문에 SQLite를 컨테이너로 선택하지 않았다는 OpenDocument에 대한 비판도 아닙니다. 오히려이 기사의 요점은 OpenDocument를 향후 프로젝트를 위해 더 나은 애플리케이션 파일 형식을 빌드하는 데 SQLite를 사용하는 방법에 대한 구체적인 예제로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="073894d80c5b6bf878448685b3b14eeafe3f2f87" translate="yes" xml:space="preserve">
          <source>Finally, sqlite3rbu_close() is called to close the RBU handle. If the application stopped calling sqlite3rbu_step() before either the vacuum finished or an error occurred, the state of the vacuum is saved in the state database so that it may be resumed later on.</source>
          <target state="translated">마지막으로 sqlite3rbu_close ()가 호출되어 RBU 핸들을 닫습니다. 진공이 완료되거나 오류가 발생하기 전에 애플리케이션이 sqlite3rbu_step () 호출을 중지 한 경우 진공 상태는 나중에 다시 시작할 수 있도록 상태 데이터베이스에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4a29ee7b183a9cf65e440601eae0ebf5e26ecb" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value; the same value stored in the first 8 bytes of a</source>
          <target state="translated">마지막으로 &lt;b&gt;저널 매직&lt;/b&gt; 필드에는 항상 잘 알려진 8 바이트 문자열 값이 포함됩니다. a의 첫 8 바이트에 저장된 동일한 값</target>
        </trans-unit>
        <trans-unit id="8605914ae34d83e606a255958e7dd2026ebd2652" translate="yes" xml:space="preserve">
          <source>Finally, the following requirements describe step 5 of the above procedure in more detail.</source>
          <target state="translated">마지막으로, 다음 요구 사항은 위 절차의 5 단계를보다 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a60f2db9df368ccf37180701e9147b70fddeaf82" translate="yes" xml:space="preserve">
          <source>Finally, we observe that the instrumented memory allocator and the memory leak detector both work over the entire SQLite test suite and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; provides over 99% statement test coverage and that the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness provides &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; with no leak leaks. This is strong evidence that dynamic memory allocation is used correctly everywhere within SQLite.</source>
          <target state="translated">마지막으로, 인스트루먼트 된 메모리 할당 자와 메모리 누출 감지기는 전체 SQLite 테스트 스위트에서 작동하며 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트&lt;/a&gt; 는 99 % 이상의 명령문 테스트 범위를 제공 하며 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 테스트 하니스는 누출 누출없이 &lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 범위&lt;/a&gt; 를 제공합니다. . 이는 동적 메모리 할당이 SQLite 내 어디에서나 올바르게 사용된다는 강력한 증거입니다.</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">준비된 명령문의 데이터베이스 핸들 찾기</target>
        </trans-unit>
        <trans-unit id="7a1eb68de891c44654407116abb98e458fc1bd5d" translate="yes" xml:space="preserve">
          <source>Find all check-ins with the $trunk tag and test each one to see if it is a child of $ckid.</source>
          <target state="translated">$ trunk 태그를 사용하여 모든 체크인을 찾아 각 태그를 테스트하여 $ ckid의 하위인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ed342ba1f36533ca8947f53603f475b54647d31" translate="yes" xml:space="preserve">
          <source>Find all children of check-in $ckid and test each one to see if it has the $trunk tag.</source>
          <target state="translated">체크인 $ ckid의 모든 하위 항목을 찾아 각 하위 항목에 $ trunk 태그가 있는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e070eff936a49d2ff08648583ffdfb004cab42c4" translate="yes" xml:space="preserve">
          <source>Find the name of every customer whose account number is an even multiple of 100 between 10000 and 20000.</source>
          <target state="translated">계정 번호가 10000에서 20000 사이의 100의 배수 인 모든 고객의 이름을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="da3dcd15d290d67e8d58f666d8051f5d819612a5" translate="yes" xml:space="preserve">
          <source>Find the next available sequence number for cursor P1. Write the sequence number into register P2. The sequence number on the cursor is incremented after this instruction.</source>
          <target state="translated">커서 P1에 사용 가능한 다음 시퀀스 번호를 찾으십시오. 시퀀스 번호를 레지스터 P2에 씁니다. 이 명령어 후에 커서의 시퀀스 번호가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="241d2c67f0e7de4a78cfc1411341e1cf4add0d41" translate="yes" xml:space="preserve">
          <source>Find the next prepared statement</source>
          <target state="translated">다음에 준비된 진술을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6b89ff41f23972efdb7d4d4d2879439750317194" translate="yes" xml:space="preserve">
          <source>FindFrame(P,M): Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">FindFrame (P, M) : 페이지 번호 P와 최대 WAL 프레임 인덱스 M이 주어지면 M을 초과하지 않는 페이지 P에 대해 가장 큰 WAL 프레임 인덱스를 반환하거나 페이지 P에 대해 초과하지 않는 프레임이 없으면 NULL을 반환합니다. 미디엄.</target>
        </trans-unit>
        <trans-unit id="8c22258580b7042e2985fb2531773f63cce4fbd9" translate="yes" xml:space="preserve">
          <source>Finding The Subtype Of SQL Values</source>
          <target state="translated">SQL 값의 하위 유형 찾기</target>
        </trans-unit>
        <trans-unit id="66cbda77dfc7ac64a5cc57c477b9363b8fe8ac68" translate="yes" xml:space="preserve">
          <source>Finish the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">마침 &lt;a href=&quot;vdbe&quot;&gt;VDBE 자습서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e427d7820cf1b8e5b50925cc386518036005e42d" translate="yes" xml:space="preserve">
          <source>Firebird</source>
          <target state="translated">Firebird</target>
        </trans-unit>
        <trans-unit id="74b23cbe57ab08ce3fe7d8464a6e1321304083eb" translate="yes" xml:space="preserve">
          <source>First Improvement: Replace ZIP with SQLite</source>
          <target state="translated">첫 번째 개선 : ZIP을 SQLite로 교체</target>
        </trans-unit>
        <trans-unit id="dab25715d81345a4dd48b6f14dd00623e0e7e7b5" translate="yes" xml:space="preserve">
          <source>First copy of the WAL Index Information</source>
          <target state="translated">WAL 색인 정보의 첫 번째 사본</target>
        </trans-unit>
        <trans-unit id="3fac2c84e2a48e8615e59439a4315e88bc22133f" translate="yes" xml:space="preserve">
          <source>First of all, love the Lord God with your whole heart, your whole soul, and your whole strength.</source>
          <target state="translated">우선, 온 마음과 영혼과 힘을 다해 주 하나님을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="c3afbcc4f52445143bcb3400b71a71870fa31be7" translate="yes" xml:space="preserve">
          <source>Five &quot;read marks&quot;. Each read mark is a 32-bit unsigned integer (4 bytes).</source>
          <target state="translated">&quot;읽기 표시&quot;5 개. 각 읽기 표시는 32 비트 부호없는 정수 (4 바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="ff744b4cca49b05e1cc47f0cdb68b5f181f74d45" translate="yes" xml:space="preserve">
          <source>Five out of nine columns in the ftsdocs table are updated. Two of the modified columns, &quot;idxed&quot; and &quot;name&quot;, can be updated independently of the query. But the three columns &quot;label&quot;, &quot;url&quot;, and &quot;mtime&quot; all require a join query against the &quot;event&quot; and &quot;blob&quot; tables. Without row values, the equivalent UPDATE would require that the join be repeated three times, once for each column to be updated.</source>
          <target state="translated">ftsdocs 테이블의 9 개 열 중 5 개가 업데이트됩니다. 수정 된 열 중 &quot;idxed&quot;및 &quot;name&quot;은 쿼리와 별도로 업데이트 할 수 있습니다. 그러나 &quot;label&quot;, &quot;url&quot;및 &quot;mtime&quot;열은 모두 &quot;event&quot;및 &quot;blob&quot;테이블에 대한 조인 쿼리가 필요합니다. 행 값이 없으면 동등한 UPDATE는 각 열이 갱신 될 때마다 조인을 세 번 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ce2ceb8be9681b5e40d9c6e6b6dcd07ce10b64b" translate="yes" xml:space="preserve">
          <source>Fix 1-second round-off errors in the strftime() function</source>
          <target state="translated">strftime () 함수에서 1 초 반올림 오류 수정</target>
        </trans-unit>
        <trans-unit id="be669a2be115c3851827688d94d0394bca0b79ab" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;http://www.sqlite.org/src/info/25ee812710&quot;&gt;a bug&lt;/a&gt; causing &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; statements compiled using sqlite3_prepare() to fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">수정 &lt;a href=&quot;http://www.sqlite.org/src/info/25ee812710&quot;&gt;버그를&lt;/a&gt; 일으키는 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA의 case_sensitive_like의&lt;/a&gt; 실패 할 sqlite3_prepare ()를 사용하여 컴파일 된 문 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA의&lt;/a&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e8265e2fdb9b8761b939ee47825c38858fb1ca92" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;http://www.sqlite.org/src/info/5d863f876e&quot;&gt;a bug&lt;/a&gt; involving frequent changes in and out of WAL mode and VACUUM that could (in theory) cause database corruption.</source>
          <target state="translated">이론적으로 데이터베이스 손상을 일으킬 수있는 WAL 모드 및 VACUUM의 빈번한 변경과 관련된 &lt;a href=&quot;http://www.sqlite.org/src/info/5d863f876e&quot;&gt;버그&lt;/a&gt; 를 수정 합니다 .</target>
        </trans-unit>
        <trans-unit id="6db1b858dadb915c24c32523f41d2befabc2cef1" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt; so that it does &lt;u&gt;not&lt;/u&gt; recognize ASCII form-feed as a whitespace character, in order to comply with RFC-7159. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/57eec374ae1d0a1d&quot;&gt;57eec374ae1d0a1d&lt;/a&gt;</source>
          <target state="translated">RFC-7159를 준수하기 위해 ASCII 형식 피드를 공백 문자로 인식 하지 &lt;u&gt;않도록 &lt;/u&gt;&lt;a href=&quot;json1&quot;&gt;json1 확장을&lt;/a&gt; 수정 하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/57eec374ae1d0a1d&quot;&gt;57eec374ae1d0a1d에&lt;/a&gt; 대한 수정&lt;u&gt;&lt;/u&gt;</target>
        </trans-unit>
        <trans-unit id="653e1fa5387c0ecff27de328ef34374bea516dcd" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; so that columns of type TEXT never end up holding an INT value. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f2ad7de056ab1dc9200&quot;&gt;f2ad7de056ab1dc9200&lt;/a&gt;</source>
          <target state="translated">TEXT 유형의 열이 INT 값을 보유하지 않도록 &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS를&lt;/a&gt; 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f2ad7de056ab1dc9200&quot;&gt;F2AD7DE056AB1DC9200&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="091608f8d0d4066f12489a0e4488600c5939f66b" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; so that it does not leave NULL entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; if the SELECT statement on the right-hand side aborts with an error. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</source>
          <target state="translated">오른쪽의 SELECT 문이 오류와 함께 중단되는 경우 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 에 NULL 항목을 남기지 않도록 &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS를&lt;/a&gt; 수정 하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/873cae2b6e25b&quot;&gt;873cae2b6e25b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac8940c23a1d170f8aa53744c8aaeb1be9b1ef6c" translate="yes" xml:space="preserve">
          <source>Fix &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; so that they inherit column datatypes from the table that they are defined against, when possible.</source>
          <target state="translated">가능하면 정의 된 테이블에서 열 데이터 유형을 상속하도록 &lt;a href=&quot;lang_createview&quot;&gt;뷰를&lt;/a&gt; 수정 하십시오.</target>
        </trans-unit>
        <trans-unit id="80e2c4478889733dabe7d26f6bdb0764a5389b93" translate="yes" xml:space="preserve">
          <source>Fix VACUUM so that it works with AUTOINCREMENT.</source>
          <target state="translated">AUTOINCREMENT와 함께 작동하도록 VACUUM을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c07848937a890999ea4da3f0e665f2c7a3794556" translate="yes" xml:space="preserve">
          <source>Fix VDBE stack overflow problems with INSTEAD OF triggers and NULLs in IN operators.</source>
          <target state="translated">IN 연산자에서 INSTEAD OF 트리거 및 NULL로 VDBE 스택 오버 플로우 문제를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="55121f8a7129cf78265426bfd91d90add437aa1d" translate="yes" xml:space="preserve">
          <source>Fix a #define that prevented &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; from compiling</source>
          <target state="translated">&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 가 컴파일 되지 못하게하는 #define 수정</target>
        </trans-unit>
        <trans-unit id="13e6ad7999531a4c075a28adfff4eeebc2c1045e" translate="yes" xml:space="preserve">
          <source>Fix a 16-month-old bug in the query planner that could generate incorrect results when a scalar subquery attempts to use the &lt;a href=&quot;queryplanner#partialsort&quot;&gt;block sorting&lt;/a&gt; optimization. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/cb3aa0641d9a4&quot;&gt;cb3aa0641d9a4&lt;/a&gt;.</source>
          <target state="translated">스칼라 하위 쿼리가 &lt;a href=&quot;queryplanner#partialsort&quot;&gt;블록 정렬&lt;/a&gt; 최적화 를 사용하려고 시도 할 때 쿼리 플래너에서 16 개월 된 버그를 수정하여 잘못된 결과를 생성 할 수 있습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/cb3aa0641d9a4&quot;&gt;cb3aa0641d9a4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce67b37c5c15e62d47883a4360d92e7b7a4edca0" translate="yes" xml:space="preserve">
          <source>Fix a 32-bit integer overflow problem that could result in corrupt indices in a database if large negative numbers (less than -2147483648) were inserted into an indexed numeric column.</source>
          <target state="translated">색인화 된 숫자 열에 큰 음수 (-2147483648 미만)가 삽입 된 경우 데이터베이스에서 인덱스가 손상 될 수있는 32 비트 정수 오버 플로우 문제점을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f159ffac47049907d64d00a20c1c1b2dcba7ac" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; problem with the &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 로 &lt;a href=&quot;datatype3#affinity&quot;&gt;열 선호도&lt;/a&gt; 문제를 해결하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/9a8b09f8e6&quot;&gt;9a8b09f8e6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c700ca4bfcd722334b41ae90cb174f21fd61403d" translate="yes" xml:space="preserve">
          <source>Fix a &lt;a href=&quot;http://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;bug&lt;/a&gt; introduced in &lt;a href=&quot;#version_3_7_10&quot;&gt;version 3.7.10&lt;/a&gt; that might cause a LEFT JOIN to be incorrectly converted into an INNER JOIN if the WHERE clause indexable terms connected by OR.</source>
          <target state="translated">WHERE 절이 OR로 연결된 색인 가능한 용어 인 경우 LEFT JOIN이 INNER JOIN으로 잘못 변환 될 수 있는 &lt;a href=&quot;#version_3_7_10&quot;&gt;버전 3.7.10에&lt;/a&gt; 도입 된 &lt;a href=&quot;http://www.sqlite.org/src/info/b7c8682cc1&quot;&gt;버그를&lt;/a&gt; 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b3da353b2f72b307d534809a0843fba3651f875" translate="yes" xml:space="preserve">
          <source>Fix a NULL pointer dereference in ATTACH/DETACH following a maliciously constructed syntax error. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2f1b168ab4d4844&quot;&gt;2f1b168ab4d4844&lt;/a&gt;.</source>
          <target state="translated">악의적으로 생성 된 구문 오류에 따라 ATTACH / DETACH에서 NULL 포인터 역 참조를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/2f1b168ab4d4844&quot;&gt;2f1b168ab4d4844&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17fc4210b6dfacb182d91554ad786d32ff022dca" translate="yes" xml:space="preserve">
          <source>Fix a NULL-pointer dereference/crash that could occurs when a transitive WHERE clause references a non-existent collating sequence. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e8d439c77685eca6&quot;&gt;e8d439c77685eca6&lt;/a&gt;.</source>
          <target state="translated">전 이적 WHERE 절이 존재하지 않는 조합 순서를 참조 할 때 발생할 수있는 NULL 포인터 역 참조 / 충돌을 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/e8d439c77685eca6&quot;&gt;e8d439c77685eca6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d9ac49b0e2e7ef5de936abd680dc68a27fa30a0" translate="yes" xml:space="preserve">
          <source>Fix a backwards compatibility problem in version 3.12.0 and 3.12.1: Columns declared as &lt;code&gt;&quot;INTEGER&quot; PRIMARY KEY&lt;/code&gt; (with quotes around the datatype keyword) were not being recognized as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, which resulted in an incompatible database file. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7d7525cb01b68&quot;&gt;7d7525cb01b68&lt;/a&gt;</source>
          <target state="translated">버전 3.12.0 및 3.12.1의 이전 버전과의 호환성 문제 수정 : &lt;code&gt;&quot;INTEGER&quot; PRIMARY KEY&lt;/code&gt; (데이터 유형 키워드를 따옴표 로 묶음)로 선언 된 열 이 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 로 인식 되지 않아 데이터베이스 파일이 호환되지 않습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7d7525cb01b68&quot;&gt;7d7525cb01b68&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a0318a8c44e81fefd0856134a5f3fbaa5501b8f" translate="yes" xml:space="preserve">
          <source>Fix a blunder in the Unix mutex implementation that can lead to deadlock on multithreaded systems.</source>
          <target state="translated">멀티 스레드 시스템에서 교착 상태를 유발할 수있는 Unix mutex 구현의 실수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="be0de15ce56f51daac8ff3913d5b4688f8feba74" translate="yes" xml:space="preserve">
          <source>Fix a boundary condition error introduced by version 3.12.0 that can result in a crash during heavy &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; usage. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7f7f8026eda38&quot;&gt;7f7f8026eda38&lt;/a&gt;.</source>
          <target state="translated">버전 3.12.0에 의해 도입 된 경계 조건 오류를 수정하여 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT를&lt;/a&gt; 많이 사용 하는 동안 충돌이 발생할 수 있습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7f7f8026eda38&quot;&gt;7f7f8026eda38&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be5dcc6b578060cb5dc3ca4c23baedea5a1b2470" translate="yes" xml:space="preserve">
          <source>Fix a buffer overread that might occur if &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; is used to query a corrupt database file.</source>
          <target state="translated">경우에 발생할 수있는 버퍼 overread 수정 &lt;a href=&quot;fts5&quot;&gt;FTS5을&lt;/a&gt; 를 사용하여 손상된 데이터베이스 파일을 쿼리하는 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca2f1fb1d0cfb02ea2efcffdd2e281055a42ff0e" translate="yes" xml:space="preserve">
          <source>Fix a buffer-overrun problem in &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; which occurs when a string without a zero-terminator is passed to &quot;%.*s&quot;.</source>
          <target state="translated">에서 버퍼 오버런 문제 해결 &lt;a href=&quot;c3ref/mprintf&quot;&gt;&lt;/a&gt;제로 종결자가없는 문자열이 &quot;%. * s&quot;에 전달 될 때 발생하는 sqlite3_mprintf () .</target>
        </trans-unit>
        <trans-unit id="fb7444fa62b4ee35a92c0c428d8d337f76386f0f" translate="yes" xml:space="preserve">
          <source>Fix a bug (discovered by OSSFuzz) that causes an assertion fault if certain dodgy CREATE TABLE declarations are used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/bc115541132dad136&quot;&gt;bc115541132dad136&lt;/a&gt;</source>
          <target state="translated">특정 dodgy CREATE TABLE 선언을 사용하는 경우 어설 션 오류를 유발하는 버그 (OSSFuzz에서 발견)를 수정합니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/bc115541132dad136&quot;&gt;bc115541132dad136&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e41d5ca51e4539e3e6f67be481f8af26cda08c2" translate="yes" xml:space="preserve">
          <source>Fix a bug (present since &lt;a href=&quot;#version_3_9_0&quot;&gt;version 3.9.0&lt;/a&gt;) that can cause the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation to miss rows if &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; is turned on. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a306e56ff68b8fa5&quot;&gt;a306e56ff68b8fa5&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; 가 설정된 경우 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 작업에서 행이 누락 될 수 있는 버그 ( &lt;a href=&quot;#version_3_9_0&quot;&gt;버전 3.9.0&lt;/a&gt; 부터 존재 함)를 수정합니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/a306e56ff68b8fa5&quot;&gt;A306E56FF68B8FA5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54d44af51dd9a421c7ecd0eded2acf535ab0d495" translate="yes" xml:space="preserve">
          <source>Fix a bug (present since version 3.7.13) that could result in database corruption on windows if two or more processes try to access the same database file at the same time and immediately after third process crashed in the middle of committing to that same file. See ticket &lt;a href=&quot;http://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt; for further information.</source>
          <target state="translated">두 개 이상의 프로세스가 같은 데이터베이스 파일에 동시에 액세스하려고 할 때와 같은 파일을 커밋하는 도중에 세 번째 프로세스가 중단 된 직후에 Windows에서 데이터베이스가 손상 될 수있는 버그 (버전 3.7.13부터 존재 함)를 수정합니다. . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/7ff3120e4f&quot;&gt;7ff3120e4f&lt;/a&gt; 참조 를 .</target>
        </trans-unit>
        <trans-unit id="52cd073d277867a6532709b039582ead6364202d" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2273) that could cause a segfault when the IN operator is used one one term of a two-column index and the right-hand side of the IN operator contains a NULL.</source>
          <target state="translated">IN 연산자가 2 열 인덱스의 한 용어 중 하나를 사용하고 IN 연산자의 오른쪽에 NULL이 포함 된 경우 segfault를 유발할 수있는 버그 (티켓 # 2273)를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="1b4373a8bed1703d94011bbf7b01bd3bd2002f0a" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2913) that prevented virtual tables from working in a LEFT JOIN. The problem was introduced into shortly before the 3.5.5 release.</source>
          <target state="translated">가상 테이블이 왼쪽 조인에서 작동하지 못하게하는 버그 (티켓 # 2913)를 수정합니다. 이 문제는 3.5.5 릴리스 직전에 소개되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9815ddc115669106a2e918a17fe2c7f8f2e58b3" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #2927) in the register allocation for compound selects - introduced by the new VM code in version 3.5.5.</source>
          <target state="translated">버전 3.5.5의 새 VM 코드에 의해 도입 된 복합 선택에 대한 레지스터 할당에서 버그 (티켓 # 2927)를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0251ebbb4578c3eee40a3a6252b33652a004ab77" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket #3929) that occasionally causes INSERT or UPDATE operations to fail on an indexed table that has a self-modifying trigger.</source>
          <target state="translated">자체 수정 트리거가있는 색인화 된 테이블에서 때때로 INSERT 또는 UPDATE 조작이 실패하는 버그 (티켓 # 3929)를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="d3832aaea84b1f718a1bb048238cd8a3bc9bc19d" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt;) that causes rows to go missing on some queries with OR clauses and IS NOT NULL operators in the WHERE clause, when the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time options are used.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 타임 옵션이 사용될 때 WHERE 절에서 OR 절 및 IS NOT NULL 연산자가있는 일부 쿼리에서 행이 누락 되는 버그 (티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;4c86b126f2&lt;/a&gt; )를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cf57837bbedc091bf1a9a8a86eff54c1cbf0549" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;https://sqlite.org/www.sqlite.org/src/tktview/d02e1406a58ea02d&quot;&gt;[d02e1406a58ea02d]]&lt;/a&gt;) that causes a segfault on a LEFT JOIN that includes an OR in the ON clause.</source>
          <target state="translated">ON 절에 OR을 포함하는 LEFT JOIN에서 segfault를 유발 하는 버그 (티켓 &lt;a href=&quot;https://sqlite.org/www.sqlite.org/src/tktview/d02e1406a58ea02d&quot;&gt;[d02e1406a58ea02d]]&lt;/a&gt; )를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="150bcf2022457384fa67a29e77f678763b594e30" translate="yes" xml:space="preserve">
          <source>Fix a bug (ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2326c258d02ead33&quot;&gt;2326c258d02ead33&lt;/a&gt;) that can lead to incorrect results if the qualifying constraint of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; appears in the ON clause of a LEFT JOIN.</source>
          <target state="translated">LEFT JOIN의 ON 절에 &lt;a href=&quot;partialindex&quot;&gt;부분 색인&lt;/a&gt; 의 규정 제한 조건이 나타나는 경우 잘못된 결과를 초래할 수 있는 버그 (티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/2326c258d02ead33&quot;&gt;2326c258d02ead33&lt;/a&gt; )를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a970cab6c15ff586a60a11ea992ea839f10ae97" translate="yes" xml:space="preserve">
          <source>Fix a bug &lt;a href=&quot;http://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;(ticket c2ad16f997)&lt;/a&gt; in the 3.7.12 release that can cause a segfault for certain obscure nested aggregate queries.</source>
          <target state="translated">버그 수정 &lt;a href=&quot;http://www.sqlite.org/src/info/c2ad16f997ee9c&quot;&gt;(티켓 c2ad16f997)&lt;/a&gt;3.7.12 릴리스 를 모호한 중첩 집계 쿼리에 대해 segfault를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ba96e9b687649d1638a02359c366ad11eb2427" translate="yes" xml:space="preserve">
          <source>Fix a bug associated with &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; that can lead to database corruption. The bug was introduced in &lt;a href=&quot;#version_3_16_0&quot;&gt;version 3.16.0&lt;/a&gt; (2017-01-02). Ticket &lt;a href=&quot;https://sqlite.org/src/info/fda22108&quot;&gt;fda22108&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 손상을 일으킬 수 있는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 와 관련된 버그를 수정하십시오 . 이 버그는 &lt;a href=&quot;#version_3_16_0&quot;&gt;버전 3.16.0&lt;/a&gt; (2017-01-02) 에서 도입되었습니다 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/fda22108&quot;&gt;fda22108&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b307eb453950463be890be400bcb57bcc52631d" translate="yes" xml:space="preserve">
          <source>Fix a bug causing a crash when a &lt;a href=&quot;windowfunctions&quot;&gt;window function&lt;/a&gt; is misused. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/4feb3159c6bc3f7e33959&quot;&gt;4feb3159c6bc3f7e33959&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 을 잘못 사용할 때 충돌을 일으키는 버그를 수정합니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/4feb3159c6bc3f7e33959&quot;&gt;4feb3159c6bc3f7e33959&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cee5afa83d7f05f4fb0199eac752e1fa6d08e720" translate="yes" xml:space="preserve">
          <source>Fix a bug concerning the use of &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt; within &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; (see ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8c9458e7&quot;&gt;8c9458e7&lt;/a&gt;) that was in version 3.15.0 but was not reported until moments after the 3.16.0 release was published.</source>
          <target state="translated">버전 3.15.0에 있지만 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 가 3.16.0 릴리스 이후 게시 될 때까지보고되지 않은 트리거 내 ( &lt;a href=&quot;https://www.sqlite.org/src/info/8c9458e7&quot;&gt;8c9458e7&lt;/a&gt; 참조) &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 사용과 관련된 버그를 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="71975cabda8207d03e62b70b052c839461a12d21" translate="yes" xml:space="preserve">
          <source>Fix a bug effecting DELETE and UPDATE statements that changed more than 40960 rows.</source>
          <target state="translated">40960 개 이상의 행이 변경된 DELETE 및 UPDATE 문에 영향을주는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="c19062438eee134d4fd76768c8b829db307bd8b6" translate="yes" xml:space="preserve">
          <source>Fix a bug in 3.7.6 that only appears if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; file control is used with a build of SQLite that makes use of the HAVE_POSIX_FALLOCATE compile-time option and which has SQLITE_ENABLE_LOCKING_MODE turned off.</source>
          <target state="translated">3.7.6에서 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; 파일 컨트롤이 HAVE_POSIX_FALLOCATE 컴파일 타임 옵션을 사용하고 SQLITE_ENABLE_LOCKING_MODE가 해제 된 SQLite 빌드와 함께 사용되는 경우에만 나타나는 버그를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="58bd3a61dd215f4dc0de8f7e4c69f4281129c76a" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;#version_3_6_12&quot;&gt;version 3.6.12&lt;/a&gt; that causes a segfault that when inserting into a table using a DEFAULT value where there is a function as part of the DEFAULT value expression. Ticket #3791.</source>
          <target state="translated">DEFAULT 값 표현식의 일부로 함수가있는 DEFAULT 값을 사용하여 테이블에 삽입 할 때 segfault를 발생시키는 &lt;a href=&quot;#version_3_6_12&quot;&gt;버전 3.6.12&lt;/a&gt; 의 버그를 수정하십시오 . 티켓 # 3791.</target>
        </trans-unit>
        <trans-unit id="12af322bb1c5c6e90dac936b110cd29e40c242c1" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;#version_3_6_12&quot;&gt;version 3.6.12&lt;/a&gt; that causes a segfault when running a count(*) on the sqlite_master table of an empty database. Ticket #3774.</source>
          <target state="translated">빈 데이터베이스의 sqlite_master 테이블에서 count (*)를 실행할 때 segfault를 발생시키는 &lt;a href=&quot;#version_3_6_12&quot;&gt;버전 3.6.12&lt;/a&gt; 의 버그를 수정하십시오 . 티켓 # 3774.</target>
        </trans-unit>
        <trans-unit id="8c7bed4eabe4f021221bdbe53bf5d864f6a114c5" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; that was causing it to sometimes fail to print an SQL statement if that statement needed to be re-prepared. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 에서 해당 명령문을 다시 준비해야하는 경우 SQL 문을 인쇄하지 못하는 버그를 수정했습니다 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/11d5aa455e0d98f3c1e6a08&quot;&gt;11d5aa455e0d98f3c1e6a08&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52d2997db72cd3a48af4f7a4ac02cf3d05df11b7" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_aggfunc#groupconcat&quot;&gt;group_concat()&lt;/a&gt;, ticket #3841</source>
          <target state="translated">티켓 # 3841, &lt;a href=&quot;lang_aggfunc#groupconcat&quot;&gt;group_concat ()&lt;/a&gt; 의 버그 수정</target>
        </trans-unit>
        <trans-unit id="ee7b9b5fa7ce3740b16e9a62ff83417f288103a2" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt;, introduced when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; support added in version 3.8.2, that allows a non-unique NOT NULL column to be given a UNIQUE index. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITH ROWID&lt;/a&gt; 지원이 버전 3.8.2에 추가되어 고유하지 않은 NOT NULL 열에 UNIQUE 인덱스가 제공 될 때 도입 된 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; 버그를 수정하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/9a6daf340df99ba93c&quot;&gt;9a6daf340df99ba93c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0f89fd8501d868e0cf1692fe6c2c59b7af31e92" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; that can lead to database corruptio if two processes are connected to the database at the same time and one VACUUMs then the other then modifies the database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 에서 두 프로세스가 동시에 데이터베이스에 연결되어 있고 하나의 VACUUM이 다른 하나가 데이터베이스를 수정하면 데이터베이스가 손상 될 수 있는 버그 를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="f19b1530d0c7e58f2b87f9576dc8b2e836f21fd1" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;, introduced in the previous release, that can cause an incorrect results for queries that use the rowid of the R-Tree on the left-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;d2889096e7bdeac6&lt;/a&gt;.</source>
          <target state="translated">이전 릴리스에서 소개 된 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 의 버그를 수정 하여 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 왼쪽에서 R-Tree의 rowid를 사용하는 쿼리에 대해 잘못된 결과가 발생할 수 있습니다 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/d2889096e7bdeac6&quot;&gt;D2889096E7BDEAC6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9932e1bb4a31444134a7372fbfdfb3c865e3fba" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation that causes a crash if an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table is &lt;a href=&quot;lang_droptable&quot;&gt;dropped&lt;/a&gt; inside a transaction and a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; occurs afterwards.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 테이블이 트랜잭션 내부에서 &lt;a href=&quot;lang_droptable&quot;&gt;삭제&lt;/a&gt; 되고 이후에 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 가 발생할 경우 충돌을 일으키는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 버그를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="51aaba302afca30eafb8d628825b7a74d833e817" translate="yes" xml:space="preserve">
          <source>Fix a bug in &lt;b&gt;CREATE TEMPORARY TABLE&lt;/b&gt; which was causing the table to be initially allocated in the main database file instead of in the separate temporary file. This bug could cause the library to suffer an assertion failure and it could cause &quot;page leaks&quot; in the main database file.</source>
          <target state="translated">&lt;b&gt;CREATE TEMPORARY TABLE&lt;/b&gt; 의 버그를 수정 하여 테이블이 별도의 임시 파일 대신 기본 데이터베이스 파일에 처음 할당되었습니다. 이 버그로 인해 라이브러리에 어설 션 오류가 발생하여 기본 데이터베이스 파일에서 &quot;페이지 누수&quot;가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="463c4702a2f65488e2ffd92dbf1a4aa6269d0eb8" translate="yes" xml:space="preserve">
          <source>Fix a bug in ASCII-to-float conversion that causes slow performance and incorrect results when converting numbers with ridiculously large exponents.</source>
          <target state="translated">엄청나게 큰 지수를 가진 숫자를 변환 할 때 성능 저하 및 잘못된 결과를 초래하는 ASCII에서 부동 변환으로의 버그를 수정</target>
        </trans-unit>
        <trans-unit id="4c4bce3264601fae2f025bed0d43c0268a99d3c6" translate="yes" xml:space="preserve">
          <source>Fix a bug in LEFT OUTER JOIN</source>
          <target state="translated">LEFT OUTER JOIN의 버그 수정</target>
        </trans-unit>
        <trans-unit id="88cb3ba799e20b9ecbe117ccfd853b21e199cf11" translate="yes" xml:space="preserve">
          <source>Fix a bug in SELECT that occurs when a compound SELECT is used as a subquery in the FROM of a SELECT.</source>
          <target state="translated">SELECT의 FROM에서 복합 SELECT를 하위 쿼리로 사용할 때 발생하는 SELECT 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4a083d6c3036b42a4c0efc997cf20ef0d02f9455" translate="yes" xml:space="preserve">
          <source>Fix a bug in VACUUM and UNIQUE indices.</source>
          <target state="translated">VACUUM 및 UNIQUE 지수의 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="7f833cb1ccdd0e046fb058717b1c7c3e8a6a93cd" translate="yes" xml:space="preserve">
          <source>Fix a bug in WHERE clauses of the form (rowid</source>
          <target state="translated">양식의 WHERE 절에서 버그 수정 (rowid</target>
        </trans-unit>
        <trans-unit id="4b37ff9629cc27cedfa263e877ae5948961807f2" translate="yes" xml:space="preserve">
          <source>Fix a bug in Windows locking code so that locks work correctly when simultaneously accessed by Win95 and WinNT systems.</source>
          <target state="translated">Win95 및 WinNT 시스템에서 동시에 액세스 할 때 잠금이 올바르게 작동하도록 Windows 잠금 코드의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c6465c2fd0a22ca7d523a1361542f1e8ac2184b4" translate="yes" xml:space="preserve">
          <source>Fix a bug in aggregate functions for VIEWs.</source>
          <target state="translated">VIEW에 대한 집계 함수의 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="ea88e4155c22c256804a9df119ef6c90513e2203" translate="yes" xml:space="preserve">
          <source>Fix a bug in autovacuum that could cause database corruption if a CREATE UNIQUE INDEX fails because of a constraint violation. This problem only occurs if the new autovacuum feature introduced in version 3.1 is turned on.</source>
          <target state="translated">제약 조건 위반으로 인해 CREATE UNIQUE INDEX가 실패하는 경우 데이터베이스 손상을 일으킬 수있는 autovacuum의 버그를 수정하십시오. 버전 3.1에 도입 된 새로운 자동 진공 기능이 켜져있는 경우에만이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a378ba86069bf3761c418cd389173a889e823d3" translate="yes" xml:space="preserve">
          <source>Fix a bug in how the IN operator handles NULLs in subqueries. The bug was introduced by the previous release.</source>
          <target state="translated">IN 연산자가 하위 쿼리에서 NULL을 처리하는 방식의 버그를 수정합니다. 버그는 이전 릴리스에서 소개되었습니다.</target>
        </trans-unit>
        <trans-unit id="a112d7c17f6c64f21968d448b366da95b043faa4" translate="yes" xml:space="preserve">
          <source>Fix a bug in that would cause a null pointer to be dereferenced if a column with a DEFAULT that is an aggregate function tried to usee its DEFAULT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</source>
          <target state="translated">집계 함수 인 DEFAULT가있는 열이 DEFAULT를 사용하려고하면 null 포인터가 역 참조되는 버그가 수정되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/3a88d85f36704eebe1&quot;&gt;3a88d85f36704eebe1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dce4995a552b14017cf9c95aedef49ecc7e0fcc0" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &quot;expr IN ()&quot; operator.</source>
          <target state="translated">&quot;expr IN ()&quot;연산자의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="3794a44c73175a8cc1f66ea61529235aef7d447e" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &quot;table_info&quot; pragma&quot;</source>
          <target state="translated">&quot;table_info&quot;pragma &quot;에서 버그 수정</target>
        </trans-unit>
        <trans-unit id="c46340ccacfe48d973d04aab053595f54cf0a1ae" translate="yes" xml:space="preserve">
          <source>Fix a bug in the 'start of ...' modifiers for the &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6097cb92745327a1&quot;&gt;6097cb92745327a1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 에 대한 'start of ...'수정 자의 버그를 수정 합니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6097cb92745327a1&quot;&gt;6097cb92745327a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="047f4b2943991074c70108eded61dc0dd05be0b9" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; implementation that can lead to a corrupt backup database. Ticket #3858.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; 구현에서 손상된 백업 데이터베이스로 이어질 수 있는 버그를 수정하십시오 . 티켓 # 3858.</target>
        </trans-unit>
        <trans-unit id="1aae6b9bfc01515c152e99bd1e5ab1e6f3636945" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; that might cause a segfault for nested queries that use the new &lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;FILTER clause on aggregate functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1079ad19993d13fa&quot;&gt;1079ad19993d13fa&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;집계 함수&lt;/a&gt; 에서 새 FILTER 절 을 사용하는 중첩 쿼리에 대해 segfault를 유발할 수 있는 &lt;a href=&quot;optoverview#flattening&quot;&gt;쿼리 병합 기&lt;/a&gt; 의 버그를 수정 합니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/1079ad19993d13fa&quot;&gt;1079ad19993d13fa&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17cdc3977288de667446f3b87cd5b853f5d5e34" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;optoverview#minmax&quot;&gt; min()/max() optimization&lt;/a&gt; when applied to descending indices.</source>
          <target state="translated">&lt;a href=&quot;optoverview#minmax&quot;&gt;min () / max () 최적화&lt;/a&gt; 버그 수정내림차순 지수에 적용될 때 .</target>
        </trans-unit>
        <trans-unit id="df21276a9ba4f70e8b56ddb1521cb4531a3918b1" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; implementation that might result in an incorrect answer if a partial index is used in a subquery or in a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt;.</source>
          <target state="translated">부분 인덱스가 하위 쿼리 나 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 에서 사용되는 경우 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 구현 에서 버그가 수정되어 오답이 발생할 수있는 문제를 해결 합니다 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/98d973b8f5&quot;&gt;98d973b8f5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bb0056e629f96818c6e4e0e13be98af5234d969" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;b&gt;-separator&lt;/b&gt; command-line option to the &lt;b&gt;sqlite&lt;/b&gt; command.</source>
          <target state="translated">&lt;b&gt;-separator&lt;/b&gt; 명령 행 옵션 의 버그를 &lt;b&gt;sqlite&lt;/b&gt; 명령으로 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="d6bed961ccdc56f2047390095f85abd5dbafe7d0" translate="yes" xml:space="preserve">
          <source>Fix a bug in the &lt;b&gt;sqlite&lt;/b&gt; shell program that was causing a coredump when the output mode was &quot;column&quot; and the first row of data contained a NULL.</source>
          <target state="translated">출력 모드가 &quot;열&quot;이고 첫 번째 데이터 행에 NULL이 포함 된 경우 코어 덤프를 발생시키는 &lt;b&gt;sqlite&lt;/b&gt; 쉘 프로그램 의 버그를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7ee300f0b9aa623b87a2f7c0becbea03f86667f" translate="yes" xml:space="preserve">
          <source>Fix a bug in the GLOB operator that was preventing it from working with upper-case letters.</source>
          <target state="translated">대문자로 작업하지 못하게하는 GLOB 연산자의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="a793203fc0cd2f8d82f6bb2c04af0a35278a79a3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the IN operator that was introduced by an attempted optimization in version 3.27.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/df46dfb631f75694&quot;&gt;df46dfb631f75694&lt;/a&gt;</source>
          <target state="translated">버전 3.27.0에서 최적화 시도로 인해 도입 된 IN 연산자의 버그를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/df46dfb631f75694&quot;&gt;df46dfb631f75694&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a2b2aae8dc76f1b662e734a37e06cc3bb736c0a2" translate="yes" xml:space="preserve">
          <source>Fix a bug in the IS NULL optimization that was added in version 3.3.9 - the bug was causing incorrect results on certain LEFT JOINs that included in the WHERE clause an IS NULL constraint for the right table of the LEFT JOIN.</source>
          <target state="translated">버전 3.3.9에 추가 된 IS NULL 최적화 버그 수정-버그가 WHERE 절에 포함 된 특정 LEFT JOIN에서 LEFT JOIN의 오른쪽 테이블에 대한 IS NULL 제약 조건에 잘못된 결과를 초래했습니다.</target>
        </trans-unit>
        <trans-unit id="32b2ca59c98e57defc81fa337a98f052b51fdc62" translate="yes" xml:space="preserve">
          <source>Fix a bug in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/cad1ab4cb7b0fc&quot;&gt;cad1ab4cb7b0fc&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 버그를 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/cad1ab4cb7b0fc&quot;&gt;cad1ab4cb7b0fc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38685e288bff59c882db6ca759d7bfb29309f44e" translate="yes" xml:space="preserve">
          <source>Fix a bug in the LIKE optimizer that occurs when the last character before the first wildcard is an upper-case &quot;Z&quot;</source>
          <target state="translated">LIKE 옵티 마이저에서 첫 번째 와일드 카드 앞의 마지막 문자가 대문자 &quot;Z&quot;일 때 발생하는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="c45bdef943497947610b6f15bb60f3f8c0bf760c" translate="yes" xml:space="preserve">
          <source>Fix a bug in the NEAR operator of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; when applied to subfields. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt;.</source>
          <target state="translated">서브 필드에 적용될 때 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 의 NEAR 연산자의 버그를 수정하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/38b1ae018f&quot;&gt;38b1ae018f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbe8c363630fb44f795b5ddd0d6782543a6fe85a" translate="yes" xml:space="preserve">
          <source>Fix a bug in the ORDER BY clause optimizer for joins where the left-most table in the join is constrained by a UNIQUE index.</source>
          <target state="translated">조인의 가장 왼쪽 테이블이 UNIQUE 인덱스에 의해 제한되는 조인에 대한 ORDER BY 절 옵티마이 저의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="aa7ce008f89c153b1eace05cd426c962ecd2e761" translate="yes" xml:space="preserve">
          <source>Fix a bug in the ORDER BY logic that was introduced in version 2.7.0</source>
          <target state="translated">버전 2.7.0에 도입 된 ORDER BY 로직의 버그 수정</target>
        </trans-unit>
        <trans-unit id="23821f33e4999e66f2f0641e1828f40a34f1ba2d" translate="yes" xml:space="preserve">
          <source>Fix a bug in the RTRIM collating sequence.</source>
          <target state="translated">RTRIM 조합 순서의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="f7f484abe5d349b673cad3a8de0d61afd71cebdb" translate="yes" xml:space="preserve">
          <source>Fix a bug in the SQLITE_SECURE_DELETE option that was causing Firefox crashes. Make arrangements to always test SQLITE_SECURE_DELETE prior to each release.</source>
          <target state="translated">Firefox 충돌을 일으킨 SQLITE_SECURE_DELETE 옵션의 버그를 수정하십시오. 각 릴리스 전에 항상 SQLITE_SECURE_DELETE를 테스트하도록 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="6940928d96820acfbcbd9f40b16f8c38b9024a13" translate="yes" xml:space="preserve">
          <source>Fix a bug in the VDBE code generator that caused crashes when doing an INSERT INTO ... SELECT statement where the number of columns being inserted is larger than the number of columns in the destination table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;e9654505cfd&lt;/a&gt;</source>
          <target state="translated">삽입되는 열 수가 대상 테이블의 열 수보다 큰 INSERT INTO ... SELECT 문을 수행 할 때 충돌을 일으킨 VDBE 코드 생성기의 버그를 수정합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/e9654505cfda9&quot;&gt;E9654505cfd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a77d823ed51c71db80398e891bdd02b6519c7cf3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree delete algorithm that seems like it might be able to cause database corruption. The bug was first introduced in &lt;a href=&quot;#version_3_6_6&quot;&gt;version 3.6.6&lt;/a&gt; by check-in [5899] on 2008-11-13.</source>
          <target state="translated">데이터베이스 손상을 일으킬 수있는 것처럼 보이는 b-tree delete 알고리즘의 버그를 수정하십시오. 버그는 2008-11-13의 체크인 [5899]에 의해 &lt;a href=&quot;#version_3_6_6&quot;&gt;버전 3.6.6&lt;/a&gt; 에서 처음 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1f2e950889f0b3e1a67070b1b57e16286bf69c2d" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree logic that can result in incorrect duplicate answers for IN operator queries. Ticket &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;</source>
          <target state="translated">IN 연산자 쿼리에 대해 잘못된 중복 답변을 초래할 수있는 b- 트리 논리의 버그를 수정합니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f057be07a38c5126040dd7ba0d2e89c56925fd1" translate="yes" xml:space="preserve">
          <source>Fix a bug in the b-tree subsystem that could sometimes cause the first row of a table to be repeated during a database scan.</source>
          <target state="translated">데이터베이스 검색 중에 때때로 테이블의 첫 번째 행이 반복 될 수있는 b- 트리 하위 시스템의 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3878c223944534bca090e7e00dd247a414b7a6aa" translate="yes" xml:space="preserve">
          <source>Fix a bug in the code generator that can cause incorrect results if two or more &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; are joined and the virtual table used in outer loop of the join has an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt; constraint.</source>
          <target state="translated">두 개 이상의 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 이 조인되고 조인의 외부 루프에 사용 된 가상 테이블에 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 제약 조건 이있는 경우 코드 생성기의 버그가 수정되어 잘못된 결과가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc69c155beef2c0a01905468a8453d4d607f81a" translate="yes" xml:space="preserve">
          <source>Fix a bug in the configure script.</source>
          <target state="translated">configure 스크립트의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="e769bec58aa8644f68bd5d7d1bfe1cc29fa2dac6" translate="yes" xml:space="preserve">
          <source>Fix a bug in the fts3 snippet() function causing it to omit leading separator characters from snippets that begin with the first token in a column.</source>
          <target state="translated">fts3 snippet () 함수의 버그를 수정하여 열의 첫 번째 토큰으로 시작하는 스 니펫에서 선행 분리 문자를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="2545295866be036cf8499a7ef858658efd552656" translate="yes" xml:space="preserve">
          <source>Fix a bug in the handling of &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; errors that could lead to database corruption. Ticket #2686.</source>
          <target state="translated">데이터베이스 손상으로 이어질 수 있는 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 처리에서 버그를 수정하십시오 . 티켓 # 2686.</target>
        </trans-unit>
        <trans-unit id="9e5c8f1eaffe30d733afa2edd14eb7426ae21825" translate="yes" xml:space="preserve">
          <source>Fix a bug in the handling of UTF16 codepoint 0xE000</source>
          <target state="translated">UTF16 코드 포인트 0xE000 처리시 버그 수정</target>
        </trans-unit>
        <trans-unit id="4c6d887f63dbb405c7a71cd63e8fbd9d52e03a50" translate="yes" xml:space="preserve">
          <source>Fix a bug in the locking protocol.</source>
          <target state="translated">잠금 프로토콜의 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="6f0cf8c78b30d2944aa061b217d1b3f9efdadbb3" translate="yes" xml:space="preserve">
          <source>Fix a bug in the offsets() function of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 의 offsets () 함수의 버그 수정</target>
        </trans-unit>
        <trans-unit id="6a7fee3c78838e4aef23ba9632b4dc89c4818959" translate="yes" xml:space="preserve">
          <source>Fix a bug in the optimization that attempts to omit unused LEFT JOINs</source>
          <target state="translated">사용하지 않는 LEFT JOIN을 생략하려는 최적화 버그 수정</target>
        </trans-unit>
        <trans-unit id="5b06586dcca4e61d320a961a9e47d8eb276b85a7" translate="yes" xml:space="preserve">
          <source>Fix a bug in the page cache that can lead database corruption following a rollback. This bug was first introduced in &lt;a href=&quot;#version_3_6_4&quot;&gt;version 3.6.4&lt;/a&gt;.</source>
          <target state="translated">롤백 후 데이터베이스가 손상 될 수있는 페이지 캐시 버그를 수정합니다. 이 버그는 &lt;a href=&quot;#version_3_6_4&quot;&gt;버전 3.6.4&lt;/a&gt; 에서 처음 소개되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a46e1e49b7340ac0ed74db8ca87feecde1f4308f" translate="yes" xml:space="preserve">
          <source>Fix a bug in the query optimizer: an adverse interaction between the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; and the optimization that tries to use values read directly from an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; instead of recomputing the expression. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/4e8e4857d32d401f&quot;&gt;4e8e4857d32d401f&lt;/a&gt;</source>
          <target state="translated">쿼리 최적화 프로그램의 버그 수정 : &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화&lt;/a&gt; 와 &lt;a href=&quot;expridx&quot;&gt;표현식&lt;/a&gt; 을 다시 계산하는 대신 표현식 인덱스 에서 직접 읽은 값을 사용하려는 최적화 간의 불리한 상호 작용 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/4e8e4857d32d401f&quot;&gt;4e8e4857d32d401f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f3e2194be3728297cf8e6d4eddf0e2da5b578f9" translate="yes" xml:space="preserve">
          <source>Fix a bug in the sorting logic, present since version 3.8.4, that can cause output to appear in the wrong order on queries that contains an ORDER BY clause, a LIMIT clause, and that have approximately 60 or more columns in the result set. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=f97c4637102a3ae72b79&quot;&gt;f97c4637102a3ae72b79&lt;/a&gt;.</source>
          <target state="translated">ORDER BY 절, LIMIT 절을 포함하고 결과 집합에 약 60 개 이상의 열이있는 쿼리에서 출력이 잘못된 순서로 나타날 수있는 버전 3.8.4 이후의 정렬 논리 버그를 수정합니다. . 티켓&lt;a href=&quot;https://www.sqlite.org/src/tktview?name=f97c4637102a3ae72b79&quot;&gt; f97c4637102a3ae72b79&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="961b61911dc711c8f8610e6dbfb97dc726ab74a3" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in 3.3.14 that caused a rollback of CREATE TEMP TABLE to leave the database connection wedged.</source>
          <target state="translated">CREATE TEMP TABLE의 롤백으로 인해 데이터베이스 연결이 연결되지 않는 버그가 3.3.14에서 소개되었습니다.</target>
        </trans-unit>
        <trans-unit id="7dafd437c5fe093f21f82604a02e45e665b33614" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in 3.6.18 that can lead to a segfault when an attempt is made to write on a read-only database.</source>
          <target state="translated">읽기 전용 데이터베이스에 쓰려고 할 때 segfault로 이어질 수있는 3.6.18에 도입 된 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3e91e6207d38fe47800880c516d9f8186320c567" translate="yes" xml:space="preserve">
          <source>Fix a bug introduced in the previous release that can cause a segfault while generating code for complex WHERE clauses.</source>
          <target state="translated">복잡한 WHERE 절에 대한 코드를 생성하는 동안 segfault를 일으킬 수있는 이전 릴리스에 도입 된 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4cbb196a2e1220a7bdeefef09bd59463fa0805e1" translate="yes" xml:space="preserve">
          <source>Fix a bug that can cause database corruption if a VACUUM (or autovacuum) fails and is rolled back on a database that is larger than 1GiB</source>
          <target state="translated">VACUUM (또는 autovacuum)이 실패하고 1GiB보다 큰 데이터베이스에서 롤백되는 경우 데이터베이스 손상을 일으킬 수있는 버그 수정</target>
        </trans-unit>
        <trans-unit id="8fcffb46aac4ff97bedf3b9e6f64e13ea5d224e0" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error occurs in the middle of an explicit transaction and that transaction is later committed. Ticket #2409.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY 인&lt;/a&gt; 경우 데이터베이스 손상으로 이어질 수있는 버그 수정명시 적 트랜잭션 도중에 오류가 발생하고 해당 트랜잭션이 나중에 커밋 된 . 티켓 # 2409.</target>
        </trans-unit>
        <trans-unit id="f0062262db2ebf6b0dc42f784bd0016892cca702" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if autovacuum mode is on and a malloc() failure follows a CREATE TABLE or CREATE INDEX statement which itself follows a cache overflow inside a transaction. See ticket #2418.</source>
          <target state="translated">autovacuum 모드가 켜져 있고 malloc () 실패가 CREATE TABLE 또는 CREATE INDEX 문을 따라 트랜잭션 자체의 캐시 오버플로를 따르는 경우 데이터베이스 손상으로 이어질 수있는 버그를 수정합니다. 티켓 # 2418을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57d88d579c18e5b4924089be5a9ae175983b00fb" translate="yes" xml:space="preserve">
          <source>Fix a bug that can lead to database corruption if there are two open connections to the same database and one connection does a VACUUM and the second makes some change to the database.</source>
          <target state="translated">동일한 데이터베이스에 대한 두 개의 열린 연결이 있고 하나의 연결이 VACUUM을 수행하고 두 번째는 데이터베이스를 변경하면 데이터베이스가 손상 될 수있는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="235d3ce4d5053a3a3ebb175799b3496bb1e2bca5" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; values to be truncated when inserted into a table that uses an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bb4bdb9f7f654b0bb9&quot;&gt;bb4bdb9f7f654b0bb9&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;식 인덱스&lt;/a&gt; 를 사용하는 테이블에 삽입 할 때 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; 값이 잘리는 버그를 수정했습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/bb4bdb9f7f654b0bb9&quot;&gt;bb4bdb9f7f654b0bb9&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f87f69bef7402ec8819762f3097cf3cb4bc0c8" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to fail if the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; was engaged.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma 인&lt;/a&gt; 경우 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 이 실패 하는 버그 수정 가 관여 된 .</target>
        </trans-unit>
        <trans-unit id="22063eb55417c5408e7943413ae415aaa6bc0f18" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused VACUUM to fail if NULLs appeared in a UNIQUE column.</source>
          <target state="translated">UNIQUE 열에 NULL이 나타나면 VACUUM이 실패하는 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="b01b0578c2bd5ee379e0164996215a5a9e5cafe9" translate="yes" xml:space="preserve">
          <source>Fix a bug that caused an extra NULL row to be returned when a descending query was interrupted by a change to the database.</source>
          <target state="translated">데이터베이스 변경으로 인해 내림차순 쿼리가 중단 될 때 여분의 NULL 행이 반환되는 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="071533ebdec27c28688ac540bc6a87af7b306521" translate="yes" xml:space="preserve">
          <source>Fix a bug that causes incorrect results in aggregate queries that use multiple aggregate functions whose arguments contain complicated expressions that differ only in the case of string literals contained within those expressions.</source>
          <target state="translated">인수에 해당 표현식 내에 포함 된 문자열 리터럴의 경우에만 다른 복잡한 표현식이 포함 된 여러 집계 함수를 사용하는 집계 쿼리에서 잘못된 결과를 초래하는 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="e234d8c8772201f75d48e658f96b976e70db46a8" translate="yes" xml:space="preserve">
          <source>Fix a bug that could (rarely) cause the database to become unreadable after a DROP TABLE due to corruption to the SQLITE_MASTER table.</source>
          <target state="translated">SQLITE_MASTER 테이블의 손상으로 인해 DROP TABLE 후에 데이터베이스를 읽을 수 없게되는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4d0709824aa035da84b355852a499807973fe8eb" translate="yes" xml:space="preserve">
          <source>Fix a bug that could cause database corruption when inserting record into tables with around 125 columns.</source>
          <target state="translated">약 125 개의 열이있는 테이블에 레코드를 삽입 할 때 데이터베이스가 손상 될 수있는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a150aeb08b356b152ddea42ccaf4421a6b9641d1" translate="yes" xml:space="preserve">
          <source>Fix a bug that could cause index corruption when an attempt to delete rows of a table is blocked by a pending query.</source>
          <target state="translated">보류중인 쿼리에 의해 테이블의 행을 삭제하려는 시도가 차단 될 때 인덱스 손상을 일으킬 수있는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3e8b7620d6c7d85e18e5166d221c692cea660029" translate="yes" xml:space="preserve">
          <source>Fix a bug that might cause duplicate output rows when an IN operator is used in the WHERE clause. Ticket &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt;.</source>
          <target state="translated">IN 연산자가 WHERE 절에 사용될 때 중복 된 출력 행을 유발할 수있는 버그를 수정합니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/61fe9745&quot;&gt;61fe9745&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1129d4f4c65ec87058e64f0efea0bacc49cf4128" translate="yes" xml:space="preserve">
          <source>Fix a bug that prevent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... RENAME&lt;/a&gt; from working on some virtual tables in a database with a UTF16 encoding.</source>
          <target state="translated">UTF16 인코딩으로 데이터베이스의 일부 가상 테이블에서 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... RENAME&lt;/a&gt; 이 작동 하지 않는 버그를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="219da8cf0cf50a7385bd113afe9758749614f5f4" translate="yes" xml:space="preserve">
          <source>Fix a bug that prevented the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check&lt;/a&gt; pragmas from working correctly if their names were capitalized.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check&lt;/a&gt; pragma의 이름이 대문자 인 경우 제대로 작동 하지 않던 버그를 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="cdefb813daa0922ae7c9b101c4e520cb5ad8e08f" translate="yes" xml:space="preserve">
          <source>Fix a bug that was causing the optimizer to miss an OR optimization opportunity</source>
          <target state="translated">옵티마이 저가 OR 최적화 기회를 놓치게하는 버그 수정</target>
        </trans-unit>
        <trans-unit id="3ee4681350e42b37480225b05e910c31df54b667" translate="yes" xml:space="preserve">
          <source>Fix a bug that was causing the precompiled binary of SQLITE.EXE to report &quot;out of memory&quot; under Windows 98.</source>
          <target state="translated">사전 컴파일 된 SQLITE.EXE 바이너리가 Windows 98에서 &quot;메모리 부족&quot;을보고하게하는 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="b4696dc19dc4ef79e67cd457b6f5dd7958efb5b4" translate="yes" xml:space="preserve">
          <source>Fix a bug that will might corrupt the rollback journal if a power failure or external program halt occurs in the middle of a COMMIT. The corrupt journal can lead to database corruption when it is rolled back.</source>
          <target state="translated">COMMIT 도중에 정전 또는 외부 프로그램 정지가 발생할 경우 롤백 저널을 손상시킬 수있는 버그를 수정하십시오. 손상된 저널은 롤백 될 때 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe26500762fc616cee225a47a0d139acf639f85" translate="yes" xml:space="preserve">
          <source>Fix a bug which could cause database corruption during a rollback. This bugs was introduced in version 2.4.0 by the freelist optimization of checkin [410].</source>
          <target state="translated">롤백 중에 데이터베이스가 손상 될 수있는 버그를 수정하십시오. 이 버그는 버전 2.4.0에서 체크인의 프리리스트 최적화 [410]에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="968c6618094d057d35f26f676f0f017e389d2400" translate="yes" xml:space="preserve">
          <source>Fix a bug which prevented deferred foreign key constraints from being enforced when &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; was not called by one statement with a failed foreign key constraint prior to another statement with foreign key constraints running.</source>
          <target state="translated">외래 키 제약 조건이 실행되는 다른 명령문에 앞서 외래 키 제약 조건이 실패한 명령문에서 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 호출되지 않은 경우 지연된 외래 키 제약 조건이 적용 되지 않는 버그를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="a9887b88380d05a17b65b1ccb749514ab2085ef9" translate="yes" xml:space="preserve">
          <source>Fix a bug which was causing the UPDATE command to fail on systems where &quot;malloc(0)&quot; returns NULL. The problem does not appear on Windows, Linux, or HPUX but does cause the library to fail on QNX.</source>
          <target state="translated">&quot;malloc (0)&quot;이 NULL을 반환하는 시스템에서 UPDATE 명령이 실패하던 버그를 수정했습니다. Windows, Linux 또는 HPUX에서는 문제가 나타나지 않지만 QNX에서 라이브러리가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c1055cb4316f59caf76e0609241062a76fd13540" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes a segfault if the AS name of a result column of a SELECT statement is used as a logical term in the WHERE clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt;.</source>
          <target state="translated">SELECT 문 결과 열의 AS 이름이 WHERE 절에서 논리 용어로 사용되는 경우 &lt;a href=&quot;#version_3_7_15&quot;&gt;버전 3.7.15에&lt;/a&gt; 도입 된 버그를 수정하여 segfault를 발생시킵니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/a7b7803e8d1e869&quot;&gt;a7b7803e8d1e869&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e34d4a301d86656b94178e76078ea4244568334" translate="yes" xml:space="preserve">
          <source>Fix a bug, introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt;, that causes an ORDER BY clause to be optimized out of a three-way join when the ORDER BY is actually required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#version_3_7_15&quot;&gt;버전 3.7.15에&lt;/a&gt; 도입 된 ORDER BY 절이 실제로 필요할 때 ORDER BY 절이 3 방향 조인에서 최적화되도록 하는 버그를 수정하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/598f5f7596b055&quot;&gt;598f5f7596b055&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb89133b15e7a026f1baf9b7fe301f81fe1d3d95" translate="yes" xml:space="preserve">
          <source>Fix a byte alignment problem on 64-bit Sparc machines.</source>
          <target state="translated">64 비트 Sparc 시스템에서 바이트 정렬 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="6473e2522b76dc29f2ba1c3b0d9873c89f59958f" translate="yes" xml:space="preserve">
          <source>Fix a cache coherency problem that could lead to database corruption. Ticket #3584.</source>
          <target state="translated">데이터베이스 손상으로 이어질 수있는 캐시 일관성 문제를 해결하십시오. 티켓 # 3584.</target>
        </trans-unit>
        <trans-unit id="f481ad2c49e362e89cd9792732a32d8df98fae76" translate="yes" xml:space="preserve">
          <source>Fix a case (present since 3.8.0 - 2013-08-26) where OR-connected terms in the ON clause of a LEFT JOIN might cause incorrect results. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34a579141b2c5ac&quot;&gt;34a579141b2c5ac&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN의 ON 절에 OR로 연결된 용어가 잘못된 결과를 초래할 수있는 경우를 수정합니다 (3.8.0-2013-08-26 이후). 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/34a579141b2c5ac&quot;&gt;34a579141b2c5ac&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a50086fd665b1844f9cbf74b7aa34cea2f9e72f" translate="yes" xml:space="preserve">
          <source>Fix a case where the use of &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt; in the ON clause of a LEFT JOIN might cause incorrect results. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/fef4bb4bd9185ec8f&quot;&gt;fef4bb4bd9185ec8f&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN의 ON 절에서 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 을 사용 하면 잘못된 결과가 발생할 수있는 문제를 해결합니다. &lt;a href=&quot;https://www.sqlite.org/src/info/fef4bb4bd9185ec8f&quot;&gt;fef4bb4bd9185ec8f&lt;/a&gt; 티켓 .</target>
        </trans-unit>
        <trans-unit id="850a9a02fc22a5dd385d30f0d1ad0aee11fcbb3d" translate="yes" xml:space="preserve">
          <source>Fix a code generator bug introduced in &lt;a href=&quot;#version_3_6_14&quot;&gt;version 3.6.14&lt;/a&gt;. This bug can cause incorrect query results under obscure circumstances. Ticket #3879.</source>
          <target state="translated">&lt;a href=&quot;#version_3_6_14&quot;&gt;버전 3.6.14&lt;/a&gt; 에서 도입 된 코드 생성기 버그를 수정하십시오 . 이 버그로 인해 모호한 상황에서 잘못된 쿼리 결과가 발생할 수 있습니다. 티켓 # 3879.</target>
        </trans-unit>
        <trans-unit id="7a882216b94af4a2070d74e5a8f2213bc7c7e6d4" translate="yes" xml:space="preserve">
          <source>Fix a code generator bug that occurs when the left-hand side of an IN operator is constant and the right-hand side is a SELECT statement</source>
          <target state="translated">IN 연산자의 왼쪽이 일정하고 오른쪽이 SELECT 문인 경우 발생하는 코드 생성기 버그 수정</target>
        </trans-unit>
        <trans-unit id="9f3aff5bff9f1047fcb33e054774693e6c093317" translate="yes" xml:space="preserve">
          <source>Fix a configuration problem for HPUX.</source>
          <target state="translated">HPUX 구성 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="c2e54ff806a6902137c2c4fd9a054e09b463f65d" translate="yes" xml:space="preserve">
          <source>Fix a configuration program for WinNT.</source>
          <target state="translated">WinNT 구성 프로그램을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="23af7692a6ff84f6d023153258d882cbb37a308d" translate="yes" xml:space="preserve">
          <source>Fix a couple of problems associated with running an UPDATE or DELETE on a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; with a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; in the WHERE clause.</source>
          <target state="translated">에 UPDATE 또는 DELETE 실행과 관련된 몇 가지 문제 해결 &lt;a href=&quot;lang_createview&quot;&gt;VIEW를&lt;/a&gt; 로모그래퍼 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; WHERE 절에 있습니다.</target>
        </trans-unit>
        <trans-unit id="250b9893a36b233fbf22987bf8f6ae81bb4e4fd3" translate="yes" xml:space="preserve">
          <source>Fix a crash that can occur following an out-of-memory condition in the built-in &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr()&lt;/a&gt; function.</source>
          <target state="translated">내장 &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr ()&lt;/a&gt; 함수 에서 메모리 부족 상태에 따라 발생할 수있는 충돌을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bf5e6293bb28bf946bc8a30fe12004cac2b4090" translate="yes" xml:space="preserve">
          <source>Fix a critical bug in UPDATE or DELETE that occurs when an OR REPLACE clause or a trigger causes rows in the same table to be deleted as side effects. (See ticket #2832.) The most likely result of this bug is a segmentation fault, though database corruption is a possibility.</source>
          <target state="translated">OR REPLACE 절 또는 트리거로 인해 같은 테이블의 행이 부작용으로 삭제 될 때 발생하는 UPDATE 또는 DELETE의 중요한 버그를 수정합니다. (티켓 # 2832 참조)이 버그의 가장 큰 결과는 데이터베이스 손상일 가능성이 있지만 분할 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b9fcf5056d43d3f414de5f5ffa794d580179047a" translate="yes" xml:space="preserve">
          <source>Fix a critical bug introduced into 2.8.0 which could cause database corruption.</source>
          <target state="translated">2.8.0에 도입 된 중요한 버그를 수정하여 데이터베이스 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6104ea2315fdf5ec79a2a34465e1d850ba0d687d" translate="yes" xml:space="preserve">
          <source>Fix a database corruption bug that might occur if a ROLLBACK command is executed in &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto-vacuum mode&lt;/a&gt; and a very small &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit&lt;/a&gt; is set. Ticket #2565.</source>
          <target state="translated">ROLLBACK 명령이 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;자동 진공 모드&lt;/a&gt; 에서 실행되고 매우 작은 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit&lt;/a&gt; 가 설정된 경우 발생할 수있는 데이터베이스 손상 버그를 수정하십시오 . 티켓 # 2565.</target>
        </trans-unit>
        <trans-unit id="549a524d06c92ebec7e6ffb1582d9efa4f972e29" translate="yes" xml:space="preserve">
          <source>Fix a faulty assert() statement discovered by OSSFuzz. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">OSSFuzz에서 발견 한 잘못된 assert () 문을 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8894e23611b9543c06bdf188b997836d648e35ed" translate="yes" xml:space="preserve">
          <source>Fix a faulty assert() statement. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</source>
          <target state="translated">잘못된 assert () 문을 수정하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/369d57fb8e5ccdff06f1&quot;&gt;369d57fb8e5ccdff06f1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="636e1cdce08fa0db48343c6add77567a882165ff" translate="yes" xml:space="preserve">
          <source>Fix a few bugs discovered while adding test cases</source>
          <target state="translated">테스트 사례를 추가하는 동안 발견 된 몇 가지 버그 수정</target>
        </trans-unit>
        <trans-unit id="acf902b397dd2f6810f6423a62c7af2c0994b48b" translate="yes" xml:space="preserve">
          <source>Fix a harmless TSAN warning associated with the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly ()&lt;/a&gt; 인터페이스 와 관련된 무해한 TSAN 경고를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="81f5e5474510cb05b9499ec918f7ec055d5a9376" translate="yes" xml:space="preserve">
          <source>Fix a harmless compiler warning that was causing problems for VS2013.</source>
          <target state="translated">VS2013에 문제를 일으키는 무해한 컴파일러 경고를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="2655086c46a997c2b6b5f7afcdb8bc73a701e203" translate="yes" xml:space="preserve">
          <source>Fix a harmless reference to an uninitialized virtual machine register. Ticket &lt;a href=&quot;https://sqlite.org/src/info/093420fc0eb7cba7&quot;&gt;093420fc0eb7cba7&lt;/a&gt;.</source>
          <target state="translated">초기화되지 않은 가상 머신 레지스터에 대한 무해한 참조를 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/093420fc0eb7cba7&quot;&gt;093420fc0eb7cba7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34aba552e98280ade2ad01a58c129c559bbb6622" translate="yes" xml:space="preserve">
          <source>Fix a harmless warning in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on some versions of MSVC.</source>
          <target state="translated">일부 버전의 MSVC에서는 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 무해한 경고를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbae4bd36201745ce6091bd306e15a27174abe7" translate="yes" xml:space="preserve">
          <source>Fix a locking problem on multi-threaded Linux implementations.</source>
          <target state="translated">다중 스레드 Linux 구현에서 잠금 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1b59f0eebd0deebb37ffe61aff53f12ea768f8" translate="yes" xml:space="preserve">
          <source>Fix a locking race condition in Windows that can occur when two or more processes attempt to recover the same &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; at the same time.</source>
          <target state="translated">둘 이상의 프로세스가 동일한 &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;핫 저널&lt;/a&gt; 을 동시에 복구하려고 할 때 발생할 수있는 잠금 경쟁 조건을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="17e68593b4791e7bd7d4208e13b7223230a1abc9" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in INSERT INTO ... SELECT ... statements where the SELECT is compound.</source>
          <target state="translated">SELECT가 복합적인 INSERT INTO ... SELECT ... 문에서 오랜 버그 수정</target>
        </trans-unit>
        <trans-unit id="fd962c6fc1c64a845409232765bfdaeb36f664fe" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in RAISE(IGNORE) as used in BEFORE triggers.</source>
          <target state="translated">BEFORE 트리거에 사용 된 RAISE (IGNORE)의 오래된 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5983823f14e9a5e5ea15cf21202053241c588d81" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; that would recognize UTF16 characters as digits even if their most-significant-byte was not zero. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 바이트가 0이 아니더라도 UTF16 문자를 숫자로 인식 하는 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식의&lt;/a&gt; 오랜 버그를 수정하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/689137afb6da41&quot;&gt;689137afb6da41&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e421af2a92eeb75b68bc6dee75d2cded7fea49f" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the query planner that caused incorrect results on a LEFT JOIN where the left-hand table is a subquery and the join constraint is a bare column name coming from the left-hand subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;.</source>
          <target state="translated">왼쪽 테이블이 하위 쿼리이고 조인 제약 조건이 왼쪽 하위 쿼리에서 나오는 기본 열 이름 인 LEFT JOIN에서 잘못된 결과를 초래 한 쿼리 플래너의 오랜 버그를 수정합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd66bb0d12f0c4694325a08e38b8332a42b240a" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">스토리지 엔진에서 SQLITE_CORRUPT 오류에 대한 가짜 보고서를 생성하지만 (해당 치 않은) 무해한 오래된 버그를 수정하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71423e6b2d68869ba9f90d3de52635f50c9c7337" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem in &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that was reported a few hours after the 3.8.11 release.</source>
          <target state="translated">3.8.11 릴리스 후 몇 시간 동안보고 된 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대한 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()의&lt;/a&gt; 오랜 문제점을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e8d63f91df6bbd58bdb3b0c96b08a128597488" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem wherein a corrupt schema on the &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; table used by &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; can lead to a crash. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT에서&lt;/a&gt; 사용 하는 &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; 테이블 의 손상된 스키마 가 충돌을 일으킬 수 있는 오랜 문제를 해결하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d123dda0b40a993f6ee01005258efb1310831bb" translate="yes" xml:space="preserve">
          <source>Fix a memory allocation error in the new ADD COLUMN comment.</source>
          <target state="translated">새 ADD COLUMN 주석의 메모리 할당 오류를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="557f85fef49a7d6b5ef7280b85eaabf9d86a9cbc" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a disk I/O error.</source>
          <target state="translated">디스크 I / O 오류 다음에 발생할 수있는 메모리 누수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e50e850f4bad5e2b888790e4a27dda05de65d0" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a failure to open error in the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블&lt;/a&gt; 에서 오류를 열지 못한 후 발생할 수있는 메모리 누수 수정</target>
        </trans-unit>
        <trans-unit id="08e2d33c27f7ca8760cc5e591fecb5972898df17" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that occurred when sqlite_open() failed.</source>
          <target state="translated">sqlite_open ()이 실패했을 때 발생한 메모리 누수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="475ca6beba2ec99949495af6c237c0b95d23fba9" translate="yes" xml:space="preserve">
          <source>Fix a missing &quot;sync&quot; that when omitted could lead to database corruption if a power failure or OS crash occurred just as a ROLLBACK operation was finishing.</source>
          <target state="translated">누락 된 &quot;동기화&quot;를 수정하면 ROLLBACK 작업이 완료되는 동안 정전 또는 OS 충돌이 발생한 경우 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd148f4d09fd6cc6bad30b19733a82972a2cebe0" translate="yes" xml:space="preserve">
          <source>Fix a naming conflict between sqlite.h and sqlite3.h.</source>
          <target state="translated">sqlite.h와 sqlite3.h 사이의 이름 충돌을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="86cbab0ce9e871e04d98798d23ca791be9552d16" translate="yes" xml:space="preserve">
          <source>Fix a parser bug that prevented the use of parentheses around table-valued functions.</source>
          <target state="translated">테이블 반환 함수 주위에 괄호를 사용하지 못하게하는 파서 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="1ea82017fb31c1e817b4ca5fcdba2b68c62a7e38" translate="yes" xml:space="preserve">
          <source>Fix a performance bug in the pager cache, ticket #3844</source>
          <target state="translated">호출기 캐시, 티켓 # 3844의 성능 버그 수정</target>
        </trans-unit>
        <trans-unit id="0b4a31de7ab7e54e3e4f0e6dd796fb43aef54770" translate="yes" xml:space="preserve">
          <source>Fix a performance regression on LEFT JOIN (see ticket #3015) that was mistakenly introduced in &lt;a href=&quot;#version_3_5_8&quot;&gt;version 3.5.8&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#version_3_5_8&quot;&gt;버전 3.5.8&lt;/a&gt; 에서 실수로 도입 된 LEFT JOIN (티켓 # 3015 참조)의 성능 회귀를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a1cd95a4c2ce3fd6ef13919dca1d81326877a9" translate="yes" xml:space="preserve">
          <source>Fix a performance regression related to the query planner enhancements of version 3.7.0.</source>
          <target state="translated">버전 3.7.0의 쿼리 플래너 향상과 관련된 성능 회귀를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="59850e50fa6095504ef5b88efd743956885d3a6e" translate="yes" xml:space="preserve">
          <source>Fix a possible infinite loop on VACUUM for corrupt database files. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</source>
          <target state="translated">손상된 데이터베이스 파일에 대해 VACUUM에서 가능한 무한 루프를 수정하십시오. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16de14f899013ff24b7caea8ce7237c3023ffe3c" translate="yes" xml:space="preserve">
          <source>Fix a possible segfault with DELETE when table is a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt; with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and the WHERE clause contains a OR and the table has one or more indexes that are able to trigger the OR optimization, but none of the indexes reference any table columns other than the INTEGER PRIMARY KEY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;.</source>
          <target state="translated">테이블이있을 때 DELETE의 발생 가능한 세그먼트 폴트를 해결 &lt;a href=&quot;rowidtable&quot;&gt;ROWID 테이블&lt;/a&gt; 와 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , 그리고 절에 OR을 포함하는 WHERE 테이블은 OR 최적화를 트리거 할 수있는 하나 개 이상의 인덱스가 있지만 인덱스 중 어느 것도 모든 테이블의 열을 참조하지 정수 기본 키 이외의 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d502547575294f85b69c2db2bf60e7be17520a7d" translate="yes" xml:space="preserve">
          <source>Fix a potential 32-bit integer overflow problem in the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 인터페이스 에서 잠재적 인 32 비트 정수 오버 플로우 문제점을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="86abca115efafefa4d8227ca90c204f72ac25973" translate="yes" xml:space="preserve">
          <source>Fix a potential buffer overread that could result when trying to search a corrupt database file.</source>
          <target state="translated">손상된 데이터베이스 파일을 검색 할 때 발생할 수있는 잠재적 버퍼 겹쳐 쓰기를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="e6cf1ce475579b639fd9a6e590dcc754d75c144f" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">버전 3.7.0 및 버전 3.6.23.1이 동일한 데이터베이스 파일에 번갈아 쓸 경우 발생할 수있는 데이터베이스 손상 버그를 수정하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;티켓 [51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2326ddb13e351e1098f9d7af1605ec053a972e00" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption problem on Unix caused by the fact that all POSIX advisory locks are cleared whenever you close() a file. The work around it to embargo all close() calls while locks are outstanding.</source>
          <target state="translated">파일을 닫을 때마다 모든 POSIX 권고 잠금이 해제되어 유닉스에서 발생할 수있는 데이터베이스 손상 문제를 해결하십시오. 잠금이 눈에 띄는 동안 모든 close () 호출을 금지하는 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="3c1404201cf0f45ed7d26fb3ee3e025fabad8654" translate="yes" xml:space="preserve">
          <source>Fix a potential integer overflow problem when compiling a particular horrendous common table expression. This was another problem discovered by OSSFuzz. Check-in &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;.</source>
          <target state="translated">특정 끔찍한 공통 테이블 표현식을 컴파일 할 때 잠재적 인 정수 오버 플로우 문제점을 수정하십시오. 이것은 OSSFuzz에서 발견 한 또 다른 문제입니다. 체크인 &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa021a738435d20102aefd6ba8aa9227f2196bfd" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; processing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 처리 에서 잠재적 인 메모리 누수를 수정하십시오 . 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d59a5b1204741917d207d0911c7f5b60cccb2e8" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interface. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 인터페이스 에서 잠재적 인 메모리 누수를 수정하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9b94c0ee4da7edac18db1b27719d5740439e09" translate="yes" xml:space="preserve">
          <source>Fix a potential out-of-bound read when querying a corrupt database file, a problem detected by Natalie Silvanovich of Google Project Zero. Check-in &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;.</source>
          <target state="translated">Google Project Zero의 Natalie Silvanovich가 감지 한 손상된 데이터베이스 파일을 쿼리 할 때 잠재적 인 범위를 벗어난 읽기를 수정합니다. 체크인 &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94450756c5f997edafdb983263e971e139725961" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault in complex recursive triggers, resulting from a bug in the OP_Once opcode introduced as part of a performance optimization in version 3.15.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</source>
          <target state="translated">버전 3.15.0의 성능 최적화의 일부로 도입 된 OP_Once opcode의 버그로 인해 복잡한 재귀 트리거에서 잠재적 segfault를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c23851f526115afe862ef20f590dcfe854957d3" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault when destroying locks on WinCE in a multi-threaded environment.</source>
          <target state="translated">다중 스레드 환경에서 WinCE의 잠금을 제거 할 때 잠재적 segfault를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5254d73f95694f4312acfaaba5e2519c7f711c7" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; that can result in a corrupt database containing two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;.</source>
          <target state="translated">동일한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 가진 두 개 이상의 행을 포함하는 데이터베이스가 손상 될 수 있는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 의 문제점을 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="cce51ec3d9eafc83d9bef6eb168bd83fba551391" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; that was causing a subsequent &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to behave suboptimally.</source>
          <target state="translated">후속 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 이 차선책으로 작동하게 하는 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 의 문제점을 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2ab7efe53f641d1c01e53f622fc41a617719096" translate="yes" xml:space="preserve">
          <source>Fix a problem in CSV import in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; where if the leftmost field of the first row in the CSV file was both zero bytes in size and unquoted no data would be imported.</source>
          <target state="translated">CSV 파일에서 첫 번째 행의 가장 왼쪽 필드의 크기가 모두 0 바이트이고 인용되지 않은 데이터를 가져 오지 않는 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 CSV 가져 오기의 문제를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8e5e51fd7781a4a270ea3403c1d91e18539fa5d" translate="yes" xml:space="preserve">
          <source>Fix a problem in FTS4 where the left-most column that contained the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;notindexed column&lt;/a&gt; name as a prefix was not indexed rather than the column whose name matched exactly.</source>
          <target state="translated">FTS4에서 색인화되지 않은 &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;열&lt;/a&gt; 이름을 접두사로 포함하는 맨 왼쪽 열의 이름이 정확히 일치하는 열이 아닌 색인화되지 않은 문제를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed16f1842283c33640adef4111628a226934ccb4" translate="yes" xml:space="preserve">
          <source>Fix a problem in the &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interface that could cause problems for the &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; extension under obscure circumstances. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;.</source>
          <target state="translated">의 문제를 해결 &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 에 문제가 발생할 수 인터페이스 &lt;a href=&quot;json1&quot;&gt;json1의&lt;/a&gt; 애매한 상황에서 확장. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="7871f6059f0a9d8ae6199f7ed5e914925c1946d3" translate="yes" xml:space="preserve">
          <source>Fix a problem in the query planner that results when a row-value expression is used with a PRIMARY KEY with redundant columns. Ticket &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</source>
          <target state="translated">중복 열이있는 PRIMARY KEY에 행 값 식을 사용할 때 발생하는 쿼리 플래너의 문제를 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee14ad300b53edffc750ba4ada032439baf8cf04" translate="yes" xml:space="preserve">
          <source>Fix a problem in the virtual table commit mechanism that was causing a crash in FTS3. Ticket #3497.</source>
          <target state="translated">FTS3에서 충돌을 일으킨 가상 테이블 커밋 메커니즘의 문제를 해결하십시오. 티켓 # 3497.</target>
        </trans-unit>
        <trans-unit id="367c86dcc3176132b397b28f7554be7148358015" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing excess memory usage with large &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; transactions in win32 systems.</source>
          <target state="translated">win32 시스템에서 대규모 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 트랜잭션으로 과도한 메모리 사용을 유발하는 문제를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4c5c3190d6e5398a03cc1624a8ad085afe03197" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing poor performance when many thousands of SQL statements were executed by a single sqlite_exec() call.</source>
          <target state="translated">단일 sqlite_exec () 호출로 수천 개의 SQL 문을 실행할 때 성능이 저하되는 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="d6546ef65a68047eca9a74f928d58465048048f8" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the database file if you drop a table from the main database that has a TEMP index.</source>
          <target state="translated">TEMP 인덱스가있는 기본 데이터베이스에서 테이블을 삭제하면 데이터베이스 파일이 손상되는 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="6a895d74574faf7c3e5b7c17bfc4a1aebd1bd35a" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the indices on a table if you do an INSERT OR REPLACE or an UPDATE OR REPLACE on a table that contains an INTEGER PRIMARY KEY plus one or more indices.</source>
          <target state="translated">INTEGER PRIMARY KEY와 하나 이상의 인덱스가 포함 된 테이블에서 INSERT OR REPLACE 또는 UPDATE OR REPLACE를 수행하면 테이블의 인덱스가 손상되는 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="fa339d6b0d5c93a4f64854920f80fba0a5a92e67" translate="yes" xml:space="preserve">
          <source>Fix a problem where &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; was causing incorrect results for updates on tables with triggers</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; 로 인해 트리거가있는 테이블의 업데이트에 대해 잘못된 결과가 발생 하는 문제 수정</target>
        </trans-unit>
        <trans-unit id="2367f688e4ee0ae00d13a38bb5c62a10fab4c4f9" translate="yes" xml:space="preserve">
          <source>Fix a problem with 3-way joins that do not use indices</source>
          <target state="translated">인덱스를 사용하지 않는 3 방향 조인 문제 해결</target>
        </trans-unit>
        <trans-unit id="fc131893314d3ec5912c469546ad607795fe252a" translate="yes" xml:space="preserve">
          <source>Fix a problem with &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; which could cause transactions to silently rollback if the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is set very small (less than 10) and SQLite comes under memory pressure.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; 가 매우 작게 설정되고 (10 미만) SQLite가 메모리 압력을받는 경우 트랜잭션이 자동 롤백 될 수있는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 의 문제점을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f2f150e12c534df43b52ade585282148590c894" translate="yes" xml:space="preserve">
          <source>Fix a problem with VACUUM on databases from which tables containing AUTOINCREMENT have been dropped.</source>
          <target state="translated">AUTOINCREMENT를 포함하는 테이블이 삭제 된 데이터베이스에서 VACUUM 관련 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="e98ac2eb09507917a285747f2d5bd3a4164f2534" translate="yes" xml:space="preserve">
          <source>Fix a problem with string memory management in the VDBE</source>
          <target state="translated">VDBE에서 문자열 메모리 관리 관련 문제 수정</target>
        </trans-unit>
        <trans-unit id="1c1c998fb53575b975370a5727818e77b27c3b5a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; in which the optimization was being applied inappropriately due to an IS NOT NULL operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;.</source>
          <target state="translated">IS NOT NULL 연산자로 인해 최적화가 부적절하게 적용되는 &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN 강도 감소 최적화&lt;/a&gt; 문제를 해결하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e42c3e04422e8992158af198fdedf65d8a494b4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; on &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;.</source>
          <target state="translated">에 문제를 수정 &lt;a href=&quot;optoverview#or_opt&quot;&gt;또는 최적화&lt;/a&gt; 에 대한 &lt;a href=&quot;expridx&quot;&gt;표현의 인덱스&lt;/a&gt; . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a552a20d99699b5fa85e0ed7fb142721053399d9" translate="yes" xml:space="preserve">
          <source>Fix a problem with the multi-row one-pass DELETE optimization that was causing it to compute incorrect answers with a self-referential subquery in the WHERE clause. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</source>
          <target state="translated">WHERE 절에서 자체 참조 하위 쿼리를 사용하여 오답을 계산하도록하는 다중 행 원 패스 DELETE 최적화 문제를 해결하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087에&lt;/a&gt; 대한 수정</target>
        </trans-unit>
        <trans-unit id="070ed03b719700575899432a2c98f057535dbcc4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the new &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; implementation that caused a malfunction when complicated expressions involving window functions were used inside of a view.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;창 함수&lt;/a&gt; 와 관련된 복잡한 표현식을 뷰 내부에서 사용할 때 오작동을 일으킨 새 창 함수 구현 문제를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef0924214b0eb9fe23d46afbb07aaf1261d67d0a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the sort order when comparing upper-case strings against characters greater than 'Z' but less than 'a'.</source>
          <target state="translated">대문자 문자열을 'Z'보다 크지 만 'a'보다 작은 문자와 비교할 때 정렬 순서 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="5e753a491c25e8edb1492253042a4e79f112f875" translate="yes" xml:space="preserve">
          <source>Fix a problem with the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; used within &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_expr#cosub&quot;&gt;상관 된 하위 쿼리&lt;/a&gt; 내 에서 사용되는 &lt;a href=&quot;windowfunctions&quot;&gt;창 함수&lt;/a&gt; 사용 관련 문제를 해결합니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;D0866b26f83e9c55e3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551f44e055f1b2367c902fea7be697c804fc97a8" translate="yes" xml:space="preserve">
          <source>Fix a problem with using the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; on an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 에서 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화&lt;/a&gt; 를 사용할 때 발생하는 문제를 해결하십시오 . 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="293886e1e2fac8f6d1689e1a0e83ac48f4add2fd" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug involving a LEFT JOIN with a BETWEEN or LIKE/GLOB constraint and then another INNER JOIN to the right that involves an OR constraint.</source>
          <target state="translated">BETWEEN 또는 LIKE / GLOB 제약 조건이있는 LEFT JOIN과 OR 제약 조건이 포함 된 오른쪽에 또 다른 INNER JOIN이 포함 된 쿼리 플래너 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="8ff17cc556a87f30aa15241b1ac5c7a361de91a4" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that could result in a segfault when querying tables with a UNIQUE or PRIMARY KEY constraint with more than four columns.</source>
          <target state="translated">4 개 이상의 열이있는 UNIQUE 또는 PRIMARY KEY 제약 조건이있는 테이블을 쿼리 할 때 segfault가 발생할 수있는 쿼리 플래너 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="9fb45458b64cd84ba2a2f30a7bfee1435ad64176" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">DESC 인덱스를 사용하여 동일한 GROUP BY 절이있는 쿼리에서 ORDER BY 절을 구현할 때 테이블이 잘못된 방향으로 스캔 될 수있는 쿼리 플래너 버그를 수정하십시오 (따라서 출력 순서를 반대로). 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09bdfd52ac4cb9f3c70abc6d5f401e62168b1225" translate="yes" xml:space="preserve">
          <source>Fix a query planner problem that could result in an incorrect answer due to the use of &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; in subqueries in the FROM clause of a correlated scalar subqueries. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;.</source>
          <target state="translated">상관 스칼라 서브 쿼리의 FROM 절에서 서브 쿼리에서 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 을 사용하여 잘못된 응답을 초래할 수있는 쿼리 플래너 문제점을 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="3db45cb5a06554ceffd3c2fab04e67abb9573838" translate="yes" xml:space="preserve">
          <source>Fix a race condition in AUTOVACUUM that can lead to corrupt databases</source>
          <target state="translated">데이터베이스가 손상 될 수있는 AUTOVACUUM의 경쟁 조건 수정</target>
        </trans-unit>
        <trans-unit id="96a8e915a1becae62cd060b6c6ea6fdc08fd0da2" translate="yes" xml:space="preserve">
          <source>Fix a race condition in test_async.c.</source>
          <target state="translated">test_async.c에서 경쟁 조건을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="625e5e94c16544ff24dd9e860382b39ea7c80a87" translate="yes" xml:space="preserve">
          <source>Fix a segfault that can occur for queries that use table-valued functions in an IN or EXISTS subquery. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</source>
          <target state="translated">IN 또는 EXISTS 하위 쿼리에서 테이블 반환 함수를 사용하는 쿼리에 대해 발생할 수있는 segfault를 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;B899B6042F97F5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a280dd5a4ba61a6ed5b8a4172311dcec663fd176" translate="yes" xml:space="preserve">
          <source>Fix a serious bug in the INSERT command which was causing data to go into the wrong columns if the data source was a SELECT and the INSERT clauses specified its columns in some order other than the default.</source>
          <target state="translated">데이터 소스가 SELECT이고 INSERT 절이 기본값 이외의 순서로 열을 지정한 경우 INSERT 명령에서 심각한 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a11d09fcf4c5c4f534bed3e95aeaedc75d2eadb8" translate="yes" xml:space="preserve">
          <source>Fix a strange (but valid) C declaration that was causing problems for QNX. No logical changes.</source>
          <target state="translated">QNX에 문제를 일으키는 이상한 (그러나 유효한) C 선언을 수정하십시오. 논리적 변경 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a54239aed950f147b9530647f9884464a8a7700" translate="yes" xml:space="preserve">
          <source>Fix a use-after-free that can occur when SQLite is compiled with -DSQLITE_HAS_CODEC.</source>
          <target state="translated">SQLite가 -DSQLITE_HAS_CODEC로 컴파일 될 때 발생할 수있는 사용 후 수정을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="65b8ad24259b51f708505579d558096b74643e0f" translate="yes" xml:space="preserve">
          <source>Fix an 64-bit alignment bug on HP/UX and Sparc</source>
          <target state="translated">HP / UX 및 Sparc에서 64 비트 정렬 버그 수정</target>
        </trans-unit>
        <trans-unit id="8d3940a154d321cca0d2eb2aa13ea157138409fd" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; issue in which the 'optimize' command could cause index corruption.</source>
          <target state="translated">'optimize'명령으로 인덱스가 손상 될 수 있는 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="cf27be06b87f8658f160d75e065a66b3575cb593" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 을 사용할 때 데이터베이스 &lt;a href=&quot;fileformat2#freelist&quot;&gt;무료 페이지 목록&lt;/a&gt; 이 손상 될 수 있는 &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt;오래되고 매우 모호한 버그&lt;/a&gt; 를 수정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b834d02e62a3f123a1b8d14a7dd0d0f55d7a363" translate="yes" xml:space="preserve">
          <source>Fix an alignment problem on 64-bit machines</source>
          <target state="translated">64 비트 컴퓨터에서 정렬 문제 해결</target>
        </trans-unit>
        <trans-unit id="22b28f14aad0849b7f089af3e0ae2de83c9cc448" translate="yes" xml:space="preserve">
          <source>Fix an assertion failure that occurred when deleting all rows of a table with the &quot;count_changes&quot; pragma turned on.</source>
          <target state="translated">&quot;count_changes&quot;pragma가 설정된 테이블의 모든 행을 삭제할 때 발생하는 어설 션 오류를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="24c083d9fe654c2c6b13e8a4783ebdcf071478d1" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that can occur when updating the NULL value of a field at the end of a table that was added using &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN을&lt;/a&gt; 사용하여 추가 된 테이블 끝에서 필드의 NULL 값을 업데이트 할 때 발생할 수있는 어설 션 결함을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="24c0b7a3124e531d424b372570a621483ca0c334" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that could occur following &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; 다음에 발생할 수있는 어설 션 오류를 수정하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28b592fe11bf16075b14f304072980cfa741f4d3" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that occurred on deeply nested views.</source>
          <target state="translated">깊이 중첩 된 뷰에서 발생한 어설 션 오류를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5a204d98c949cf8975212c05340c51bd92e0547a" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that was coming up when the expression in an index-on-expressions is really a constant. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</source>
          <target state="translated">식에 대한 인덱스식이 실제로 일정 할 때 발생하는 어설 션 오류를 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5edfc637acd59a3db220a001c5781ab4bd7de9b5" translate="yes" xml:space="preserve">
          <source>Fix an index corruption issue introduced by &lt;a href=&quot;#version_3_8_7&quot;&gt;version 3.8.7&lt;/a&gt;. An index with a TEXT key can be corrupted by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into the corresponding table if the table has two nested triggers that convert the key value to INTEGER and back to TEXT again. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#version_3_8_7&quot;&gt;버전 3.8.7에서&lt;/a&gt; 소개 된 색인 손상 문제를 해결하십시오 . 테이블에 키 값을 INTEGER로 변환하고 다시 TEXT로 변환하는 두 개의 중첩 트리거가있는 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 에 의해 TEXT 키가있는 인덱스가 해당 테이블로 손상 될 수 있습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eeeaac39b440e493474edfe8a18c8edd3970590" translate="yes" xml:space="preserve">
          <source>Fix an infinite-loop in the query planner that could occur on malformed &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">쿼리 플래너에서 잘못된 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에서 발생할 수있는 무한 루프를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7f2f6913b7c03deeb2b6b41e2ed3b92c354b90f" translate="yes" xml:space="preserve">
          <source>Fix an internal code generator problem that was causing some &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations to no-op. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</source>
          <target state="translated">일부 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 조작이 작동하지 않는 내부 코드 생성기 문제점을 수정하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="337ef48955d3bd9a0a84bd4a9dd181f41e6cabab" translate="yes" xml:space="preserve">
          <source>Fix an issue in the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, that caused a segfault if the fsdir() table was used as the inner table of a join. Problem reported on the mailing list and fixed by check-in &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</source>
          <target state="translated">fsdir (PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 에서 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; 확장명으로 fsdir () 테이블이 조인의 내부 테이블로 사용 된 경우 segfault가 발생하는 문제를 해결하십시오. 메일 링리스트에보고되었으며 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be로&lt;/a&gt; 해결되는 문제</target>
        </trans-unit>
        <trans-unit id="6f2b91637b2c2c39f1dab693ce0e485fd3cd7d63" translate="yes" xml:space="preserve">
          <source>Fix an issue with incorrect sharing of VDBE temporary registers between co-routines that could cause incorrect query results in obscure cases. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;.</source>
          <target state="translated">공동 루틴간에 VDBE 임시 레지스터를 잘못 공유하여 잘못된 쿼리 결과가 불명확 할 수있는 문제를 해결하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c984a9789b89b098bf54d9a87bf8ad24379596a" translate="yes" xml:space="preserve">
          <source>Fix an obscure and relatively harmless problem that might have caused a resource leak following an I/O error.</source>
          <target state="translated">I / O 오류 후 리소스 누수를 유발할 수있는 불분명하고 비교적 무해한 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="9af5e2e7bb886d04f6d1d3a91c18b1bcfc2e680c" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness constraint but the containing transaction commits.</source>
          <target state="translated">다음과 같은 비정상적인 상황에서 데이터베이스 손상을 유발할 수있는 모호한 버그를 수정하십시오. 더 큰 트랜잭션의 일부인 큰 INSERT 또는 UPDATE 문은 고유 제한 조건으로 인해 실패하지만 포함하는 트랜잭션 커밋으로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0096a0fca1b6b43797d06b363272bd306cbf7ce9" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness contraint but the containing transaction commits.</source>
          <target state="translated">다음과 같은 비정상적인 상황에서 데이터베이스 손상을 일으킬 수있는 모호한 버그를 수정하십시오. 더 큰 트랜잭션의 일부인 큰 INSERT 또는 UPDATE 문은 고유 제약 조건으로 인해 실패하지만 포함하는 트랜잭션 커밋으로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ce8d90d9be96ff29e6eda51d841a97e900370a1d" translate="yes" xml:space="preserve">
          <source>Fix an obscure memory leak in &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 에서 메모리 누수를 수정하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9faef411a2ddeadaf79ebd73389c10f7af52120" translate="yes" xml:space="preserve">
          <source>Fix an obscure segfault in UTF-8 to UTF-16 conversions</source>
          <target state="translated">UTF-8에서 UTF-16으로의 변환에서 애매한 segfault 수정</target>
        </trans-unit>
        <trans-unit id="b5c1f0802c64a77b99076bfc9059cf131dd55807" translate="yes" xml:space="preserve">
          <source>Fix an off-by-one error that caused quoted empty string at the end of a CRNL-terminated line of CSV input to be misread by the command-line shell.</source>
          <target state="translated">CRNL 종료 CSV 입력 행 끝에있는 따옴표가없는 빈 문자열이 명령 행 쉘에 의해 잘못 읽히도록하는 일대일 오류를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="30b0fd93ee02b86cc24f6cc7bd2523397f033eee" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug involving subqueries in a compound SELECT that has both an ORDER BY and a LIMIT clause. Ticket #2339.</source>
          <target state="translated">ORDER BY와 LIMIT 절이 모두있는 복합 SELECT의 하위 쿼리와 관련된 최적화 프로그램 버그를 수정합니다. 티켓 # 2339.</target>
        </trans-unit>
        <trans-unit id="683ed4e4563f819c0aec9579fc2147e259103b73" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug that could have caused some unusual LEFT OUTER JOINs to give incorrect results.</source>
          <target state="translated">비정상적인 LEFT OUTER JOIN이 잘못된 결과를 초래할 수있는 최적화 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="762e5ec5f054c66d660a449bf35057af7025d512" translate="yes" xml:space="preserve">
          <source>Fix an uninitialized variable in pager.c which could (with a probability of about 1 in 4 billion) result in a corrupted database.</source>
          <target state="translated">pager.c에서 초기화되지 않은 변수를 수정하여 (40 억에서 약 1의 확률로) 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff50f16c16225e491f827922f36f0a1b00ee9e8" translate="yes" xml:space="preserve">
          <source>Fix another bug in the IS NULL optimization that was added in version 3.3.9.</source>
          <target state="translated">버전 3.3.9에서 추가 된 IS NULL 최적화의 다른 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="e8f06a6dcd8a035bb10d1fb00994a8c1617f3e5c" translate="yes" xml:space="preserve">
          <source>Fix another bug in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API. We'll get it right eventually...</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; API 구현에서 다른 버그를 수정했습니다 . 우리는 결국 그것을 얻을 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="6f129ae803d9883975a2438f98f71935a3f57c27" translate="yes" xml:space="preserve">
          <source>Fix bugs in pager.c that could lead to database corruption if two processes both try to recover a hot journal at the same instant</source>
          <target state="translated">두 프로세스가 모두 같은 순간에 핫 저널을 복구하려고하면 pager.c의 버그로 인해 데이터베이스가 손상 될 수있는 버그 수정</target>
        </trans-unit>
        <trans-unit id="e51c167c962ab37e883d84e10e98aee9dad05d15" translate="yes" xml:space="preserve">
          <source>Fix bugs in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API that can lead to segfaults.</source>
          <target state="translated">segfault로 이어질 수 있는 새로운 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; API 구현에서 버그를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="15b10b87ff343116def15b81c85457d634788432" translate="yes" xml:space="preserve">
          <source>Fix bugs that can (rarely) lead to incorrect query results when the CAST or OR operators are used in the WHERE clause of a query.</source>
          <target state="translated">CAST 또는 OR 연산자가 쿼리의 WHERE 절에 사용될 때 잘못된 쿼리 결과를 초래할 수있는 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3d935fe3f3737292749bd1972d56f443d7c93968" translate="yes" xml:space="preserve">
          <source>Fix byte alignment problems on 64-bit architectures.</source>
          <target state="translated">64 비트 아키텍처에서 바이트 정렬 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="7bca40ab59e8b9695f58ea94f5115e8c80d7a7c3" translate="yes" xml:space="preserve">
          <source>Fix commenting errors and improve the comments generated on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 컴파일 타임 옵션이 사용될 때 주석 오류를 수정하고 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 목록에서 생성 된 주석을 개선하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6a563b99fee018f87bcc6d45b57949ce6d02874" translate="yes" xml:space="preserve">
          <source>Fix data races that might occur under stress when running with many threads in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; where some of the threads are opening and closing connections.</source>
          <target state="translated">일부 스레드가 연결을 열고 닫는 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 많은 스레드로 실행할 때 스트레스가 발생할 수있는 데이터 경쟁 문제를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="3810fcb3cfb91e5274e7723b80500a70b2e4eef7" translate="yes" xml:space="preserve">
          <source>Fix data structure alignment issues on Sparc. Ticket #3777.</source>
          <target state="translated">Sparc에서 데이터 구조 정렬 문제를 해결합니다. 티켓 # 3777.</target>
        </trans-unit>
        <trans-unit id="a7f89cd0a1f20da8469d2ab54509c35e86684ab3" translate="yes" xml:space="preserve">
          <source>Fix editline support in the command-line shell.</source>
          <target state="translated">명령 행 쉘에서 편 집행 지원을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="87d44c2123224749ec741fa602897daad30b0e0b" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">사실 정렬이 필요할 때 정렬 단계를 최적화하는 &lt;a href=&quot;#version_3_7_15&quot;&gt;버전 3.7.15&lt;/a&gt; 에 도입 된 ORDER BY 최적화 프로그램의 버그가 수정되었습니다 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a782f7686d7d9707b5dc5190d2cb994db1da8ac" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the SELECT DISTINCT logic that was introduced by the prior version.</source>
          <target state="translated">이전 버전에서 도입 된 SELECT DISTINCT 논리의 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="293d91bd4dad89365956202fbbdc05193695a217" translate="yes" xml:space="preserve">
          <source>Fix for another problem (unrelated to the one fixed in 2.1.4) that sometimes causes &lt;b&gt;sqlite_exec()&lt;/b&gt; to return SQLITE_PROTOCOL unnecessarily. This time the bug was in the POSIX locking code and should not effect Windows users.</source>
          <target state="translated">&lt;b&gt;sqlite_exec ()&lt;/b&gt; 가 불필요하게 SQLITE_PROTOCOL을 반환 하는 다른 문제 (2.1.4에서 수정 된 문제와 관련이 없음)를 수정했습니다 . 이번에는 버그가 POSIX 잠금 코드에 있었고 Windows 사용자에게는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="692cc3acdf11cc382c710566eb5e8d41ae9a76e6" translate="yes" xml:space="preserve">
          <source>Fix inconsistent integer to floating-point comparison operations that could result in a corrupt index if the index is created on a table column that contains both large integers and floating point values of similar magnitude. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;.</source>
          <target state="translated">큰 정수와 비슷한 크기의 부동 소수점 값을 모두 포함하는 테이블 열에서 인덱스가 작성 될 경우 인덱스가 손상 될 수있는 일치하지 않는 정수를 부동 소수점 비교 연산으로 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbe4713574b5e7e1bf3ea574e5968f7da369b174" translate="yes" xml:space="preserve">
          <source>Fix incorrect result with complex OR-connected WHERE and STAT4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</source>
          <target state="translated">복잡한 OR 연결 WHERE 및 STAT4로 잘못된 결과를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32ba32659ea655886bad57a0dd08fbe5d98856b9" translate="yes" xml:space="preserve">
          <source>Fix locking behavior under Windows</source>
          <target state="translated">Windows에서 잠금 동작 수정</target>
        </trans-unit>
        <trans-unit id="1f35665eab7b4eb2d565f64daa7ab9de3e2952ac" translate="yes" xml:space="preserve">
          <source>Fix many obscure problems discovered while &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL fuzzing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL 퍼징&lt;/a&gt; 중에 발견 된 많은 모호한 문제점을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e786cb80b44d5b0bc787df47e982713af4c0ff9" translate="yes" xml:space="preserve">
          <source>Fix many potential segfaults that could be caused by malicious SQL statements.</source>
          <target state="translated">악의적 인 SQL 문으로 인해 발생할 수있는 많은 잠재적 segfault를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab2336b4ec301e575c6d8af5dd4486d9002cf92" translate="yes" xml:space="preserve">
          <source>Fix memory leaks that used to occur after a malloc() failure.</source>
          <target state="translated">malloc () 실패 후 발생했던 메모리 누수를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6c482ed533b8d025b0b530bd86fd284d9ab805" translate="yes" xml:space="preserve">
          <source>Fix memory size tracking so that it works even if SQLite uses more than 2GiB of memory.</source>
          <target state="translated">SQLite가 2GiB 이상의 메모리를 사용하는 경우에도 작동하도록 메모리 크기 추적을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="83c4e0c639eeed5339ef3f3550050703ea306329" translate="yes" xml:space="preserve">
          <source>Fix minor issues with the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블&lt;/a&gt; 의 사소한 문제를 해결 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d8fc1c13727f748ff40e9e6be94b0b7005ead11" translate="yes" xml:space="preserve">
          <source>Fix misbehavior of the FTS5 xBestIndex method. Ticket &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;.</source>
          <target state="translated">FTS5 xBestIndex 메소드의 오작동을 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6aeb35ac1eb7c66584445cf87b55f99254ca966" translate="yes" xml:space="preserve">
          <source>Fix more bugs in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 에서 더 많은 버그 수정 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1506d1bb252e85d5b0e36b68a46cf1665d4a7c8f" translate="yes" xml:space="preserve">
          <source>Fix more problems with rollback. Enhance the test suite to exercise the rollback logic extensively in order to prevent any future problems.</source>
          <target state="translated">롤백 관련 문제를 해결하십시오. 향후 문제가 발생하지 않도록 테스트 스위트를 강화하여 롤백 로직을 광범위하게 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3fb27e5b00960417518969df0f918d06f25d9624" translate="yes" xml:space="preserve">
          <source>Fix multiple bugs that can occur following a malloc() failure.</source>
          <target state="translated">malloc () 실패 후 발생할 수있는 여러 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="8252f0ee7c2b56c6e1d2a3ae12fb9ec74fcaf061" translate="yes" xml:space="preserve">
          <source>Fix obscure crash bugs found by &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;american fuzzy lop&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;미국 퍼지 lop에&lt;/a&gt; 의해 발견 된 모호한 충돌 버그 수정 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="029dc6c7c9dc876556264390601510f43467cb42" translate="yes" xml:space="preserve">
          <source>Fix other minor problems with using small soft heap limits.</source>
          <target state="translated">작은 소프트 힙 제한 사용과 관련된 기타 사소한 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="2953bbeca888101c80fba41134554ee3b46a5872" translate="yes" xml:space="preserve">
          <source>Fix portability problems for MinGW/MSYS.</source>
          <target state="translated">MinGW / MSYS의 이식성 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="46269c4cd0e4bb26c3e434c946d6ad61c56e3d22" translate="yes" xml:space="preserve">
          <source>Fix potential corruption in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; due to automatic datatype conversions. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</source>
          <target state="translated">자동 데이터 유형 변환으로 인한 &lt;a href=&quot;expridx&quot;&gt;표현식 색인의&lt;/a&gt; 잠재적 손상을 수정 합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b60b2ce1e9e806c6a1d1ab2efe5b7b8417ffc" translate="yes" xml:space="preserve">
          <source>Fix problems found on 64-bit systems.</source>
          <target state="translated">64 비트 시스템에서 발견 된 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="07f0a4d00027e8a55978e27f100b7e116a031b97" translate="yes" xml:space="preserve">
          <source>Fix problems with the handling of ORDER BY expressions on compound SELECT statements in subqueries.</source>
          <target state="translated">하위 쿼리의 복합 SELECT 문에서 ORDER BY 식 처리 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="3f1665257f79bd93e546dd7e3d88c5139efb7056" translate="yes" xml:space="preserve">
          <source>Fix rare false-positives in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; when run on a database connection with &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;연결된 데이터베이스가&lt;/a&gt; 있는 데이터베이스 연결에서 실행될 때 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 에서 드문 거짓 양성을 수정하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;A4E06E75A9AB61A12&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715572171eb76d3d2c9de665f3a896a9b21d3581" translate="yes" xml:space="preserve">
          <source>Fix several important bugs in the new ATTACH and DETACH commands.</source>
          <target state="translated">새로운 ATTACH 및 DETACH 명령에서 몇 가지 중요한 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="ddb3a4c421a408022b093da748a9383a9c659be4" translate="yes" xml:space="preserve">
          <source>Fix several nuisance bugs.</source>
          <target state="translated">몇 가지 귀찮은 버그를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="893a9bc034bf998aa3ff5b40cdc26495f66e42a9" translate="yes" xml:space="preserve">
          <source>Fix table rename feature so that it also updates references to the renamed table in &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;.</source>
          <target state="translated">테이블 이름 바꾸기 기능을 수정하여 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 및 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 에서 이름이 바뀐 테이블에 대한 참조도 업데이트 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c93787ec12e369e67cea4716187fa506565c4de" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.import&quot; command of the shell so that it ignores \r characters at the end of lines.</source>
          <target state="translated">셸의 &quot;.import&quot;명령을 수정하여 줄 끝의 \ r 문자를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="efa608a017df9d7fa42cace30fce54f90785e7c6" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.read&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it understands that its input is not interactive.</source>
          <target state="translated">입력이 대화식이 아님을 이해하도록 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &quot;.read&quot;명령을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dd018e621c55cac03b1d82cf14914c81075f182" translate="yes" xml:space="preserve">
          <source>Fix the --enable-threadsafe option on the configure script</source>
          <target state="translated">configure 스크립트에서 --enable-threadsafe 옵션 수정</target>
        </trans-unit>
        <trans-unit id="4f27e177384472d9d1a0c017bbab8f18de27d2fa" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface so that it returns true if the database is read-only due to the file format write version number being too large.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly ()&lt;/a&gt; 수정파일 형식 쓰기 버전 번호가 너무 커서 데이터베이스가 읽기 전용 인 경우 true를 리턴하도록 인터페이스를 .</target>
        </trans-unit>
        <trans-unit id="bec6839af346a0afcfd8b6b2618aee85250ace7f" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces so that they actually do provide a 64-bit answer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스가 실제로 64 비트 응답을 제공하도록 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ba95583c49ccb4f7efb59b2718e52202fa58e8d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface so that it gives the correct answer for &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; statements that have been stepped but never reset.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy ()&lt;/a&gt; 인터페이스를 수정하여 단계 화되었지만 재설정되지 않은 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 문에 대한 올바른 응답을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8b77554fdfe7204548bebac009120f0ab4ce5d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface so that it is disabled if either the callback or the mask arguments are zero, in accordance with the documentation.</source>
          <target state="translated">설명서에 따라 &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 인터페이스가 콜백 또는 마스크 인수가 0 인 경우 비활성화되도록 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="956e98f8a5992e566b23150a8321e220d594d919" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt; interface so that it correctly translates content generated by &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; into a string of all 0x00 characters. This is a long-standing issue discovered after the 3.16.1 release by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 인터페이스를 수정하여 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob ()&lt;/a&gt; 에 의해 생성 된 컨텐츠 를 모든 0x00 문자의 문자열로 올바르게 변환하십시오 . 이것은 &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt; 에서 3.16.1 릴리스 이후에 발견 된 오랜 문제입니다.</target>
        </trans-unit>
        <trans-unit id="56c77cb746417e9f9c249b6c4c57b8b0bd6b303c" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it builds with -DSQLITE_UNTESTABLE</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 가 -DSQLITE_UNTESTABLE로 빌드되도록 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac07a1bdc161b16f3469a85c1d0b7329721b6d7" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function so that it returns an empty BLOB rather than throwing an out-of-memory error when reading an empty file.</source>
          <target state="translated">빈 파일을 읽을 때 메모리 부족 오류가 발생하지 않고 빈 BLOB를 반환하도록 &lt;a href=&quot;cli#fileio&quot;&gt;readfile ()&lt;/a&gt; 함수를 수정 하십시오.</target>
        </trans-unit>
        <trans-unit id="403d90d10026656bd2341e3610eb64ec19d4191d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;writefile()&lt;/a&gt; function so that when it creates new directories along the path of a new file, it gives them umask permissions rather than the same permissions as the file.</source>
          <target state="translated">새 파일의 경로를 따라 새 디렉토리를 작성할 때 파일과 동일한 권한 대신 umask 권한을 부여하도록 &lt;a href=&quot;cli#fileio&quot;&gt;writefile ()&lt;/a&gt; 함수를 수정 하십시오.</target>
        </trans-unit>
        <trans-unit id="c637b1ba45c5e9182867d4d4a220fb33c1f49c9d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; extension so that it works with &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks=ON&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; 확장명이 작동하도록 수정하십시오.&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks = ON&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="742c65bbfe2ba6c5ffb22d31b0549c4b28db3ce5" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;json1#jeach&quot;&gt;json_each()&lt;/a&gt; function so that it returns valid results on its &quot;fullkey&quot; column when the input is a simple value rather than an array or object.</source>
          <target state="translated">&lt;a href=&quot;json1#jeach&quot;&gt;json_each ()&lt;/a&gt; 수정입력이 배열이나 객체가 아닌 단순한 값일 때 &quot;풀키&quot;열에 유효한 결과를 반환하도록 함수를 .</target>
        </trans-unit>
        <trans-unit id="6faddebbbfb3cf6bd640c7723cc149f43cca6d2e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command so that it does not corrupt &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indexes&lt;/a&gt; when adding a column to a &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy file format&lt;/a&gt; database. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;레거시 파일 형식&lt;/a&gt; 데이터베이스에 열을 추가 할 때 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;내림차순 인덱스&lt;/a&gt; 가 손상되지 않도록 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령을 수정하십시오 . 티켓&lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt; F68BF68513A1C15F&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02f53a9fc9d770e6300288b8428f8e92433fe895" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; command so that it works for tables that have redundant UNIQUE constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</source>
          <target state="translated">중복 UNIQUE 제한 조건이있는 테이블에 대해 작동하도록 &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; 명령을 수정하십시오 . 티켓&lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt; bc8d94f0fbd633fd9a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97c52dd1e73a0efdc1a5a635f402eb42bf6e057e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 테이블에서 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대한 올바른 샘플을 추가하도록 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 수정하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d872c8e6bb3c85572831647367d9180d6f56948" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it computes statistics on tables whose names begin with &quot;sqlite&quot;. Check-in &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</source>
          <target state="translated">이름이 &quot;sqlite&quot;로 시작하는 테이블에서 통계를 계산하도록 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 수정하십시오 . 체크인 &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc9460bbb01c2af9870b809ff07c3b2b7356fe99" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; command so that it is no longer able to sneak a NULL value into a NOT NULL column even if the NOT NULL column has a default value of NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</source>
          <target state="translated">NOT NULL 열의 기본값이 NULL 인 경우에도 더 이상 NULL 값을 NOT NULL 열로 몰래 이동할 수 없도록 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 명령을 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d54e2533360cb4659b717a0226d2d7a1dbf1bbf" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; statement for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that lack secondary indexes so that it works correctly with triggers and foreign keys. This was a new bug caused by performance optimizations added in version 3.16.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</source>
          <target state="translated">2 차 인덱스가없는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 의 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 문을 수정하여 트리거 및 외래 키와 올바르게 작동하도록하십시오. 버전 3.16.0에 추가 된 성능 최적화로 인해 발생한 새로운 버그입니다. 티켓&lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt; 30027b613b4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d509397fe960e4575a2e26f651dde6ff90b84a19" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command so that it spills excess content to disk rather than holding everything in memory, and possible causing an out-of-memory error for larger database files. This fixes an issue introduced by version 3.15.0.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 수정하여 메모리에있는 모든 것을 보유하지 않고 디스크에 초과 컨텐츠를 쏟아서 더 큰 데이터베이스 파일에 대해 메모리 부족 오류가 발생할 수 있도록 수정하십시오. 버전 3.15.0에서 소개 된 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b036730fcf1ecafecf0573d1d74619be57162b96" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; so that it works on queries that contain subqueries that use &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 을 사용하는 하위 쿼리가 포함 된 쿼리에서 작동하도록 &lt;a href=&quot;optoverview#flattening&quot;&gt;쿼리 병합기를&lt;/a&gt; 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a295aba8a2bc4b671641db0bf3a60e0d6006706" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; so that it always ignores subplans that do not use an index.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화를&lt;/a&gt; 수정하여 인덱스를 사용하지 않는 하위 계획을 항상 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="69a683f5bb13785c6e99f6455ca83c519f9c2e7d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; so that it works correctly when the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is used on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에서 &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화&lt;/a&gt; 를 사용할 때 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 가 올바르게 작동하도록 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64c703876098dc69084f33c7133d65be1531802" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command so that it works correctly with foreign keys on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에서 외래 키와 올바르게 작동하도록 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d608a4f7657ad4f577e7889d266b51e07ca7fe6" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; virtual table so that it correctly returns no rows if any of its constraints are NULL.</source>
          <target state="translated">제약 조건이 NULL 인 경우 행을 올바르게 반환하지 않도록 &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; 가상 테이블을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="16b43b19be563d99895b6b7aa73c97080f1c15c0" translate="yes" xml:space="preserve">
          <source>Fix the REPLACE() function so that it returns NULL if the second argument is an empty string. Ticket #2324.</source>
          <target state="translated">두 번째 인수가 빈 문자열 인 경우 NULL을 리턴하도록 REPLACE () 함수를 수정하십시오. 티켓 # 2324.</target>
        </trans-unit>
        <trans-unit id="b71b83145fe1ea70f5f98014557a62cf7f2c2ec4" translate="yes" xml:space="preserve">
          <source>Fix the TCL interface so that the &quot;nullvalue&quot; setting is honored for TCL implementations of SQL functions.</source>
          <target state="translated">SQL 함수의 TCL 구현에 &quot;널값&quot;설정이 적용되도록 TCL 인터페이스를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="681e860e148ced87ec9dd7b3cfb9b43a75c2065d" translate="yes" xml:space="preserve">
          <source>Fix the behavior of &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; for queries that use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that the result is consistent with other queries that do not use that optimization, and with PostgreSQL, MySQL, and SQLServer. Ticket &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 를 사용하는 쿼리에 대해 &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 의 동작을 수정하여 결과가 해당 최적화를 사용하지 않는 다른 쿼리와 PostgreSQL, MySQL 및 SQLServer와 일치하도록하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2fb92f8546f34175b1dda79777c363dd68d103" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;amp;lt&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">인덱스의 항목 순서와 일치하도록 비교 연산자 (예 : &quot; &lt;b&gt;&amp;amp; lt&lt;/b&gt; &quot;, &quot; &lt;b&gt;==&lt;/b&gt; &quot;등) 의 동작을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a8e8cd65707752281f4a6188d7da381520e451a" translate="yes" xml:space="preserve">
          <source>Fix the behavior of typeof() and length() on virtual tables. Ticket &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</source>
          <target state="translated">가상 테이블에서 typeof () 및 length ()의 동작을 수정하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df05e2dc4f6d16d80624e7984c8465e501af7d3b" translate="yes" xml:space="preserve">
          <source>Fix the build so that it works with -DSQLITE_OMIT_WAL.</source>
          <target state="translated">-DSQLITE_OMIT_WAL과 작동하도록 빌드를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="2766a0c67ddd6ed7f5aaccb304bc1ba6ad153261" translate="yes" xml:space="preserve">
          <source>Fix the built-in printf logic so that it prints &quot;NaN&quot; not &quot;Inf&quot; for floating-point NaNs. Ticket #2345</source>
          <target state="translated">부동 소수점 NaN에 대해 &quot;Inf&quot;가 아닌 &quot;NaN&quot;을 인쇄하도록 내장 printf 논리를 수정하십시오. 티켓 # 2345</target>
        </trans-unit>
        <trans-unit id="5bfcd9ce8f5df54205f92dd3b6c0521e656224b0" translate="yes" xml:space="preserve">
          <source>Fix the bytecode generator to deal with a subquery in the FROM clause that is itself a UNION ALL where one side of the UNION ALL is a view that contains an ORDER BY. This is a long-standing issue that was discovered after the release of 3.16.1. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;.</source>
          <target state="translated">UNION ALL의 한 쪽이 ORDER BY를 포함하는 뷰인 FUN 절에서 하위 쿼리를 처리하도록 바이트 코드 생성기를 수정하십시오. 이것은 3.16.1 릴리스 이후에 발견 된 오랜 문제입니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d203309fb6041974c7687fc93bbf99d6e93873bc" translate="yes" xml:space="preserve">
          <source>Fix the code generator for expressions of the form &quot;x IN (SELECT...)&quot; where the SELECT statement on the RHS is a correlated subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;.</source>
          <target state="translated">RHS의 SELECT 문이 상관 부속 조회 인 &quot;x IN (SELECT ...)&quot;형식의 표현식에 대한 코드 생성기를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13a43d34f4444938ebdb413873a4acf48769174e" translate="yes" xml:space="preserve">
          <source>Fix the configure script for the amalgamation so that the --readline option works again on Raspberry PIs.</source>
          <target state="translated">--readline 옵션이 Raspberry PI에서 다시 작동하도록 합병에 대한 구성 스크립트를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="0dffaab8602b04f745c3456ad0e79054b8bf2a09" translate="yes" xml:space="preserve">
          <source>Fix the function prototype for the open(2) system call to agree with POSIX. Without this fix, pthreads does not work correctly on NetBSD.</source>
          <target state="translated">POSIX와 일치하도록 open (2) 시스템 호출의 함수 프로토 타입을 수정하십시오. 이 수정 사항이 없으면 NetBSD에서 pthread가 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cdcb447680d92da840bf449347a30236662eba4" translate="yes" xml:space="preserve">
          <source>Fix the locking mechanism yet again to prevent &lt;b&gt;sqlite_exec()&lt;/b&gt; from returning SQLITE_PROTOCOL unnecessarily. This time the bug was a race condition in the locking code. This change affects both POSIX and Windows users.</source>
          <target state="translated">&lt;b&gt;sqlite_exec ()&lt;/b&gt; 가 불필요하게 SQLITE_PROTOCOL을 리턴 하지 않도록 잠금 메커니즘을 다시 수정하십시오 . 이번에는 버그가 잠금 코드의 경쟁 조건이었습니다. 이 변경은 POSIX 및 Windows 사용자 모두에게 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="007c6c873e32f4b431e8ac6f01127288ee55c964" translate="yes" xml:space="preserve">
          <source>Fix the min() and max() optimizer so that it works when the FROM clause consists of a subquery.</source>
          <target state="translated">FROM 절이 서브 쿼리로 구성 될 때 작동하도록 min () 및 max () 최적화 프로그램을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b12f6e9f1f8f67709743497fbebb71ef8c53459f" translate="yes" xml:space="preserve">
          <source>Fix the parser to accept valid &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; syntax. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</source>
          <target state="translated">유효한 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 구문 을 허용하도록 구문 분석기를 수정하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f421298ab97922575edd88af10f5d60d0152b2" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to correctly handle constant expressions in the ON clause of a LEFT JOIN. Ticket #2403</source>
          <target state="translated">LEFT JOIN의 ON 절에서 상수 표현식을 올바르게 처리하도록 쿼리 최적화 프로그램을 수정하십시오. 티켓 # 2403</target>
        </trans-unit>
        <trans-unit id="40584ba785f1b7ac57821c3d2f85216f2b32614c" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to handle rowid comparisons to NULL correctly. Ticket #2404</source>
          <target state="translated">rowid 비교를 NULL로 올바르게 처리하도록 쿼리 최적화 프로그램을 수정하십시오. 티켓 # 2404</target>
        </trans-unit>
        <trans-unit id="dfa9a47acf25a2f05ea48c9410e4c4747561d320" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that IS and IS NULL operators are able to drive an index on a LEFT OUTER JOIN.</source>
          <target state="translated">IS 및 IS NULL 연산자가 LEFT OUTER JOIN에서 인덱스를 구동 할 수 있도록 쿼리 플래너를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5653a698bc06b9d4be42b0c1c2f59e7a1e2b1d3a" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it knows not to use &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the right table of LEFT JOIN if the WHERE clause uses the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;. Fix for &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;.</source>
          <target state="translated">WHERE 절이 &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS 연산자를&lt;/a&gt; 사용하는 경우 LEFT JOIN의 오른쪽 테이블에서 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱스&lt;/a&gt; 를 사용하지 않도록 쿼리 플래너를 수정하십시오 . &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="f099fcbe9d8c0841133d0c1acb48be9e9aec8aff" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it takes into account dependencies in the arguments to table-valued functions in subexpressions in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</source>
          <target state="translated">WHERE 절의 하위 표현식에서 테이블 값 함수에 대한 인수의 종속성을 고려하도록 쿼리 플래너를 수정하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51036bc7729aa3fd5a9f1ed633c206de4f498ea" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it works correctly for IS NOT NULL operators in the ON clause of a LEFT JOIN with the SQLITE_ENABLE_STAT4 compile-time option. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</source>
          <target state="translated">SQLITE_ENABLE_STAT4 컴파일 시간 옵션을 사용하여 LEFT JOIN의 ON 절에서 IS NOT NULL 연산자에 대해 올바르게 작동하도록 쿼리 플래너를 수정하십시오. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e67f4820003d691c4c8b5a0ce32d382b50cc512" translate="yes" xml:space="preserve">
          <source>Fix the regression test suite so that it works with Tcl8.5</source>
          <target state="translated">Tcl8.5에서 작동하도록 회귀 테스트 스위트 수정</target>
        </trans-unit>
        <trans-unit id="6d468d38a1ed912125e5b1192b25781bdc29bb56" translate="yes" xml:space="preserve">
          <source>Fix the schema parser so that it interprets certain (obscure and ill-formed) CREATE TABLE statements the same as legacy. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</source>
          <target state="translated">스키마 구문 분석기가 레거시와 동일하게 특정 (불분명하고 형식이 잘못된) CREATE TABLE 문을 해석하도록 수정하십시오. 티켓 수정&lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt; ac661962a2aeab3c331에&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29c5cfa4d69ee4c85bc560fdea69b6008202a144" translate="yes" xml:space="preserve">
          <source>Fix to UPDATE triggers on TEMP tables.</source>
          <target state="translated">TEMP 테이블에서 UPDATE 트리거로 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ac8e543b0bc738b6dc67d65d9b587bde27a9189" translate="yes" xml:space="preserve">
          <source>Fix to the --rbu option of &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">sqldiff --rbu 옵션으로 &lt;a href=&quot;sqldiff&quot;&gt;수정하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dce0daf2e8b6a6a74ce23add5bf251c814f89da9" translate="yes" xml:space="preserve">
          <source>Fix two bugs in the locking protocol. (One was masking the other.)</source>
          <target state="translated">잠금 프로토콜에서 두 가지 버그가 수정되었습니다. (하나는 다른 것을 가리고있었습니다.)</target>
        </trans-unit>
        <trans-unit id="140466bf745b30af0254a8472b1f139b069fbb53" translate="yes" xml:space="preserve">
          <source>Fix two bugs, which when combined might result in incorrect query results. Both bugs were harmless by themselves; only when they team up do they cause problems. Ticket #3581.</source>
          <target state="translated">두 가지 버그를 수정하여 결합하면 쿼리 결과가 잘못 될 수 있습니다. 두 버그 모두 스스로 무해했습니다. 그들이 팀을 구성 할 때만 문제를 일으 킵니다. 티켓 # 3581.</target>
        </trans-unit>
        <trans-unit id="c6b3c2eac5340186aa60ec6ef1bd320d9af1b4cf" translate="yes" xml:space="preserve">
          <source>Fix two problems in the new &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt;. Tickets &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN 강도 감소 최적화&lt;/a&gt; 에서 두 가지 문제를 해결하십시오 . 티켓 &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce60dbf83ec6124a3874f74bb112313a53e7aca8" translate="yes" xml:space="preserve">
          <source>Fix type coercion rules for the IN operator</source>
          <target state="translated">IN 연산자에 대한 수정 유형 강제 규칙</target>
        </trans-unit>
        <trans-unit id="1ef59214b1b8979108ab36722686dbe71717d826" translate="yes" xml:space="preserve">
          <source>Fix typos in documentation.</source>
          <target state="translated">문서에서 오타를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5df6889e7873170528ac5b7149060416fb8a48c" translate="yes" xml:space="preserve">
          <source>Fix typos in the documentation</source>
          <target state="translated">문서에서 오타 수정</target>
        </trans-unit>
        <trans-unit id="a8caeeab6423273de2d0f3b9037854eda089993c" translate="yes" xml:space="preserve">
          <source>Fix uninitialized variables causing malfunctions for various obscure queries</source>
          <target state="translated">불분명 한 다양한 쿼리에 대해 오작동을 일으키는 초기화되지 않은 변수 수정</target>
        </trans-unit>
        <trans-unit id="334faf48b2d08d39ac3f83df69ba4313064d2eca" translate="yes" xml:space="preserve">
          <source>Fix various documentation typos</source>
          <target state="translated">다양한 문서 오타 수정</target>
        </trans-unit>
        <trans-unit id="bfc06020350fd18063be73e1e193870b6478ef89" translate="yes" xml:space="preserve">
          <source>Fix various other minor test script problems.</source>
          <target state="translated">기타 여러 가지 사소한 테스트 스크립트 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="04a80b08dce7f337318b3de8005ba6821f9088b9" translate="yes" xml:space="preserve">
          <source>Fix warning messages in VC++ 7.0. (Patches from nicolas352001)</source>
          <target state="translated">VC ++ 7.0의 경고 메시지를 수정하십시오. (nicolas352001의 패치)</target>
        </trans-unit>
        <trans-unit id="e356e2b704a2e01de653ed2ebbf706f69ff2717e" translate="yes" xml:space="preserve">
          <source>Fixed &lt;b&gt;sqlite.h&lt;/b&gt; so that it is usable from C++</source>
          <target state="translated">C ++에서 사용할 수 있도록 &lt;b&gt;sqlite.h를&lt;/b&gt; 수정 했습니다.</target>
        </trans-unit>
        <trans-unit id="79e373e30e82498299cb604bd835209f11c2361f" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the &quot;copy&quot; method of the TCL interface.</source>
          <target state="translated">TCL 인터페이스의 &quot;복사&quot;방법의 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c148872cc8b9ab806e9be600a6bc5019b39f4b73" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the processing of LEFT OUTER JOIN</source>
          <target state="translated">LEFT OUTER JOIN 처리 과정에서 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8958f58770783b2b2d9b98f41e760b01637c6fbf" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the query planner that caused performance regressions relative to 3.6.23.1 on some complex joins.</source>
          <target state="translated">쿼리 플래너의 일부 복잡한 조인에서 3.6.23.1에 대한 성능 회귀를 유발하는 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce57a2f7dac9c404f24a8b0780affccd90fd36f4" translate="yes" xml:space="preserve">
          <source>Fixed a bug that caused database corruption when an &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is rolled back in an in-memory database. Ticket #3761.</source>
          <target state="translated">메모리 내 데이터베이스에서 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 이 롤백 될 때 데이터베이스가 손상되는 버그를 수정했습니다 . 티켓 # 3761.</target>
        </trans-unit>
        <trans-unit id="47075269c498ed42295ff1e4b7548fb034943cbd" translate="yes" xml:space="preserve">
          <source>Fixed a bug that was causing updates to fail inside of transactions when the database contained a temporary table.</source>
          <target state="translated">데이터베이스에 임시 테이블이 포함되어있을 때 트랜잭션 내부에서 업데이트가 실패하는 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="479bbff8b43af13fac5ef791395960b4f803b850" translate="yes" xml:space="preserve">
          <source>Fixed a critical bug in the &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; that could cause the database to become unreadable and unrecoverable if a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command changed the size of the encryption nonce.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 암호화 nonce의 크기를 변경 한 경우 데이터베이스를 읽을 수없고 복구 할 수없는 &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; 의 중요한 버그가 수정 되었습니다.</target>
        </trans-unit>
        <trans-unit id="59729403a0ff39e62d5592f59ad0496bc74d3cb0" translate="yes" xml:space="preserve">
          <source>Fixed a typo in the OS/2 backend.</source>
          <target state="translated">OS / 2 백엔드에서 오타가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="639269284376af975435d947ede551d59f7c8a90" translate="yes" xml:space="preserve">
          <source>Fixed an off-by-one error that was causing a coredump in the '%q' format directive of the new &lt;b&gt;sqlite_..._printf()&lt;/b&gt; routines.</source>
          <target state="translated">새로운 &lt;b&gt;sqlite _..._ printf ()&lt;/b&gt; 루틴 의 '% q'형식 지시문에서 코어 덤프를 발생시키는 &lt;b&gt;개별&lt;/b&gt; 오류를 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="2f93f642c24bc3ca9d72401aa0c30d511f868145" translate="yes" xml:space="preserve">
          <source>Fixed lots of spelling errors in the source-code comments</source>
          <target state="translated">소스 코드 주석에서 많은 철자 오류가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="fd59e954365ccfc713ffa89ef7eee7b8910b50c3" translate="yes" xml:space="preserve">
          <source>Fixed naming conflicts so that versions 2.8 and 3.0 can be linked and used together in the same ANSI-C source file.</source>
          <target state="translated">버전 2.8 및 3.0을 동일한 ANSI-C 소스 파일에서 링크하여 함께 사용할 수 있도록 이름 충돌이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8dc0276046c4c36ea547c5cf770bbba66b28361f" translate="yes" xml:space="preserve">
          <source>Fixed performance problems and potential stack overflows when creating &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; from multi-row VALUES clauses with hundreds of thousands of rows.</source>
          <target state="translated">수십만 행의 여러 행 VALUES 절에서 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 를 만들 때 성능 문제 및 잠재적 인 스택 오버플로가 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="48a5b411b131a16a7c3a81ff9ffe341d205ab7e3" translate="yes" xml:space="preserve">
          <source>Fixed some instances where &lt;b&gt;sqlite_exec()&lt;/b&gt; was returning the wrong error code.</source>
          <target state="translated">&lt;b&gt;sqlite_exec ()&lt;/b&gt; 가 잘못된 오류 코드를 반환하는 일부 인스턴스를 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="d2abd59d7529d7221419b75d94eed0ee9277c4cd" translate="yes" xml:space="preserve">
          <source>Fixed the &quot;.dump&quot; command in the command-line shell to show indices, triggers and views again.</source>
          <target state="translated">명령 줄 셸에서 &quot;.dump&quot;명령이 인덱스, 트리거 및 뷰를 다시 표시하도록 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="923cc8fbcaf6842679b5f1e15d6df83e508e85ec" translate="yes" xml:space="preserve">
          <source>Fixed the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; so that &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; return the correct values.</source>
          <target state="translated">&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; 가 올바른 값을 반환 하도록 &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;잘라 &lt;/a&gt;내기 최적화를 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="9e28c4773e158241fde9583f9f170c5ef9db0282" translate="yes" xml:space="preserve">
          <source>Fixed the operator precedence for the ~ operator.</source>
          <target state="translated">~ 연산자의 연산자 우선 순위를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="7effc13b7d809cd0670d65239ee3df045defba54" translate="yes" xml:space="preserve">
          <source>Fixes for various minor bugs.</source>
          <target state="translated">다양한 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="6db891bdea0dad81fb2181f92e7eface672bbf02" translate="yes" xml:space="preserve">
          <source>Fixes for various other compiler warnings and minor problems associated with obscure configurations.</source>
          <target state="translated">불분명 한 구성과 관련된 다양한 다른 컴파일러 경고 및 사소한 문제에 대한 수정.</target>
        </trans-unit>
        <trans-unit id="2582d7cc3520de6113cfebc05a4c0c40c10d2aea" translate="yes" xml:space="preserve">
          <source>Fixes to the rollback and locking behavior</source>
          <target state="translated">롤백 및 잠금 동작 수정</target>
        </trans-unit>
        <trans-unit id="300a0178f58415dda787e9c4b1d46e58f9cdc26d" translate="yes" xml:space="preserve">
          <source>FkCounter</source>
          <target state="translated">FkCounter</target>
        </trans-unit>
        <trans-unit id="a7826ae0da180dcf999c042085ef7ac58cfd77ff" translate="yes" xml:space="preserve">
          <source>FkIfZero</source>
          <target state="translated">FkIfZero</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="502eddf598188b96c0b40f89e8492bff9de3fa43" translate="yes" xml:space="preserve">
          <source>Flags For File Open Operations</source>
          <target state="translated">파일 열기 작업을위한 플래그</target>
        </trans-unit>
        <trans-unit id="9e0bdeb766ef28db46f01b095bdb326b4da9f972" translate="yes" xml:space="preserve">
          <source>Flags consist of zero or more characters that immediately follow the &quot;%&quot; that introduces the substitution. The various flags and their meanings are as follows:</source>
          <target state="translated">플래그는 대체를 소개하는 &quot;%&quot;바로 뒤에 오는 0 개 이상의 문자로 구성됩니다. 다양한 플래그와 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e52973142fb5309e0599d0aece55b28093c55ec5" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_deserialize()</source>
          <target state="translated">sqlite3_deserialize ()의 플래그</target>
        </trans-unit>
        <trans-unit id="763319af81f124ab801773d718a34a5b48132717" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_serialize</source>
          <target state="translated">sqlite3_serialize에 대한 플래그</target>
        </trans-unit>
        <trans-unit id="f15088d96e03c231ed7711a618b87a23e40d38d1" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_apply_v2</source>
          <target state="translated">sqlite3changeset_apply_v2에 대한 플래그</target>
        </trans-unit>
        <trans-unit id="9c6b7b2401c21ffe043e97decac28ab2c77bcf8f" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_start_v2</source>
          <target state="translated">sqlite3changeset_start_v2에 대한 플래그</target>
        </trans-unit>
        <trans-unit id="8565c5e3d19dd91c15d8aea38675feb62cbfe94b" translate="yes" xml:space="preserve">
          <source>Flags for the xAccess VFS method</source>
          <target state="translated">xAccess VFS 메소드의 플래그</target>
        </trans-unit>
        <trans-unit id="caa91d141d9230cced8ac027e0837943663b4e27" translate="yes" xml:space="preserve">
          <source>Flags for the xShmLock VFS method</source>
          <target state="translated">xShmLock VFS 메소드의 플래그</target>
        </trans-unit>
        <trans-unit id="a4c5b52302ff6c09b0d29efa63650e0dd9711b0a" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgemental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">유연한 타이핑은 버그가 아닌 SQLite의 기능으로 간주됩니다. 그럼에도 불구하고, 우리는이 기능으로 인해 데이터 유형과 관련하여 더 판단력이있는 다른 데이터베이스를 다루는 데 익숙한 개발자에게 혼란과 고통을 유발할 수 있음을 알고 있습니다. 돌이켜 보면 SQLite가 ANY 데이터 유형을 구현 한 경우 개발자가 유연한 타이핑을 기본값으로 사용하는 대신 유연한 타이핑을 사용하고 싶을 때 명시 적으로 언급 할 수 있다면 더 좋을 것입니다. 그러나 이는 SQLite의 유연한 타이핑 기능을 이미 사용하고있는 수백만 개의 응용 프로그램과 수십억 개의 데이터베이스 파일을 손상시키지 않고 지금 변경할 수있는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="595acd952f7adef405182868a3f64d0a5da38dfd" translate="yes" xml:space="preserve">
          <source>Flock locking style. This is used for file-systems that do not support POSIX locking style. Locks are obtained and released using the flock() system call.</source>
          <target state="translated">무리 잠금 스타일. POSIX 잠금 스타일을 지원하지 않는 파일 시스템에 사용됩니다. 잠금은 flock () 시스템 호출을 사용하여 확보 및 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c57073033af4c5995ecd6e60b89e343929d9d2c9" translate="yes" xml:space="preserve">
          <source>Flush all database file changes to the disk. Wait for those changes to actually be written onto the disk surface.</source>
          <target state="translated">디스크에 대한 모든 데이터베이스 파일 변경 사항을 비 웁니다. 변경 사항이 실제로 디스크 표면에 기록 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="de39ff51371c017e6227bb21dd0f83307b8a58ff" translate="yes" xml:space="preserve">
          <source>Flush caches to disk mid-transaction</source>
          <target state="translated">디스크 중간 트랜잭션으로 캐시 플러시</target>
        </trans-unit>
        <trans-unit id="f57e8f8a92192df5f1207764618acfad2559efdf" translate="yes" xml:space="preserve">
          <source>Follow these steps to create your own virtual table:</source>
          <target state="translated">다음 단계에 따라 고유 한 가상 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="95cf2c9a54fa89f9d97591c92b0397a9def66730" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">이 함수를 성공적으로 호출 한 후 호출자는 * ppChangeset이 &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 사용을 가리키는 버퍼를 결국 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="94243dad6fb7fd03cdf4ccdea9ad8045597be29a" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">이 함수를 성공적으로 호출 한 후 호출자는 * ppChangeset이 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 사용을 가리키는 버퍼를 결국 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ecbb1f3edb4dd34a3fdff354068e2c4ff752166" translate="yes" xml:space="preserve">
          <source>Following a system recovery, if a device sector is deemed to be untrustworthy as defined by A21008 and neither A21011 or A21012 apply to the range of bytes written, then no assumption can be made about the content of the sector following recovery. It is assumed that it is possible for such a sector to be written correctly, not written at all, populated with garbage data or any combination thereof.</source>
          <target state="translated">시스템 복구 후, 장치 섹터가 A21008에 정의 된대로 신뢰할 수없는 것으로 간주되고 A21011 또는 A21012가 기록 된 바이트 범위에 적용되지 않으면 복구 후 섹터의 내용에 대한 가정을 할 수 없습니다. 이러한 섹터는 가비지 데이터 또는 이들의 조합으로 채워져 전혀 기록되지 않고 정확하게 기록 될 수 있다고 가정된다.</target>
        </trans-unit>
        <trans-unit id="1945818b9ff5e13872866426c7d8f1fe8a043f70" translate="yes" xml:space="preserve">
          <source>Following the header is the array of coordinate pairs. Each coordinate is a 32-bit floating point number. The use of 32-bit floating point values for coordinates means that any point on the earth's surface can be mapped with a resolution of approximately 2.5 meters. Higher resolutions are of course possible if the map is restricted to a single continent or country. Note that the resolution of coordinates in the geopoly module is similar in magnitude to daily movement of points on the earth's surface due to tidal forces.</source>
          <target state="translated">헤더 다음에는 좌표 쌍 배열이 있습니다. 각 좌표는 32 비트 부동 소수점 숫자입니다. 좌표에 32 비트 부동 소수점 값을 사용하면 지구 표면의 모든 지점을 약 2.5 미터의 해상도로 매핑 할 수 있습니다. 지도가 단일 대륙 또는 국가로 제한된 경우 더 높은 해상도가 가능합니다. 지오 폴리 모듈의 좌표 분해능은 조력으로 인한 지표면의 일일 점 이동과 크기가 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="581c115a7d0dc8fd1981c305296d4c558b5b086c" translate="yes" xml:space="preserve">
          <source>Following the single big &quot;timeline&quot; query, there are additional queries for each timeline element. Fossil is using the &quot;N+1 Query&quot; pattern rather than trying to grab all the information in as few queries as possible. But that is ok because there is no unnecessary IPC overhead. At the bottom of each timeline page, Fossil shows approximately how long it took to generate the page. For a 50-entry timeline, the latency is usually less than 25 milliseconds. Profiling shows that few of those milliseconds were spent inside the database engine.</source>
          <target state="translated">하나의 큰 &quot;타임 라인&quot;쿼리 다음에 각 타임 라인 요소에 대한 추가 쿼리가 있습니다. Fossil은 가능한 적은 수의 쿼리로 모든 정보를 파악하려고 시도하기보다는 &quot;N + 1 쿼리&quot;패턴을 사용하고 있습니다. 그러나 불필요한 IPC 오버 헤드가 없기 때문에 괜찮습니다. 각 타임 라인 페이지 하단에 Fossil은 페이지를 생성하는 데 걸린 시간을 대략적으로 보여줍니다. 50 개 입력 타임 라인의 경우 대기 시간은 일반적으로 25 밀리 초 미만입니다. 프로파일 링에 따르면 데이터베이스 엔진 내부에서 소비되는 밀리 초는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="19775ac9542956e84e3786d1a483a9c9a75b880c" translate="yes" xml:space="preserve">
          <source>For BLOBs smaller than 100KB, reads are faster when the BLOBs are stored directly in the database file. For BLOBs larger than 100KB, reads from a separate file are faster.</source>
          <target state="translated">100KB보다 작은 BLOB의 경우 BLOB를 데이터베이스 파일에 직접 저장하면 읽기 속도가 빨라집니다. 100KB보다 큰 BLOB의 경우 별도의 파일에서 읽는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="395ae193aa1eadd77633da6e02ed51db87786473" translate="yes" xml:space="preserve">
          <source>For SQLite</source>
          <target state="translated">SQLite의 경우</target>
        </trans-unit>
        <trans-unit id="f3c131948733abd40fff7115bdc1ab412d61d9a8" translate="yes" xml:space="preserve">
          <source>For SQLite version 2.6.3 and earlier, all values used the numeric datatype. The text datatype appears in version 2.7.0 and later. In the sequel it is assumed that you are using version 2.7.0 or later of SQLite.</source>
          <target state="translated">SQLite 버전 2.6.3 이하의 경우 모든 값이 숫자 데이터 유형을 사용했습니다. 텍스트 데이터 유형은 버전 2.7.0 이상에 나타납니다. 후속편에서는 버전 2.7.0 이상의 SQLite를 사용하고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="942453851992f474fda1456f6f181f26cf640d20" translate="yes" xml:space="preserve">
          <source>For SQLite versions prior to 3.24.0 (2018-06-04), the only information that an R*Tree index stores about an object is its integer ID and its bounding box. Additional information needs to be stored in separate tables and related to the R*Tree index using the primary key. For the example above, one might create an auxiliary table as follows:</source>
          <target state="translated">3.24.0 (2018-06-04) 이전의 SQLite 버전의 경우 R * Tree 인덱스가 객체에 대해 저장하는 유일한 정보는 정수 ID 및 경계 상자입니다. 추가 정보는 별도의 테이블에 저장하고 기본 키를 사용하여 R * Tree 색인과 관련되어야합니다. 위의 예에서 다음과 같이 보조 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b4a9ef398b6737e332f74269051f6a928aaf6c" translate="yes" xml:space="preserve">
          <source>For a &lt;b&gt;DELETE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields only. The original values of other fields are not stored as part of a patchset.</source>
          <target state="translated">A에 대한 &lt;b&gt;DELETE&lt;/b&gt; 변화, 페이로드 만 PRIMARY KEY 필드로 구성되어 있습니다. 다른 필드의 원래 값은 패치 세트의 일부로 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bad0ea706b018c5833dc966db96c3bbf3f0b2138" translate="yes" xml:space="preserve">
          <source>For a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT JOIN or LEFT OUTER JOIN, the difference is very important. In a LEFT JOIN, the extra NULL row for the right-hand table is added after ON clause processing but before WHERE clause processing. A constraint of the form &quot;left.x=right.y&quot; in an ON clause will therefore allow through the added all-NULL rows of the right table. But if that same constraint is in the WHERE clause a NULL in &quot;right.y&quot; will prevent the expression &quot;left.x=right.y&quot; from being true, and thus exclude that row from the output.</source>
          <target state="translated">JOIN, INNER JOIN 또는 CROSS JOIN의 경우 WHERE 절의 제약 조건 식과 ON 절의 제약 조건 식에는 차이가 없습니다. 그러나 LEFT JOIN 또는 LEFT OUTER JOIN의 경우 그 차이가 매우 중요합니다. LEFT JOIN에서 오른쪽 테이블에 대한 추가 NULL 행은 ON 절 처리 후 WHERE 절 처리 전에 추가됩니다. ON 절에서 &quot;left.x = right.y&quot;형식의 제한 조건은 오른쪽 테이블의 추가 된 모든 NULL 행을 허용합니다. 그러나 동일한 제약 조건이 WHERE 절에있는 경우 &quot;right.y&quot;의 NULL은 &quot;left.x = right.y&quot;표현식이 true가되지 않도록하여 해당 행을 출력에서 ​​제외시킵니다.</target>
        </trans-unit>
        <trans-unit id="2837a8bb64314525a9077bf3440c2ed144dbb1b8" translate="yes" xml:space="preserve">
          <source>For a LEFT OUTER JOIN the situation is more complex. The following two queries are not equivalent:</source>
          <target state="translated">LEFT OUTER JOIN의 경우 상황이 더 복잡합니다. 다음 두 쿼리는 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad715a95908c984b7542ffaa9563f1288257e6ce" translate="yes" xml:space="preserve">
          <source>For a SELECT query that uses the full-text index, the offsets() function returns a text value containing a series of space-separated integers. For each term in each &lt;a href=&quot;#matchable&quot;&gt;phrase match&lt;/a&gt; of the current row, there are four integers in the returned list. Each set of four integers is interpreted as follows:</source>
          <target state="translated">전체 텍스트 인덱스를 사용하는 SELECT 쿼리의 경우 offsets () 함수는 일련의 공백으로 구분 된 정수를 포함하는 텍스트 값을 반환합니다. 현재 행 &lt;a href=&quot;#matchable&quot;&gt;과 일치&lt;/a&gt; 하는 각 구의 각 용어에 대해 반환 된 목록에 4 개의 정수가 있습니다. 4 개의 정수로 구성된 각 세트는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="6eca1d9c3f6f9db89f4bb4081945f8167605d308" translate="yes" xml:space="preserve">
          <source>For a command of the form &quot;REINDEX</source>
          <target state="translated">&quot;REINDEX 형식의 명령</target>
        </trans-unit>
        <trans-unit id="06d5551761da6c159b879a307caa21c04cdacf8a" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a master journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the master journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">여러 데이터베이스 및 마스터 저널과 관련된 커밋의 경우 다양한 데이터베이스가 다른 디스크 볼륨에 있고 커밋 중에 전원 장애가 발생하면 시스템이 다시 시작될 때 디스크가 다른 이름으로 다시 마운트 될 수 있습니다. 또는 일부 디스크가 전혀 마운트되지 않았을 수 있습니다. 이 경우 개별 파일 저널과 마스터 저널이 서로를 찾지 못할 수 있습니다. 이 시나리오에서 최악의 결과는 커밋이 원자 적이 지 않다는 것입니다. 일부 데이터베이스는 롤백되고 다른 데이터베이스는 롤백되지 않을 수 있습니다. 모든 데이터베이스는 계속 일관성을 유지합니다. 이 문제를 방지하려면 모든 데이터베이스를 동일한 디스크 볼륨에 유지하거나 정전 후에 정확히 동일한 이름을 사용하여 디스크를 다시 마운트하십시오.</target>
        </trans-unit>
        <trans-unit id="bb9e9e569c28385b62c9d2cc5d8fba70bcf036db" translate="yes" xml:space="preserve">
          <source>For a directory entry, any value inserted into this field is ignored. Otherwise, if it is set to 0, then the file data or symbolic link target is stored as is in the zip archive and the compression method set to 0. If it is set to 8, then the file data or link target is compressed using deflate compression before it is stored and the compression method set to 8. Finally, if a NULL value is written to this field, the zipfile module automatically decides whether or not to compress the data before storing it.</source>
          <target state="translated">디렉토리 항목의 경우이 필드에 삽입 된 값은 무시됩니다. 그렇지 않으면, 0으로 설정되면 파일 데이터 또는 기호 링크 대상은 zip 아카이브에있는 그대로 저장되고 압축 방법은 0으로 설정됩니다. 8로 설정되면 파일 데이터 또는 링크 대상은 다음을 사용하여 압축됩니다. 압축을 저장하기 전에 압축을 풀고 압축 방법을 8로 설정하십시오. 마지막으로,이 필드에 NULL 값이 기록되면 zipfile 모듈은 데이터를 저장하기 전에 압축할지 여부를 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="60b588cb6440e5757b3bffacb57c3da76e66f360" translate="yes" xml:space="preserve">
          <source>For a listing of the available dot commands, you can enter &quot;.help&quot; with no arguments. Or enter &quot;.help TOPIC&quot; for detailed information about TOPIC. The list of available dot-commands follows:</source>
          <target state="translated">사용 가능한 도트 명령 목록을 보려면 인수없이 &quot;.help&quot;를 입력하십시오. 또는 TOPIC에 대한 자세한 내용을 보려면 &quot;.help TOPIC&quot;을 입력하십시오. 사용 가능한 도트 명령 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4baaae0b83211d05bdb6a6f17481963667e90c7" translate="yes" xml:space="preserve">
          <source>For a program that uses an SQLite database as its &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;, when a new database instance is first created the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is ineffective because the database contain no data from which to gather statistics. In that case, one could construct a large prototype database containing typical data during development and run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on this prototype database to gather statistics, then save the prototype statistics as part of the application. After deployment, when the application goes to create a new database file, it can run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command in order to create the statistics tables, then copy the precomputed statistics obtained from the prototype database into these new statistics tables. In that way, statistics from large working data sets can be preloaded into newly created application files.</source>
          <target state="translated">SQLite 데이터베이스를 &lt;a href=&quot;appfileformat&quot;&gt;애플리케이션 파일 형식&lt;/a&gt; 으로 사용하는 프로그램의 경우, 새 데이터베이스 인스턴스가 처음 작성 될 때 데이터베이스에 통계를 수집 할 데이터가 없으므로 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령이 유효하지 않습니다. 이 경우 개발 중에 일반적인 데이터를 포함하는 대형 프로토 타입 데이터베이스를 구성 하고이 프로토 타입 데이터베이스 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하여 통계를 수집 한 다음 프로토 타입 통계를 애플리케이션의 일부로 저장할 수 있습니다. 배포 후 응용 프로그램이 새 데이터베이스 파일을 만들 때 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE를&lt;/a&gt; 실행할 수 있습니다.명령을 사용하여 통계 테이블을 작성하고 프로토 타입 데이터베이스에서 얻은 사전 계산 된 통계를이 새 통계 테이블에 복사하십시오. 이러한 방식으로 대규모 작업 데이터 세트의 통계를 새로 작성된 애플리케이션 파일에 사전로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a94574556e6541171dc1e77628bd7786ebcc44a5" translate="yes" xml:space="preserve">
          <source>For a row-value &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;, the left-hand side (hereafter &quot;LHS&quot;) can be either a parenthesized list of values or a subquery with multiple columns. But the right-hand side (hereafter &quot;RHS&quot;) must be a subquery expression.</source>
          <target state="translated">행 값 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 의 경우 왼쪽 (이하 &quot;LHS&quot;)은 괄호로 묶은 값 목록이거나 여러 열이있는 하위 쿼리 일 수 있습니다. 그러나 오른쪽 (이하 &quot;RHS&quot;)은 하위 쿼리 식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1f6b45d36586c69d55b8983f8d799c1d8e89a8c6" translate="yes" xml:space="preserve">
          <source>For a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.</source>
          <target state="translated">문자열 값 X의 경우 length (X) 함수는 첫 번째 NUL 문자 이전의 X에서 문자 수 (바이트가 아님)를 반환합니다. SQLite 문자열에는 일반적으로 NUL 문자가 포함되지 않으므로 length (X) 함수는 일반적으로 문자열 X의 총 문자 수를 반환합니다. Blob 값 X의 경우 length (X)는 Blob의 바이트 수를 반환합니다. X가 NULL이면 length (X)는 NULL입니다. X가 숫자이면 length (X)는 X의 문자열 표현 길이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7e042b4a217a46e364221bac2287b2e16ce5e8f" translate="yes" xml:space="preserve">
          <source>For added readability, also set &quot;.echo on&quot; so that the output contains the original SQL text.</source>
          <target state="translated">가독성을 높이기 위해 출력에 원본 SQL 텍스트가 포함되도록 &quot;.echo on&quot;도 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="464bd448fbdde2a69f1880b4aadf91dc5c60e76e" translate="yes" xml:space="preserve">
          <source>For additional information on how the SQLite library functions, the reader is directed to look at the SQLite source code directly. If you understand the material in this article, you should not have much difficulty in following the sources. Serious students of the internals of SQLite will probably also want to make a careful study of the VDBE opcodes as documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;. Most of the opcode documentation is extracted from comments in the source code using a script so you can also get information about the various opcodes directly from the &lt;b&gt;vdbe.c&lt;/b&gt; source file. If you have successfully read this far, you should have little difficulty understanding the rest.</source>
          <target state="translated">SQLite 라이브러리 기능에 대한 추가 정보는 독자가 SQLite 소스 코드를 직접 보도록 지시합니다. 이 기사의 내용을 이해하면 소스를 따르는 데 많은 어려움이 없어야합니다. SQLite 내부의 심각한 학생들은 &lt;a href=&quot;opcode&quot;&gt;여기에&lt;/a&gt; 설명 된대로 VDBE opcode를 신중하게 연구하기를 원할 것입니다 . 대부분의 opcode 문서는 스크립트를 사용하여 소스 코드의 주석에서 추출되므로 &lt;b&gt;vdbe.c&lt;/b&gt; 소스 파일 에서 다양한 opcode에 대한 정보를 직접 얻을 수도 있습니다. 이 글을 성공적으로 읽었다면, 나머지를 이해하는데 어려움이 거의 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5cc0c6c827845b6d255c4013e6ccd3c888188ba4" translate="yes" xml:space="preserve">
          <source>For aggregate functions, the &lt;b&gt;xStep&lt;/b&gt; callback is invoked once for each row in the result and then &lt;b&gt;xFinalize&lt;/b&gt; is invoked at the end to compute a final answer. The xStep routine can use the &lt;b&gt;sqlite_aggregate_context()&lt;/b&gt; interface to allocate memory that will be unique to that particular instance of the SQL function. This memory will be automatically deleted after xFinalize is called. The &lt;b&gt;sqlite_aggregate_count()&lt;/b&gt; routine can be used to find out how many rows of data were passed to the aggregate. The xFinalize callback should invoke one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to set the final result of the aggregate.</source>
          <target state="translated">집계 함수 의 경우 결과의 각 행에 대해 &lt;b&gt;xStep&lt;/b&gt; 콜백이 한 번 호출 된 다음 끝에 최종 응답을 계산하기 위해 &lt;b&gt;xFinalize&lt;/b&gt; 가 호출됩니다. xStep 루틴은 &lt;b&gt;sqlite_aggregate_context ()&lt;/b&gt; 인터페이스를 사용 하여 SQL 함수의 특정 인스턴스에 고유 한 메모리를 할당 할 수 있습니다. 이 메모리는 xFinalize가 호출 된 후 자동으로 삭제됩니다. &lt;b&gt;sqlite_aggregate_count ()&lt;/b&gt; 루틴은 많은 데이터 행이 집계에 전달 된 방법을 찾을 수 있습니다. xFinalize 콜백은 &lt;b&gt;sqlite_set_result _...&lt;/b&gt; 인터페이스 중 하나를 호출 하여 집계의 최종 결과를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a2b8e655022b370f7bf1cade1de14d9df62358a" translate="yes" xml:space="preserve">
          <source>For all of these errors, SQLite attempts to undo just the one statement it was working on and leave changes from prior statements within the same transaction intact and continue with the transaction. However, depending on the statement being evaluated and the point at which the error occurs, it might be necessary for SQLite to rollback and cancel the entire transaction. An application can tell which course of action SQLite took by using the &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit()&lt;/a&gt; C-language interface.</source>
          <target state="translated">이러한 모든 오류에 대해 SQLite는 작업중인 단일 명령문 만 실행 취소하고 동일한 트랜잭션 내에서 이전 명령문의 변경 사항을 그대로두고 트랜잭션을 계속합니다. 그러나 평가중인 명령문과 오류가 발생한 지점에 따라 SQLite가 전체 트랜잭션을 롤백하고 취소해야 할 수도 있습니다. 응용 프로그램은 &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit ()&lt;/a&gt; C 언어 인터페이스 를 사용하여 SQLite가 수행 한 조치 과정을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edd867afbc99c464b46e982c8bdb271f01de00a1" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">SQLite는 모든 버전의 최대 및 3.6.23.1의 호출을 포함 들어 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()를&lt;/a&gt; sqlite3_step 후 요구되었다 () 이외의 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW을&lt;/a&gt; sqlite3_step의 후속 호출하기 전에 (). &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()을&lt;/a&gt; 사용하여 준비된 명령문을 재설정하지 못하면 sqlite3_step () 에서 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE가&lt;/a&gt; 리턴됩니다. 그러나 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;버전 3.6.23.1&lt;/a&gt; (2010-03-26 이후 ), sqlite3_step ()은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE를&lt;/a&gt; 반환하지 않고이 상황에서 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()을&lt;/a&gt; 자동으로 호출하기 시작했습니다 . . &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;컴파일 타임 옵션을 사용하여 레거시 동작을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ec8a08c58f886e596c21082f16011397cbdb2b" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;컴파일 타임 옵션을 사용하여 레거시 동작을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3ef573edb29303f7422a9886c28f0ac60f646d" translate="yes" xml:space="preserve">
          <source>For allocators other than &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;, all memory allocations are of the same size. Hence, &lt;b&gt;n&lt;/b&gt;=1 and therefore &lt;b&gt;N&lt;/b&gt;=&lt;b&gt;M&lt;/b&gt;. In other words, the memory pool need be no larger than the largest amount of memory in use at any given moment.</source>
          <target state="translated">&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 이외의 할당 자의 경우 모든 메모리 할당 크기가 동일합니다. 따라서 &lt;b&gt;n&lt;/b&gt; = 1이므로 &lt;b&gt;N&lt;/b&gt; = &lt;b&gt;M&lt;/b&gt; 입니다. 즉, 메모리 풀은 주어진 순간에 사용중인 최대 메모리 양보다 크지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a2e786b5782b352cf04ddbf2d2c01d46af6ed148" translate="yes" xml:space="preserve">
          <source>For an &lt;b&gt;UPDATE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields and the new values of modified fields only. The original values of modified fields are not stored as part of a patchset.</source>
          <target state="translated">위해 &lt;b&gt;업데이트&lt;/b&gt; , 변경, 페이로드는 PRIMARY KEY 필드 만 변경되는 필드의 새로운 값으로 구성된다. 수정 된 필드의 원래 값은 패치 세트의 일부로 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87c8bcb65c916a4e76edf02935c7238f192ed71f" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">&lt;a href=&quot;../rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에 대한 UPDATE 또는 DELETE 조작의 경우 사전 갱신 콜백에 전달 된 여섯 번째 매개 변수 는 수정 또는 삭제되는 행 의 초기 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다. rowid 테이블에 대한 INSERT 조작 또는 WITHOUT ROWID 테이블에 대한 조작의 경우, 여섯 번째 매개 변수의 값은 정의되지 않습니다. rowid 테이블의 INSERT 또는 UPDATE의 경우 일곱 번째 매개 변수는 삽입 또는 업데이트되는 행의 최종 rowid 값입니다. 콜백 함수에 전달 된 7 번째 매개 변수의 값은 WITHOUT ROWID 테이블의 조작 또는 rowid 테이블의 INSERT 조작에 대해 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3fa74a389b030ce220f00901508abe1120507900" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">&lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에 대한 UPDATE 또는 DELETE 조작의 경우 사전 갱신 콜백에 전달 된 여섯 번째 매개 변수 는 수정 또는 삭제되는 행 의 초기 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다. rowid 테이블에 대한 INSERT 조작 또는 WITHOUT ROWID 테이블에 대한 조작의 경우, 여섯 번째 매개 변수의 값은 정의되지 않습니다. rowid 테이블의 INSERT 또는 UPDATE의 경우 일곱 번째 매개 변수는 삽입 또는 업데이트되는 행의 최종 rowid 값입니다. 콜백 함수에 전달 된 7 번째 매개 변수의 값은 WITHOUT ROWID 테이블의 조작 또는 rowid 테이블의 INSERT 조작에 대해 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6babaeb551e0ac84ca65632772689ec35209b982" translate="yes" xml:space="preserve">
          <source>For an example of an INSTEAD OF trigger, consider the following schema:</source>
          <target state="translated">INSTEAD OF 트리거의 예를 보려면 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb2ec7dc6172161d64c33e9d01d6ab6fb648efe" translate="yes" xml:space="preserve">
          <source>For an expression, the datatype of the result is often determined by the outermost operator. For example, arithmetic operators (&quot;+&quot;, &quot;*&quot;, &quot;%&quot;) always return a numeric results. The string concatenation operator (&quot;||&quot;) returns a text result. And so forth. If you are ever in doubt about the datatype of an expression you can use the special &lt;b&gt;typeof()&lt;/b&gt; SQL function to determine what the datatype is. For example:</source>
          <target state="translated">표현식의 경우 결과의 데이터 유형은 종종 가장 바깥 쪽 연산자에 의해 결정됩니다. 예를 들어, 산술 연산자 ( &quot;+&quot;, &quot;*&quot;, &quot;%&quot;)는 항상 숫자 결과를 반환합니다. 문자열 연결 연산자 ( &quot;||&quot;)는 텍스트 결과를 반환합니다. 기타 등등. 표현식의 데이터 유형에 대해 의문이있는 경우 특수 &lt;b&gt;typeof ()&lt;/b&gt; SQL 함수를 사용하여 데이터 유형이 무엇인지 판별 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8771671648f56259c0348d58066fbd244a9f5761" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. But special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">내부 조인의 경우 위의 두 쿼리는 동일합니다. 그러나 특수 처리는 OUTER 조인의 ON 및 USING 절에 적용됩니다. 특히, 조인의 오른쪽 테이블이 널 (NULL) 행에있는 경우 ON 또는 USING 절의 제한 조건이 적용되지 않지만 WHERE 절에 제한 조건이 적용됩니다. . 결과적으로 WHERE 절에 LEFT JOIN에 ON 또는 USING 절 표현식을 넣으면 쿼리가 일반 INNER JOIN으로 효과적으로 변환됩니다 (내부 조인은 더 느리게 실행 됨).</target>
        </trans-unit>
        <trans-unit id="a4c04f89a73080a41ad80cd0704141b22ed403a6" translate="yes" xml:space="preserve">
          <source>For an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a &quot;TEMP&quot; database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.</source>
          <target state="translated">일반적인 온 디스크 데이터베이스 파일의 경우 직렬화는 디스크 파일의 사본 일뿐입니다. 메모리 내 데이터베이스 또는 &quot;TEMP&quot;데이터베이스의 경우 직렬화는 해당 데이터베이스가 디스크에 백업 된 경우 디스크에 기록되는 바이트 시퀀스와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="363689c9e649bf1c45ea48634a5a7f396dccdc2a" translate="yes" xml:space="preserve">
          <source>For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; that tries to pick the fastest and most efficient algorithm for each SQL statement.</source>
          <target state="translated">주어진 SQL 문에 대해 조작을 수행하는 수백 또는 수천 또는 수백만 가지의 다른 알고리즘이있을 수 있습니다. 이러한 알고리즘은 모두 정답을 얻지 만 일부 알고리즘은 다른 알고리즘보다 빠르게 실행됩니다. 쿼리 플래너는 각 SQL 문에 대해 가장 빠르고 효율적인 알고리즘을 선택하려고 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20178a76e031f6e0dd46cd965f669f77257d11d8" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indices on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">주어진 쿼리에 대해 여기에 설명 된 OR 절 최적화를 사용할 수 있다고해서 이것이 사용될 것이라는 보장은 없습니다. SQLite는 다양한 경쟁 쿼리 계획의 CPU 및 디스크 I / O 비용을 추정하고 가장 빠른 계획을 선택하는 비용 기반 쿼리 플래너를 사용합니다. WHERE 절에 많은 OR 용어가 있거나 개별 OR 절 하위 용어의 일부 인덱스가 매우 선택적이지 않은 경우 SQLite는 다른 쿼리 알고리즘 또는 전체 테이블 스캔을 사용하는 것이 더 빠르다고 결정할 수 있습니다. 응용 프로그램 개발자는 명령문 에서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN 접&lt;/a&gt; 두부를 사용 하여 선택된 조회 전략에 대한 상위 레벨 개요를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c7cb0ca5e5ce3a2a0070ff33c0953ef0a2395f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">모든 SQLite 히스토리 버전의 경우 소스 트리는 특정 버전에 대한 tarball 또는 ZIP 아카이브를 다운로드하거나 전체 프로젝트 히스토리를 복제하여 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; 버전 제어 시스템 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38f9906eb0f1f05679eef0c31ffe0e8cfcb13adf" translate="yes" xml:space="preserve">
          <source>For backwards compatibility with older versions of SQLite that lack the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface, the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically upon entry to certain key interfaces such as &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. The overhead of invoking &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; automatically in this way may be omitted by building SQLite with the SQLITE_OMIT_AUTOINIT C-preprocessor macro. When built using SQLITE_OMIT_AUTOINIT, SQLite will not automatically initialize itself and the application is required to invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; directly prior to beginning use of the SQLite library.</source>
          <target state="translated">&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 인터페이스 가없는 이전 버전의 SQLite와의 호환성을 위해 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 특정 키 인터페이스에 진입하면 자동으로 호출됩니다 . 이러한 방식으로 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()를&lt;/a&gt; 자동으로 호출하는 오버 헤드는 SQLITE_OMIT_AUTOINIT C 전 처리기 매크로를 사용하여 SQLite를 빌드하여 생략 할 수 있습니다. SQLITE_OMIT_AUTOINIT를 사용하여 빌드 할 때 SQLite는 자동으로 자체 초기화되지 않으며 SQLite 라이브러리를 사용하기 전에 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()를&lt;/a&gt; 직접 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad7a915b64d6fe6bb79ac5b4ba72d86b2b8e4dad" translate="yes" xml:space="preserve">
          <source>For bitmask tests, &lt;code&gt;testcase()&lt;/code&gt; macros are used to verify that every bit of the bitmask affects the outcome. For example, in the following block of code, the condition is true if the mask contains either of two bits indicating either a MAIN_DB or a TEMP_DB is being opened. The &lt;code&gt;testcase()&lt;/code&gt; macros that precede the if statement verify that both cases are tested:</source>
          <target state="translated">비트 마스크 테스트의 경우 &lt;code&gt;testcase()&lt;/code&gt; 매크로를 사용하여 비트 마스크의 모든 비트가 결과에 영향을 미치는지 확인합니다. 예를 들어, 다음 코드 블록에서 마스크에 MAIN_DB 또는 TEMP_DB가 열려 있음을 나타내는 두 비트 중 하나가 포함되어 있으면 조건이 참입니다. if 문 앞에 나오는 &lt;code&gt;testcase()&lt;/code&gt; 매크로는 두 경우 모두 테스트되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1eab60de14b7b002b878e809e16b0c4001fb65d3" translate="yes" xml:space="preserve">
          <source>For both text and numeric values, NULL sorts before any other value. A comparison of any value against NULL using operators like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot; is always false.</source>
          <target state="translated">텍스트 및 숫자 값의 경우 NULL은 다른 값보다 먼저 정렬됩니다. &quot;&amp;lt;&quot;또는 &quot;&amp;gt; =&quot;와 같은 연산자를 사용하여 NULL에 대한 값을 비교하는 것은 항상 false입니다.</target>
        </trans-unit>
        <trans-unit id="0001dc558eb2ab6e42a7bb8e2fadd29ee6f23dde" translate="yes" xml:space="preserve">
          <source>For brevity, the diagrams in this section are simplified from those that came before. Blue color still signifies original content and pink still signifies new content. But the individual pages in the rollback journal and the database file are not shown and we are not making the distinction between information in the operating system cache and information that is on disk. All of these factors still apply in a multi-file commit scenario. They just take up a lot of space in the diagrams and they do not add any new information, so they are omitted here.</source>
          <target state="translated">간결하게하기 위해이 섹션의 다이어그램은 이전의 다이어그램에서 단순화되었습니다. 파란색은 여전히 ​​원본 콘텐츠를 나타내고 분홍색은 여전히 ​​새 콘텐츠를 나타냅니다. 그러나 롤백 저널의 개별 페이지와 데이터베이스 파일은 표시되지 않으며 운영 체제 캐시의 정보와 디스크의 정보를 구분하지 않습니다. 이러한 모든 요소는 여전히 다중 파일 커밋 시나리오에 적용됩니다. 그들은 다이어그램에서 많은 공간을 차지하고 새로운 정보를 추가하지 않으므로 여기에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="4e31069a755a0df659f64899fd564b4a8cf6e824" translate="yes" xml:space="preserve">
          <source>For command-line usage, add the short style command-line options immediately following the &quot;-A&quot;, without an intervening space. All subsequent arguments are considered to be part of the .archive command. For example, the following commands are equivalent:</source>
          <target state="translated">명령 줄 사용의 경우 공백없이 &quot;-A&quot;바로 다음에 짧은 스타일 명령 줄 옵션을 추가하십시오. 이후의 모든 인수는 .archive 명령의 일부로 간주됩니다. 예를 들어 다음 명령은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b9d0d974a63b482f33f7f36907a5721a5611077f" translate="yes" xml:space="preserve">
          <source>For commit records, the size of the database file in pages after the commit. For all other records, zero.</source>
          <target state="translated">커밋 레코드의 경우 커밋 후 페이지의 데이터베이스 파일 크기입니다. 다른 모든 레코드의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="e91c377baed35ec4162bb3c1ca2f7aeb4671aa6f" translate="yes" xml:space="preserve">
          <source>For compatibility with older &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations, this flag is turned on temporarily while the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method is being run. The value of this flag is restore after the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method finishes.</source>
          <target state="translated">이전 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 과의 호환성 을 위해 &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; 메소드가 실행되는 동안이 플래그가 일시적으로 켜집니다 . 이 플래그의 값은 &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; 메소드가 완료된 후 복원 됩니다.</target>
        </trans-unit>
        <trans-unit id="da9484ca4033054fc98b8e99fd5bf556ff20f8cb" translate="yes" xml:space="preserve">
          <source>For completeness, some of the higher level formatting information contains in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document and elsewhere is replicated here, when it pertains to WAL mode processing.</source>
          <target state="translated">완성도를 높이기 위해 일부 상위 레벨 형식화 정보는 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 문서에 포함되며 WAL 모드 처리와 관련하여 여기에 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="e99fbef35a40e331c478cf6f191e30ae20bee3b1" translate="yes" xml:space="preserve">
          <source>For correct operation of the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;, make a copy of the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib source code&lt;/a&gt; into the compat/zlib subdirectory of the source tree and compile this way:</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령이&lt;/a&gt; 올바르게 작동 하려면 &lt;a href=&quot;https://zlib.net&quot;&gt;zlib 소스 코드&lt;/a&gt; 의 사본을 소스 트리의 compat / zlib 서브 디렉토리에 작성하고 다음과 같이 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="a28c51fc9c57d328cc18317fd43208e2e391d0d1" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps thing simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">라이터 동시성이 적고 테라 바이트 미만의 컨텐츠를 가진 장치 로컬 스토리지의 경우 SQLite는 거의 항상 더 나은 솔루션입니다. SQLite는 빠르고 안정적이며 구성이나 유지 관리가 필요 없습니다. 일을 단순하게 유지합니다. SQLite는 &quot;그냥 작동합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="14026abb0078c30fcbc6bf88b3e2948c23e3f5c6" translate="yes" xml:space="preserve">
          <source>For doclists for which the term appears in more than one column of the FTS virtual table, term-offset lists within the doclist are stored in column number order. This ensures that the term-offset list associated with column 0 (if any) is always first, allowing the first two fields of the term-offset list to be omitted in this case.</source>
          <target state="translated">용어가 FTS 가상 테이블의 둘 이상의 열에 나타나는 문서 목록의 경우 문서 목록 내의 용어 오프셋 목록은 열 번호 순서로 저장됩니다. 이렇게하면 열 0과 연관된 용어 오프셋 목록 (있는 경우)이 항상 첫 번째이므로 용어 오프셋 목록의 처음 두 필드를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b4ec40df531b5b987432b4a7fed5ea5b3e27ac" translate="yes" xml:space="preserve">
          <source>For each DELETE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all non-primary key columns also match the values stored in the changeset the row is deleted from the target database.</source>
          <target state="translated">각 DELETE 변경에 대해 함수는 대상 데이터베이스에 변경 세트에 저장된 원래 행 값과 동일한 기본 키 값이있는 행이 있는지 확인합니다. 일치하는 경우 기본이 아닌 모든 키 열에 저장된 값도 변경 세트에 저장된 값과 일치하며 행이 대상 데이터베이스에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb2d165bb57742263f5c19d2ad3dc7e863bddd8" translate="yes" xml:space="preserve">
          <source>For each FTS virtual table in a database, three to five real (non-virtual) tables are created to store the underlying data. These real tables are called &quot;shadow tables&quot;. The real tables are named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot;, where &quot;%&quot; is replaced by the name of the FTS virtual table.</source>
          <target state="translated">데이터베이스의 각 FTS 가상 테이블에 대해 기본 데이터를 저장하기 위해 3 ~ 5 개의 실제 (가상이 아닌) 테이블이 생성됩니다. 이러한 실제 테이블을 &quot;새도우 테이블&quot;이라고합니다. 실제 테이블의 이름은 &quot;% _content&quot;, &quot;% _segdir&quot;, &quot;% _segments&quot;, &quot;% _stat&quot;및 &quot;% _docsize&quot;입니다. 여기서 &quot;%&quot;는 FTS 가상 테이블의 이름으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ca14bfe0c8ef783300da3fae2f2faf6123712788" translate="yes" xml:space="preserve">
          <source>For each INSERT change, an attempt is made to insert the new row into the database. If the changeset row contains fewer fields than the database table, the trailing fields are populated with their default values.</source>
          <target state="translated">각 INSERT 변경에 대해 데이터베이스에 새 행을 삽입하려고 시도합니다. 변경 세트 행에 데이터베이스 테이블보다 적은 수의 필드가 포함 된 경우 후행 필드가 기본값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="af26a43594c40c8d5075b1d213281d1a0d5d674e" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all modified non-primary key columns also match the values stored in the changeset the row is updated within the target database.</source>
          <target state="translated">각 UPDATE 변경에 대해 함수는 대상 데이터베이스에 변경 세트에 저장된 원래 행 값과 동일한 기본 키 값이있는 행이 있는지 확인합니다. 일치하는 경우 수정 된 기본이 아닌 모든 키 열에 저장된 값도 변경 집합에 저장된 값과 일치하며 대상 데이터베이스 내에서 행이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2b6b338ac313921ef720ea9cbd33ced2c0a043" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the old.* and new.* values are exchanged.</source>
          <target state="translated">각 UPDATE 변경에 대해 old. * 및 new. * 값이 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a86ead2de9a7fdab60caec05b45cc30754d41b" translate="yes" xml:space="preserve">
          <source>For each cell in the r-tree structure (%_node table), that:</source>
          <target state="translated">r- 트리 구조 (% _node 테이블)의 각 셀에 대해 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44564b0e8d37eeca09117cb0ce5677dfdd15f643" translate="yes" xml:space="preserve">
          <source>For each change for which there is a compatible table, an attempt is made to modify the table contents according to the UPDATE, INSERT or DELETE change. If a change cannot be applied cleanly, the conflict handler function passed as the fifth argument to sqlite3changeset_apply() may be invoked. A description of exactly when the conflict handler is invoked for each type of change is below.</source>
          <target state="translated">호환 가능한 테이블이있는 각 변경에 대해 UPDATE, INSERT 또는 DELETE 변경에 따라 테이블 내용을 수정하려고 시도합니다. 변경 사항을 완전히 적용 할 수 없으면 sqlite3changeset_apply ()에 다섯 번째 인수로 전달 된 충돌 처리기 함수가 호출 될 수 있습니다. 각 유형의 변경에 대해 충돌 핸들러가 호출되는시기에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fabf5b0df1d79746c4d3b0f7c3d3e26095a89ed6" translate="yes" xml:space="preserve">
          <source>For each column in a row of the result, the name of that column is used as an index in to array and the value of the column is stored in the corresponding array entry. (Caution: If two or more columns in the result set of a query have the same name, then the last column with that name will overwrite prior values and earlier columns with the same name will be inaccessible.) The special array index * is used to store a list of column names in the order that they appear.</source>
          <target state="translated">결과 행의 각 열에 대해 해당 열의 이름이 배열에 대한 인덱스로 사용되며 열의 값은 해당 배열 항목에 저장됩니다. (주의 : 쿼리 결과 집합의 둘 이상의 열에 동일한 이름이 있으면 해당 이름을 가진 마지막 열이 이전 값을 덮어 쓰고 같은 이름을 가진 이전 열에 액세스 할 수 없습니다.) 특수 배열 인덱스 *가 사용됩니다. 표시되는 순서대로 열 이름 목록을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="c334738444e4ad47d383e7911a76c91bc19cd2c6" translate="yes" xml:space="preserve">
          <source>For each column, the average number of tokens in the text values stored in the column (considering all rows in the FTS4 table). This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">각 열에 대해 열에 저장된 텍스트 값의 평균 토큰 수 (FTS4 테이블의 모든 행을 고려). 이 값은 FTS3이 아닌 FTS4 테이블을 쿼리 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8f829d184d100e174a5aa5857d53deb24e800d" translate="yes" xml:space="preserve">
          <source>For each column, the length of the longest subsequence of phrase matches that the column value has in common with the query text. For example, if a table column contains the text 'a b c d e' and the query is 'a c &quot;d e&quot;', then the length of the longest common subsequence is 2 (phrase &quot;c&quot; followed by phrase &quot;d e&quot;).</source>
          <target state="translated">각 열에 대해 구문의 가장 긴 하위 시퀀스의 길이는 열 값이 쿼리 텍스트와 공통으로 일치합니다. 예를 들어, 테이블 열에 텍스트 'abcde'가 포함되고 쿼리가 'ac &quot;d e'인 경우 가장 긴 공통 하위 시퀀스의 길이는 2입니다 (구문&quot;c &quot;뒤에 구&quot;d e &quot;).</target>
        </trans-unit>
        <trans-unit id="a1353b0cd18d624357976b5c201f2ed175d084b1" translate="yes" xml:space="preserve">
          <source>For each column, the length of the value stored in the current row of the FTS4 table, in tokens. This value is only available when querying FTS4 tables, not FTS3. And only if the &quot;matchinfo=fts3&quot; directive was not specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create the FTS4 table.</source>
          <target state="translated">각 열에 대해 FTS4 테이블의 현재 행에 저장된 값의 길이 (토큰)입니다. 이 값은 FTS3이 아닌 FTS4 테이블을 쿼리 할 때만 사용할 수 있습니다. &quot;matchinfo = fts3&quot;지시문이 FTS4 테이블을 작성하는 데 사용 된 &quot;CREATE VIRTUAL TABLE&quot;문의 일부로 지정되지 않은 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8b6483ba6be5818f8c523c79ce85a1e7ccc3ba" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the following three values:</source>
          <target state="translated">구와 테이블 열의 각 고유 조합에 대해 다음 세 가지 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf92fe281dadfcf306551aea2a8a2fccc4c37192" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the number of usable phrase matches that appear in the column. This is usually identical to the first value in each set of three returned by the &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x' flag&lt;/a&gt;. However, the number of hits reported by the 'y' flag is zero for any phrase that is part of a sub-expression that does not match the current row. This makes a difference for expressions that contain AND operators that are descendants of OR operators. For example, consider the expression:</source>
          <target state="translated">구와 테이블 열의 각 고유 한 조합에 대해 열에 나타나는 사용 가능한 구의 수가 일치합니다. 이것은 보통 &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x'플래그에&lt;/a&gt; 의해 반환되는 각 세 세트의 첫 번째 값과 동일합니다 . 그러나 'y'플래그로보고되는 적중 수는 현재 행과 일치하지 않는 하위 표현식의 일부인 구에 대해 0입니다. 이는 OR 연산자의 자손 인 AND 연산자를 포함하는 표현식에 차이를 만듭니다. 예를 들어, 다음 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fffbd38440022e9244e6e0693275b0d19d1857ad" translate="yes" xml:space="preserve">
          <source>For each modified table, a changeset includes the following:</source>
          <target state="translated">수정 된 각 테이블에 대해 변경 세트에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a24f08d30b83fb31d42fefd2e7c6a4eb2dab4115" translate="yes" xml:space="preserve">
          <source>For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.</source>
          <target state="translated">USING 절로 식별 된 각 열 쌍에 대해 오른쪽 데이터 세트의 열이 결합 된 데이터 세트에서 생략됩니다. 이것은 USING 절과 동등한 ON 제한 조건의 유일한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="9c5c3e6a930debab2d5dd5b538d4a23999481e17" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an INSERT operation, the sessions module checks if there is a row with a matching primary key still in the table. If so, an INSERT change is added to the changeset.</source>
          <target state="translated">INSERT 조작의 결과로 기록 된 각 기본 키에 대해 세션 모듈은 테이블에 일치하는 기본 키가있는 행이 있는지 확인합니다. 그렇다면 INSERT 변경 사항이 변경 집합에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="829855e999389ecdd1577f6b633317b639cef854" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an UPDATE or DELETE operation, the sessions module also checks for a row with a matching primary key within the table. If one can be found, but one or more of the non-PRIMARY KEY fields does not match the original recorded value, an UPDATE is added to the changeset. Or, if there is no row at all with the specified primary key, a DELETE is added to the changeset. If the row does exist but none of the non-PRIMARY KEY fields have been modified, no change is added to the changeset.</source>
          <target state="translated">UPDATE 또는 DELETE 조작의 결과로 기록 된 각 기본 키에 대해 세션 모듈은 또한 테이블 내에서 일치하는 기본 키가있는 행을 확인합니다. 하나를 찾을 수 있지만 기본이 아닌 키 필드 중 하나 이상이 원래 기록 된 값과 일치하지 않으면 UPDATE가 변경 세트에 추가됩니다. 또는 지정된 기본 키가있는 행이 없으면 변경 세트에 DELETE가 추가됩니다. 행이 존재하지만 기본이 아닌 키 필드가 수정되지 않은 경우 변경 세트에 변경 사항이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d07e7398b3da8e6434d5c2443839062a6f35040b" translate="yes" xml:space="preserve">
          <source>For each record generated by an insert, the database is queried for a row with a matching primary key. If one is found, an INSERT change is added to the changeset. If no such row is found, no change is added to the changeset.</source>
          <target state="translated">삽입에 의해 생성 된 각 레코드에 대해 일치하는 기본 키가있는 행에 대해 데이터베이스가 조회됩니다. 발견되면 INSERT 변경 사항이 변경 세트에 추가됩니다. 그러한 행이 없으면 변경 세트에 변경 사항이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9651a17487870ac448b95f61451215a9e031bca7" translate="yes" xml:space="preserve">
          <source>For each record generated by an update or delete, the database is queried for a row with a matching primary key. If such a row is found and one or more of the non-primary key fields have been modified from their original values, an UPDATE change is added to the changeset. Or, if no such row is found in the table, a DELETE change is added to the changeset. If there is a row with a matching primary key in the database, but all fields contain their original values, no change is added to the changeset.</source>
          <target state="translated">업데이트 또는 삭제로 생성 된 각 레코드에 대해 일치하는 기본 키가있는 행에 대해 데이터베이스가 쿼리됩니다. 이러한 행이 발견되고 기본이 아닌 키 필드 중 하나 이상이 원래 값에서 수정 된 경우 UPDATE 변경 사항이 변경 세트에 추가됩니다. 또는 테이블에 해당 행이 없으면 DELETE 변경 사항이 변경 집합에 추가됩니다. 데이터베이스에 일치하는 기본 키가있는 행이 있지만 모든 필드에 원래 값이 포함되어 있으면 변경 세트에 변경 사항이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d85944e801be901ece01bab4a06681779097370" translate="yes" xml:space="preserve">
          <source>For each record in the first table, do:</source>
          <target state="translated">첫 번째 테이블의 각 레코드에 대해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="db1b960f818a6af8cfaa2c24a19e780d2703af81" translate="yes" xml:space="preserve">
          <source>For each record in the second table do:</source>
          <target state="translated">두 번째 테이블의 각 레코드에 대해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="07832e91f880502fa8c96087f4d7417bdd043461" translate="yes" xml:space="preserve">
          <source>For each record in the table, do:</source>
          <target state="translated">테이블의 각 레코드에 대해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="87586acdd8d3aae53c73008136985fcb94271fa7" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in both tables, but features different non-PK values in each, an UPDATE record is added to the session.</source>
          <target state="translated">두 테이블에 존재하지만 각각 다른 비 PK 값을 갖는 각 행 (기본 키)에 대해 UPDATE 레코드가 세션에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b65ebd60d0a165260cae83ea942ac1bc3113efb" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, a DELETE record is added to the session object.</source>
          <target state="translated">To 테이블에는 있지만 From 테이블에는없는 각 행 (1 차 키)에 대해 DELETE 레코드가 세션 오브젝트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9d14fe0322a1c66d129265052088ccffec38ab12" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, an INSERT record is added to the session object.</source>
          <target state="translated">To 테이블에는 있지만 From 테이블에는없는 각 행 (1 차 키)에 대해 INSERT 레코드가 세션 오브젝트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4da03b9da8c161d1cf42bd495a3368247989f4" translate="yes" xml:space="preserve">
          <source>For each row in the FTS table, the %_docsize table contains a corresponding row with the same &quot;docid&quot; value. The &quot;size&quot; field contains a blob consisting of</source>
          <target state="translated">FTS 테이블의 각 행에 대해 % _docsize 테이블에는 동일한 &quot;docid&quot;값을 가진 해당 행이 포함됩니다. &quot;크기&quot;필드는 다음으로 구성된 얼룩을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a8c233269c53521f30c5ffc0bf77144b7402512d" translate="yes" xml:space="preserve">
          <source>For each row to DELETE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 1. The real primary key values of the row to delete should be stored in the corresponding columns of the data_% table. The values stored in the other columns are not used.</source>
          <target state="translated">RBU 업데이트의 일부로 대상 데이터베이스에서 각 행을 삭제하려면 해당 data_ % 테이블에 정수 값 1을 포함하도록 설정된 &quot;rbu_control&quot;열이있는 단일 레코드가 포함되어야합니다. 삭제할 행의 실제 기본 키 값은 data_ % 테이블의 해당 열에 저장됩니다. 다른 열에 저장된 값은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a5706b24e2b237dcb339a0ad1090fb73a23781f" translate="yes" xml:space="preserve">
          <source>For each row to INSERT into the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 0. The other columns should be set to the values that make up the new record to insert.</source>
          <target state="translated">RBU 업데이트의 일부로 대상 데이터베이스에 삽입 할 각 행에 대해 해당 data_ % 테이블에는 정수 값 0을 포함하도록 설정된 &quot;rbu_control&quot;열이있는 단일 레코드가 포함되어야합니다. 다른 열은 다음 값을 설정해야합니다. 삽입 할 새 레코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="34669c17538b482482cba6957b264502d60d1060" translate="yes" xml:space="preserve">
          <source>For each row to UPDATE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain a value of type text. The real primary key values identifying the row to update should be stored in the corresponding columns of the data_% table row, as should the new values of all columns being update. The text value in the &quot;rbu_control&quot; column must contain the same number of characters as there are columns in the target database table, and must consist entirely of 'x' and '.' characters (or in some special cases 'd' - see below). For each column that is being updated, the corresponding character is set to 'x'. For those that remain as they are, the corresponding character of the rbu_control value should be set to '.'. For example, given the tables above, the update statement:</source>
          <target state="translated">RBU 업데이트의 일부로 대상 데이터베이스에서 UPDATE 할 각 행에 대해 해당 data_ % 테이블에는 &quot;rbu_control&quot;열이 text 유형의 값을 포함하도록 설정된 단일 레코드가 포함되어야합니다. 업데이트 할 행을 식별하는 실제 기본 키 값은 업데이트중인 모든 열의 새 값과 마찬가지로 data_ % 테이블 행의 해당 열에 저장해야합니다. &quot;rbu_control&quot;열의 텍스트 값은 대상 데이터베이스 테이블의 열과 동일한 수의 문자를 포함해야하며 'x'와 '.'로만 이루어져야합니다. 문자 (또는 특수한 경우 'd'-아래 참조) 업데이트중인 각 열에 대해 해당 문자가 'x'로 설정됩니다. 그대로 남아있는 사람들에게는rbu_control 값의 해당 문자는 '.'로 설정되어야합니다. 예를 들어, 위의 표에서 update 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a430b6812c406e37a693a08685ab05caa617b118" translate="yes" xml:space="preserve">
          <source>For each such constraint, the aConstraint[].iColumn field indicates which column appears on the left-hand side of the constraint. The first column of the virtual table is column 0. The rowid of the virtual table is column -1. The aConstraint[].op field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants map integer constants into operator values. Columns occur in the order they were defined by the call to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; in the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method. Hidden columns are counted when determining the column index.</source>
          <target state="translated">이러한 각 제약 조건에 대해 aConstraint []. iColumn 필드는 제약 조건의 왼쪽에 표시되는 열을 나타냅니다. 가상 테이블의 첫 번째 열은 열 0입니다. 가상 테이블의 rowid는 열 -1입니다. aConstraint []. op 필드는 사용되는 연산자를 나타냅니다. SQLITE_INDEX_CONSTRAINT_ * 상수는 정수 상수를 연산자 값에 맵핑합니다. &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드 에서 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 호출에 의해 정의 된 순서대로 열이 발생합니다 . 열 인덱스를 결정할 때 숨겨진 열이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f5aad29ac204438525f336e09bd7bc093d292717" translate="yes" xml:space="preserve">
          <source>For each table in the target database that will be modified by the update, a corresponding table is created within the RBU database. The RBU database table schema is not the same as that of the target database, but is derived from it as &lt;a href=&quot;rbu#database_tables&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">업데이트로 수정 될 대상 데이터베이스의 각 테이블에 대해 해당 테이블이 RBU 데이터베이스 내에 작성됩니다. RBU 데이터베이스 테이블 스키마는 대상 데이터베이스의 스키마와 동일하지 않지만 &lt;a href=&quot;rbu#database_tables&quot;&gt;아래에 설명 된대로&lt;/a&gt; 파생 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f11dacd70a0954440fff36de5fbb6ca308465c38" translate="yes" xml:space="preserve">
          <source>For each table in the target database, the RBU database should contain a table named &quot;data&amp;lt;</source>
          <target state="translated">대상 데이터베이스의 각 테이블에 대해 RBU 데이터베이스에는 &quot;data &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42f788bf7b6ac170ed8ce05feddfec2cba592bef" translate="yes" xml:space="preserve">
          <source>For each table read by the query, the output of EXPLAIN QUERY PLAN includes a record for which the value in the &quot;detail&quot; column begins with either &quot;SCAN&quot; or &quot;SEARCH&quot;. &quot;SCAN&quot; is used for a full-table scan, including cases where SQLite iterates through all records in a table in an order defined by an index. &quot;SEARCH&quot; indicates that only a subset of the table rows are visited. Each SCAN or SEARCH record includes the following information:</source>
          <target state="translated">쿼리에서 읽은 각 테이블에 대해 EXPLAIN QUERY PLAN의 출력에는 &quot;세부 사항&quot;열의 값이 &quot;SCAN&quot;또는 &quot;SEARCH&quot;로 시작하는 레코드가 포함됩니다. &quot;SCAN&quot;은 SQLite가 인덱스에 의해 정의 된 순서대로 테이블의 모든 레코드를 반복하는 경우를 포함하여 전체 테이블 스캔에 사용됩니다. &quot;SEARCH&quot;는 테이블 행의 서브 세트 만 방문 함을 나타냅니다. 각 스캔 또는 검색 레코드에는 다음 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ecba2625cd566548c3eee164f8360eb376f2aaad" translate="yes" xml:space="preserve">
          <source>For each table that is not excluded by the filter callback, this function tests that the target database contains a compatible table. A table is considered compatible if all of the following are true:</source>
          <target state="translated">필터 콜백에서 제외되지 않은 각 테이블에 대해이 함수는 대상 데이터베이스에 호환 가능한 테이블이 포함되어 있는지 테스트합니다. 다음 모두에 해당하면 테이블이 호환 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a67fb3e6d59fc22a676badf1b731424e48e59895" translate="yes" xml:space="preserve">
          <source>For each term in a document, the FTS index maintained by FTS5 stores the rowid of the document, the column number of the column that contains the term and the offset of the term within the column value. The &quot;detail&quot; option may be used to omit some of this information. This reduces the space that the index consumes within the database file, but also reduces the capability and efficiency of the system.</source>
          <target state="translated">문서의 각 용어에 대해 FTS5가 유지 관리하는 FTS 인덱스는 문서의 rowid, 용어를 포함하는 열의 열 번호 및 열 값 내에 용어의 오프셋을 저장합니다. &quot;상세 정보&quot;옵션은이 정보 중 일부를 생략하는 데 사용될 수 있습니다. 이렇게하면 인덱스가 데이터베이스 파일 내에서 사용하는 공간이 줄어들지 만 시스템의 기능과 효율성도 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ec159e8f6dc1a68285f736b240d086ca832050e3" translate="yes" xml:space="preserve">
          <source>For each term present in the FTS table, there are between 2 and N+1 rows in the fts4aux table, where N is the number of user-defined columns in the associated FTS table. An fts4aux table always has the same four columns, as follows, from left to right:</source>
          <target state="translated">FTS 테이블에있는 각 용어에 대해 fts4aux 테이블에 2와 N + 1 개의 행이 있습니다. 여기서 N은 연관된 FTS 테이블의 사용자 정의 열 수입니다. fts4aux 테이블에는 왼쪽에서 오른쪽으로 항상 다음과 같은 네 개의 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdf0037f493d99e63f11ef023d4ede2161885e4" translate="yes" xml:space="preserve">
          <source>For each token in the input string, the supplied callback xToken() must be invoked. The first argument to it should be a copy of the pointer passed as the second argument to xTokenize(). The third and fourth arguments are a pointer to a buffer containing the token text, and the size of the token in bytes. The 4th and 5th arguments are the byte offsets of the first byte of and first byte immediately following the text from which the token is derived within the input.</source>
          <target state="translated">입력 문자열의 각 토큰에 대해 제공된 콜백 xToken ()을 호출해야합니다. 첫 번째 인수는 xTokenize ()에 두 번째 인수로 전달 된 포인터의 사본이어야합니다. 세 번째와 네 번째 인수는 토큰 텍스트와 토큰 크기 (바이트)를 포함하는 버퍼에 대한 포인터입니다. 4 번째와 5 번째 인수는 입력에서 토큰이 파생 된 텍스트 바로 다음의 첫 번째 바이트와 첫 번째 바이트의 바이트 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="77d69c67e1a2a185641c2031933b357307710ee5" translate="yes" xml:space="preserve">
          <source>For each token in the text fragment that is part of a phrase match, the &quot;start match&quot; text is inserted into the fragment before the token, and the &quot;end match&quot; text is inserted immediately after it.</source>
          <target state="translated">문구 일치의 일부인 텍스트 조각의 각 토큰에 대해 &quot;시작 일치&quot;텍스트가 토큰 앞에 조각에 삽입되고 &quot;끝 일치&quot;텍스트가 바로 뒤에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="4c5274d9826ac0360165a29a3e66a8506f1ab799" translate="yes" xml:space="preserve">
          <source>For every successful call to this method, the SQLite core will later invoke the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method to destroy the allocated cursor.</source>
          <target state="translated">이 메소드를 성공적으로 호출 할 때마다 SQLite 코어는 나중에 &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; 메소드를 호출 하여 할당 된 커서를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c6c48664cbefae23df70df3591300d92263e5f4c" translate="yes" xml:space="preserve">
          <source>For example to find the highest paid employee:</source>
          <target state="translated">예를 들어 가장 높은 급여를받는 직원을 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2479f1e642da058be56d1001ffac81d069a0ba6c" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement cannot be run while another thread is reading from that table on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; because dropping the table would delete the table out from under the concurrent reader.</source>
          <target state="translated">예를 들어, 테이블을 삭제하면 동시 판독기 아래에서 테이블이 삭제되므로 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 가 동일한 데이터베이스 연결 의 해당 테이블에서 다른 스레드를 읽는 동안 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 실행할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6761f7f398c5e173f6115ef00ea11329cb9f3d54" translate="yes" xml:space="preserve">
          <source>For example, a query like the following might be used to find all R*Tree entries that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:</source>
          <target state="translated">예를 들어, 다음과 같은 쿼리를 사용하여 반경이 5.0 인 45.3,22.9를 중심으로하는 원과 겹치는 모든 R * Tree 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fbeb339bf81a5c29e36447b781a19ea1d40440" translate="yes" xml:space="preserve">
          <source>For example, adding an &quot;ON UPDATE CASCADE&quot; clause to the foreign key as shown below enhances the example schema from section 1 to allow the user to update the artistid (the parent key of the foreign key constraint) column without breaking referential integrity:</source>
          <target state="translated">예를 들어, 아래 표시된 것처럼 외래 키에 &quot;ON UPDATE CASCADE&quot;절을 추가하면 섹션 1의 예제 스키마가 향상되어 참조 무결성을 손상시키지 않고 아티스트 ID (외래 키 제약 조건의 부모 키) 열을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a7b041107b28bf1e4e9feea5241e1ae83cb4f3" translate="yes" xml:space="preserve">
          <source>For example, as currently implemented, if writes are happening at a steady stream that exceeds the I/O capability of the background writer thread, the queue of pending write operations will grow without bound. If this goes on for long enough, the host system could run out of memory. A more sophisticated module could to keep track of the quantity of pending writes and stop accepting new write requests when the queue of pending writes grows too large.</source>
          <target state="translated">예를 들어, 현재 구현 된대로 백그라운드 기록기 스레드의 I / O 기능을 초과하는 꾸준한 스트림에서 쓰기가 발생하면 보류중인 쓰기 작업 대기열이 제한없이 커집니다. 이것이 오랫동안 지속되면 호스트 시스템의 메모리가 부족할 수 있습니다. 보다 정교한 모듈은 보류중인 쓰기 수를 추적하고 보류중인 쓰기 큐가 너무 커지면 새 쓰기 요청 수락을 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74530ffba7f866870009106e3c8e5c0a0af944ca" translate="yes" xml:space="preserve">
          <source>For example, given the database schema:</source>
          <target state="translated">예를 들어 데이터베이스 스키마가 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7f52cca71f3aa80082462a01861b0a720f46594" translate="yes" xml:space="preserve">
          <source>For example, if a prepared statement is created using the SQL text &quot;SELECT $abc,:xyz&quot; and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql() will return the original string, &quot;SELECT $abc,:xyz&quot; but sqlite3_expanded_sql() will return &quot;SELECT 2345,NULL&quot;.</source>
          <target state="translated">예를 들어, SQL 문 &quot;SELECT $ abc, : xyz&quot;를 사용하여 준비된 명령문을 작성하고 $ abc 매개 변수가 정수 2345에 바인딩되고 매개 변수 : xyz가 바인딩되지 않은 경우 sqlite3_sql ()은 원래 문자열 &quot;SELECT를 리턴합니다. $ abc, : xyz &quot;이지만 sqlite3_expanded_sql ()은&quot;SELECT 2345, NULL &quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06bed93067ff2c82141c677c5fde8b31f46e4d93" translate="yes" xml:space="preserve">
          <source>For example, if both the local and remote changesets contain an INSERT of the same key on &quot;CREATE TABLE t1(a PRIMARY KEY, b)&quot;:</source>
          <target state="translated">예를 들어, 로컬 및 원격 변경 세트 모두 &quot;CREATE TABLE t1 (a PRIMARY KEY, b)&quot;에서 동일한 키의 INSERT를 포함하는 경우 :</target>
        </trans-unit>
        <trans-unit id="336ff6fc840939163a24ab8fbcfd1876f5d7462b" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">예를 들어 &quot; &lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt; &quot;의 각 517430 문서 가 FTS 테이블과 다음 SQL 스크립트를 사용하여 생성 된 일반 SQLite 테이블에 모두 삽입 된 경우 :</target>
        </trans-unit>
        <trans-unit id="9af2b0a0be2507f901ab349b61afc42441edaa60" translate="yes" xml:space="preserve">
          <source>For example, if nCol is the number of columns in the table, to determine if phrase p is present in column c:</source>
          <target state="translated">예를 들어, nCol이 테이블의 열 수인 경우 구 p에 구 p가 있는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4ff402b57bb3c7de072fb37615e2f1f44b822435" translate="yes" xml:space="preserve">
          <source>For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt; are available to process B to help it deal with SQLITE_BUSY errors.</source>
          <target state="translated">예를 들어, 프로세스 A가 대규모 쓰기 트랜잭션의 중간에 있고 프로세스 B가 새 쓰기 트랜잭션을 시작하려고 시도하는 경우 SQLite는 한 번에 하나의 작성자 만 지원하므로 프로세스 B는 SQLITE_BUSY 결과를 다시 가져옵니다. 프로세스 B는 새 트랜잭션을 시작하기 전에 프로세스 A가 트랜잭션을 완료 할 때까지 기다려야합니다. &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma는&lt;/a&gt; 이 SQLITE_BUSY 오류를 처리하는 데 도움 프로세스 B를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d347b5f74f99e1b9952eb3244ae0159feff20d3e" translate="yes" xml:space="preserve">
          <source>For example, if the</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="c3622449954a6635d6d6221d72610b7472bd6c7b" translate="yes" xml:space="preserve">
          <source>For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3] constraint.</source>
          <target state="translated">예를 들어, aConstraint [3] .argvIndex가 1로 설정된 경우 xFilter가 호출되면 xFilter에 전달 된 argv [0]은 aConstraint [3] 제약 조건의 EXPR 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7f637c26bc4431eea662487596dfe6901f17e071" translate="yes" xml:space="preserve">
          <source>For example, if the following SQL is passed to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 다음 SQL이 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()에&lt;/a&gt; 전달 된 경우 :</target>
        </trans-unit>
        <trans-unit id="9d9a182c3de2bb26679903dabe753f3a90f09588" translate="yes" xml:space="preserve">
          <source>For example, if you have a table column declared to be of type &quot;INTEGER&quot; and you try to insert a string, the column will look at the text string and see if it looks like a number. If the string does look like a number it is converted into a number and into an integer if the number does not have a fractional part, and stored that way. But if the string is not a well-formed number it is still stored as a string. A column with a type of &quot;TEXT&quot; tries to convert numbers into an ASCII-Text representation before storing them. But BLOBs are stored in TEXT columns as BLOBs because you cannot in general convert a BLOB into text.</source>
          <target state="translated">예를 들어 &quot;INTEGER&quot;유형으로 선언 된 테이블 열이 있고 문자열을 삽입하려고하면 열이 텍스트 문자열을보고 숫자처럼 보이는지 확인합니다. 문자열이 숫자처럼 보이면 숫자에 소수 부분이 없으면 숫자와 정수로 변환되어 저장됩니다. 그러나 문자열이 올바른 형식이 아닌 경우 여전히 문자열로 저장됩니다. &quot;TEXT&quot;유형의 열은 저장하기 전에 숫자를 ASCII 텍스트 표현으로 변환하려고합니다. 그러나 BLOB는 일반적으로 BLOB를 텍스트로 변환 할 수 없기 때문에 TEXT 열에 BLOB으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8d78d9a4a4ef5a078d77893775dee024ca144a" translate="yes" xml:space="preserve">
          <source>For example, in gdb, to see the complete hierarchy of an Expr node (that is to say, the Expr node and all of its children), given a pointer &quot;pExpr&quot; to that node, type:</source>
          <target state="translated">예를 들어 gdb에서 해당 노드에 대한 &quot;pExpr&quot;포인터가 주어지면 Expr 노드 (즉, Expr 노드 및 모든 하위)의 전체 계층을 보려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="65de8cd85e7f9352044ea42fa34fc26263f7d653" translate="yes" xml:space="preserve">
          <source>For example, in the following call to json_object(), the</source>
          <target state="translated">예를 들어, json_object ()에 대한 다음 호출에서</target>
        </trans-unit>
        <trans-unit id="376c3a63c2d900eda2a882017f3f3a33aef34667" translate="yes" xml:space="preserve">
          <source>For example, information about the columns in an index can be read using the &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; as follows:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; 를 사용하여 인덱스의 열에 대한 정보를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bccea8458a0de711e349540a29ecfcb98a65f40" translate="yes" xml:space="preserve">
          <source>For example, let the index be</source>
          <target state="translated">예를 들어, 색인이</target>
        </trans-unit>
        <trans-unit id="3da423bea60d2f28b9bd6c6b606ccc9294140d5b" translate="yes" xml:space="preserve">
          <source>For example, many words of Greek origin begin with letters &quot;ps&quot; where the &quot;p&quot; is silent. Ex: psalm, pseudonym, psoriasis, psyche. In another example, many Scottish surnames can be spelled with an initial &quot;Mac&quot; or &quot;Mc&quot;. Thus, &quot;MacKay&quot; and &quot;McKay&quot; are both pronounced the same.</source>
          <target state="translated">예를 들어, 그리스어 원어의 많은 단어는 &quot;p&quot;가 침묵 인 &quot;ps&quot;문자로 시작합니다. 예 : 시편, 가명, 건선, 정신. 다른 예에서, 많은 스코틀랜드 성은 초기 &quot;Mac&quot;또는 &quot;Mc&quot;로 철자를 지정할 수 있습니다. 따라서 &quot;MacKay&quot;와 &quot;McKay&quot;는 모두 동일하게 발음됩니다.</target>
        </trans-unit>
        <trans-unit id="20083fcfe31a171e687fd7f98763b1bd15a6a1ec" translate="yes" xml:space="preserve">
          <source>For example, say the SQL statement returns the following data when executed:</source>
          <target state="translated">예를 들어, SQL 문이 실행될 때 다음 데이터를 리턴한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbaaa7d12d4edb21ff19c0963b0289115f32a55" translate="yes" xml:space="preserve">
          <source>For example, suppose an additional database is attached to the database connection using a statement like this:</source>
          <target state="translated">예를 들어, 다음과 같은 명령문을 사용하여 추가 데이터베이스가 데이터베이스 연결에 접속되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="81c47bbba7e6d3bcfa83f9d58601629924b27df8" translate="yes" xml:space="preserve">
          <source>For example, suppose the input word is &quot;Paskagula&quot;. The phonetic key is &quot;BACACALA&quot; which is then truncated to 4 characters &quot;BACA&quot;. The edit distance is then run on the 4980 entries (out of 272,597 entries total) of the vocabulary whose k2 values begin with BACA, yielding &quot;Pascagoula&quot; as the best match.</source>
          <target state="translated">예를 들어, 입력 단어가 &quot;Paskagula&quot;라고 가정하십시오. 발음 키는 &quot;BACACALA&quot;이며 4 자로 &quot;BACA&quot;로 잘립니다. 그런 다음 편집 거리는 k2 값이 BACA로 시작하는 어휘의 4980 개 항목 (총 272,597 개 항목)에서 실행되어 &quot;Pascagoula&quot;가 가장 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bd462d6a706c77e5432cc4b960d8cc42361a6e96" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular &quot;team&quot;. Each team has a &quot;leader&quot; who is also a member of that team. The table might look something like this:</source>
          <target state="translated">예를 들어, 각 개인이 특정 &quot;팀&quot;에 할당 된 대규모 조직 구성원의 데이터베이스가 있다고 가정하십시오. 각 팀에는 해당 팀의 구성원 인 &quot;리더&quot;가 있습니다. 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d2ab8533e293c8a84090c9b6694f2a969c007bb" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this could be done:</source>
          <target state="translated">예를 들어, 열 이름이 &quot;a&quot;, &quot;b&quot;및 &quot;c&quot;인 &quot;t1&quot;이라는 테이블이 있고이 테이블에서 &quot;c&quot;열을 삭제하려고한다고 가정하십시오. 다음 단계는이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e8c74e845df3aa4e4554ece864cf2478aa417801" translate="yes" xml:space="preserve">
          <source>For example, suppose you wanted undo/redo on a class (table) that looks like this:</source>
          <target state="translated">예를 들어 다음과 같은 클래스 (테이블)에서 실행 취소 / 다시 실행을 원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c888ac7552fad64c94327f4d9dde6c1939c79ffa" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">예를 들어, &quot;generate_series&quot;확장자 ( &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;소스 트리&lt;/a&gt; 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt; 파일에 있음 ) 는 다음 스키마를 사용하여 시상 &lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a41d4a0a2c571159c4d3d9a9bcfe397816127e93" translate="yes" xml:space="preserve">
          <source>For example, the first argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; function is supposed to be a special column of the FTS3 table that contains a pointer to an fts3cursor object that contains information about the current full text search match. That pointer was formerly passed as a BLOB. For example, if the FTS3 table is named &quot;t1&quot; and has a column named &quot;cx&quot;, one might write:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet ()&lt;/a&gt; 함수에 대한 첫 번째 인수 는 현재 전체 텍스트 검색 일치에 대한 정보를 포함하는 fts3cursor 오브젝트에 대한 포인터를 포함하는 FTS3 테이블의 특수 열이어야합니다. 그 포인터는 이전에 BLOB으로 전달되었습니다. 예를 들어, FTS3 테이블의 이름이 &quot;t1&quot;이고 이름이 &quot;cx&quot;인 열이 있으면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1719c0fad0c46d95494599fc76472814afb3096" translate="yes" xml:space="preserve">
          <source>For example, the following EXPLAIN QUERY PLAN command operates on a SELECT statement that is implemented by performing a full-table scan on table t1:</source>
          <target state="translated">예를 들어, 다음 EXPLAIN QUERY PLAN 명령은 테이블 t1에서 전체 테이블 스캔을 수행하여 구현 된 SELECT 문에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f54bfe9858a294d74efc1029b390f83e76127bc5" translate="yes" xml:space="preserve">
          <source>For example, the following JSON describes an isosceles triangle, sitting on the X axis and with an area of 0.5:</source>
          <target state="translated">예를 들어 다음 JSON은 X 축에 0.5의 면적을 갖는 이등변 삼각형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="83a6fbeea816f56be60daf62a9ac68c383f63398" translate="yes" xml:space="preserve">
          <source>For example, the following code implements a collating sequence called &quot;NOCASE&quot; that sorts in text order without regard to case:</source>
          <target state="translated">예를 들어 다음 코드는 대소 문자와 상관없이 텍스트 순서로 정렬되는 &quot;NOCASE&quot;라는 조합 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9c27a0d3845f1eceb95943662637d42bbbaddf2a" translate="yes" xml:space="preserve">
          <source>For example, the following statement is valid in SQLite:</source>
          <target state="translated">예를 들어, 다음 명령문은 SQLite에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c949165d26ebc110da68da66e13bc86685e04c18" translate="yes" xml:space="preserve">
          <source>For example, the values NULL, 0.0, 0, 'english' and '0' are all considered to be false. Values 1, 1.0, 0.1, -0.1 and '1english' are considered to be true.</source>
          <target state="translated">예를 들어, NULL, 0.0, 0, 'english'및 '0'값은 모두 false로 간주됩니다. 1, 1.0, 0.1, -0.1 및 '1english'값은 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a80abcae23d48d4d5c71b5964b931b771a14df0d" translate="yes" xml:space="preserve">
          <source>For example, this row:</source>
          <target state="translated">예를 들어이 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0774215613f5a93e554bf719be214f376054f20" translate="yes" xml:space="preserve">
          <source>For example, to avoid adding the contents of the &quot;uuid&quot; field to the FTS index:</source>
          <target state="translated">예를 들어, &quot;uuid&quot;필드의 내용을 FTS 색인에 추가하지 않으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e25e9fcbc6cbbe4aa86a860fba9ee3e23406906c" translate="yes" xml:space="preserve">
          <source>For example, to create a new SQLite database named &quot;ex1&quot; with a single table named &quot;tbl1&quot;, you might do this:</source>
          <target state="translated">예를 들어, &quot;tbl1&quot;이라는 단일 테이블을 사용하여 &quot;ex1&quot;이라는 새 SQLite 데이터베이스를 만들려면 다음과 같이하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
