<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="bf2789a3dfac2aec0ce73567ef591f88c395a4a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SESSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8abf674d55e555f734817a21ddcd5e21c3015707" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SNAPSHOT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fbcbad5bbf055acd0b8cb0f65883a99e15403389" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="050fd9347aba0613e41edd6d9163428b913cee4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_SQLLOG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0204d4bbf2c54d3a1ed06e32f0d2fbfba810aaf2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc060831fa345f0a6eab149e614a038d39d92be3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT3&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aadb411eed6a3e5c2d4eea8759254437ad95f39e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STAT4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="faf2c9cc0d944bfbdb7cc148d522d3051abfdcf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMTVTAB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95df966b12c5979c6c37cfbb73acce4de4031b52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8c43e0af9e63a24260b1237ffafa9382ffcb8eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="10ad0ef0211ad8e21498cf3f4662f8bcc6ba15cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd992a7384df4b2049382d0b4180b642a115bd15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e01ddc96bb53d6b852d1690bde30ccdb2f85dafe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cedadab65ac150d458ca8e13ba1611fb33b07ce8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_EXTRA_DURABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="253b5d9f8f32fa07fef6dbd123f4ce91b701c1d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_FTS3_MAX_EXPR_DEPTH=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6a286554137726a245c1b95b8192b6c3bbd3251" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ISNAN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9db0cb11222acab74db65c807eff63f7f55c2ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_HAVE_ZLIB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05591c0534904e32ca8cdac4b25cbb9d60a573b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9c352c0861967ddc2df753cc4bbcd4bcba3f2f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5ceb830bc9fd789f4fa5f7fcc0cabfaf48496306" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_EXCLUSIVE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b03ae772584c2d2a9e11d0dc7338890a0357eb9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_LOCK_SHARED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99e4b045bc420fa97a94b4105d7f761fb24049c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MEMORY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9c354011c14318ca6d262f2573fba28199396470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_MMAP_SIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a401e4995f5551e362e32c54e2ba19071ea64e48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_SCHEMA_RETRY=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acb2a8063accd6b8beb78cacc0a648a21d40a870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MAX_WORKER_THREADS=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b462c3d40d420240b9032bbae35bd514d016567b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99a1ffd86d48620ac9d92bbfacc8dd600f0161cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MEMDEBUG&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a4e92305244c1ce6fd0f4cd7269789b8529f373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3334e6a6da5c866bd89fe950d2c9b62e97f7ceb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ALTERTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9ecdc843e92293dcb6abf6daf54b6c3b4881468" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ANALYZE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bfe038e385667f427bfaba3d91a9af26eba94450" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_ATTACH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d6d0848efb00b356cb9465d9f109e2147210b9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTHORIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7fdef8c2a9c01031f943ed79f514a8156d673500" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINCREMENT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d8960215ae00abd7ebb1925d984e4b874f7c871" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOINIT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aaf355948028ec514c8e85609b52d8ff903f1574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a1d498df4dd274ff01a03900ec4b34dda79009c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTORESET&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c6a54eaef40777e126f4002faabd672a7e9f7e91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_AUTOVACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc2f291f887ee161ef88691303623ca2effb8629" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BETWEEN_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31a30cf46373dc5197f8e3344abb93ca02b039ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BLOB_LITERAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7e8d3c023e1a4ccad20b87139d88b7081b6817b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BTREECOUNT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cff423655eb39b2c748dff51e94300e8f28ba4e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b62e20033dec22257f890ac30be31c4cd927192f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a4c5907c936567c2b7b9fa6bc346c059d43fc957" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CAST&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5633de952d476b5d96fee010583ad94474595fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6fc3ef0b372de46a78bc829d1b0ac42417cbe60e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42dd6fec81e49f75f5ff85d610101a339b93346" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPLETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="52d61fa2500d572bc3c2f61bc09133f36d87d7a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_COMPOUND_SELECT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffebea17346fc66899b100e42dde64847ae162ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_CTE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02a8ebfb8c51bfa8f5f04b211a7d7ff033ad0d12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00568160f62e1e2f3c85a4ec68228a6d706532ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DECLTYPE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d35796e3c6ab5d85720734a37998a6ce92535777" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DEPRECATED&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03eb1718823b671bd128fc3257e8b9065c569dd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_DISKIO&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b059b5b58e6147c9da00dc4a5c50c89efee3912a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_EXPLAIN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389e2542bf1d776bda49aa816f7acb08834bd6cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLAG_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="707057fed5f688f9208bf46ef4426a605d5f09df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FLOATING_POINT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bc82fd2191660ac807469076e0f7a404c356a0be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdf469011a3b01a769905c13c811e2aa6924e16e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GENERATED_COLUMNS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0905065083397f185f42d644502785ba7c6069f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_GET_TABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0da634636aa21dd63f86722f0b3d34ffade49316" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_HEX_INTEGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3e27ca5135fcc6a84108dc0ffc11de226b7192e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INCRBLOB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2d75578c65599befa260ca475b0a32c3620f002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTEGRITY_CHECK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14ef2bd88a85199b30182a69235817a3b5204f1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="77f3d1be3901c085b4a5db58cfdd2f9aaa6ceeca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LIKE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="136a7594d2f3c6161370dbd3a5755699a0f58d29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3dc23714e6733b26ba59900b7bd7b338d8e9f8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOCALTIME&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5afb0b5eb77dd513826c4b386ca2f26d1f287909" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_LOOKASIDE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bf04e411ffa329ca1466479098e23ff67d50730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_MEMORYDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c059cfc62627b1886e1ca9f2629fb0b673e1d368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_OR_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ed3f9bfbb996093381267996d7d33c4f934eb7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PAGER_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d0281a47c9f5f4c349fb5ba928eb8bf37efa960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="be2660af6ab813539e2a8692aa5c050fd19d360c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_PROGRESS_CALLBACK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="668be95a6a3f50c7a5a63db473a408745e328f6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_QUICKBALANCE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f4eaaca938ecabc5c4dc11eaf9e065917dc70e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_REINDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="78dab73ee3da96b8c7ec1553d7f97a1d26d45cc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e59c47d4c6184784743e4358c78e436ed302c8d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f0e56325b2afaf6793e05912f440ee78e1e06f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SHARED_CACHE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b5feca8b64e60e028e2dbdb4dce97b1428f8b10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_SUBQUERY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="273973ea2fa452aa7255dd76283f67114dc7bc9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TCL_VARIABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b844869cbb137b3f5aae65d9fc2124a7f75df280" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TEMPDB&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14def5836843dc064ff211faf4a1e5d1c19a5fc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8c7a3f7709d5ca48aa62de5b3a866714d6593cfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRIGGER&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bff9bf2bc1a52aebb220f94954f92e1545ac1446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abef01fc3e06b07aafa25fb3d9e477bfd22cef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_UTF16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6336b6b7d8d57c2d7a777490e28348a06393d36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VACUUM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="059e2862fefd88c744b1377dc92f308d73cc50bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIEW&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebb08208b1feeb2e4092b776ed5ddb8063c890ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6542f591162b1fac32afa54f47fc6731f33601c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WAL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="04514e40f182ad456b5245a466634fbd7e92daf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_WSD&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3932897bd040e95c1eb9739b7659d68beda3ea49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OMIT_XFER_OPT&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2fad4f7fe54b95701a39ee8feb95777319a60e90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_OS_OTHER=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_OS_OTHER = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56ee3d0e684b44b8675f52b13d0096d23504a7af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_POWERSAFE_OVERWRITE = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="80c6ed8dbd133860dd6d357b4dc8c60c2b09f69b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_PRINTF_PRECISION_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6463226645ffe362c178bbe7f828d660c275a442" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6885cb8516f8377a9c28e855cb70b63504e6e435" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3a0235475a7827d68e0c1bb73ea4b44f4d323a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cec139681f0df7f780a39dbfc2f329845e7c650b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_RTREE_INT_ONLY&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d94d24b874c2c537a6ea7780b2a6592350047905" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SECURE_DELETE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7713ed7ab2f2f1c55f8fdb3ab145f3b1b932345b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SORTER_PMASZ=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc3bed687fc846b37c550cd3cddfd9155cb90685" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SOUNDEX&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d310d3f3bd739c56f040cc79192496e87ececfd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_STMTJRNL_SPILL=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b8a23171b43aabf136109acb20d220b99d3e9da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_SYSCALL&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0aba06a9fc72c1f03ecfc53abd7d244a52e61ce7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TCLAPI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="857f1d4b039067e7938f0fbe3cd9dacc12a3cc3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TEMP_STORE=&lt;i&gt;&amp;lt;0 through 3&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TEMP_STORE = &lt;i&gt;&amp;lt;&lt;/i&gt; 0-3 &lt;i&gt;&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="763974a69da7c357391024b037f2ff65866c1c72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_THREADSAFE=&lt;i&gt;&amp;lt;0 or 1 or 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_THREADSAFE = &lt;i&gt;&amp;lt;0 또는 1 또는 2&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db798c4c2b06b4515c31c3444478572466898eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRACE_SIZE_LIMIT=&lt;i&gt;N&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a864ab43b658af57ffcc85d7075d94f4c0eb4a1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_TRUSTED_SCHEMA=&lt;i&gt;&amp;lt;0 or 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_TRUSTED_SCHEMA = &lt;i&gt;&amp;lt;0 또는 1&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="88ec24333763838d2b35e7775950f2196c7691af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_UNTESTABLE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08dfc4ddda00225d961592ced42dcb85aa2a6b68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_ALLOCA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b2c678e1824f51e764911d1d97afa9303106537c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_FCNTL_TRACE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f442370983bde912aeaa8688fb8696ae2e052aae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_USE_URI&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa939f2dbd402ef231f0ab3788a92497d3d84650" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_HEAP_CREATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1343ce5771a0eb9359ec0df9e37c4cc2874c8ebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="382b47f1f3b8cd49c3216efbc6c7a391dd57252d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55cb4273e62d90804c53d091b40902649ec6153d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SQLITE_ZERO_MALLOC&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de509a166760f395e8d9ff623bc5c20f291203f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하여 확장로드를 사용 안함으로 설정하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 사용 불가능하게 유지됩니다. 이렇게하면 SQL 삽입으로 공격자가 확장로드 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="77d070aba76c9c45f3f4dfb8cb2c0f7b57ceed06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be disabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하여 확장로드를 사용 안함으로 설정하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 사용 불가능하게 유지됩니다. 이렇게하면 SQL 삽입으로 공격자가 확장로드 기능에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d719a3c99ca55bb1bc6c2bd4c61f4ad80e27b087" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메서드를 사용하여 확장로드를 활성화하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 비활성화 된 상태로 유지됩니다. 이렇게하면 SQL 삽입이 공격자에게 확장로드 기능에 대한 액세스 권한을 부여하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="fed85e3d24d294923ff9a94eb30c8ccf98e23751" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that extension loading be enabled using the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method rather than this interface, so the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 대신 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메서드를 사용하여 확장로드를 활성화하는 것이 좋습니다 &lt;b&gt;.&lt;/b&gt; 따라서 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수는 비활성화 된 상태로 유지됩니다. 이렇게하면 SQL 삽입이 공격자에게 확장로드 기능에 대한 액세스 권한을 부여하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="c39a9a8ee0c9f06fa3f477352418d833d84efb0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 만 사용 하려면 &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하는 것이 좋습니다 . &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스 사용을 피해야합니다. 이렇게하면 SQL 함수 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()이&lt;/a&gt; 비활성화되고 SQL 주입으로 인해 공격자가 확장 기능에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="85bcf242d91006a6e47ad703972cc780357bae6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Security warning:&lt;/b&gt; It is recommended that the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; method be used to enable only this interface. The use of the &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface should be avoided. This will keep the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; disabled and prevent SQL injections from giving attackers access to extension loading capabilities.</source>
          <target state="translated">&lt;b&gt;보안 경고 :&lt;/b&gt; 이 인터페이스 만 사용 하려면 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; 메소드를 사용하는 것이 좋습니다 . &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스 사용을 피해야합니다. 이렇게하면 SQL 함수 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()이&lt;/a&gt; 비활성화되고 SQL 주입으로 인해 공격자가 확장 기능에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="cef37acd0e58d7484bc210c3874856e993d57c42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Self-documentation.&lt;/b&gt; Self-documenting digital objects contain basic descriptive, technical, and other administrative metadata.</source>
          <target state="translated">&lt;b&gt;자기 문서화. &lt;/b&gt;자체 문서화 디지털 개체에는 기본 설명, 기술 및 기타 관리 메타 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="67039928069e29c2b8fc9b97ed6661597211b7d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serialized&lt;/b&gt;. In serialized mode, SQLite can be safely used by multiple threads with no restriction.</source>
          <target state="translated">&lt;b&gt;직렬화&lt;/b&gt; . 직렬화 모드에서 SQLite는 제한없이 여러 스레드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6c18085190b76c91a8135185e5040fe095bb489" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Server-side database&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;서버 측 데이터베이스&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a71e55c9e2165337c5f26b98320364c9a71fa32b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Serverless&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Serverless&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d28078da99c520e2ece9e2e044a1e465058479f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Bare columns in an aggregate queries.&lt;/b&gt; The usual case is that all column names in an aggregate query are either arguments to &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; or else appear in the GROUP BY clause. A result column which contains a column name that is not within an aggregate function and that does not appear in the GROUP BY clause (if one exists) is called a &quot;bare&quot; column. Example:</source>
          <target state="translated">&lt;b&gt;참고 사항 : 집계 쿼리에서 맨손 열입니다.&lt;/b&gt; 일반적으로 집계 쿼리의 모든 열 이름은 &lt;a href=&quot;lang_aggfunc&quot;&gt;함수&lt;/a&gt; 를 집계 하는 인수 이거나 GROUP BY 절에 나타납니다. 집계 함수 내에 있지 않고 GROUP BY 절 (없는 경우)에 나타나지 않는 열 이름을 포함하는 결과 열을 &quot;베어&quot;열이라고합니다. 예:</target>
        </trans-unit>
        <trans-unit id="9a2bd3e845310e3146f075b7477b9a77fd861938" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Side note: Special handling of CROSS JOIN.&lt;/b&gt; There is no difference between the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; join operators. They are completely interchangeable in SQLite. The &quot;CROSS JOIN&quot; join operator produces the same result as the &quot;INNER JOIN&quot;, &quot;JOIN&quot; and &quot;,&quot; operators, but is &lt;a href=&quot;optoverview#crossjoin&quot;&gt;handled differently by the query optimizer&lt;/a&gt; in that it prevents the query optimizer from reordering the tables in the join. An application programmer can use the CROSS JOIN operator to directly influence the algorithm that is chosen to implement the SELECT statement. Avoid using CROSS JOIN except in specific situations where manual control of the query optimizer is desired. Avoid using CROSS JOIN early in the development of an application as doing so is a &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;premature optimization&lt;/a&gt;. The special handling of CROSS JOIN is an SQLite-specific feature and is not a part of standard SQL.</source>
          <target state="translated">&lt;b&gt;참고 : CROSS JOIN의 특수 처리.&lt;/b&gt; &quot;INNER JOIN&quot;, &quot;JOIN&quot;및 &quot;,&quot;조인 연산자에는 차이가 없습니다. 그것들은 SQLite에서 완전히 호환됩니다. &quot;CROSS JOIN&quot;조인 연산자는 &quot;INNER JOIN&quot;, &quot;JOIN&quot;및 &quot;,&quot;연산자와 동일한 결과를 생성하지만 쿼리 옵티마이 저가 조인의 테이블을 재정렬하지 못하도록 &lt;a href=&quot;optoverview#crossjoin&quot;&gt;쿼리 옵티 마이저&lt;/a&gt; 에서 다르게 처리됩니다 . 응용 프로그램 프로그래머는 CROSS JOIN 연산자를 사용하여 SELECT 문을 구현하기 위해 선택한 알고리즘에 직접 영향을 줄 수 있습니다. 쿼리 최적화 프로그램의 수동 제어가 필요한 특정 상황을 제외하고 CROSS JOIN을 사용하지 마십시오.&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;조기 최적화 는 애플리케이션 개발 초기에 CROSS JOIN을 사용하지 마십시오.&lt;/a&gt;. CROSS JOIN의 특수 처리는 SQLite 관련 기능이며 표준 SQL의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ded659eb85771f35ee1281ea75f0b58206ff5892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Simplified Application Development.&lt;/b&gt; No new code is needed for reading or writing the application file. One has merely to link against the SQLite library, or include the &lt;a href=&quot;amalgamation&quot;&gt;single &quot;sqlite3.c&quot; source file&lt;/a&gt; with the rest of the application C code, and SQLite will take care of all of the application file I/O. This can reduce application code size by many thousands of lines, with corresponding saving in development and maintenance costs.</source>
          <target state="translated">&lt;b&gt;단순화 된 응용 프로그램 개발. &lt;/b&gt;응용 프로그램 파일을 읽거나 쓰는 데 새로운 코드가 필요하지 않습니다. 하나는 단지 SQLite 라이브러리에 연결하거나 &lt;a href=&quot;amalgamation&quot;&gt;단일 &quot;sqlite3.c&quot;소스 파일&lt;/a&gt; 을 나머지 응용 프로그램 C 코드와 함께 포함하면 SQLite는 모든 응용 프로그램 파일 I / O를 처리합니다. 따라서 개발 및 유지 관리 비용을 절약하면서 애플리케이션 코드 크기를 수천 줄 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1a07cced5f47f7259b19ba37568ce82cb769c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;단일 데이터베이스 파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3366f819b02e356be2c09f8db154e11cec6006c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-File Documents.&lt;/b&gt; An SQLite database is contained in a single file, which is easily copied or moved or attached. The &quot;document&quot; metaphor is preserved.</source>
          <target state="translated">&lt;b&gt;단일 파일 문서. &lt;/b&gt;SQLite 데이터베이스는 단일 파일에 포함되어 있으며 쉽게 복사하거나 이동하거나 첨부 할 수 있습니다. &quot;문서&quot;은유는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="68d21fce42cee774794d3e89752dc4c799a36e13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Single-thread&lt;/b&gt;. In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.</source>
          <target state="translated">&lt;b&gt;단일 스레드&lt;/b&gt; . 이 모드에서는 모든 뮤텍스가 비활성화되고 SQLite는 한 번에 하나 이상의 스레드에서 사용하기에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b814fcbadf45ac4a5e2cf73ad790b7ea7575388b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stable Cross-Platform Database File&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;안정적인 크로스 플랫폼 데이터베이스 파일&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4b6d0729d61e68af9be12dd919ff6d4508e9058a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in For An Enterprise RDBMS.&lt;/b&gt; SQLite is often used as a surrogate for an enterprise RDBMS for demonstration purposes or for testing. SQLite is fast and requires no setup, which takes a lot of the hassle out of testing and which makes demos perky and easy to launch.</source>
          <target state="translated">&lt;b&gt;Enterprise RDBMS를위한 스탠드 인. &lt;/b&gt;SQLite는 종종 데모 목적 또는 테스트를 위해 엔터프라이즈 RDBMS의 대리자로 사용됩니다. SQLite는 빠르며 설정이 필요하지 않으므로 테스트 과정에서 많은 번거 로움이 발생하여 데모가 거칠고 시작하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="49211ca87490fc949777a3fa6df7da5023e3e641" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Stand-in for an enterprise database during demos or testing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;데모 또는 테스트 중 엔터프라이즈 데이터베이스를위한 스탠드 인&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e613e33621af0e53400119bdd08e80a1c293ae5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Startup is slow.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;시작이 느립니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b6f8a8cb97bdf26af3f7bcb45031e40198e438d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Summary:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Summary:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b838b6a7626f1106767937cfe090ef328a06b3c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;T&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;T&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cc92e1072d6f0803cf0720093c61b6114a74aff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt; as ISO8601 strings (&quot;YYYY-MM-DD HH:MM:SS.SSS&quot;).</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;ISO8601 문자열 인 &lt;b&gt;텍스트&lt;/b&gt; ( &quot;YYYY-MM-DD HH : MM : SS.SSS&quot;).</target>
        </trans-unit>
        <trans-unit id="51b499bb47a4b816c200573bc1654699b3396326" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;TEXT&lt;/b&gt;. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).</source>
          <target state="translated">&lt;b&gt;TEXT&lt;/b&gt; . 값은 데이터베이스 인코딩 (UTF-8, UTF-16BE 또는 UTF-16LE)을 사용하여 저장된 텍스트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1175f4dc14e4a992c9182cfb85c0229a4412adea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Table name&lt;/b&gt;. The name of the component table within its database.</source>
          <target state="translated">&lt;b&gt;표 이름&lt;/b&gt; . 데이터베이스 내 구성 요소 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cce6f2ddbb90e75814b5925f282a337f2a6222d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Technical Protection Mechanisms.&lt;/b&gt; Implementation of mechanisms such as encryption that prevent the preservation of content by a trusted repository.</source>
          <target state="translated">&lt;b&gt;기술 보호 메커니즘. &lt;/b&gt;신뢰할 수있는 리포지토리가 콘텐츠를 보존하지 못하게하는 암호화와 같은 메커니즘 구현</target>
        </trans-unit>
        <trans-unit id="8b8491e1f95ab90350e3e533b25fcfd87b3e25b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Test, Debug, and Analysis Changes:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;테스트, 디버그 및 분석 변경 사항 :&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e053a51d81e6a2c72b1bc41555611b2f50e7a8c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &quot;DROP TABLE&quot; Exception&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;DROP TABLE&quot;예외&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7ee9ee9b8b34c217caeb5704b148f23d252d528" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental blob I/O&lt;/a&gt; mechanism does not work for WITHOUT ROWID tables.&lt;/b&gt; Incremental BLOB I/O uses the rowid to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for doing the direct I/O. However, WITHOUT ROWID tables do not have a rowid, and so there is no way to create an &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object for a WITHOUT ROWID table.</source>
          <target state="translated">&lt;b&gt;WITHOUT ROWID 테이블 에는 &lt;a href=&quot;c3ref/blob_open&quot;&gt;증분 Blob I / O&lt;/a&gt; 메커니즘이 작동하지 않습니다. &lt;/b&gt;증분 BLOB I / O는 rowid를 사용 하여 직접 I / O를 수행하기위한 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 객체 를 만듭니다 . 그러나 WITHOUT ROWID 테이블에는 rowid가 없으므로 WITHOUT ROWID 테이블에 대한 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 오브젝트 를 작성할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9333e7627a2d8956128f8661c8ce6d0c01b3a38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function does not work for WITHOUT ROWID tables.&lt;/b&gt; Inserts into a WITHOUT ROWID do not change the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. The &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; SQL function is also unaffected since it is just a wrapper around &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수는 ROWID 테이블없이 작동하지 않습니다. &lt;/b&gt;WITHOUT ROWID에 삽입해도 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수가 리턴 한 값은 변경되지 않습니다 . &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;LAST_INSERT_ROWID ()&lt;/a&gt; 는 주변 단지 래퍼이기 때문에 SQL의 기능은 영향을받지 않습니다 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid은 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d83b61d9f4987dc0f941ad211863bc9aa49f3be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface does not fire callbacks for changes to a WITHOUT ROWID table.&lt;/b&gt; Part of the callback from &lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; is the rowid of the table row that has changed. However, WITHOUT ROWID tables do not have a rowid. Hence, the update hook is not invoked when a WITHOUT ROWID table changes.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스는 ROWID 테이블이없는 변경에 대한 콜백을 발생하지 않습니다. &lt;/b&gt;&lt;a href=&quot;c3ref/update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 의 콜백 중 일부 는 변경된 테이블 행의 rowid입니다. 그러나 WITHOUT ROWID 테이블에는 rowid가 없습니다. 따라서 WITHOUT ROWID 테이블이 변경 될 때 업데이트 후크가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d6305d6204c7fa058d43a6412f44de76568442f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The pthreads API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;pthreads API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2445d1d7779f00615aec27dcadb26e02eae2a0fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The special behaviors associated &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; do not apply on WITHOUT ROWID tables.&lt;/b&gt; In an ordinary table, &quot;INTEGER PRIMARY KEY&quot; means that the column is an alias for the rowid. But since there is no rowid in a WITHOUT ROWID table, that special meaning no longer applies. An &quot;INTEGER PRIMARY KEY&quot; column in a WITHOUT ROWID table works like an &quot;INT PRIMARY KEY&quot; column in an ordinary table: It is a PRIMARY KEY that has integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &quot; 와 관련된 특수 동작 은 WITHOUT ROWID 테이블에 적용되지 않습니다. &lt;/b&gt;일반 테이블에서 &quot;INTEGER PRIMARY KEY&quot;는 열이 rowid의 별명임을 의미합니다. 그러나 WITHOUT ROWID 테이블에는 rowid가 없으므로 해당 특수 의미는 더 이상 적용되지 않습니다. WITHOUT ROWID 테이블의 &quot;INTEGER PRIMARY KEY&quot;열은 일반 테이블의 &quot;INT PRIMARY KEY&quot;열처럼 작동합니다. 정수 &lt;a href=&quot;datatype3#affinity&quot;&gt;친화도&lt;/a&gt; 를 갖는 PRIMARY KEY입니다 .</target>
        </trans-unit>
        <trans-unit id="dca5135672aa5896d1934aec89434fccdee88668" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_config() interface is not threadsafe. The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config() is running.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_config () 인터페이스는 스레드 세이프가 아닙니다. 응용 프로그램은 sqlite3_config ()가 실행되는 동안 다른 스레드가 다른 SQLite 인터페이스를 호출하지 않도록해야합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c710e5ea2792e8eded22905b82d87b3dcd213e68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The sqlite3_unlock_notify() API&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_unlock_notify () API&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4617744409076bb539fa2b6bcbc61a76f81045ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This pragma is deprecated&lt;/b&gt; and exists for backwards compatibility only. New applications should avoid using this pragma. Older applications should discontinue use of this pragma at the earliest opportunity. This pragma may be omitted from the build when SQLite is compiled using &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;이 pragma는 더 이상 사용되지 않으며&lt;/b&gt; 이전 버전과의 호환성을 위해서만 존재합니다. 새로운 응용 프로그램은이 pragma를 사용하지 않아야합니다. 오래된 응용 프로그램은 가능한 빨리이 pragma의 사용을 중단해야합니다. 이 pragma는 SQLite가 &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED를&lt;/a&gt; 사용하여 컴파일 될 때 빌드에서 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58398df6716c7ad104ead532e8557ae487862fcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Token or token prefix queries&lt;/b&gt;. An FTS table may be queried for all documents that contain a specified term (the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple case&lt;/a&gt; described above), or for all documents that contain a term with a specified prefix. As we have seen, the query expression for a specific term is simply the term itself. The query expression used to search for a term prefix is the prefix itself with a '*' character appended to it. For example:</source>
          <target state="translated">&lt;b&gt;토큰 또는 토큰 접두사 쿼리&lt;/b&gt; . FTS 테이블은 지정된 용어가 포함 된 모든 문서 ( 위에서 설명한 &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;간단한 경우&lt;/a&gt; ) 또는 지정된 접두사가있는 용어가 포함 된 모든 문서에 대해 쿼리 할 수 ​​있습니다 . 우리가 보았 듯이, 특정 용어에 대한 쿼리 표현식은 단순히 용어 자체입니다. 용어 접두사를 검색하는 데 사용되는 쿼리 식은 접두사 자체에 '*'문자가 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35470c2e36b5d89ec0e5e0b5a16713ad8751938f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transition into and out of WAL-mode&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL 모드로 및 외부에서 전환&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e85cc4d69fe87371b922680953209fdf60a9693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Transparency.&lt;/b&gt; Degree to which the digital representation is open to direct analysis with basic tools, such as human readability using a text-only editor.</source>
          <target state="translated">&lt;b&gt;투명도. &lt;/b&gt;텍스트 전용 편집기를 사용한 사람의 가독성과 같은 기본 도구를 사용하여 직접 분석하기 위해 디지털 표현을 여는 정도.</target>
        </trans-unit>
        <trans-unit id="6a1fef7ef2345014e787011b548dc8376d0bc1e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Truncate file&lt;/b&gt; operations. SQLite may truncate existing files by invoking the xTruncate() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 작업을 &lt;b&gt;자릅니다&lt;/b&gt; . SQLite는 sqlite3_file 객체의 xTruncate () 메서드를 호출하여 기존 파일을자를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4145432e1ccc1ea44b70a3377b44f8258ea4c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED FOLLOWING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;언 바운드 추종&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8d68f4761ba65c695e8f710308c336949cdcf89a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;UNBOUNDED PRECEDING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;바운딩되지 않은 선행&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f890ba61b6934cda1714e413c59c0c5a42dc7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Ubuntu&lt;/b&gt;: Desktop built from Intel i7-4770K at 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS</source>
          <target state="translated">&lt;b&gt;Ubuntu&lt;/b&gt; : Intel i7-4770K에서 3.50GHz, 32GiB RAM, Ubuntu 16.04.2 LTS로 구축 된 데스크탑</target>
        </trans-unit>
        <trans-unit id="8085a5307e375e1a3cc4d8ecb812cae7fed22ef8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Uninitialized memory.&lt;/b&gt; The instrumented memory allocator initializes each memory allocation to a nonsense bit pattern to help ensure that the user makes no assumptions about the content of allocation memory.</source>
          <target state="translated">&lt;b&gt;초기화되지 않은 메모리. &lt;/b&gt;인스트루먼트 된 메모리 할당자는 사용자가 할당 메모리의 내용에 대한 가정을하지 않도록하기 위해 각 메모리 할당을 넌센스 비트 패턴으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3925f9c7cd97c1b3f5e29f1be80c33e589fe5fd4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update on 2018-05-39:&lt;/b&gt; Our goal of supporting SQLite long-term have apparently come to the notice of the preservationist at the &lt;a href=&quot;https://www.loc.gov&quot;&gt;US Library Of Congress&lt;/a&gt; who have identified SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for the preservation of digital content.</source>
          <target state="translated">&lt;b&gt;2018-05-39 업데이트 :&lt;/b&gt; SQLite 장기 지원 목표 는 디지털 컨텐츠 보존을 위해 SQLite를 &lt;a href=&quot;locrsf&quot;&gt;권장 저장 형식으로&lt;/a&gt; 지정한 &lt;a href=&quot;https://www.loc.gov&quot;&gt;미국 의회 도서관의&lt;/a&gt; 보존 주의자에게 통지 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bd99662722847f47c9d95c77023462c53957fe12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Update:&lt;/b&gt; As of SQLite version 3.7.0 (2010-07-21), all of SQLite memory allocation interfaces are considered stable and will be supported in future releases.</source>
          <target state="translated">&lt;b&gt;업데이트 :&lt;/b&gt; SQLite 버전 3.7.0 (2010-07-21)부터 모든 SQLite 메모리 할당 인터페이스는 안정적인 것으로 간주되며 이후 릴리스에서 지원 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4a17f9a5725b7ea7266f7211279b754186bbd337" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions.&lt;/b&gt; SQLite normally assumes that terms in the WHERE clause that cannot be used by indexes have a strong probability of being true. If this assumption is incorrect, it could lead to a suboptimal query plan. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions can be used to provide hints to the query planner about WHERE clause terms that are probably not true, and thus aid the query planner in selecting the best possible plan.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;가능성 ()&lt;/a&gt; 과 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성 ()&lt;/a&gt; SQL 함수. &lt;/b&gt;SQLite는 일반적으로 인덱스에서 사용할 수없는 WHERE 절의 용어가 참일 가능성이 높다고 가정합니다. 이 가정이 올바르지 않으면 차선의 쿼리 계획으로 이어질 수 있습니다. &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;가능성 ()&lt;/a&gt; 과 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성 ()&lt;/a&gt; SQL 함수를 따라서 아마 사실이 아니다, 그리고 절 용어는 최적의 계획을 선택하는 쿼리 계획을 돕기 WHERE에 대한 쿼리 계획에 대한 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb5521088e750b2b0996ab4ac8d5d78ce99b3974" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use compile-time options to enable debugging features.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;컴파일 시간 옵션을 사용하여 디버깅 기능을 활성화하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="624e8c505d78662928c531469f8c4839dcd31815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use of memory after freeing.&lt;/b&gt; When each block of memory is freed, every byte is overwritten with a nonsense bit pattern. This helps to ensure that no memory is ever used after having been freed.</source>
          <target state="translated">&lt;b&gt;해제 후 메모리 사용. &lt;/b&gt;각 메모리 블록이 해제되면 모든 바이트는 넌센스 비트 패턴으로 덮어 씁니다. 이를 통해 해제 된 후 메모리가 사용되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60df967df8dc96a687fd1c6e5298ea7d5de4825c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &quot;.eqp full&quot; option on the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &quot;.eqp full&quot;옵션을 사용하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee77fa4780771a6f5280fc94a682c4c8900c4945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; syntax to enforce the selection of particular indexes on problem queries.&lt;/b&gt; As with the previous two bullets, avoid this step if possible, and especially avoid doing this early in development as it is clearly a premature optimization.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;lang_indexedby&quot;&gt;에 의해 색인을&lt;/a&gt; 문제 쿼리에 특정 인덱스의 선택을 적용하는 구문. &lt;/b&gt;앞의 두 글 머리표와 마찬가지로 가능한 경우이 단계를 피하고 특히 조기 최적화이므로 개발 초기에이 단계를 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bba7254595e9a630fbbef9f9fef16a316097697a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use the &lt;a href=&quot;optoverview#crossjoin&quot;&gt;CROSS JOIN&lt;/a&gt; syntax to enforce a particular loop nesting order on queries that might use low-quality indexes in an unanalyzed database.&lt;/b&gt; SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;treats the CROSS JOIN operator specially&lt;/a&gt;, forcing the table to the left to be an outer loop relative to the table on the right.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;optoverview#crossjoin&quot;&gt;가입 CROSS을&lt;/a&gt; unanalyzed 데이터베이스에 낮은 품질의 인덱스를 사용할 수있는 쿼리의 특정 루프 중첩 순서를 적용하는 구문을. &lt;/b&gt;SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;는 CROSS JOIN 연산자를 특수하게 처리하여&lt;/a&gt; 테이블을 왼쪽으로 강제하여 오른쪽 테이블과 관련하여 외부 루프가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fa98b891b98a769270b4431b060723a6be69cc3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Use unary &quot;+&quot; operators to disqualify WHERE clause terms.&lt;/b&gt; If the query planner insists on selecting a poor-quality index for a particular query when a much higher-quality index is available, then &lt;a href=&quot;optoverview#uplus&quot;&gt;careful use of unary &quot;+&quot; operators&lt;/a&gt; in the WHERE clause can force the query planner away from the poor-quality index. Avoid using this trick if at all possible, and especially avoid it early in the application development cycle. Beware that adding a unary &quot;+&quot; operator to an equality expression might change the result of that expression if &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is involved.</source>
          <target state="translated">&lt;b&gt;단항 &quot;+&quot;연산자를 사용하여 WHERE 절 용어를 실격하십시오. &lt;/b&gt;쿼리 플래너가 훨씬 더 높은 품질의 인덱스를 사용할 수있을 때 특정 쿼리에 대해 열악한 인덱스를 선택 &lt;a href=&quot;optoverview#uplus&quot;&gt;해야하는&lt;/a&gt; 경우 WHERE 절에서 단항 &quot;+&quot;연산자 를 주의해서 사용 하면 쿼리 플래너가 열악한 품질에서 벗어날 수 있습니다. 인덱스. 가능하면이 트릭을 사용하지 말고 특히 애플리케이션 개발주기 초기에 사용하지 마십시오. 항등식에 단항 &quot;+&quot;연산자를 추가하면 &lt;a href=&quot;datatype3#affinity&quot;&gt;형식 선호도&lt;/a&gt; 가 관련된 경우 해당 식의 결과가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cca9bf8bd8b6e185263dc550b7207fcabdfc778b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.breakpoint&quot; shell command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;.breakpoint&quot;셸 명령 사용&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="185e070273e5254ad642967181d8c3d2a28284dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; shell commands&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&quot;.selecttrace&quot;및 &quot;.wheretrace&quot;쉘 명령 사용&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f9397605fb07688bb69ea9f7536e70930b36524" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Variable-length records&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;가변 길이 레코드&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a6e556c10ec550463c045d14c122976ce8b5d00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large datasets&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;매우 큰 데이터 세트&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97000c025a0125f099ec23dce5e3ca08c6acd95e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Very large write transactions.&lt;/b&gt; A checkpoint can only complete when no other transactions are running, which means the WAL file cannot be reset in the middle of a write transaction. So a large change to a large database might result in a large WAL file. The WAL file will be checkpointed once the write transaction completes (assuming there are no other readers blocking it) but in the meantime, the file can grow very big.</source>
          <target state="translated">&lt;b&gt;매우 큰 쓰기 트랜잭션. &lt;/b&gt;검사 점은 다른 트랜잭션이 실행되고 있지 않을 때만 완료 할 수 있으므로 쓰기 트랜잭션 도중 WAL 파일을 재설정 할 수 없습니다. 따라서 큰 데이터베이스를 크게 변경하면 WAL 파일이 커질 수 있습니다. WAL 파일은 쓰기 트랜잭션이 완료되면 (이를 차단하는 다른 독자가 없다고 가정 할 때) 체크 포인트되지만 그 동안 파일이 매우 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d515fde87203051ec78c69e20ed524f4de5793a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_CKPT_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad6d56d4428a77145ca6242e596a7fa2c1803531" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_READ_LOCK(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5d110f0b82f62dd2f5a0794e764ea8169257175" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_RECOVER_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f158b1754a80661dff694e137aecc3b2f6efb345" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;WAL_WRITE_LOCK&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="888483948ca68cc0b0af34e4a9b2b453974882ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; Misuse of this pragma can result in &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;database corruption&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; 이 pragma를 잘못 사용하면 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;데이터베이스가 손상&lt;/a&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0030ed0fd53893377f5547815043278fa13ee8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The data returned by the EXPLAIN QUERY PLAN command is intended for interactive debugging only. The output format may change between SQLite releases. Applications should not depend on the output format of the EXPLAIN QUERY PLAN command.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; EXPLAIN QUERY PLAN 명령으로 리턴 된 데이터는 대화식 디버깅 전용입니다. 출력 형식은 SQLite 릴리스간에 변경 될 수 있습니다. 응용 프로그램은 EXPLAIN QUERY PLAN 명령의 출력 형식에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3df3036875341edb9f8fc3a8acb1f8bcea071d37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 객체 는 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체입니다. 멀티 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로&lt;a href=&quot;#sqlite3_create_function&quot;&gt;&lt;/a&gt;최상위 응용 프로그램 코드 내에 있지 않은 응용 프로그램 정의 SQL 함수 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e64773b994422fdf54e1035001ec5e582ab69ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 개체 는 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 개체입니다. 다중 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 만 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로 다음 구현 내에서만 유용합니다.&lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; , 최상위 애플리케이션 코드 내에 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d8f3551ffb881577fe6fa2ff6b699dbc1110b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 개체 는 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 개체입니다. 다중 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 만 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로 다음 구현 내에서만 유용합니다.&lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; , 최상위 애플리케이션 코드 내에 없습니다.</target>
        </trans-unit>
        <trans-unit id="e113677f8631906939d48925646a6301748cade3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; The object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object. In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;. If the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is used in any other way, including calls to routines like &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, the behavior is not threadsafe. Hence, the sqlite3_column_value() interface is normally only useful within the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;, not within top-level application code.</source>
          <target state="translated">&lt;b&gt;경고 : &lt;/b&gt;&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 객체 는 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체입니다. 멀티 스레드 환경에서 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; 와 함께 안전하게 사용할 수 있습니다 . 경우 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value의&lt;/a&gt; 개체에 의해 반환 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()&lt;/a&gt; 와 같은 루틴 호출을 포함, 다른 방법으로 사용된다 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_int ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; 또는 &lt;a href=&quot;value_blob&quot;&gt;() sqlite3_value_bytes&lt;/a&gt; , 행동이 스레드되지 않습니다. 따라서 sqlite3_column_value () 인터페이스는 일반적으로&lt;a href=&quot;create_function&quot;&gt;&lt;/a&gt;최상위 응용 프로그램 코드 내에 있지 않은 응용 프로그램 정의 SQL 함수 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c159c6aeb388ae4e30b7b7f4145c9b703dbe4dfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Warning:&lt;/b&gt; writing to the SQLITE_DBPAGE virtual table can very easily cause unrecoverably database corruption. Do not allow untrusted components to access the SQLITE_DBPAGE table. Use appropriate care while using the SQLITE_DBPAGE table. Back up important data prior to experimenting with the SQLITE_DBPAGE table. Writes to the SQLITE_DBPAGE virtual table are disabled when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set.</source>
          <target state="translated">&lt;b&gt;경고 :&lt;/b&gt; SQLITE_DBPAGE 가상 테이블에 쓰면 복구 할 수없는 데이터베이스 손상이 매우 쉽게 발생할 수 있습니다. 신뢰할 수없는 구성 요소가 SQLITE_DBPAGE 테이블에 액세스하도록 허용하지 마십시오. SQLITE_DBPAGE 테이블을 사용하는 동안 적절한주의를 기울이십시오. SQLITE_DBPAGE 테이블을 실험하기 전에 중요한 데이터를 백업하십시오. &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 설정 되면 SQLITE_DBPAGE 가상 테이블에 대한 쓰기가 사용 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="4f374c63735201c6cdaca2e4426827ae4ba2ca2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Website Database.&lt;/b&gt; Because it requires no configuration and stores information in ordinary disk files, SQLite is a popular choice as the database to back small to medium-sized websites.</source>
          <target state="translated">&lt;b&gt;웹 사이트 데이터베이스. &lt;/b&gt;구성이 필요하지 않고 일반 디스크 파일에 정보를 저장하기 때문에 SQLite는 중소 규모 웹 사이트를 백업하는 데이터베이스로 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e075eb30727f1c365f2bc04efc0a16da3a863f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Websites&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Websites&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="da1e82610dd7e1bffc89ad32ea03dfb074479e2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win10&lt;/b&gt;: A 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</source>
          <target state="translated">&lt;b&gt;Win10&lt;/b&gt; : 2016 Lenovo YOGA 910, Intel i7-7500 at 2.70GHz, 16GiB RAM, Windows10.</target>
        </trans-unit>
        <trans-unit id="ea8bed047d5529263f89a6ee40214f46592fa94e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Win7&lt;/b&gt;: A circa-2009 Dell Inspiron laptop, Pentium dual-core at 2.30GHz, 4GiB RAM, Windows7.</source>
          <target state="translated">&lt;b&gt;Win7&lt;/b&gt; : 2009 년경 Dell Inspiron 노트북, 2.30GHz의 Pentium 듀얼 코어, 4GiB RAM, Windows7.</target>
        </trans-unit>
        <trans-unit id="e68611734bd3e7ab106c3521f7c655f4756a046c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Wrapped Pile-of-Files Formats.&lt;/b&gt; Some applications use a Pile-of-Files that is then encapsulated into some kind of single-file container, usually a ZIP archive. EPUB, ODT,and ODP are examples of this approach. An EPUB book is really just a ZIP archive that contains various XHTML files for the text of book chapters, GIF and JPEG images for the artwork, and a specialized catalog file that tells the eBook reader how all the XML and image files fit together. OpenOffice documents (ODT and ODP) are also ZIP archives containing XML and images that represent their content as well as &quot;catalog&quot; files that show the interrelationships between the component parts.</source>
          <target state="translated">&lt;b&gt;래핑 된 파일 더미 형식.&lt;/b&gt; 일부 응용 프로그램은 파일 더미를 사용하여 일종의 단일 파일 컨테이너 (일반적으로 ZIP 아카이브)로 캡슐화합니다. EPUB, ODT 및 ODP가이 방법의 예입니다. EPUB 서적은 실제로 책 장의 텍스트를위한 다양한 XHTML 파일, 아트 워크를위한 GIF 및 JPEG 이미지, eBook 리더에게 모든 XML 및 이미지 파일이 어떻게 어울리는지를 알려주는 특화된 카탈로그 파일을 포함하는 ZIP 아카이브입니다. OpenOffice 문서 (ODT 및 ODP)는 구성 요소 부분 간의 상호 관계를 나타내는 &quot;카탈로그&quot;파일뿐만 아니라 해당 내용을 나타내는 XML 및 이미지를 포함하는 ZIP 아카이브입니다.</target>
        </trans-unit>
        <trans-unit id="e80e6ef180f77a11e4ad718760489bfd6c1d3980" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Write file&lt;/b&gt; operations. SQLite may modify the contents and increase the size of a file by files by invoking the xWrite() method of the sqlite3_file object.</source>
          <target state="translated">&lt;b&gt;파일 쓰기&lt;/b&gt; 작업. SQLite는 sqlite3_file 객체의 xWrite () 메서드를 호출하여 파일의 내용을 수정하고 파일 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93a8e5c6820d5cb61b30e7580636cac841de035" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Writer Starvation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;작가 기아&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d5d06edcd682d757dc164e732a60c0964a20210" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYSTACKDEPTH=&lt;i&gt;&amp;lt;max_depth&amp;gt;&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ccba30872e5a56e0c69301bb6c07bd4a14eedd1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;YYTRACKMAXSTACKDEPTH&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d9774ec4279042a099a60de1ddc091ef4d042e40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-Configuration&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Zero-Configuration&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d787411914cc50b14089e0d3d1dd388e2edc91a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Zero-malloc option.&lt;/b&gt; The application can optionally provide SQLite with several buffers of bulk memory at startup and SQLite will then use those provided buffers for all of its memory allocation needs and never call system malloc() or free().</source>
          <target state="translated">&lt;b&gt;멀록 제로 옵션. &lt;/b&gt;응용 프로그램은 시작시 SQLite에 여러 벌크 메모리 버퍼를 선택적으로 제공 할 수 있으며 SQLite는 모든 메모리 할당 요구에 대해 제공된 버퍼를 사용하고 시스템 malloc () 또는 free ()를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f2b743bcbe285635e0463a315a493eb37176373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;_HAVE_SQLITE_CONFIG_H&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33dcc6c87c822c07ebff240814a228ff607b0b40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;abs(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe5e3b0d396d614226a54388a7b4de0441733b51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;alignment&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;alignment&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194ffe7cb502ded114f889082435f2c16c8b7359" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5443e0f7d9f275c31c0eb7151cf4ea53927946d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;application_id; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;application_id; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e52171e1f2ed13a70f81dde9b3a852059c3f9848" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;assert(X)&lt;/b&gt; &amp;rarr; The assert(X) statement indicates that the condition X is always true. In other words, X is an invariant. The assert(X) macro works like a procedure in that it has no return value.</source>
          <target state="translated">&lt;b&gt;assert (X)&lt;/b&gt; &amp;rarr; assert (X) 문은 조건 X가 항상 참임을 나타냅니다. 다시 말해, X는 변하지 않습니다. assert (X) 매크로는 반환 값이 없다는 점에서 프로 시저처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e1d034110b826070c391f6a1b3222b94a181199d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d7cd7347cc987aab65acd4c17d0fb4f855e08cf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;auto_vacuum;&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;auto_vacuum; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d128f6edd956bb72b334d983e9c173584d32d33a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;avg(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="eb7b6c83e75fbe3b054ea415310a7352288778a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;backup_remaining() and backup_pagecount()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;backup_remaining () 및 backup_pagecount ()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="af51318f30245050461c25ceed50b0039299603f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;busy&lt;/b&gt;: This field is true if the prepared statement is currently running. In other words, this field is true if &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called on the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; at least once but &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; has not yet been called to reset it.</source>
          <target state="translated">&lt;b&gt;busy&lt;/b&gt; : 준비된 명령문이 현재 실행중인 경우이 필드는 true입니다. 경우 즉,이 필드는 사실이다 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()가&lt;/a&gt; 온 호출 된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 하지만 적어도 한 번 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()가&lt;/a&gt; 아직 다시 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c07a69ddd20e31f1d596560030beac75f1ec41f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache&lt;/b&gt;: The cache parameter may be set to either &quot;shared&quot; or &quot;private&quot;. Setting it to &quot;shared&quot; is equivalent to setting the SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to sqlite3_open_v2(). Setting the cache parameter to &quot;private&quot; is equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit. If sqlite3_open_v2() is used and the &quot;cache&quot; parameter is present in a URI filename, its value overrides any behavior requested by setting SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.</source>
          <target state="translated">&lt;b&gt;cache&lt;/b&gt; : 캐시 매개 변수는 &quot;shared&quot;또는 &quot;private&quot;으로 설정 될 수 있습니다. &quot;shared&quot;로 설정하는 것은 sqlite3_open_v2 ()에 전달 된 flags 인수에서 SQLITE_OPEN_SHAREDCACHE 비트를 설정하는 것과 같습니다. 캐시 매개 변수를 &quot;private&quot;으로 설정하는 것은 SQLITE_OPEN_PRIVATECACHE 비트를 설정하는 것과 같습니다. sqlite3_open_v2 ()를 사용하고 &quot;캐시&quot;매개 변수가 URI 파일 이름에있는 경우 해당 값은 SQLITE_OPEN_PRIVATECACHE 또는 SQLITE_OPEN_SHAREDCACHE 플래그를 설정하여 요청 된 동작을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="048afc3980c205fecc84abbd48f15a61272e10f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache=shared&lt;br/&gt;cache=private&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f187cf2b0d507dcac54b947ef4b4bb4548adec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = -&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size =-&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="66a05bfa29a1d5ad78648c64ef4a1bc402a7ef7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8be0f4e9732fbef28f44a865ce5359d4c63e5ba3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_size; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d813d1d4f13504bccfdec67887288aeb2c74bf6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cache_spill=&lt;i&gt;N&lt;/i&gt;;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ee76635f943345e36eadd20f93c4b84d756cd424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e34c8fad0c61810b664b1fb208a7e152cbd2d8f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;char(&lt;i&gt;X1&lt;/i&gt;,&lt;i&gt;X2&lt;/i&gt;,...,&lt;i&gt;XN&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9abb03962a5dc4852aff5e36c48f45d6a4a3d77a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;close&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;close&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2d6e4e63ef7fd21c4175c425685a7ddb1ca2bea1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;coalesce(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="35bbbb1bb66c64e00f2934f51b73b8e4f4056495" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;columns=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22b498af88a752c45b7e25f4181284d3db7afb1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;command&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;command&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad084040fb5ea49d3658d7989127f682b7f28c67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;count(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;count(*)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39af06e9905a7448ee0b1defae9d454b6841f4d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cov.rc&lt;/b&gt; - Options for measuring test coverage</source>
          <target state="translated">&lt;b&gt;cov.rc-&lt;/b&gt; 테스트 범위를 측정하기위한 옵션</target>
        </trans-unit>
        <trans-unit id="5cca5b66dc12bd7e7becb822abbebae01386bdb2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;cume_dist()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;cume_dist()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bce3e62d8a1b34b91114cf92fb902035b214587" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3783e6f7dc101319ad924bc9f09ae132e7c7f898" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data_version;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;data_version;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="389b2f8f724900f956d877a644e2e9603c0f26c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;date(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;date(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cbcb55ef3726cc2a71910590d0902f7faab4f9ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;datetime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;datetime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aee590495d14ff2cf1c5cbc37042295e0d1f08cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="402ca1dacea0721ad239c1af6cb3f5819295774e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;default_cache_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;default_cache_size; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6313bf298d297088101bbaddb662c2c916679adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;dense_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;dense_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2aac9f3db608b20d11947a5ae9700ebd62f45001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;distance&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;distance&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b484c204986ea3c75fae52cefde5798b5dd4e4f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;editdist3(P,W)&lt;br/&gt;editdist3(P,W,L)&lt;br/&gt;editdist3(T)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="70f1ae63992807b1cef27255763402cd1c0c70d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;extensions.rc&lt;/b&gt; - Options to enable &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;, and &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;extensions.rc&lt;/b&gt; - &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; , &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt; 및 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;STAT4&lt;/a&gt; 를 활성화하는 옵션 .</target>
        </trans-unit>
        <trans-unit id="9dd31bb22c519a3244a9371c90073d27eba9fcff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fast.rc&lt;/b&gt; - Run most tests, including those not needed for coverage, skipping only soak tests, using delivery compiler options (ex: -O3)</source>
          <target state="translated">&lt;b&gt;fast.rc-&lt;/b&gt; 제공 컴파일러 옵션 (예 : -O3)을 사용하여 적용 범위에 필요하지 않은 테스트를 포함하여 대부분의 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7047224cc767c22276bcd97b8b93c32d6c6dd0c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;filename=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;filename=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d86f5b252ea2c3905e9317b675f86261fe647565" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;first_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;first_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f6c983beee928db863455a33eaeb9e6e8731e6e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="98b8402ef4aa6df707621ab3e1424480dcd1b470" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;foreign_key_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;foreign_key_check; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e17b9027ffda510fd8200ef5dd02defe76fb361b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;freelist_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;freelist_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49c799144ac6e15128ed0f9aa7ec635a662a3d31" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;glob(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d51045bdeca73ea8688c5521c40c4f76212598ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;group_concat(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;group_concat(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cbaa7085724de96292b616e3361c44f3e9990d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffde63e4ba8d63cb5d1bc14f06bfecda9f5dd8b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;header=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;header=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cfef432e2caab9415a288e0d7ba9d174b173a01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;hex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd48f9963329d57278b189812b34811095c6cdeb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c5a7a75e65828537df32db2f1ac3e8fbbb008fae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ifnull(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="59e394b44a6744677d3a72d0eb34c77ce86693ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;iif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cce521b193beb15f59295fefb696fd4ade983bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt; : 불변 매개 변수는 데이터베이스 파일이 읽기 전용 미디어에 저장되어 있음을 나타내는 부울 쿼리 매개 변수입니다. 불변이 설정되면 SQLite는 더 높은 권한을 가진 프로세스로도 데이터베이스 파일을 변경할 수 없다고 가정하므로 데이터베이스는 읽기 전용으로 열리고 모든 잠금 및 변경 감지가 비활성화됩니다. 주의 : 실제로 변경되는 데이터베이스 파일에서 불변 속성을 설정하면 잘못된 쿼리 결과 및 / 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 오류가 발생할 수 있습니다. &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf141062b07419b584f4c1883f6a203a2df6601" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable&lt;/b&gt;: The immutable parameter is a boolean query parameter that indicates that the database file is stored on read-only media. When immutable is set, SQLite assumes that the database file cannot be changed, even by a process with higher privilege, and so the database is opened read-only and all locking and change detection is disabled. Caution: Setting the immutable property on a database file that does in fact change can result in incorrect query results and/or &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors. See also: &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;immutable&lt;/b&gt; : 불변 매개 변수는 데이터베이스 파일이 읽기 전용 미디어에 저장되어 있음을 나타내는 부울 쿼리 매개 변수입니다. 불변이 설정되면 SQLite는 더 높은 권한을 가진 프로세스로도 데이터베이스 파일을 변경할 수 없다고 가정하므로 데이터베이스는 읽기 전용으로 열리고 모든 잠금 및 변경 감지가 비활성화됩니다. 주의 : 실제로 변경되는 데이터베이스 파일에서 불변 속성을 설정하면 잘못된 쿼리 결과 및 / 또는 &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 오류가 발생할 수 있습니다. &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed08b6b1d1f0a664ae0f81d71d8d7810b3165b6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;immutable=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;immutable=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cccabe1bc4519474ead8892d0cd69c8b0775ed4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b5baf91e220e87719852feaa7184a098f41965b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;incremental_vacuum&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;incremental_vacuum&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f16d799bd7829150ce3e6604138fbebab20b5419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7688cc1ff573d2bca1de629a8d2a79e927035298" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_list(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_list(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2dfeb29a44b8e71355e11dbd4cf0aebfdd351c06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;index_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;index_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="207535d3995e19d40dc08d055ca415f8028e650a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;instr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac72f17cc719eb38ab9ab57e1ac893c356c119eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xColumnCount) (Fts5Context *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9750e0f760da519d8715d51c87874648a8fe67e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xColumnSize) (Fts5Context *, int iCol, int * pnToken)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d42b31da68a1e7f9ae5eecbab61aee9b43cb6b1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xColumnText) (Fts5Context *, int iCol, const char ** pz, int * pn)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a7ce4bfbb6d268c0d1ef8670fc34f7a4b65bb387" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xColumnTotalSize) (Fts5Context *, int iCol, sqlite3_int64 * pnToken)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3190bda489a99715fd738757d80223d99cccdbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xInst) (Fts5Context *, int iIdx, int * piPhrase, int * piCol, int * piOff)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="892559d9568a1d87d97b14bc61079a34debf6b83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xInstCount)(Fts5Context*, int *pnInst)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xInstCount) (Fts5Context *, int * pnInst)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="100e77957aba25dbbb31de82532ca7bf291eb970" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseCount)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xPhraseCount) (Fts5Context *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fcdaa92e2b0fc49b2bf5da218bbca933cf5c296" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xPhraseFirst) (Fts5Context *, int iPhrase, Fts5PhraseIter *, int *, int *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="031f3306d8acf8f83f8963454a0457de1feea424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xPhraseFirstColumn) (Fts5Context *, int iPhrase, Fts5PhraseIter *, int *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d49467cfac66b79b5909b3a249dfaa9d04d187b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xPhraseSize)(Fts5Context*, int iPhrase)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xPhraseSize) (Fts5Context *, int iPhrase)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e27ad327723310374823171bdbac767d224d4747" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData, int(*)(const Fts5ExtensionApi*,Fts5Context*,void*) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xQueryPhrase) (Fts5Context *, int iPhrase, void * pUserData, int (*) (const Fts5ExtensionApi *, Fts5Context *, void *))&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8af65e8dd1bd43dd26a39f7927ec9a0e3fc20406" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xRowCount) (Fts5Context *, sqlite3_int64 * pnRow)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="028bae0525e377b198a0579de0698834b402ef0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xSetAuxdata) (Fts5Context *, void * pAux, void (* xDelete) (void *))&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96b299d4b01b17194f0bfab31185570b2a5b0e26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int (*xTokenize)(Fts5Context*, const char *pText, int nText, void *pCtx, int (*xToken)(void*, int, const char*, int, int, int) )&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int (* xTokenize) (Fts5Context *, const char * pText, int nText, void * pCtx, int (* xToken) (void *, int, const char *, int, int, int))&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="71f951b67bdae3181e28bc99fbd1081f3db56229" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;integrity_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5f61e2b4f6af6827071e26ba0468c59f77f7382d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;integrity_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;integrity_check; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8dbcbd2f1b02531496228f6526096af9fa315739" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode = &lt;i&gt;DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode = &lt;i&gt;삭제 | 절단 | 지속 자 | 메모리 | 월 | 떨어져서&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f421c8ecbe88c2e594c771b7201c65eb77fcce60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_mode; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="33e1050ba5c76fd251b389021a94f193300849d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6038a087fec5ff7e87d3be2a0c692b4c7d54bf7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;journal_size_limit&lt;br/&gt; PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;journal_size_limit &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="27b030b978b02cc9207038086c7f2c60253ad04d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;julianday(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;julianday(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c43da3ded817719eb56f1590ebd527ae35875002" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d8481cc752e77e81f239fb8d49320bf2fa634efc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;k2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;k2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ede80f5c49ab1747c7f023b90de4537abacf288" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lag(expr)&lt;br/&gt;lag(expr, offset)&lt;br/&gt;lag(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;시차 (expr) &lt;br/&gt;시차 (expr, offset) &lt;br/&gt;시차 (expr, offset, default)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6d9ce10c584a3ee6d960754c6357d4f20cf2de71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;langid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;langid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f306288a791aefbb510d07825cdcbd178d873e42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_insert_rowid()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_insert_rowid()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cca2232f164d7c66d07ad3c034e6f4b6dda69dbd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;last_value(expr)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;last_value(expr)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="81ed8362f530c16dff1f7d9cc5b282b98b462fc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lead(expr)&lt;br/&gt;lead(expr, offset)&lt;br/&gt;lead(expr, offset, default)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lead (expr) &lt;br/&gt;lead (expr, offset) &lt;br/&gt;리드 (expr, 오프셋, 기본값)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="43d2123909b0f5a819af3db1c1e94d06a3f8779f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;length(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dfc5b8f00ea873518dc12f8893f25bbc6c66ce67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;br/&gt;like(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07c7c73b4b3991211d36821e85de44d186de4969" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likelihood(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="811594ce0b6e61d3b980bd09f4d1c39bf30bbb95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;likely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cdbe6610ca98a28c81ac1d281754e9a5e02f6a4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;load_extension(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;load_extension(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9df7ac0e0e06da4f24921e24ffa4a99e384f1953" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode = &lt;i&gt;NORMAL | EXCLUSIVE&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;locking_mode = &lt;i&gt;NORMAL | 독특한&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbd9cb7c00973c9cf4c02835fba7d46c4cd155b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locking_mode; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;잠금 모드; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d97f3f643b48dea573d334c35e46808c117b3e16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;lower(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="99d4e148947298901a28af9618a2edc72556c7ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ltrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;ltrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="50ee49b847d1bd0b4c011677c606dfe46418f9b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;matchlen&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;matchlen&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84700aab85d80dd19448c1aadba1ce06d6cac5e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dc1c91322cff028b6d2a6ae101916dba85e55305" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="86c668cbb57e22aa0c108185ae17175562403e88" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cca5fba8273357af3d23375f683db4ab915088e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;max_page_count; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;max_page_count; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46970ade90f97e0fcf3e0dcfc00dfcc8abf51125" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mem&lt;/b&gt;: This field is the number of bytes of heap storage used by the prepared statement. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;mem&lt;/b&gt; :이 필드는 준비된 명령문이 사용하는 힙 스토리지의 바이트 수입니다. 이 필드는 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2323e80eea828e053d28f31a4b3c98243b0559a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;memdebug.rc&lt;/b&gt; - like test.rc but also enable &lt;a href=&quot;compile#memdebug&quot;&gt;-DSQLITE_MEMDEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;memdebug.rc&lt;/b&gt; - &lt;b&gt;test.rc&lt;/b&gt; 와 유사하지만 -DSQLITE_MEMDEBUG도 활성화 &lt;a href=&quot;compile#memdebug&quot;&gt;합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2385b3a406fa9ea94dd4092a1e7ffc158d26ec6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb8829a5160360e2352f3a4c213691d03f9ba3f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;min(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d8df04651e720bd40286ee83b4d6e48760a9ee7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;min.rc&lt;/b&gt; - Run the minimum set of tests needed for 100% coverage.</source>
          <target state="translated">&lt;b&gt;min.rc&lt;/b&gt; -100 % 적용 범위에 필요한 최소 테스트 세트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9b5e7d659f4cfe7edf20e886f624adf61dcf6fe6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2d0eb11df5451ce3b5760e53da3fa40b8b4daa6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mmap_size=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mmap_size=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ab2f639309419d347aca23f719e0b621afb92015" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt; : mode 매개 변수는 &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;또는 &quot;memory&quot;로 설정 될 수 있습니다. 다른 값으로 설정하려고하면 오류가 발생합니다. &quot;ro&quot;가 지정되면 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; 플래그가 sqlite3_open_v2 ()의 세 번째 인수에 설정된 것처럼 데이터베이스가 읽기 전용 액세스를 위해 열립니다 . mode 옵션이 &quot;rw&quot;로 설정되면 SQLITE_OPEN_READWRITE (SQLITE_OPEN_CREATE가 아님)가 설정된 것처럼 데이터베이스가 읽기-쓰기 (만들지는 않음) 액세스를 위해 열립니다. &quot;rwc&quot;값은 SQLITE_OPEN_READWRITE 및 SQLITE_OPEN_CREATE를 모두 설정하는 것과 같습니다. mode 옵션이 &quot;memory&quot;로 설정되면 순수한 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt;디스크에서 읽거나 쓰지 않는 디스크가 사용됩니다. 세 번째 매개 변수에 sqlite3_open_v2 ()에 전달 된 플래그에 의해 지정된 것보다 덜 제한적인 모드 매개 변수의 값을 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="09e6b105c2bf735792ce11591cbf9c2f8556c47d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode&lt;/b&gt;: The mode parameter may be set to either &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;, or &quot;memory&quot;. Attempting to set it to any other value is an error. If &quot;ro&quot; is specified, then the database is opened for read-only access, just as if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; flag had been set in the third argument to sqlite3_open_v2(). If the mode option is set to &quot;rw&quot;, then the database is opened for read-write (but not create) access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had been set. Value &quot;rwc&quot; is equivalent to setting both SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE. If the mode option is set to &quot;memory&quot; then a pure &lt;a href=&quot;../inmemorydb&quot;&gt;in-memory database&lt;/a&gt; that never reads or writes from disk is used. It is an error to specify a value for the mode parameter that is less restrictive than that specified by the flags passed in the third parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;mode&lt;/b&gt; : mode 매개 변수는 &quot;ro&quot;, &quot;rw&quot;, &quot;rwc&quot;또는 &quot;memory&quot;로 설정 될 수 있습니다. 다른 값으로 설정하려고하면 오류가 발생합니다. &quot;ro&quot;가 지정되면 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; 플래그가 sqlite3_open_v2 ()의 세 번째 인수에 설정된 것처럼 데이터베이스가 읽기 전용 액세스를 위해 열립니다 . mode 옵션이 &quot;rw&quot;로 설정되면 SQLITE_OPEN_READWRITE (SQLITE_OPEN_CREATE가 아님)가 설정된 것처럼 데이터베이스가 읽기-쓰기 (만들지는 않음) 액세스를 위해 열립니다. &quot;rwc&quot;값은 SQLITE_OPEN_READWRITE 및 SQLITE_OPEN_CREATE를 모두 설정하는 것과 같습니다. mode 옵션이 &quot;memory&quot;로 설정되면 순수한 &lt;a href=&quot;../inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt;디스크에서 읽거나 쓰지 않는 디스크가 사용됩니다. 세 번째 매개 변수에 sqlite3_open_v2 ()에 전달 된 플래그에 의해 지정된 것보다 덜 제한적인 모드 매개 변수의 값을 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c3e378c447b57b9647ef1790cbe9e8e0fd004c14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;mode=ro&lt;br/&gt;mode=rw&lt;br/&gt;mode=rwc&lt;br/&gt;mode=memory&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3bd7aa3ba452f8a404691484d3d1e2ea817d6231" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;modeof=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;modeof=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b94737558aa8e30aba81834f353e695e866e2607" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;naidx&lt;/b&gt;: This field is the number of rows that have been inserted into &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt;. A positive value in this field may indicate an opportunity to improve performance by adding a named index that take the place of the automatic index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;naidx&lt;/b&gt; :이 필드는 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인&lt;/a&gt; 에 삽입 된 행 수입니다 . 이 필드의 양수 값은 자동 인덱스를 대신하는 명명 된 인덱스를 추가하여 성능을 향상시킬 수있는 기회를 나타낼 수 있습니다. 이 필드는 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusautoindex&quot;&gt;SQLITE_STMTSTATUS_AUTOINDEX&lt;/a&gt; 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1dca50e56e569f3a137f02613f8e101412a6fd0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ncol&lt;/b&gt;: The number of columns in the result set of a query. For DML statements, this column has a value of 0.</source>
          <target state="translated">&lt;b&gt;ncol&lt;/b&gt; : 쿼리 결과 집합의 열 수입니다. DML 문의 경우이 열의 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9266cf0d1aa52a6c88fc7a9ce528569eaf218e98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock&lt;/b&gt;: The nolock parameter is a boolean query parameter which if set disables file locking in rollback journal modes. This is useful for accessing a database on a filesystem that does not support locking. Caution: Database corruption might result if two or more processes write to the same database and any one of those processes uses nolock=1.</source>
          <target state="translated">&lt;b&gt;nolock&lt;/b&gt;: The nolock parameter is a boolean query parameter which if set disables file locking in rollback journal modes. This is useful for accessing a database on a filesystem that does not support locking. Caution: Database corruption might result if two or more processes write to the same database and any one of those processes uses nolock=1.</target>
        </trans-unit>
        <trans-unit id="92049c4fa68e8dcb2a9ce5d1c47395f719ee2e59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nolock=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nolock=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0821cde6d9d92bcfa8f51b791e202fe561c692f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;now&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;now&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c962d8bc64dcb99d96b34edfd80eef77b82d8960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nscan&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; has stepped through a table as part of a full-table scan. A large number if this field may indicate an opportunity to improve performance by adding an index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nscan&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; has stepped through a table as part of a full-table scan. A large number if this field may indicate an opportunity to improve performance by adding an index. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; value.</target>
        </trans-unit>
        <trans-unit id="793a688ba89916bc91e2948fcbbff88d939d50df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nsort&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; had to sort. A positive value in this field may indicate an opportunity to improve performance by adding an index that will cause the query results to appear naturally in the desired order. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nsort&lt;/b&gt;: This field is the number of times that the &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; had to sort. A positive value in this field may indicate an opportunity to improve performance by adding an index that will cause the query results to appear naturally in the desired order. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; value.</target>
        </trans-unit>
        <trans-unit id="bfe71888a18b09526c41d1b94956d1609d2df2a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nstep&lt;/b&gt;: This field is the number of &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; operations that have been performed for the prepared statement. This field can be used as a proxy for how much CPU time a statement has used. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;nstep&lt;/b&gt;: This field is the number of &lt;a href=&quot;opcode&quot;&gt;bytecode engine&lt;/a&gt; operations that have been performed for the prepared statement. This field can be used as a proxy for how much CPU time a statement has used. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; value.</target>
        </trans-unit>
        <trans-unit id="63815c843d590daa0dcf061c4721a9d5d4a2d517" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nth_value(expr, N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nth_value(expr, N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d0c888098e8713ffd7470fb70089d0baee7e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ntile(N)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ntile(N)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05286bde0bd001f85739e8fbad5157036721e2a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;nullif(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b025946bb0710a483f2eb1f6bb0f6acf583de102" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_count;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_count;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0acb36fa4cfdbd1af777924754ed8b90f92f80e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;page_size = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a41e038bc3ab6f9cb7c6c880a15dd5da22bca16a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;page_size; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;페이지 크기; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0f8fb606ccbf864fa90cbb5ee1a6f32cf556579f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;percent_rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;percent_rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7925229e75f9a5ddc4c6bcf1fce67735fed59f14" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;phonehash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;phonehash&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5499744b67dcd6206fb619427cb287b68fddad94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;printf(&lt;i&gt;FORMAT&lt;/i&gt;,...)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="173bb75d2eff480770bb8e83d250aaf82ef0042e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;profile&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;profile&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ab4d8dffa722a511d73e114b16c08dc6a537cb6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;../psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt; : psow 매개 변수는 &lt;a href=&quot;../psow&quot;&gt;powersafe 덮어 쓰기&lt;/a&gt; 속성이 데이터베이스 파일이있는 저장 장치 미디어에 적용 되는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="18dbe2a36203a00ce25e37c7598791b053afe0f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow&lt;/b&gt;: The psow parameter indicates whether or not the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property does or does not apply to the storage media on which the database file resides.</source>
          <target state="translated">&lt;b&gt;psow&lt;/b&gt; : psow 매개 변수는 &lt;a href=&quot;psow&quot;&gt;powersafe 덮어 쓰기&lt;/a&gt; 속성이 데이터베이스 파일이있는 저장 장치 미디어에 적용 되는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="19672e769c27252099c41616a5a8161a4d6518d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;psow=0&lt;br/&gt;psow=1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2f260f1801a8e818b6ff06e8303be11d7451a10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick.rc&lt;/b&gt; - Run all tests required for 100% coverage tests using -Os and &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;quick.rc&lt;/b&gt; --Os 및 &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG를&lt;/a&gt; 사용하여 100 % 적용 범위 테스트에 필요한 모든 테스트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fd4aa79ddd410cd9139a41d386311916ebe9d17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quick_check(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="994a2c2443ac0da9003e00fe190aaa31db2160a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quick_check; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;빠른 확인; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b14e2eb2027ccd9a5fae3e53bbc6e949cbc94b70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;quote(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="340804ccd9900156a5ee658749fc30933ec1cc6d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;random()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;random()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e582c145eb46045893175b9cad76026024fcc73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;randomblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d52d0687653f788c9a1d0b62c1ec148950ea4eb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c0dddfe101189ad9de03f6a2247d0074815decf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rank&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rank&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5642fd86cd16372a166c437b2acd799966efa693" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;replace(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1387ead5a7eaf9239d995873793737440d057fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;reprep&lt;/b&gt;: This field is the number of times that the statement has had to be reprepared due to schema changes or changes to parameter bindings. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;reprep&lt;/b&gt; :이 필드는 스키마 변경 또는 매개 변수 바인딩 변경으로 인해 명령문을 다시 준비 &lt;b&gt;해야하는&lt;/b&gt; 횟수입니다. 이 필드는 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt; 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="13892832e8f338f883dc9f1b67835b33d26f9407" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ro&lt;/b&gt;: The &quot;read only&quot; column. This column is true (non-zero) if the SQL statement is a query and false (zero) if it is a DML statement.</source>
          <target state="translated">&lt;b&gt;ro&lt;/b&gt; : &quot;읽기 전용&quot;열. 이 명령문은 SQL 문이 쿼리 인 경우 true (0이 아님)이고 DML 문인 경우 false (0)입니다.</target>
        </trans-unit>
        <trans-unit id="578448d770f3d2a1b5a91906bea2c63bf15fb132" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;round(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;round(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7c9a2c7f5f210b7436687e26513be6f97e02a2d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bc595dec6582246906837ece99dd2d9d595c4be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;row_number()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;row_number()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bb5815912a7a25828847a14d830afa81794e48c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid BETWEEN $lwr AND $upr&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;$ lwr와 $ upr 사이의 rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="24cc6900b78e2dccfbf100ecdd22f5422feb3151" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid IN&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid IN&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="194d8c92ba435bfeb5dddcca984211dc5c83f9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cc7bc59f8cdd1723aa19dd21067fb2173a1d966d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rowid=$id&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rowid=$id&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8b2e4bd1806543d782878e39a0464ee350a55bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;rtrim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;rtrim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a01ed5e9b0f95f0e890796478ba1457e1d2012a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;run&lt;/b&gt;: This field is the number of times that the statement has been run. This field is equivalent to the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt; value.</source>
          <target state="translated">&lt;b&gt;run&lt;/b&gt; :이 필드는 명령문이 실행 된 횟수입니다. 이 필드는 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt; 값 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6665c42d1931c0c11bc5fdb3f4263f62967dd63d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7581ff4e29fb81935f4ac0e64765167bccedcaf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e88eb35aae7e462aa136a9cf07bcc20b9b1be9ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;schema_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;schema_version; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a9f0cd2885d562989c04156ad40993a8ae646" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;scope&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;scope&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2741e4cf3f42be902ed8f4f9feeb47588d70ef90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;score&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;score&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c73b09e15d5fda473433a1b9ec4f9f86563ba45c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf2ead5c4efff15afbf4a1d95f72bf4bcf3aaac9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;secure_delete; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;secure_delete; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e7bba61243050573065917c0d6af2442d5ad0e95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;shell.c&lt;/b&gt;: The command-line interface program itself. This is the C source code file that contains the definition of the &lt;b&gt;main()&lt;/b&gt; routine and the loop that prompts for user input and passes that input into the SQLite database engine for processing.</source>
          <target state="translated">&lt;b&gt;shell.c&lt;/b&gt; : 명령 행 인터페이스 프로그램 자체. 이것은 &lt;b&gt;main ()&lt;/b&gt; 루틴 의 정의 와 사용자 입력을 요구하고 처리를 위해 해당 입력을 SQLite 데이터베이스 엔진으로 전달하는 루프 의 정의를 포함하는 C 소스 코드 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="605c53952422929c94c4ef797c0cae43610c5471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundex(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd4f59d9802ac2b8b9ccdfced25c86d0a351f22a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;soundslike&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;soundslike&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="439148df042711bd9ba70bd7e598ffbca547afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_editdist(P,W)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a6c0d38f6505697db2c498ea35b78ed9e5fc63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_phonehash(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ce4abdb98f5e793c14ba05e7c794774cec57a9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_scriptcode(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="55372a1db28566500f11b9a322c8e23b33028121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;spellfix1_translit(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="72513f2eaa33786572b541eb69611d8a91d32bd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sql&lt;/b&gt;: The original SQL text of the prepared statement. If the prepared statement is compiled using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface, then the SQL text might not have been saved, in which case this column will be NULL.</source>
          <target state="translated">&lt;b&gt;sql&lt;/b&gt; : 준비된 명령문의 원본 SQL 텍스트 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스를 사용하여 준비된 명령문을 컴파일 하면 SQL 텍스트가 저장되지 않았을 수 있으며이 경우이 열은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="b98d7e7639e1091f7a9cc980b2fa80fcf072e758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_compress(X)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40ef691312d4ca7479d76cbfc1797a518f374cc8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlar_uncompress(Y,SZ)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6cebe7a7b12fd950a74b5fba5575de4973ffb868" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.c&lt;/b&gt;: The SQLite amalgamation source file</source>
          <target state="translated">&lt;b&gt;sqlite3.c&lt;/b&gt; : SQLite 합병 소스 파일</target>
        </trans-unit>
        <trans-unit id="5c09182d460b59bea381dbce17c0a713fbd32a19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3.h&lt;/b&gt;: The header files that accompanies sqlite3.c and defines the C-language interfaces to SQLite.</source>
          <target state="translated">&lt;b&gt;sqlite3.h&lt;/b&gt; : sqlite3.c와 함께 제공되며 SQLite에 대한 C 언어 인터페이스를 정의하는 헤더 파일.</target>
        </trans-unit>
        <trans-unit id="5bc4c2f9fd5dadcb7d70ecf5019b082922291e64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_finish()&lt;/b&gt; is called to release all resources associated with the backup operation.</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;백업 조작과 연관된 모든 자원을 해제하기 위해 &lt;b&gt;sqlite3_backup_finish ()&lt;/b&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7599f05bd7927f9fe0e7226e610b201a20fca5cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_init()&lt;/b&gt; is called once to initialize the backup,</source>
          <target state="translated">&lt;b&gt;&lt;/b&gt;백업을 초기화하기 위해 &lt;b&gt;sqlite3_backup_init ()&lt;/b&gt; 가 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="50049f9518772742b4f4d7a9638718fd332f558c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_backup_step()&lt;/b&gt; is called one or more times to transfer the data between the two databases, and finally</source>
          <target state="translated">&lt;b&gt;sqlite3_backup_step ()&lt;/b&gt; 이 두 데이터베이스간에 데이터를 전송하기 위해 한 번 이상 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="36384ee5a830c16bb1e112e7d3a904e2090a6806" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite3_int64 (*xRowid)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite3_int64 (* xRowid) (Fts5Context *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d84a20c3533b13fd8f3158014a02d324fdf73854" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_get(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f387f1d980ba1b6ac824b01c4502663c86db1b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_compileoption_used(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d6e44884028fa4a47b130aec37b250e2c69a0833" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ebcfeff700a28642ccb8dde6efb294b6168bbaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_exec_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a04b66dabddcc301fcb52fd7ec612ccbabf6148" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_printf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f711405ae8eba472544d1aa5cfd209c541dc90a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_get_table_vprintf()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8617cd19825488ab7fdd81fef2642bb7b5bd4e71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_offset(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2efa54cd4a876a8b910e9958257c43e50054c08b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_source_id()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_source_id()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6332e2508f2d7603546d3bcc08b9be6340cd89c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sqlite_version()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sqlite_version()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="abde37706a46b7ca8874418dde8c8e57d75e9301" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;srchcnt&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;srchcnt&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="766dd6c9278d00bc9e2d900050adefb7e1ac80fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;statement&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;statement&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61469f9128c59549d8929ca8786e2516099564cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;strftime(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;strftime(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cae9927a2b3298dd39e25b370b34d3395edd5527" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;br/&gt;substr(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e12c6d8c9e8a39f25add895e2c0bf8d194e1c45f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;sum(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;total(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8a3492ae3d2a89485e206c4937164ed7d324c5a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;동기식 = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f085e6ee811e844fee162829f6334cdd145d4bca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;synchronous; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;동기식; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f03ee139387146c590bdbb574bc081c350f09bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_info(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_info(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c6eefb15dd071e91029df39120e4adef6f09f67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;table_xinfo(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;table_xinfo(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a7146ae989b40b504ed9566df150fba27db865a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test-ex.rc&lt;/b&gt; - long-running soak tests.</source>
          <target state="translated">&lt;b&gt;test-ex.rc-&lt;/b&gt; 장시간 실행되는 담금 테스트.</target>
        </trans-unit>
        <trans-unit id="9082bc8530887269298fa6b758b7df0103f4afb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.rc&lt;/b&gt; - Run the same tests as in fast.rc but without compiler optimization and enabling options like &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt; and -DSQLITE_ENABLE_EXPENSIVE_ASSERT.</source>
          <target state="translated">&lt;b&gt;test.rc&lt;/b&gt; - &lt;b&gt;fast.rc&lt;/b&gt; 와 동일한 테스트를 수행하지만 컴파일러 최적화없이 &lt;a href=&quot;compile#debug&quot;&gt;-DSQLITE_DEBUG&lt;/a&gt; 및 -DSQLITE_ENABLE_EXPENSIVE_ASSERT와 같은 옵션을 활성화 하십시오.</target>
        </trans-unit>
        <trans-unit id="4ec47fe06e8fa40340ac7dc1a59a81c280b08d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;testcase(X)&lt;/b&gt; &amp;rarr; The testcase(X) statement indicates that X is sometimes true and sometimes false. In other words, testcase(X) indicates that X is definitely not an invariant. Since SQLite uses 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC testing&lt;/a&gt;, the presence of a testcase(X) macro indicates that not only is it possible for X to be either true or false, but there are test cases to demonstrate this.</source>
          <target state="translated">&lt;b&gt;testcase (X)&lt;/b&gt; &amp;rarr; testcase (X) 문은 X가 때때로 true이고 때로는 false임을 나타냅니다. 즉, testcase (X)는 X가 항상 변하지 않는 것을 나타냅니다. SQLite는 100 % &lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC testing&lt;/a&gt; 을 사용하므로 testcase (X) 매크로가 있으면 X가 true 또는 false 일 수있을뿐만 아니라이를 입증하는 테스트 사례가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="387747815042252f6049ab6dffd4c9e618d3c9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;time(&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;time(&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="751f81cbcc6744df5561e7226f36021bf2e3af36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;top&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;top&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e24cfa079085118e42e96d2a55a37a53557cd88e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;total_changes()&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;total_changes()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="542f31e075ca05fd951176f4d597451afd1125ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;trim(&lt;i&gt;X&lt;/i&gt;)&lt;br/&gt;trim(&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Y&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5adfeb6f8a74b81f3673d50c2e3be5461cb4506" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;typeof(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="564af250a086d4ca4862414f517487932362df50" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unicode(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9a493d0d93cdad6d8063bb460480308af31d81af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-dotfile&lt;/b&gt; - uses dot-file locking rather than POSIX advisory locks.</source>
          <target state="translated">&lt;b&gt;unix-dotfile&lt;/b&gt; -POSIX 권고 잠금이 아닌 도트 파일 잠금을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7ee0b7222a0d2745b0960933b8554bb0b2cb0f36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-excl&lt;/b&gt; - obtains and holds an exclusive lock on database files, preventing other processes from accessing the database. Also keeps the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; in heap rather than in shared memory.</source>
          <target state="translated">&lt;b&gt;unix-excl-&lt;/b&gt; 데이터베이스 파일에 대한 독점 잠금을 확보하고 보유하여 다른 프로세스가 데이터베이스에 액세스하지 못하게합니다. 또한 &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; 를 공유 메모리가 아닌 힙으로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="171a40a565e91b5e38415639e5c0e1f0a1d0147f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-namedsem&lt;/b&gt; - uses named semaphores for file locking. VXWorks only.</source>
          <target state="translated">&lt;b&gt;unix-namedsem-&lt;/b&gt; 파일 잠금을 위해 명명 된 세마포어를 사용합니다. VXWorks 만 해당.</target>
        </trans-unit>
        <trans-unit id="87aa888be05eec90be29a815beb11ebb61786bc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unix-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;unix-none-&lt;/b&gt; 모든 파일 잠금 작업이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3e2ab215f74d535aecccce1746b0b6f8e4eee96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;unlikely(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7abd3b06da2eeea0c8f757f2140032a74361ffdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;upper(&lt;i&gt;X&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a630c6ced4b606f3e586eb856c79eca570d7b5d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version = &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version = &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25f14ee4f8a99c00c21229b1476cff5c7dcf693f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;user_version; &lt;br/&gt;PRAGMA &lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;user_version; &lt;br/&gt;PRAGMA&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="088cf7d75ebd01b23e3aca416dca22a57dac9950" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs&lt;/b&gt;: The &quot;vfs&quot; parameter may be used to specify the name of a VFS object that provides the operating system interface that should be used to access the database file on disk. If this option is set to an empty string the default VFS object is used. Specifying an unknown VFS is an error. If sqlite3_open_v2() is used and the vfs option is present, then the VFS specified by the option takes precedence over the value passed as the fourth parameter to sqlite3_open_v2().</source>
          <target state="translated">&lt;b&gt;vfs&lt;/b&gt; : &quot;vfs&quot;매개 변수는 디스크의 데이터베이스 파일에 액세스하는 데 사용해야하는 운영 체제 인터페이스를 제공하는 VFS 오브젝트의 이름을 지정하는 데 사용될 수 있습니다. 이 옵션을 빈 문자열로 설정하면 기본 VFS 객체가 사용됩니다. 알 수없는 VFS를 지정하면 오류가 발생합니다. sqlite3_open_v2 ()가 사용되고 vfs 옵션이 존재하면 옵션으로 지정된 VFS가 sqlite3_open_v2 ()에 네 번째 매개 변수로 전달 된 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="2998c7ff661dc1402458997c40d904ae7019342d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;vfs=&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;vfs=&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6be0f1dac527f6a7a3a8b6d2e7324226055d9238" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void (* xPhraseNext) (Fts5Context *, Fts5PhraseIter *, int * piCol, int * piOff)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bfac065939a7511e81786f4f00b434cd5618329" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void (* xPhraseNextColumn) (Fts5Context *, Fts5PhraseIter *, int * piCol)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0f50db153cf3b9cc7e9e88b1554a9c5a044290b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xGetAuxdata)(Fts5Context*, int bClear)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;무효 * (* xGetAuxdata) (Fts5Context *, int bClear)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1dd96b486c80ce4df848a29698eba4d9200ba1cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void *(*xUserData)(Fts5Context*)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;무효 * (* xUserData) (Fts5Context *)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b126f269504e317361d82c9eb42ec77f3cb00678" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(FULL);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5c4d6723b1efc24a3f9e4546fac324515250a15f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(PASSIVE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="245179a0a4378112590955d1a1537df9f96e19d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(RESTART);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf71d8462439fb51aa407e19229e4d9affee0e5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint(TRUNCATE);&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7e49255e11543623b2c50370c1e1606794efe285" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;wal_checkpoint;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;wal_checkpoint;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0751bc3711d32d9aac3b755aa8669d93303b0272" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath-none&lt;/b&gt; - combination of &quot;win32-longpath&quot; and &quot;win32-none&quot; - long pathnames are supported and all lock operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32-longpath-none-&lt;/b&gt; &quot;win32-longpath&quot;와 &quot;win32-none&quot;의 조합-긴 경로 이름이 지원되며 모든 잠금 작업이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ad6725cafce35d815b8464dedebc92eb51ec573" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-longpath&lt;/b&gt; - like &quot;win32&quot; except that pathnames can be up to 65534 bytes in length, whereas pathnames max out at 1040 bytes in &quot;win32&quot;.</source>
          <target state="translated">&lt;b&gt;win32-longpath-&lt;/b&gt; 경로 이름의 길이는 최대 65534 바이트 일 수 있지만 &quot;win32&quot;의 경로 이름은 1040 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="beadca375c7cb43a64419f239d7bb81fa172a062" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;win32-none&lt;/b&gt; - all file locking operations are no-ops.</source>
          <target state="translated">&lt;b&gt;win32- 없음&lt;/b&gt; -모든 파일 잠금 작업이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f7df8b834c26f9670be7255e91884f981bbdf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;word&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;word&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ccfe69e2ef2274904ba1b989763fe9daed749" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xCreate:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;xCreate:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08ea35c5e28008270d3f794e11e6b29032f8b335" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(3)&lt;/b&gt; - remove value &quot;3&quot; from the window. The window now contains values 8 and 1 only.</source>
          <target state="translated">&lt;b&gt;xInverse (3)&lt;/b&gt; -창에서 &quot;3&quot;값을 제거하십시오. 이제 창에는 값 8과 1 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d06f04ca5de186ef308cf987a39acd62fa581efb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(4)&lt;/b&gt; - remove &quot;4&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse (4)&lt;/b&gt; -창에서 &quot;4&quot;를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea3b2c9ac24752a4d124bf259358d12a4385ed1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xInverse(5)&lt;/b&gt; - remove value &quot;5&quot; from the window.</source>
          <target state="translated">&lt;b&gt;xInverse (5)&lt;/b&gt; -창에서 &quot;5&quot;값을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c201bad931f8401061d806fb20a99e02f340ca75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(1)&lt;/b&gt; - add value &quot;1&quot; to the window.</source>
          <target state="translated">&lt;b&gt;xStep (1)&lt;/b&gt; -창에 &quot;1&quot;값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="552183d8347d4aa8b4ecd28963b82e0980c54d3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(3)&lt;/b&gt; - add &quot;3&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep (3)&lt;/b&gt; -현재 창에 &quot;3&quot;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4686be269638aad4598d31d42b3f4f673d7fe4a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(4)&lt;/b&gt; - add &quot;4&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep (4)&lt;/b&gt; -현재 창에 &quot;4&quot;를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d82113cc4bb37a3f6a26309f9a359011d7b90a67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(5)&lt;/b&gt; - add &quot;5&quot; to the current window.</source>
          <target state="translated">&lt;b&gt;xStep (5)&lt;/b&gt; -현재 창에 &quot;5&quot;를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="26af953955c0fb0cb311f7c624b1676a7c454639" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xStep(8)&lt;/b&gt; - add &quot;8&quot; to the current window. The window now consists of values 5, 3 and 8.</source>
          <target state="translated">&lt;b&gt;xStep (8)&lt;/b&gt; -현재 창에 &quot;8&quot;을 추가하십시오. 이제 창은 값 5, 3 및 8로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="cf072a5adae091a25691fa9f8a75085c48f93b90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='a'). The window currently consists of values 4 and 5, and so the result is 9.</source>
          <target state="translated">&lt;b&gt;xValue ()&lt;/b&gt; -xValue ()를 호출하여 (x = 'a')가있는 행의 sumint () 값을 얻습니다. 창은 현재 값 4와 5로 구성되므로 결과는 9입니다.</target>
        </trans-unit>
        <trans-unit id="2c5dd79d383628751a86ee2ffb1fcdc34f1bd26e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoke xValue() to obtain the value of sumint() for the row with (x='b'). The window currently consists of values 4, 5 and 3, and so the result is 12.</source>
          <target state="translated">&lt;b&gt;xValue ()&lt;/b&gt; -xValue ()를 호출하여 행의 sumint () 값을 (x = 'b')로 얻습니다. 이 창은 현재 값 4, 5 및 3으로 구성되어 있으므로 결과는 12입니다.</target>
        </trans-unit>
        <trans-unit id="a6e4b8f199ffe99bce9be789081aca11bd89a987" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d').</source>
          <target state="translated">&lt;b&gt;xValue ()&lt;/b&gt; -행의 값을 얻기 위해 호출됩니다 (x = 'd').</target>
        </trans-unit>
        <trans-unit id="1a08acb2172b97a134c2c8886902b63f79dd194d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for row (x='d'). 9.</source>
          <target state="translated">&lt;b&gt;xValue ()&lt;/b&gt; -행의 값을 얻기 위해 호출됩니다 (x = 'd'). 9.</target>
        </trans-unit>
        <trans-unit id="5ff710f762c530458940d685a64c42fe7d5eb730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;xValue()&lt;/b&gt; - invoked to obtain the value for the row with (x='c'). In this case, 16.</source>
          <target state="translated">&lt;b&gt;xValue ()&lt;/b&gt; -(x = 'c')로 행의 값을 얻기 위해 호출됩니다. 이 경우 16입니다.</target>
        </trans-unit>
        <trans-unit id="c2de13f92fe4c6dae6ac8db9dacd9ccaae02dc07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;zeroblob(&lt;i&gt;N&lt;/i&gt;)&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9fa13734f5aacd4ab8879e00f3c9d12402784092" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Create indexes that might have been helpful to recent queries.</source>
          <target state="translated">&lt;em&gt;(아직 구현되지 않음)&lt;/em&gt; 최근 쿼리에 도움이되었을 수있는 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b6e6228539f5984d272435f54680c919edca57b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Not yet implemented)&lt;/em&gt; Record usage and performance information from the current session in the database file so that it will be available to &quot;optimize&quot; pragmas run by future database connections.</source>
          <target state="translated">&lt;em&gt;(아직 구현되지 않음)&lt;/em&gt; 향후 데이터베이스 연결로 실행되는 pragma를 &quot;최적화&quot;할 수 있도록 데이터베이스 파일에 현재 세션의 사용량 및 성능 정보를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="6d4e8b1714f1b41237ba93ca2e5bf1b3d93408f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_master table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; sqlite_master 테이블을 이와 같이 변경하면 변경에 구문 오류가있는 경우 데이터베이스가 손상되어 읽을 수 없게됩니다. 중요한 데이터가 포함 된 데이터베이스에서 UPDATE 문을 사용하기 전에 별도의 빈 데이터베이스에서 UPDATE 문을주의 깊게 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="51f3632551479a4241159ad77de3f62c093d8c27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Making a change to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains a syntax error. It is suggested that careful testing of the UPDATE statement be done on a separate blank database prior to using it on a database containing important data.</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; 이와 같이 sqlite_schema 테이블을 변경하면 변경에 구문 오류가 포함 된 경우 데이터베이스가 손상되고 읽을 수 없게됩니다. 중요한 데이터를 포함하는 데이터베이스에서 사용하기 전에 별도의 빈 데이터베이스에서 UPDATE 문을주의 깊게 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e8d8331be552f1d9886147666d4d00355995833" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_master table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; sqlite_master 테이블을 이와 같이 변경하면 변경 사항에 오류가있는 경우 데이터베이스가 손상되어 읽을 수 없게됩니다. 이 절차를 실행하기 전에 중요한 데이터가 포함 된 데이터베이스에서 사용하기 전에 별도의 테스트 데이터베이스에서이 전체 절차를주의 깊게 테스트하거나 중요한 데이터베이스의 백업 복사본을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="6d6c1135084f914bbdf80a671b4bb8717b33074e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; Once again, making changes to the sqlite_schema table like this will render the database corrupt and unreadable if the change contains an error. Carefully test this entire procedure on a separate test database prior to using it on a database containing important data and/or make backup copies of important databases prior to running this procedure.</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; 다시 한 번 sqlite_schema 테이블을 이와 같이 변경하면 변경에 오류가있는 경우 데이터베이스가 손상되고 읽을 수 없게됩니다. 중요한 데이터가 포함 된 데이터베이스에서 사용하기 전에 별도의 테스트 데이터베이스에서이 전체 절차를주의 깊게 테스트하고 /하거나이 절차를 실행하기 전에 중요한 데이터베이스의 백업 복사본을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="80f6ba8783597d88987529bbf21585dc3045c297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nota Bene:&lt;/em&gt; In this rule, &quot;application&quot; means the code that issues SQL statements. If the &quot;application&quot; is an &lt;a href=&quot;whentouse#serversidedb&quot;&gt;application server&lt;/a&gt; and if the content resides on the same physical machine as the application server, then SQLite might still be appropriate even though the end user is another network hop away.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이 규칙에서 &quot;application&quot;은 SQL 문을 발행하는 코드를 의미합니다. &quot;응용 프로그램&quot;이 &lt;a href=&quot;whentouse#serversidedb&quot;&gt;응용 프로그램 서버&lt;/a&gt; 이고 컨텐츠 가 응용 프로그램 서버 와 동일한 실제 시스템에 상주하는 경우, 최종 사용자가 다른 네트워크로 이동하더라도 SQLite가 여전히 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a88a70f28eea7505a4745ef400e6ee503235e73" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;any&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;any&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9f86c02aa28130769f3916ecd58dfbb1c988d34" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;It is not possible to open &lt;a href=&quot;wal#readonly&quot;&gt;read-only WAL databases&lt;/a&gt;. The opening process must have write privileges for &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; shared memory file associated with the database, if that file exists, or else write access on the directory containing the database file if the &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; file does not exist.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22), a read-only WAL-mode database file can be opened if the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists or those files can be created or the &lt;a href=&quot;uri#uriimmutable&quot;&gt;database is immutable&lt;/a&gt;.</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;wal#readonly&quot;&gt;읽기 전용 WAL 데이터베이스&lt;/a&gt; 를 열 수 없습니다 . 오프닝 프로세스에는 해당 파일이 존재하는 경우 데이터베이스와 연관된 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot; &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; 공유 메모리 파일에 대한 쓰기 권한이 있거나 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;파일이없는 경우 데이터베이스 파일을 포함하는 디렉토리에 대한 쓰기 액세스 권한이 있어야 합니다. &lt;/s&gt;&lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;버전 3.22.0&lt;/a&gt; (2018-01-22) 부터 &lt;code&gt;-shm&lt;/code&gt; 및 &lt;code&gt;-wal&lt;/code&gt; 파일이 이미 존재하거나 해당 파일을 만들거나 &lt;a href=&quot;uri#uriimmutable&quot;&gt;데이터베이스를 변경할 수없는&lt;/a&gt; 경우 읽기 전용 WAL 모드 데이터베이스 파일을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4adae4e92d852fe832ed5d1eceb7319abc564534" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;The target database may not contain &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.&lt;/s&gt; Indexes on expressions are supported beginning with SQLite 3.30.0 (2019-10-04).</source>
          <target state="translated">&lt;s&gt;대상 데이터베이스에는 &lt;a href=&quot;expridx&quot;&gt;표현식에 대한 색인이&lt;/a&gt; 포함되어 있지 않을 수 있습니다 . &lt;/s&gt;식에 대한 인덱스는 SQLite 3.30.0 (2019-10-04)부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db395f459bbe4efd96a60570c6c0dc0d9de9b06f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;WAL works best with smaller transactions. WAL does not work well for very large transactions. For transactions larger than about 100 megabytes, traditional rollback journal modes will likely be faster. For transactions in excess of a gigabyte, WAL mode may fail with an I/O or disk-full error. It is recommended that one of the rollback journal modes be used for transactions larger than a few dozen megabytes.&lt;/s&gt; Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), WAL mode works as efficiently with large transactions as does rollback mode.</source>
          <target state="translated">&lt;s&gt;WAL은 소규모 거래에서 가장 잘 작동합니다. 대규모 트랜잭션에는 WAL이 제대로 작동하지 않습니다. 약 100MB보다 큰 트랜잭션의 경우 기존 롤백 저널 모드가 더 빠를 수 있습니다. 기가 바이트를 초과하는 트랜잭션의 경우 WAL 모드가 I / O 또는 디스크 가득 참 오류와 함께 실패 할 수 있습니다. 롤백 저널 모드 중 하나를 수십 메가 바이트보다 큰 트랜잭션에 사용하는 것이 좋습니다. &lt;/s&gt;부터 &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016년 2월 15일), WAL 모드는 롤백 모드처럼 큰 트랜잭션을 효율적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89e3d94a9d9f3be8c533f30cf505fbbc9e619b12" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;count_changes&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="2fe7dcf40a505cee3d2c9c220b0b032b337985ba" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;data_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="529e4c95946d239f6f7340a28f8c19b836131c18" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;default_cache_size&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="1e40be7959fdcb27f689b1bd4b4c13f00f9648e7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;empty_result_callbacks&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="37b8e45b75945b9a2ed1c6840780034aeaa96def" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;full_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="7ba50a54ae872e46e392d945fcfe8882528f779d" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;short_column_names&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="5cf9a92ecc51fe417c6554bfdf564ab70b6793e5" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_aggregate_count&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="e04a1191ffe57ae4dc80fdf0b0d1302374a5223c" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_expired&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_expired&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="d4ae465dac3d471fb929f18f6459bc6fcd0ad5ac" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_global_recover&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c152f165bf4d682834190453559ca4079d4e3e8f" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_memory_alarm&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="213d566c65b6e979c0b12b5cb2c6d769f7e68036" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_soft_heap_limit&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="650653e2136ca438507f86226e9dd600546df2c7" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_thread_cleanup&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="9810cb85410d21ed25bad43b513e5d44434fc79b" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;sqlite3_transfer_bindings&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="c56e6ca2d9c7c42057a3d4b7225bd064062059b2" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;temp_store_directory&amp;sup1;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="156219115afff08d45c71a04e60351afa6d72952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; An R*Tree index does not normally provide the exact answer but merely reduces the set of potential answers from millions to dozens.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; R * Tree 지수는 일반적으로 정확한 답을 제공하지는 않지만 잠재적 인 대답 세트를 수백만에서 수십 개로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6049fd8bb72e0e6f1e8d8a417d9fe8b5a790ff5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Changes to compile-time options have the potential to affect makefiles in projects that do customized builds of SQLite. These changes should have zero impact on application code and for most projects which use a standard, default build of SQLite.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 컴파일 타임 옵션을 변경하면 사용자 정의 된 SQLite 빌드를 수행하는 프로젝트의 makefile에 영향을 줄 수 있습니다. 이러한 변경 사항은 응용 프로그램 코드와 표준 기본 SQLite 빌드를 사용하는 대부분의 프로젝트에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fe0585022e152f67097fdd4ed2411a232e49da4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The change to the way NULL values are handled by the IN and NOT IN operators is technically a bug fix, not a design change. However, maintainers should check to ensure that applications do not depend on the older, buggy behavior prior to upgrading to version 3.6.0.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; IN 및 NOT IN 연산자가 NULL 값을 처리하는 방식의 변경은 기술적으로 디자인 변경이 아니라 버그 수정입니다. 그러나 관리자는 버전 3.6.0으로 업그레이드하기 전에 응용 프로그램이 이전의 버그가있는 동작에 의존하지 않는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac582c2b4e7dacb497b4397bfa98eb62970fbb75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The incompatible changes in the SQLite operating-system interface for version 3.6.0 only affect the rare applications that make use of the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface or that supply an application-defined &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementation&lt;/a&gt; or that make use of other obscure compile-time options. The changes introduced by SQLite version 3.6.0 will have zero impact on the vast majority of SQLite applications that use the built-in interfaces to Unix, Windows, and OS/2 and that use the standard build configuration.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 버전 3.6.0의 SQLite 운영 체제 인터페이스에서 호환되지 않는 변경 사항은 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 인터페이스를 사용하거나 응용 프로그램 정의 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;뮤텍스 구현을 제공&lt;/a&gt; 하거나 다른 모호한 컴파일을 사용 하는 드문 응용 프로그램에만 영향을줍니다. 시간 옵션. SQLite 버전 3.6.0에서 도입 된 변경 사항은 Unix, Windows 및 OS / 2에 대한 내장 인터페이스를 사용하고 표준 빌드 구성을 사용하는 대다수의 SQLite 응용 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc0502f968c401bb51d275b3d308a8f8dcc412b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Points:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키 포인트:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="e3be666c416d3eeb09cb76c7b7abf3ac3e2ab55d" translate="yes" xml:space="preserve">
          <source>=0).</source>
          <target state="translated">=0).</target>
        </trans-unit>
        <trans-unit id="0f8eebb6cdfbace0c569728246016f04641f12f9" translate="yes" xml:space="preserve">
          <source>=1 and</source>
          <target state="translated">= 1과</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="3611d993bcfe075143e56843e7c942308dbe016c" translate="yes" xml:space="preserve">
          <source>?NNN</source>
          <target state="translated">?NNN</target>
        </trans-unit>
        <trans-unit id="1a2a6f3e69a4dab4720c5d9a3aae1f202d725e39" translate="yes" xml:space="preserve">
          <source>@VVV</source>
          <target state="translated">@VVV</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="83c828fc11c0e93226c89266f2e8a91c52ebb360" translate="yes" xml:space="preserve">
          <source>A &quot;CREATE TABLE ... AS SELECT&quot; statement creates and populates a database table based on the results of a SELECT statement. The table has the same number of columns as the rows returned by the SELECT statement. The name of each column is the same as the name of the corresponding column in the result set of the SELECT statement. The declared type of each column is determined by the &lt;a href=&quot;datatype3#expraff&quot;&gt;expression affinity&lt;/a&gt; of the corresponding expression in the result set of the SELECT statement, as follows:</source>
          <target state="translated">&quot;CREATE TABLE ... AS SELECT&quot;문은 SELECT 문의 결과에 따라 데이터베이스 테이블을 작성하고 채 웁니다. 테이블은 SELECT 문이 리턴 한 행과 동일한 수의 열을 갖습니다. 각 열의 이름은 SELECT 문의 결과 집합에있는 해당 열의 이름과 동일합니다. 각 열의 선언 된 유형은 다음과 같이 SELECT 문의 결과 세트에서 해당 표현식 의 &lt;a href=&quot;datatype3#expraff&quot;&gt;표현식 선호도&lt;/a&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1591a1617a12bcdebc03ff048dd0aaab529e900a" translate="yes" xml:space="preserve">
          <source>A &quot;long int&quot; or &quot;long unsigned int&quot;. Also 32-bits on all modern systems.</source>
          <target state="translated">&quot;long int&quot;또는 &quot;long unsigned int&quot;입니다. 모든 최신 시스템에서도 32 비트입니다.</target>
        </trans-unit>
        <trans-unit id="7f3cd818abaaa9a0e6005a308275969363d99be5" translate="yes" xml:space="preserve">
          <source>A &quot;long long int&quot; or &quot;long long unsigned&quot; or an &quot;sqlite3_int64&quot; or &quot;sqlite3_uint64&quot; value. These are 64-bit integers on all modern systems.</source>
          <target state="translated">&quot;long long int&quot;또는 &quot;long long unsigned&quot;또는 &quot;sqlite3_int64&quot;또는 &quot;sqlite3_uint64&quot;값 이들은 모든 최신 시스템에서 64 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7f83dc95438f0748d2d21836359d9d250a9cf519" translate="yes" xml:space="preserve">
          <source>A &quot;row value&quot; is an ordered list of two or more scalar values. In other words, a &quot;row value&quot; is a vector.</source>
          <target state="translated">&quot;행 값&quot;은 둘 이상의 스칼라 값으로 정렬 된 목록입니다. 즉, &quot;행 값&quot;은 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="283fddadbd97aab80b3f5c004c94712b610008ef" translate="yes" xml:space="preserve">
          <source>A &quot;rowid table&quot; is any table in an SQLite schema that</source>
          <target state="translated">&quot;행 테이블&quot;은 SQLite 스키마의 모든 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="82ef35610d000dac934111c06adc58ba665e4eea" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; is a single number, string, BLOB or NULL. Sometimes the qualified name &quot;scalar value&quot; is used to emphasize that only a single quantity is involved.</source>
          <target state="translated">&quot;값&quot;은 단일 숫자, 문자열, BLOB 또는 NULL입니다. 때때로 한정된 이름 &quot;scalar value&quot;는 단일 수량 만 관련되어 있음을 강조하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e595cea14982c806deb1a68df267f727d390b83d" translate="yes" xml:space="preserve">
          <source>A &quot;variable&quot; or &quot;parameter&quot; token specifies a placeholder in the expression for a value that is filled in at runtime using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; family of C/C++ interfaces. Parameters can take several forms:</source>
          <target state="translated">&quot;variable&quot;또는 &quot;parameter&quot;토큰은 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; C / C ++ 인터페이스 제품군을 사용하여 런타임에 채워지는 값에 대한 표현식에서 플레이스 홀더를 지정합니다 . 매개 변수는 여러 가지 형태를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0650b7b535494da46a67e89f0076bd1eb000f596" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian integer page number for the first page of the overflow page list - omitted if all payload fits on the b-tree page.</source>
          <target state="translated">오버 플로우 페이지 목록의 첫 번째 페이지에 대한 4 바이트 빅 엔디안 정수 페이지 번호-모든 페이로드가 b- 트리 페이지에 맞는 경우 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="457dd24244954b2ed62ddd2400a48d0f00613b7e" translate="yes" xml:space="preserve">
          <source>A 4-byte big-endian page number which is the left child pointer.</source>
          <target state="translated">왼쪽 자식 포인터 인 4 바이트 빅 엔디안 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="40fcda7469ad59852cc6bee2078ffd2e27a37099" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt; for each column is necessary in order to compute the order of text fields. SQLite defines three built-in collating functions:</source>
          <target state="translated">&lt;a href=&quot;datatype3#collation&quot;&gt;조합 함수&lt;/a&gt; 열마다 텍스트 필드의 순서를 계산하기 위해 필요하다. SQLite는 세 가지 기본 제공 조합 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0941f09d0d99d3f4e14cafccc32de96df6f4ca23" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; means to rewind the WAL and start adding new frames at the beginning. This occurs while appending new frames to a WAL that has &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and which has no locks on WAL_READ_LOCK(1) through WAL_READ_LOCK(4). The WAL_WRITE_LOCK is held.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL 리셋&lt;/a&gt; 월마트 되감기 처음에 새로운 프레임을 추가하려면 수단. WAL 갖는 새로운 프레임을 추가하는 동안 발생 &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame가&lt;/a&gt; 동일 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 및 WAL_READ_LOCK (4)를 통해 WAL_READ_LOCK (1)에는 잠금을 갖지 않는. WAL_WRITE_LOCK이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d00aa28b4ba172b3e360c196f89dfcfc325f153e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; interface</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;전체 텍스트 검색&lt;/a&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="27fbe703a2a9d7026510938d0ef6d0e90ee4db6f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;very obscure bug&lt;/a&gt; associated with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;or optimization&lt;/a&gt; was fixed.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/info/80ba201079&quot;&gt;매우 모호한 버그&lt;/a&gt; 과 관련된 &lt;a href=&quot;optoverview#or_opt&quot;&gt;또는 최적화가&lt;/a&gt; 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c246c5420b674d2441ed9c3d37319384c74b2e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; command operates the same whether or not &lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;foreign key constraints are enabled&lt;/a&gt;. The parent key definitions of foreign key constraints are not checked when a table is created. There is nothing stopping the user from creating a foreign key definition that refers to a parent table that does not exist, or to parent key columns that do not exist or are not collectively bound by a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">A는 &lt;a href=&quot;lang_createtable&quot;&gt;표 CREATE&lt;/a&gt; 명령 여부 같은 동작 &lt;a href=&quot;foreignkeys#fk_enable&quot;&gt;외래 키 제약 조건을 사용할 수 있습니다&lt;/a&gt; . 외래 키 제약 조건의 부모 키 정의는 테이블을 만들 때 확인되지 않습니다. 존재하지 않는 부모 테이블 또는 존재하지 않거나 PRIMARY KEY 또는 UNIQUE 제약 조건에 의해 집합 적으로 바인딩되지 않은 부모 키 열을 참조하는 외래 키 정의를 만드는 것을 사용자가 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e29b640b6e66681a005ec711b53b3e91c43098d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; may now reference undefined tables and functions when initially created. Missing tables and functions are reported when the VIEW is used in a query.</source>
          <target state="translated">&lt;a href=&quot;lang_createview&quot;&gt;보기는&lt;/a&gt; 처음 만들 때 이제 정의되지 않은 테이블과 기능을 참조 할 수있다. VIEW가 쿼리에 사용될 때 누락 된 테이블과 함수가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="84a46b4de837835c04612d05bdcd4565ff372f5f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoint&lt;/a&gt; transaction may be RELEASEd while the database is in a state that does not satisfy a deferred foreign key constraint. A transaction savepoint (a non-nested savepoint that was opened while there was not currently an open transaction), on the other hand, is subject to the same restrictions as a COMMIT - attempting to RELEASE it while the database is in such a state will fail.</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;중첩 된 세이브 포인트&lt;/a&gt; 데이터베이스가 연기 외래 키 제약 조건을 만족하지 않는 상태에있는 동안 트랜잭션이 해제 될 수 있습니다. 반면에 트랜잭션 저장 점 (현재 열려있는 트랜잭션이없는 동안 열린 중첩되지 않은 저장 점)에는 COMMIT와 동일한 제한이 적용됩니다. 데이터베이스가 이러한 상태에있는 동안이를 해제하려고하면 불합격.</target>
        </trans-unit>
        <trans-unit id="5ac241bd5950cee76dd1c229b208c7ae5eeaa8f2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement enclosed in parentheses is a subquery. All types of SELECT statement, including aggregate and compound SELECT queries (queries with keywords like UNION or EXCEPT) are allowed as scalar subqueries. The value of a subquery expression is the first row of the result from the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The value of a subquery expression is NULL if the enclosed &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement returns no rows.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 괄호 안에 문은 하위 쿼리입니다. 집계 및 복합 SELECT 쿼리 (UNION 또는 EXCEPT와 같은 키워드가 포함 된 쿼리)를 포함한 모든 유형의 SELECT 문은 스칼라 하위 쿼리로 허용됩니다. 부속 조회 표현식의 값은 동봉 된 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과의 첫 번째 행입니다 . 부속 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 행을 리턴하지 않으면 부속 조회 표현식의 값은 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="20f43c4aca8f02e6e0cae74a1bfed1c05ee2754b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement used as either a scalar subquery or as the right-hand operand of an IN, NOT IN or EXISTS expression may contain references to columns in the outer query. Such a subquery is known as a correlated subquery. A correlated subquery is reevaluated each time its result is required. An uncorrelated subquery is evaluated only once and the result reused as necessary.</source>
          <target state="translated">스칼라 서브 쿼리 또는 IN, NOT IN 또는 EXISTS 표현식의 오른쪽 피연산자로 사용 된 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문은 외부 쿼리의 열에 대한 참조를 포함 할 수 있습니다. 이러한 하위 쿼리를 상관 하위 쿼리라고합니다. 상관 서브 쿼리는 결과가 필요할 때마다 재평가됩니다. 상관되지 않은 하위 쿼리는 한 번만 평가되며 결과는 필요에 따라 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="024807a5ea9e932cf26bbf315bdeb3b063751ec8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause can be the first element in a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; that uses a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause, but a &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; that consists of just a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause cannot be preceded by a &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES의&lt;/a&gt; 절은 첫 번째 요소가 될 수있는 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물을 선택하는&lt;/a&gt; 것을 이용하는 &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; 절 있지만 &lt;a href=&quot;lang_select#simpleselect&quot;&gt;간단한 SELECT&lt;/a&gt; 단지 구성 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES의&lt;/a&gt; 절 앞에는 수없는 &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; 절.</target>
        </trans-unit>
        <trans-unit id="df491b521dc505e42bc3c6ecd099baa148547e6b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; can also be used to search and sort at the same time. Consider the following:</source>
          <target state="translated">&lt;a href=&quot;queryplanner#covidx&quot;&gt;포함하는 인덱스&lt;/a&gt; 도 동시에 검색하고 정렬 할 수 있습니다. 다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="871606b16605f413dc5599aac71b78fa3849a872" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an interface to an external storage or computation engine that appears to be a table but does not actually store information in the database file.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블은&lt;/a&gt; 테이블을 것으로 보인다 실제로 데이터베이스 파일에 정보를 저장하지 않는 외부 저장 또는 계산 엔진에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="df4e6c14456215b9d0962cb62cb7b05235ec1b11" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; is an object that presents an SQL table interface but which is not stored in the database file, at least not directly. The virtual table mechanism is a feature of SQLite that allows SQLite to access and manipulate resources other than bits in the database file using the powerful SQL query language.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블은&lt;/a&gt; SQL 테이블 인터페이스 만있는 선물이 적어도 직접적으로 데이터베이스 파일에 저장되지 않는다는 객체입니다. 가상 테이블 메커니즘은 SQLite가 강력한 SQL 쿼리 언어를 사용하여 데이터베이스 파일의 비트 이외의 리소스에 액세스하고 조작 할 수 있도록하는 SQLite의 기능입니다.</target>
        </trans-unit>
        <trans-unit id="68d8302bde332ff69849e87aae361fdd6eed88bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; in the FROM clause. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table. Additional information can be found in the &lt;a href=&quot;vtab#tabfunc2&quot;&gt;virtual table documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 포함 된 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 FROM 절에서 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 처럼 사용할 수 있습니다 . 테이블 반환 함수에 대한 인수는 가상 테이블의 HIDDEN 열에 대한 제약 조건이됩니다. 추가 정보는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;가상 테이블 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9a4d2f7abc06c64a3d373982c1067a695d076ac" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that contains &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; can be used like a table-valued function in the FROM clause of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The arguments to the table-valued function become constraints on the HIDDEN columns of the virtual table.</source>
          <target state="translated">&lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 포함 된 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 FROM 절에서 테이블 반환 함수처럼 사용할 수 있습니다 . 테이블 반환 함수에 대한 인수는 가상 테이블의 HIDDEN 열에 대한 제약 조건이됩니다.</target>
        </trans-unit>
        <trans-unit id="6f54a772ec3e29fda7795793266725eca1b672c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; containing one row for each &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; associated with an open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">열린 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 연관된 각 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에 대해 하나의 행을 포함 하는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="856349bba241130042131d7b4885683066e751c5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; for decomposing a JSON string.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; JSON 문자열을 분해.</target>
        </trans-unit>
        <trans-unit id="0582a0885ca700a90a04a8eff4c47df7102e8b08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning a sequence of increasing integers, modeled after the table-valued function by the same name in PostgreSQL.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 의 증가의 정수의 시퀀스를 돌려는 PostgreSQL의 동일한 이름 테이블 값 함수 본뜬.</target>
        </trans-unit>
        <trans-unit id="cb2741cf2cdf7ad64ce11cd345c855b98d1f85eb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; returning one row for each file in a selected file hierarchy of the host computer. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;.</source>
          <target state="translated">호스트 컴퓨터의 선택된 파일 계층에서 각 파일에 대해 하나의 행을 반환 하는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 입니다. 에 의해 사용 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 도움말을하면 구현 &lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="373d830be5eb15d2da2a61288dc21f7719b3437c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that allows a C-language array of integers, doubles, or strings to be used as table in a query.</source>
          <target state="translated">&lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 정수 배로, 또는 문자열 C 언어 배열을 허용하는 조회 테이블로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="c7e525a231144d654e7b02c354858c4739a1f24e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; which, in combination with a co-packaged &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; provides information on the number of system calls performed by SQLite.</source>
          <target state="translated">A &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; which, in combination with a co-packaged &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; provides information on the number of system calls performed by SQLite.</target>
        </trans-unit>
        <trans-unit id="1b6d070d5ecc711101d38eeaab3df0bef09ff2fd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; consists of a header followed by zero or more &quot;frames&quot;. Each frame records the revised content of a single page from the database file. All changes to the database are recorded by writing frames into the WAL. Transactions commit when a frame is written that contains a commit marker. A single WAL can and usually does record multiple transactions. Periodically, the content of the WAL is transferred back into the database file in an operation called a &quot;checkpoint&quot;.</source>
          <target state="translated">A &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; consists of a header followed by zero or more &quot;frames&quot;. Each frame records the revised content of a single page from the database file. All changes to the database are recorded by writing frames into the WAL. Transactions commit when a frame is written that contains a commit marker. A single WAL can and usually does record multiple transactions. Periodically, the content of the WAL is transferred back into the database file in an operation called a &quot;checkpoint&quot;.</target>
        </trans-unit>
        <trans-unit id="0a26bbd25ee7f100819f3c23deb01a412e2b8ae6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;clean page&lt;/i&gt;&lt;/b&gt; is one for which the cached data currently matches the contents of the corresponding page of the database file. The page has not been modified since it was loaded from the file.</source>
          <target state="translated">&lt;b&gt;&lt;i&gt;청소 페이지가&lt;/i&gt;&lt;/b&gt; 캐시 된 데이터가 현재 데이터베이스 파일의 해당 페이지의 내용과 일치하는 것입니다. 페이지가 파일에서로드 된 이후 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3149daa49a57f043076bca55d34c79bbf2a94c10" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;&lt;i&gt;dirty page&lt;/i&gt;&lt;/b&gt; is a</source>
          <target state="translated">&lt;b&gt;&lt;i&gt;더러운 페이지&lt;/i&gt;&lt;/b&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="a631580fd38df6770ba8186e0d9bd01ddb2b0586" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;CHECK&lt;/b&gt; constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="translated">&lt;b&gt;체크&lt;/b&gt; 제약 열 정의에 부착 또는 테이블 제약으로 지정 될 수있다. 실제로는 아무런 차이가 없습니다. 새 행이 테이블에 삽입되거나 기존 행이 업데이트 될 때마다 각 CHECK 제한 조건과 연관된 표현식이 평가되고 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; 과 동일한 방식으로 NUMERIC 값으로 캐스트됩니다 . 결과가 0 (정수 값 0 또는 실수 0.0)이면 제약 조건 위반이 발생한 것입니다. CHECK 표현식이 NULL 또는 0이 아닌 다른 값으로 평가되는 경우 제한 조건 위반이 아닙니다. CHECK 제약 조건의 식에 하위 쿼리가 포함되어 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b22b413028503aa499aa22dd5a425b910c462c65" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DELETE&lt;/b&gt;. A DELETE change represents a row, identified by its primary key values, to remove from a database table. The payload of a DELETE change consists of the values for all fields of the deleted row.</source>
          <target state="translated">&lt;b&gt;DELETE&lt;/b&gt; . DELETE 변경은 데이터베이스 키에서 제거 할 기본 키 값으로 식별되는 행을 나타냅니다. DELETE 변경의 페이로드는 삭제 된 행의 모든 ​​필드 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dc432bfd116ade86c9a957fa16cdde115d0191b7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;NOT NULL&lt;/b&gt; constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="translated">&lt;b&gt;NOT NULL의&lt;/b&gt; 제약뿐만 아니라 테이블 제약 조건으로 지정된 열 정의에 부착 될 수있다. 당연히 NOT NULL 제약 조건은 관련 열에 NULL 값이 포함되어 있지 않을 수 있음을 나타냅니다. 새 행을 삽입하거나 기존 행을 업데이트 할 때 열 값을 NULL로 설정하려고하면 제약 조건 위반이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdf1ca3328f33f13bfd67487e1be34ff9035a3f1" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;UNIQUE&lt;/b&gt; constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="translated">&lt;b&gt;고유의&lt;/b&gt; 제약 조건은 PRIMARY KEY 제약 조건과 유사 하나의 테이블에 UNIQUE 제약 조건의 수를 가질 수있다 것을 제외하고. 테이블의 각 UNIQUE 제약 조건에 대해 각 행에는 UNIQUE 제약 조건으로 식별되는 열의 고유 한 값 조합이 포함되어야합니다. UNIQUE 제약 조건을 위해 NULL 값은 다른 NULL을 포함하여 다른 모든 값과 다른 것으로 간주됩니다. 기본 키와 같이, UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건&lt;/a&gt; 절은 열 이름을 포함해야합니다 -에서 표현의 사용 &lt;a href=&quot;syntax/indexed-column&quot;&gt;인덱스 컬럼&lt;/a&gt; 고유의의 &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건이&lt;/a&gt; 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e32809ac84c6935c3f1d547f445c33b4edd8239b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;configuration option&lt;/b&gt; consists of an FTS5 bareword - the option name - followed by an &quot;=&quot; character, followed by the option value. The option value is specified using either a single FTS5 bareword or a string literal, again quoted in any manner acceptable to the SQLite core. For example:</source>
          <target state="translated">&lt;b&gt;구성 옵션은&lt;/b&gt; 옵션 이름 - -에 &quot;=&quot;문자 다음, 옵션 값 뒤에 FTS5의 bareword는 구성되어 있습니다. 옵션 값은 단일 FTS5 베어 워드 또는 문자열 리터럴을 사용하여 지정되며 SQLite 코어에 허용되는 방식으로 다시 인용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a32195c7a6fc427bc8287dc1bfc7fa1047963781" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;delete file&lt;/b&gt; operation (invoked by a call to the VFS xDelete() method) is assumed to be an atomic and durable operation.</source>
          <target state="translated">&lt;b&gt;파일 삭제&lt;/b&gt; 합니다 (VFS xDelete () 메소드의 호출에 의해 호출 된) 동작 원자 내구성 동작으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="81eb114ea2af4078474a1cbfc4dcbef58bf150be" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;write file&lt;/b&gt; operation modifies the contents of an existing file within the file-system. It may also increase the size of the file. The effects of a</source>
          <target state="translated">&lt;b&gt;쓰기 파일&lt;/b&gt; 작업은 파일 시스템 내에서 기존 파일의 내용을 수정합니다. 파일 크기가 커질 수도 있습니다. 의 효과</target>
        </trans-unit>
        <trans-unit id="837ab313b69fffe66bfeb6474a06eb42c1252970" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">sqlite3_blob_open 의해 참조 BLOB ()를 이용하여 판독 될 수있다 &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 인터페이스를 사용하여 수정 및 &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write을 ()&lt;/a&gt; . &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 은 USING 같은 테이블의 다른 행으로 이동할 수 &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스. 그러나,의 열, 테이블 또는 데이터베이스 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 후에는 변경할 수 없습니다 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 열립니다.</target>
        </trans-unit>
        <trans-unit id="ee0640d0645ccd75a4dc327263af24976feba6da" translate="yes" xml:space="preserve">
          <source>A BLOB referenced by sqlite3_blob_open() may be read using the &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface and modified by using &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;. The &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; can be moved to a different row of the same table using the &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface. However, the column, table, or database of a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; cannot be changed after the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is opened.</source>
          <target state="translated">sqlite3_blob_open 의해 참조 BLOB ()를 이용하여 판독 될 수있다 &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 인터페이스를 사용하여 수정 및 &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write을 ()&lt;/a&gt; . &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 은 USING 같은 테이블의 다른 행으로 이동할 수 &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스. 그러나,의 열, 테이블 또는 데이터베이스 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 후에는 변경할 수 없습니다 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 열립니다.</target>
        </trans-unit>
        <trans-unit id="13017a10bf35a23815a31249ff53b230bf8d7de4" translate="yes" xml:space="preserve">
          <source>A C99 compiler such as GCC (including MinGW variants for Windows), Clang, or MSVC</source>
          <target state="translated">GCC (Windows 용 MinGW 변형 포함), Clang 또는 MSVC와 같은 C99 컴파일러</target>
        </trans-unit>
        <trans-unit id="e474401c2fb781e6f6b3a595d076e4ab1e391bd7" translate="yes" xml:space="preserve">
          <source>A CASE expression serves a role similar to IF-THEN-ELSE in other programming languages.</source>
          <target state="translated">CASE 표현식은 다른 프로그래밍 언어에서 IF-THEN-ELSE와 유사한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="6efc18580100345c76fd2798e95f8e107ce315e6" translate="yes" xml:space="preserve">
          <source>A CAST expression of the form &quot;CAST(</source>
          <target state="translated">&quot;CAST (</target>
        </trans-unit>
        <trans-unit id="691cb52a8521a0ce5d8225252c59ceffa19ac6f9" translate="yes" xml:space="preserve">
          <source>A CHECK constraint may be attached to a column definition or specified as a table constraint. In practice it makes no difference. Each time a new row is inserted into the table or an existing row is updated, the expression associated with each CHECK constraint is evaluated and cast to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred. If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation. The expression of a CHECK constraint may not contain a subquery.</source>
          <target state="translated">CHECK 제약 조건은 열 정의에 첨부되거나 테이블 제약 조건으로 지정 될 수 있습니다. 실제로는 차이가 없습니다. 새 행이 테이블에 삽입되거나 기존 행이 업데이트 될 때마다 각 CHECK 제약 조건과 연관된 표현식이 평가되고 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식&lt;/a&gt; 과 동일한 방식으로 NUMERIC 값으로 캐스트됩니다 . 결과가 0이면 (정수 값 0 또는 실수 값 0.0) 제약 조건 위반이 발생한 것입니다. CHECK식이 NULL 또는 0이 아닌 다른 값으로 평가되면 제약 조건 위반이 아닙니다. CHECK 제약 조건의 식에는 하위 쿼리가 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e31c615e2a94e5252f4b80b762cba6c0141f5cde" translate="yes" xml:space="preserve">
          <source>A COLLATE operator has the same affinity as its left-hand side operand.</source>
          <target state="translated">COLLATE 연산자는 왼쪽 피연산자와 동일한 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="636b65c339e5b4cff4c6abf3acf46d5d5c4067ad" translate="yes" xml:space="preserve">
          <source>A Frame object (Used by &lt;a href=&quot;opcode#subprog&quot;&gt;subprograms&lt;/a&gt; - see &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;)</source>
          <target state="translated">Frame 객체 ( &lt;a href=&quot;opcode#subprog&quot;&gt;서브 프로그램에서 사용&lt;/a&gt; - &lt;a href=&quot;opcode#Program&quot;&gt;프로그램&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="5dd1dbb7ef5708d18278d3388bedd2577e0b3815" translate="yes" xml:space="preserve">
          <source>A Handle To An Open BLOB</source>
          <target state="translated">열린 BLOB에 대한 핸들</target>
        </trans-unit>
        <trans-unit id="5c5c40156ee6de3eca7fbc6151e6b7fa931030d3" translate="yes" xml:space="preserve">
          <source>A NOT NULL constraint may only be attached to a column definition, not specified as a table constraint. Not surprisingly, a NOT NULL constraint dictates that the associated column may not contain a NULL value. Attempting to set the column value to NULL when inserting a new row or updating an existing one causes a constraint violation.</source>
          <target state="translated">NOT NULL 제약 조건은 테이블 제약 조건으로 지정되지 않고 열 정의에만 연결할 수 있습니다. 당연히 NOT NULL 제약 조건은 관련 열에 NULL 값이 포함되지 않을 수 있음을 나타냅니다. 새 행을 삽입하거나 기존 행을 업데이트 할 때 열 값을 NULL로 설정하려고하면 제약 조건 위반이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3401d49e10d9d0dae1ba0bfad0af249daa8b1e6a" translate="yes" xml:space="preserve">
          <source>A NULL result is considered untrue when evaluating WHEN terms.</source>
          <target state="translated">WHEN 항을 평가할 때 NULL 결과는 참이 아닌 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e08d53bb50141ecc1637476fc883985d9f9ebb" translate="yes" xml:space="preserve">
          <source>A NULL value</source>
          <target state="translated">NULL 값</target>
        </trans-unit>
        <trans-unit id="bffde3dc2b5165819167f5c21c867d724ac37b28" translate="yes" xml:space="preserve">
          <source>A NULL value is not changed by this routine. It remains NULL.</source>
          <target state="translated">이 루틴은 NULL 값을 변경하지 않습니다. NULL로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="e254962b9e0cb1aea3bfd54acadf87214effe474" translate="yes" xml:space="preserve">
          <source>A PENDING lock means that the process holding the lock wants to write to the database as soon as possible and is just waiting on all current SHARED locks to clear so that it can get an EXCLUSIVE lock. No new SHARED locks are permitted against the database if a PENDING lock is active, though existing SHARED locks are allowed to continue.</source>
          <target state="translated">PENDING 잠금은 잠금을 보유한 프로세스가 가능한 빨리 데이터베이스에 쓰려고하고 독점 잠금을 얻을 수 있도록 현재 공유 된 모든 잠금을 지울 때까지 대기하고 있음을 의미합니다. PENDING 잠금이 활성화 된 경우 기존 SHARED 잠금을 계속할 수 있지만 데이터베이스에 대해 새로운 SHARED 잠금이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="792513b3669ee7042166df65b3b518052dfec139" translate="yes" xml:space="preserve">
          <source>A RESERVED lock means that the process is planning on writing to the database file at some point in the future but that it is currently just reading from the file. Only a single RESERVED lock may be active at one time, though multiple SHARED locks can coexist with a single RESERVED lock. RESERVED differs from PENDING in that new SHARED locks can be acquired while there is a RESERVED lock.</source>
          <target state="translated">예약 된 잠금은 프로세스가 나중에 특정 시점에 데이터베이스 파일에 쓰려고 계획하고 있지만 현재는 파일에서 읽기만한다는 것을 의미합니다. 한 번에 하나의 RESERVED 잠금 만 활성화 될 수 있지만 여러 개의 SHARED 잠금이 단일 RESERVED 잠금과 공존 할 수 있습니다. 예약 된 잠금이있는 동안 새 공유 잠금을 획득 할 수 있다는 점에서 예약 됨과 보류 중이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7573b1578e511f894b8024c7cc3d97b302451de" translate="yes" xml:space="preserve">
          <source>A RowSet object (See the &lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt;, &lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt;, and &lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt; opcodes)</source>
          <target state="translated">RowSet 객체 ( &lt;a href=&quot;opcode#RowSetAdd&quot;&gt;RowSetAdd&lt;/a&gt; , &lt;a href=&quot;opcode#RowSetRead&quot;&gt;RowSetRead&lt;/a&gt; 및 &lt;a href=&quot;opcode#RowSetTest&quot;&gt;RowSetTest&lt;/a&gt; opcode 참조)</target>
        </trans-unit>
        <trans-unit id="7145fed841f2e927e89061340853d861304c9e1a" translate="yes" xml:space="preserve">
          <source>A Slightly More Complex Query</source>
          <target state="translated">약간 더 복잡한 쿼리</target>
        </trans-unit>
        <trans-unit id="be9ffde27510374ea69b59f34f53d3d90e8acc69" translate="yes" xml:space="preserve">
          <source>A TEXT value is less than a BLOB value. When two TEXT values are compared an appropriate collating sequence is used to determine the result.</source>
          <target state="translated">TEXT 값이 BLOB 값보다 작습니다. 두 개의 TEXT 값을 비교하면 적절한 조합 순서가 결과를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46f405c1f7939c335f90c63056ef77e55a911955" translate="yes" xml:space="preserve">
          <source>A Template For SELECT Programs</source>
          <target state="translated">SELECT 프로그램을위한 템플릿</target>
        </trans-unit>
        <trans-unit id="d9fc87b4657ba9032bc3c9439eec37292a4b8792" translate="yes" xml:space="preserve">
          <source>A UNIQUE constraint is similar to a PRIMARY KEY constraint, except that a single table may have any number of UNIQUE constraints. For each UNIQUE constraint on the table, each row must contain a unique combination of values in the columns identified by the UNIQUE constraint. For the purposes of UNIQUE constraints, NULL values are considered distinct from all other values, including other NULLs. As with PRIMARY KEYs, a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; clause must contain only column names &amp;mdash; the use of expressions in an &lt;a href=&quot;syntax/indexed-column&quot;&gt;indexed-column&lt;/a&gt; of a UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;table-constraint&lt;/a&gt; is not supported.</source>
          <target state="translated">UNIQUE 제약 조건은 단일 테이블에 여러 UNIQUE 제약 조건이있을 수 있다는 점을 제외하면 PRIMARY KEY 제약 조건과 유사합니다. 테이블의 각 UNIQUE 제약 조건에 대해 각 행에는 UNIQUE 제약 조건으로 식별되는 열에 고유 한 값 조합이 포함되어야합니다. UNIQUE 제약 조건을 위해 NULL 값은 다른 NULL을 포함하여 다른 모든 값과 구별되는 것으로 간주됩니다. 기본 키와 같이, UNIQUE &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건&lt;/a&gt; 절은 열 이름을 포함해야합니다 -에서 표현의 사용 &lt;a href=&quot;syntax/indexed-column&quot;&gt;인덱스 컬럼&lt;/a&gt; 고유의의 &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건이&lt;/a&gt; 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a236f9f7962be97b127c37048fd412e1478ca675" translate="yes" xml:space="preserve">
          <source>A URI filename can optionally be followed by a query string. The query string consists of text following the first &quot;&lt;code&gt;?&lt;/code&gt;&quot; character but excluding the optional fragment that begins with &quot;&lt;code&gt;#&lt;/code&gt;&quot;. The query string is divided into key/value pairs. We usually refer to these key/value pairs as &quot;query parameters&quot;. Key/value pairs are separated by a single &quot;&lt;code&gt;&amp;amp;&lt;/code&gt;&quot; character. The key comes first and is separated from the value by a single &quot;&lt;code&gt;=&lt;/code&gt;&quot; character. Both key and value may contain &lt;b&gt;%HH&lt;/b&gt; escape sequences.</source>
          <target state="translated">URI 파일 이름 뒤에 선택적으로 쿼리 문자열이 올 수 있습니다. 쿼리 문자열은 첫 번째 &quot; &lt;code&gt;?&lt;/code&gt; &quot;문자 다음에 나오는 텍스트로 구성 되지만 &quot; &lt;code&gt;#&lt;/code&gt; &quot;으로 시작하는 선택적 부분은 제외됩니다 . 쿼리 문자열은 키 / 값 쌍으로 나뉩니다. 일반적으로 이러한 키 / 값 쌍을 &quot;쿼리 매개 변수&quot;라고합니다. 키 / 값 쌍은 단일 &quot; &lt;code&gt;&amp;amp;&lt;/code&gt; &quot;문자 로 구분됩니다 . 키가 먼저 나오고 단일 &quot; &lt;code&gt;=&lt;/code&gt; &quot;문자로 값과 구분됩니다 . 키와 값 모두 &lt;b&gt;% HH&lt;/b&gt; 이스케이프 시퀀스를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99cb44555e9b0216321b2979e33a8e1ad8600bba" translate="yes" xml:space="preserve">
          <source>A UTF-16 byte-order-mark (BOM) is embedded at the beginning of an SQL string literal value inserted into an FTS3 table. For example:</source>
          <target state="translated">UTF-16 BOM (byte-order-mark)은 FTS3 테이블에 삽입 된 SQL 문자열 리터럴 값의 시작 부분에 포함됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b929656e7ccea842d99a6cdd674c24cfe9ebde24" translate="yes" xml:space="preserve">
          <source>A VACUUM will fail if there is an open transaction on the database connection that is attempting to run the VACUUM. Unfinalized SQL statements typically hold a read transaction open, so the VACUUM might fail if there are unfinalized SQL statements on the same connection. VACUUM (but not VACUUM INTO) is a write operation and so if another database connection is holding a lock that prevents writes, then the VACUUM will fail.</source>
          <target state="translated">VACUUM을 실행하려는 데이터베이스 연결에 열린 트랜잭션이 있으면 VACUUM이 실패합니다. 완료되지 않은 SQL 문은 일반적으로 읽기 트랜잭션을 열린 상태로 유지하므로 동일한 연결에 완료되지 않은 SQL 문이 있으면 VACUUM이 실패 할 수 있습니다. VACUUM (VACUUM INTO 아님)은 쓰기 작업이므로 다른 데이터베이스 연결이 쓰기를 방지하는 잠금을 보유하고 있으면 VACUUM이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4b3d695cfd113fe761861c75383b2e044c2e7e2b" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;.</source>
          <target state="translated">VALUES 절 뒤에 &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT을&lt;/a&gt; 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7ab21b8d4d0b0af0b5e16d3d9e8b9adc5cafa097" translate="yes" xml:space="preserve">
          <source>A VALUES clause cannot be followed by &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;.</source>
          <target state="translated">VALUES 절 뒤에 &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY가 올&lt;/a&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="05d95a064571927a9a88c570d25a1e13033bf432" translate="yes" xml:space="preserve">
          <source>A VDBE program begins execution on instruction 0 and continues with successive instructions until it either (1) encounters a fatal error, (2) executes a Halt instruction, or (3) advances the program counter past the last instruction of the program. When the VDBE completes execution, all open database cursors are closed, all memory is freed, and everything is popped from the stack. So there are never any worries about memory leaks or undeallocated resources.</source>
          <target state="translated">VDBE 프로그램은 명령 0에서 실행을 시작하고 (1) 치명적인 오류가 발생하거나 (2) 중지 명령을 실행하거나 (3) 프로그램의 마지막 명령을지나 프로그램 카운터를 진행할 때까지 연속 명령으로 계속 진행됩니다. VDBE가 실행을 완료하면 열려있는 모든 데이터베이스 커서가 닫히고 모든 메모리가 해제되고 모든 것이 스택에서 팝됩니다. 따라서 메모리 누수 나 할당되지 않은 리소스에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0432168769d5fe51afb6dbaedceaf1d86ce22932" translate="yes" xml:space="preserve">
          <source>A VFS object is an instance of the following structure:</source>
          <target state="translated">VFS 객체는 다음 구조의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="ebb27bb2698737a1c139441a44f3243078e096d2" translate="yes" xml:space="preserve">
          <source>A WHERE-clause term that uses the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator can sometimes be used with an index to do a range search, almost as if the LIKE or GLOB were an alternative to a &lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt; operator. There are many conditions on this optimization:</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 를 사용하는 WHERE 절 은 때때로 LIKE 또는 GLOB가 &lt;a href=&quot;lang_expr#between&quot;&gt;BETWEEN&lt;/a&gt; 연산자 의 대안 인 것처럼 인덱스를 사용하여 범위 검색을 수행 할 수 있습니다. 이 최적화에는 많은 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4f80b113ccea127e4d3021f3a4f02819b934ae" translate="yes" xml:space="preserve">
          <source>A WITH clause can contain ordinary common table expressions even if it includes the RECURSIVE keyword. The use of RECURSIVE does not force common table expressions to be recursive.</source>
          <target state="translated">WITH 절은 RECURSIVE 키워드를 포함하더라도 일반적인 공통 테이블 표현식을 포함 할 수 있습니다. RECURSIVE를 사용한다고해서 공통 테이블 표현식을 재귀 적으로 강제하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f55340617c249beb5aa9dcbec3b3a452cd918cec" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is a table that uses a &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;Clustered Index&lt;/a&gt; as the primary key.</source>
          <target state="translated">WITHOUT ROWID 테이블은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Clustered&quot;&gt;클러스터형 인덱스&lt;/a&gt; 를 기본 키로 사용하는 테이블입니다 .</target>
        </trans-unit>
        <trans-unit id="fd8fd2213389a0089cdcbfb615d2045c57a83ef1" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table is an optimization that can reduce storage and processing requirements.</source>
          <target state="translated">WITHOUT ROWID 테이블은 스토리지 및 처리 요구 사항을 줄일 수있는 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="bfd83295099a678d051eac126141e86eda45f403" translate="yes" xml:space="preserve">
          <source>A WITHOUT ROWID table uses a different data design for the equivalent table.</source>
          <target state="translated">WITHOUT ROWID 테이블은 동등한 테이블에 대해 다른 데이터 디자인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd77ad55fd4a01dbb8f0524dc072785f80da4f86" translate="yes" xml:space="preserve">
          <source>A ZIP archive appears to be a database containing a single table with the following schema:</source>
          <target state="translated">ZIP 아카이브는 다음 스키마가있는 단일 테이블을 포함하는 데이터베이스로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8671aa0f63652c459215ac815d19beddc15e8e03" translate="yes" xml:space="preserve">
          <source>A ZIP archive is basically a key/value database, optimized for the case of write-once/read-many and for a relatively small number of distinct keys (a few hundred to a few thousand) each with a large BLOB as its value. A ZIP archive can be viewed as a &quot;pile-of-files&quot; database. This works, but it has some shortcomings relative to an SQLite database, as follows:</source>
          <target state="translated">ZIP 아카이브는 기본적으로 키 / 값 데이터베이스이며, 1 회 기록 / 읽기 다수의 경우와 각각 큰 BLOB를 값으로하는 비교적 적은 수의 개별 키 (수백에서 수천까지)에 최적화되어 있습니다. ZIP 아카이브는 &quot;파일 파일&quot;데이터베이스로 볼 수 있습니다. 이것은 작동하지만 다음과 같이 SQLite 데이터베이스와 관련하여 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b75515041a194398c4ef9c7f4df42ebbf1ae1c" translate="yes" xml:space="preserve">
          <source>A b-tree page</source>
          <target state="translated">b- 트리 페이지</target>
        </trans-unit>
        <trans-unit id="78e4a5662f4ab95c05c9b1089cf8d552e985bac1" translate="yes" xml:space="preserve">
          <source>A b-tree page is divided into regions in the following order:</source>
          <target state="translated">b- 트리 페이지는 다음 순서로 영역으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="50e24d6d35682efd44eaa4aca8795ead18d76998" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_schema table is always a table b-tree and always has a root page of 1. The sqlite_schema table contains the root page number for every other table and index in the database file.</source>
          <target state="translated">b- 트리 페이지는 테이블 b- 트리 페이지 또는 인덱스 b- 트리 페이지입니다. 각 완전한 b- 트리 내의 모든 페이지는 동일한 유형 (테이블 또는 인덱스)입니다. &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 와 같은 시스템 테이블을 포함하여 데이터베이스 스키마의 각 rowid 테이블에 대한 데이터베이스 파일에는 하나의 테이블 B- 트리가 있습니다. 고유성 제약 조건에 의해 생성 된 암시 적 인덱스를 포함하여 스키마의 각 인덱스에 대해 데이터베이스 파일에 하나의 인덱스 B- 트리가 있습니다. &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 과 관련된 B- 트리가 없습니다 . 특정 가상 테이블 구현은 스토리지 에 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 사용할 수 있지만 이러한 새도우 테이블은 데이터베이스 스키마에 별도의 항목을 갖습니다. &lt;a href=&quot;withoutrowid&quot;&gt;ROWID없이&lt;/a&gt;테이블은 테이블 B- 트리가 아닌 인덱스 B- 트리를 사용하므로 데이터베이스 파일에는 각 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에 대해 하나의 인덱스 B- 트리가 있습니다. sqlite_schema 테이블에 해당하는 b- 트리는 항상 테이블 b- 트리이며 항상 루트 페이지가 1입니다. sqlite_schema 테이블에는 데이터베이스 파일의 다른 모든 테이블과 인덱스에 대한 루트 페이지 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="63a9edcac9a730619e0cfe51d4bfd7d8720cb6a9" translate="yes" xml:space="preserve">
          <source>A b-tree page is either a table b-tree page or an index b-tree page. All pages within each complete b-tree are of the same type: either table or index. There is one table b-trees in the database file for each rowid table in the database schema, including system tables such as sqlite_master. There is one index b-tree in the database file for each index in the schema, including implied indexes created by uniqueness constraints. There are no b-trees associated with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Specific virtual table implementations might make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; for storage, but those shadow tables will have separate entries in the database schema. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables use index b-trees rather than a table b-trees, so there is one index b-tree in the database file for each &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The b-tree corresponding to the sqlite_master table is always a table b-tree and always has a root page of 1. The sqlite_master table contains the root page number for every other table and index in the database file.</source>
          <target state="translated">b- 트리 페이지는 테이블 b- 트리 페이지 또는 인덱스 b- 트리 페이지입니다. 각각의 완전한 b- 트리 내의 모든 페이지는 동일한 유형 (테이블 또는 인덱스)입니다. sqlite_master와 같은 시스템 테이블을 포함하여 데이터베이스 스키마의 각 rowid 테이블에 대한 데이터베이스 파일에는 하나의 테이블 b- 트리가 있습니다. 고유성 제한 조건에 의해 작성된 내재 된 색인을 포함하여 스키마의 각 색인에 대해 데이터베이스 파일에 하나의 색인 b- 트리가 있습니다. &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 과 연관된 b- 트리가 없습니다 . 특정 가상 테이블 구현은 스토리지 에 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; 을 사용할 수 있지만 해당 새도우 테이블은 데이터베이스 스키마에서 별도의 항목을 갖습니다. &lt;a href=&quot;withoutrowid&quot;&gt;ROWID가없는&lt;/a&gt; 테이블은 테이블 b- 트리 대신 인덱스 b- 트리를 사용하므로 데이터베이스 파일에는 각각에 대해 하나의 인덱스 b- 트리가 있습니다.&lt;a href=&quot;withoutrowid&quot;&gt;ROWID&lt;/a&gt; 테이블 없이 . sqlite_master 테이블에 해당하는 b- 트리는 항상 테이블 b- 트리이며 항상 루트 페이지 1입니다. sqlite_master 테이블에는 데이터베이스 파일의 다른 모든 테이블 및 인덱스에 대한 루트 페이지 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e8872d8050defbccbb334917b38d2ca8e1564dc7" translate="yes" xml:space="preserve">
          <source>A b-tree page is either an interior page or a leaf page. A leaf page contains keys and in the case of a table b-tree each key has associated data. An interior page contains K keys together with K+1 pointers to child b-tree pages. A &quot;pointer&quot; in an interior b-tree page is just the 31-bit integer page number of the child page.</source>
          <target state="translated">b- 트리 페이지는 내부 페이지 또는 리프 페이지입니다. 리프 페이지에는 키가 포함되며 테이블 b- 트리의 경우 각 키에 연결된 데이터가 있습니다. 내부 페이지에는 하위 b- 트리 페이지에 대한 K + 1 포인터와 함께 K 키가 포함되어 있습니다. 내부 b- 트리 페이지의 &quot;포인터&quot;는 자식 페이지의 31 비트 정수 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="3cfdea8b36cb23cd0493dd048fd3164b70e3686a" translate="yes" xml:space="preserve">
          <source>A b-tree root page. The page number should be zero.</source>
          <target state="translated">b- 트리 루트 페이지. 페이지 번호는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="928af6fa4be08c1c19873c470bbd5a2625ae1f46" translate="yes" xml:space="preserve">
          <source>A better user experience</source>
          <target state="translated">더 나은 사용자 경험</target>
        </trans-unit>
        <trans-unit id="e7bff53ba8dac51c9265761e2c2a4ff11158671e" translate="yes" xml:space="preserve">
          <source>A bug in SQLite versions prior to 3.6.0 (2008-07-16) caused the database to be reported as corrupt if any of the last 6 entries in the freelist trunk page array contained non-zero values. Newer versions of SQLite do not have this problem. However, newer versions of SQLite still avoid using the last six entries in the freelist trunk page array in order that database files created by newer versions of SQLite can be read by older versions of SQLite.</source>
          <target state="translated">프리리스트 트렁크 페이지 배열의 마지막 6 개 항목 중 하나가 0이 아닌 값을 포함하는 경우 3.6.0 (2008-07-16) 이전의 SQLite 버전의 버그로 인해 데이터베이스가 손상된 것으로보고되었습니다. 최신 버전의 SQLite에는이 문제가 없습니다. 그러나 최신 버전의 SQLite는 최신 버전의 SQLite로 작성된 데이터베이스 파일을 이전 버전의 SQLite에서 읽을 수 있도록 여전히 프리리스트 트렁크 페이지 배열에서 마지막 6 개의 항목을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89c8d4cd9f6ee835f0aa8d6326cf3bfa8b9da543" translate="yes" xml:space="preserve">
          <source>A build of the &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; requires three source files:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; 빌드 에는 세 개의 소스 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df3827a0612890cae9712a71ec1095000e1430ec" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">사용중인 핸들러는 사용중인 핸들러 를 호출 한 데이터베이스 연결 또는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 닫아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a3ac4c495afe83c385509d9e3c6a5a309fa36de0" translate="yes" xml:space="preserve">
          <source>A busy handler must not close the database connection or &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that invoked the busy handler.</source>
          <target state="translated">사용중인 핸들러는 사용중인 핸들러 를 호출 한 데이터베이스 연결 또는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 닫아야 합니다.</target>
        </trans-unit>
        <trans-unit id="243759da16d869bd57d5e12d61c35e1be1f805d8" translate="yes" xml:space="preserve">
          <source>A bytecoded program in SQLite consists of one or more instructions. Each instruction has an opcode and five operands named P1, P2 P3, P4, and P5. The P1, P2, and P3 operands are 32-bit signed integers. These operands often refer to registers. For instructions that operate on b-tree cursors, the P1 operand is usually the cursor number. For jump instructions, P2 is usually the jump destination. P4 may be a 32-bit signed integer, a 64-bit signed integer, a 64-bit floating point value, a string literal, a Blob literal, a pointer to a collating sequence comparison function, or a pointer to the implementation of an application-defined SQL function, or various other things. P5 is an 16-bit unsigned integer normally used to hold flags. Bits of the P5 flag can sometimes affect the opcode in subtle ways. For example, if the SQLITE_NULLEQ (0x0080) bit of the P5 operand is set on the &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; opcode, then the NULL values compare equal to one another. Otherwise NULL values compare different from one another.</source>
          <target state="translated">SQLite의 바이트 코드 프로그램은 하나 이상의 명령어로 구성됩니다. 각 명령어에는 opcode와 P1, P2 P3, P4 및 P5라는 5 개의 피연산자가 있습니다. P1, P2 및 P3 피연산자는 부호있는 32 비트 정수입니다. 이 피연산자는 종종 레지스터를 나타냅니다. b- 트리 커서에서 작동하는 명령어의 경우 일반적으로 P1 피연산자가 커서 번호입니다. 점프 명령의 경우 일반적으로 P2가 점프 대상입니다. P4는 32 비트 부호있는 정수, 64 비트 부호있는 정수, 64 비트 부동 소수점 값, 문자열 리터럴, Blob 리터럴, 조합 순서 비교 함수에 대한 포인터 또는 응용 프로그램 정의 SQL 함수 또는 기타 여러 가지. P5는 일반적으로 플래그를 보유하는 데 사용되는 16 비트 부호없는 정수입니다. P5 플래그의 비트는 때때로 미묘한 방식으로 opcode에 영향을 줄 수 있습니다. 예를 들어P5 피연산자의 SQLITE_NULLEQ (0x0080) 비트가&lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; opcode, NULL 값은 서로 동일합니다. 그렇지 않으면 NULL 값이 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="af46994da07ef61f25c2f526b23c9597924b8bf6" translate="yes" xml:space="preserve">
          <source>A cache spill causes the lock on the database file to escalate from reserved to exclusive. This reduces concurrency. A cache spill also causes extra disk flush or fsync operations to occur and these operations are slow, hence a cache spill can seriously reduce performance. For these reasons a cache spill is avoided whenever possible.</source>
          <target state="translated">캐시 유출로 인해 데이터베이스 파일의 잠금이 예약에서 독점으로 에스컬레이션됩니다. 이것은 동시성을 줄입니다. 캐시 유출로 인해 추가 디스크 플러시 또는 fsync 작업이 발생하고 이러한 작업이 느려지므로 캐시 유출로 인해 성능이 크게 저하 될 수 있습니다. 이러한 이유로 캐시 유출은 가능할 때마다 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="952fa12450de75899de19565202a5c251a96a2d4" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">데이터베이스 연결 D가 스키마 S의 데이터베이스 파일이 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 임을 알지 못하면 &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)에&lt;/a&gt; 대한 호출 이 실패 합니다 . 해당 데이터베이스 연결 에 대한 사전 I / O가 없거나 데이터베이스 연결 에서 가장 최근의 I / O 후에 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 들어간 경우 데이터베이스 연결 은 데이터베이스 파일이 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있음을 알 수 없습니다 . 힌트 : 스냅 샷을 사용할 수 있도록 새로 열린 데이터베이스 연결에 대해 &quot; &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &quot;를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbce2a7d14e5d524aa34fd10caef37f64f6407da" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; will fail if the database connection D does not know that the database file for schema S is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. A database connection might not know that the database file is in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; if there has been no prior I/O on that database connection, or if the database entered &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; after the most recent I/O on the database connection. (Hint: Run &quot;&lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;&quot; against a newly opened database connection in order to make it ready to use snapshots.)</source>
          <target state="translated">데이터베이스 연결 D가 스키마 S의 데이터베이스 파일이 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; 임을 알지 못하면 &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)에&lt;/a&gt; 대한 호출 이 실패 합니다 . 해당 데이터베이스 연결 에 대한 사전 I / O가 없거나 데이터베이스 연결 에서 가장 최근의 I / O 후에 데이터베이스가 &lt;a href=&quot;../wal&quot;&gt;WAL 모드에&lt;/a&gt; 들어간 경우 데이터베이스 연결 은 데이터베이스 파일이 &lt;a href=&quot;../wal&quot;&gt;WAL 모드에&lt;/a&gt; 있음을 알 수 없습니다 . 힌트 : 스냅 샷을 사용할 수 있도록 새로 열린 데이터베이스 연결에 대해 &quot; &lt;a href=&quot;../pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; &quot;를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0586f982e4b86cf9914eab1aee68b8462d61681f" translate="yes" xml:space="preserve">
          <source>A call to one of the above APIs creates a new SQL function named by the second parameter (zQueryFunc or zGeom). When that SQL function appears on the right-hand side of the MATCH operator and the left-hand side of the MATCH operator is any column in the R*Tree virtual table, then the callback defined by the third argument (xQueryFunc or xGeom) is invoked to determine if a particular object or subtree overlaps the desired region.</source>
          <target state="translated">위 API 중 하나를 호출하면 두 번째 매개 변수 (zQueryFunc 또는 zGeom)로 명명 된 새 SQL 함수가 작성됩니다. 해당 SQL 함수가 MATCH 연산자의 오른쪽에 나타나고 MATCH 연산자의 왼쪽이 R * Tree 가상 테이블의 열인 경우 세 번째 인수 (xQueryFunc 또는 xGeom)로 정의 된 콜백은 다음과 같습니다. 특정 객체 또는 하위 트리가 원하는 영역과 겹치는 지 확인하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c9d57a6c7577d82ae5958b8d5845cbdeb488ef" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_backup_init() will fail, returning NULL, if there is already a read or read-write transaction open on the destination database.</source>
          <target state="translated">대상 데이터베이스에서 이미 읽기 또는 읽기 / 쓰기 트랜잭션이 열려 있으면 sqlite3_backup_init () 호출이 실패하고 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f76c2f91f4bc291282ba8411c90b19f5effe501" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_initialize() is an &quot;effective&quot; call if it is the first time sqlite3_initialize() is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize() is invoked following a call to sqlite3_shutdown(). Only an effective call of sqlite3_initialize() does any initialization. All other calls are harmless no-ops.</source>
          <target state="translated">sqlite3_initialize ()에 대한 호출은 프로세스 유효 기간 동안 sqlite3_initialize ()가 처음 호출되거나 sqlite3_sialdown ()에 대한 호출 이후 sqlite3_initialize ()가 처음 호출 된 경우 &quot;유효&quot;호출입니다. sqlite3_initialize ()의 효과적인 호출 만 초기화를 수행합니다. 다른 모든 전화는 무해합니다.</target>
        </trans-unit>
        <trans-unit id="f8e50509528b4aaa1911d41bfa12097644542f6c" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_serialize(D,S,P,F) might return NULL even if the SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory allocation error occurs.</source>
          <target state="translated">메모리 할당 오류가 발생하면 SQLITE_SERIALIZE_NOCOPY 비트가 인수 F에서 생략 된 경우에도 sqlite3_serialize (D, S, P, F)에 대한 호출은 NULL을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f09c1e84942a3f4e19f6efa6988346dd1bf454a" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_shutdown() is an &quot;effective&quot; call if it is the first call to sqlite3_shutdown() since the last sqlite3_initialize(). Only an effective call to sqlite3_shutdown() does any deinitialization. All other valid calls to sqlite3_shutdown() are harmless no-ops.</source>
          <target state="translated">sqlite3_shutdown ()에 대한 호출은 마지막 sqlite3_initialize () 이후 sqlite3_shutdown ()에 대한 첫 번째 호출 인 경우 &quot;유효한&quot;호출입니다. sqlite3_shutdown ()에 대한 효과적인 호출 만이 초기화를 해제합니다. sqlite3_shutdown ()에 대한 다른 모든 유효한 호출은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="99d86897005e13370bf2940a7d68c4f6212b3540" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">지정된 스냅 샷을 &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; 로 덮어 쓴 경우 sqlite3_snapshot_open ()에 대한 호출이 열리지 않습니다 . 이 경우 SQLITE_ERROR_SNAPSHOT가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b123d9394215fb466274e78d5f37dcb5d1971345" translate="yes" xml:space="preserve">
          <source>A call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. In this case SQLITE_ERROR_SNAPSHOT is returned.</source>
          <target state="translated">지정된 스냅 샷을 &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; 로 덮어 쓴 경우 sqlite3_snapshot_open ()에 대한 호출이 열리지 않습니다 . 이 경우 SQLITE_ERROR_SNAPSHOT가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="83087efdcf0ff814df49782ed7673c5bb32e0d3c" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; and &lt;a href=&quot;vtab#xsync&quot;&gt;xSync&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 대한 호출은 항상 &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; 및 &lt;a href=&quot;vtab#xsync&quot;&gt;xSync에&lt;/a&gt; 대한 이전 호출을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="53bba7422e25acf22029d539a9c3e869ba9eebb8" translate="yes" xml:space="preserve">
          <source>A call to this method always follows a prior call to &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 대한 호출은 항상 &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin에&lt;/a&gt; 대한 이전 호출을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="63823dedf5b482128e2d0cda7c31f9b2e6a816fd" translate="yes" xml:space="preserve">
          <source>A call to this routine stores N bytes of randomness into buffer P. The P parameter can be a NULL pointer.</source>
          <target state="translated">이 루틴을 호출하면 N 바이트의 임의성이 버퍼 P에 저장됩니다. P 매개 변수는 NULL 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b22fa4e435ba9bc17d0619fd2c72b0454f69b7" translate="yes" xml:space="preserve">
          <source>A cast of a REAL value into an INTEGER results in the integer between the REAL value and zero that is closest to the REAL value. If a REAL is greater than the greatest possible signed integer (+9223372036854775807) then the result is the greatest possible signed integer and if the REAL is less than the least possible signed integer (-9223372036854775808) then the result is the least possible signed integer.</source>
          <target state="translated">REAL 값을 INTEGER로 캐스트하면 REAL 값과 REAL 값에 가장 가까운 0 사이의 정수가됩니다. REAL이 가능한 최대 부호있는 정수 (+9223372036854775807)보다 큰 경우 결과는 가능한 가장 큰 부호있는 정수이고 REAL이 가능한 가장 작은 부호있는 정수보다 작은 경우 (-9223372036854775808) 결과는 가능한 최소 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e33e1dcf808eee9d2baa613dd62fa64f94613f9b" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../sessionintro#changeset&quot;&gt;변경 그룹&lt;/a&gt; 은 둘 이상의 변경 &lt;a href=&quot;../sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 를 결합하는 데 사용되는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="75339bffdc37dce20eb97a829cfa5c7aa288c842" translate="yes" xml:space="preserve">
          <source>A changegroup is an object used to combine two or more &lt;a href=&quot;sessionintro#changeset&quot;&gt;changesets&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchsets&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sessionintro#changeset&quot;&gt;변경 그룹&lt;/a&gt; 은 둘 이상의 변경 &lt;a href=&quot;sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 를 결합하는 데 사용되는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="42a455c489be5e742a9b6a79c8fd17fd21034f9a" translate="yes" xml:space="preserve">
          <source>A changeset blob is extracted from the session object using a call to &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; (or, if using patchsets, a call to the &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; function).</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()에&lt;/a&gt; 대한 호출 (또는 패치 세트를 사용하는 경우 &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()&lt;/a&gt; 함수에 대한 호출)을 사용하여 세션 오브젝트에서 변경 세트 블롭을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="bca7cd75094117285613d3c27e6356cf37002d9b" translate="yes" xml:space="preserve">
          <source>A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes, each representing a change to a single row of an attached table. An INSERT change contains the values of each field of a new database row. A DELETE contains the original values of each field of a deleted database row. An UPDATE change contains the original values of each field of an updated database row along with the updated values for each updated non-primary-key column. It is not possible for an UPDATE change to represent a change that modifies the values of primary key columns. If such a change is made, it is represented in a changeset as a DELETE followed by an INSERT.</source>
          <target state="translated">변경 세트는 0 개 이상의 INSERT, UPDATE 및 / 또는 DELETE 변경으로 구성되며 각 변경은 첨부 된 테이블의 단일 행에 대한 변경을 나타냅니다. INSERT 변경 사항에는 새 데이터베이스 행의 각 필드 값이 포함됩니다. DELETE는 삭제 된 데이터베이스 행의 각 필드의 원래 값을 포함합니다. UPDATE 변경에는 업데이트 된 데이터베이스 키 행의 각 필드에 대한 원래 값과 업데이트 된 기본 키가 아닌 열 각각에 대한 업데이트 된 값이 포함됩니다. UPDATE 변경이 기본 키 열의 값을 수정하는 변경을 나타내는 것은 불가능합니다. 그러한 변경이 이루어지면, 변경 세트에서 DELETE와 INSERT로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b70e5afa0d3f4c5cf0dce236c8276c0465659ed" translate="yes" xml:space="preserve">
          <source>A changeset may be &quot;inverted&quot; using the &lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; API function. An inverted changeset undoes the changes made by the original. If changeset C&lt;sup&gt;+&lt;/sup&gt; is the inverse of changeset C, then applying C and then C&lt;sup&gt;+&lt;/sup&gt; to a database should leave the database unchanged.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; API 함수를 사용하여 변경 세트를 &quot;반전&quot;할 수 있습니다 . 반전 된 변경 세트는 원본의 변경 사항을 취소합니다. 변경 세트 C &lt;sup&gt;+&lt;/sup&gt; 가 변경 세트 C 의 역수 인 경우 C를 적용한 다음 C &lt;sup&gt;+&lt;/sup&gt; 를 데이터베이스에 적용 하면 데이터베이스가 변경되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9f32575cd3ae2a269f162fb8c8c71eb2f8f6d374" translate="yes" xml:space="preserve">
          <source>A checkpoint need not run to completion. It might be that some readers are still using older transactions with data that is contained in the database file. In that case, transferring content for newer transactions from the WAL file into the database would delete the content out from under readers still using the older transactions. To avoid that, checkpoints only run to completion if all reader are using the last transaction in the WAL.</source>
          <target state="translated">체크 포인트를 완료하기 위해 실행할 필요는 없습니다. 일부 독자는 여전히 데이터베이스 파일에 포함 된 데이터로 이전 트랜잭션을 사용하고있을 수 있습니다. 이 경우, WAL 파일에서 데이터베이스로 최신 트랜잭션에 대한 컨텐츠를 전송하면 여전히 이전 트랜잭션을 사용하는 판독기에서 컨텐츠가 삭제됩니다. 이를 방지하기 위해 모든 판독기가 WAL에서 마지막 트랜잭션을 사용하는 경우에만 체크 포인트가 완료 될 때까지 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b3764489da6b52009c87b8c15206abcd48df46" translate="yes" xml:space="preserve">
          <source>A checkpoint operation takes content from the WAL file and transfers it back into the original database file. A checkpoint can run concurrently with readers, however the checkpoint must stop when it reaches a page in the WAL that is past the end mark of any current reader. The checkpoint has to stop at that point because otherwise it might overwrite part of the database file that the reader is actively using. The checkpoint remembers (in the wal-index) how far it got and will resume transferring content from the WAL to the database from where it left off on the next invocation.</source>
          <target state="translated">검사 점 작업은 WAL 파일에서 내용을 가져 와서 원래 데이터베이스 파일로 다시 전송합니다. 검사 점은 리더와 동시에 실행될 수 있지만 WAL에서 현재 리더의 끝 표시를 지나는 페이지에 도달하면 검사 점을 중지해야합니다. 검사 점은 그 시점에서 중지해야합니다. 그렇지 않으면 판독기가 현재 사용중인 데이터베이스 파일의 일부를 겹쳐 쓸 수 있습니다. 검사 점은 (wal-index에서) 얼마나 멀리 있는지 기억하고 다음 호출에서 중단 된 위치에서 WAL에서 데이터베이스로 컨텐츠 전송을 재개합니다.</target>
        </trans-unit>
        <trans-unit id="b96f1bd57862e095f823ff7f46e3b31f9d401ec4" translate="yes" xml:space="preserve">
          <source>A checksum over bytes 0 through 39 of this header.</source>
          <target state="translated">이 헤더의 바이트 0에서 39까지의 체크섬.</target>
        </trans-unit>
        <trans-unit id="65d66abdb2f9e568e194d84301cc7c1defdf138c" translate="yes" xml:space="preserve">
          <source>A co-routine is like a subroutine in that it runs in the same thread as the caller and eventually returns control back to the caller. The difference is that a co-routine also has the ability to return before it has finished, and then resume where it left off the next time it is called.</source>
          <target state="translated">코 루틴은 호출자와 동일한 스레드에서 실행되고 결국에는 제어를 호출자에게 반환한다는 점에서 서브 루틴과 같습니다. 차이점은 코 루틴은 또한 완료되기 전에 복귀 한 다음 다음에 호출 될 때 중단 된 지점에서 재개 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3446ddc5c2704f78e209be503e073dd5871e32d" translate="yes" xml:space="preserve">
          <source>A collating sequence is implemented as a function that takes the two strings being compared as inputs and returns negative, zero, or positive if the first string is less than, equal to, or greater than the second. SQLite 3.0 comes with a single built-in collating sequence named &quot;BINARY&quot; which is implemented using the memcmp() routine from the standard C library. The BINARY collating sequence works well for English text. For other languages or locales, alternative collating sequences may be preferred.</source>
          <target state="translated">조합 순서는 두 문자열을 입력으로 비교하고 첫 번째 문자열이 두 번째보다 작거나 같거나 큰 경우 음수, 0 또는 양수를 반환하는 함수로 구현됩니다. SQLite 3.0에는 표준 C 라이브러리의 memcmp () 루틴을 사용하여 구현되는 &quot;BINARY&quot;라는 단일 내장 조합 시퀀스가 ​​제공됩니다. BINARY 조합 순서는 영어 텍스트에 적합합니다. 다른 언어 또는 로케일의 경우 대체 조합 순서가 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99502ad72180308e0c6e1dcbcacfcd00577dfed1" translate="yes" xml:space="preserve">
          <source>A collating sequence is just a defined order for text. When SQLite 3.0 sorts (or uses a comparison operator like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot;) the sort order is first determined by the data type.</source>
          <target state="translated">조합 순서는 정의 된 텍스트 순서입니다. SQLite 3.0이 정렬 할 때 (또는 &quot;&amp;lt;&quot;또는 &quot;&amp;gt; =&quot;와 같은 비교 연산자를 사용하는 경우) 정렬 순서는 먼저 데이터 유형에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5f87dfb8e180544c52ac50b7d5f03687e7a73db7" translate="yes" xml:space="preserve">
          <source>A column name can be any of the names defined in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement or one of the following special identifiers: &quot;&lt;b&gt;ROWID&lt;/b&gt;&quot;, &quot;&lt;b&gt;OID&lt;/b&gt;&quot;, or &quot;&lt;b&gt;_ROWID_&lt;/b&gt;&quot;. The three special identifiers describe the unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) associated with every row of every table and so are not available on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The special identifiers only refer to the row key if the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement does not define a real column with the same name. The rowid can be used anywhere a regular column can be used.</source>
          <target state="translated">열 이름은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문에 정의 된 이름 이거나 &quot; &lt;b&gt;ROWID&lt;/b&gt; &quot;, &quot; &lt;b&gt;OID&lt;/b&gt; &quot;또는 &quot; &lt;b&gt;_ROWID_&lt;/b&gt; &quot; 와 같은 특수 식별자 &lt;b&gt;중 하나 일 수 있습니다&lt;/b&gt; . 세 개의 특수 식별자 는 모든 테이블의 모든 행과 관련된 고유 한 정수 키 ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; )를 설명 하므로 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에서는 사용할 수 없습니다 . &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문이 동일한 이름의 실제 열을 정의하지 않은 경우 특수 식별자는 행 키만 참조합니다 . rowid는 일반 열을 사용할 수있는 곳이면 어디에서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b67ef6e85463cb42541d756505c5b2ae3565809" translate="yes" xml:space="preserve">
          <source>A column that includes a GENERATED ALWAY AS clause is a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;. Generated columns are supported beginning with SQLite verison 3.31.0 (2020-01-22). See the &lt;a href=&quot;gencol&quot;&gt;separate documentation&lt;/a&gt; for details on the capabilities and limitations of generated columns.</source>
          <target state="translated">GENERATED ALWAY AS 절을 포함하는 &lt;a href=&quot;gencol&quot;&gt;열&lt;/a&gt; 은 생성 된 열 입니다. 생성 된 열은 SQLite 버전 3.31.0 (2020-01-22)부터 지원됩니다. 생성 된 열의 기능 및 제한 사항에 대한 자세한 내용은 &lt;a href=&quot;gencol&quot;&gt;별도의 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06f5bfc838f715cc006584587792787f6b98f6d0" translate="yes" xml:space="preserve">
          <source>A column that uses INTEGER affinity behaves the same as a column with NUMERIC affinity. The difference between INTEGER and NUMERIC affinity is only evident in a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;.</source>
          <target state="translated">INTEGER 선호도를 사용하는 열은 선호도가 NUMERIC 인 열과 동일하게 동작합니다. INTEGER와 NUMERIC 선호도의 차이는 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식&lt;/a&gt; 에서만 분명 합니다 .</target>
        </trans-unit>
        <trans-unit id="7bec05409618ea12efea321b6ffb50468bbd6938" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if such conversion is lossless and reversible. For conversions between TEXT and REAL storage classes, SQLite considers the conversion to be lossless and reversible if the first 15 significant decimal digits of the number are preserved. If the lossless conversion of TEXT to INTEGER or REAL is not possible then the value is stored using the TEXT storage class. No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">선호도가 NUMERIC 인 열에는 5 개의 스토리지 클래스를 모두 사용하는 값이 포함될 수 있습니다. 텍스트 데이터가 NUMERIC 열에 삽입 될 때 텍스트의 스토리지 클래스는 이러한 변환이 손실이없고 되돌릴 수있는 경우 INTEGER 또는 REAL (기본 설정 순서)로 변환됩니다. TEXT와 REAL 스토리지 클래스 간의 변환에서 SQLite는 숫자의 첫 15 자리 십진 숫자가 유지되면 변환이 손실이없고 되돌릴 수있는 것으로 간주합니다. TEXT를 INTEGER 또는 REAL로 무손실 변환 할 수없는 경우 값은 TEXT 스토리지 클래스를 사용하여 저장됩니다. NULL 또는 BLOB 값을 변환하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67992ebe6149e17ea7cdb1cdfe8c4235d6887281" translate="yes" xml:space="preserve">
          <source>A column with NUMERIC affinity may contain values using all five storage classes. When text data is inserted into a NUMERIC column, the storage class of the text is converted to INTEGER or REAL (in order of preference) if the text is a well-formed integer or real literal, respectively. If the TEXT value is a well-formed integer literal that is too large to fit in a 64-bit signed integer, it is converted to REAL. For conversions between TEXT and REAL storage classes, only the first 15 significant decimal digits of the number are preserved. If the TEXT value is not a well-formed integer or real literal, then the value is stored as TEXT. For the purposes of this paragraph, hexadecimal integer literals are not considered well-formed and are stored as TEXT. (This is done for historical compatibility with versions of SQLite prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;version 3.8.6&lt;/a&gt; 2014-08-15 where hexadecimal integer literals were first introduced into SQLite.) No attempt is made to convert NULL or BLOB values.</source>
          <target state="translated">선호도가 NUMERIC 인 열에는 5 개의 스토리지 클래스를 모두 사용하는 값이 포함될 수 있습니다. 텍스트 데이터가 NUMERIC 열에 삽입 될 때 텍스트가 각각 올바른 형식의 정수 또는 실제 리터럴이면 텍스트의 스토리지 클래스가 INTEGER 또는 REAL (선호도 순서대로)으로 변환됩니다. TEXT 값이 너무 커서 64 비트 부호있는 정수에 맞지 않는 올바른 형식의 정수 리터럴이면 REAL로 변환됩니다. TEXT 및 REAL 스토리지 클래스 간의 변환의 경우 숫자의 처음 15 자리 유효 십진수 만 유지됩니다. TEXT 값이 올바른 형식의 정수 또는 실제 리터럴이 아닌 경우 값은 TEXT로 저장됩니다. 이 단락에서 16 진 정수 리터럴은 올바른 형식으로 간주되지 않으며 TEXT로 저장됩니다. (이것은 이전의 SQLite 버전과의 역사적 호환성을 위해 수행됩니다.&lt;a href=&quot;https://sqlite.org/releaselog/3_8_6.html&quot;&gt;&lt;/a&gt;16 진 정수 리터럴이 SQLite에 처음 도입 된 버전 3.8.6 2014-08-15.) NULL 또는 BLOB 값을 변환하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="636834272fe49a104c8b0f637d91fe89b1a7c34e" translate="yes" xml:space="preserve">
          <source>A column with REAL affinity behaves like a column with NUMERIC affinity except that it forces integer values into floating point representation. (As an internal optimization, small floating point values with no fractional component and stored in columns with REAL affinity are written to disk as integers in order to take up less space and are automatically converted back into floating point as the value is read out. This optimization is completely invisible at the SQL level and can only be detected by examining the raw bits of the database file.)</source>
          <target state="translated">REAL 선호도가있는 열은 정수 값을 부동 소수점 표현으로 강제한다는 점을 제외하고는 NUMERIC 선호도가있는 열처럼 작동합니다. (내부 최적화로서, 소수 구성 요소가없고 REAL 선호도가있는 열에 저장된 작은 부동 소수점 값은 공간을 덜 차지하기 위해 디스크에 정수로 기록되며 값을 읽을 때 자동으로 부동 소수점으로 다시 변환됩니다. 최적화는 SQL 수준에서 완전히 보이지 않으며 데이터베이스 파일의 원시 비트를 검사해야만 탐지 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e5c849785a5191658d60300de8d49f0749c36fe5" translate="yes" xml:space="preserve">
          <source>A column with TEXT affinity stores all data using storage classes NULL, TEXT or BLOB. If numerical data is inserted into a column with TEXT affinity it is converted into text form before being stored.</source>
          <target state="translated">TEXT 선호도가있는 열은 스토리지 클래스 NULL, TEXT 또는 BLOB를 사용하여 모든 데이터를 저장합니다. TEXT 선호도가있는 열에 숫자 데이터를 삽입하면 저장하기 전에 텍스트 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="331f0240bd92e0f60f02450a7696762f50b6d061" translate="yes" xml:space="preserve">
          <source>A column with affinity BLOB does not prefer one storage class over another and no attempt is made to coerce data from one storage class into another.</source>
          <target state="translated">A column with affinity BLOB does not prefer one storage class over another and no attempt is made to coerce data from one storage class into another.</target>
        </trans-unit>
        <trans-unit id="a9b523c7ac2e4f6d2358ca3e1fc9c4bea3b0b218" translate="yes" xml:space="preserve">
          <source>A compile-time option (SQLITE_BUSY_RESERVED_LOCK) causes the busy handler to be called when there is contention for a RESERVED lock.</source>
          <target state="translated">A compile-time option (SQLITE_BUSY_RESERVED_LOCK) causes the busy handler to be called when there is contention for a RESERVED lock.</target>
        </trans-unit>
        <trans-unit id="b67fed388120bd5bc263b4502fa3722ec97dd3d6" translate="yes" xml:space="preserve">
          <source>A complete database is stored in a &lt;a href=&quot;onefile&quot;&gt;single cross-platform disk file&lt;/a&gt;. Great for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">A complete database is stored in a &lt;a href=&quot;onefile&quot;&gt;single cross-platform disk file&lt;/a&gt;. Great for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="11f700eff4c65192a540e579b7e4f8ad1d2b1604" translate="yes" xml:space="preserve">
          <source>A complete release-test of SQLite requires additional software,</source>
          <target state="translated">A complete release-test of SQLite requires additional software,</target>
        </trans-unit>
        <trans-unit id="85cbfa4256773a63897f24495c59253a95e5dd50" translate="yes" xml:space="preserve">
          <source>A composite foreign key constraint is one where the child and parent keys are both composite keys. For example, consider the following database schema:</source>
          <target state="translated">A composite foreign key constraint is one where the child and parent keys are both composite keys. For example, consider the following database schema:</target>
        </trans-unit>
        <trans-unit id="0bdd710506454d94afdc4228574e57b24f793bf2" translate="yes" xml:space="preserve">
          <source>A compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is two or more SELECT statements connected by operators UNION, UNION ALL, EXCEPT, or INTERSECT. We call each individual SELECT statement within a compound SELECT a &quot;term&quot;.</source>
          <target state="translated">A compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is two or more SELECT statements connected by operators UNION, UNION ALL, EXCEPT, or INTERSECT. We call each individual SELECT statement within a compound SELECT a &quot;term&quot;.</target>
        </trans-unit>
        <trans-unit id="aff14af06eef38988e550d3bb6bb8834b81c2ab0" translate="yes" xml:space="preserve">
          <source>A compound SELECT created using UNION ALL operator returns all the rows from the SELECT to the left of the UNION ALL operator, and all the rows from the SELECT to the right of it. The UNION operator works the same way as UNION ALL, except that duplicate rows are removed from the final result set. The INTERSECT operator returns the intersection of the results of the left and right SELECTs. The EXCEPT operator returns the subset of rows returned by the left SELECT that are not also returned by the right-hand SELECT. Duplicate rows are removed from the results of INTERSECT and EXCEPT operators before the result set is returned.</source>
          <target state="translated">A compound SELECT created using UNION ALL operator returns all the rows from the SELECT to the left of the UNION ALL operator, and all the rows from the SELECT to the right of it. The UNION operator works the same way as UNION ALL, except that duplicate rows are removed from the final result set. The INTERSECT operator returns the intersection of the results of the left and right SELECTs. The EXCEPT operator returns the subset of rows returned by the left SELECT that are not also returned by the right-hand SELECT. Duplicate rows are removed from the results of INTERSECT and EXCEPT operators before the result set is returned.</target>
        </trans-unit>
        <trans-unit id="56b1d09048efb4fd1fb06c9b9ddec9b21053649e" translate="yes" xml:space="preserve">
          <source>A conflict handler callback must return one of the following three values.</source>
          <target state="translated">A conflict handler callback must return one of the following three values.</target>
        </trans-unit>
        <trans-unit id="8d286e1793dce553da5e2fb27f69090f877b2aeb" translate="yes" xml:space="preserve">
          <source>A connection may not compile an SQL statement if any other connection is holding a write-lock on the</source>
          <target state="translated">A connection may not compile an SQL statement if any other connection is holding a write-lock on the</target>
        </trans-unit>
        <trans-unit id="4a47f7617f36f73967261be474fcf1ca9ab960be" translate="yes" xml:space="preserve">
          <source>A connection must obtain a read-lock on</source>
          <target state="translated">A connection must obtain a read-lock on</target>
        </trans-unit>
        <trans-unit id="ba1dcaac6e13d9eb13e548994e129aca79ff47b0" translate="yes" xml:space="preserve">
          <source>A contentless FTS5 table is created by setting the &quot;content&quot; option to an empty string. For example:</source>
          <target state="translated">A contentless FTS5 table is created by setting the &quot;content&quot; option to an empty string. For example:</target>
        </trans-unit>
        <trans-unit id="a267c5dab66f5e34a45852cc32f71b97729d1b15" translate="yes" xml:space="preserve">
          <source>A copy of bytes 0 through 47 of this header.</source>
          <target state="translated">A copy of bytes 0 through 47 of this header.</target>
        </trans-unit>
        <trans-unit id="6bfcf4a271894a36753059f74bed2256dff4a758" translate="yes" xml:space="preserve">
          <source>A coverage testing build is used to validate the test suite, to confirm that the test suite provides 100% MC/DC.</source>
          <target state="translated">A coverage testing build is used to validate the test suite, to confirm that the test suite provides 100% MC/DC.</target>
        </trans-unit>
        <trans-unit id="94c5d9a042e6577c2dabc042ff092ff7fee14842" translate="yes" xml:space="preserve">
          <source>A database connection in read-uncommitted mode does not attempt to obtain read-locks before reading from database tables as described above. This can lead to inconsistent query results if another database connection modifies a table while it is being read, but it also means that a read-transaction opened by a connection in read-uncommitted mode can neither block nor be blocked by any other connection.</source>
          <target state="translated">A database connection in read-uncommitted mode does not attempt to obtain read-locks before reading from database tables as described above. This can lead to inconsistent query results if another database connection modifies a table while it is being read, but it also means that a read-transaction opened by a connection in read-uncommitted mode can neither block nor be blocked by any other connection.</target>
        </trans-unit>
        <trans-unit id="5f2be52de867ed0c8228dad137b9e9be0ede3dc9" translate="yes" xml:space="preserve">
          <source>A database file might contain one or more pages that are not in active use. Unused pages can come about, for example, when information is deleted from the database. Unused pages are stored on the freelist and are reused when additional pages are required.</source>
          <target state="translated">A database file might contain one or more pages that are not in active use. Unused pages can come about, for example, when information is deleted from the database. Unused pages are stored on the freelist and are reused when additional pages are required.</target>
        </trans-unit>
        <trans-unit id="e31bb0c648c1594ace271ab750089b7069eca230" translate="yes" xml:space="preserve">
          <source>A database filename pointer created by the SQLite core and passed into the xOpen() method of a VFS implemention, or</source>
          <target state="translated">SQLite 코어에 의해 생성되고 VFS 구현의 xOpen () 메서드에 전달 된 데이터베이스 파일 이름 포인터 또는</target>
        </trans-unit>
        <trans-unit id="d0d2200c58a122988a36133f11d5ad81150a5964" translate="yes" xml:space="preserve">
          <source>A database handle may only have a single profile script registered at any time. If there is already a script registered when the profile method is invoked, the previous profile script is replaced by the new one. If the</source>
          <target state="translated">A database handle may only have a single profile script registered at any time. If there is already a script registered when the profile method is invoked, the previous profile script is replaced by the new one. If the</target>
        </trans-unit>
        <trans-unit id="f7c56f6c25c0806c71336c6dfe79200c9d74d137" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;amp;sup1. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">A database in SQLite is a single disk file&amp;amp;sup1. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</target>
        </trans-unit>
        <trans-unit id="a33a00bec56bc970089c19de104ce52c75222367" translate="yes" xml:space="preserve">
          <source>A database in SQLite is a single disk file&amp;sup1;. Furthermore, the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; is cross-platform. A database that is created on one machine can be copied and used on a different machine with a different architecture. SQLite databases are portable across 32-bit and 64-bit machines and between &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;little-endian&lt;/a&gt; architectures.</source>
          <target state="translated">SQLite의 데이터베이스는 단일 디스크 파일 &amp;sup1;입니다. 또한 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 은 크로스 플랫폼입니다. 한 시스템에서 생성 된 데이터베이스는 아키텍처가 다른 다른 시스템에서 복사하여 사용할 수 있습니다. SQLite 데이터베이스는 32 비트 및 64 비트 시스템과 &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;빅 엔디안&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;리틀 엔디안&lt;/a&gt; 아키텍처 간에 이식 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="58caf1944b94d1b1b9c822b0c5664121932f85cd" translate="yes" xml:space="preserve">
          <source>A database page number P is mapped into a hash value using the following hash function:</source>
          <target state="translated">A database page number P is mapped into a hash value using the following hash function:</target>
        </trans-unit>
        <trans-unit id="ed3347e26b126664d224486fe7f1e3e439c82acd" translate="yes" xml:space="preserve">
          <source>A database page size of 8192 or 16384 gives the best performance for large BLOB I/O.</source>
          <target state="translated">A database page size of 8192 or 16384 gives the best performance for large BLOB I/O.</target>
        </trans-unit>
        <trans-unit id="103c49f4c460c42c7a0369b1a9d6281b2a84fdfe" translate="yes" xml:space="preserve">
          <source>A datatype to SQLite is any sequence of zero or more names optionally followed by a parenthesized lists of one or two signed integers. Notice in particular that a datatype may be &lt;em&gt;zero&lt;/em&gt; or more names. That means that an empty string is a valid datatype as far as SQLite is concerned. So you can declare tables where the datatype of each column is left unspecified, like this:</source>
          <target state="translated">A datatype to SQLite is any sequence of zero or more names optionally followed by a parenthesized lists of one or two signed integers. Notice in particular that a datatype may be &lt;em&gt;zero&lt;/em&gt; or more names. That means that an empty string is a valid datatype as far as SQLite is concerned. So you can declare tables where the datatype of each column is left unspecified, like this:</target>
        </trans-unit>
        <trans-unit id="de414f6a58ee8730c6b30d4d04397485a33b014d" translate="yes" xml:space="preserve">
          <source>A default build of SQLite, if a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statement has no WHERE clause and operates on a table with no triggers, an optimization occurs that causes the DELETE to occur by dropping and recreating the table. Dropping and recreating a table is usually much faster than deleting the table content row by row. This is the &quot;truncate optimization&quot;.</source>
          <target state="translated">A default build of SQLite, if a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statement has no WHERE clause and operates on a table with no triggers, an optimization occurs that causes the DELETE to occur by dropping and recreating the table. Dropping and recreating a table is usually much faster than deleting the table content row by row. This is the &quot;truncate optimization&quot;.</target>
        </trans-unit>
        <trans-unit id="2702a604a55a621adb104d691b4fe3d29100cf61" translate="yes" xml:space="preserve">
          <source>A default collation sequence to use with each column.</source>
          <target state="translated">각 열에 사용할 기본 데이터 정렬 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="547106accc42ee8c3be32b9edfc90679c871cd46" translate="yes" xml:space="preserve">
          <source>A default value or expression for each column in the table.</source>
          <target state="translated">테이블의 각 열에 대한 기본값 또는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f9bafa0d6a619bf3ec9b0838fb3a083c9a68cbd8" translate="yes" xml:space="preserve">
          <source>A demonstration of how to use a virtual table to implement approximate string matching.</source>
          <target state="translated">가상 테이블을 사용하여 근사 문자열 일치를 구현하는 방법에 대한 데모.</target>
        </trans-unit>
        <trans-unit id="2c07573f063bff6f3b90762e19698056e9e8c100" translate="yes" xml:space="preserve">
          <source>A description of the available auxiliary functions, and more details regarding configuration of the special &quot;rank&quot; column, are &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;available below&lt;/a&gt;. &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;Custom auxiliary functions&lt;/a&gt; may also be implemented in C and registered with FTS5, just as custom SQL functions may be registered with the SQLite core.</source>
          <target state="translated">사용 가능한 보조 기능에 대한 설명과 특수 &quot;순위&quot;열 구성에 대한 자세한 내용은 &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;아래에서 확인할 수 있습니다&lt;/a&gt; . &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;커스텀 보조 함수&lt;/a&gt; 는 커스텀 SQL 함수가 SQLite 코어에 등록 될 수있는 것처럼 C로 구현되고 FTS5에 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c23846cd545b2b63ddda813679cd4a49e68b63" translate="yes" xml:space="preserve">
          <source>A design flaw in the layout of indices required a file format change to correct. This change appeared in version 2.6.0.</source>
          <target state="translated">인덱스 레이아웃의 디자인 결함으로 인해 파일 형식을 수정해야합니다. 이 변경 사항은 버전 2.6.0에 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="a09b00a1870ec37c4a6711c6d9a83ee63caec494" translate="yes" xml:space="preserve">
          <source>A deterministic function always gives the same answer when it has the same inputs. Most built-in SQL functions in SQLite are deterministic. For example, the &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs(X)&lt;/a&gt; function always returns the same answer as long as its input X is the same.</source>
          <target state="translated">결정 론적 함수는 입력이 같을 때 항상 동일한 대답을 제공합니다. SQLite에 내장 된 대부분의 SQL 함수는 결정적입니다. 예를 들어 &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs (X)&lt;/a&gt; 함수는 입력 X가 같으면 항상 같은 답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1d23588be86a8b0f51bcfc6d42620be9c04bdb9" translate="yes" xml:space="preserve">
          <source>A different interface is used to find statistics associated with a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;:</source>
          <target state="translated">단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 관련된 통계를 찾는 데 다른 인터페이스가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bab2383badd353faf6d58c28e00ad5e2dc43f7f" translate="yes" xml:space="preserve">
          <source>A different temporary file is created each time, so that just like as with the special &quot;:memory:&quot; string, two database connections to temporary databases each have their own private database. Temporary databases are automatically deleted when the connection that created them closes.</source>
          <target state="translated">매번 다른 임시 파일이 만들어 지므로 특별한 &quot;: memory :&quot;문자열과 마찬가지로 임시 데이터베이스에 대한 두 개의 데이터베이스 연결에는 각각 개인 데이터베이스가 있습니다. 임시 데이터베이스는 생성 한 연결이 닫히면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="616182c007ad6c0ef9a037faf15b8a4c7b4e27dc" translate="yes" xml:space="preserve">
          <source>A docid (document id), and</source>
          <target state="translated">문서 (문서 ID)</target>
        </trans-unit>
        <trans-unit id="ffa8c1978179e5d6594c307606a0c96c65d178b7" translate="yes" xml:space="preserve">
          <source>A doclist consists of an array of 64-bit signed integers, serialized using the FTS varint format. Each doclist entry is made up of a series of two or more integers, as follows:</source>
          <target state="translated">doclist는 FTS varint 형식을 사용하여 직렬화 된 64 비트 부호있는 정수의 배열로 구성됩니다. 각 doclist 항목은 다음과 같이 두 개 이상의 정수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="70b611cc962affaff5bc25b34d8cf2a147e0cff8" translate="yes" xml:space="preserve">
          <source>A dot-command cannot occur in the middle of an ordinary SQL statement. In other words, a dot-command cannot occur at a continuation prompt.</source>
          <target state="translated">일반 SQL 문 중간에 도트 명령을 사용할 수 없습니다. 즉, 연속 프롬프트에서 도트 명령을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed3f86822b1bda8e466c4526bffa4f20cb3e5064" translate="yes" xml:space="preserve">
          <source>A dot-command must begin with the &quot;.&quot; at the left margin with no preceding whitespace.</source>
          <target state="translated">점 명령은 &quot;.&quot;으로 시작해야합니다. 왼쪽 여백에 선행 공백이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9419d21a9cdfce978f5cf3af5bf95604556793ad" translate="yes" xml:space="preserve">
          <source>A federation of programs, perhaps all written in different programming languages, can access the same application file with no compatibility concerns.</source>
          <target state="translated">서로 다른 프로그래밍 언어로 작성된 프로그램 연합은 호환성 문제없이 동일한 응용 프로그램 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d364c247d7037a579b6c9cd2b367d98adf71052d" translate="yes" xml:space="preserve">
          <source>A few SQLite extensions benefit from passing pointers:</source>
          <target state="translated">몇 가지 SQLite 확장은 포인터를 전달하면 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f7d6f4dcc5ba74ac0335fa025ccd8910f0c1e1" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 일부 opcode 는 SQLite 코어에서 직접 처리하며 sqlite3_io_methods.xFileControl 메소드를 호출하지 않습니다. &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 매개 변수의 값은 기본에 대한 포인터가 발생 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file의&lt;/a&gt; 객체가 4 매개 변수가 가리키는 공간에 기록 될 수 있습니다. &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER는&lt;/a&gt; 그것이 반환하는 것을 제외하고 유사하게 작동 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file의&lt;/a&gt; 저널 파일 대신 기본 데이터베이스와 관련된 개체를. &lt;a href=&quot;#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 기본에 연산 코드를 반환 포인터 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs는&lt;/a&gt; 파일에 대한 객체. &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 호출기에서 데이터 버전 카운터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15b71d02b16fcc797e9ca6b0c9b9270d384f8e61" translate="yes" xml:space="preserve">
          <source>A few opcodes for &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; value for the op parameter causes a pointer to the underlying &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object to be written into the space pointed to by the 4th parameter. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; works similarly except that it returns the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file instead of the main database. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode returns a pointer to the underlying &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object for the file. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; returns the data version counter from the pager.</source>
          <target state="translated">&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 일부 opcode 는 SQLite 코어에서 직접 처리하며 sqlite3_io_methods.xFileControl 메소드를 호출하지 않습니다. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER의&lt;/a&gt; 연산 매개 변수의 값은 기본에 대한 포인터가 발생 &lt;a href=&quot;file&quot;&gt;sqlite3_file의&lt;/a&gt; 객체가 4 매개 변수가 가리키는 공간에 기록 될 수 있습니다. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER는&lt;/a&gt; 그것이 반환하는 것을 제외하고 유사하게 작동 &lt;a href=&quot;file&quot;&gt;sqlite3_file의&lt;/a&gt; 저널 파일 대신 기본 데이터베이스와 관련된 개체를. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER의&lt;/a&gt; 기본에 연산 코드를 반환 포인터 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs는&lt;/a&gt; 파일에 대한 객체. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; 호출기에서 데이터 버전 카운터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a30cb03f77194a1ffe9dcf2f61544ecd6effb5d" translate="yes" xml:space="preserve">
          <source>A file-handle is opened on the database file.</source>
          <target state="translated">데이터베이스 파일에서 파일 핸들이 열립니다.</target>
        </trans-unit>
        <trans-unit id="a9388c7b2c5482cecf8486b9ae5cf08dcef6f978" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename ()&lt;/a&gt; 에서 얻은 파일 이름 또는</target>
        </trans-unit>
        <trans-unit id="a919b14072f3c1d12642ca7fcf434072aba372a6" translate="yes" xml:space="preserve">
          <source>A filename obtained from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename ()&lt;/a&gt; 에서 얻은 파일 이름 또는</target>
        </trans-unit>
        <trans-unit id="fa2d542371ac8e72fa484fee76e990ca0bf35dd8" translate="yes" xml:space="preserve">
          <source>A filename that is not a well-formed URI is interpreted as an ordinary filename.</source>
          <target state="translated">잘 구성된 URI가 아닌 파일 이름은 일반 파일 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="925a1b52b051c06afa6e58e50e2b8bb4927090d1" translate="yes" xml:space="preserve">
          <source>A frame is considered valid if and only if the following conditions are true:</source>
          <target state="translated">다음 조건에 해당하는 경우에만 프레임이 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9611de2f1872728925114c844500f9f8ef115f15" translate="yes" xml:space="preserve">
          <source>A frame type - either ROWS, RANGE or GROUPS,</source>
          <target state="translated">프레임 유형-ROWS, RANGE 또는 GROUPS</target>
        </trans-unit>
        <trans-unit id="14b126bb6dbd1d7edb9b84085983a8045b613274" translate="yes" xml:space="preserve">
          <source>A freeblock is a structure used to identify unallocated space within a b-tree page. Freeblocks are organized as a chain. The first 2 bytes of a freeblock are a big-endian integer which is the offset in the b-tree page of the next freeblock in the chain, or zero if the freeblock is the last on the chain. The third and fourth bytes of each freeblock form a big-endian integer which is the size of the freeblock in bytes, including the 4-byte header. Freeblocks are always connected in order of increasing offset. The second field of the b-tree page header is the offset of the first freeblock, or zero if there are no freeblocks on the page. In a well-formed b-tree page, there will always be at least one cell before the first freeblock.</source>
          <target state="translated">프리 블록은 b- 트리 페이지 내에서 할당되지 않은 공간을 식별하는 데 사용되는 구조입니다. 프리 블록은 체인으로 구성됩니다. 프리 블록의 처음 2 바이트는 빅 엔디안 정수이며, 이는 체인에서 다음 프리 블록의 b- 트리 페이지에서 오프셋이거나 프리 블록이 체인에서 마지막이면 0입니다. 각 프리 블록의 3 번째 및 4 번째 바이트는 4 바이트 헤더를 포함하여 바이트 단위의 프리 블록 크기 인 빅 엔디안 정수를 형성합니다. 프리 블록은 항상 오프셋을 증가시키기 위해 연결됩니다. b- 트리 페이지 헤더의 두 번째 필드는 첫 번째 여유 블록의 오프셋이거나 페이지에 여유 블록이없는 경우 0입니다. 올바르게 구성된 b- 트리 페이지에는 첫 번째 프리 블록 앞에 항상 하나 이상의 셀이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2acc382f3b34dd5d099262b455a40252f22e8680" translate="yes" xml:space="preserve">
          <source>A freeblock requires at least 4 bytes of space. If there is an isolated group of 1, 2, or 3 unused bytes within the cell content area, those bytes comprise a fragment. The total number of bytes in all fragments is stored in the fifth field of the b-tree page header. In a well-formed b-tree page, the total number of bytes in fragments may not exceed 60.</source>
          <target state="translated">프리 블록에는 최소 4 바이트의 공간이 필요합니다. 셀 내용 영역 내에 사용되지 않는 1, 2 또는 3 개의 바이트 그룹이있는 경우 해당 바이트는 조각을 구성합니다. 모든 프래그먼트의 총 바이트 수는 b- 트리 페이지 헤더의 다섯 번째 필드에 저장됩니다. 올바르게 구성된 b- 트리 페이지에서 조각의 총 바이트 수는 60을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b80d94705f8bf7c5e4c97f09c2fe3da9d04e1505" translate="yes" xml:space="preserve">
          <source>A freelist leaf page</source>
          <target state="translated">프리리스트 리프 페이지</target>
        </trans-unit>
        <trans-unit id="c3220fe91d800548a519d55ab5c5896e3d8a1361" translate="yes" xml:space="preserve">
          <source>A freelist page</source>
          <target state="translated">프리리스트 페이지</target>
        </trans-unit>
        <trans-unit id="c408c3d929760cbe3bea5989823d3bcbc82cd883" translate="yes" xml:space="preserve">
          <source>A freelist page. The page number should be zero.</source>
          <target state="translated">프리리스트 페이지. 페이지 번호는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4a249e10dcc6a39be18d8c2e3b23ef6d5feaebd" translate="yes" xml:space="preserve">
          <source>A freelist trunk page</source>
          <target state="translated">프리리스트 트렁크 페이지</target>
        </trans-unit>
        <trans-unit id="0db4fc71bebbc8176162f7cd595aa13edbeb12ed" translate="yes" xml:space="preserve">
          <source>A freelist trunk page consists of an array of 4-byte big-endian integers. The size of the array is as many integers as will fit in the usable space of a page. The minimum usable space is 480 bytes so the array will always be at least 120 entries in length. The first integer on a freelist trunk page is the page number of the next freelist trunk page in the list or zero if this is the last freelist trunk page. The second integer on a freelist trunk page is the number of leaf page pointers to follow. Call the second integer on a freelist trunk page L. If L is greater than zero then integers with array indexes between 2 and L+1 inclusive contain page numbers for freelist leaf pages.</source>
          <target state="translated">프리리스트 트렁크 페이지는 4 바이트 빅 엔디안 정수 배열로 구성됩니다. 배열의 크기는 페이지의 사용 가능한 공간에 맞는만큼의 정수입니다. 사용 가능한 최소 공간은 480 바이트이므로 배열의 길이는 항상 최소 120 개의 항목입니다. 프리리스트 트렁크 페이지의 첫 번째 정수는 목록에서 다음 프리리스트 트렁크 페이지의 페이지 번호이거나 마지막 프리리스트 트렁크 페이지 인 경우 0입니다. 프리리스트 트렁크 페이지의 두 번째 정수는 따라갈 리프 페이지 포인터의 수입니다. 프리리스트 트렁크 페이지 L에서 두 번째 정수를 호출하십시오. L이 0보다 크면 2와 L + 1 사이의 배열 인덱스를 가진 정수에는 프리리스트 리프 페이지의 페이지 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f9d805045a05b8c1c21a89d92690feac608128" translate="yes" xml:space="preserve">
          <source>A full disk drive will normally give an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error rather than an SQLITE_IOERR error.</source>
          <target state="translated">전체 디스크 드라이브는 일반적으로 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_IOERR&lt;/a&gt; 오류 대신 SQLITE_FULL 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dd246aeb0987ce268dd63d7c5d7c659921acc423" translate="yes" xml:space="preserve">
          <source>A functionality testing build is used to validate the source code.</source>
          <target state="translated">기능 테스트 빌드는 소스 코드의 유효성을 검사하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69647f389c03a5fb55f353538995da652df9828c" translate="yes" xml:space="preserve">
          <source>A geopoly table is created as follows:</source>
          <target state="translated">지오 폴리 테이블은 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="deba985c96e7599b149dd466acf4a33fd8b7d25a" translate="yes" xml:space="preserve">
          <source>A good rule of thumb is to avoid using SQLite in situations where the same database will be accessed directly (without an intervening application server) and simultaneously from many computers over a network.</source>
          <target state="translated">경험 상으로는 동일한 데이터베이스에 (중재 응용 프로그램 서버없이) 직접 액세스하고 네트워크를 통해 많은 컴퓨터에서 동시에 액세스하는 상황에서 SQLite를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47ce97c37cb3d63bea994c838fc3580d1c732993" translate="yes" xml:space="preserve">
          <source>A good rule of thumb seems to be to always set &quot;PRAGMA analysis_limit=N&quot; for N between 100 and 1000 prior to running either &quot;ANALYZE&quot; or &quot;&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;&quot;. The results are not quite as precise, but they are precise enough, and the fact that the results are computed so much faster means that developers are more likely to compute them. An approximate ANALYZE is better than not running ANALYZE at all.</source>
          <target state="translated">경험상 좋은 규칙은 &quot;ANALYZE&quot;또는 &quot; &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; &quot; 를 실행하기 전에 N에 대해 항상 &quot;PRAGMA analysis_limit = N&quot;을 100에서 1000 사이로 설정하는 것 같습니다 . 결과는 그다지 정확하지는 않지만 충분히 정확하며 결과가 훨씬 더 빨리 계산된다는 사실은 개발자가 계산할 가능성이 더 높다는 것을 의미합니다. 대략적인 ANALYZE는 ANALYZE를 전혀 실행하지 않는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="504276fb27ab49d77f3fa65dc56539df4f20135a" translate="yes" xml:space="preserve">
          <source>A good way to make an archival copy of a database is this:</source>
          <target state="translated">데이터베이스의 아카이브 사본을 작성하는 좋은 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3552536e0c3fc2b1a5c13a249c60fb3e232b20" translate="yes" xml:space="preserve">
          <source>A high-performance full-text search index.</source>
          <target state="translated">고성능 전체 텍스트 검색 색인.</target>
        </trans-unit>
        <trans-unit id="f3fc66c121035cba95cdccd27eb5988b1d320b84" translate="yes" xml:space="preserve">
          <source>A higher-performance full-text search index</source>
          <target state="translated">고성능 전체 텍스트 검색 색인</target>
        </trans-unit>
        <trans-unit id="55bfdc0040ab9af19d73d70ad7d6c87f58f9b24f" translate="yes" xml:space="preserve">
          <source>A host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; is a place-holder in an SQL statement that is filled in using one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; interfaces. Many SQL programmers are familiar with using a question mark (&quot;?&quot;) as a host parameter. SQLite also supports named host parameters prefaced by &quot;:&quot;, &quot;$&quot;, or &quot;@&quot; and numbered host parameters of the form &quot;?123&quot;.</source>
          <target state="translated">호스트 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 는 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX ()&lt;/a&gt; 인터페이스 중 하나를 사용하여 채워지는 SQL 문의 자리 표시 자 입니다. 많은 SQL 프로그래머는 물음표 ( &quot;?&quot;)를 호스트 매개 변수로 사용하는 데 익숙합니다. SQLite는 &quot;:&quot;, &quot;$&quot;또는 &quot;@&quot;로 시작하는 명명 된 호스트 매개 변수와 &quot;? 123&quot;형식의 번호가 매겨진 호스트 매개 변수도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="257267c1113a289e6b9feab4b089bb45cde287f6" translate="yes" xml:space="preserve">
          <source>A host computer with a 32-bit or 64-bit address space. The OS can be Linux, Mac, Windows, *BSD, Solaris, or some other.</source>
          <target state="translated">주소가 32 비트 또는 64 비트 인 호스트 컴퓨터 OS는 Linux, Mac, Windows, * BSD, Solaris 또는 기타 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b6a216d45c25e568110df32be35198581043b2" translate="yes" xml:space="preserve">
          <source>A journal file consists of one or more</source>
          <target state="translated">저널 파일은 하나 이상의 구성</target>
        </trans-unit>
        <trans-unit id="e29bbea10489e0962b8f547beacaa5c44b5643b7" translate="yes" xml:space="preserve">
          <source>A journal is hot if...</source>
          <target state="translated">일기는 ...</target>
        </trans-unit>
        <trans-unit id="bf4b3bcb8b3070bf8bd1c4dde82d2f44df71510d" translate="yes" xml:space="preserve">
          <source>A jump is made to P2 if the result set after filtering would be empty.</source>
          <target state="translated">필터링 후 결과 세트가 비어 있으면 P2로 점프합니다.</target>
        </trans-unit>
        <trans-unit id="93a1f585c4bb54305bbad30d5d616a96cefe0475" translate="yes" xml:space="preserve">
          <source>A limited form of table-level locking is now also available in SQLite. If each table is stored in a separate database file, those separate files can be attached to the main database (using the ATTACH command) and the combined databases will function as one. But locks will only be acquired on individual files as needed. So if you redefine &quot;database&quot; to mean two or more database files, then it is entirely possible for two processes to be writing to the same database at the same time. To further support this capability, commits of transactions involving two or more ATTACHed database are now atomic.</source>
          <target state="translated">SQLite에서는 제한된 형식의 테이블 수준 잠금도 사용할 수 있습니다. 각 테이블이 별도의 데이터베이스 파일에 저장된 경우 해당 개별 파일을 기본 데이터베이스에 첨부 할 수 있으며 (ATTACH 명령 사용) 결합 된 데이터베이스는 하나의 기능을합니다. 그러나 필요한 경우 개별 파일에 대해서만 잠금을 획득합니다. 따라서 두 개 이상의 데이터베이스 파일을 의미하도록 &quot;데이터베이스&quot;를 재정의하면 두 프로세스가 동시에 같은 데이터베이스에 쓸 수 있습니다. 이 기능을 추가로 지원하기 위해 둘 이상의 첨부 된 데이터베이스와 관련된 트랜잭션 커밋은 이제 원 자성입니다.</target>
        </trans-unit>
        <trans-unit id="759400fcd5974123ad0b1241cafe4f82c240d273" translate="yes" xml:space="preserve">
          <source>A list of term offsets, one for each occurrence of the term within the document. A term offset indicates the number of tokens (words) that occur before the term in question, not the number of characters or bytes. For example, the term offset of the term &quot;war&quot; in the phrase &quot;Ancestral voices prophesying war!&quot; is 3.</source>
          <target state="translated">문서 내에서 용어가 나타날 때마다 하나씩, 용어 오프셋 목록. 용어 오프셋은 문자 또는 바이트 수가 아닌 해당 용어 앞에 발생하는 토큰 (단어)의 수를 나타냅니다. 예를 들어, &quot;전쟁을 예언하는 조상의 목소리&quot;라는 문구에서 &quot;전쟁&quot;이라는 용어의 오프셋. 3입니다</target>
        </trans-unit>
        <trans-unit id="b68d4ff4d7b33cd92deee3174c451fcde6f5c709" translate="yes" xml:space="preserve">
          <source>A list of term-offsets, sorted from smallest to largest. Instead of storing the term-offset value literally, each integer stored is the difference between the current term-offset and the previous one (or zero if the current term-offset is the first), plus 2.</source>
          <target state="translated">최소값에서 최대 값으로 정렬 된 용어 오프셋 목록입니다. 말 그대로 오프셋 값을 저장하는 대신, 저장된 각 정수는 현재 항 오프셋과 이전 항의 차이 (또는 현재 항 오프셋이 첫 번째 인 경우 0)에 2를 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="f2c5240a715ebac0343aac16762c04ccbb3c2e9c" translate="yes" xml:space="preserve">
          <source>A literal value can also be the token &quot;NULL&quot;.</source>
          <target state="translated">리터럴 값은 &quot;NULL&quot;토큰 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="677dc4104adc8eb80a0bd3eedfbb0364028f37cc" translate="yes" xml:space="preserve">
          <source>A literal value represents a constant. Literal values may be integers, floating point numbers, strings, BLOBs, or NULLs.</source>
          <target state="translated">리터럴 값은 상수를 나타냅니다. 리터럴 값은 정수, 부동 소수점 숫자, 문자열, BLOB 또는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec763a0eb37a9be20ccf4fd503223781cee5eb4c" translate="yes" xml:space="preserve">
          <source>A local change may be rebased against multiple remote changes simultaneously. If a single key is modified by multiple remote changesets, they are combined as follows before the local changeset is rebased:</source>
          <target state="translated">로컬 변경 사항은 여러 원격 변경 사항에 동시에 동시에 적용됩니다. 단일 원격 키가 여러 원격 변경 세트에 의해 수정되면 로컬 변경 세트가 리베이스되기 전에 다음과 같이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f44fa8f0079eaf328b711da0c194b82f3bfca0" translate="yes" xml:space="preserve">
          <source>A maliciously crafted database might be able to inject SQL by defining new &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; in the schema that the application does not anticipate. There are multiple defenses:</source>
          <target state="translated">악의적으로 제작 된 데이터베이스 는 응용 프로그램에서 예상하지 못한 스키마에 새로운 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 또는 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 를 정의하여 SQL을 주입 할 수 있습니다 . 여러 가지 방어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0169e2a34230a953484e9b48ea9bd77dd4f6ea97" translate="yes" xml:space="preserve">
          <source>A master journal is stale if no individual file journals are pointing to it. To figure out if a master journal is stale, we first read the master journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the master journal exists and points back to the master journal, then the master journal is not stale. If all file journals are either missing or refer to other master journals or no master journal at all, then the master journal we are testing is stale and can be safely deleted.</source>
          <target state="translated">개별 파일 저널이이를 가리 키지 않으면 마스터 저널이 오래되었습니다. 마스터 저널이 오래되었는지 확인하기 위해 먼저 마스터 저널을 읽고 모든 파일 저널의 이름을 얻습니다. 그런 다음 각 파일 저널을 확인합니다. 마스터 저널에 이름 지정된 파일 저널이 존재하고 마스터 저널을 다시 가리키는 경우 마스터 저널은 유효하지 않습니다. 모든 파일 저널이 없거나 다른 마스터 저널을 참조하거나 마스터 저널을 전혀 참조하지 않는 경우 테스트중인 마스터 저널이 오래되어 안전하게 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2661539e5d017b557d9c14e5c75af338d27b4e59" translate="yes" xml:space="preserve">
          <source>A merge has already been started (perhaps by a 'merge' command that specified a negative parameter).</source>
          <target state="translated">병합이 이미 시작되었습니다 (음수 매개 변수를 지정한 'merge'명령에 의해).</target>
        </trans-unit>
        <trans-unit id="279ebae13f861bd71157c08bf29f5b4c651d6c5d" translate="yes" xml:space="preserve">
          <source>A minimal build of SQLite requires just these routines from the standard C library:</source>
          <target state="translated">SQLite의 최소 빌드에는 표준 C 라이브러리에서 다음 루틴 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a5c466a87de63404dc0230e1abc285b23bb040a4" translate="yes" xml:space="preserve">
          <source>A minimum setup for compiling and testing SQLite from canonical sources is as follows:</source>
          <target state="translated">표준 소스에서 SQLite를 컴파일하고 테스트하기위한 최소 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab3655d2734192b9504cea343051e8b9d73b7c75" translate="yes" xml:space="preserve">
          <source>A more compact format for database files.</source>
          <target state="translated">데이터베이스 파일을위한보다 컴팩트 한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1330a0c8c8c0bac23fcad77a5abcbf9b765e263a" translate="yes" xml:space="preserve">
          <source>A more efficient approach is to remember the last entry currently displayed and then use a row value comparison in the WHERE clause:</source>
          <target state="translated">보다 효율적인 방법은 현재 표시된 마지막 항목을 기억하고 WHERE 절에서 행 값 비교를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cfada028d3ce37e834b96c227e215c6f74539e9e" translate="yes" xml:space="preserve">
          <source>A multi-column index follows the same pattern as a single-column index; the indexed columns are added in front of the rowid. The only difference is that now multiple columns are added. The left-most column is the primary key used for ordering the rows in the index. The second column is used to break ties in the left-most column. If there were a third column, it would be used to break ties for the first two columns. And so forth for all columns in the index. Because rowid is guaranteed to be unique, every row of the index will be unique even if all of the content columns for two rows are the same. That case does not happen in our sample data, but there is one case (fruit='Orange') where there is a tie on the first column which must be broken by the second column.</source>
          <target state="translated">다중 열 인덱스는 단일 열 인덱스와 동일한 패턴을 따릅니다. 인덱스 된 열은 rowid 앞에 추가됩니다. 유일한 차이점은 이제 여러 열이 추가된다는 것입니다. 가장 왼쪽 열은 인덱스에서 행을 정렬하는 데 사용되는 기본 키입니다. 두 번째 열은 가장 왼쪽 열의 연결을 끊는 데 사용됩니다. 세 번째 열이 있으면 처음 두 열의 연결을 끊는 데 사용됩니다. 인덱스의 모든 열에 대해서도 마찬가지입니다. rowid는 고유해야하므로 두 행의 모든 ​​내용 열이 동일하더라도 인덱스의 모든 행은 고유합니다. 이 경우는 표본 데이터에서 발생하지 않지만 첫 번째 열에 넥타이가 있고 두 번째 열에서 끊어야하는 경우 (fruit = 'Orange')가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f562249be7affb427174375ce85f9677d3d8ba0" translate="yes" xml:space="preserve">
          <source>A nearby diagram shows the main components of SQLite and how they interoperate. The text below explains the roles of the various components.</source>
          <target state="translated">근처 다이어그램은 SQLite의 주요 구성 요소와 상호 운용 방식을 보여줍니다. 아래의 텍스트는 다양한 구성 요소의 역할을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="089a318d287cfcafbb763115d5d6b053c8d7bc38" translate="yes" xml:space="preserve">
          <source>A new R*Tree index is created as follows:</source>
          <target state="translated">새로운 R * Tree 색인은 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="64a48a9b58450b09d0cfb9d4aa090ba17af83a99" translate="yes" xml:space="preserve">
          <source>A new VFS is implemented by subclassing three objects:</source>
          <target state="translated">새로운 VFS는 다음 세 가지 객체를 서브 클래 싱하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c89d2ee009f148a6ac5458e28252dd05648bb979" translate="yes" xml:space="preserve">
          <source>A new algorithm for statements of the form INSERT INTO</source>
          <target state="translated">INSERT INTO 형식의 명령문에 대한 새로운 알고리즘</target>
        </trans-unit>
        <trans-unit id="0a719325f748bb1a27f330e6d9c663cf611a3f59" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;#sqlite3_create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_filename&quot;&gt;sqlite3_create_filename ()을&lt;/a&gt; 사용하여 생성 된 새 파일 이름 .</target>
        </trans-unit>
        <trans-unit id="fb1283a78c873d763b7bafe624f1c1082569445b" translate="yes" xml:space="preserve">
          <source>A new filename constructed using &lt;a href=&quot;create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;create_filename&quot;&gt;sqlite3_create_filename ()을&lt;/a&gt; 사용하여 생성 된 새 파일 이름 .</target>
        </trans-unit>
        <trans-unit id="9387ece4f279e3ed8f65e6b38d71e87ff67c981e" translate="yes" xml:space="preserve">
          <source>A new flag &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; is made available to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스 에서 새로운 플래그 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82571217188a60c8f7271b16be25afd37dc1bf34" translate="yes" xml:space="preserve">
          <source>A new interface has been added to provided additional control over the creation of new database connections: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The legacy interfaces of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; continue to be fully supported.</source>
          <target state="translated">새로운 데이터베이스 연결 생성을위한 추가적인 제어를 제공하기 위해 새로운 인터페이스가 추가되었습니다 : &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 의 레거시 인터페이스는 계속 완벽하게 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7504ffc80677e48bad7daae529fd681b4630cb" translate="yes" xml:space="preserve">
          <source>A new union-vtab instance is created as follows:</source>
          <target state="translated">새로운 union-vtab 인스턴스는 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="21f615460738794433e991ce2ff6b478badda600" translate="yes" xml:space="preserve">
          <source>A non-NULL text value must be specified for the name column. It is an error if the specified name already exists in the archive.</source>
          <target state="translated">이름 열에 NULL이 아닌 텍스트 값을 지정해야합니다. 지정된 이름이 이미 아카이브에 존재하면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="44ae7e61487d1800801d4d106af7abaadcf50460" translate="yes" xml:space="preserve">
          <source>A non-root b-tree page. The page number is the parent b-tree page.</source>
          <target state="translated">루트가 아닌 b- 트리 페이지 페이지 번호는 상위 b- 트리 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="f8e201e2c3e74fe126c7287d5626bd1b0950b6b8" translate="yes" xml:space="preserve">
          <source>A null-terminated string containing the text of one or more SQL statements and/or queries to be processed.</source>
          <target state="translated">처리 할 하나 이상의 SQL 문 및 / 또는 쿼리의 텍스트를 포함하는 널 종료 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="43fd742955a943f2d8d68ae03590be0ffb9da9fd" translate="yes" xml:space="preserve">
          <source>A page in an overflow chain other than the first page. The page number is the prior page of the overflow chain.</source>
          <target state="translated">첫 번째 페이지가 아닌 오버 플로우 체인의 페이지. 페이지 번호는 오버 플로우 체인의 이전 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="d92232575e7ddb99b286147d87a7eb37c112dd51" translate="yes" xml:space="preserve">
          <source>A page is journalled by adding a</source>
          <target state="translated">페이지를 추가하여 저널링</target>
        </trans-unit>
        <trans-unit id="67d41f5dca0e121bb84e085c18fb28ea2c138474" translate="yes" xml:space="preserve">
          <source>A parenthesized, comma-separated list of scalar values.</source>
          <target state="translated">괄호로 묶은 쉼표로 구분 된 스칼라 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9ef2906548f6946959e71df0c261521f3831b983" translate="yes" xml:space="preserve">
          <source>A partial index definition may include the UNIQUE keyword. If it does, then SQLite requires every entry &lt;em&gt;in the index&lt;/em&gt; to be unique. This provides a mechanism for enforcing uniqueness across some subset of the rows in a table.</source>
          <target state="translated">부분 인덱스 정의에는 UNIQUE 키워드가 포함될 수 있습니다. 그렇다면 SQLite &lt;em&gt;는 인덱스의&lt;/em&gt; 모든 항목 이 고유해야합니다. 이를 통해 테이블의 일부 행 하위 집합에서 고유성을 적용 할 수있는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1bf63cba8a9d42e2054c36a2ad3d1ea049c41b10" translate="yes" xml:space="preserve">
          <source>A partial index is an index over a subset of the rows of a table.</source>
          <target state="translated">부분 인덱스는 테이블 행의 하위 집합에 대한 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="5d5173a741f61feaf55620d5f7f757f59051d29a" translate="yes" xml:space="preserve">
          <source>A patchset blob may be used with up to date versions of all sqlite3changeset_xxx API functions except for sqlite3changeset_invert(), which returns SQLITE_CORRUPT if it is passed a patchset. Similarly, attempting to use a patchset blob with old versions of the sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error.</source>
          <target state="translated">패치 세트 blob은 sqlite3changeset_invert ()를 제외한 모든 sqlite3changeset_xxx API 함수의 최신 버전과 함께 사용할 수 있습니다. sqlite3changeset_invert ()는 패치 세트가 전달되면 SQLITE_CORRUPT를 반환합니다. 마찬가지로, 이전 버전의 sqlite3changeset_xxx API에서 패치 세트 Blob을 사용하려고하면 SQLITE_CORRUPT 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e65df542e5b2ab6d391d8808bfc9bfd9a42dd1c8" translate="yes" xml:space="preserve">
          <source>A patchset is similar to a changeset. It is slightly more compact than a changeset, but provides more limited conflict detection and resolution options (see the next section for details). The differences between a patchset and a changeset are that:</source>
          <target state="translated">패치 세트는 변경 세트와 유사합니다. 변경 세트보다 약간 더 작지만 충돌 감지 및 해결 옵션이 더 제한적입니다 (자세한 내용은 다음 섹션 참조). 패치 세트와 변경 세트의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c8a1598f2157bb3e660a70a2c1195f71bea8641" translate="yes" xml:space="preserve">
          <source>A payload overflow page</source>
          <target state="translated">페이로드 오버 플로우 페이지</target>
        </trans-unit>
        <trans-unit id="40fb2ed4e8bd2a3775c9d2eeb2d4e37e28a73a34" translate="yes" xml:space="preserve">
          <source>A pending lock allows other processes that already have a shared lock to continue reading the database file. But it prevents new shared locks from being established. The idea behind a pending lock is to prevent writer starvation caused by a large pool of readers. There might be dozens, even hundreds, of other processes trying to read the database file. Each process acquires a shared lock before it starts reading, reads what it needs, then releases the shared lock. If, however, there are many different processes all reading from the same database, it might happen that a new process always acquires its shared lock before the previous process releases its shared lock. And so there is never an instant when there are no shared locks on the database file and hence there is never an opportunity for the writer to seize the exclusive lock. A pending lock is designed to prevent that cycle by allowing existing shared locks to proceed but blocking new shared locks from being established. Eventually all shared locks will clear and the pending lock will then be able to escalate into an exclusive lock.</source>
          <target state="translated">보류중인 잠금을 사용하면 이미 공유 잠금이있는 다른 프로세스가 데이터베이스 파일을 계속 읽을 수 있습니다. 그러나 새로운 공유 잠금이 설정되지 않도록합니다. 보류중인 잠금의 개념은 많은 독자 그룹으로 인한 작가 기아를 방지하는 것입니다. 데이터베이스 파일을 읽으려는 수십, 심지어 수백 개의 다른 프로세스가있을 수 있습니다. 각 프로세스는 읽기를 시작하기 전에 공유 잠금을 획득하고 필요한 내용을 읽은 다음 공유 잠금을 해제합니다. 그러나 동일한 데이터베이스에서 모두 읽는 여러 프로세스가 많은 경우 이전 프로세스가 공유 잠금을 해제하기 전에 새 프로세스가 항상 공유 잠금을 획득 할 수 있습니다. 따라서 데이터베이스 파일에 공유 잠금이없는 순간은 없으므로 기록기가 독점 잠금을 탈취 할 기회가 없습니다.보류중인 잠금은 기존 공유 잠금이 진행되도록 허용하지만 새 공유 잠금이 설정되지 않도록 차단하여주기를 방지하도록 설계되었습니다. 결국 모든 공유 잠금이 해제되고 보류중인 잠금이 독점 잠금으로 에스컬레이션 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfdf078a1ad97afe7d10282a6193866f5d046f1b" translate="yes" xml:space="preserve">
          <source>A performance enhancement to the page-cache &quot;truncate&quot; operation reduces &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; time by dozens of milliseconds on systems with a large &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="translated">페이지 캐시 &quot;잘라 내기&quot;조작의 성능 향상 은 큰 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;페이지 캐시&lt;/a&gt; 가있는 시스템에서 수십 밀리 초까지 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 시간을 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="d3934877796a31e3b44b08445cac9678ddebadf6" translate="yes" xml:space="preserve">
          <source>A phrase matches a document if the document contains at least one sub-sequence of tokens that matches the sequence of tokens that make up the phrase.</source>
          <target state="translated">문서에 문구를 구성하는 일련의 토큰과 일치하는 토큰의 하위 시퀀스가 ​​하나 이상 포함 된 경우 문구는 문서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="aad9a1c432b5f54ebccf2d84436734289434a755" translate="yes" xml:space="preserve">
          <source>A pile-of-files encourages content to be stored in a few large chunks. In the case of ODP, there are just four XML files that define the layout off all slides in a presentation. An SQLite database allows storing information in a few large chunks, but SQLite is also adept and efficient at storing information in numerous smaller pieces.</source>
          <target state="translated">파일 더미는 컨텐츠를 몇 개의 큰 덩어리로 저장하도록 권장합니다. ODP의 경우 프레젠테이션의 모든 슬라이드에서 레이아웃을 정의하는 XML 파일이 4 개뿐입니다. SQLite 데이터베이스를 사용하면 정보를 몇 개의 큰 청크로 저장할 수 있지만 SQLite는 정보를 여러 개의 작은 조각으로 저장하는 데에도 적합하고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="95a8394ec4ac0fe21d190c15e56ba33ddbedef33" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be read incrementally just like SQLite. But many developers are surprised to learn that SQLite can read and write smaller BLOBs (less than about 100KB in size) from its database faster than those same blobs can be read or written as separate files from the filesystem. (See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; for further information.) There is overhead associated with operating a relational database engine, however one should not assume that direct file I/O is faster than SQLite database I/O, as often it is not.</source>
          <target state="translated">파일 더미 형식은 SQLite처럼 점진적으로 읽을 수 있습니다. 그러나 많은 개발자들은 SQLite가 동일한 BLOB을 파일 시스템에서 별도의 파일로 읽거나 쓸 수있는 것보다 데이터베이스에서 더 작은 BLOB (약 100KB 미만)를 읽고 쓸 수 있다는 사실에 놀랐습니다. (자세한 정보 &lt;a href=&quot;fasterthanfs&quot;&gt;는 파일 시스템&lt;/a&gt; 및 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;외부 BLOB &lt;/a&gt;보다 내부 35 % 빠름 참조 ) 관계형 데이터베이스 엔진 운영과 관련된 오버 헤드가 있지만 직접 파일 I / O가 SQLite 데이터베이스 I / O보다 빠르다고 가정해서는 안됩니다. 종종 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6baa78bd5928c61d383f2bef11579e65db7d21d3" translate="yes" xml:space="preserve">
          <source>A pile-of-files format can be viewed as a key/value database. A key/value database is better than no database at all. But without transactions or indices or a high-level query language or a proper schema, it is much harder and more error prone to use a key/value database than a relational database.</source>
          <target state="translated">파일 더미 형식은 키 / 값 데이터베이스로 볼 수 있습니다. 키 / 값 데이터베이스는 데이터베이스가없는 것보다 낫습니다. 그러나 트랜잭션이나 인덱스, 고급 쿼리 언어 또는 적절한 스키마가 없으면 관계형 데이터베이스보다 키 / 값 데이터베이스를 사용하는 것이 훨씬 어렵고 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="52eaf71372365322d7054ef987ab3062057c54cd" translate="yes" xml:space="preserve">
          <source>A pointer map page</source>
          <target state="translated">포인터 맵 페이지</target>
        </trans-unit>
        <trans-unit id="3b58d729b79685a69c83a9e7290179a156089320" translate="yes" xml:space="preserve">
          <source>A pointer that is forwarded to become the first argument to the callback function.</source>
          <target state="translated">콜백 함수의 첫 번째 인수가되도록 전달되는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7862edef6bec5bc1b7b5c7480359b6ac1ea3fe42" translate="yes" xml:space="preserve">
          <source>A pointer to a callback function which is invoked once for each row in the result of a query. This argument may be NULL, in which case no callbacks will ever be invoked.</source>
          <target state="translated">쿼리 결과의 각 행마다 한 번씩 호출되는 콜백 함수에 대한 포인터입니다. 이 인수는 NULL 일 수 있으며이 경우 콜백이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36a5146ef90ea88c9791d18d9b2f0b91bd10d7bf" translate="yes" xml:space="preserve">
          <source>A pointer to an error string. Error messages are written to space obtained from malloc() and the error string is made to point to the malloced space. The calling function is responsible for freeing this space when it has finished with it. This argument may be NULL, in which case error messages are not reported back to the calling function.</source>
          <target state="translated">오류 문자열에 대한 포인터. 오류 메시지는 malloc ()에서 얻은 공간에 기록되고 오류 문자열은 Malloced 공간을 가리 키도록 만들어집니다. 호출 기능은이 공간을 마치면 해제합니다. 이 인수는 NULL 일 수 있으며,이 경우 오류 메시지가 호출 함수에 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b85ea2771637242c212f75c32dcf4f1c99ff7a4" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;../loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">불투명 한 sqlite3_api_routines 구조에 대한 포인터는 &lt;a href=&quot;../loadext&quot;&gt;로드 가능한 확장의&lt;/a&gt; 진입 점에 세 번째 매개 변수로 전달됩니다 . 일부 플랫폼에서 컴파일러 경고를 해결하려면이 구조를 typedef로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2d07e71fb26035e20fdffa2af9f1c6c108edfd9" translate="yes" xml:space="preserve">
          <source>A pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. This structure must be typedefed in order to work around compiler warnings on some platforms.</source>
          <target state="translated">불투명 한 sqlite3_api_routines 구조에 대한 포인터는 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장의&lt;/a&gt; 진입 점에 세 번째 매개 변수로 전달됩니다 . 일부 플랫폼에서 컴파일러 경고를 해결하려면이 구조를 typedef로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec59a85cc0f126d0446beb84b628cc1897023e1d" translate="yes" xml:space="preserve">
          <source>A pointer to the sqlite structure obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;sqlite_open에&lt;/b&gt; 대한 이전 호출에서 얻은 sqlite 구조에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="a83e616cb2fe97cb47d6b546b005133e60c0010f" translate="yes" xml:space="preserve">
          <source>A pointer to the virtual machine is stored in a pointer which is passed in as the 4th parameter. Space to hold the virtual machine is dynamically allocated. To avoid a memory leak, the calling function must invoke &lt;b&gt;sqlite_finalize&lt;/b&gt; on the virtual machine after it has finished with it. The 4th parameter may be set to NULL if an error is encountered during compilation.</source>
          <target state="translated">가상 머신에 대한 포인터는 네 번째 매개 변수로 전달되는 포인터에 저장됩니다. 가상 머신을 보유 할 공간이 동적으로 할당됩니다. 메모리 누수를 방지하려면 호출 함수는 가상 머신이 완료된 후 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출해야 합니다. 컴파일하는 동안 오류가 발생하면 네 번째 매개 변수가 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4123ec647ffbea69c18e776fd8ad4e58f6d7bab" translate="yes" xml:space="preserve">
          <source>A polygon is defined by its vertexes. Each vertex is a JSON array of two numeric values which are the X and Y coordinates of the vertex. A polygon is a JSON array of at least four of these vertexes, and hence is an array of arrays. The first and last vertex in the array must be the same. The polygon follows the right-hand rule: When tracing a line from one vertex to the next, the area to the right of the line is outside of the polygon and the area to the left is inside the polygon. In other words, the net rotation of the vertexes is counter-clockwise.</source>
          <target state="translated">다각형은 꼭지점으로 정의됩니다. 각 정점은 정점의 X 및 Y 좌표 인 두 개의 숫자 값으로 구성된 JSON 배열입니다. 다각형은 이러한 꼭지점 중 4 개 이상의 JSON 배열이므로 배열 배열입니다. 배열의 첫 번째 정점과 마지막 정점이 같아야합니다. 다각형은 오른쪽 규칙을 따릅니다. 한 정점에서 다음 정점으로 선을 추적 할 때 선의 오른쪽 영역은 다각형 외부에 있고 왼쪽 영역은 다각형 내부에 있습니다. 즉, 꼭지점의 순 회전은 시계 반대 방향입니다.</target>
        </trans-unit>
        <trans-unit id="83be320cc6f7531e133a8fe75643df0ab1bd341d" translate="yes" xml:space="preserve">
          <source>A pragma can take either zero or one argument. The argument is may be either in parentheses or it may be separated from the pragma name by an equal sign. The two syntaxes yield identical results. In many pragmas, the argument is a boolean. The boolean can be one of:</source>
          <target state="translated">pragma는 0 또는 1 개의 인수를 취할 수 있습니다. 인수는 괄호 안에 있거나 pragma 이름과 등호로 구분 될 수 있습니다. 두 구문은 동일한 결과를 생성합니다. 많은 pragma에서 논증은 부울입니다. 부울은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1439b9f8c7100215a693725c95a80144f9686663" translate="yes" xml:space="preserve">
          <source>A pragma may have an optional schema-name before the pragma name. The schema-name is the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database or &quot;main&quot; or &quot;temp&quot; for the main and the TEMP databases. If the optional schema name is omitted, &quot;main&quot; is assumed. In some pragmas, the schema name is meaningless and is simply ignored. In the documentation below, pragmas for which the schema name is meaningful are shown with a &quot;</source>
          <target state="translated">A pragma may have an optional schema-name before the pragma name. The schema-name is the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database or &quot;main&quot; or &quot;temp&quot; for the main and the TEMP databases. If the optional schema name is omitted, &quot;main&quot; is assumed. In some pragmas, the schema name is meaningless and is simply ignored. In the documentation below, pragmas for which the schema name is meaningful are shown with a &quot;</target>
        </trans-unit>
        <trans-unit id="86c8a11b948e6795af6a6ceb139ca3117a5cbdfe" translate="yes" xml:space="preserve">
          <source>A prefix index is a separate index that records the location of all instances of prefix tokens of a certain length in characters used to speed up queries for prefix tokens. For example, optimizing a query for prefix token &quot;abc*&quot; requires a prefix index of three-character prefixes.</source>
          <target state="translated">A prefix index is a separate index that records the location of all instances of prefix tokens of a certain length in characters used to speed up queries for prefix tokens. For example, optimizing a query for prefix token &quot;abc*&quot; requires a prefix index of three-character prefixes.</target>
        </trans-unit>
        <trans-unit id="b552ccb7eeae1cbc2221248d3b23583ca4696c9f" translate="yes" xml:space="preserve">
          <source>A prepared statement can have zero or more open cursors. Each cursor is identified by a small integer, which is usually the P1 parameter to the opcode that uses the cursor. There can be multiple cursors open on the same index or table. All cursors operate independently, even cursors pointing to the same indices or tables. The only way for the virtual machine to interact with a database file is through a cursor. Instructions in the virtual machine can create a new cursor (ex: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; or &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;), read data from a cursor (&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;), advance the cursor to the next entry in the table (ex: &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;), and so forth. All cursors are automatically closed when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">A prepared statement can have zero or more open cursors. Each cursor is identified by a small integer, which is usually the P1 parameter to the opcode that uses the cursor. There can be multiple cursors open on the same index or table. All cursors operate independently, even cursors pointing to the same indices or tables. The only way for the virtual machine to interact with a database file is through a cursor. Instructions in the virtual machine can create a new cursor (ex: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; or &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;), read data from a cursor (&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;), advance the cursor to the next entry in the table (ex: &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;), and so forth. All cursors are automatically closed when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3128db754cafeec12014626682cba0f5822aef4d" translate="yes" xml:space="preserve">
          <source>A primer on &lt;a href=&quot;howitworks&quot;&gt;How SQLite Works&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howitworks&quot;&gt;SQLite의 작동 원리&lt;/a&gt; 에 대한 입문서 .</target>
        </trans-unit>
        <trans-unit id="9e5a41eea2027bd1c81329dfc78cb1162a2b5985" translate="yes" xml:space="preserve">
          <source>A pseudo-table created by this opcode is used to hold a single row output from the sorter so that the row can be decomposed into individual columns using the &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode is the only cursor opcode that works with a pseudo-table.</source>
          <target state="translated">A pseudo-table created by this opcode is used to hold a single row output from the sorter so that the row can be decomposed into individual columns using the &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; opcode is the only cursor opcode that works with a pseudo-table.</target>
        </trans-unit>
        <trans-unit id="5cfba3e1d0f3aba9e4771931b3f9186e0cfec67a" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To defeat the shells automatic graph rendering, simply include extra white space in between any of the &quot;EXPLAIN&quot;, &quot;QUERY&quot;, and/or &quot;PLAN&quot; keywords and the output will appear in a (less helpful) tabular format.</source>
          <target state="translated">A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To defeat the shells automatic graph rendering, simply include extra white space in between any of the &quot;EXPLAIN&quot;, &quot;QUERY&quot;, and/or &quot;PLAN&quot; keywords and the output will appear in a (less helpful) tabular format.</target>
        </trans-unit>
        <trans-unit id="3aa6dc6aaac817be80debe7e4af4df4ff711024e" translate="yes" xml:space="preserve">
          <source>A query plan is represented as a tree. In raw form, as returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, each node of the tree consists of four fields: An integer node id, an integer parent id, an auxiliary integer field that is not currently used, and a description of the node. The entire tree is therefore a table with four columns and zero or more rows. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will usually intercept this table and renders it as an ASCII-art graph for more convenient viewing. To disable the shells automatic graph rendering and to display EXPLAIN QUERY PLAN output in its tabular format, run the command &quot;.explain off&quot; to set the &quot;EXPLAIN formatting mode&quot; to off. To restore automatic graph rendering, run &quot;.explain auto&quot;. You can see the current &quot;EXPLAIN formatting mode&quot; setting using the &quot;.show&quot; command.</source>
          <target state="translated">쿼리 계획은 트리로 표시됩니다. 원시 형식에서 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 반환 된대로 트리의 각 노드는 정수 노드 ID, 정수 부모 ID, 현재 사용되지 않는 보조 정수 필드 및 노드 설명의 4 개 필드로 구성됩니다. 따라서 전체 트리는 4 개의 열과 0 개 이상의 행이있는 테이블입니다. &lt;a href=&quot;cli&quot;&gt;명령 줄 셸은&lt;/a&gt; 일반적으로이 테이블을 차단하고보다 편리하게 볼 수있는 ASCII 예술 그래프로 렌더링됩니다. 쉘 자동 그래프 렌더링을 비활성화하고 EXPLAIN QUERY PLAN 출력을 표 형식으로 표시하려면 &quot;.explain off&quot;명령을 실행하여 &quot;EXPLAIN 형식화 모드&quot;를 꺼짐으로 설정하십시오. 자동 그래프 렌더링을 복원하려면 &quot;.explain auto&quot;를 실행하십시오. 현재 &quot;EXPLAIN 서식 모드&quot;를 볼 수 있습니다.&quot;.show&quot;명령을 사용하여 설정합니다.</target>
        </trans-unit>
        <trans-unit id="987ff31ff0ec375872e214a21f32922e046b143e" translate="yes" xml:space="preserve">
          <source>A query sees all changes that are completed on the same database connection prior to the start of the query, regardless of whether or not those changes have been committed.</source>
          <target state="translated">A query sees all changes that are completed on the same database connection prior to the start of the query, regardless of whether or not those changes have been committed.</target>
        </trans-unit>
        <trans-unit id="91d5213dcc2c8331ce561f8806234820515ddce9" translate="yes" xml:space="preserve">
          <source>A quick enumeration of the changes in SQLite version 3.5.0 is provided here. Subsequent sections will describe these changes in more detail.</source>
          <target state="translated">A quick enumeration of the changes in SQLite version 3.5.0 is provided here. Subsequent sections will describe these changes in more detail.</target>
        </trans-unit>
        <trans-unit id="f1276c60969bd19155a8ae4ef6b0cf70c5a9044f" translate="yes" xml:space="preserve">
          <source>A random nonce for the checksum</source>
          <target state="translated">A random nonce for the checksum</target>
        </trans-unit>
        <trans-unit id="e714ea743566ecda01d0b9ba96c42399b2c76767" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to a write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">읽기 트랜잭션은 읽기 전용으로 사용됩니다. 쓰기 트랜잭션은 읽기와 쓰기를 모두 허용합니다. 읽기 트랜잭션은 SELECT 문에 의해 시작되고 쓰기 트랜잭션은 CREATE, DELETE, DROP, INSERT 또는 UPDATE와 같은 명령문 (통칭 &quot;쓰기 문&quot;)에 의해 시작됩니다. 읽기 트랜잭션이 활성화 된 상태에서 쓰기 문이 발생하면 읽기 트랜잭션이 가능한 경우 쓰기 트랜잭션으로 업그레이드됩니다. 다른 데이터베이스 연결이 이미 데이터베이스를 수정했거나 이미 데이터베이스를 수정하는 중이면 쓰기 트랜잭션으로 업그레이드 할 수 없으며 쓰기 문이 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY로&lt;/a&gt; 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="b3bb741ebe526223297eaf9b1bcbc9817350f52d" translate="yes" xml:space="preserve">
          <source>A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">A read transaction is used for reading only. A write transaction allows both reading and writing. A read transaction is started by a SELECT statement, and a write transaction is started by statements like CREATE, DELETE, DROP, INSERT, or UPDATE (collectively &quot;write statements&quot;). If a write statement occurs while a read transaction is active, then the read transaction is upgraded to write transaction if possible. If some other database connection has already modified the database or is already in the process of modifying the database, then upgrading to a write transaction is not possible and the write statement will fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d3e78c57da493fb53e9af08b8cbcf76787c9e57d" translate="yes" xml:space="preserve">
          <source>A read-only connection that is rebuilding its private heap-memory WAL-index does not hold this lock. (It cannot, since read-only connections are not allowed to hold any exclusive locks.) This lock is only held when rebuilding the global shared WAL-index contained in the memory-mapped SHM file.</source>
          <target state="translated">A read-only connection that is rebuilding its private heap-memory WAL-index does not hold this lock. (It cannot, since read-only connections are not allowed to hold any exclusive locks.) This lock is only held when rebuilding the global shared WAL-index contained in the memory-mapped SHM file.</target>
        </trans-unit>
        <trans-unit id="4cbb00ca2a5b578f8c701ce299cc1bdaf023483d" translate="yes" xml:space="preserve">
          <source>A record contains a header and a body, in that order. The header begins with a single varint which determines the total number of bytes in the header. The varint value is the size of the header in bytes including the size varint itself. Following the size varint are one or more additional varints, one per column. These additional varints are called &quot;serial type&quot; numbers and determine the datatype of each column, according to the following chart:</source>
          <target state="translated">A record contains a header and a body, in that order. The header begins with a single varint which determines the total number of bytes in the header. The varint value is the size of the header in bytes including the size varint itself. Following the size varint are one or more additional varints, one per column. These additional varints are called &quot;serial type&quot; numbers and determine the datatype of each column, according to the following chart:</target>
        </trans-unit>
        <trans-unit id="da56351fba5f53698fda54910e0c1f0207d7d3fd" translate="yes" xml:space="preserve">
          <source>A record might have fewer values than the number of columns in the corresponding table. This can happen, for example, after an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL statement has increased the number of columns in the table schema without modifying preexisting rows in the table. Missing values at the end of the record are filled in using the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; for the corresponding columns defined in the table schema.</source>
          <target state="translated">A record might have fewer values than the number of columns in the corresponding table. This can happen, for example, after an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; SQL statement has increased the number of columns in the table schema without modifying preexisting rows in the table. Missing values at the end of the record are filled in using the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; for the corresponding columns defined in the table schema.</target>
        </trans-unit>
        <trans-unit id="9e5c8169a30113a9ed52f687099166107e7b2523" translate="yes" xml:space="preserve">
          <source>A recursive common table expression can be used to write a query that walks a tree or graph. A recursive common table expression has the same basic syntax as an ordinary common table expression, but with the following additional features:</source>
          <target state="translated">A recursive common table expression can be used to write a query that walks a tree or graph. A recursive common table expression has the same basic syntax as an ordinary common table expression, but with the following additional features:</target>
        </trans-unit>
        <trans-unit id="176317ddd357b266ebf755cfa3f6bc813ff788c9" translate="yes" xml:space="preserve">
          <source>A reference to &lt;b&gt;the associated &lt;i&gt;database connection&lt;/i&gt;&lt;/b&gt;. Each entry in the</source>
          <target state="translated">&lt;b&gt;관련 &lt;i&gt;데이터베이스 연결에&lt;/i&gt;&lt;/b&gt; 대한 참조 입니다. 의 각 항목</target>
        </trans-unit>
        <trans-unit id="e876211f841b1a5a0841faa539bd0f497224e5b7" translate="yes" xml:space="preserve">
          <source>A register can also be &quot;Undefined&quot; meaning that it holds no value at all. Undefined is different from NULL. Depending on compile-time options, an attempt to read an undefined register will usually cause a run-time error. If the code generator (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;) ever generates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that reads an Undefined register, that is a bug in the code generator.</source>
          <target state="translated">레지스터는 &quot;정의되지 않음&quot;일 수도 있으며 이는 값이 전혀 없음을 의미합니다. 정의되지 않음은 NULL과 다릅니다. 컴파일 타임 옵션에 따라 정의되지 않은 레지스터를 읽으려고하면 일반적으로 런타임 오류가 발생합니다. 코드 생성기 ( &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; )가 정의되지 않은 레지스터를 읽는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 생성하는 경우 이는 코드 생성기 의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="2a489dc4470d6b0b8e6fff51584f1f564a2e53cf" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">결과 테이블은 0으로 끝나는 UTF-8 문자열에 대한 포인터 배열입니다. 배열에 (N + 1) * M 요소가 있습니다. 첫 번째 M 포인터는 열 이름이 포함 된 0으로 끝나는 문자열을 가리 킵니다. 나머지 항목은 모두 쿼리 결과를 가리 킵니다. NULL 값은 NULL 포인터가됩니다. 다른 모든 값은 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()에&lt;/a&gt; 의해 반환되는 UTF-8로 끝나는 문자열 표현에 있습니다.</target>
        </trans-unit>
        <trans-unit id="5699300dbfc9bd124afc697b07363b109eb2de77" translate="yes" xml:space="preserve">
          <source>A result table is an array of pointers to zero-terminated UTF-8 strings. There are (N+1)*M elements in the array. The first M pointers point to zero-terminated strings that contain the names of the columns. The remaining entries all point to query results. NULL values result in NULL pointers. All other values are in their UTF-8 zero-terminated string representation as returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;.</source>
          <target state="translated">결과 테이블은 0으로 끝나는 UTF-8 문자열에 대한 포인터 배열입니다. 배열에 (N + 1) * M 요소가 있습니다. 첫 번째 M 포인터는 열 이름이 포함 된 0으로 끝나는 문자열을 가리 킵니다. 나머지 항목은 모두 쿼리 결과를 가리 킵니다. NULL 값은 NULL 포인터가됩니다. 다른 모든 값은 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()에&lt;/a&gt; 의해 반환되는 UTF-8로 끝나는 문자열 표현에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c7b119b5d4d81d6f920e05ce966ec036ccb516b" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">결과 테이블은 하나 이상의 메모리 할당으로 구성 될 수 있습니다. 결과 테이블을 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()로&lt;/a&gt; 직접 전달하는 것은 안전하지 않습니다 . &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table ()을&lt;/a&gt; 사용하여 결과 테이블을 할당 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b9f7610b427ba3a5db84c1d578ca567b66e4baef" translate="yes" xml:space="preserve">
          <source>A result table might consist of one or more memory allocations. It is not safe to pass a result table directly to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. A result table should be deallocated using &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt;.</source>
          <target state="translated">결과 테이블은 하나 이상의 메모리 할당으로 구성 될 수 있습니다. 결과 테이블을 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()로&lt;/a&gt; 직접 전달하는 것은 안전하지 않습니다 . &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table ()을&lt;/a&gt; 사용하여 결과 테이블을 할당 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c8be34ce66bc36d8a3f910227d25c082cf34040" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step ()에서 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 의 리턴은 영구적 오류가 아니며 sqlite3_backup_finish ()의 리턴 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3ccc60d216c44abcc74c0cabe1a2c3a2883ce18" translate="yes" xml:space="preserve">
          <source>A return of &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; or &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; from sqlite3_backup_step() is not a permanent error and does not affect the return value of sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step ()에서 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 의 리턴은 영구적 오류가 아니며 sqlite3_backup_finish ()의 리턴 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79663f33ba3ea21585830534cfcf02f738ed2ade" translate="yes" xml:space="preserve">
          <source>A rich library of &lt;a href=&quot;lang_corefunc&quot;&gt;standard SQL functions&lt;/a&gt;</source>
          <target state="translated">풍부한 &lt;a href=&quot;lang_corefunc&quot;&gt;표준 SQL 함수&lt;/a&gt; 라이브러리</target>
        </trans-unit>
        <trans-unit id="5984037d329bed4e182dea84884ebbc957606423" translate="yes" xml:space="preserve">
          <source>A rollback journal header is padded with zeros out to the size of a single sector (as defined by the sector size integer at offset 20). The header is in a sector by itself so that if a power loss occurs while writing the sector, information that follows the header will be (hopefully) undamaged.</source>
          <target state="translated">롤백 저널 헤더는 단일 섹터의 크기에 오프셋이 0으로 채워집니다 (오프셋 20의 섹터 크기 정수로 정의 됨). 헤더는 자체적으로 섹터에 있으므로 섹터를 쓰는 동안 전력 손실이 발생하면 헤더 뒤에 오는 정보가 손상되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="da825d373397b8ff214c898f7100fa92209fe481" translate="yes" xml:space="preserve">
          <source>A rollback journal is a &quot;hot&quot; journal if all of the following are true:</source>
          <target state="translated">롤백 저널은 다음 모두에 해당하는 경우 &quot;핫&quot;저널입니다.</target>
        </trans-unit>
        <trans-unit id="93117b5d93400d4aff3d9fc5e17e1f968466bd65" translate="yes" xml:space="preserve">
          <source>A rollback journal is a temporary file used to implement atomic commit and rollback capabilities in SQLite. (For a detailed discussion of how this works, see the separate document titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt;.) The rollback journal is always located in the same directory as the database file and has the same name as the database file except with the 8 characters &quot;&lt;b&gt;-journal&lt;/b&gt;&quot; appended. The rollback journal is usually created when a transaction is first started and is usually deleted when a transaction commits or rolls back. The rollback journal file is essential for implementing the atomic commit and rollback capabilities of SQLite. Without a rollback journal, SQLite would be unable to rollback an incomplete transaction, and if a crash or power loss occurred in the middle of a transaction the entire database would likely go corrupt without a rollback journal.</source>
          <target state="translated">롤백 저널은 SQLite에서 원자 커밋 및 롤백 기능을 구현하는 데 사용되는 임시 파일입니다. (이 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 라는 별도의 문서를 참조하십시오 .) 롤백 저널은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 8 자 &quot;를 제외하고 데이터베이스 파일과 이름이 같습니다. &lt;b&gt;-일지&lt;/b&gt;롤백 저널은 일반적으로 트랜잭션이 처음 시작될 때 작성되며 일반적으로 트랜잭션이 커밋 또는 롤백 될 때 삭제됩니다. 롤백 저널 파일은 SQLite의 원자 적 커밋 및 롤백 기능을 구현하는 데 필수적입니다. 롤백 저널이 없으면 SQLite 불완전한 트랜잭션을 롤백 할 수 없으며 트랜잭션 중간에 충돌 또는 전원 손실이 발생하면 롤백 저널이 없으면 전체 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f61ea74ecbbdde9b91ead35df3827efa60778b" translate="yes" xml:space="preserve">
          <source>A rollback journal is only considered to be valid if it exists and contains a valid header. Hence a transaction can be committed in one of three ways:</source>
          <target state="translated">롤백 저널은 존재하고 유효한 헤더를 포함하는 경우에만 유효한 것으로 간주됩니다. 따라서 다음 세 가지 방법 중 하나로 트랜잭션을 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbab471bf381ac51a7c14fe650ef7023a98cf57" translate="yes" xml:space="preserve">
          <source>A rollback journal is said to be &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot&lt;/a&gt; if it needs to be rolled back in order to restore the integrity of its database. A hot journal is created when a process is in the middle of a database update and a program or operating system crash or power failure prevents the update from completing. Hot journals are an exception condition. Hot journals exist to recover from crashes and power failures. If everything is working correctly (that is, if there are no crashes or power failures) you will never get a hot journal.</source>
          <target state="translated">롤백 저널은 데이터베이스의 무결성을 복원하기 위해 롤백해야하는 경우 &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;핫&lt;/a&gt; 상태라고합니다. 프로세스가 데이터베이스 업데이트 도중에있을 때 핫 저널이 만들어지고 프로그램 또는 운영 체제 충돌 또는 정전으로 인해 업데이트가 완료되지 않습니다. 인기 저널은 예외 조건입니다. 핫 저널은 충돌 및 정전으로부터 복구하기 위해 존재합니다. 모든 것이 올바르게 작동하는 경우 (즉, 충돌 또는 정전이없는 경우) 저널이 뜨지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52857503386ca8187f9c97fd4ff05410c36c8f77" translate="yes" xml:space="preserve">
          <source>A running SELECT statement that lacks a FROM clause (or any other statement that never reads or writes from any database file) will not prevent a read transaction from closing.</source>
          <target state="translated">FROM 절 (또는 데이터베이스 파일에서 읽거나 쓰지 않는 다른 명령문)이없는 실행중인 SELECT 문으로 인해 읽기 트랜잭션이 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cb07d260e238ef8be6278670ca8159f485f6d07" translate="yes" xml:space="preserve">
          <source>A separate document, &lt;a href=&quot;c3ref/intro&quot;&gt;The SQLite C/C++ Interface&lt;/a&gt;, provides detailed specifications for all C/C++ APIs for SQLite. Once the reader understands the basic principles of operation for SQLite, &lt;a href=&quot;c3ref/intro&quot;&gt;that document&lt;/a&gt; should be used as a reference guide. This article is intended as introduction only and is neither a complete nor authoritative reference for the SQLite API.</source>
          <target state="translated">별도의 문서 인 &lt;a href=&quot;c3ref/intro&quot;&gt;SQLite C / C ++ 인터페이스는 SQLite의&lt;/a&gt; 모든 C / C ++ API에 대한 세부 스펙을 제공합니다. 독자가 SQLite의 기본 작동 원리를 이해하면 &lt;a href=&quot;c3ref/intro&quot;&gt;해당 문서&lt;/a&gt; 를 참조 안내서로 사용해야합니다. 이 기사는 단지 소개를 목적으로하며 SQLite API에 대한 완전하거나 권위있는 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="baa6b5660e49902a9d6721951328be3eefc3b18e" translate="yes" xml:space="preserve">
          <source>A sequence number assigned to each index for internal tracking purposes.</source>
          <target state="translated">내부 추적 목적으로 각 색인에 지정된 순서 번호.</target>
        </trans-unit>
        <trans-unit id="1ac44a9b2150727d7d1aea70b509f77cbf75e147" translate="yes" xml:space="preserve">
          <source>A series of tests were run to measure the relative performance of SQLite 2.7.6, PostgreSQL 7.1.3, and MySQL 3.23.41. The following are general conclusions drawn from these experiments:</source>
          <target state="translated">SQLite 2.7.6, PostgreSQL 7.1.3 및 MySQL 3.23.41의 상대적 성능을 측정하기 위해 일련의 테스트가 실행되었습니다. 다음은이 실험에서 얻은 일반적인 결론입니다.</target>
        </trans-unit>
        <trans-unit id="b4faee13d5e4cc6ba30a1f6541864d69478d0a60" translate="yes" xml:space="preserve">
          <source>A serious bug fixed on Windows. Windows users should upgrade. No impact to Unix.</source>
          <target state="translated">Windows에서 해결 된 심각한 버그. Windows 사용자는 업그레이드해야합니다. 유닉스에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="275829adb94b5831ffff4998c0fd3b6cdf2a2059" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_master&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">위에서 설명한 수동 임 포스터 테이블 방식의 심각한 문제점은 &quot;sqlite_master&quot;테이블에 새 &quot;t2&quot;항목을 추가 한 후 데이터베이스 파일이 기술적으로 손상된다는 것입니다. &quot;t1bc&quot;인덱스와 &quot;t2&quot;테이블은 모두 동일한 b- 트리를 가리 킵니다. &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 실행을 피해야하지만 즉각적인 문제는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b3a86e163a24ba3d737d0e6d5f37de76bb1d3304" translate="yes" xml:space="preserve">
          <source>A serious problem with the manual imposter table approach described above is that after adding the new &quot;t2&quot; entry to the &quot;sqlite_schema&quot; table, the database file will technically be corrupt. Both the &quot;t1bc&quot; index and the &quot;t2&quot; table will point to the same b-tree. This will not cause any immediate problems, though one should avoid running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">위에서 설명한 수동 가짜 테이블 접근 방식의 심각한 문제는 &quot;sqlite_schema&quot;테이블에 새 &quot;t2&quot;항목을 추가 한 후 데이터베이스 파일이 기술적으로 손상된다는 것입니다. &quot;t1bc&quot;인덱스와 &quot;t2&quot;테이블은 모두 동일한 b- 트리를 가리 킵니다. 이것은 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 실행을 피해야하지만 즉각적인 문제를 일으키지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="45dc320cdb9816a2a39a9f3943b5295b82ce63f3" translate="yes" xml:space="preserve">
          <source>A session object (type sqlite3_session*) is created by making a call to the &lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; API function.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; API 함수를 호출하여 세션 오브젝트 (sqlite3_session * 유형)가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2fc199170ebe2ff874f6db2f5e7dced1a879c2ec" translate="yes" xml:space="preserve">
          <source>A set of SQL constraints for each table. SQLite supports UNIQUE, NOT NULL, CHECK and FOREIGN KEY constraints.</source>
          <target state="translated">각 테이블에 대한 SQL 제한 조건 세트. SQLite는 UNIQUE, NOT NULL, CHECK 및 FOREIGN KEY 제약 조건을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b9ec162401bfb188342d12868912e1becc54935f" translate="yes" xml:space="preserve">
          <source>A signed 64-bit integer</source>
          <target state="translated">부호있는 64 비트 정수</target>
        </trans-unit>
        <trans-unit id="a7e9fa36fa007a2f469e4a4760e755754b6f4660" translate="yes" xml:space="preserve">
          <source>A simple example of a shim is the &quot;vfstrace&quot; VFS. This is a VFS (implemented in the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt; source file) that writes a message associated with each VFS method call into a log file, then passes control off to another VFS to do the actual work.</source>
          <target state="translated">shim의 간단한 예는 &quot;vfstrace&quot;VFS입니다. VFS ( &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c&quot;&gt;test_vfstrace.c&lt;/a&gt; 소스 파일 에서 구현 됨 )는 각 VFS 메서드 호출과 관련된 메시지를 로그 파일에 기록한 다음 다른 VFS로 제어를 전달하여 실제 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7006cbe04f6d24543c2da75c91c78320fed7444e" translate="yes" xml:space="preserve">
          <source>A single CREATE VIRTUAL TABLE statement may contain any number of SQL parameters.</source>
          <target state="translated">단일 CREATE VIRTUAL TABLE 문에는 여러 개의 SQL 매개 변수가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62311c4f8d538cb3c9b6fb7e004b99ac7cc9aab4" translate="yes" xml:space="preserve">
          <source>A single WAL file can be reused multiple times. In other words, the WAL can fill up with frames and then be checkpointed and then new frames can overwrite the old ones. A WAL always grows from beginning toward the end. Checksums and counters attached to each frame are used to determine which frames within the WAL are valid and which are leftovers from prior checkpoints.</source>
          <target state="translated">단일 WAL 파일을 여러 번 재사용 할 수 있습니다. 다시 말해, WAL은 프레임으로 채워진 다음 체크 포인트되고 새 프레임이 이전 프레임을 덮어 쓸 수 있습니다. WAL은 항상 처음부터 끝까지 커집니다. 각 프레임에 연결된 체크섬과 카운터는 WAL 내의 어떤 프레임이 유효하고 이전 체크 포인트에서 남은 프레임을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8785683b4ed7102093caaeccc3a5196c51a5907f" translate="yes" xml:space="preserve">
          <source>A single changeset may contain changes that apply to more than one database table. For each table that the changeset includes at least one change for, it also encodes the following data:</source>
          <target state="translated">단일 변경 세트에는 둘 이상의 데이터베이스 테이블에 적용되는 변경 사항이 포함될 수 있습니다. 변경 집합에 하나 이상의 변경 내용이 포함 된 각 테이블에 대해 다음 데이터도 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="608ce0bf9e63bfc85403ac0271b130acd58c64d6" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">단일 데이터베이스 핸들은 한 번에 최대 하나의 미리 쓰기 로그 콜백을 등록 할 수 있습니다. &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 호출 하면 이전에 등록 된 미리 쓰기 로그 콜백이 대체됩니다. 참고 그 &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그&lt;/a&gt; 호출의 두 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 및 사전 덮어 쓰게됩니다 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()를&lt;/a&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="89206c073889a1c1170a0ebb7406a8fb98a4806a" translate="yes" xml:space="preserve">
          <source>A single database handle may have at most a single write-ahead log callback registered at one time. Calling &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; replaces any previously registered write-ahead log callback. Note that the &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; interface and the &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; both invoke &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; and will overwrite any prior &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; settings.</source>
          <target state="translated">단일 데이터베이스 핸들은 한 번에 최대 하나의 미리 쓰기 로그 콜백을 등록 할 수 있습니다. &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 호출 하면 이전에 등록 된 미리 쓰기 로그 콜백이 대체됩니다. 참고 그 &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint 프라그&lt;/a&gt; 호출의 두 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 및 사전 덮어 쓰게됩니다 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()를&lt;/a&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="bae717677f5ddab7e1611867390ac460d23c6cd8" translate="yes" xml:space="preserve">
          <source>A single function declaration should contain no more than one of the following: &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">: 하나의 함수 선언은 더 이상 다음 중 하나 이상 포함되어야합니다 &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt; , &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt; , 또는 &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e26df4d33430b6b34c4d91859f0ec1b63873b0b8" translate="yes" xml:space="preserve">
          <source>A single phrase or NEAR group may be restricted to matching text within a specified column of the FTS table by prefixing it with the column name followed by a colon character. Or to a set of columns by prefixing it with a whitespace separated list of column names enclosed in parenthesis (&quot;curly brackets&quot;) followed by a colon character. Column names may be specified using either of the two forms described for strings above. Unlike strings that are part of phrases, column names are not passed to the tokenizer module. Column names are case-insensitive in the usual way for SQLite column names - upper/lower case equivalence is understood for ASCII-range characters only.</source>
          <target state="translated">단일 문구 또는 NEAR 그룹은 FTS 테이블의 지정된 열 내에서 텍스트 앞에 열 이름과 콜론 문자를 붙여서 일치하는 텍스트로 제한 될 수 있습니다. 또는 괄호 ( &quot;중괄호&quot;)로 묶인 공백으로 구분 된 열 이름 목록과 콜론 문자로 접두어를 붙여 열 집합에 추가하십시오. 열 이름은 위의 문자열에 대해 설명 된 두 가지 형식 중 하나를 사용하여 지정할 수 있습니다. 문구의 일부인 문자열과 달리 열 이름은 토크 나이저 모듈로 전달되지 않습니다. 열 이름은 SQLite 열 이름에 대해 일반적인 방식으로 대소 문자를 구분하지 않습니다. 대소 문자의 동등성은 ASCII 범위 문자에 대해서만 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="957ff29feb802c055a16b8a1e4c52a503d6ee8db" translate="yes" xml:space="preserve">
          <source>A single session object monitors changes made to a single database (i.e. &quot;main&quot;, &quot;temp&quot; or an attached database) via a single sqlite3* database handle.</source>
          <target state="translated">단일 세션 객체는 단일 sqlite3 * 데이터베이스 핸들을 통해 단일 데이터베이스 (예 : &quot;main&quot;, &quot;temp&quot;또는 연결된 데이터베이스)에 대한 변경 사항을 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="1707c93eb5e5ee6c5b850e9748ead9054742daf0" translate="yes" xml:space="preserve">
          <source>A small patch to version 3.6.16 to fix &lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;the OP_If bug&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/src/info/6b00e0a34c&quot;&gt;OP_If 버그&lt;/a&gt; 를 수정하기위한 3.6.16 버전의 작은 패치 .</target>
        </trans-unit>
        <trans-unit id="d37282f44ff8f219293b2945eedcfa47898899c4" translate="yes" xml:space="preserve">
          <source>A smaller and faster implementation of text to floating-point conversion subroutine: sqlite3AtoF().</source>
          <target state="translated">텍스트 대 부동 소수점 변환 서브 루틴의보다 작고 빠른 구현 : sqlite3AtoF ().</target>
        </trans-unit>
        <trans-unit id="9e409edf566363994702e2aef11edf00e8d07606" translate="yes" xml:space="preserve">
          <source>A special SQL function RAISE() may be used within a trigger-program, with the following syntax</source>
          <target state="translated">특수 SQL 함수 RAISE ()는 다음 구문으로 트리거 프로그램 내에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a6631c65b5f7328388f2b5ccd5678cd79d4fa1" translate="yes" xml:space="preserve">
          <source>A stale master journal is a master journal that is no longer being used for anything. There is no requirement that stale master journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="translated">오래된 마스터 저널은 더 이상 사용되지 않는 마스터 저널입니다. 오래된 마스터 저널을 삭제할 필요는 없습니다. 그렇게하는 유일한 이유는 디스크 공간을 확보하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d496d822cbfbcef6fd2f26cb43721e4d7db1958" translate="yes" xml:space="preserve">
          <source>A stale super-journal is a super-journal that is no longer being used for anything. There is no requirement that stale super-journals be deleted. The only reason for doing so is to free up disk space.</source>
          <target state="translated">오래된 슈퍼 저널은 더 이상 어떤 용도로도 사용되지 않는 슈퍼 저널입니다. 오래된 슈퍼 저널을 삭제할 필요는 없습니다. 이렇게하는 유일한 이유는 디스크 공간을 확보하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7ebc788dee352b396a0729f45e60a8dfd65ce42" translate="yes" xml:space="preserve">
          <source>A standard SQLite build includes a small amount of logic associated with &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; to exercise parts of the SQLite core that are otherwise difficult to validate. This compile-time option omits that extra testing logic. This compile-time option was called &quot;SQLITE_OMIT_BUILTIN_TEST&quot; prior to SQLite version 3.16.0 (2017-01-02). The name was changed to better describe the implications of using it.</source>
          <target state="translated">표준 SQLite 빌드에는 &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 과 관련된 소량의 로직이 포함되어있어 달리 검증하기 어려운 SQLite 코어의 일부를 실행합니다. 이 컴파일 타임 옵션은 추가 테스트 로직을 생략합니다. 이 컴파일 타임 옵션은 SQLite 버전 3.16.0 (2017-01-02) 이전에 &quot;SQLITE_OMIT_BUILTIN_TEST&quot;라고합니다. 이름이 사용의 의미를보다 잘 설명하기 위해 이름이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="61a7a7e55f6d9bd17dba85ad11c8944fbcdc4459" translate="yes" xml:space="preserve">
          <source>A starting frame boundary,</source>
          <target state="translated">시작 프레임 경계</target>
        </trans-unit>
        <trans-unit id="37fb198dfcb0d142d377ce0e169267e9a1cdfccb" translate="yes" xml:space="preserve">
          <source>A statement journal file is used to rollback partial results of a single statement within a larger transaction. For example, suppose an UPDATE statement will attempt to modify 100 rows in the database. But after modifying the first 50 rows, the UPDATE hits a constraint violation which should block the entire statement. The statement journal is used to undo the first 50 row changes so that the database is restored to the state it was in at the start of the statement.</source>
          <target state="translated">명령문 저널 파일은 더 큰 트랜잭션 내에서 단일 명령문의 부분 결과를 롤백하는 데 사용됩니다. 예를 들어, UPDATE 문이 데이터베이스에서 100 개의 행을 수정하려고 시도한다고 가정하십시오. 그러나 처음 50 개 행을 수정 한 후 UPDATE는 제약 조건 위반으로 인해 전체 문을 차단해야합니다. 명령문 저널은 데이터베이스가 명령문 시작시의 상태로 복원되도록 처음 50 개의 행 변경 사항을 실행 취소하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="940c3a5de694a1d82ab455c32b9b6bed30de5212" translate="yes" xml:space="preserve">
          <source>A statement journal is only created for an UPDATE or INSERT statement that might change multiple rows of a database and which might hit a constraint or a RAISE exception within a trigger and thus need to undo partial results. If the UPDATE or INSERT is not contained within BEGIN...COMMIT and if there are no other active statements on the same database connection then no statement journal is created since the ordinary rollback journal can be used instead. The statement journal is also omitted if an alternative &lt;a href=&quot;lang_conflict&quot;&gt;conflict resolution algorithm&lt;/a&gt; is used. For example:</source>
          <target state="translated">명령문 저널은 데이터베이스의 여러 행을 변경하고 트리거 내에서 제한 조건 또는 RAISE 예외를 발생시켜 부분 결과를 실행 취소해야하는 UPDATE 또는 INSERT 문에 대해서만 작성됩니다. UPDATE 또는 INSERT가 BEGIN ... COMMIT에 포함되어 있지 않고 동일한 데이터베이스 연결에 다른 활성 명령문이없는 경우 일반 롤백 저널을 대신 ​​사용할 수 있으므로 명령문 저널이 작성되지 않습니다. 대체 &lt;a href=&quot;lang_conflict&quot;&gt;충돌 해결 알고리즘&lt;/a&gt; 을 사용 하는 경우 명령문 저널도 생략 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d0a69ee154fd724c3f7e2b66c07110e679818fe" translate="yes" xml:space="preserve">
          <source>A statement such as the above can be run immediately prior to invoking &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; to confirm that all prepared statements have been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; and to help identify and track down prepared statements that have &quot;leaked&quot; and missed finalization.</source>
          <target state="translated">위와 같은 명령문은 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하기 직전에 실행 되어 모든 준비된 명령문이 &lt;a href=&quot;c3ref/finalize&quot;&gt;완료&lt;/a&gt; 되었는지 확인하고 &quot;누설&quot;되어 종료되지 않은 준비된 명령문을 식별하고 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e2d7eae4ab34999aac0e06cf630caa26eca256" translate="yes" xml:space="preserve">
          <source>A storage class is more general than a datatype. The INTEGER storage class, for example, includes 6 different integer datatypes of different lengths. This makes a difference on disk. But as soon as INTEGER values are read off of disk and into memory for processing, they are converted to the most general datatype (8-byte signed integer). And so for the most part, &quot;storage class&quot; is indistinguishable from &quot;datatype&quot; and the two terms can be used interchangeably.</source>
          <target state="translated">스토리지 클래스는 데이터 유형보다 일반적입니다. 예를 들어, INTEGER 스토리지 클래스에는 길이가 다른 6 개의 서로 다른 정수 데이터 유형이 포함됩니다. 이것은 디스크에 차이를 만듭니다. 그러나 INTEGER 값이 디스크에서 처리를 위해 메모리로 읽히자 마자 가장 일반적인 데이터 유형 (8 바이트 부호있는 정수)으로 변환됩니다. 따라서 대부분 &quot;스토리지 클래스&quot;는 &quot;데이터 유형&quot;과 구별 할 수 없으며 두 용어를 서로 바꿔서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7675d21b606912c9ad81d09f8bd030b6fb973bc2" translate="yes" xml:space="preserve">
          <source>A straightforward implementation of a spelling corrector would be to compare the search term against every word in the vocabulary and select the 20 with the lowest scores. However, there will typically be hundreds of thousands or millions of words in the vocabulary, and so this approach is not fast enough.</source>
          <target state="translated">맞춤법 교정기의 간단한 구현은 검색 용어를 어휘의 모든 단어와 비교하고 점수가 가장 낮은 20을 선택하는 것입니다. 그러나 어휘에는 일반적으로 수십만 또는 수백만 단어가 있으므로이 방법은 충분히 빠르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaf0250c67cab7be0dc1ee87f425a759227d1fab" translate="yes" xml:space="preserve">
          <source>A string constant is formed by enclosing the string in single quotes ('). A single quote within the string can be encoded by putting two single quotes in a row - as in Pascal. C-style escapes using the backslash character are not supported because they are not standard SQL.</source>
          <target state="translated">문자열 상수는 문자열을 작은 따옴표 ( ')로 묶어 형성합니다. 파스칼에서와 같이 문자열 내에 작은 따옴표를 두 개의 작은 따옴표를 넣어서 인코딩 할 수 있습니다. 백 슬래시 문자를 사용하는 C 스타일 이스케이프는 표준 SQL이 아니므로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="833d0cdbb5e0f11e62e7535fa2b560860c4b3b41" translate="yes" xml:space="preserve">
          <source>A string might look like a floating-point literal with a decimal point and/or exponent notation but as long as the value can be expressed as an integer, the NUMERIC affinity will convert it into an integer. Hence, the string '3.0e+5' is stored in a column with NUMERIC affinity as the integer 300000, not as the floating point value 300000.0.</source>
          <target state="translated">문자열은 소수점 및 / 또는 지수 표기법이있는 부동 소수점 리터럴처럼 보일 수 있지만 값이 정수로 표현 될 수있는 한 NUMERIC 선호도는 문자열을 정수로 변환합니다. 따라서 문자열 '3.0e + 5'는 부동 소수점 값 300000.0이 아닌 정수 300000으로 NUMERIC 선호도를 가진 열에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8190afbd8c6bbd11bbd6c14f28a0172cbb480b3c" translate="yes" xml:space="preserve">
          <source>A subquery expression with two or more result columns.</source>
          <target state="translated">둘 이상의 결과 열이있는 하위 쿼리 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="5635ec05c69c3ce96a3233f42069b4904d399309" translate="yes" xml:space="preserve">
          <source>A subquery on the right-hand side of IN operator must often be materialized. For example:</source>
          <target state="translated">IN 연산자의 오른쪽에있는 하위 쿼리는 종종 구체화되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c0661a4bdbca6636faba7e3ce330659e6cc7c97" translate="yes" xml:space="preserve">
          <source>A subquery that returns a single column is a scalar subquery and can be used most anywhere. A subquery that returns two or more columns is a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; subquery and can only be used as the operand of a comparison operator.</source>
          <target state="translated">단일 열을 반환하는 하위 쿼리는 스칼라 하위 쿼리이며 어디에서나 사용할 수 있습니다. 둘 이상의 열을 반환하는 하위 쿼리는 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 하위 쿼리이며 비교 연산자의 피연산자로만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513c8fcc36f3dbb3fe1ba2919acd7ef31b0580f6" translate="yes" xml:space="preserve">
          <source>A successful invocation of this method will cause *pRowid to be filled with the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of row that the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; pCur is currently pointing at. This method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. It returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">이 메소드를 성공적으로 호출 하면 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;가상 테이블 커서&lt;/a&gt; pCur가 현재 가리키는 행 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 로 * pRowid가 채워집니다 . 이 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . 실패시 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e843c0218f6351825674391272a0db4bb8db636e" translate="yes" xml:space="preserve">
          <source>A super-journal is stale if no individual file journals are pointing to it. To figure out if a super-journal is stale, we first read the super-journal to obtain the names of all of its file journals. Then we check each of those file journals. If any of the file journals named in the super-journal exists and points back to the super-journal, then the super-journal is not stale. If all file journals are either missing or refer to other super-journals or no super-journal at all, then the super-journal we are testing is stale and can be safely deleted.</source>
          <target state="translated">슈퍼 저널은 개별 파일 저널이 가리 키지 않는 경우 부실한 것입니다. 수퍼 저널이 오래된 것인지 알아 내기 위해 먼저 수퍼 저널을 읽고 모든 파일 저널의 이름을 얻습니다. 그런 다음 각 파일 저널을 확인합니다. 수퍼 저널에 이름이 지정된 파일 저널이 존재하고 수퍼 저널을 다시 가리키는 경우 수퍼 저널은 부실하지 않습니다. 모든 파일 저널이 누락되었거나 다른 수퍼 저널을 참조하거나 수퍼 저널이 전혀없는 경우 테스트중인 수퍼 저널이 오래되어 안전하게 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a876cbac258b205fceef1496fbc66fdbd28a83e7" translate="yes" xml:space="preserve">
          <source>A swarmvtab table has the same schema as each of its component tables.</source>
          <target state="translated">swarmvtab 테이블에는 각 구성 요소 테이블과 동일한 스키마가 있습니다.</target>
        </trans-unit>
        <trans-unit id="24f9af565c085a8964740fe3fa13a54013369f70" translate="yes" xml:space="preserve">
          <source>A swarmvtab virtual table is created as follows:</source>
          <target state="translated">swarmvtab 가상 테이블은 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3b6e57942158b2ce08f2d6299decb29e664e48f" translate="yes" xml:space="preserve">
          <source>A table b-tree interior page</source>
          <target state="translated">테이블 b- 트리 인테리어 페이지</target>
        </trans-unit>
        <trans-unit id="bcb5ce26b9e5292874c4f103c523b7155ab1d3d5" translate="yes" xml:space="preserve">
          <source>A table b-tree leaf page</source>
          <target state="translated">테이블 b- 트리 리프 페이지</target>
        </trans-unit>
        <trans-unit id="1e18698afc8eb8fd55a13d0d4739a4898ecead4e" translate="yes" xml:space="preserve">
          <source>A table created using CREATE TABLE AS has no PRIMARY KEY and no constraints of any kind. The default value of each column is NULL. The default collation sequence for each column of the new table is BINARY.</source>
          <target state="translated">CREATE TABLE AS를 사용하여 작성된 테이블에는 PRIMARY KEY가 없으며 모든 종류의 제한 조건이 없습니다. 각 열의 기본값은 NULL입니다. 새 테이블의 각 열에 대한 기본 데이터 정렬 순서는 BINARY입니다.</target>
        </trans-unit>
        <trans-unit id="2722d24833adf5b38fd57107e3991ba2e3c139c1" translate="yes" xml:space="preserve">
          <source>A table of insertion, deletion, and substitution costs can be provided by the application.</source>
          <target state="translated">응용 프로그램에서 삽입, 삭제 및 대체 비용 테이블을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d688ea9d1619e762c6e53a152855aec30c051d2" translate="yes" xml:space="preserve">
          <source>A table with the name &quot;sqlite_sequence&quot; that is used to keep track of the maximum historical &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for a table using &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT를&lt;/a&gt; 사용하여 테이블 의 최대 히스토리 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 를 추적하는 데 사용되는 이름이 &quot;sqlite_sequence&quot;인 테이블 .</target>
        </trans-unit>
        <trans-unit id="a57714ccd156bf9e3f87fe308936736e98e591aa" translate="yes" xml:space="preserve">
          <source>A table-valued function, which provides read-only access to existing archives, either from the file-system or in-memory.</source>
          <target state="translated">파일 시스템 또는 메모리 내에서 기존 아카이브에 대한 읽기 전용 액세스를 제공하는 테이블 반환 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a7fc019c02a91fed82d92a06336ce9b17ea402c2" translate="yes" xml:space="preserve">
          <source>A template loadable extension contains the following three elements:</source>
          <target state="translated">템플릿로드 가능한 확장에는 다음 세 가지 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8ceeadc33088d54343486462a0c9aba5dbbc0128" translate="yes" xml:space="preserve">
          <source>A template virtual table implementation useful as a starting point for developers who want to write their own virtual tables</source>
          <target state="translated">자신의 가상 테이블을 작성하려는 개발자에게 시작점으로 유용한 템플릿 가상 테이블 구현</target>
        </trans-unit>
        <trans-unit id="cab32d076f372c6b13570208a924360640dda14f" translate="yes" xml:space="preserve">
          <source>A temporary index is always used to hold the values of the right-hand side of an IN operator when that right-hand side is a list of values.</source>
          <target state="translated">오른쪽이 값 목록 인 경우 IN 연산자의 오른쪽 값을 보유하기 위해 임시 색인이 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee92b6976c5d4721278b029adeafc2db008e6cdc" translate="yes" xml:space="preserve">
          <source>A term is a contiguous sequence of eligible characters, where eligible characters are all alphanumeric characters and all characters with Unicode codepoint values greater than or equal to 128. All other characters are discarded when splitting a document into terms. Their only contribution is to separate adjacent terms.</source>
          <target state="translated">용어는 연속되는 적합한 문자 시퀀스입니다. 여기서 적합한 문자는 모두 영숫자 문자이고 유니 코드 코드 포인트 값이 128보다 크거나 같은 모든 문자입니다. 문서를 용어로 분리하면 다른 모든 문자는 삭제됩니다. 그들의 유일한 기여는 인접한 용어를 분리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bdd3e37ef65b6b87adc2cbe96c6048ce8be9f761" translate="yes" xml:space="preserve">
          <source>A text editor of the user's choice supporting UTF-8 text.</source>
          <target state="translated">UTF-8 텍스트를 지원하는 사용자가 선택한 텍스트 편집기.</target>
        </trans-unit>
        <trans-unit id="739cfe03c5105216274ffacf61131b06ede6508f" translate="yes" xml:space="preserve">
          <source>A text value created by casting a blob that begins with the two bytes 0xFF and 0xFE, in either possible order, is inserted into an FTS3 table. For example:</source>
          <target state="translated">2 바이트 0xFF 및 0xFE로 시작하는 Blob을 가능한 순서로 캐스팅하여 만든 텍스트 값이 FTS3 테이블에 삽입됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="52d6801cd3f12d6898833bf9ca6bab5539cfae7b" translate="yes" xml:space="preserve">
          <source>A time string can be in any of the following formats:</source>
          <target state="translated">시간 문자열은 다음 형식 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8aa525971c9057cebec913efdec9452b2a87880" translate="yes" xml:space="preserve">
          <source>A tokenizer is used that recognizes byte-order-marks as whitespace. (The default &quot;simple&quot; tokenizer for FTS3/4 does not think that BOMs are whitespace, but the unicode tokenizer does.)</source>
          <target state="translated">바이트 순서 표시를 공백으로 인식하는 토크 나이저가 사용됩니다. (FTS3 / 4의 기본 &quot;단순&quot;토크 나이 저는 BOM이 공백이라고 생각하지 않지만 유니 코드 토크 나이 저는 그렇습니다.)</target>
        </trans-unit>
        <trans-unit id="0d86f49b9040272a60a55ad61e8ad5131c63f59c" translate="yes" xml:space="preserve">
          <source>A torn page occurs when a database page is larger than a disk sector, the database page is written to disk, but a power loss occurs prior to all sectors of the database page being written. Then, upon recovery, part of the database page will have the old content while some other parts of the page will have the new content. Some database engines assume that page writes are atomic and hence a torn page is an unrecoverable error.</source>
          <target state="translated">데이터베이스 페이지가 디스크 섹터보다 크면 데이터베이스 페이지가 디스크에 기록되지만 데이터베이스 페이지의 모든 섹터가 기록되기 전에 전원 손실이 발생합니다. 그런 다음 복구시 데이터베이스 페이지의 일부에는 이전 컨텐츠가 있고 페이지의 다른 일부에는 새 컨텐츠가 있습니다. 일부 데이터베이스 엔진은 페이지 쓰기가 원 자성이므로 조각난 페이지는 복구 할 수없는 오류라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="321b99cb3ca22320bc4d4754f57c85325a5439b8" translate="yes" xml:space="preserve">
          <source>A trace callback has four arguments: xCallback(T,C,P,X). The T argument is one of the integer type codes above. The C argument is a copy of the context pointer passed in as the fourth argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">추적 콜백에는 4 개의 인수가 있습니다 : xCallback (T, C, P, X). T 인수는 위의 정수 유형 코드 중 하나입니다. C 인수는 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()에&lt;/a&gt; 네 번째 인수로 전달 된 컨텍스트 포인터의 사본입니다 . P 및 X 인수는 의미가 T에 의존하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="99f3aaaba3c5cbd27990154339c07e3ae8d754b2" translate="yes" xml:space="preserve">
          <source>A trace callback has four arguments: xCallback(T,C,P,X). The T argument is one of the integer type codes above. The C argument is a copy of the context pointer passed in as the fourth argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">추적 콜백에는 4 개의 인수가 있습니다 : xCallback (T, C, P, X). T 인수는 위의 정수 유형 코드 중 하나입니다. C 인수는 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()에&lt;/a&gt; 네 번째 인수로 전달 된 컨텍스트 포인터의 사본입니다 . P 및 X 인수는 의미가 T에 의존하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f8bfcc86c34516e1fd4709998e44b1f12ab7abe6" translate="yes" xml:space="preserve">
          <source>A trace callback is invoked with four arguments: callback(T,C,P,X). The T argument is one of the &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants to indicate why the callback was invoked. The C argument is a copy of the context pointer. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">콜백 (T, C, P, X)이라는 네 개의 인수로 추적 콜백이 호출됩니다. T 인수는 콜백이 호출 된 이유를 나타내는 &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 중 하나입니다 . C 인수는 컨텍스트 포인터의 사본입니다. P 및 X 인수는 의미가 T에 의존하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="3391a0e081f93a34b14f66af9af68c43e3c9b43e" translate="yes" xml:space="preserve">
          <source>A trace callback is invoked with four arguments: callback(T,C,P,X). The T argument is one of the &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants to indicate why the callback was invoked. The C argument is a copy of the context pointer. The P and X arguments are pointers whose meanings depend on T.</source>
          <target state="translated">콜백 (T, C, P, X)이라는 네 개의 인수로 추적 콜백이 호출됩니다. T 인수는 콜백이 호출 된 이유를 나타내는 &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 중 하나입니다 . C 인수는 컨텍스트 포인터의 사본입니다. P 및 X 인수는 의미가 T에 의존하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="6f406be63849f147005f5bd90bb0cfb01b00b5d0" translate="yes" xml:space="preserve">
          <source>A transaction must be started before executing this opcode.</source>
          <target state="translated">이 opcode를 실행하기 전에 트랜잭션을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="d659782eaca92197beb5705e0198423f0973c8e4" translate="yes" xml:space="preserve">
          <source>A transactional database is one in which all changes and queries appear to be Atomic, Consistent, Isolated, and Durable (&lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt;). SQLite implements &lt;a href=&quot;http://en.wikipedia.org/wiki/Serializability&quot;&gt;serializable&lt;/a&gt; transactions that are atomic, consistent, isolated, and durable, even if the transaction is interrupted by a program crash, an operating system crash, or a power failure to the computer.</source>
          <target state="translated">트랜잭션 데이터베이스는 모든 변경 및 쿼리가 원자, 일관성, 격리 및 내구성 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/ACID&quot;&gt;ACID&lt;/a&gt; ) 인 것처럼 보이는 데이터베이스입니다 . SQLite 는 프로그램 충돌, 운영 체제 충돌 또는 컴퓨터의 정전으로 인해 트랜잭션이 중단 된 경우에도 원 자성, 일관성, 격리 및 내구성이있는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Serializability&quot;&gt;직렬화 가능&lt;/a&gt; 트랜잭션을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="762f7ff34044b36794c45c18c95e9030f7e31400" translate="yes" xml:space="preserve">
          <source>A triangle has three vertexes, but the GeoJSON description of the triangle has 4 vertexes because the first and last vertex are duplicates.</source>
          <target state="translated">삼각형에는 3 개의 꼭지점이 있지만 삼각형의 GeoJSON 설명에는 첫 번째 꼭지점과 마지막 꼭지점이 중복되므로 4 개의 꼭지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29b340a77213cb4d10ec115c1281733a8d75cde1" translate="yes" xml:space="preserve">
          <source>A trigger may be specified to fire whenever a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; of a particular database table occurs, or whenever an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; occurs on on one or more specified columns of a table.</source>
          <target state="translated">특정 데이터베이스 테이블 의 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 가 발생할 때마다 또는 테이블의 하나 이상의 지정된 열에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 가 발생할 때마다 트리거를 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd2260f1e1f77326af7731e7d8239b68e8a9f11e" translate="yes" xml:space="preserve">
          <source>A trigger normally exists in the same database as the table named after the &quot;ON&quot; keyword in the CREATE TRIGGER statement. Except, it is possible to create a TEMP TRIGGER on a table in another database. Such a trigger will only fire when changes are made to the target table by the application that defined the trigger. Other applications that modify the database will not be able to see the TEMP trigger and hence cannot run the trigger.</source>
          <target state="translated">트리거는 일반적으로 CREATE TRIGGER 문에서 &quot;ON&quot;키워드의 이름을 딴 테이블과 동일한 데이터베이스에 존재합니다. 다른 데이터베이스의 테이블에서 TEMP TRIGGER를 작성할 수 있습니다. 이러한 트리거는 트리거를 정의한 애플리케이션이 대상 테이블을 변경 한 경우에만 실행됩니다. 데이터베이스를 수정하는 다른 응용 프로그램은 TEMP 트리거를 볼 수 없으므로 트리거를 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ae92c55b82f470eeeb4bba0b8d4309fbfff3525" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same non-null values in the unique columns.</source>
          <target state="translated">테이블의 두 행이 고유 열에서 널이 아닌 동일한 값을 갖는 경우에만 고유 제한 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae94a52f226bc47de3ee1540f2d8d90e50fc05b" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same values and have non-null values in the unique columns.</source>
          <target state="translated">테이블의 두 행에 동일한 값이 있고 고유 열에 널이 아닌 값이있는 경우에만 고유 제한 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="dabcb6d549c13ce12ef42eaf48b0d41d8c3dfc2d" translate="yes" xml:space="preserve">
          <source>A unique constraint is satisfied if and only if no two rows in a table have the same values in the subset of unique columns that are not null.</source>
          <target state="translated">테이블의 두 행이 고유 열의 서브 세트에서 널이 아닌 동일한 값을 갖지 않는 경우에만 고유 제한 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="952f4e6659d04ec5f193202b5fddffcc0087004e" translate="yes" xml:space="preserve">
          <source>A unique integer number associated with each vocabulary item in the table. This can be used as a foreign key on other tables in the database.</source>
          <target state="translated">표의 각 어휘 항목과 관련된 고유 한 정수입니다. 데이터베이스의 다른 테이블에서 외래 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe70411c725bc0721714f08714a5a3f518456c0" translate="yes" xml:space="preserve">
          <source>A valid rollback journal begins with a header in the following format:</source>
          <target state="translated">유효한 롤백 저널은 다음 형식의 헤더로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9323ac27e089e4d34d2bcc6e9f8a53b215a87e94" translate="yes" xml:space="preserve">
          <source>A value of 10 (0x0a) means the page is a leaf index b-tree page.</source>
          <target state="translated">값 10 (0x0a)은 페이지가 리프 색인 b- 트리 페이지임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="62e1a106666132bc7aa0c524ac57c51e9c1fa6f1" translate="yes" xml:space="preserve">
          <source>A value of 13 (0x0d) means the page is a leaf table b-tree page.</source>
          <target state="translated">값 13 (0x0d)은 페이지가 리프 테이블 b- 트리 페이지임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="40f1a1f1a6aa95dae3ca3a5407b50cea28bcd1e7" translate="yes" xml:space="preserve">
          <source>A value of 2 (0x02) means the page is an interior index b-tree page.</source>
          <target state="translated">값 2 (0x02)는 페이지가 내부 색인 b- 트리 페이지임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="63a906019a3e0d60d30d9b9306736264578b9862" translate="yes" xml:space="preserve">
          <source>A value of 5 (0x05) means the page is an interior table b-tree page.</source>
          <target state="translated">값 5 (0x05)는 페이지가 내부 테이블 b- 트리 페이지임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="98aefbc577505a102a4bdbd9d45da156baa1724a" translate="yes" xml:space="preserve">
          <source>A value with storage class NULL is considered less than any other value (including another value with storage class NULL).</source>
          <target state="translated">스토리지 클래스가 NULL 인 값은 다른 값 (스토리지 클래스가 NULL 인 다른 값 포함)보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="61966bda21e838b4a385c022331516a90f448e33" translate="yes" xml:space="preserve">
          <source>A variable-length integer or &quot;varint&quot; is a static Huffman encoding of 64-bit twos-complement integers that uses less space for small positive values. A varint is between 1 and 9 bytes in length. The varint consists of either zero or more bytes which have the high-order bit set followed by a single byte with the high-order bit clear, or nine bytes, whichever is shorter. The lower seven bits of each of the first eight bytes and all 8 bits of the ninth byte are used to reconstruct the 64-bit twos-complement integer. Varints are big-endian: bits taken from the earlier byte of the varint are more significant than bits taken from the later bytes.</source>
          <target state="translated">가변 길이 정수 또는 &quot;varint&quot;는 작은 양수 값에 더 적은 공간을 사용하는 64 비트 2 보수 정수의 정적 허프만 인코딩입니다. varint의 길이는 1에서 9 바이트 사이입니다. varint는 상위 비트 세트가있는 0 개 이상의 바이트와 상위 비트 클리어가있는 단일 바이트 또는 9 바이트 중 더 짧은 바이트로 구성됩니다. 처음 8 바이트 각각의 하위 7 비트와 9 번째 바이트의 모든 8 비트는 64 비트 2 보수 정수를 재구성하는 데 사용됩니다. 바 린트는 ​​빅 엔디안입니다. 바 린트의 이전 바이트에서 가져온 비트가 이후 바이트에서 가져온 비트보다 중요합니다.</target>
        </trans-unit>
        <trans-unit id="39d2c41c22785c16d3ddf35c480bf3c0b5dd588a" translate="yes" xml:space="preserve">
          <source>A varint which is the integer key</source>
          <target state="translated">정수 키인 varint</target>
        </trans-unit>
        <trans-unit id="8fee174cbc89434778acfe5a3e125ad5320c50ab" translate="yes" xml:space="preserve">
          <source>A varint which is the integer key, a.k.a. &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;</source>
          <target state="translated">정수 키, 즉 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &quot;인 varint</target>
        </trans-unit>
        <trans-unit id="7dcfb4fd379871a1c7b556422d5224ce7bad5762" translate="yes" xml:space="preserve">
          <source>A varint which is the total number of bytes of key payload, including any overflow</source>
          <target state="translated">오버 플로우를 포함하여 키 페이로드의 총 바이트 수인 varint</target>
        </trans-unit>
        <trans-unit id="a3d513baeec19bb3a29eb1d68e0c4ec488b8735e" translate="yes" xml:space="preserve">
          <source>A varint which is the total number of bytes of payload, including any overflow</source>
          <target state="translated">오버로드를 포함한 페이로드의 총 바이트 수인 varint</target>
        </trans-unit>
        <trans-unit id="da04ae498ca0dc39858789333261d6656f640502" translate="yes" xml:space="preserve">
          <source>A version control system (VCS) will typically store the evolving versions of a project as a directed acyclic graph (DAG). Call each version of the project a &quot;checkin&quot;. A single checkin can have zero or more parents. Most checkins (except the first) have a single parent, but in the case of a merge, a checkin might have two or three or more parents. A schema to keep track of checkins and the order in which they occur might look something like this:</source>
          <target state="translated">버전 제어 시스템 (VCS)은 일반적으로 진화하는 버전의 프로젝트를 DAG (directed acyclic graph)로 저장합니다. 각 버전의 프로젝트를 &quot;체크인&quot;이라고합니다. 단일 체크인에는 부모가 0 명 이상있을 수 있습니다. 대부분의 체크인 (첫 번째 제외)에는 단일 부모가 있지만 병합의 경우 체크인에 부모가 둘 또는 셋 이상있을 수 있습니다. 체크인을 추적하는 스키마와 발생 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="881d501220206ee1c616806563f13fecfb51dbf6" translate="yes" xml:space="preserve">
          <source>A virtual filesystem (VFS) is an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that SQLite uses to interact with the underlying operating system. Most SQLite builds come with a single default VFS that is appropriate for the host computer. New VFSes can be registered and existing VFSes can be unregistered. The following interfaces are provided.</source>
          <target state="translated">가상 파일 시스템 (VFS)은 SQLite가 기본 운영 체제와 상호 작용하는 데 사용 하는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체입니다. 대부분의 SQLite 빌드에는 호스트 컴퓨터에 적합한 단일 기본 VFS가 제공됩니다. 새로운 VFS를 등록하고 기존 VFS를 등록 취소 할 수 있습니다. 다음과 같은 인터페이스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1900bfd100646a0b3b036033184bd610a0f59cc1" translate="yes" xml:space="preserve">
          <source>A virtual filesystem (VFS) is an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that SQLite uses to interact with the underlying operating system. Most SQLite builds come with a single default VFS that is appropriate for the host computer. New VFSes can be registered and existing VFSes can be unregistered. The following interfaces are provided.</source>
          <target state="translated">가상 파일 시스템 (VFS)은 SQLite가 기본 운영 체제와 상호 작용하는 데 사용 하는 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체입니다. 대부분의 SQLite 빌드에는 호스트 컴퓨터에 적합한 단일 기본 VFS가 제공됩니다. 새로운 VFS를 등록하고 기존 VFS를 등록 취소 할 수 있습니다. 다음과 같은 인터페이스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="97b11082572e398dba7e2062d48e57376c3d93de" translate="yes" xml:space="preserve">
          <source>A virtual table implementation must be able to support an arbitrary number of simultaneously open cursors.</source>
          <target state="translated">가상 테이블 구현은 임의의 수의 동시에 열린 커서를 지원할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="56cb3efe7eb44df0ba67e5ea661e95ce4f842882" translate="yes" xml:space="preserve">
          <source>A virtual table is an object that is registered with an open SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. From the perspective of an SQL statement, the virtual table object looks like any other table or view. But behind the scenes, queries and updates on a virtual table invoke callback methods of the virtual table object instead of reading and writing on the database file.</source>
          <target state="translated">가상 테이블은 열린 SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 등록 된 객체입니다 . SQL 문의 관점에서 가상 테이블 오브젝트는 다른 테이블 또는 뷰처럼 보입니다. 그러나 뒤에서 가상 테이블에 대한 쿼리 및 업데이트는 데이터베이스 파일을 읽고 쓰는 대신 가상 테이블 개체의 콜백 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="52af07e40184e006612d2e3054e64de5f1d7c832" translate="yes" xml:space="preserve">
          <source>A virtual table is created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">가상 테이블은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a893a3a1c0e0b537926a2530a012fcadd49c1a89" translate="yes" xml:space="preserve">
          <source>A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement. There is no DROP VIRTUAL TABLE statement.</source>
          <target state="translated">가상 테이블은 일반 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 사용하여 삭제됩니다 . DROP VIRTUAL TABLE 문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="847101905322620243ed31c601c382674aa4a14b" translate="yes" xml:space="preserve">
          <source>A virtual table is eponymous if its &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is the exact same function as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, or if the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL. The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is called when a virtual table is first created using the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method is invoked whenever a database connection attaches to or reparses a schema. When these two methods are the same, that indicates that the virtual table has no persistent state that needs to be created and destroyed.</source>
          <target state="translated">그 경우, 가상 테이블은 시조이다 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate에&lt;/a&gt; 있어서, 상기와 동일한 함수이다 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect의&lt;/a&gt; 방법, 또는 경우 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate의&lt;/a&gt; 방법은 NULL이다. &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate의&lt;/a&gt; 가상 테이블을 먼저 사용을 만들 때 메서드가 호출되는 &lt;a href=&quot;lang_createvtab&quot;&gt;가상 테이블의 CREATE&lt;/a&gt; 문을. &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect의&lt;/a&gt; 방법에 때마다 데이터베이스 연결 첨부합니다 호출 또는 스키마를 재분석한다. 이 두 가지 방법이 동일하면 가상 테이블에 작성 및 제거해야하는 지속적 상태가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="353f0b8410ad856bf5ebf8e7164ab137690e2e5f" translate="yes" xml:space="preserve">
          <source>A virtual table might represent an in-memory data structures. Or it might represent a view of data on disk that is not in the SQLite format. Or the application might compute the content of the virtual table on demand.</source>
          <target state="translated">가상 테이블은 메모리 내 데이터 구조를 나타낼 수 있습니다. 또는 SQLite 형식이 아닌 디스크의 데이터보기를 나타낼 수 있습니다. 또는 애플리케이션이 요청시 가상 테이블의 컨텐츠를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4f90d299472ce309a8e439b029daf5f8f8923b0" translate="yes" xml:space="preserve">
          <source>A virtual table module is created by filling in a persistent instance of this structure and passing a pointer to that instance to &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt;. The registration remains valid until it is replaced by a different module or until the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; closes. The content of this structure must not change while it is registered with any database connection.</source>
          <target state="translated">가상 테이블 모듈은이 구조의 영구 인스턴스를 채우고 해당 인스턴스에 대한 포인터를 &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module_v2 ()로&lt;/a&gt; 전달하여 작성됩니다 . 등록은 다른 모듈로 교체되거나 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 닫힐 때까지 유효합니다 . 이 구조의 내용은 데이터베이스 연결에 등록되어있는 동안 변경되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="38351d643190ff2e0c5028a024cfec96116efe36" translate="yes" xml:space="preserve">
          <source>A virtual table module is created by filling in a persistent instance of this structure and passing a pointer to that instance to &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt;. The registration remains valid until it is replaced by a different module or until the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; closes. The content of this structure must not change while it is registered with any database connection.</source>
          <target state="translated">가상 테이블 모듈은이 구조의 영구 인스턴스를 채우고 해당 인스턴스에 대한 포인터를 &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module_v2 ()로&lt;/a&gt; 전달하여 작성됩니다 . 등록은 다른 모듈로 교체되거나 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 닫힐 때까지 유효합니다 . 이 구조의 내용은 데이터베이스 연결에 등록되어있는 동안 변경되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="94ab9a8c810266d9131b7dc3abfde1084e5a3827" translate="yes" xml:space="preserve">
          <source>A virtual table returns all integers between 1 and 4294967295.</source>
          <target state="translated">가상 테이블은 1과 4294967295 사이의 모든 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9550c8ab6f8d693fb2f5399ce989472075011998" translate="yes" xml:space="preserve">
          <source>A virtual table that implements a spelling correction engine.</source>
          <target state="translated">철자 수정 엔진을 구현하는 가상 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="8d81c8273172f3de70ea8fa615e0e6a43a86ed85" translate="yes" xml:space="preserve">
          <source>A virtual table that prints diagnostic information on stdout when its key methods are invoked. Intended for interactive analysis and debugging of virtual table interfaces.</source>
          <target state="translated">주요 메소드가 호출 될 때 stdout에 진단 정보를 인쇄하는 가상 테이블. 가상 테이블 인터페이스의 대화식 분석 및 디버깅에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e16ff1f72c104772393373b9711e80e90eaa372" translate="yes" xml:space="preserve">
          <source>A virtual table that represents a comma-separated-value or CSV file (&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt;) as a read-only table so that it can be used as part of a larger query.</source>
          <target state="translated">큰 쿼리의 일부로 사용할 수 있도록 쉼표로 구분 된 값 또는 CSV 파일 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; )을 읽기 전용 테이블 로 나타내는 가상 테이블입니다 .</target>
        </trans-unit>
        <trans-unit id="adf39798b9f95adc35fd6772c7cbfb7068e01df6" translate="yes" xml:space="preserve">
          <source>A virtual table, which provides read and write access to archives stored in the file-system.</source>
          <target state="translated">파일 시스템에 저장된 아카이브에 대한 읽기 및 쓰기 액세스를 제공하는 가상 테이블.</target>
        </trans-unit>
        <trans-unit id="0516d8f39a8906e53dce6da52e21c642d9370cf8" translate="yes" xml:space="preserve">
          <source>A well-written C program will typically contain some defensive conditionals which in practice are always true or always false. This leads to a programming dilemma: Does one remove defensive code in order to obtain 100% branch coverage?</source>
          <target state="translated">잘 작성된 C 프로그램에는 일반적으로 항상 참 또는 항상 거짓 인 방어 조건이 포함됩니다. 이것은 프로그래밍 딜레마로 이어진다 : 100 % 지점 커버리지를 얻기 위해 방어 코드를 제거 하는가?</target>
        </trans-unit>
        <trans-unit id="a3522671a3a254f98c06c7d8eb6a707b7852ebea" translate="yes" xml:space="preserve">
          <source>A width of 0 means the column width is chosen automatically. Unspecified columns widths to go zero. Hence, the command &quot;.width&quot; with no arguments sets all columns widths to zero and hence causes all column widths to be determine automatically.</source>
          <target state="translated">너비가 0이면 열 너비가 자동으로 선택됨을 의미합니다. 0이되는 지정되지 않은 열 너비. 따라서 인수가없는 &quot;.width&quot;명령은 모든 열 너비를 0으로 설정하므로 모든 열 너비가 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f05d1eb22dd9a9ee6d24e61fd43de0311fb625" translate="yes" xml:space="preserve">
          <source>A window function is an SQL function where the input values are taken from a &quot;window&quot; of one or more rows in the results set of a SELECT statement.</source>
          <target state="translated">창 함수는 입력 값이 SELECT 문의 결과 세트에있는 하나 이상의 행의 &quot;창&quot;에서 가져 오는 SQL 함수입니다.</target>
        </trans-unit>
        <trans-unit id="95e1d6e7e3fb96b500c945c549b86f711da8262a" translate="yes" xml:space="preserve">
          <source>A working &lt;a href=&quot;https://zlib.net&quot;&gt;zlib compression library&lt;/a&gt; is needed in order for the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; to operate.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령&lt;/a&gt; 이 작동 하려면 작업 &lt;a href=&quot;https://zlib.net&quot;&gt;zlib 압축 라이브러리&lt;/a&gt; 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="12ba0d7954a4428935b75868db48e0376c9b0d38" translate="yes" xml:space="preserve">
          <source>A wrapped pile-of-files format is a compromise between a full custom file format and a pure pile-of-files format. A wrapped pile-of-files format is not an opaque blob in the same sense as a custom format, since the component parts can still be accessed using any common ZIP archiver, but the format is not quite as accessible as a pure pile-of-files format because one does still need the ZIP archiver, and one cannot normally use command-line tools like &quot;find&quot; on the file hierarchy without first un-zipping it. On the other hand, a wrapped pile-of-files format does preserve the document metaphor by putting all content into a single disk file. And because it is compressed, the wrapped pile-of-files format tends to be more compact.</source>
          <target state="translated">랩핑 된 파일 더미 형식은 전체 사용자 정의 파일 형식과 순수한 파일 더미 형식 사이의 절충입니다. 랩핑 된 파일 더미 형식은 일반적인 ZIP 아카이버를 사용하여 구성 요소 파트에 여전히 액세스 할 수 있기 때문에 사용자 정의 형식과 동일한 의미에서 불투명 한 얼룩이 아닙니다. 그러나 형식은 순수한 파일처럼 액세스 할 수 없습니다. -files 형식은 여전히 ​​ZIP 아카이버가 필요하기 때문에 먼저 파일 계층 구조에서 &quot;find&quot;와 같은 명령 줄 도구를 먼저 압축 해제하지 않고 사용할 수 없습니다. 다른 한편으로, 랩핑 된 파일 더미 형식은 모든 내용을 단일 디스크 파일에 넣어서 문서 비유를 보존합니다. 압축되어 있기 때문에 랩핑 된 파일 더미 형식이 더 컴팩트 한 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0cb831fafd0869c861cfe72928b427adff2aa0c" translate="yes" xml:space="preserve">
          <source>A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-wal&lt;/b&gt;&quot; appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 작동 할 때 롤백 저널 대신 미리 쓰기 로그 또는 WAL 파일이 사용 됩니다 . 롤백 저널과 마찬가지로 WAL 파일의 목적은 원자 커밋 및 롤백을 구현하는 것입니다. WAL 파일은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 4 자 &quot; &lt;b&gt;-wal&lt;/b&gt; &quot;이 추가 된 것을 제외하고 데이터베이스 파일과 이름이 같습니다 . WAL 파일은 데이터베이스에 대한 첫 번째 연결이 열릴 때 작성되며 데이터베이스에 대한 마지막 연결이 닫히면 일반적으로 제거됩니다. 그러나 마지막 연결이 완전히 종료되지 않으면 WAL 파일은 파일 시스템에 남아 있으며 다음에 데이터베이스를 열 때 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="7f97d795973bc84aa355c2feb5c3e28a10896757" translate="yes" xml:space="preserve">
          <source>A zero-terminated string containing the text of one or more SQL statements and/or queries to be processed.</source>
          <target state="translated">처리 할 하나 이상의 SQL 문 및 / 또는 쿼리의 텍스트를 포함하는 0으로 끝나는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="606ec6e9bd8a8ff2ad14e5fade3f264471e82251" translate="yes" xml:space="preserve">
          <source>AAA</source>
          <target state="translated">AAA</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="dc1f44b95b4f44c4b87ebcf57cafc6780d0a90b6" translate="yes" xml:space="preserve">
          <source>ACID transactions using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; , &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK을&lt;/a&gt; 사용하는 ACID 트랜잭션</target>
        </trans-unit>
        <trans-unit id="2b9f1cf5c4d33807129af3dcb41af0a491f4cda7" translate="yes" xml:space="preserve">
          <source>ACTION</source>
          <target state="translated">ACTION</target>
        </trans-unit>
        <trans-unit id="f9460492306d4b99cd31848c3a99a26a7e978d96" translate="yes" xml:space="preserve">
          <source>ADD</source>
          <target state="translated">ADD</target>
        </trans-unit>
        <trans-unit id="ee5600b2ed97ece803d7f4350448a1f4928404a3" translate="yes" xml:space="preserve">
          <source>AFL has proven remarkably adept at finding arcane bugs in SQLite. Most of the findings have been assert() statements where the conditional was false under obscure circumstances. But AFL has also found a fair number of crash bugs in SQLite, and even a few cases where SQLite computed incorrect results.</source>
          <target state="translated">AFL은 SQLite에서 비전 버그를 찾는 데 상당히 능숙한 것으로 입증되었습니다. 대부분의 결과는 모호한 상황에서 조건부가 잘못된 경우 assert () 문입니다. 그러나 AFL은 SQLite에서 상당한 수의 충돌 버그를 발견했으며 심지어 SQLite가 잘못된 결과를 계산 한 경우도 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="5d726e4e98d71e7677fc370d3c1ae46220f46b39" translate="yes" xml:space="preserve">
          <source>AFL proved adept at finding arcane bugs in SQLite. Most of the findings have been assert() statements where the conditional was false under obscure circumstances. But AFL has also found a fair number of crash bugs in SQLite, and even a few cases where SQLite computed incorrect results.</source>
          <target state="translated">AFL은 SQLite에서 신비한 버그를 찾는 데 능숙 함을 입증했습니다. 대부분의 결과는 모호한 상황에서 조건부가 거짓 인 assert () 문이었습니다. 그러나 AFL은 SQLite에서 상당한 수의 크래시 버그를 발견했으며 SQLite가 잘못된 결과를 계산 한 몇 가지 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="63edc193e8cfcf6757dd5596309d5a764f92ace2" translate="yes" xml:space="preserve">
          <source>AFP locking style. This locking style is used for network file systems that use the AFP (Apple Filing Protocol) protocol. Locks are obtained by calling the library function _AFPFSSetLock().</source>
          <target state="translated">AFP 잠금 스타일. 이 잠금 스타일은 AFP (Apple Filing Protocol) 프로토콜을 사용하는 네트워크 파일 시스템에 사용됩니다. 라이브러리 함수 _AFPFSSetLock ()을 호출하여 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="6e69e31990a7343ff088d4c32eea14ef655df385" translate="yes" xml:space="preserve">
          <source>ALTER</source>
          <target state="translated">ALTER</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">테이블 변경</target>
        </trans-unit>
        <trans-unit id="dc1fbac7d45ba56f622f7752b89525d62ceed128" translate="yes" xml:space="preserve">
          <source>ALTER TABLE ADD COLUMN</source>
          <target state="translated">테이블 추가 열 추가</target>
        </trans-unit>
        <trans-unit id="094aafb4c8ae4eba399881e4d9b84c158bb3ff0a" translate="yes" xml:space="preserve">
          <source>ALTER TABLE RENAME</source>
          <target state="translated">테이블 이름 변경</target>
        </trans-unit>
        <trans-unit id="b5b6c520c273175237f91ec319fe56f82283ec27" translate="yes" xml:space="preserve">
          <source>ALTER TABLE RENAME COLUMN</source>
          <target state="translated">ALTER TABLE RENAME COLUMN</target>
        </trans-unit>
        <trans-unit id="f9d0d0176fb0a7f55f27682b7d026c807b2a0515" translate="yes" xml:space="preserve">
          <source>ALTER TABLE uses double-quotes instead of single-quotes for quoting filenames.</source>
          <target state="translated">ALTER TABLE은 파일 이름을 인용하기 위해 작은 따옴표 대신 큰 따옴표를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ae0ecf3287dbfbb668b86fe771af6cf210ce9334" translate="yes" xml:space="preserve">
          <source>ALWAYS</source>
          <target state="translated">ALWAYS</target>
        </trans-unit>
        <trans-unit id="8ca598e81cf4b7eae20f25366c64a9099ce76a39" translate="yes" xml:space="preserve">
          <source>ALWAYS(X)</source>
          <target state="translated">ALWAYS(X)</target>
        </trans-unit>
        <trans-unit id="7b4e17353a4bd1a4f2d336a59d39168308ceecbc" translate="yes" xml:space="preserve">
          <source>ALWAYS(X) and NEVER(X) functions are used in places where we always want the test to occur even though the developers believe the value of X is always true or false. For example, the sqlite3BtreeCloseCursor() routine shown must remove the closing cursor from a linked list of all cursors. We know that the cursor is on the list, so that the loop must terminate by the &quot;break&quot; statement, but it is convenient to use the ALWAYS(X) test at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&lt;/a&gt; to prevent running off the end of the linked list in case there is an error in some other part of the code that has corrupted the linked list.</source>
          <target state="translated">ALWAYS (X) 및 NEVER (X) 함수는 개발자가 X의 값이 항상 참 또는 거짓이라고 생각하더라도 테스트가 항상 일어나길 원하는 곳에서 사용됩니다. 예를 들어, 표시된 sqlite3BtreeCloseCursor () 루틴은 모든 커서의 링크 된 목록에서 닫기 커서를 제거해야합니다. 커서가 목록에 있으므로 루프가 &quot;break&quot;문으로 끝나야한다는 것을 알고 있지만 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=4371&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3&lt;/a&gt; 에서 ALWAYS (X) 테스트를 사용하는 것이 편리 합니까? ln = 4371 : 링크 된 목록을 손상시킨 코드의 다른 부분에 오류가있는 경우 링크 된 목록의 끝에서 벗어나지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="1a397ebb8cf61587cd521ec01e5c6b51276f91a4" translate="yes" xml:space="preserve">
          <source>ANSI Common Lisp</source>
          <target state="translated">ANSI 공통 리스프</target>
        </trans-unit>
        <trans-unit id="d00bb3f3b7c7b8815b6dcf237dd16aab9744eca8" translate="yes" xml:space="preserve">
          <source>AS</source>
          <target state="translated">AS</target>
        </trans-unit>
        <trans-unit id="eaffec78401451424652480dc382235348ce1b66" translate="yes" xml:space="preserve">
          <source>ASC</source>
          <target state="translated">ASC</target>
        </trans-unit>
        <trans-unit id="166240989b0ab1b8695abcaef83da0a4918a2fb9" translate="yes" xml:space="preserve">
          <source>ASCII rendering of the float</source>
          <target state="translated">float의 ASCII 렌더링</target>
        </trans-unit>
        <trans-unit id="6b519334032a98f7c2594012c3b3e7e13014c677" translate="yes" xml:space="preserve">
          <source>ASCII rendering of the integer</source>
          <target state="translated">정수의 ASCII 렌더링</target>
        </trans-unit>
        <trans-unit id="8a5ebc115bc75bb938a3838103c3725bf90efb01" translate="yes" xml:space="preserve">
          <source>ATTACH</source>
          <target state="translated">ATTACH</target>
        </trans-unit>
        <trans-unit id="33ca34fea5ce451e0bc66a6eadd28cb502c9e81b" translate="yes" xml:space="preserve">
          <source>ATTACH DATABASE</source>
          <target state="translated">첨부 데이터베이스</target>
        </trans-unit>
        <trans-unit id="1ac676774c3a8c1551764b1d83b7d37f669fb5a0" translate="yes" xml:space="preserve">
          <source>ATTACH and DETACH as well as some other operations cause existing prepared statements to expire.</source>
          <target state="translated">ATTACH 및 DETACH와 일부 다른 조작으로 인해 기존의 준비된 명령문이 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="21a7e17a976b425553bc577b3148824d2a1f1a44" translate="yes" xml:space="preserve">
          <source>AUTOINCREMENT</source>
          <target state="translated">AUTOINCREMENT</target>
        </trans-unit>
        <trans-unit id="5c70ef0cc48907c519166dce4b32226739e45e67" translate="yes" xml:space="preserve">
          <source>AUTOINCREMENT keyword supported on INTEGER PRIMARY KEY</source>
          <target state="translated">INTEGER PRIMARY KEY에서 지원되는 AUTOINCREMENT 키워드</target>
        </trans-unit>
        <trans-unit id="76bb2a7951c7bb2c965f22c9a57e2ce25974df9a" translate="yes" xml:space="preserve">
          <source>Abbreviations are applied in the multitest.tcl output so that each th3make invocation will fit on a single 80-column output line. The initial &quot;th3make&quot; verb is omitted. &quot;~&quot; is shorthand for &quot;-DSQLITE_&quot; and &quot;++&quot; is stands for &quot;-DSQLITE_ENABLE&quot;. Hence, multitest.tcl output line</source>
          <target state="translated">multitest.tcl 출력에 약어가 적용되어 각 th3make 호출이 단일 80 열 출력 행에 맞습니다. 초기 &quot;th3make&quot;동사는 생략됩니다. &quot;~&quot;는 &quot;-DSQLITE_&quot;의 약자이고 &quot;++&quot;는 &quot;-DSQLITE_ENABLE&quot;의 약자입니다. 따라서 multitest.tcl 출력 라인</target>
        </trans-unit>
        <trans-unit id="aa097a59aa23d1ea05fcdf2e722330d9e25e4b14" translate="yes" xml:space="preserve">
          <source>Abortable</source>
          <target state="translated">Abortable</target>
        </trans-unit>
        <trans-unit id="a87b7bc256c5e187e5504df77ba712267f376ec4" translate="yes" xml:space="preserve">
          <source>About OpenDocument And OpenDocument Presentation</source>
          <target state="translated">OpenDocument 및 OpenDocument 프레젠테이션 정보</target>
        </trans-unit>
        <trans-unit id="f32e574abd9aafdacaa9afd3405d7877d90e54cb" translate="yes" xml:space="preserve">
          <source>Accept &quot;Z&quot; as the zulu timezone at the end of date strings</source>
          <target state="translated">날짜 문자열의 끝에서 Zulu 시간대로 &quot;Z&quot;를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ce752666b5e444987daa4b6966df37d55bde025" translate="yes" xml:space="preserve">
          <source>Accept column names in parentheses.</source>
          <target state="translated">괄호 안에 열 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0213d4fd54eabb051f311ba8f2befe3b9c69a5c" translate="yes" xml:space="preserve">
          <source>Access is coordinated in WAL mode using both the legacy DELETE-mode locks controlled by the xLock and xUnlock methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and the WAL locks controlled by the xShmLock method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">액세스는 모두의 XLOCK xUnlock 및 방법에 의해 제어되는 레거시 DELETE 모드 잠금 사용 WAL 모드 배위 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods이&lt;/a&gt; 물체와 WAL이 xShmLock의 방법에 의해 제어 잠그는 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 개체.</target>
        </trans-unit>
        <trans-unit id="80d3ef128ce8adb3705e036419e075fdb4f48299" translate="yes" xml:space="preserve">
          <source>Access the filesystem of the host computer as if it were a database table</source>
          <target state="translated">데이터베이스 테이블 인 것처럼 호스트 컴퓨터의 파일 시스템에 액세스</target>
        </trans-unit>
        <trans-unit id="61521a7d6f538076f32bc9879102eb6d96388ec7" translate="yes" xml:space="preserve">
          <source>Access to records via &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is highly optimized and very fast.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 통한 레코드 액세스 는 고도로 최적화되고 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b0ba54a3a4413a8377f766e7307b65f628b16b98" translate="yes" xml:space="preserve">
          <source>Accessible Content</source>
          <target state="translated">접근 가능한 컨텐츠</target>
        </trans-unit>
        <trans-unit id="c17f44cb688221742030703d589c802bf0664eb2" translate="yes" xml:space="preserve">
          <source>Accommodation can be made for words that are not spelled as they sound by making additional entries into the virtual table for the same word, but adding an alternative spelling in the &quot;soundslike&quot; column. For example, the canonical entry for &quot;psalm&quot; would be this:</source>
          <target state="translated">같은 단어를 가상 테이블에 추가로 입력하지만 &quot;soundslike&quot;열에 대체 철자를 추가하여 소리가 나지 않아 철자가 틀린 단어를 조정할 수 있습니다. 예를 들어, &quot;psalm&quot;에 대한 표준 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6705b13fdc28369e54f6bdd712ca9a4db4cbf219" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, a URI consists of a scheme, an authority, a path, a query string, and a fragment. The scheme is always required. One of either the authority or the path is also always required. The query string and fragment are optional.</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; 에 따르면 URI는 체계, 권한, 경로, 쿼리 문자열 및 조각으로 구성됩니다. 계획은 항상 필요합니다. 권한 또는 경로 중 하나도 항상 필요합니다. 쿼리 문자열과 조각은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="05b6d5d4d823df2e184aec7120d805247860b8ea" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, PRIMARY KEY should always imply NOT NULL. Unfortunately, due to a bug in some early versions, this is not the case in SQLite. Unless the column is an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; or the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or the column is declared NOT NULL, SQLite allows NULL values in a PRIMARY KEY column. SQLite could be fixed to conform to the standard, but doing so might break legacy applications. Hence, it has been decided to merely document the fact that SQLite allowing NULLs in most PRIMARY KEY columns.</source>
          <target state="translated">SQL 표준에 따르면 PRIMARY KEY는 항상 NOT NULL을 암시해야합니다. 불행히도 일부 초기 버전의 버그로 인해 SQLite에서는 그렇지 않습니다. 열이 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 이거나 테이블이 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이거나 열이 NOT NULL로 선언되지 않으면 SQLite는 PRIMARY KEY 열에 NULL 값을 허용합니다. SQLite는 표준에 맞게 수정 될 수 있지만 그렇게하면 레거시 응용 프로그램이 손상 될 수 있습니다. 따라서 SQLite가 대부분의 PRIMARY KEY 열에서 NULL을 허용한다는 사실을 문서화하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="3dec6852ffb8757da75544af2803b809f2b130fe" translate="yes" xml:space="preserve">
          <source>Acquire a PENDING lock then an EXCLUSIVE lock on the database file. (Note: Do not acquire a RESERVED lock because that would make other processes think the journal was no longer hot.) If we fail to acquire these locks it means another process is already trying to do the rollback. In that case, drop all locks, close the database, and return SQLITE_BUSY.</source>
          <target state="translated">데이터베이스 파일에서 PENDING 잠금을 획득 한 후 독점 잠금을 확보하십시오. (참고 : 다른 프로세스에서 저널이 더 이상 핫하지 않다고 생각할 수 있으므로 예약 된 잠금을 확보하지 마십시오.) 이러한 잠금을 확보하지 못하면 다른 프로세스가 이미 롤백을 시도하고 있음을 의미합니다. 이 경우 모든 잠금을 제거하고 데이터베이스를 닫은 후 SQLITE_BUSY를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb030a7cb15f50d9dc25d4f04078043f2675ff3" translate="yes" xml:space="preserve">
          <source>Activate schema editing using &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON을&lt;/a&gt; 사용하여 스키마 편집을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c78b30e5c862affd42bb5f1c596df83d2545ece" translate="yes" xml:space="preserve">
          <source>Actually, SQLite will easily do 50,000 or more &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements per second on an average desktop computer. But it will only do a few dozen transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per second.</source>
          <target state="translated">실제로 SQLite는 평균 데스크톱 컴퓨터에서 초당 50,000 개 이상의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문 을 쉽게 수행 합니다. 그러나 초당 수십 건의 트랜잭션 만 수행합니다. 트랜잭션 속도는 디스크 드라이브의 회전 속도에 의해 제한됩니다. 트랜잭션에는 일반적으로 디스크 플래터의 두 번의 완전한 회전이 필요하며, 7200RPM 디스크 드라이브에서는 초당 약 60 개의 트랜잭션으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc81cc5fb5822da9569ed8c4f8843257c8f59e9" translate="yes" xml:space="preserve">
          <source>Actually, if one is only concerned with atomic and consistent writes and is willing to forego durable writes, the sync operation does not need to wait until the content is completely stored on persistent media. Instead, the sync operation can be thought of as an I/O barrier. As long as all writes that occur before the sync are completed before any write that happens after the sync, no database corruption will occur. If sync is operating as an I/O barrier and not as a true sync, then a power failure or system crash might cause one or more previously committed transactions to roll back (in violation of the &quot;durable&quot; property of &quot;ACID&quot;) but the database will at least continue to be consistent, and that is what most people care about.</source>
          <target state="translated">실제로, 원자적이고 일관된 쓰기에만 관심이 있고 내구성있는 쓰기를 포기하려는 경우 동기화 작업은 내용이 영구 미디어에 완전히 저장 될 때까지 기다릴 필요가 없습니다. 대신 동기화 작업은 I / O 장벽으로 생각할 수 있습니다. 동기화 전에 발생하는 모든 쓰기가 동기화 후에 발생하기 전에 모든 쓰기가 완료되면 데이터베이스 손상이 발생하지 않습니다. 동기화가 실제 동기화가 아닌 I / O 장벽으로 작동하는 경우 정전 또는 시스템 충돌로 인해 하나 이상의 이전에 커밋 된 트랜잭션이 롤백 될 수 있습니다 ( &quot;ACID&quot;의 &quot;durable&quot;속성을 위반 함). 데이터베이스는 최소한 일관성이 유지 될 것이며, 이것이 대부분의 사람들이 관심을 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="8ac6e880abe35cd3b7a1b0834fe47d4337bfddaa" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt;, &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt;, and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; options for the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스에 대해 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusreprepare&quot;&gt;SQLITE_STMTSTATUS_REPREPARE&lt;/a&gt; , &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusrun&quot;&gt;SQLITE_STMTSTATUS_RUN&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusmemused&quot;&gt;SQLITE_STMTSTATUS_MEMUSED&lt;/a&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="58cbb6e0f1775750062ac5669e49e04ab20b20ce" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;fts3#fts4&quot;&gt;full text search&lt;/a&gt; capabilities to the slide deck, or across multiple slide decks.</source>
          <target state="translated">추가 &lt;a href=&quot;fts3#fts4&quot;&gt;전체 텍스트 검색&lt;/a&gt; 슬라이드 데크, 또는 여러 슬라이드 데크에서 능력을.</target>
        </trans-unit>
        <trans-unit id="8dfeff2912792716526d37688fba56051d490d1d" translate="yes" xml:space="preserve">
          <source>Add &lt;a href=&quot;rescode#readonly_dbmoved&quot;&gt;SQLITE_READONLY_DBMOVED&lt;/a&gt; error code, returned at the beginning of a transaction, to indicate that the underlying database file has been renamed or moved out from under SQLite.</source>
          <target state="translated">트랜잭션 시작시 리턴 된 &lt;a href=&quot;rescode#readonly_dbmoved&quot;&gt;SQLITE_READONLY_DBMOVED&lt;/a&gt; 오류 코드를 추가 하여 기본 데이터베이스 파일의 이름이 변경되었거나 SQLite에서 이동되었음을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1c3f88960217978a5bdd7bc25245b711a532a875" translate="yes" xml:space="preserve">
          <source>Add A Changeset To A Changegroup</source>
          <target state="translated">변경 그룹에 변경 세트 추가</target>
        </trans-unit>
        <trans-unit id="9c66f22d5376c90e1654bc1561e3076b1f2090a2" translate="yes" xml:space="preserve">
          <source>Add C-language APIs for discovering SQL keywords used by SQLite: &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt;.</source>
          <target state="translated">SQLite에서 사용하는 SQL 키워드를 찾기 위해 C 언어 API를 추가하십시오 : &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count ()&lt;/a&gt; , &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65ffcfc767739ad0ab5f4bd4c91e85118f99542a" translate="yes" xml:space="preserve">
          <source>Add C-language APIs for dynamic strings based on the &lt;a href=&quot;c3ref/str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/str&quot;&gt;sqlite3_str&lt;/a&gt; 객체를 기반으로 동적 문자열에 대한 C 언어 API를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c5a3264f3bad4a3d08e2dbdc79dc6adf56d9043" translate="yes" xml:space="preserve">
          <source>Add Content To A Dynamic String</source>
          <target state="translated">동적 문자열에 내용 추가</target>
        </trans-unit>
        <trans-unit id="6d839bba6e835d3e16ff5554d03f6b92e3f024d0" translate="yes" xml:space="preserve">
          <source>Add FD_CLOEXEC to all open files under Unix.</source>
          <target state="translated">Unix에서 열린 모든 파일에 FD_CLOEXEC를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="45653642fbaec798956daf72ef08f996b3b84141" translate="yes" xml:space="preserve">
          <source>Add VxWorks-7 as an officially supported and tested platform.</source>
          <target state="translated">공식적으로 지원되고 테스트 된 플랫폼으로 VxWorks-7을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e51c9c34fae46cbf2d267f197a36b3b0082c2414" translate="yes" xml:space="preserve">
          <source>Add a &quot;fragmentation&quot; measurement in the output of sqlite3_analyzer.</source>
          <target state="translated">sqlite3_analyzer 출력에 &quot;조각화&quot;측정을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="233e69a92bb5e64e50fa57ffccc06dceae5fcbce" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;http://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=7d539cedb1c&amp;amp;v2=ebad891b7494d&amp;amp;smhdr&quot;&gt;one-character fix&lt;/a&gt; for a problem that might cause incorrect query results on a query that mixes DISTINCT, GROUP BY in a subquery, and ORDER BY. &lt;a href=&quot;http://www.sqlite.org/src/info/98825a79ce1456863&quot;&gt;Ticket 98825a79ce14&lt;/a&gt;.</source>
          <target state="translated">DISTINCT, GROUP BY 및 하위 쿼리를 혼합하는 쿼리에서 잘못된 쿼리 결과를 초래할 수있는 문제에 대해 한 &lt;a href=&quot;http://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=7d539cedb1c&amp;amp;v2=ebad891b7494d&amp;amp;smhdr&quot;&gt;문자 수정&lt;/a&gt; 을 추가하십시오 . &lt;a href=&quot;http://www.sqlite.org/src/info/98825a79ce1456863&quot;&gt;티켓 98825a79ce14&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fef40390b6db6660e8fd5ac547942832b3f403b" translate="yes" xml:space="preserve">
          <source>Add a few #ifdef and build script changes to address compilation issues that appeared after the 3.9.0 release.</source>
          <target state="translated">3.9.0 릴리스 이후에 나타난 컴파일 문제를 해결하기 위해 #ifdef를 몇 개 추가하고 스크립트 변경 사항을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="30713a4bbbb832f4d4a12dd5d80665712406baac" translate="yes" xml:space="preserve">
          <source>Add a limit counter to the query planner to prevent excessive &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; times for certain pathological SQL inputs.</source>
          <target state="translated">특정 병리학 적 SQL 입력에 대해 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 시간이 초과되지 않도록 쿼리 플래너에 제한 카운터를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b8f1d1e0ae5e1fa1781dadcf39fcd78b4b595c9" translate="yes" xml:space="preserve">
          <source>Add a makefile target &quot;sqlite3.c&quot; that builds an amalgamation containing the core SQLite library C code in a single file.</source>
          <target state="translated">핵심 SQLite 라이브러리 C 코드를 포함하는 통합을 단일 파일로 작성하는 makefile 대상 &quot;sqlite3.c&quot;를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ad83f8f8177f2cca17785adb28404967ca258c75" translate="yes" xml:space="preserve">
          <source>Add a new test harness called &quot;mptester&quot; used to verify correct operation when multiple processes are using the same database file at the same time.</source>
          <target state="translated">여러 프로세스가 동일한 데이터베이스 파일을 동시에 사용하는 경우 올바른 작동을 확인하는 데 사용되는 &quot;mptester&quot;라는 새 테스트 하니스를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e847129cbafc1b300962a09db16bffecab4a4530" translate="yes" xml:space="preserve">
          <source>Add a new type of fts5vocab virtual table - &quot;instance&quot; - that provides direct access to an FTS5 full-text index at the lowest possible level.</source>
          <target state="translated">가능한 최저 레벨에서 FTS5 전체 텍스트 인덱스에 직접 액세스 할 수있는 새로운 유형의 fts5vocab 가상 테이블 ( &quot;인스턴스&quot;)을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="feb097c7808e448486c05ee42c0ad6699287c273" translate="yes" xml:space="preserve">
          <source>Add a numeric version number to the sqlite3.h include file.</source>
          <target state="translated">sqlite3.h 포함 파일에 숫자 버전 번호를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="192cfdedd0a31a6c0e19a0d0ffbfa19825b53d8b" translate="yes" xml:space="preserve">
          <source>Add a zero terminator if needed</source>
          <target state="translated">필요한 경우 제로 터미네이터 추가</target>
        </trans-unit>
        <trans-unit id="d0f1497ef21ab12913bab71ba40d0af254e81913" translate="yes" xml:space="preserve">
          <source>Add additional forward compatibility to the future version 3.2 database file format.</source>
          <target state="translated">향후 버전 3.2 데이터베이스 파일 형식에 추가 호환성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="41a75e7708f6493171875bbdcb71d6c0d0c35512" translate="yes" xml:space="preserve">
          <source>Add all changes within the changeset (or patchset) in buffer pData (size nData bytes) to the changegroup.</source>
          <target state="translated">버퍼 pData (크기 nData 바이트)의 변경 세트 (또는 패치 세트) 내의 모든 변경 사항을 변경 그룹에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="53df8d5802795502e64b884c78d43fbcd180d6bf" translate="yes" xml:space="preserve">
          <source>Add an extension loading entry point routine that looks like something the following:</source>
          <target state="translated">다음과 같은 확장 로딩 시작점 루틴을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="99f1bd5a0f02484338a165c19358793d065e8df6" translate="yes" xml:space="preserve">
          <source>Add demonstration code showing how to build a VFS for a raw mass storage without a filesystem.</source>
          <target state="translated">파일 시스템없이 원시 대용량 스토리지를위한 VFS를 구축하는 방법을 보여주는 데모 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="074e15d829469130ecedfd553fe1780886ad13ec" translate="yes" xml:space="preserve">
          <source>Add extension functions &lt;a href=&quot;cli#fileio&quot;&gt;readfile(X) and writefile(X,Y)&lt;/a&gt; (using code copy/pasted from fileio.c in the previous bullet) to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">확장 기능 &lt;a href=&quot;cli#fileio&quot;&gt;readfile (X) 및 writefile (X, Y)&lt;/a&gt; (이전 글 머리 기호의 fileio.c에서 복사 / 붙여 넣기 한 코드 사용)을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5609b29ef4b019538ab2911fb3b91dc194584696" translate="yes" xml:space="preserve">
          <source>Add files to existing archive &lt;em&gt;if&lt;/em&gt; they have changed.</source>
          <target state="translated">파일 이 변경된 &lt;em&gt;경우&lt;/em&gt; 기존 아카이브에 파일을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e66dc568f4c182e96e2de9065612a0db049a1a8" translate="yes" xml:space="preserve">
          <source>Add files to existing archive.</source>
          <target state="translated">기존 아카이브에 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="acbd82da92201959c1e073134cea4dbf8415586f" translate="yes" xml:space="preserve">
          <source>Add forward compatibility to the future version 3.2 database file format.</source>
          <target state="translated">향후 버전 3.2 데이터베이스 파일 형식에 대한 호환성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dd1bef805d2eee9b43a065117a80304d349f0efa" translate="yes" xml:space="preserve">
          <source>Add functions prototypes for the database encryption API.</source>
          <target state="translated">데이터베이스 암호화 API에 대한 함수 프로토 타입을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ee62379e8314b790802298bb169ed3d7eef9f2d4" translate="yes" xml:space="preserve">
          <source>Add interfaces sqlite3_quota_ferror() and sqlite3_quota_file_available() to the test_quota.c module.</source>
          <target state="translated">sqlite3_quota_ferror () 및 sqlite3_quota_file_available () 인터페이스를 test_quota.c 모듈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d9994f198ea8554c8d135ebfa9e7a42a508d9f76" translate="yes" xml:space="preserve">
          <source>Add new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bindptr&quot;&gt;인터페이스를 전달하는&lt;/a&gt; 새 포인터를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c37dbbd1aba851a9c8e067c055285579f7ba5410" translate="yes" xml:space="preserve">
          <source>Add new verbs to &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; so that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method of virtual tables can declare the virtual table as &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">가상 테이블 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메서드가 가상 테이블을 &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt; 로 선언 할 수 있도록 &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config ()에&lt;/a&gt; 새 동사를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6207d3440089bac343c8fc43288997a2214b79" translate="yes" xml:space="preserve">
          <source>Add option support for LIMIT and ORDER BY clauses on &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements. Only works if SQLite is compiled with &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 LIMIT 및 ORDER BY 절에 대한 옵션 지원을 추가하십시오 . SQLite가 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 로 컴파일 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="efbdccfa6f84dcf86953bb91270d5a08c92376ba" translate="yes" xml:space="preserve">
          <source>Add options &quot;--expanded&quot;, &quot;--normalized&quot;, &quot;--plain&quot;, &quot;--profile&quot;, &quot;--row&quot;, &quot;--stmt&quot;, and &quot;--close&quot; to the &quot;.trace&quot; command.</source>
          <target state="translated">&quot;.expanded&quot;, &quot;--normalized&quot;, &quot;--plain&quot;, &quot;--profile&quot;, &quot;--row&quot;, &quot;--stmt&quot;및 &quot;--close&quot;옵션을 &quot;.trace&quot;에 추가하십시오. 명령.</target>
        </trans-unit>
        <trans-unit id="4cbca09144fd7e3e8b43bc8c2d286fd40deac6d2" translate="yes" xml:space="preserve">
          <source>Add options &lt;b&gt;-encoding&lt;/b&gt; and &lt;b&gt;-tcl-uses-utf&lt;/b&gt; to the &lt;b&gt;sqlite&lt;/b&gt; TCL command.</source>
          <target state="translated">옵션 추가 &lt;b&gt;-encoding&lt;/b&gt; 및 &lt;b&gt;-tcl - 사용 - UTF&lt;/b&gt; 받는 &lt;b&gt;SQLite는&lt;/b&gt; TCL 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c2f37fd7facad2de96bd5183bac5e1e1511c68e" translate="yes" xml:space="preserve">
          <source>Add options to the &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; command: --csv, --ascii, --skip</source>
          <target state="translated">&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; 명령에 옵션 추가 : --csv, --ascii, --skip</target>
        </trans-unit>
        <trans-unit id="d573825baf33d38c179e029681eca20a46ccd519" translate="yes" xml:space="preserve">
          <source>Add pluggable tokenizers and &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt; tokenization support to FTS2</source>
          <target state="translated">FTS2에 플러그 가능 토크 나이저 및 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt; 토큰 화 지원 추가</target>
        </trans-unit>
        <trans-unit id="72c6bdab5b3258b6277e55104bb87d93b720f14a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;.open --hexdb&quot;. The &quot;&lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;dbtotxt&lt;/a&gt;&quot; utility program used to generate the text for the &quot;hexdb&quot; is added to the source tree.</source>
          <target state="translated">&quot;.open --hexdb&quot;에 대한 지원을 추가하십시오. &quot; &lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;hexdb&lt;/a&gt; &quot;에 대한 텍스트를 생성하는 데 사용되는 &quot; dbtotxt &quot;유틸리티 프로그램이 소스 트리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a0763ade3c8a449006c413b6f49449ce7b3a928a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; FOLLOWING&lt;/a&gt;&quot; boundaries in RANGE &lt;a href=&quot;windowfunctions#framespec&quot;&gt;frames&lt;/a&gt;.</source>
          <target state="translated">&quot;에 대한 지원을 추가 &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;EXPR&amp;gt; PRECEDING&lt;/a&gt; &quot; &quot;를 &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;파악하기 &amp;lt;EXPR&amp;gt;&lt;/a&gt; RANGE의에서 경계&quot; &lt;a href=&quot;windowfunctions#framespec&quot;&gt;프레임&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e92f21bcec77d71c0f65f3070792505ed0c70690" translate="yes" xml:space="preserve">
          <source>Add support for &quot;PRAGMA page_size&quot; to adjust the page size of the database.</source>
          <target state="translated">&quot;PRAGMA page_size&quot;에 대한 지원을 추가하여 데이터베이스의 페이지 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="aa2fb3ed1f060dfe837a3d960578d49b6bc22685" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;gencol&quot;&gt;생성 된 열에&lt;/a&gt; 대한 지원을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3c5f5d30415f9f1977e35ba188ec9b5fcd474e" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;.</source>
          <target state="translated">에 대한 지원을 추가 &lt;a href=&quot;mmap&quot;&gt;메모리 매핑 I / O&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4c8688bed6db9be32019244a2d807910dea0cc" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 지원 추가</target>
        </trans-unit>
        <trans-unit id="c5b2de4466aa197bc12dce31206322740e3db16d" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;rtree#auxcol&quot;&gt;auxiliary columns in r-tree tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtree#auxcol&quot;&gt;r- 트리 테이블에서 보조 열에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f90c29b7cfc3c62f6507d98b86aed5242ee68ae7" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 지원 추가</target>
        </trans-unit>
        <trans-unit id="af696b60eb69d945c8a46227c312eb8878086caa" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;윈도우 기능에&lt;/a&gt; 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="136f3b0eed5bac09b5f3815f7575bda175da3514" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS frames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS 프레임에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e66dce38847e4f4f6cc41e4cccbb39be56c45c40" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#wchaining&quot;&gt;window chaining&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#wchaining&quot;&gt;창 체인에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="212edd25833b5883700b116710f87eea867169b2" translate="yes" xml:space="preserve">
          <source>Add support for DEFERRED, IMMEDIATE, and EXCLUSIVE transactions.</source>
          <target state="translated">DEFERRED, IMMEDIATE 및 EXCLUSIVE 트랜잭션에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5fb939adf84fb0194534bbaf8a41088037bb5c1e" translate="yes" xml:space="preserve">
          <source>Add support for INSERT OR REPLACE, INSERT OR IGNORE, and UPDATE OR REPLACE in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블&lt;/a&gt; 에서 INSERT OR REPLACE, INSERT OR IGNORE 및 UPDATE OR REPLACE에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2330e77a6f10374d78e1306109d17dffa46e862" translate="yes" xml:space="preserve">
          <source>Add support for PostgreSQL-style &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 스타일 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="890cc871d57b4e2f53773580ef56c71b18a22739" translate="yes" xml:space="preserve">
          <source>Add support for coverage testing of VDBE programs using the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt; verb of &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt; 동사를 사용하여 VDBE 프로그램의 적용 범위 테스트 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="be6c363a6bf564dc52386b7db08ec41552cf1d89" translate="yes" xml:space="preserve">
          <source>Add support for handling &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; virtual tables. &lt;a href=&quot;#vtab&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; 가상 테이블 처리에 대한 지원을 추가하십시오 . &lt;a href=&quot;#vtab&quot;&gt;자세한 내용은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a526c3a38229774d8ba86548def1a8d12a36b235" translate="yes" xml:space="preserve">
          <source>Add support for renaming columns within a table using ALTER TABLE</source>
          <target state="translated">ALTER TABLE을 사용하여 테이블 내에서 열 이름 바꾸기 지원 추가</target>
        </trans-unit>
        <trans-unit id="d659c9c8cb6c1f04393b0fc5e63bbdac64002cf9" translate="yes" xml:space="preserve">
          <source>Add support for tab-completion using the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt;, for both readline and linenoise.</source>
          <target state="translated">readline 및 linenoise에 대해 &lt;a href=&quot;completion&quot;&gt;COMPLETION 확장을&lt;/a&gt; 사용하여 탭 완성에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4eee573107dab889c4b93bbd22bffbdf1483817" translate="yes" xml:space="preserve">
          <source>Add support for the &quot;--maxsize N&quot; option on &quot;.open --deserialize&quot;.</source>
          <target state="translated">&quot;.open --deserialize&quot;에 &quot;--maxsize N&quot;옵션에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="31f5d3e263c4687cf09a721220bb511aa4a69c6f" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;FILTER clause on aggregate functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;집계 함수에 FILTER 절에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f217130627272aa13b670d0e6f0d5167655ce0bd" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt; and &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt; syntax in &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; clauses.</source>
          <target state="translated">&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; 절 에서 &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt; 및 &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt; 구문에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4007f3ce6829066fa4409e2ecd136e62637d894" translate="yes" xml:space="preserve">
          <source>Add support for the full SQL-92 join syntax and LEFT OUTER JOINs.</source>
          <target state="translated">전체 SQL-92 조인 구문 및 LEFT OUTER JOIN에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3a2eb33317dae4a033cc092362d492fb572cccd4" translate="yes" xml:space="preserve">
          <source>Add support for wildcard parameters of the form: &quot;?nnn&quot;</source>
          <target state="translated">&quot;? nnn&quot;형식의 와일드 카드 매개 변수에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb80b8d534ca7c36dc1e214c6909a01fde00f37" translate="yes" xml:space="preserve">
          <source>Add support the &lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE clause&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE 절&lt;/a&gt; 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ab8baa6625378dcd2fbc2b48fe42102792d59fe" translate="yes" xml:space="preserve">
          <source>Add tclsqlite.c to the libsqlite.a library</source>
          <target state="translated">libsqlite.a 라이브러리에 tclsqlite.c 추가</target>
        </trans-unit>
        <trans-unit id="936423dc9b571e197d4ed47a549d3e24bf5f5c1f" translate="yes" xml:space="preserve">
          <source>Add tests to make sure that tclsqlite was compiled using Tcl header files and libraries that match.</source>
          <target state="translated">tclsqlite가 일치하는 Tcl 헤더 파일 및 라이브러리를 사용하여 컴파일되었는지 확인하는 테스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8e0200d4b2125e37622440b4e128b278c449eb8c" translate="yes" xml:space="preserve">
          <source>Add the &quot;%token_class&quot; directive to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; and use it to simplify the grammar.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기에&lt;/a&gt; &quot;% token_class&quot;지시문을 추가하고 문법을 단순화하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="283b2638c2b05ae208073cb37d46fd5320238943" translate="yes" xml:space="preserve">
          <source>Add the &quot;--async&quot; option to the &quot;.backup&quot; command.</source>
          <target state="translated">&quot;.async&quot;옵션을 &quot;.backup&quot;명령에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6e8b7b2093500ea36f5f180a7347d1d5a53d8fe" translate="yes" xml:space="preserve">
          <source>Add the &quot;--memtrace&quot; command-line option, to show all memory allocations and deallocations.</source>
          <target state="translated">&quot;--memtrace&quot;명령 행 옵션을 추가하여 모든 메모리 할당 및 할당 해제를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="216e54fa647db35fda70c92921d3229237ed92dd" translate="yes" xml:space="preserve">
          <source>Add the &quot;.binary&quot; and &quot;.limits&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.binary&quot;및 &quot;.limits&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8da8fe6a9987104191ff2baa0e3404f2a667db" translate="yes" xml:space="preserve">
          <source>Add the &quot;.cd&quot; command.</source>
          <target state="translated">&quot;.cd&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d55280d1b7b3a8bbfa8326a3e6f14a48e7308e" translate="yes" xml:space="preserve">
          <source>Add the &quot;.clone&quot; and &quot;.save&quot; commands to the command-line shell.</source>
          <target state="translated">&quot;.clone&quot;및 &quot;.save&quot;명령을 명령 행 쉘에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c7d25cbe44023d988e7e9d81da8b1c5eafbc6826" translate="yes" xml:space="preserve">
          <source>Add the &quot;.eqp trace&quot; option on builds with SQLITE_DEBUG, to enable bytecode program listing with indentation and &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace&lt;/a&gt; all in one step.</source>
          <target state="translated">SQLITE_DEBUG를 사용하여 빌드시 &quot;.eqp 추적&quot;옵션을 추가하여 들여 쓰기 및 &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace&lt;/a&gt; 를 사용하여 바이트 코드 프로그램 목록을 모두 한 번 에 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="97816312767ca4a2c31df9a27f1fb491af457876" translate="yes" xml:space="preserve">
          <source>Add the &quot;.filectrl&quot; command useful for testing.</source>
          <target state="translated">테스트에 유용한 &quot;.filectrl&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="762e62184ff88d2ac7f6d5e9106bb08dbc9e2cb4" translate="yes" xml:space="preserve">
          <source>Add the &quot;.import&quot; command to the command-line shell.</source>
          <target state="translated">&quot;.import&quot;명령을 명령 행 쉘에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cc49dc138146b590b8cff67298e595fca2d6f169" translate="yes" xml:space="preserve">
          <source>Add the &quot;.progress&quot; command for accessing the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; 인터페이스 에 액세스하기 위해 &quot;.progress&quot;명령을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7c0e14ee7666efcfedda1a8139570d6579e1c44" translate="yes" xml:space="preserve">
          <source>Add the &quot;.recover&quot; command which tries to recover as much content as possible from a corrupt database file.</source>
          <target state="translated">손상된 데이터베이스 파일에서 가능한 한 많은 내용을 복구하려고하는 &quot;.recover&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1e8a4b92340d9f7a1f000bec88f280625487d118" translate="yes" xml:space="preserve">
          <source>Add the &quot;.system&quot; and &quot;.once&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.system&quot;및 &quot;.once&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88db3041288101d122dcba112957a35b89342c78" translate="yes" xml:space="preserve">
          <source>Add the &quot;.testcase&quot; and &quot;.check&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;.</source>
          <target state="translated">&quot;.testcase&quot;및 &quot;.check&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;도트 명령을&lt;/a&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="80eb0002e6ca30dbe7265165c28f78bf3c05f869" translate="yes" xml:space="preserve">
          <source>Add the &quot;.wheretrace&quot; command when compiled with SQLITE_DEBUG</source>
          <target state="translated">SQLITE_DEBUG로 컴파일 할 때 &quot;.wheretrace&quot;명령 추가</target>
        </trans-unit>
        <trans-unit id="8804479c26e1da45bb9e3ed0888fbc0d4a08ae1c" translate="yes" xml:space="preserve">
          <source>Add the &quot;totype.c&quot; extension, implementing the tointeger() and toreal() SQL functions.</source>
          <target state="translated">&quot;totype.c&quot;확장을 추가하여 tointeger () 및 toreal () SQL 함수를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="92a34239c6cf2de2a3fdbbe86a2b80a08fe2e86b" translate="yes" xml:space="preserve">
          <source>Add the --bom option to the &lt;a href=&quot;cli#dotexcel&quot;&gt;.excel&lt;/a&gt;, &lt;a href=&quot;cli#dotoutput&quot;&gt;.output&lt;/a&gt;, and &lt;a href=&quot;cli#dotoutput&quot;&gt;.once&lt;/a&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;cli#dotexcel&quot;&gt;.excel&lt;/a&gt; , &lt;a href=&quot;cli#dotoutput&quot;&gt;.output&lt;/a&gt; 및 &lt;a href=&quot;cli#dotoutput&quot;&gt;.once&lt;/a&gt; 명령에 --bom 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="df81e72aa83e90414fe2ffd4c6cb48365750ab99" translate="yes" xml:space="preserve">
          <source>Add the -withoutnulls option to the &lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL interface eval method&lt;/a&gt;.</source>
          <target state="translated">-withoutnulls 옵션을 &lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL 인터페이스 평가 방법에&lt;/a&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe5b9c333c6038520094761f864493e2e7097cc4" translate="yes" xml:space="preserve">
          <source>Add the .oom command in debugging builds</source>
          <target state="translated">디버깅 빌드에 .oom 명령 추가</target>
        </trans-unit>
        <trans-unit id="4f125709e724b34ac5ad47f8eda53803f5734890" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="40592c218ccd34fab463deb3f03be7da30417f9c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; verb for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; 동사를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e48cfd1c7357fb4864216d4d254e3beabe8b5a2d" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="be8b97d6b9385048b55638f312823bb2eb008ce5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; file control.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 파일 컨트롤을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="081364f71e5fefa3da91ea51b10405c027faaabe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; for setting an upper bound on the size of the in-memory database created by sqlite3_deserialize. The default upper bound is 1GiB, or whatever alternative value is specified by &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;) and/or &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;.</source>
          <target state="translated">sqlite3_deserialize로 작성된 메모리 내 데이터베이스의 크기에 상한을 설정하기 위해 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 를 추가하십시오 . 기본 상한은 1GiB이거나 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt; ) 및 / 또는 &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE에&lt;/a&gt; 의해 지정된 대체 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5d92af1fb4c4ac1e07a26f5836df488794b6bbdc" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe034b4f2512875ab8ea3e02c36867f516b685b5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt; interface, allowing applications to disable automatically loaded virtual tables that they do not need.</source>
          <target state="translated">&lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt; 인터페이스를 추가하여 애플리케이션이 필요하지 않은 자동로드 된 가상 테이블을 비활성화 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="35fb0feea0a1d59c3a8842f9214443f77d92d83e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface and the corresponding &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt; command.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()&lt;/a&gt; 인터페이스와 해당 &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA의 hard_heap_limit의&lt;/a&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1930b99359d377b2cc8ba418ec5abbff446f6fae" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/open#opennofollow&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; option to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; that prevents SQLite from opening symbolic links.</source>
          <target state="translated">SQLite가 심볼릭 링크를 열지 못하게 하는 &lt;a href=&quot;c3ref/open#opennofollow&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; 옵션을 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="21d27cce565db8490729a43e1af27acdeb1a1d96" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application-defined page cache&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="a4d7eada875b03c7029bca58ac2ddc67b6735f11" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces when the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 컴파일 타임 옵션이 사용될 때 &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="065e4967252d67f2418c2b348070eac9ee82255f" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt; convenience interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 편의 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb552cbe49d24f288fc511724cd559eb4a233c0e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_key()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_key ()&lt;/a&gt; 인터페이스를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="52490b8c94f339853539d2cd7b35574401e395a9" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface in support of &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 과 함께 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절을 지원 하도록 &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e9c1c8302237fd30d6977796970b681fda7464c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;cksumvfs&quot;&gt;checksum VFS shim&lt;/a&gt; to the set of run-time loadable extensions included in the source tree.</source>
          <target state="translated">소스 트리에 포함 된 런타임로드 가능한 확장 집합에 &lt;a href=&quot;cksumvfs&quot;&gt;체크섬 VFS shim&lt;/a&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b4f5bebd726b497704665ee703792c5087bc4e88" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. Setting this option to 0 disables automatic indices by default.</source>
          <target state="translated">&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 . 이 옵션을 0으로 설정하면 기본적으로 자동 인덱스가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="470112a79227f7c994e11abc7f3c3d991569cdaa" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="85aebd6ee91874adb96cb2db93f6f4d317b58eb7" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="21a90d69aeda9911ff14bd96ba3dda734bfd8d53" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt; compile-time option to force the &lt;a href=&quot;rtree&quot;&gt;R*Tree Extension Module&lt;/a&gt; to use integer instead of floating point values for both storage and computation.</source>
          <target state="translated">&lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt; 컴파일 타임 옵션을 추가하여 &lt;a href=&quot;rtree&quot;&gt;R * Tree Extension Module&lt;/a&gt; 이 스토리지 및 계산에 부동 소수점 값 대신 정수를 사용하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e8f43e6254598c7b3221cade8d257bd4fa709b38" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;dbstat#dbstatagg&quot;&gt;aggregated mode&lt;/a&gt; feature to the &lt;a href=&quot;dbstat&quot;&gt;DBSTAT virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dbstat#dbstatagg&quot;&gt;집계 모드&lt;/a&gt; 기능을 &lt;a href=&quot;dbstat&quot;&gt;DBSTAT 가상 테이블에&lt;/a&gt; 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="15e9f2fd2f640e3984cdc406903ee8672531ce05" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4 &quot;merge&quot; command&lt;/a&gt;, the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4 &quot;automerge&quot; command&lt;/a&gt;, and the &lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4 &quot;integrity-check&quot; command&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4 &quot;병합&quot;명령&lt;/a&gt; 의 &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4 &quot;자동 병합&quot;명령&lt;/a&gt; 및 &lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4 &quot;무결성 검사&quot;명령을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98046a6bd29ea22d322eeeda3a2f3bdacd96dcab" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; loadable extension - a VFS shim that measures I/O together with an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that provides access to the measurements.</source>
          <target state="translated">측정에 대한 액세스를 제공 하는 &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;시상 &lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 과 함께 I / O를 측정하는 VFS 심인 vfsstat.c 로드 가능 확장을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7cd3c312e6d704d9ddb06fdac7e44b6ba43e781a" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; 절을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f9efcb02f9ffd6cbf45dbb655ea785d5db4c65" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; that converts a LEFT JOIN into an ordinary JOIN if there exist terms in the WHERE clause that would prevent the extra all-NULL row of the LEFT JOIN from appearing in the output set.</source>
          <target state="translated">추가 &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT를 강도 감소 최적화 가입&lt;/a&gt; 이 왼쪽의 추가 모든 NULL 행을 방해하는 WHERE 절에 조건을 존재하는 출력 세트에 나타나지 가입하는 경우 LEFT가 일반에 가입 변환이 가입 것을.</target>
        </trans-unit>
        <trans-unit id="6294f954692677e23d4407af3d20a5f13384a9c1" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; command that causes the &quot;ALTER TABLE RENAME&quot; command to behave as it did in SQLite versions 3.24.0 and earlier: references to the renamed table inside the bodies of triggers and views are not updated. This new pragma provides a compatibility work around for older programs that expected the older, wonky behavior of ALTER TABLE RENAME.</source>
          <target state="translated">SQLite 3.24.0 및 이전 버전에서와 같이 &quot;ALTER TABLE RENAME&quot;명령이 작동하게 하는 &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt; 명령을 추가하십시오 . 트리거 및 뷰 본문 내의 이름이 바뀐 테이블에 대한 참조는 업데이트되지 않습니다. 이 새로운 pragma는 ALTER TABLE RENAME의 오래되고 기발한 동작을 예상했던 이전 프로그램에 대한 호환성 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b9e0bbc3322ff734087f22e70d84d21a6e7a30fe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt;, &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt; and &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt; methods in &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; in support of &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; for virtual tables.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 를 지원 하기 위해 가상 테이블에 &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt; , &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt; 및 &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt; 메소드를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ed36cb9eb24ef6e4831d3cb6e75c5a505ce11d8" translate="yes" xml:space="preserve">
          <source>Add the &lt;b&gt;sqlite_version[]&lt;/b&gt; string constant to the library</source>
          <target state="translated">라이브러리에 &lt;b&gt;sqlite_version []&lt;/b&gt; 문자열 상수 추가</target>
        </trans-unit>
        <trans-unit id="1a77c4f39c42e3d8e465cea41bb54ff783957906" translate="yes" xml:space="preserve">
          <source>Add the COLLATE operator used to explicitly set the collating sequence used by an expression. This feature is considered experimental pending additional testing.</source>
          <target state="translated">표현식에서 사용하는 조합 순서를 명시 적으로 설정하는 데 사용되는 COLLATE 연산자를 추가하십시오. 이 기능은 추가 테스트가 보류중인 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="29546c6fbd4241b614f52b701e19fb42190f52db" translate="yes" xml:space="preserve">
          <source>Add the MEMORY option to the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma에&lt;/a&gt; MEMORY 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="08441390d486d4a704f4d3ebdd1c1a4095467616" translate="yes" xml:space="preserve">
          <source>Add the ability for INSERT and UPDATE statements to refer to the &quot;rowid&quot; (or &quot;_rowid_&quot; or &quot;oid&quot;) columns.</source>
          <target state="translated">INSERT 및 UPDATE 문에 &quot;rowid&quot;(또는 &quot;_rowid_&quot;또는 &quot;oid&quot;) 열을 참조하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="91d47c24f96a5ac57ed4cd528de551cd89df640b" translate="yes" xml:space="preserve">
          <source>Add the ability to change the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; status of a database by setting the auto_vaccum pragma and VACUUMing the database.</source>
          <target state="translated">auto_vaccum pragma를 설정하고 데이터베이스를 VACUUMing하여 데이터베이스 의 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 상태 를 변경하는 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="90b4842e5d50e9cfd8c2600caa26cf77f6f838dc" translate="yes" xml:space="preserve">
          <source>Add the ability to do MSVC Windows builds from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt; 에서 MSVC Windows 빌드 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9cc0bb08d1187beca47dd9f85ca607d55ca39f7" translate="yes" xml:space="preserve">
          <source>Add the ability to find a full-index-scan query plan for queries using &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; which previously would fail with &quot;no query solution&quot;.</source>
          <target state="translated">이전에는 &quot;쿼리 솔루션 없음&quot;으로 실패했던 &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; 를 사용하여 쿼리에 대한 전체 인덱스 스캔 쿼리 계획을 찾는 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4db540a1419635a899fe1e123412560851c41e" translate="yes" xml:space="preserve">
          <source>Add the ability to implement FROM clause subqueries as coroutines rather that manifesting the subquery into a temporary table.</source>
          <target state="translated">하위 쿼리를 임시 테이블에 표시하는 대신 FROM 절 하위 쿼리를 코 루틴으로 구현하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="641284aafcb663d3733121dbe152ab06583bd76f" translate="yes" xml:space="preserve">
          <source>Add the ability to put TABLE.* in the column list of a SELECT statement.</source>
          <target state="translated">SELECT.의 열리스트에 TABLE. *를 넣는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="76eab5ccc29a6c69261726a47189c3c56c533ee9" translate="yes" xml:space="preserve">
          <source>Add the ability to put a single .command in the second argument of the sqlite shell</source>
          <target state="translated">sqlite 쉘의 두 번째 인수에 단일 .command를 넣는 기능 추가</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
