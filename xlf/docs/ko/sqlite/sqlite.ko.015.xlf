<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="translated">DBSTAT 가상 테이블</target>
        </trans-unit>
        <trans-unit id="97ceb7c4621bdd8f62a9cfbb2a879b8e9e999bd7" translate="yes" xml:space="preserve">
          <source>The DBSTAT table only reports on the content of btrees within the database file. Freelist pages, pointer-map pages, and the lock page are omitted from the analysis.</source>
          <target state="translated">DBSTAT 테이블은 데이터베이스 파일 내의 btree 내용에 대해서만보고합니다. 자유 목록 페이지, 포인터 맵 페이지 및 잠금 페이지는 분석에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="76cd10f2092ca8f1b285dee48937f8c50e332d42" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about the amount of disk space used to store the content of an SQLite database. Example use cases for the DBSTAT virtual table include the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program and the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">DBSTAT 가상 테이블은 SQLite 데이터베이스의 콘텐츠를 저장하는 데 사용되는 디스크 공간의 양에 대한 정보를 반환 하는 읽기 전용 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; 입니다. DBSTAT 가상 테이블의 예제 사용 사례에는 SQLite 용 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 구현&lt;/a&gt; 버전 제어 시스템 의 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램과 &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;테이블 크기 원형 차트가 포함&lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">dbstat와 가상 테이블은 읽기 전용입니다 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; 을 반환 정보가있는에 대한 데이터베이스 파일의 페이지가 사용하는 스키마에있는 테이블과 인덱스에 의해. DBSTAT 가상 테이블은 &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; 유틸리티 프로그램 을 구현 하고 SQLite 용 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 구현&lt;/a&gt; 버전 제어 시스템 에서 &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;테이블 크기 원형 차트&lt;/a&gt; 를 계산하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ce5a525fa3a87844d5ab55ef30cdd54b0cc3c2" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">DBSTAT 가상 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블입니다&lt;/a&gt; . 즉, 사용하기 전에 dbstat 가상 테이블의 인스턴스를 생성하기 위해 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 을 실행할 필요가 없습니다 . &quot;dbstat&quot;모듈 이름은 dbstat 가상 테이블을 직접 쿼리하는 테이블 이름 인 것처럼 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f357b6765d9672540c415d35375e9c82ab3dde27" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">DBSTAT 가상 테이블은 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 컴파일 시간 옵션을 사용하여 SQLite를 빌드 할 때 모든 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="translated">DEFAULT 절은 &lt;a href=&quot;lang_insert&quot;&gt;INSERT를&lt;/a&gt; 수행 할 때 사용자가 명시 적으로 값을 제공하지 않으면 열에 사용할 기본값을 지정합니다 . 열 정의에 명시 적 DEFAULT 절이 첨부되지 않은 경우 열의 기본값은 NULL입니다. 명시 적 DEFAULT 절은 기본값이 NULL, 문자열 상수, 얼룩 상수, 부호있는 숫자 또는 괄호로 묶인 상수 표현식임을 지정할 수 있습니다. 기본값은 대소 문자를 구분하지 않는 특수 키워드 CURRENT_TIME, CURRENT_DATE 또는 CURRENT_TIMESTAMP 중 하나 일 수도 있습니다. DEFAULT 절의 목적 상, 서브 쿼리, 열 또는 테이블 참조, &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 또는 작은 따옴표 대신 큰 따옴표로 묶인 문자열 리터럴 이없는 표현식은 상수로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="translated">DELETE 명령은 &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;Qualified-table-name으로&lt;/a&gt; 식별 된 테이블에서 레코드를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="translated">WHILE 절이없는 DELETE 명령은 레코드별로 레코드를 삭제하거나 삭제하지 않고 디스크에서 데이터베이스 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="translated">DELETE 저널링 모드는 정상적인 동작입니다. 삭제 모드에서 롤백 저널은 각 트랜잭션이 끝날 때 삭제됩니다. 실제로 삭제 작업은 트랜잭션을 커밋하는 작업입니다. (자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 문서를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="translated">컨텐츠 테이블에서 실제 삭제를 수행하기 전에 DELETE 트리거를 시작해야합니다. FTS4가 여전히 전체 텍스트 인덱스를 업데이트하기 위해 원래 값을 검색 할 수 있습니다. 그리고 시스템 내에서 rowid가 자동으로 할당되는 경우를 처리 할 수 ​​있도록 새 행을 삽입 한 후에 INSERT 트리거를 시작해야합니다. UPDATE 트리거는 동일한 이유로 컨텐츠 테이블 업데이트 전후에 발생하는 두 부분으로 나누어야합니다.</target>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="translated">DELETE 모드 잠금은 기본 데이터베이스 파일 의 &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;잠금 바이트 페이지&lt;/a&gt; 에 저장됩니다. SQLITE_LOCK_SHARED 및 SQLITE_LOCK_EXCLUSIVE 만 WAL 모드 데이터베이스의 요소입니다. 다른 잠금 상태는 롤백 모드에서 사용되지만 WAL 모드에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="translated">집계 쿼리의 DISTINCT 키워드</target>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="translated">DISTINCT 키워드는 적절한 색인을 사용할 수 있고 최적화 프로그램에서 사용이 유리하다고 생각할 때 때때로 INDEX를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="translated">집계 쿼리의 DISTINCT 키워드는 임시 파일에 임시 색인을 작성하고 각 결과 행을 해당 색인에 저장하여 구현됩니다. 새 결과 행이 계산되면 임시 색인에 이미 존재하는지와 새 결과 행이 있는지 확인하기 위해 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="translated">DROP INDEX 문은 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문으로 추가 된 색인을 제거합니다 . 디스크에서 인덱스가 완전히 제거됩니다. 인덱스를 복구하는 유일한 방법은 적절한 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 명령 을 다시 입력하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="translated">DROP TABLE 문은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문으로 추가 된 테이블을 제거합니다 . 지정된 이름이 테이블 이름입니다. 삭제 된 테이블은 데이터베이스 스키마 및 디스크 파일에서 완전히 제거됩니다. 테이블을 복구 할 수 없습니다. 테이블과 관련된 모든 인덱스 및 트리거도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">DROP TRIGGER 문은 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로 작성된 트리거를 제거합니다 . 일단 제거되면 트리거 정의가 더 이상 sqlite_master (또는 sqlite_temp_master) 테이블에 존재하지 않으며 후속 INSERT, UPDATE 또는 DELETE 문에 의해 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="translated">DROP VIEW 문은 &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 문으로 작성된보기를 제거합니다 . 뷰 정의는 데이터베이스 스키마에서 제거되지만 기본 테이블의 실제 데이터는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="translated">Dbbe 추상화와 GDBM 및 메모리 드라이버가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="translated">SQLite 3.12.0의 기본 페이지 크기 변경</target>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="translated">복합 쿼리에 대한 EXCEPT 연산자는 임시 파일에 임시 색인을 작성하고이 임시 색인에 왼쪽 서브 쿼리의 결과를 저장 한 후 오른쪽 서브 쿼리의 결과를 임시 색인에서 제거하고 마지막으로 색인을 시작하여 구현됩니다. 최종 출력을 얻기 위해 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="translated">EXISTS 연산자</target>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="translated">EXISTS 연산자는 항상 정수 값 0과 1 중 하나로 평가됩니다. EXISTS 연산자의 오른쪽 피연산자로 지정된 SELECT 문을 실행하면 하나 이상의 행이 리턴되면 EXISTS 연산자는 1로 평가됩니다. 행을 전혀 반환하지 않으면 EXISTS 연산자는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="translated">EXPLAIN QUERY PLAN 명령에 대한 &lt;a href=&quot;eqp&quot;&gt;자세한 내용은 여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="translated">EXPLAIN 및 EXPLAIN QUERY PLAN 접두사는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 실행하는 동작에 영향을줍니다 . &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 이와 유사한 것을 사용하여 새로운 준비된 명령문을 생성하는 프로세스 는 (대부분) EXPLAIN의 영향을받지 않습니다. (이전 문장의 예외는 EXPLAIN QUERY PLAN 준비 명령문을 빌드 할 때 EXPLAIN QUERY PLAN에서 사용하는 일부 특수 opcode가 성능 최적화로 생략 된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="translated">오류 및 경고 로그</target>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="translated">FAIL 동작은 고유성, NOT NULL 및 CHECK 제약 조건에서만 작동합니다. &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건의&lt;/a&gt; 위반은 ABORT가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="translated">트리거의 FOR EACH STATEMENT 절이 구문 오류를 발생시킵니다. 예전에는 무시당했습니다.</target>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="translated">FTS 모듈은 두 가지 약간 다른 버전의 전체 텍스트 쿼리 구문 인 &quot;표준&quot;쿼리 구문과 &quot;향상된&quot;쿼리 구문 중 하나를 사용하도록 컴파일 될 수 있습니다. 위에서 설명한 기본 용어, 용어 접두사, 구문 및 NEAR 쿼리는 두 버전의 구문에서 동일합니다. 세트 연산이 지정되는 방식은 약간 다릅니다. 다음 두 하위 섹션에서는 작업 설정과 관련된 두 쿼리 구문의 일부를 설명합니다. 컴파일 노트는 &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;fts&lt;/a&gt; 를 컴파일 하는 방법에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="translated">FTS 쿼리 구문 (MATCH 연산자의 오른쪽)이 몇 가지 방식으로 변경되었습니다. FTS5 구문은 FTS4 &quot;향상된 구문&quot;에 매우 가깝습니다. 주요 차이점은 FTS5가 인식 할 수없는 문장 부호 문자에 대해 더 까다 롭고 쿼리 문자열 내에서 유사하다는 것입니다. FTS3 / 4에서 작동하는 대부분의 쿼리는 FTS5에서도 작동해야하며 구문 분석 오류를 반환하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="translated">반환 된 텍스트 조각을 추출 할 FTS 테이블 열 번호입니다. 열은 왼쪽에서 오른쪽으로 0부터 시작하여 번호가 매겨집니다. 음수 값은 텍스트가 임의의 열에서 추출 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="translated">FTS3 및 FTS4 확장 모듈을 사용하면 내장 된 전체 텍스트 인덱스 (이하 &quot;FTS 테이블&quot;)가있는 특수 테이블을 만들 수 있습니다. 전체 텍스트 인덱스를 사용하면 테이블에 많은 큰 문서가 포함되어 있어도 하나 이상의 단어 (이하 &quot;토큰&quot;)가 포함 된 모든 행에 대해 데이터베이스를 효율적으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="translated">FTS3 및 FTS4 모듈은 전체 텍스트 쿼리 시스템 개발자에게 유용한 &quot;스 니펫&quot;, &quot;오프셋&quot;및 &quot;matchinfo&quot;의 세 가지 특수 SQL 스칼라 함수를 제공합니다. &quot;스 니펫&quot;및 &quot;오프셋&quot;기능의 목적은 사용자가 반환 된 문서에서 쿼리 된 용어의 위치를 ​​식별 할 수 있도록하는 것입니다. &quot;matchinfo&quot;기능은 관련성에 따라 쿼리 결과를 필터링하거나 정렬하는 데 유용한 메트릭을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="translated">FTS3 확장은 주요 재 작업 및 정리를 거쳤습니다. 새로운 &lt;a href=&quot;fts3&quot;&gt;FTS3 문서&lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4 &quot;automerge = X&quot;명령이 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge 옵션&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="translated">FTS3 / 4 &quot;merge = X, Y&quot;명령이 &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge 명령&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="translated">FTS4 접두사 옵션은 FTS가 항상 완전한 용어를 색인화하는 것과 같은 방식으로 지정된 길이의 용어 접 두부를 색인화합니다. 접두사 옵션은 쉼표로 구분 된 양수가 아닌 정수 목록으로 설정해야합니다. 목록의 각 값 N에 대해 길이가 N 바이트 인 접두어 (UTF-8을 사용하여 인코딩 된 경우)가 색인화됩니다. FTS4는 용어 접두사 인덱스를 사용하여 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두사 쿼리&lt;/a&gt; 속도를 높 입니다. 물론 전체 용어뿐만 아니라 색인 용어 접두어는 데이터베이스 크기를 늘리고 FTS4 테이블에서 쓰기 작업을 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="translated">동기식 pragma가 &quot;full&quot;이외의 것으로 설정된 경우 F_FULLSYNC ioctl (현재 Mac OS X에서만 지원됨)이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="translated">화석 NGQP 업그레이드 사례 연구</target>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="translated">TAGXREF_I1 색인의 가장 왼쪽 열 (TAGID 열)에 대해 동일한 값을 가진 TAGXREF 테이블에 10 천 개가 넘는 항목이 있기 때문에이 문서의 이전 섹션에서 설명한 화석 성능 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="translated">화석보기는 지점이 결국 트렁크로 다시 병합되었음을 분명히 보여줍니다. 분기가 시작된 위치를 표시하고 트렁크의 변경 사항이 분기에 병합 된 두 가지 경우를 보여줍니다. GitHub는이 중 어느 것도 보여주지 않습니다. 실제로 GitHub 디스플레이는 어떤 일이 발생했는지 파악하는 데 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="translated">Fts5PhraseIter 구조는 위에 정의되어 있습니다. 응용 프로그램은이 구조를 직접 수정해서는 안됩니다. xPhraseFirst () 및 xPhraseNext () API 메서드와 함께 (아래 그림과 같이 xPhraseFirstColumn () 및 xPhraseNextColumn ()에 의해) 위에 표시된 대로만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="translated">GLOB 연산자는 항상 대소 문자를 구분합니다. GLOB 연산자의 왼쪽 열은 항상 내장 BINARY 배열 순서를 사용해야합니다. 그렇지 않으면 해당 연산자를 인덱스로 최적화하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="translated">GLOB 연산자는 LIKE와 비슷하지만 와일드 카드에 유닉스 파일 글 로빙 구문을 사용합니다. 또한 GLOB은 LIKE와 달리 대소 문자를 구분합니다. GLOB와 LIKE 앞에 NOT 키워드를 붙여 테스트 의미를 반전시킬 수 있습니다. 삽입 GLOB 연산자는 &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; )&lt;/a&gt; 함수를 호출하여 구현되며 해당 함수를 대체하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="translated">SQLite R * Tree 모듈에 대한 Geopoly 인터페이스</target>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="translated">Geopoly 모듈은 &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 표기법 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt; )을 사용하여 2 차원 다각형을 설명 하는 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장에&lt;/a&gt; 대한 대체 인터페이스 입니다. Geopoly에는 다각형으로 둘러싸인 영역을 계산하거나 다각형의 선형 변형을 수행하거나 다각형을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; 로 렌더링하기위한 다각형 및 기타 유사한 작업 을 수행하기 위해 하나의 다각형이 다른 다각형 내에 포함되거나 중복되는시기를 감지하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="translated">Geopoly 모듈은 GeoJSON의 작은 부분 집합 만 이해하지만 중요한 부분 집합을 이해합니다. 특히 GeoJSON은 간단한 다각형을 설명하는 정점의 JSON 배열을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="translated">ICU 토크 나이저 구현은 매우 간단합니다. 단어 경계를 찾기 위해 ICU 규칙에 따라 입력 텍스트를 분할하고 공백으로 구성된 토큰을 모두 버립니다. 이는 일부 로케일의 일부 응용 프로그램에 적합 할 수 있지만 전부는 아닙니다. 예를 들어 형태소 분석 또는 폐기 구두점을 구현하기 위해 더 복잡한 처리가 필요한 경우, ICU 토큰 화기를 구현의 일부로 사용하는 토큰 화기 구현을 작성하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="translated">ICU 토크 나이저를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="translated">IN 및 NOT IN 연산자</target>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="translated">IN 및 NOT IN 연산자는 왼쪽에 표현식을, 오른쪽에 값 목록 또는 하위 쿼리를 가져옵니다. IN 또는 NOT IN 연산자의 오른쪽 피연산자가 서브 쿼리 인 경우 서브 쿼리는 왼쪽 피연산자 의 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 에있는 열과 동일한 수의 열을 가져야합니다 . 왼쪽 표현식이 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 표현식 이 아닌 경우 IN 또는 NOT IN 연산자의 오른쪽에있는 하위 쿼리는 스칼라 하위 쿼리 여야합니다 . IN 또는 NOT IN 연산자의 오른쪽 피연산자가 값 목록 인 경우 해당 값은 각각 스칼라 여야하고 왼쪽 표현식도 스칼라 여야합니다. IN 또는 NOT IN 연산자의 오른쪽은 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="translated">IN 연산자는 왼쪽이 인덱스의 가장 왼쪽 항이 아니더라도 이제 최적화 후보입니다. 동일한 IN 인덱스에 여러 IN 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="translated">IN-early-out 최적화 : 다중 열 인덱스에서 조회를 수행하고 맨 왼쪽 열 이외의 열에서 IN 연산자를 사용하는 경우 첫 번째 IN 값과 일치하는 행이 없으면 다음을 확인하십시오. 다음 IN 값을 계속하기 전에 열과 오른쪽에 일치하는 행이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c69ea675978574ca724f9055d892093e6e8c8e6f" translate="yes" xml:space="preserve">
          <source>The INDEXED BY Clause</source>
          <target state="translated">INDEXED BY 절</target>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="translated">INDEXED BY 및 NOT INDEXED 절은 트리거 내의 DELETE 문에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="translated">INDEXED BY 및 NOT INDEXED 절은 트리거 내의 UPDATE 문에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에는 INDEXED BY 및 NOT INDEXED 절이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="translated">INDEXED BY 절은 쿼리 성능 조정에 사용하기위한 것이 &lt;em&gt;아닙니다&lt;/em&gt; . INDEXED BY 절의 목적은 인덱스 삭제 또는 작성과 같은 스키마 변경으로 인해 시간에 민감한 쿼리에 대한 쿼리 계획이 변경되는 경우 런타임 오류를 발생시키는 것입니다. INDEXED BY 절은 회귀 테스트 중에 원하지 않는 쿼리 계획 변경을 감지하는 데 도움이되도록 설계되었습니다. 응용 프로그램 개발자는 응용 프로그램 디자인, 구현, 테스트 및 조정 중에 INDEXED BY를 모두 사용하지 않는 것이 좋습니다. INDEXED BY를 사용하려면 디자인을 &quot;잠글&quot;때 개발 프로세스의 맨 끝에 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="translated">INDEXED BY 구문은 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 가 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 특정 명명 된 인덱스를 사용하도록 합니다. INDEXED BY 구문은 SQLite 확장이며 다른 SQL 데이터베이스 엔진으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="translated">INSERT 변경은 ​​변경 그룹에 남아 있습니다. INSERT 변경의 값은 행이 기존 변경에 의해 삽입 된 것처럼 수정 된 다음 새 변경에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">위의 INSERT 문은 sqlite_master 테이블에 새 행을 추가합니다.이 테이블은 &quot;t1bc&quot;색인과 동일한 온 디스크 형식을 가지며 동일한 b- 트리를 가리키는 &quot;t2&quot;테이블을 정의합니다. 이 sqlite_master 테이블 항목을 추가 한 후 SQLite가 스키마를 다시 읽도록하려면 데이터베이스를 닫았다가 다시 열어야합니다. 그런 다음 &quot;t1bc&quot;인덱스의 내용을보기 위해 &quot;t2&quot;테이블을 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe3ae8d2c81f2e60d52f407b340e91b2e1ca71c" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_schema table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_schema table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">위의 INSERT 문은 인덱스 &quot;t1bc&quot;와 동일한 온 디스크 형식을 가지며 동일한 b- 트리를 가리키는 테이블 &quot;t2&quot;를 정의하는 sqlite_schema 테이블에 새 행을 추가합니다. 이 sqlite_schema 테이블 항목을 추가 한 후 SQLite가 스키마를 다시 읽도록하려면 데이터베이스를 닫았다가 다시 열어야합니다. 그런 다음 &quot;t2&quot;테이블을 쿼리하여 &quot;t1bc&quot;인덱스의 내용을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="translated">INSERT 문은 세 가지 기본 형식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="translated">복합 쿼리에 대한 INTERSECT 연산자는 각각 별도의 임시 파일에 두 개의 별도 임시 인덱스를 작성하여 구현됩니다. 왼쪽 및 오른쪽 하위 쿼리는 각각 별도의 임시 인덱스로 평가됩니다. 그런 다음 두 인덱스가 함께 걸러지고 두 인덱스에 나타나는 항목이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="translated">과일별로 순서대로 각 항목의 rowid를 찾기 위해 Idx1 인덱스가 위에서 아래로 (또는 &quot;ORDER BY fruit DESC&quot;를 사용하는 경우 아래에서 위로) 스캔됩니다. 그런 다음 각 rowid에 대해 이진 검색을 수행하여 해당 행을 조회하고 출력합니다. 이러한 방식으로 출력은 전체 출력을 수집하고 별도의 단계를 사용하여 정렬 할 필요없이 요청 된 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="translated">JSON1 확장</target>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">LIKE 연산자는 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma를&lt;/a&gt; 사용하여 대소 문자를 구분할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="translated">LIKE 연산자는 패턴 일치 비교를 수행합니다. LIKE 연산자의 오른쪽에있는 피연산자는 패턴을 포함하고 왼쪽 피연산자는 패턴과 일치하는 문자열을 포함합니다. LIKE 패턴의 퍼센트 기호 ( &quot;%&quot;)는 문자열에서 0 개 이상의 문자 시퀀스와 일치합니다. LIKE 패턴의 밑줄 ( &quot;_&quot;)은 문자열의 단일 문자와 일치합니다. 다른 모든 문자는 자체 또는 대소 문자가 일치합니다 (예 : 대소 문자를 구분하지 않음). &lt;u&gt;중요 사항 :&lt;/u&gt; SQLite는 기본적으로 ASCII 문자의 대 / 소문자 만 이해합니다. LIKE 연산자는 기본적으로 ASCII 범위를 벗어난 유니 코드 문자에 대해 대소 문자를 구분합니다. 예를 들어 &lt;b&gt;'a'LIKE 'A'&lt;/b&gt; 표현식 은 TRUE이지만 &lt;b&gt;'&amp;aelig;'LIKE '&amp;AElig; '&lt;/b&gt;거짓입니다. SQLite의 ICU 확장에는 모든 유니 코드 문자를 접는 경우를 포함하는 향상된 버전의 LIKE 연산자가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="translated">LIKE 연산자에는 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt; 로 설정할 수있는 두 가지 모드가 있습니다 . 기본 모드는 LIKE 비교가 latin1 문자의 대소 문자 차이에 영향을받지 않는 것입니다. 따라서 기본적으로 다음 표현식은 true입니다.</target>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="translated">LIKE 연산자는 SQL 표준에서 요구하는 것이므로 기본적으로 대소 문자를 구분하지 않습니다. 컴파일러에 &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; 명령 행 옵션을 사용하여 컴파일시 기본 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="translated">내장 된 BINARY 조합 순서를 사용하여 연산자 왼쪽에 명명 된 열이 색인화되고 case_sensitive_like가 설정된 경우 LIKE 최적화가 발생할 수 있습니다. 또는 내장 NOCASE 조합 순서를 사용하여 열이 색인화되고 case_sensitive_like 모드가 해제 된 경우 최적화가 발생할 수 있습니다. LIKE 연산자가 최적화되는 유일한 두 가지 조합입니다.</target>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="translated">LIKE 최적화는 잘못된 바이트 코드를 생성하여 왼쪽 피연산자가 숫자 선호도를 갖고 오른쪽 패턴이 '/ %'이거나 패턴이 ESCAPE 문자로 시작하는 경우 잘못된 응답을 얻습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b에&lt;/a&gt; 대한 수정</target>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">GLOB 또는 LIKE 연산자의 우측 어느 문자 또는 문자열 인 경우 등에 최적화 만 시도 될 것이다 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개&lt;/a&gt; 된 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;결합 된&lt;/a&gt; 캐릭터 문자로이. 문자열 리터럴은 와일드 카드로 시작해서는 안됩니다. 오른쪽이 와일드 카드 문자로 시작하면이 최적화가 시도됩니다. 오른쪽 이 문자열에 바인딩 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수 인&lt;/a&gt; 경우이 최적화는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문이있는&lt;/a&gt; 경우에만 시도됩니다 , 표현식을 포함하는 이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 로 컴파일 된 . 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문을 사용하여 명령문을 준비한 경우 LIKE 최적화가 시도되지 않습니다.&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75a37b85ec9af203958779031808e1e864da0987" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is not attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">GLOB 또는 LIKE 연산자의 우측 어느 문자 또는 문자열 인 경우 등에 최적화 만 시도 될 것이다 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개&lt;/a&gt; 된 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;결합 된&lt;/a&gt; 캐릭터 문자로이. 문자열 리터럴은 와일드 카드로 시작하면 안됩니다. 오른쪽이 와일드 카드 문자로 시작하면이 최적화가 시도되지 않습니다. 오른쪽 이 문자열에 바인딩 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수 인&lt;/a&gt; 경우 표현식이 포함 된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 로 컴파일 된 경우에만이 최적화가 시도됩니다 . 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문이 다음을 사용하여 준비된 경우 LIKE 최적화가 시도되지 않습니다.&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="translated">LIKE, GLOB, REGEXP 및 MATCH 연산자</target>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="translated">LIMIT 및 ORDER BY 절 (아래 설명 참조)은 트리거 내의 DELETE 문에 대해 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="translated">UPDATE에 대한 LIMIT 및 ORDER BY 절은 SQLite를 빌드하는 데 사용 된 컴파일 옵션에 관계없이 트리거 내에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="translated">LIMIT 절</target>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="translated">LIMIT 절은 전체 SELECT 문이 리턴 한 행 수에 상한을 두는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="translated">LIMIT 절은 이제 부속 선택에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="translated">LIMIT 절이 있으면 2b 단계에서 재귀 테이블에 추가 될 최대 행 수를 결정합니다. 한도에 도달하면 재귀가 중지됩니다. 제한이 0이면 재귀 테이블에 행이 추가되지 않고 음수 제한이 있으면 무한 반복 행이 재귀 테이블에 추가 될 수 있다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="translated">LOCKING_STYLE 확장은 이제 Mac OS X에서 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="translated">레몬 LALR (1) 파서 생성기</target>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="translated">레몬 소스 코드는 원래 별도의 소스 파일로 작성되었으며 나중에 단일 &quot;lemon.c&quot;소스 파일로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="217ce06ccfd8bf843619afe9ea4c73c55d14a961" translate="yes" xml:space="preserve">
          <source>The M value is the &quot;mantissa&quot; and E is the &quot;exponent&quot;. Both M and E are integers.</source>
          <target state="translated">M 값은 &quot;가수&quot;이고 E는 &quot;지수&quot;입니다. M과 E는 모두 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="translated">MATCH 연산자는 match () 응용 프로그램 정의 함수의 특수 구문입니다. 기본 match () 함수 구현은 예외를 발생시키고 실제로는 유용하지 않습니다. 그러나 확장은 더 유용한 논리로 match () 함수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="translated">사용자 정의 R * Tree 조회 함수의 MATCH 연산자는 WHERE 절의 최상위 AND 연결 용어 여야합니다. 그렇지 않으면 R * Tree 조회 최적화 프로그램에서 사용할 수 없으며 조회를 실행할 수 없습니다. 예를 들어, MATCH 연산자가 OR 연산자를 통해 WHERE 절의 다른 용어에 연결되면 쿼리는 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="translated">MEMORY 저널링 모드는 롤백 저널을 휘발성 RAM에 저장합니다. 이는 디스크 I / O를 절약하지만 데이터베이스 안전 및 무결성을 희생합니다. MEMORY 저널링 모드가 설정되어있을 때 트랜잭션 도중 SQLite를 사용하는 응용 프로그램이 충돌하면 데이터베이스 파일이 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;손상&lt;/a&gt; 될 가능성이 큽니다 .</target>
        </trans-unit>
        <trans-unit id="f83732bb3e32c92cf54961a7828a9a9bf48899eb" translate="yes" xml:space="preserve">
          <source>The MySQL UPDATE statement does not have just one target table like other systems. Any of the tables that participate in the join can be modified in the SET clause. The MySQL UPDATE syntax allows you to update multiple tables at once!</source>
          <target state="translated">MySQL UPDATE 문에는 다른 시스템과 같이 대상 테이블이 하나만있는 것은 아닙니다. 조인에 참여하는 테이블은 SET 절에서 수정할 수 있습니다. MySQL UPDATE 구문을 사용하면 한 번에 여러 테이블을 업데이트 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="translated">신화적인 남자-월</target>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="translated">NGQP는 데이터베이스에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 가 실행 되지 않는 한이 쿼리에서 TAGXREF_I1이 거의 쓸모가 없음을 알 수있는 방법이 없습니다 . 는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 다양한 인덱스와 상점에서 그 통계의 품질에 명령 집결 통계를 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; 테이블. 이 통계 정보에 액세스하면 NGQP는 알고리즘 1을 가장 좋은 알고리즘으로 쉽게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="translated">NGQP는 레거시 쿼리 플래너보다 거의 항상 좋습니다. 그러나 레거시 쿼리 플래너에서 정의되지 않은 및 / 또는 차선의 동작에 무의식적으로 의존하는 레거시 응용 프로그램이있을 수 있으며 이러한 레거시 응용 프로그램에서 NGQP로 업그레이드하면 성능이 저하 될 수 있습니다. 이 위험을 고려하고 위험을 줄이고 발생하는 문제를 해결하기위한 점검 목록이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="translated">NGQP는 &quot;N Nearest Neighbors&quot;(이하 &quot;N3&quot;) 그래프를 통해 최상의 경로를 찾는 데 새로운 휴리스틱을 사용합니다. N3을 사용하면 각 단계마다 가장 가까운 이웃을 하나만 선택하는 대신 알고리즘은 일부 작은 정수 N에 대해 각 단계에서 N 개의 최고의 경로를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="translated">NGQP는 스키마가 인덱스의 맨 왼쪽 열에 동일한 값을 가진 약 10 또는 20 개가 넘는 행을 갖는 인덱스를 포함하지 않는 한 항상 좋은 쿼리 계획을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="translated">정확한가에 NGQP는 항상 액세스 할 수있는만큼, 이전의 쿼리 계획에 비해 동일하거나 더 나은 쿼리 계획을 찾을 수 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 의 데이터를 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1의&lt;/a&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="translated">NOCASE 데이터 정렬은 비교를 실행하기 전에 대문자 ASCII 문자 ( 'A'- 'Z')가 소문자로 접힌다는 점을 제외하고는 BINARY와 같습니다. ASCII 문자 만 대소 문자를 사용합니다. NOCASE는 범용 유니 코드 대소 문자를 비교하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="translated">NOT 연산자 (또는 표준 구문을 사용하는 경우 단항 &quot;-&quot;연산자)를 사용하면 다른 문서와 관련하여 한 문서 세트의 &lt;b&gt;상대적인 보완&lt;/b&gt; 을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="translated">NOT 연산자는 지원되지 않습니다. NOT 연산자 대신 표준 쿼리 구문은 기본 용어 및 용어 접두사 쿼리 (구문 또는 NEAR 쿼리에는 적용되지 않음)에 적용될 수있는 단항 &quot;-&quot;연산자를 지원합니다. 단항 &quot;-&quot;연산자가 첨부 된 용어 또는 접두어는 OR 연산자에 피연산자로 표시되지 않을 수 있습니다. FTS 쿼리는 단항 &quot;-&quot;연산자가 첨부 된 용어 또는 접두사 쿼리로 완전히 구성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f10f8b9e2a034cee1135ad17b2a216a2126edd" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hence NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLS FIRST 및 NULLS LAST 술어는 인덱스에 대해 지원되지 않습니다. 대한 &lt;a href=&quot;datatype3#sortorder&quot;&gt;목적을 정렬&lt;/a&gt; , SQLite는 다른 모든 값보다 작게 NULL 값을 고려합니다. 따라서 NULL 값은 항상 ASC 색인의 시작과 DESC 색인의 끝에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">NULLS FIRST 및 NULLS LAST 술어는 인덱스에 지원되지 않습니다. 대한 &lt;a href=&quot;datatype3#sortorder&quot;&gt;분류 목적&lt;/a&gt; , SQLite는 다른 모든 값보다 작게 NULL 값을 고려합니다. 따라서 NULL 값은 항상 ASC 색인의 시작과 DESC 색인의 끝에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="translated">Next 명령어는 커서 P0이 가리키는 테이블의 다음 요소를 가리 키도록 커서를 증가시키고, 성공한 경우 P2 (6, 루프 본문의 시작)로 분기됩니다. 닫기 명령은 커서 P1을 닫습니다. 커서 P1과 연관되지 않으므로 임시 스토리지 목록에 영향을 미치지 않습니다. 대신 전역 작업 목록입니다 (ListPush로 저장할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="translated">차세대 쿼리 플래너</target>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="translated">ODP ZIP 아카이브에는 content.xml, styles.xml, meta.xml 및 settings.xml의 네 가지 XML 파일이 있습니다. 이 4 개의 파일은 슬라이드 레이아웃, 텍스트 내용 및 스타일을 정의합니다. 이 특정 프레젠테이션에는 전체 화면 사진에서 작은 아이콘에 이르는 62 개의 이미지가 포함되어 있으며 각각은 그림 폴더에 별도의 파일로 저장됩니다. &quot;mimetype&quot;파일에는 다음과 같은 한 줄의 텍스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="translated">OFF 저널링 모드는 롤백 저널을 완전히 비활성화합니다. 롤백 저널이 작성되지 않으므로 삭제할 롤백 저널이 없습니다. OFF 저널링 모드는 SQLite의 자동 커밋 및 롤백 기능을 비활성화합니다. &lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 명령이 더 이상 작동하지 않습니다; 정의되지 않은 방식으로 동작합니다. 저널 모드가 OFF 인 경우 응용 프로그램은 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령을 사용하지 않아야합니다 . OFF 저널링 모드가 설정 될 때 트랜잭션 중간에 응용 프로그램이 충돌하면 데이터베이스 파일이 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;손상&lt;/a&gt; 될 가능성이 큽니다 . 저널이 없으면 제한 조건 오류 후에 명령문이 부분적으로 완료된 조작을 해제 할 수있는 방법이 없습니다. 또한 데이터베이스가 손상된 상태로 남아있을 수 있습니다. 예를 들어, 중복 된 항목으로 인해&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; 문이 중간에 실패하면 부분적으로 생성 된 인덱스가 남게됩니다. OFF 저널링 모드에서는 일반 SQL을 사용하여 데이터베이스 파일을 손상시킬 수 있으므로 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 가 활성화 되면 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="translated">OFFSET 절이 존재하고 양수 값 N을 갖는 경우, 첫 번째 N 개의 행이 재귀 테이블에 추가되지 않도록합니다. 첫 번째 N 행은 여전히 ​​재귀 선택에 의해 처리되며 재귀 테이블에는 추가되지 않습니다. 모든 OFFSET 행을 건너 뛸 때까지 행은 LIMIT를 이행하는 것으로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b277e3e2e965c40320745de00278d14c1b4c238" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT Clause</source>
          <target state="translated">ON CONFLICT 조항</target>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="translated">ON CONFLICT 절은 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; , &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 적용됩니다. ON CONFLICT 알고리즘은 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY 제약 조건&lt;/a&gt; 에는 적용되지 않습니다 . ROLLBACK, ABORT, FAIL, IGNORE 및 REPLACE의 5 가지 충돌 해결 알고리즘 중에서 선택할 수 있습니다. 기본 충돌 해결 알고리즘은 ABORT입니다. 이것이 의미하는 바입니다.</target>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="translated">여기에 설명 된 ON CONFLICT 절은 버전 3.0.0 (2004-06-18) 이전부터 SQLite의 일부입니다. &quot;ON CONFLICT&quot;라는 문구는 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT의&lt;/a&gt; 일부이며 버전 3.24.0 (2018-06-04)에 추가 된 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 의 확장 입니다. &quot;ON CONFLICT&quot;문구의이 두 가지 용도를 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="translated">ON CONFLICT 절은 다른 많은 SQL 명령에 나타날 수있는 SQLite에 특정한 비표준 확장입니다. 이 문서는 표준 SQL의 일부가 아니므로 친숙하지 않기 때문에이 문서에서 자체 섹션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="translated">SQLite 데이터베이스의 각 외래 키와 관련된 ON DELETE 및 ON UPDATE 작업은 &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot;또는 &quot;CASCADE&quot;중 하나입니다. 조치가 명시 적으로 지정되지 않은 경우 기본값은 &quot;NO ACTION&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">내부 조인의 ON 및 USING 절은 위에서 단락 1.0에서 설명한 WHERE 절 분석 전에 WHERE 절의 추가 조건으로 변환됩니다. 따라서 SQLite의 경우 이전 SQL89 쉼표 결합 구문보다 새로운 SQL92 결합 구문을 사용하면 계산상의 이점이 없습니다. 둘 다 내부 조인에서 정확히 같은 것을 달성합니다.</target>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">OR 연산자 는 두 문서 세트의 &lt;b&gt;합집합&lt;/b&gt; 을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="translated">ORDER BY LIMIT 최적화는 가장 안쪽 IN 연산자 루프가 실제로 쿼리 계획에 의해 사용되지 않는 한 유효하지 않습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="translated">ORDER BY LIMIT 최적화는 쿼리 최적화 프로그램의 사소한 결함의 합류로 인해 매우 모호한 상황에서 준비된 명령문의 바이트 코드에서 무한 루프를 발생시킬 수 있습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt; 수정</target>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에 대한 ORDER BY 및 LIMIT 절 은 지원되지 않습니다. ORDER BY 및 LIMIT는 일반적으로 모든 컨텍스트에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 에 대해 지원되지 않지만 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 타임 옵션을 사용하여 최상위 레벨 명령문에 사용할 수 있습니다 . 그러나 컴파일 시간 옵션 은 트리거 내의 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문이 아닌 최상위 레벨 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">DELETE 문의 ORDER BY 절은 LIMIT 내에 속하는 행을 판별하는 데만 사용됩니다. 행이 삭제되는 순서는 임의적이며 ORDER BY 절의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">UPDATE 문의 ORDER BY 절은 LIMIT에 속하는 행을 판별하는 데만 사용됩니다. 행이 수정되는 순서는 임의적이며 ORDER BY 절의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="translated">&quot;VFS&quot;라고도하는 OS 인터페이스는 운영 체제에서 SQLite를 이식 가능하게 만드는 것입니다. SQLite의 다른 모듈이 운영 체제와 통신해야 할 때마다 VFS에서 메소드를 호출합니다. 그런 다음 VFS는 요청을 충족시키는 데 필요한 운영 관련 코드를 호출합니다. 따라서 SQLite를 새로운 운영 체제로 포팅하는 것은 단순히 새로운 OS 인터페이스 계층 또는 &quot;VFS&quot;를 작성하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="translated">OS 인터페이스 계층이 완전히 재 작업되었습니다.</target>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="translated">OVER 절은 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능에&lt;/a&gt; 필요하며 그렇지 않으면 금지됩니다. DISTINCT 키워드는 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; 에서만 사용할 수 있습니다 . FILTER 절은 &lt;a href=&quot;lang_corefunc&quot;&gt;간단한 함수&lt;/a&gt; 에 나타나지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">OpenDocument 파일 형식은 워드 프로세서, 스프레드 시트 및 프리젠 테이션과 같은 사무용 응용 프로그램에 사용됩니다. 원래 OpenOffice 제품 군용으로 설계되었지만 이후 다른 데스크톱 응용 프로그램 제품군에 통합되었습니다. OpenOffice 응용 프로그램이 몇 번 분기되어 이름이 변경되었습니다. OpenDocument에 대한이 저자의 주요 용도는 &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice (&lt;/a&gt; Mac) 또는 &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice (&lt;/a&gt; Linux 및 Windows)를 사용하여 슬라이드 프레젠테이션을 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a12f97809890d0843d3b379960cdb5a48586d66d" translate="yes" xml:space="preserve">
          <source>The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array of 2*N pointers to strings. Each pair of pointers in this array corresponds to a key and value for a query parameter. The P parameter may be a NULL pointer if N is zero. None of the 2*N pointers in the P array may be NULL pointers and key pointers should not be empty strings. None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may be NULL pointers, though they can be empty strings.</source>
          <target state="translated">sqlite3_create_filename (D, J, W, N, P)의 P 매개 변수는 문자열에 대한 2 * N 포인터의 배열이어야합니다. 이 배열의 각 포인터 쌍은 쿼리 매개 변수의 키와 값에 해당합니다. N이 0이면 P 매개 변수는 NULL 포인터가 될 수 있습니다. P 배열의 2 * N 포인터는 NULL 포인터가 될 수 없으며 키 포인터는 빈 문자열이 아니어야합니다. sqlite3_create_filename (D, J, W, N, P)에 대한 D, J 또는 W 매개 변수는 비어있는 문자열 일 수 있지만 NULL 포인터가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="translated">P1 커서는 의사 테이블이 아니라 실제 테이블 용이어야합니다. P1이 열려 있지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="translated">P1 커서는 의사 테이블이 아닌 실제 테이블 용이어야합니다. 이 opcode 이전에 P1이 열려 있어야합니다. 그렇지 않으면 프로그램이 segfault입니다.</target>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="translated">P1 매개 변수는이 opcode에서 실제로 사용되지 않습니다. 그러나이 &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; 는 루프의 맨 아래이며 P2에서 현재 행까지의 행은 EXPLAIN 출력을 위해 들여 쓰기되어야한다는 명령 행 쉘에 대한 힌트로 때때로 0 대신 1로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="translated">명령 11의 P3 주장은 특히 중요하다. 정렬 키는 P3에서 각 문자열 앞에 한 문자를 추가하고 모든 문자열을 연결하여 구성됩니다. 정렬 비교 기능은이 문자를보고 정렬 순서가 오름차순인지 내림차순인지, 문자열 또는 숫자로 정렬 할지를 결정합니다. 이 예에서 첫 번째 열은 내림차순으로 문자열로 정렬되어야하며 접두사가 &quot;D&quot;이고 두 번째 열은 숫자가 오름차순으로 정렬되어 접두사가 &quot;+&quot;입니다. 오름차순 문자열 정렬은 &quot;A&quot;를 사용하고 내림차순 숫자 정렬은 &quot;-&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="translated">P3 값은 btree 구현에 대한 힌트입니다. P3 == 1이면 P1이 SQL 인덱스이고 해당 인덱스가 고유 한 경우이 명령어를 생략했을 수 있습니다. P3은 일반적으로 0입니다. P3은 항상 0 또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="translated">P3으로 시작하는 P4 레지스터 값은 PRIMARY KEY 또는 ROWID를 생략하는 압축 해제 된 인덱스 키를 형성합니다. P1 인덱스의 PRIMARY KEY 또는 ROWID를 무시하고 P1이 현재 가리키는 인덱스와이 키 값을 &lt;a href=&quot;opcode#Compare&quot;&gt;비교하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="translated">P3으로 시작하는 P4 레지스터 값은 PRIMARY KEY를 생략하는 압축 해제 된 인덱스 키를 형성합니다. 마지막에 PRIMARY KEY 또는 ROWID 필드를 무시하고 P1이 현재 가리키는 인덱스와이 키 값을 &lt;a href=&quot;opcode#Compare&quot;&gt;비교하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="translated">P4 값은 정수 (P4_INT32) 또는 KeyInfo 구조에 대한 포인터 (P4_KEYINFO) 일 수 있습니다. KeyInfo 오브젝트에 대한 포인터 인 경우, 열려있는 테이블은 &lt;a href=&quot;fileformat2#btypes&quot;&gt;인덱스 b- 트리&lt;/a&gt; 여야하며 KeyInfo 오브젝트는 해당 인덱스 b- 트리의 컨텐츠 및 조합 순서를 정의합니다. 그렇지 않으면 P4가 정수 값인 경우 열려는 &lt;a href=&quot;fileformat2#btypes&quot;&gt;테이블&lt;/a&gt; 은 P4 값 이상의 열 이있는 테이블 b- 트리 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="translated">P5 인수는 레지스터 P2와 그 후속 장치에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="translated">P5 매개 변수는 btree.h에 정의 된 BTREE_ * 플래그의 마스크 일 수 있습니다. 이 플래그는 btree 작업의 측면을 제어합니다. BTREE_OMIT_JOURNAL 및 BTREE_SINGLE 플래그가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">PERSIST 저널링 모드는 각 트랜잭션이 끝날 때 롤백 저널이 삭제되는 것을 방지합니다. 대신 저널의 머리글을 0으로 덮어 씁니다. 이렇게하면 다른 데이터베이스 연결이 저널을 롤백하지 못하게됩니다. PERSIST 저널링 모드는 파일을 삭제하거나 자르는 것이 파일의 첫 번째 블록을 0으로 덮어 쓰는 것보다 훨씬 비싼 플랫폼에서 최적화하는 데 유용합니다. &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; 및 &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="translated">PLINK 테이블은 체크인 간의 상위-하위 관계를 보유합니다. TAGXREF 테이블은 태그를 체크인에 매핑합니다. 참고로이 두 테이블에 대한 스키마의 관련 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="translated">PRAGMA 문은 SQLite에 고유 한 SQL 확장이며 SQLite 라이브러리의 조작을 수정하거나 내부 (테이블이 아닌) 데이터에 대한 SQLite 라이브러리를 조회하는 데 사용됩니다. PRAGMA 문은 다른 SQLite 명령 (예 : &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ) 과 동일한 인터페이스를 사용하여 발행 되지만 다음과 같은 중요한 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="translated">PRAGMA synchronous = off 문은 이제 일반 롤백 저널 외에 마스터 저널 파일의 동기화를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="translated">rowid 테이블에 대한 PRIMARY KEY 제약 조건 (실제 기본 키 또는 INTEGER PRIMARY KEY가 아닌 한)은 실제로 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건&lt;/a&gt; 과 동일 합니다 . 실제 기본 키가 아니기 때문에 PRIMARY KEY의 열은 모든 SQL 표준을 위반하여 NULL이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="translated">수정 된 행을 식별하는 PRIMARY KEY 값</target>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="translated">페이지 캐시</target>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="translated">사용 된 PostgreSQL 및 MySQL 서버는 기본적으로 RedHat 7.2에서 제공되었습니다. (PostgreSQL 버전 7.1.3 및 MySQL 버전 3.23.41) 이러한 엔진을 조정하려는 노력은 없었습니다. 특히 RedHat 7.2의 기본 MySQL 구성은 트랜잭션을 지원하지 않습니다. 트랜잭션을 지원하지 않아도 MySQL은 큰 속도 이점을 제공하지만 SQLite는 여전히 대부분의 테스트에서 자체적으로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="translated">PutIntKey 명령 (INSERT에 대한 설명 중에도 설명 됨)은 데이터가 스택의 최상위이고 키가 스택의 다음 키인 데이터베이스 파일에 항목을 쓴 다음 스택을 두 번 팝합니다. PutIntKey 명령어는 기존 레코드의 데이터를 동일한 키로 덮어 씁니다. INSERT를 사용하면 이전에 사용되지 않은 키를 제공하도록 보장 된 NewRecno 명령에 의해 키가 생성 되었기 때문에 INSERT에서는 덮어 쓰기가 문제가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="translated">QPSG는 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일시 또는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; , 1,0) 를 호출하여 런타임에 사용 가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="translated">QPSG는 테스트 중에 모든 쿼리가 효율적으로 실행되고 응용 프로그램이 스키마를 변경하지 않으면 SQLite가 다른 쿼리 계획을 사용하여 갑자기 시작하지 않기 때문에 응용 프로그램이 릴리스 된 후에 성능 문제가 발생할 수 있음을 의미합니다. 사용자. 응용 프로그램이 랩에서 작동하는 경우 배포 후에도 같은 방식으로 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="translated">R-Tree 개념은 &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt; 에서 시작되었습니다 . &lt;em&gt;R-Trees : 공간 검색을위한 동적 인덱스 구조&lt;/em&gt; , Proc. 1984 ACM SIGMOD 국제 데이터 관리 회의, pp. 47-57. SQLite에서 구현 된 구현은 Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger : &lt;em&gt;R *&lt;/em&gt; -Tree &lt;em&gt;: 효율적이고 강력한 액세스에&lt;/em&gt; 의해 설명 된 Guttman의 원래 아이디어를 일반적으로 &quot;R * Trees&quot;로 개선 한 것입니다. &lt;em&gt;점과 사각형의 방법. &lt;/em&gt;SIGMOD Conference 1990 : 322-331.</target>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="translated">RAISE () 함수</target>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="translated">RBU 확장</target>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="translated">RBU 데이터베이스 테이블에는 업데이트에 의해 삽입, 업데이트 또는 삭제 된 각 대상 데이터베이스 행에 대한 단일 행이 포함됩니다. RBU 데이터베이스 테이블 채우기는 &lt;a href=&quot;rbu#database_contents&quot;&gt;다음 섹션&lt;/a&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="translated">RBU 확장 인터페이스를 통해 응용 프로그램은 RBU 데이터베이스에 저장된 RBU 업데이트를 기존 대상 데이터베이스에 적용 할 수 있습니다. 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="translated">RBU 확장은 네트워크 에지의 저전력 장치에서 대용량 SQLite 데이터베이스 파일과 함께 사용하도록 설계된 SQLite 용 애드온입니다. RBU는 두 가지 별도의 작업에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="translated">RBU 확장은 기본적으로 활성화되어 있지 않습니다. 이를 가능하게하려면 &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; 컴파일 시간 옵션을 사용하여 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 을 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="translated">RBU 업데이트는 외래 키 또는 CHECK 제약 조건 위반을 감지하거나 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="translated">RBU 업데이트는 트리거를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6564cc776de2c808e8f2b66fc117a6728b91dc4" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP 연산자는 regexp () 사용자 함수에 대한 특수 구문입니다. 기본적으로 regexp () 사용자 함수가 정의되어 있지 않으므로 REGEXP 연산자를 사용하면 일반적으로 오류 메시지가 표시됩니다. 경우 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; &quot;정규 표현식&quot;라는 이름은 실행시, 다음을 &quot;추가</target>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">REGEXP 연산자는 regexp () 사용자 함수의 특수 구문입니다. regexp () 사용자 함수는 기본적으로 정의되어 있지 않으므로 REGEXP 연산자를 사용하면 일반적으로 오류 메시지가 나타납니다. 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; &quot;정규 표현식&quot;라는 이름은 실행시, 다음을 &quot;추가</target>
        </trans-unit>
        <trans-unit id="f6504d5094ffa58be5ab1ac79df65f0b1aba5e47" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed, or when there are &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; involving a function whose definition has changed.</source>
          <target state="translated">REINDEX 명령은 인덱스를 처음부터 삭제하고 다시 만드는 데 사용됩니다. 이는 데이터 정렬 시퀀스의 정의가 변경되었거나 정의가 변경된 함수를 포함하는 &lt;a href=&quot;expridx&quot;&gt;표현식에 인덱스&lt;/a&gt; 가있을 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="translated">REINDEX 명령은 인덱스를 처음부터 삭제하고 다시 작성하는 데 사용됩니다. 데이터 정렬 순서의 정의가 변경된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="translated">REINDEX 명령이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">RELEASE 명령은 SAVEPOINT에 대한 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 와 같습니다 . RELEASE 명령은 이름이 일치하는 가장 최근의 저장 점을 포함하여 모든 저장 점이 트랜잭션 스택에서 제거되도록합니다. 내부 트랜잭션의 릴리스는 데이터베이스 파일에 변경 사항을 기록하지 않습니다. 더 이상 해당 저장 점으로 롤백 할 수 없도록 트랜잭션 스택에서 저장 점을 제거합니다. RELEASE 명령이 가장 바깥 쪽 저장 점을 해제하여 트랜잭션 스택이 비게되면 RELEASE는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 와 같습니다 . &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 명령은 모든 세이브 포인트를 해제하고 트랜잭션이 원래 대신이의 SAVEPOINT 명령에 의해 시작된 경우에도 트랜잭션을 커밋하기 위해 사용될 수있다 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="translated">RELEASE 명령은 트랜잭션 스택에 가장 최근에 추가 된 것으로 시작하여 저장 점 이름이 일치하는 저장 점을 해제 할 때까지 저장 점을 뒤로 되돌립니다. 이전 세이브 포인트, 심지어 세이브 포인트 이름이 일치하는 세이브 포인트도 변경되지 않습니다. RELEASE 명령으로 인해 트랜잭션 스택이 비게되면 (RELEASE 명령이 스택에서 가장 바깥 쪽 트랜잭션을 해제하면) 트랜잭션이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="translated">RENAME COLUMN TO 구문은 table-name 테이블의 column-name을 new-column-name으로 변경합니다. 열 이름은 테이블 정의 자체와 열을 참조하는 모든 인덱스, 트리거 및보기 내에서 변경됩니다. 컬럼 이름 변경으로 인해 트리거 또는보기에서 의미 상 모호성이 발생하는 경우 RENAME COLUMN이 오류와 함께 실패하고 변경 사항이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="translated">RENAME TO 구문은 table-name의 이름을 new-table-name으로 변경합니다. 이 명령은 연결된 데이터베이스간에 테이블을 이동하는 데 사용할 수 없으며 동일한 데이터베이스 내에서 테이블 이름을 바꾸는 데만 사용됩니다. 이름을 바꾼 테이블에 트리거 또는 인덱스가있는 경우 이름을 바꾼 후에도 테이블에 연결된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="translated">REPLACE 명령은 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 명령 의 &quot; &lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt; &quot;변형에 대한 별명입니다 . 이 별명은 다른 SQL 데이터베이스 엔진과의 호환성을 위해 제공됩니다. 추가 정보 는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 명령 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="translated">ROLLBACK TO 명령은 데이터베이스 상태를 해당 SAVEPOINT 바로 다음 상태로 되돌립니다. TO 키워드없이 일반 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 명령 과 달리 ROLLBACK TO 명령은 트랜잭션을 취소하지 않습니다. 트랜잭션을 취소하는 대신 ROLLBACK TO 명령은 처음에 트랜잭션을 다시 시작합니다. 그러나 모든 개입 SAVEPOINT는 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="translated">TO 절이있는 ROLLBACK 명령은 시간이 지난 트랜잭션을 일치하는 이름을 가진 가장 최근의 SAVEPOINT로 롤백합니다. 이름이 일치하는 SAVEPOINT는 트랜잭션 스택에 유지되지만 해당 SAVEPOINT가 작성된 후 발생한 모든 데이터베이스 변경 사항은 롤백됩니다. ROLLBACK TO 명령의 저장 점 이름이 스택의 SAVEPOINT와 일치하지 않으면 ROLLBACK 명령이 오류와 함께 실패하고 데이터베이스 상태는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="translated">ROWS 및 GROUPS 프레임 유형은 현재 행을 기준으로 계산하여 프레임 범위를 결정한다는 점에서 비슷합니다. 차이점은 ROWS는 개별 행을 계산하고 GROUPS는 피어 그룹을 계산한다는 것입니다. RANGE 프레임 유형이 다릅니다. RANGE 프레임 유형은 현재 행을 기준으로 일부 값 범위 내에있는 표현식 값을 찾아 프레임의 범위를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="translated">Robson 증명은 SQLite에서 사용하는 각 메모리 할당 자에 별도로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="translated">RowSet 객체는 정수 세트가 별개의 단계로 삽입되는 경우에 최적화되며, 각 세트에는 중복이 없습니다. 각 세트는 고유 한 P4 값으로 식별됩니다. 첫 번째 세트는 P4 == 0이어야하고 마지막 세트는 P4 ==-1이어야하고 다른 모든 세트의 경우 P4&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="translated">SAVEPOINT 명령은 이름으로 새 트랜잭션을 시작합니다. 트랜잭션 이름은 고유하지 않아도됩니다. SAVEPOINT는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 내부 또는 외부에서 시작할 수 있습니다 . SAVEPOINT가 가장 바깥쪽에있는 저장 점이고 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 이 아닌 경우 ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 동작은 BEGIN DEFERRED TRANSACTION과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 ZIPVFS 백엔드를 조사하는 경우를 제외하고 SCHEMA 컬럼은 NULL 입니다. memstat.c 모듈이 -DSQLITE_ENABLE_ZIPVFS로 컴파일 될 때와&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt; ZIPVFS&lt;/a&gt; 가 사용중인 에만 SCHEMA가 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="translated">SELECT는 친숙한 방식으로 시작됩니다. 먼저 열 이름이 초기화되고 쿼리중인 테이블이 열립니다. 색인 파일도 열리는 지침 5 및 6부터 상황이 달라집니다. 명령어 7과 8은 값이 50 인 키를 만듭니다. 9 의 &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; 명령어는 인덱스 키를 VDBE 메모리 위치 0에 저장합니다. VDBE 메모리는 스택의 깊은 곳에서 값을 가져올 필요가 없도록하기 위해 사용됩니다. 프로그램을 생성하기 어렵게 만듭니다. 주소 10의 &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; 명령 은 스택에서 키를 팝하고 인덱스 키를 해당 키가있는 인덱스의 첫 번째 행으로 이동합니다. 이것은 다음 루프에서 사용하기 위해 커서를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="360db9d4f11a05425a6e0a615ab3f9ee4fa2dd3b" translate="yes" xml:space="preserve">
          <source>The SELECT statement above shows output of:</source>
          <target state="translated">위의 SELECT 문은 다음과 같은 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="translated">SELECT 문은 SQL 언어에서 가장 복잡한 명령입니다. 설명을보다 쉽게 ​​수행 할 수 있도록 아래 문장 중 일부는 SELECT 문에서 반환 한 데이터가 일련의 단계로 결정되는 방식을 설명합니다. 이것은 단지 설명을위한 것이라는 점을 명심해야합니다. 실제로 SQLite 나 다른 SQL 엔진이이 프로세스 나 다른 특정 프로세스를 따를 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="translated">SELECT 문은 데이터베이스를 쿼리하는 데 사용됩니다. SELECT의 결과는 각 행에 고정 된 수의 열이있는 0 개 이상의 데이터 행입니다. SELECT 문은 데이터베이스를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="translated">왼쪽의 SELECT 문은 '0'과 '0.0'이 숫자로 취급되므로 구별되지 않기 때문에 단일 행을 반환합니다. 그러나 0과 0.0은 다른 문자열로 취급되므로 오른쪽의 SELECT 문은 두 개의 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="translated">SQL 명령 &quot;BEGIN TRANSACTION&quot;(TRANSACTION 키워드는 선택 사항)은 SQLite를 자동 커미트 모드에서 해제하는 데 사용됩니다. BEGIN 명령은 데이터베이스에 대한 잠금을 획득하지 않습니다. BEGIN 명령 후 첫 번째 SELECT 문이 실행될 때 SHARED 잠금이 획득됩니다. 첫 번째 INSERT, UPDATE 또는 DELETE 문이 실행될 때 RESERVED 잠금이 획득됩니다. 메모리 캐시가 가득 차서 디스크에 쏟아 지거나 트랜잭션이 커밋 될 때까지 독점 잠금은 확보되지 않습니다. 이런 방식으로 시스템은 파일 파일에 대한 읽기 액세스 차단을 마지막 순간까지 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="translated">SQL 명령 &quot;COMMIT&quot;은 실제로 변경 사항을 디스크에 커밋하지 않습니다. 자동 커밋이 다시 켜집니다. 그런 다음 명령이 완료되면 일반 자동 커밋 논리가 인계하여 실제 디스크 커밋이 발생합니다. SQL 명령 &quot;ROLLBACK&quot;도 자동 커밋을 다시 설정하여 작동하지만 자동 커밋 논리에 커밋이 아니라 롤백하도록 지시하는 플래그도 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1cddc0d667491d9249e7b156b49c099f6b89cdde" translate="yes" xml:space="preserve">
          <source>The SQL function creation interfaces may be called multiple times with the same function name. If two calls have the same function number but a different number of arguments, for example, then two variants of the SQL function will be registered, each taking a different number of arguments.</source>
          <target state="translated">SQL 함수 생성 인터페이스는 동일한 함수 이름으로 여러 번 호출 될 수 있습니다. 예를 들어 두 호출에 동일한 함수 번호가 있지만 인수 수가 다른 경우 SQL 함수의 두 변형이 등록되고 각각 다른 수의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="translated">SQL 퍼지 생성기 테스트는 TCL 테스트 스위트의 일부입니다. 전체 테스트 실행 중에 약 111.3 천 개의 퍼즈 SQL 문이 생성 및 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="translated">SQL 언어에는 표현식이 평가되고 결과가 부울 (true 또는 false) 값으로 변환되는 여러 컨텍스트가 있습니다. 이러한 맥락은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="translated">SQL 언어는 &quot;표준&quot;입니다. 그럼에도 불구하고 두 개의 SQL 데이터베이스 엔진이 정확히 동일하게 작동하지는 않습니다. 모든 SQL 구현에는 고유 한 특성과 이상한 점이 있으며 SQLite도이 규칙에서 예외가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="translated">SQL 언어는 키워드가 풍부합니다. 대부분의 SQL 구현에서는 키워드를 큰 따옴표로 묶지 않으면 키워드를 식별자 (테이블 또는 열 이름)로 사용할 수 없습니다. 그러나 SQLite는 더 유연합니다. 많은 키워드는 식별자가 될 의도가있는 상황에서 사용되는 한 따옴표없이 식별자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="translated">SQL 언어는 매우 강력하므로 악의적 인 SQL 입력 (또는 응용 프로그램 버그로 인한 잘못된 SQL 입력)이 매우 오랫동안 실행되는 SQL을 제출할 수 있습니다. 이것이 서비스 거부 공격이되지 않도록하려면 &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; 인터페이스를 사용하여 각 SQL 문이 실행될 때 주기적으로 콜백을 호출하고 명령문이 너무 오래 실행되면 명령문이 중단되도록 콜백이 0이 아닌 값을 리턴하도록 고려하십시오. . 또는 별도의 스레드에서 타이머를 설정 하고 타이머가 꺼질 때 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()를&lt;/a&gt; 호출 하여 SQL 문이 영원히 실행되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="translated">SQLite 용 SQL 언어 파서는 &quot;Lemon&quot;이라는 코드 생성기 프로그램을 사용하여 생성됩니다. 레몬 프로그램은 입력 언어의 문법을 읽고 해당 언어에 대한 파서를 구현하기 위해 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 에서 생성 된 SQL 출력 이 이제 &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; 값을 포함하도록 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="translated">위 예제의 SQL 쿼리는이 섹션의 첫 번째 예제보다 적은 CPU를 사용하지만 여전히 명백한 성능 문제가 있습니다. SQLite는 결과를 정렬하고 제한하기 전에 사용자 쿼리와 일치하는 모든 행에 대해 FTS 모듈에서 &quot;title&quot;열 및 matchinfo 데이터의 값을 검색하여이 쿼리를 충족시킵니다. SQLite의 가상 테이블 인터페이스가 작동하는 방식으로 인해 &quot;title&quot;열의 값을 검색하려면 디스크에서 전체 행을로드해야합니다 ( &quot;content&quot;필드 포함). 즉, 사용자 쿼리가 수천 개의 문서와 일치하는 경우 어떤 목적으로도 사용되지 않더라도 디스크에서 메모리로 메가 바이트의 &quot;제목&quot;및 &quot;콘텐츠&quot;데이터를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="translated">다음 예제 블록의 SQL 쿼리는이 문제에 대한 한 가지 해결책입니다. SQLite &lt;a href=&quot;optoverview#flattening&quot;&gt;에서 조인에 사용 된 하위 쿼리에 LIMIT 절이 포함되어 있으면&lt;/a&gt; 기본 쿼리가 실행되기 전에 하위 쿼리의 결과가 임시 테이블에 계산되어 저장됩니다. 즉, SQLite는 사용자 쿼리와 일치하는 각 행의 docid 및 matchinfo 데이터 만 메모리에로드하고 가장 관련성이 높은 10 개의 문서에 해당하는 docid 값을 결정한 다음 해당 10 개의 문서에 대한 제목 및 내용 정보 만로드합니다. matchinfo 및 docid 값이 전체 텍스트 인덱스에서 완전히 수집되므로 데이터베이스에서 메모리로로드되는 데이터가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="translated">SQL 표준에는 식별자 주위에 큰 따옴표가 필요하고 문자열 리터럴에는 작은 따옴표가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="translated">SQL 표준에서는 제약 조건의 하나 이상의 열이 NULL 인 경우에도 UNIQUE 제약 조건을 적용해야하지만 SQLite는이를 수행하지 않습니다. 그게 버그 아니야?</target>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="translated">SQL 표준은 테이블, 인덱스, 열, 데이터베이스, 사용자 정의 함수, 데이터 정렬, 가상 테이블 모듈 또는 기타 이름 지정된 오브젝트의 이름으로 사용되지 않을 수있는 많은 키워드를 지정합니다. 키워드 목록이 너무 길어서 모든 사람을 기억할 수있는 사람은 거의 없습니다. 대부분의 SQL 코드에서 가장 안전한 방법은 영어 단어를 사용자 정의 개체의 이름으로 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="translated">SQL 표준은 두 개의 작은 따옴표를 한 줄에 넣어 문자열의 작은 따옴표를 이스케이프하도록 지정합니다. SQL은 이와 관련하여 Pascal 프로그래밍 언어와 같이 작동합니다. 예:</target>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="translated">SQL 문은 sqlite3_prepare ()에 대한 UTF-8 문자열입니다. sqlite3_prepare16 ()은 UTF-16 문자열을 SQL 입력으로 예상한다는 점을 제외하고는 동일한 방식으로 작동합니다. 입력 문자열의 첫 번째 SQL 문만 컴파일됩니다. 다섯 번째 매개 변수는 입력 문자열에서 다음 (컴파일되지 않은) SQLite 문에 대한 포인터로 채워집니다 (있는 경우). sqlite3_finalize () 루틴은 준비된 SQL 문을 할당 해제합니다. 데이터베이스를 닫기 전에 준비된 모든 명령문을 완료해야합니다. sqlite3_reset () 루틴은 준비된 SQL 문을 재설정하여 다시 실행할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="translated">SQL 문은 &quot;?&quot;형식의 토큰을 포함 할 수 있습니다. 또는 &quot;? nnn&quot;또는 &quot;: aaa&quot;. 여기서 &quot;nnn&quot;은 정수이고 &quot;aaa&quot;는 식별자입니다. 이러한 토큰은 나중에 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; 인터페이스 로 채워질 지정되지 않은 리터럴 값 (또는 &quot;와일드 카드&quot;)을 나타냅니다 . 각 와일드 카드에는 &quot;? nnn&quot;형식의 경우 문 또는 &quot;nnn&quot;의 순서와 관련된 번호가 있습니다. 동일한 SQL 문에서 동일한 와일드 카드가 두 번 이상 발생할 수 있으며,이 경우 해당 와일드 카드의 모든 인스턴스가 동일한 값으로 채워집니다. 언 바운드 와일드 카드의 값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="translated">CREATE VIRTUAL TABLE 문에 인수로 제공된 SQL 문은 테이블이 작성 될 때 실행됩니다. 4 개 또는 5 개의 열을 반환해야합니다. 리턴 된 각 행은 구성 요소 테이블 중 하나를 설명합니다. 처음 네 개의 열은 처음부터 끝까지 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="translated">SQLite Archive 작업을 구현하는 데 사용되는 SQL 문은 다양한 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장을&lt;/a&gt; 사용 합니다 . 이 확장은 모두 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc / 하위 폴더&lt;/a&gt; 의 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite 소스 트리&lt;/a&gt; 에서 사용할 수 있습니다 . 완전한 SQLite Archive 지원에 필요한 확장 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="translated">사용자 정의 조회에 대한 SQL 구문은 SQL 함수를 등록하는 데 사용되는 sqlite3_rtree_geometry_callback () 또는 sqlite3_rtree_query_callback () 인터페이스에 관계없이 동일합니다. 그러나 새로운 쿼리 스타일 콜백을 사용하면 응용 프로그램에서 쿼리 진행 방식을보다 효과적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="translated">SQL : 1999 스펙에서는 RECURSIVE 키워드가 재귀 공통 테이블 표현식을 포함하는 WITH 절에서 WITH 뒤에 와야합니다. 그러나 SqlServer 및 Oracle과의 호환성을 위해 SQLite는이 규칙을 시행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="translated">SQLITE_ABORT 결과 코드는 작업이 완료되기 전에 중단되었으며 대개 응용 프로그램 요청임을 나타냅니다. &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="translated">SQLITE_ABORT_ROLLBACK 오류 코드는 SQLITE_ABORT에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 로 , SQL 문을 처음 시작할 때 활성화 된 트랜잭션이 롤백 &lt;a href=&quot;rescode#abort&quot;&gt;되었으므로&lt;/a&gt; SQL 문이 중단되었음을 나타냅니다. 롤백이 발생하면 보류중인 쓰기 작업이 항상이 오류와 함께 실패합니다. &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK은&lt;/a&gt; 스키마가 트랜잭션이 롤백 내에서 변경된 경우 보류중인 읽기 작업은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="translated">P5의 SQLITE_AFF_MASK 부분은 선호도 문자 (SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER 등) 여야합니다. 비교하기 전에이 선호도에 따라 두 입력을 강제하려고 시도합니다. SQLITE_AFF_MASK가 0x00이면 숫자 선호도가 사용됩니다. 선호도 변환은 입력 레지스터 P1 및 P3에 다시 저장됩니다. 따라서이 opcode는 레지스터 P1 및 P3을 지속적으로 변경시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자 콜백&lt;/a&gt; 이 준비중인 SQL 문에 권한이 없음을 표시 하면 SQLITE_AUTH 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="translated">에서 SQLITE_BUSY 결과 코드 다릅니다 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 그 SQLITE_BUSY에서 별도의와의 충돌이 발생 함을 의미&lt;a href=&quot;c3ref/sqlite3&quot;&gt; 데이터베이스 연결을&lt;/a&gt; 하는 반면, 아마도 별도의 프로세스에서, &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED이&lt;/a&gt; 같은 내 충돌을 나타냅니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (때로는 나와 데이터베이스 연결 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="translated">SQLITE_BUSY 결과 코드는 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (일반적으로 별도 프로세스의 데이터베이스 연결)에 의한 동시 활동으로 인해 데이터베이스 파일을 쓸 수 없거나 일부 경우 읽을 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="translated">SQLITE_BUSY_RECOVERY 오류 코드는 다음에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다.&lt;a href=&quot;rescode#busy&quot;&gt;&lt;/a&gt; 충돌 후 다른 프로세스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 파일을 복구 중이므로 조작을 계속할 수 없음을 나타내는 SQLITE_BUSY . SQLITE_BUSY_RECOVERY 오류 코드는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="translated">SQLITE_BUSY_SNAPSHOT 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 데이터베이스 연결이 읽기 트랜잭션을 쓰기 트랜잭션으로 승격하려고 시도하지만 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 이미 데이터베이스에 기록되어 이전 읽기를 무효화 할 때 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서 발생하는 .</target>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CANTOPEN 결과 코드는 SQLite가 파일을 열 수 없음을 나타냅니다. 문제의 파일은 기본 데이터베이스 파일이거나 여러 &lt;a href=&quot;tempfiles&quot;&gt;임시 디스크 파일&lt;/a&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="translated">SQLITE_CANTOPEN_CONVPATH 오류 코드는 Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서만 사용되는 &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다. 파일을 열려는 동안 cygwin_conv_path () 시스템 호출이 실패했음을 나타냅니다. 참조 : &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="translated">현재 SQLITE_CANTOPEN_DIRTYWAL 결과 코드는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="translated">SQLITE_CANTOPEN_FULLPATH 오류 코드는 다음에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다.&lt;a href=&quot;rescode#cantopen&quot;&gt;&lt;/a&gt; 운영 체제에서 파일 이름을 전체 경로 이름으로 변환 할 수 없어 파일 열기 작업이 실패했음을 나타내는 SQLITE_CANTOPEN에 .</target>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="translated">SQLITE_CANTOPEN_ISDIR 오류 코드는 SQLITE_CANTOPEN에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 &lt;a href=&quot;rescode#cantopen&quot;&gt;.&lt;/a&gt; 파일이 실제로 디렉토리이므로 파일 열기 조작이 실패했음을 나타내는 .</target>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="translated">SQLITE_CANTOPEN_NOTEMPDIR 오류 코드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="translated">SQLITE_CHECKPOINT_FULL, RESTART 및 TRUNCATE 모드는 데이터베이스 파일에 대한 독점적 인 &quot;기록기&quot;잠금도 얻습니다. 작성기 잠금을 즉시 확보 할 수없고 사용 중 핸들러를 구성한 경우, 호출자가 처리되고 사용 중 처리기가 0을 리턴하거나 잠금이 성공적으로 확보 될 때까지 작성기 잠금을 재 시도합니다. 사용중인 핸들러는 또한 위에서 설명한대로 데이터베이스 리더를 기다리는 동안 호출됩니다. 작성기 잠금을 확보하기 전에 또는 데이터베이스 리더를 기다리는 동안 사용 중 핸들러가 0을 리턴하면, 검사 점 조작은 SQLITE_CHECKPOINT_PASSIVE와 동일한 방식으로 해당 지점에서 진행됩니다. 이 경우 SQLITE_BUSY가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN 옵션은 단일 정수 인수를 사용하여 쿼리 최적화 프로그램에서 전체 테이블 스캔에 대한 커버링 인덱스 사용을 활성화 또는 비활성화하기 위해 부울로 해석됩니다. 기본 설정은 &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; 컴파일 시간 옵션에 의해 결정 되거나 컴파일 시간 옵션이 생략되면 &quot;on&quot;입니다. 전체 테이블 스캔에 인덱스 적용을 사용하지 않는 기능은 최적화가 사용 가능한 경우 잘못 코딩 된 일부 레거시 애플리케이션이 오작동 할 수 있기 때문입니다. 최적화를 비활성화 할 수있는 기능을 제공하면 최신 버전의 SQLite에서도 오래된 버그가있는 응용 프로그램 코드를 변경하지 않고도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">SQLITE_CONFIG_COVERING_INDEX_SCAN 옵션은 단일 정수 인수를 사용하여 쿼리 최적화 프로그램에서 전체 테이블 스캔에 대한 커버링 인덱스 사용을 활성화 또는 비활성화하기 위해 부울로 해석됩니다. 기본 설정은 &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; 컴파일 시간 옵션에 의해 결정 되거나 컴파일 시간 옵션이 생략되면 &quot;on&quot;입니다. 전체 테이블 스캔에 인덱스 적용을 사용하지 않는 기능은 최적화가 사용 가능한 경우 잘못 코딩 된 일부 레거시 애플리케이션이 오작동 할 수 있기 때문입니다. 최적화를 비활성화 할 수있는 기능을 제공하면 최신 버전의 SQLite에서도 오래된 버그가있는 응용 프로그램 코드를 변경하지 않고도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC 옵션은 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조는 현재 정의 된 메모리 할당 루틴들로 채워진다. 이 옵션을 사용하면 메모리 할당 실패를 시뮬레이션하거나 메모리 사용을 추적하는 래퍼로 기본 메모리 할당 루틴을 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">SQLITE_CONFIG_GETMALLOC 옵션은 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods의&lt;/a&gt; 구조는 현재 정의 된 메모리 할당 루틴들로 채워진다. 이 옵션을 사용하면 메모리 할당 실패를 시뮬레이션하거나 메모리 사용을 추적하는 래퍼로 기본 메모리 할당 루틴을 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX 옵션은 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods의&lt;/a&gt; 구조는 현재 정의 된 뮤텍스 루틴 채워진다. 이 옵션은 예를 들어 성능 프로파일 링 또는 테스트를 위해 뮤텍스 사용을 추적하는 데 사용되는 래퍼로 기본 뮤텍스 할당 루틴을 오버로드하는 데 사용할 수 있습니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_GETMUTEX 구성 옵션을 사용하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_GETMUTEX 옵션은 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods의&lt;/a&gt; 구조는 현재 정의 된 뮤텍스 루틴 채워진다. 이 옵션은 예를 들어 성능 프로파일 링 또는 테스트를 위해 뮤텍스 사용을 추적하는 데 사용되는 래퍼로 기본 뮤텍스 할당 루틴을 오버로드하는 데 사용할 수 있습니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_GETMUTEX 구성 옵션을 사용하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;../rescode#error&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2 옵션은 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 현재 페이지 캐시 구현의 SQLite 사본을 해당 오브젝트에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">SQLITE_CONFIG_GETPCACHE2 옵션은 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 현재 페이지 캐시 구현의 SQLite 사본을 해당 오브젝트에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP 옵션은 SQLite가 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에서&lt;/a&gt; 제공 한 것보다 모든 동적 메모리 할당 요구에 사용할 정적 메모리 버퍼를 지정합니다 . SQLite는이 중 하나를 컴파일하면 SQLITE_CONFIG_HEAP 옵션에만 사용할 수 있습니다 &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 그렇지 않으면 호출합니다. SQLITE_CONFIG_HEAP에 대한 세 가지 인수가 있습니다. 메모리에 대한 8 바이트 정렬 포인터, 메모리 버퍼의 바이트 수 및 최소 할당 크기. 첫 번째 포인터 (메모리 포인터)가 NULL이면 SQLite는 기본 메모리 할당 자 (시스템 malloc () 구현)를 사용하여 이전 호출을 취소합니다.&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt; SQLITE_CONFIG_MALLOC의&lt;/a&gt;. 메모리 포인터가 NULL이 아닌 경우 대체 메모리 할당자는 모든 SQLites 메모리 할당 요구를 처리하기 위해 사용됩니다. 첫 번째 포인터 (메모리 포인터)는 8 바이트 경계에 맞춰야합니다. 그렇지 않으면 후속 SQLite 동작이 정의되지 않습니다. 최소 할당 크기는 2 ** 12로 제한됩니다. 최소 할당 크기의 합리적인 값은 2 ** 5에서 2 ** 8입니다.</target>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">SQLITE_CONFIG_HEAP 옵션은 SQLite가 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에서&lt;/a&gt; 제공 한 것보다 모든 동적 메모리 할당 요구에 사용할 정적 메모리 버퍼를 지정합니다 . SQLite는이 중 하나를 컴파일하면 SQLITE_CONFIG_HEAP 옵션에만 사용할 수 있습니다 &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; 또는 &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; 반환 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 그렇지 않으면 호출합니다. SQLITE_CONFIG_HEAP에 대한 세 가지 인수가 있습니다. 메모리에 대한 8 바이트 정렬 포인터, 메모리 버퍼의 바이트 수 및 최소 할당 크기. 첫 번째 포인터 (메모리 포인터)가 NULL이면 SQLite는 기본 메모리 할당 자 (시스템 malloc () 구현)를 사용하여&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt; SQLITE_CONFIG_MALLOC의&lt;/a&gt; 이전 호출을 실행 취소합니다.. 메모리 포인터가 NULL이 아닌 경우 대체 메모리 할당자는 모든 SQLites 메모리 할당 요구를 처리하기 위해 사용됩니다. 첫 번째 포인터 (메모리 포인터)는 8 바이트 경계에 맞춰야합니다. 그렇지 않으면 후속 SQLite 동작이 정의되지 않습니다. 최소 할당 크기는 2 ** 12로 제한됩니다. 최소 할당 크기의 합리적인 값은 2 ** 5에서 2 ** 8입니다.</target>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG 옵션은 SQLite 전역 &lt;a href=&quot;../errlog&quot;&gt;오류 로그&lt;/a&gt; 를 구성하는 데 사용됩니다 . (SQLITE_CONFIG_LOG 옵션은 두 개의 인수, void (*) (void *, int, const char *)의 호출 서명이있는 함수에 대한 포인터와 void에 대한 포인터를 사용합니다. 함수 포인터가 NULL이 아닌 경우 호출됩니다. 각 로깅 이벤트를 처리하기 위해 &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 에 의해 함수 포인터가 NULL 인 경우, &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스는 no-op가되고 SQLITE_CONFIG_LOG에 대한 두 번째 인수 인 void 포인터는 애플리케이션 정의에 대한 첫 번째 매개 변수로 전달됩니다. 로거 함수에 대한 두 번째 매개 변수는 해당 &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; 호출 . 에 대한 첫 번째 매개 변수의 사본 &lt;a href=&quot;../rescode&quot;&gt;결과 코드 &lt;/a&gt;이거나&lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; . 로거에 전달 된 세 번째 매개 변수는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통한 형식화 후 로그 메시지 입니다. SQLite 로깅 인터페이스는 재진입되지 않습니다. 응용 프로그램이 제공 한 로거 기능은 SQLite 인터페이스를 호출하지 않아야합니다. 다중 스레드 응용 프로그램에서 응용 프로그램 정의 로거 기능은 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">SQLITE_CONFIG_LOG 옵션은 SQLite 전역 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 를 구성하는 데 사용됩니다 . (SQLITE_CONFIG_LOG 옵션은 두 개의 인수, void (*) (void *, int, const char *)의 호출 서명이있는 함수에 대한 포인터와 void에 대한 포인터를 사용합니다. 함수 포인터가 NULL이 아닌 경우 호출됩니다. 각 로깅 이벤트를 처리하기 위해 &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 에 의해 함수 포인터가 NULL 인 경우, &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스는 no-op가되고 SQLITE_CONFIG_LOG에 대한 두 번째 인수 인 void 포인터는 애플리케이션 정의에 대한 첫 번째 매개 변수로 전달됩니다. 로거 함수에 대한 두 번째 매개 변수는 해당 &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; 호출 . 에 대한 첫 번째 매개 변수의 사본 &lt;a href=&quot;rescode&quot;&gt;결과 코드 &lt;/a&gt;이거나&lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; . 로거에 전달 된 세 번째 매개 변수는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통한 형식화 후 로그 메시지 입니다. SQLite 로깅 인터페이스는 재진입되지 않습니다. 응용 프로그램이 제공 한 로거 기능은 SQLite 인터페이스를 호출하지 않아야합니다. 다중 스레드 응용 프로그램에서 응용 프로그램 정의 로거 기능은 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE 옵션은 각 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 lookaside 메모리의 기본 크기를 결정하는 두 개의 인수를 사용합니다 . 첫 번째 인수는 각 lookaside 버퍼 슬롯의 크기이고 두 번째 인수는 각 데이터베이스 연결에 할당 된 슬롯 수입니다. SQLITE_CONFIG_LOOKASIDE는</target>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">SQLITE_CONFIG_LOOKASIDE 옵션은 각 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 lookaside 메모리의 기본 크기를 결정하는 두 개의 인수를 사용합니다 . 첫 번째 인수는 각 lookaside 버퍼 슬롯의 크기이고 두 번째 인수는 각 데이터베이스 연결에 할당 된 슬롯 수입니다. SQLITE_CONFIG_LOOKASIDE는</target>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC 옵션은 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 메모리 할당 루틴 대신 사용할 대체 저수준 메모리 할당 루틴을 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 리턴 되기 전에 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 컨텐츠의 자체 개인 사본을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLITE_CONFIG_MALLOC 옵션은 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 메모리 할당 루틴 대신 사용할 대체 저수준 메모리 할당 루틴을 지정합니다. SQLite는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 리턴 되기 전에 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 구조 컨텐츠의 자체 개인 사본을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE 옵션은 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스의 기본 최대 크기 인 단일 매개 변수 &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; 매개 변수를 승인합니다 . 이 기본 최대 크기는 &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 위 또는 아래로 조정할 수 있습니다 . 이 구성 설정을 사용하지 않으면 기본 최대 값은 &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 . 해당 컴파일 시간 옵션이 설정되지 않은 경우 기본 최대 값은 1073741824입니다.</target>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">SQLITE_CONFIG_MEMDB_MAXSIZE 옵션은 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스의 기본 최대 크기 인 단일 매개 변수 &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; 매개 변수를 승인합니다 . 이 기본 최대 크기는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 위 또는 아래로 조정할 수 있습니다 . 이 구성 설정을 사용하지 않으면 기본 최대 값은 &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 . 해당 컴파일 시간 옵션이 설정되지 않은 경우 기본 최대 값은 1073741824입니다.</target>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="translated">SQLITE_CONFIG_MEMSTATUS 옵션은 int 유형의 단일 인수를 부울로 해석하여 메모리 할당 통계 콜렉션을 사용하거나 사용하지 않도록 설정합니다. 메모리 할당 통계가 사용 불가능하면 다음 SQLite 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX 옵션은 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 뮤텍스 루틴 대신 사용할 대체 저수준 뮤텍스 루틴을 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 되기 전에 &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 내용을 복사 합니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_MUTEX 구성 옵션을 사용하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONFIG_MUTEX 옵션은 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 인스턴스에 대한 포인터 인 단일 인수를 사용 합니다. 이 인수는 SQLite에 내장 된 뮤텍스 루틴 대신 사용할 대체 저수준 뮤텍스 루틴을 지정합니다. SQLite는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 되기 전에 &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 구조 의 내용을 복사 합니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 전체 mutexing 서브 시스템이 빌드에서 생략되므로 SQLITE_CONFIG_MUTEX 구성 옵션을 사용하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 호출 하면 SQLITE_ERROR가 리턴 &lt;a href=&quot;../rescode#error&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여 애플리케이션 정의 페이지 캐시 구현을로드하는 경우이 구성 옵션은 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에 대한 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인 (sz)의 크기 및 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512와 65536 사이의 2의 거듭 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 판별 할 수 있습니다.. 낭비되는 메모리를 제외하고 sz 매개 변수가 필요한 것보다 큰 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우, SQLite는 페이지 캐시 요구를 충족시키기 위해 제공된 메모리를 사용하기 위해 노력하며 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 모두 소모되면 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()로&lt;/a&gt; 되돌아갑니다 . pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트에 충분합니다. 초기 할당에서 제공하는 것 이상의 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 개별적 으로 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여 애플리케이션 정의 페이지 캐시 구현을로드하는 경우이 구성 옵션은 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에 대한 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인 (sz)의 크기 및 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512와 65536 사이의 2의 거듭 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 다음을 사용하여 확인할 수 있습니다.&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt;. 낭비되는 메모리를 제외하고 sz 매개 변수가 필요한 것보다 큰 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우, SQLite는 페이지 캐시 요구를 충족시키기 위해 제공된 메모리를 사용하기 위해 노력하며 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 모두 소모되면 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()로&lt;/a&gt; 되돌아갑니다 . pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트에 충분합니다. 초기 할당에서 제공하는 것 이상의 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 개별적 으로 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="373c6de3bbf7db29ed258a5d09d9109fe9568cc5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. 이 구성 옵션은 애플리케이션 정의 페이지 캐시 구현이 &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여로드되는 경우 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에는 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인의 크기 (sz), 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512에서 65536 사이의 2 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 확인할 수 있습니다.. 낭비되는 메모리를 제외하고는 sz 매개 변수가 필요 이상으로 커지는 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우 SQLite는 페이지 캐시 요구 사항을 충족하기 위해 제공된 메모리를 사용하려고 노력하고 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 소진되면 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 폴백합니다. pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트입니다. 초기 할당에서 제공하는 것보다 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 별도로 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="fe2e2404fd6d076f4a9442bd42821a9709933fc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">SQLITE_CONFIG_PAGECACHE 옵션은 SQLite가 기본 페이지 캐시 구현으로 데이터베이스 페이지 캐시에 사용할 수있는 메모리 풀을 지정합니다. 이 구성 옵션은 애플리케이션 정의 페이지 캐시 구현이 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2를&lt;/a&gt; 사용하여로드되는 경우 작동하지 않습니다 . SQLITE_CONFIG_PAGECACHE에는 세 가지 인수가 있습니다. 8 바이트 정렬 메모리 (pMem)에 대한 포인터, 각 페이지 캐시 라인의 크기 (sz), 캐시 라인 수 (N). sz 인수는 가장 큰 데이터베이스 페이지의 크기 (512에서 65536 사이의 2 제곱)와 각 페이지 헤더에 대한 추가 바이트 여야합니다. 페이지 헤더에 필요한 추가 바이트 수는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ를&lt;/a&gt; 사용하여 확인할 수 있습니다.. 낭비되는 메모리를 제외하고는 sz 매개 변수가 필요 이상으로 커지는 것은 무해합니다. pMem 인수는 NULL 포인터이거나 최소 sz * N 바이트의 8 바이트 정렬 메모리 블록에 대한 포인터 여야합니다. 그렇지 않으면 후속 동작이 정의되지 않습니다. pMem이 NULL이 아닌 경우 SQLite는 페이지 캐시 요구 사항을 충족하기 위해 제공된 메모리를 사용하려고 노력하고 , 페이지 캐시 라인이 sz 바이트보다 크거나 모든 pMem 버퍼가 소진되면 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 폴백합니다. pMem이 NULL이고 N이 0이 아닌 경우 각 데이터베이스 연결은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리에 대한 초기 대량 할당을 수행합니다.N이 양수이면 N 캐시 라인에 충분하고 N이 음수이면 -1024 * N 바이트입니다. 초기 할당에서 제공하는 것보다 추가 페이지 캐시 메모리가 필요한 경우 SQLite는 각 추가 캐시 라인에 대해 별도로 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2 옵션은 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 이 객체는 사용자 정의 페이지 캐시 구현에 대한 인터페이스를 지정합니다. SQLite는 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 객체 의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE2 옵션은 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 오브젝트에 대한 포인터 인 단일 인수를 사용 합니다. 이 객체는 사용자 정의 페이지 캐시 구현에 대한 인터페이스를 지정합니다. SQLite는 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 객체 의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ 옵션은 정수에 대한 포인터 인 단일 매개 변수를 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;취하여 SQLITE_CONFIG_PAGECACHE의&lt;/a&gt; 각 페이지에 필요한 페이지 당 추가 바이트 수를 해당 정수에 기록합니다 . 필요한 추가 공간은 컴파일러, 대상 플랫폼 및 SQLite 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">SQLITE_CONFIG_PCACHE_HDRSZ 옵션은 정수에 대한 포인터 인 단일 매개 변수를 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;취하여 SQLITE_CONFIG_PAGECACHE의&lt;/a&gt; 각 페이지에 필요한 페이지 당 추가 바이트 수를 해당 정수에 기록합니다 . 필요한 추가 공간은 컴파일러, 대상 플랫폼 및 SQLite 버전에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ 옵션은 부호없는 정수인 단일 매개 변수를 사용하여 멀티 스레드 정렬 기의 &quot;최소 PMA 크기&quot;를 해당 정수로 설정합니다. 기본 최소 PMA 크기는 &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일 타임 옵션으로 설정됩니다 . &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; 명령을 사용하여 다중 스레드 정렬을 사용하고 정렬 할 컨텐츠의 양이 페이지 크기에서 최소 &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 설정 및이 값을 초과하면 정렬 작업에 도움이되는 새 스레드가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">SQLITE_CONFIG_PMASZ 옵션은 부호없는 정수인 단일 매개 변수를 사용하여 멀티 스레드 정렬 기의 &quot;최소 PMA 크기&quot;를 해당 정수로 설정합니다. 기본 최소 PMA 크기는 &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일 타임 옵션으로 설정됩니다 . &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; 명령을 사용하여 다중 스레드 정렬을 사용하고 정렬 할 컨텐츠의 양이 페이지 크기에서 최소 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 설정 및이 값을 초과하면 정렬 작업에 도움이되는 새 스레드가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="translated">SQLITE_CONFIG_SCRATCH 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="translated">SQLITE_CONFIG_SMALL_MALLOC 옵션은 부울로 해석되는 int 유형의 단일 인수를 사용합니다. true 인 경우 가능한 경우 큰 메모리 할당을 피해야한다는 힌트를 SQLite에 제공합니다. 큰 메모리 할당을 자유롭게 할 수 있으면 SQLite가 더 빠르게 실행되지만 일부 응용 프로그램은 큰 할당을 피할 수있는 경우 메모리 조각화를 보장하기 위해 느리게 실행하는 것을 선호 할 수 있습니다. 이 힌트는 일반적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE 옵션은 분류기 참조 크기 임계 값의 새로운 값 (int) 유형의 단일 매개 변수를 허용합니다. 일반적으로 SQLite가 외부 정렬을 사용하여 ORDER BY 절에 따라 레코드를 정렬하면 호출자가 요구하는 모든 필드가 정렬 된 레코드에 있습니다. 그러나 SQLite가 선언 된 테이블 열 유형에 따라 값이 구성된 분류기 참조 크기 임계 값보다 클 가능성이 큰 것으로 판단되면 참조는 각 정렬 된 레코드에 저장되고 필요한 열 값은 다음에서로드됩니다. 레코드로서의 데이터베이스는 정렬 된 순서로 리턴됩니다. 이 옵션의 기본값은이 최적화를 사용하지 않는 것입니다. 이 옵션에 음수 값을 지정하면 기본 동작이 복원됩니다. 이 옵션은 SQLite가&lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; 컴파일 타임 옵션.</target>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_SORTERREF_SIZE 옵션은 분류기 참조 크기 임계 값의 새 값인 유형 (int)의 단일 매개 변수를 허용합니다. 일반적으로 SQLite가 외부 정렬을 사용하여 ORDER BY 절에 따라 레코드를 정렬하면 호출자가 요구하는 모든 필드가 정렬 된 레코드에 있습니다. 그러나 SQLite가 선언 된 테이블 열 유형에 따라 값이 구성된 정렬 기 참조 크기 임계 값보다 클 가능성이 큰 것으로 판단되면 참조는 각 정렬 된 레코드에 저장되고 필요한 열 값은 다음에서로드됩니다. 레코드로서의 데이터베이스는 정렬 된 순서로 리턴됩니다. 이 옵션의 기본값은이 최적화를 사용하지 않는 것입니다. 이 옵션에 음수 값을 지정하면 기본 동작이 복원됩니다. 이 옵션은 SQLite가&lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; 컴파일 타임 옵션.</target>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL 옵션은 단일 매개 변수를 사용하여 &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 디스크 유출 임계 값이됩니다. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 은 크기 (바이트)가이 임계 값을 초과하여 디스크에 기록 될 때까지 메모리에 보유됩니다. 또는 임계 값이 -1이면 명령문 저널은 항상 독점적으로 메모리에 보유됩니다. 많은 명세서 일지가 커지지 않기 때문에 유출 임계 값을 64KiB와 같은 값으로 설정하면 명세서 롤백을 지원하는 데 필요한 I / O 양이 크게 줄어들 수 있습니다. 이 설정의 기본값은 &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 컴파일 타임 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_CONFIG_STMTJRNL_SPILL 옵션은 단일 매개 변수를 사용하여 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 디스크 유출 임계 값이됩니다. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 은 크기 (바이트)가이 임계 값을 초과하여 디스크에 기록 될 때까지 메모리에 보유됩니다. 또는 임계 값이 -1이면 명령문 저널은 항상 독점적으로 메모리에 보유됩니다. 많은 명세서 일지가 커지지 않기 때문에 유출 임계 값을 64KiB와 같은 값으로 설정하면 명세서 롤백을 지원하는 데 필요한 I / O 양이 크게 줄어들 수 있습니다. 이 설정의 기본값은 &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 컴파일 타임 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI 옵션은 int 유형의 단일 인수를 사용합니다. 0이 아닌 경우 URI 처리가 전체적으로 사용 가능합니다. 매개 변수가 0이면 URI 처리가 전체적으로 사용 불가능합니다. URI 처리가 전체적으로 사용 가능한 경우, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()에 전달&lt;/a&gt; 되거나 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령의 일부로 지정된 모든 파일 이름 은 데이터베이스 연결이 열릴 때 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 설정 여부에 관계없이 URI로 해석됩니다 . 전역 적으로 사용 불가능한 경우, 파일 이름은 데이터베이스 연결이 열릴 때 SQLITE_OPEN_URI 플래그가 설정된 경우에만 URI로 해석됩니다. 기본적으로 URI 처리는 전체적으로 비활성화되어 있습니다. 다음과 같이 컴파일하여 기본값을 변경할 수 있습니다.&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 기호가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">SQLITE_CONFIG_URI 옵션은 int 유형의 단일 인수를 사용합니다. 0이 아닌 경우 URI 처리가 전체적으로 사용 가능합니다. 매개 변수가 0이면 URI 처리가 전체적으로 사용 불가능합니다. URI 처리가 전체적으로 사용 가능한 경우, &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()에 전달&lt;/a&gt; 되거나 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령의 일부로 지정된 모든 파일 이름 은 데이터베이스 연결이 열릴 때 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 설정 여부에 관계없이 URI로 해석됩니다 . 전역 적으로 사용 불가능한 경우, 파일 이름은 데이터베이스 연결이 열릴 때 SQLITE_OPEN_URI 플래그가 설정된 경우에만 URI로 해석됩니다. 기본적으로 URI 처리는 전체적으로 비활성화되어 있습니다. 다음과 같이 컴파일하여 기본값을 변경할 수 있습니다.&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 기호가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZE 옵션은 SQLITE가 &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; 전 처리기 매크로가 정의 된 상태로 Windows 용으로 컴파일 된 경우에만 사용할 수 있습니다 . SQLITE_CONFIG_WIN32_HEAPSIZE는 작성된 힙의 최대 크기를 지정하는 부호없는 32 비트 정수 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">SQLITE_CONFIG_WIN32_HEAPSIZE 옵션은 SQLITE가 &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; 전 처리기 매크로가 정의 된 상태로 Windows 용으로 컴파일 된 경우에만 사용할 수 있습니다 . SQLITE_CONFIG_WIN32_HEAPSIZE는 작성된 힙의 최대 크기를 지정하는 부호없는 32 비트 정수 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="translated">SQLITE_CONSTRAINT 코드는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt; 메소드의 리턴 값으로도 사용될 수 있습니다 . xBestIndex ()가 SQLITE_CONSTRAINT를 리턴하면 xBestIndex ()에 제출 된 특정 입력 조합이 사용 가능한 쿼리 계획을 생성 할 수 없으며 추가 고려 사항이 없어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT 오류 코드는 SQL 문을 처리하는 중 SQL 제한 조건 위반이 발생했음을 의미합니다. 실패한 제한 조건에 대한 추가 정보는 함께 제공되는 오류 메시지 ( &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; 를 통해 리턴 됨 )를 참조하거나 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드를&lt;/a&gt; 보면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_CHECK 오류 코드는 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="translated">SQLITE_CONSTRAINT_COMMITHOOK 오류 코드는 &lt;a href=&quot;c3ref/commit_hook&quot;&gt;커미트 후크 콜백&lt;/a&gt; 이 0이 아닌 값을 리턴하여 SQL 문이 롤백 되었음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_FOREIGNKEY 오류 코드는 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="translated">SQLITE_CONSTRAINT_FUNCTION 오류 코드는 현재 SQLite 코어에서 사용되지 않습니다. 그러나이 오류 코드는 확장 기능에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_NOTNULL 오류 코드는 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_PRIMARYKEY 오류 코드는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="translated">SQLITE_CONSTRAINT_ROWID 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT이&lt;/a&gt; 것을 나타내는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID가&lt;/a&gt; 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="translated">SQLITE_CONSTRAINT_TRIGGER 오류 코드는 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 내 &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE 함수&lt;/a&gt; 가 실행 되어 SQL 문이 중단 되었음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="translated">SQLITE_CONSTRAINT_UNIQUE 오류 코드는 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건이&lt;/a&gt; 실패했음을 나타내는 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">SQLITE_CONSTRAINT_VTAB 오류 코드는 현재 SQLite 코어에서 사용되지 않습니다. 그러나이 오류 코드는 응용 프로그램 정의 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="translated">SQLITE_CORRUPT 결과 코드는 데이터베이스 파일이 손상되었음을 나타냅니다. 손상이 발생할 수있는 방법에 대한 자세한 내용은 &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;데이터베이스 파일을 손상&lt;/a&gt; 시키는 방법을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="translated">SQLITE_CORRUPT_SEQUENCE 결과 코드는 sqlite_sequence 테이블의 스키마가 손상되었음을 의미합니다. sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 기능을 구현하는 데 도움이됩니다 . sqlite_sequence 테이블의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="translated">SQLITE_CORRUPT_VTAB 오류 코드는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에서&lt;/a&gt; 사용되는 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . &lt;a href=&quot;vtab&quot;&gt;가상 테이블은&lt;/a&gt; 가상 테이블의 콘텐츠가 손상 나타 내기 위해 SQLITE_CORRUPT_VTAB를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="translated">SQLITE_DBCONFIG_DEFENSIVE 옵션은 데이터베이스 연결에 대한 &quot;방어&quot;플래그를 활성화하거나 비활성화합니다. 방어 플래그가 활성화되면 일반 SQL에서 의도적으로 데이터베이스 파일을 손상시킬 수있는 언어 기능이 비활성화됩니다. 비활성화 된 기능에는 다음이 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS 옵션 은 CREATE TABLE 및 CREATE INDEX와 같은 DDL 문에 대한 기존의 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS 옵션 은 CREATE TABLE 및 CREATE INDEX와 같은 DDL 문에 대한 기존의 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문 (DELETE, INSERT, SELECT 및 UPDATE 문)에 대해서만 기존의 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ef07fd34a275a246ee518a98e66084fe0a55fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문, 즉 DELETE, INSERT, SELECT 및 UPDATE 문에 대해서만 레거시 &lt;a href=&quot;../quirks#dblquote&quot;&gt;큰 따옴표 문자열 리터럴&lt;/a&gt; 잘못된 기능을 활성화하거나 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문 (DELETE, INSERT, SELECT 및 UPDATE 문)에 대해서만 기존의 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 기능을&lt;/a&gt; 활성화 또는 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 타임 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8485338d9edebd1879a88fb2aa42a3b5aaf70e71" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DML 옵션 은 DML 문, 즉 DELETE, INSERT, SELECT 및 UPDATE 문에 대해서만 레거시 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표 문자열 리터럴&lt;/a&gt; 잘못된 기능을 활성화하거나 비활성화합니다 . 이 설정의 기본값은 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; 컴파일 시간 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="763206f446e43106378de90da986cb3503647378" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSG 옵션은 &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;쿼리 플래너 안정성 보증&lt;/a&gt; (QPSG)을 활성화 또는 비활성화합니다 . QPSG가 활성화되면 단일 SQL 쿼리 문은 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 값에 관계없이 항상 동일한 알고리즘을 사용합니다.. QPSG는 바인딩 된 매개 변수의 값을 확인하는 일부 쿼리 최적화를 비활성화하여 일부 쿼리를 느리게 할 수 있습니다. 그러나 QPSG는보다 예측 가능한 동작이라는 이점이 있습니다. QPSG가 활성화되면 SQLite는 항상 실험실에서 테스트하는 동안 사용 된 것과 동일한 쿼리 계획을 현장에서 사용합니다. 이 설정의 첫 번째 인수는 QPSG를 비활성화하려면 0이고, QPSG를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라 QPSG가 사용 가능 또는 사용 가능한지를 표시하기 위해 0 또는 1로 기록되는 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="e62faf35588a5d4eafe007180e96f2c0c110300b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSG 옵션은 &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;쿼리 플래너 안정성 보증&lt;/a&gt; (QPSG)을 활성화 또는 비활성화합니다 . QPSG가 활성화되면 단일 SQL 쿼리 문은 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 값에 관계없이 항상 동일한 알고리즘을 사용합니다.. QPSG는 바인딩 된 매개 변수의 값을 확인하는 일부 쿼리 최적화를 비활성화하여 일부 쿼리를 느리게 할 수 있습니다. 그러나 QPSG는보다 예측 가능한 동작이라는 이점이 있습니다. QPSG가 활성화되면 SQLite는 항상 실험실에서 테스트하는 동안 사용 된 것과 동일한 쿼리 계획을 현장에서 사용합니다. 이 설정의 첫 번째 인수는 QPSG를 비활성화하려면 0이고, QPSG를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라 QPSG가 사용 가능 또는 사용 가능한지를 표시하기 위해 0 또는 1로 기록되는 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="8bef3f5951097e41221958d251dd3bbb9ce96dee" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE 옵션은 &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; 명령 의 레거시 동작을 활성화 또는 비활성화하여 &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;버전 3.24.0&lt;/a&gt; (2018-06-04) 이전과 동일하게 작동합니다 . 자세한 내용은 &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME 설명서&lt;/a&gt; 의 &quot;호환성 고지 사항&quot;을 참조하십시오 . &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 문을 사용 하여이 기능을 켜거나 끌 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07c20d63d2e6b14f99d190fcacbd95a681ec8f6a" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE 옵션은 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; 명령 의 레거시 동작을 활성화 또는 비활성화하여 &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;버전 3.24.0&lt;/a&gt; (2018-06-04) 이전과 동일하게 작동합니다 . 자세한 내용은 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME 설명서&lt;/a&gt; 의 &quot;호환성 고지 사항&quot;을 참조하십시오 . &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 문을 사용 하여이 기능을 켜거나 끌 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b56f76674dd3d27b6ff064c91089204d7b0e90fc" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_FILE_FORMAT option activates or deactivates the legacy file format flag. When activated, this flag causes all newly created database file to have a schema format version number (the 4-byte integer found at offset 44 into the database header) of 1. This in turn means that the resulting database file will be readable and writable by any SQLite version back to 3.0.0 (2004-06-18). Without this setting, newly created databases are generally not understandable by SQLite versions prior to 3.3.0 (2006-01-11). As these words are written, there is now scarcely any need to generated database files that are compatible all the way back to version 3.0.0, and so this setting is of little practical use, but is provided so that SQLite can continue to claim the ability to generate new database files that are compatible with version 3.0.0.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 옵션은 레거시 파일 형식 플래그를 활성화하거나 비활성화합니다. 활성화되면이 플래그는 새로 생성 된 모든 데이터베이스 파일이 1의 스키마 형식 버전 번호 (데이터베이스 헤더의 오프셋 44에있는 4 바이트 정수)를 갖도록합니다. 이는 결과 데이터베이스 파일을 읽고 쓸 수 있음을 의미합니다. 모든 SQLite 버전을 3.0.0 (2004-06-18)으로 되돌립니다. 이 설정이 없으면 새로 생성 된 데이터베이스는 일반적으로 3.3.0 (2006-01-11) 이전의 SQLite 버전에서 이해할 수 없습니다. 이 단어가 작성됨에 따라 이제 버전 3.0.0까지 완전히 호환되는 데이터베이스 파일을 생성 할 필요가 거의 없으므로이 설정은 실용적이지 않지만 SQLite가 계속해서 버전 3.0.0과 호환되는 새 데이터베이스 파일을 생성하는 기능.</target>
        </trans-unit>
        <trans-unit id="609f392579cb3bfb47e8225e916b400815ceda24" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_TRUSTED_SCHEMA option tells SQLite to assume that database schemas are untainted by malicious content. When the SQLITE_DBCONFIG_TRUSTED_SCHEMA option is disabled, SQLite takes additional defensive steps to protect the application from harm including:</source>
          <target state="translated">SQLITE_DBCONFIG_TRUSTED_SCHEMA 옵션은 데이터베이스 스키마가 악성 콘텐츠에 의해 오염되지 않았다고 가정하도록 SQLite에 지시합니다. SQLITE_DBCONFIG_TRUSTED_SCHEMA 옵션이 비활성화되면 SQLite는 다음과 같은 위험으로부터 애플리케이션을 보호하기 위해 추가 방어 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="6b8460a489883d4335645b0e8208feef234ba632" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMA 옵션은 &quot;writable_schema&quot;플래그를 활성화하거나 비활성화합니다. 이는 동일한 효과를 가지며 &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; 또는 &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt; 설정과 논리적으로 동일합니다 . 이 설정에 대한 첫 번째 인수는 writable_schema를 사용 안함으로 설정하려면 0이고, writable_schema를 사용으로 설정하려면 양수, 설정을 변경하지 않은 경우 음수 인 정수입니다. 두 번째 매개 변수는이 호출에 따라 writable_schema가 사용 가능한지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="46872dc1f07ab31c88fb7c7af6f4fae5ff78bc83" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMA 옵션은 &quot;writable_schema&quot;플래그를 활성화하거나 비활성화합니다. 이는 동일한 효과를 가지며 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt; 설정과 논리적으로 동일합니다 . 이 설정에 대한 첫 번째 인수는 writable_schema를 사용 안함으로 설정하려면 0이고, writable_schema를 사용으로 설정하려면 양수, 설정을 변경하지 않은 경우 음수 인 정수입니다. 두 번째 매개 변수는이 호출에 따라 writable_schema가 사용 가능한지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="6b85aa8ea894875435c445b85abe99205949918e" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE Virtual Table</source>
          <target state="translated">SQLITE_DBPAGE 가상 테이블</target>
        </trans-unit>
        <trans-unit id="66cd1369214f0f32feaaff6ac1895398317fe842" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides direct access to the underlying database file by interacting with the pager. SQLITE_DBPAGE is capable of both reading and writing any page of the database. Because interaction is through the pager layer, all changes are transactional.</source>
          <target state="translated">SQLITE_DBPAGE 확장 은 호출기와 상호 작용하여 기본 데이터베이스 파일에 직접 액세스 할 수있는 말 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 을 구현합니다 . SQLITE_DBPAGE는 데이터베이스의 모든 페이지를 읽고 쓸 수 있습니다. 상호 작용은 호출기 계층을 통해 이루어 지므로 모든 변경 내용은 트랜잭션 방식입니다.</target>
        </trans-unit>
        <trans-unit id="10bc6095f9cb7b42e8d331fa1d325222ae39eae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">SQLITE_DBPAGE 확장은 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 기본 빌드에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="6759306b08f50bd9c66f3b5fb6678d1fa27bfe11" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option to enable the SQLITE_DBPAGE extension. The SQLITE_DBPAGE extension makes use of unpublished internal interfaces and is not run-time loadable. The only way to add SQLITE_DBPAGE to an application is to compile it in using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBPAGE 확장자는 기본적으로 비활성화되어 있지만 &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되어 있습니다. 사용 &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; SQLITE_DBPAGE 확장을 가능하게 컴파일시 옵션을 선택합니다. SQLITE_DBPAGE 확장은 공개되지 않은 내부 인터페이스를 사용하며 런타임로드 가능하지 않습니다. SQLITE_DBPAGE를 애플리케이션에 추가하는 유일한 방법은 &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; 컴파일 타임 옵션 을 사용하여 컴파일하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="29d747e639293b4d0174864bbfeb0a0f144170ea" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table allows an application to view or replace the raw binary content of each page of the database file. No attempt is made to interpret the content of the page. Content is returned byte-for-byte as it appears on disk.</source>
          <target state="translated">SQLITE_DBPAGE 테이블을 사용하면 애플리케이션이 데이터베이스 파일의 각 페이지에 대한 원시 2 진 컨텐츠를 보거나 바꿀 수 있습니다. 페이지의 내용을 해석하려고 시도하지 않습니다. 디스크에 나타나는 내용은 바이트 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b8d935ab9300d2651f69fa35d68c10b3cdb857" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table can participate in a join just like any other table. Hence, to see the content of the first page to all connected database files, one might run a statement like this:</source>
          <target state="translated">SQLITE_DBPAGE 테이블은 다른 테이블과 마찬가지로 조인에 참여할 수 있습니다. 따라서 연결된 모든 데이터베이스 파일에 대한 첫 페이지의 내용을 보려면 다음과 같은 명령문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d4ed3f8e0c537ab57736b4ad4d051438f525bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table has one row for each page in the database file. SQLITE_DBPAGE allows pages to be read or to be overwritten. However the size of the database file cannot be changed. It is not possible to change the number of rows in the SQLITE_DBPAGE table by running DELETE or INSERT operations against that table.</source>
          <target state="translated">SQLITE_DBPAGE 테이블에는 데이터베이스 파일의 각 페이지마다 하나의 행이 있습니다. SQLITE_DBPAGE를 사용하면 페이지를 읽거나 덮어 쓸 수 있습니다. 그러나 데이터베이스 파일의 크기는 변경할 수 없습니다. 해당 테이블에 대해 DELETE 또는 INSERT 조작을 실행하여 SQLITE_DBPAGE 테이블의 행 수를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74c5162b414c69b11a7519aa50aa6d53d70b24f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table schema shown above is incomplete. There is a third &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;schema&quot; that determines which &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed database&lt;/a&gt; should be read or written. Because the &quot;schema&quot; column is hidden, it can be used as a parameter when SQLITE_DBPAGE is invoked as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 SQLITE_DBPAGE 테이블 스키마가 불완전합니다. 읽거나 쓸 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH 데이터베이스&lt;/a&gt; 를 결정하는 &quot;스키마&quot;라는 세 번째 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 있습니다. &quot;스키마&quot;열이 숨겨져 있으므로 SQLITE_DBPAGE가 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 로 호출 될 때 매개 변수로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="518c52e0806550bfb6aa69b1fed15fbc4111a9ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE virtual table read/write table that provides direct access to the underlying disk file on a page-by-page basis. The virtual table appears to have a schema like this:</source>
          <target state="translated">페이지별로 기본 디스크 파일에 직접 액세스 할 수있는 SQLITE_DBPAGE 가상 테이블 읽기 / 쓰기 테이블. 가상 테이블에는 다음과 같은 스키마가있는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="c1930c1236dfcd2ca69ef991dff0ceab5ad493f1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE는 P 인수의 데이터베이스 직렬화가 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 유지되며 SQLite가이 메모리의 소유권을 가져 와서 사용이 끝나면 자동으로 해제해야 함을 의미합니다. 이 플래그가 없으면 호출자는 동적으로 할당 된 메모리를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="76631b67d929ebcd295444bce3ec1691bb16c502" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE는 P 인수의 데이터베이스 직렬화가 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 유지되며 SQLite가이 메모리의 소유권을 가져 와서 사용이 끝나면 자동으로 해제해야 함을 의미합니다. 이 플래그가 없으면 호출자는 동적으로 할당 된 메모리를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="fffd4707786aad32f12960ea601bc8b62704db6b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.</source>
          <target state="translated">SQLITE_DESERIALIZE_READONLY 플래그는 역 직렬화 된 데이터베이스가 읽기 전용으로 처리되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="684cad9c07969122877d4a208d11cefd54e63c00" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLE 플래그는 SQLite가 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64 ()&lt;/a&gt; 호출을 사용하여 데이터베이스 크기를 늘릴 수 있음을 의미합니다 . 이 플래그는 SQLITE_DESERIALIZE_FREEONCLOSE도 사용되는 경우에만 사용해야합니다. 이 플래그가 없으면 역 직렬화 된 데이터베이스는 M 매개 변수로 지정된 바이트 수를 초과하여 크기를 늘릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80121a4afb11422b1c8bfdaf5caf6ca8a41c2e89" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLE 플래그는 SQLite가 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64 ()&lt;/a&gt; 호출을 사용하여 데이터베이스 크기를 늘릴 수 있음을 의미합니다 . 이 플래그는 SQLITE_DESERIALIZE_FREEONCLOSE도 사용되는 경우에만 사용해야합니다. 이 플래그가 없으면 역 직렬화 된 데이터베이스는 M 매개 변수로 지정된 바이트 수를 초과하여 크기를 늘릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19352bde546497cb9c8447fd1d7dfafe9e2fb83c" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTIC 플래그는 입력 매개 변수가 동일 할 때 새 함수가 항상 동일한 출력을 제공함을 의미합니다. &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS () 함수는&lt;/a&gt; , 예를 들면, 결정 성이지만 &lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;RANDOMBLOB ()는&lt;/a&gt; 아니다. &lt;a href=&quot;../partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;../gencol&quot;&gt;생성 된 열과&lt;/a&gt; 같은 특정 컨텍스트에서 사용하려면 함수가 결정적이어야합니다 . SQLite는 또한 내부 루프에서 인수 분해하여 결정적 함수를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a94dcf703cfcb3aebcafb1d5511712f18433c467" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTIC 플래그는 입력 매개 변수가 동일 할 때 새 함수가 항상 동일한 출력을 제공함을 의미합니다. &lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS () 함수는&lt;/a&gt; , 예를 들면, 결정 성이지만 &lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;RANDOMBLOB ()는&lt;/a&gt; 아니다. &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;gencol&quot;&gt;생성 된 열과&lt;/a&gt; 같은 특정 컨텍스트에서 사용하려면 함수가 결정적이어야합니다 . SQLite는 또한 내부 루프에서 인수 분해하여 결정적 함수를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a817ebcb8adde635efe8cf6f019a45cbccc77452" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function will always maps the same inputs into the same output. The abs() function is deterministic, for example, but randomblob() is not.</source>
          <target state="translated">SQLITE_DETERMINISTIC 플래그는 새 함수가 항상 동일한 입력을 동일한 출력에 맵핑 함을 의미합니다. 예를 들어 abs () 함수는 결정적이지만 randomblob ()는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e7795e7dba3d35d408494ba100326feff56ac8bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLY 플래그는 함수가 최상위 SQL에서만 호출 될 수 있으며 VIEW 또는 TRIGGER 또는 &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;../expridx&quot;&gt;표현식 인덱스&lt;/a&gt; , &lt;a href=&quot;../partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 또는 &lt;a href=&quot;../gencol&quot;&gt;생성 된 열과&lt;/a&gt; 같은 스키마 구조에서 사용할 수 없음을 의미합니다 . SQLITE_DIRECTONLY 플래그는 모든 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; , 특히 부작용이 있거나 민감한 정보를 유출 할 수있는 함수에 권장되는 보안 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="fbd921523501ad6603970193474c7602b6fd6ef1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLY 플래그는 함수가 최상위 SQL에서만 호출 될 수 있으며 VIEW 또는 TRIGGER 또는 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; , &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 또는 &lt;a href=&quot;gencol&quot;&gt;생성 된 열과&lt;/a&gt; 같은 스키마 구조에서 사용할 수 없음을 의미합니다 . SQLITE_DIRECTONLY 플래그는 모든 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; , 특히 부작용이 있거나 민감한 정보를 유출 할 수있는 함수에 권장되는 보안 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="8bfa7a3aa99efd025281e40fa4911eb7511574c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLY 플래그는 함수가 최상위 SQL에서만 호출 될 수 있으며 VIEW 또는 TRIGGER에서 사용할 수 없음을 의미합니다. 이것은 부작용이있는 모든 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수에&lt;/a&gt; 권장되는 보안 기능입니다 . 이 플래그는 공격자가 스키마에 트리거 및 뷰를 추가 한 다음 일반 쿼리를 수행하는 동안 높은 권한의 응용 프로그램을 속여 의도하지 않은 부작용을 유발하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="ad5270c7d2917dccd93322da5fb7248f9aa949c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLY 플래그는 함수가 최상위 SQL에서만 호출 될 수 있으며 VIEW 또는 TRIGGER에서 사용할 수 없음을 의미합니다. 이것은 부작용이있는 모든 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수에&lt;/a&gt; 권장되는 보안 기능입니다 . 이 플래그는 공격자가 스키마에 트리거 및 뷰를 추가 한 다음 일반 쿼리를 수행하는 동안 높은 권한의 응용 프로그램을 속여 의도하지 않은 부작용을 유발하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="ec40aca0df374578f31a734ba1f44f72205f5695" translate="yes" xml:space="preserve">
          <source>The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_DONE 결과 코드는 작업이 완료되었음을 나타냅니다. SQLITE_DONE 결과 코드는 가장 일반적으로 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 의 반환 값으로 표시되어 SQL 문이 완료되었다는 것을 나타냅니다. 그러나 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 과 같은 다른 다단계 인터페이스에서 SQLITE_DONE을 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb790f9dfaacb5c859298fcd4607429394630f86" translate="yes" xml:space="preserve">
          <source>The SQLITE_EMPTY result code is not currently used.</source>
          <target state="translated">SQLITE_EMPTY 결과 코드는 현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae12a93b43b3b42e7d80f8bbf0372c74ffcd4aa7" translate="yes" xml:space="preserve">
          <source>The SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE options are not documented in &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; document because they are not officially supported. What they do is activate the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; dot-commands in the command-line shell, which provide low-level tracing output for the logic that generates code for SELECT statements and WHERE clauses, respectively.</source>
          <target state="translated">SQLITE_ENABLE_SELECTTRACE 및 SQLITE_ENABLE_WHERETRACE 옵션은 공식적으로 지원되지 않으므로 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션&lt;/a&gt; 문서에 문서화되어 있지 않습니다. 명령 줄 셸에서 &quot;.selecttrace&quot;및 &quot;.wheretrace&quot;도트 명령을 활성화하면 각각 SELECT 문과 WHERE 절에 대한 코드를 생성하는 논리에 대한 저수준 추적 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="270e8d29bbaf2c173c8af4cf652d5609825ae163" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.</source>
          <target state="translated">SQLITE_ERROR 결과 코드는 다른 특정 오류 코드를 사용할 수 없을 때 사용되는 일반 오류 코드입니다.</target>
        </trans-unit>
        <trans-unit id="98c271c04ddb7b453a82bc99e0c9a2f05fc01521" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_MISSING_COLLSEQ result code means that an SQL statement could not be prepared because a collating sequence named in that SQL statement could not be located.</source>
          <target state="translated">SQLITE_ERROR_MISSING_COLLSEQ 결과 코드는 해당 SQL 문에 이름이 지정된 조합 순서를 찾을 수 없으므로 SQL 문을 준비 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ba8f59027948d8336d219d332d3588711710c0d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_RETRY is used internally to provoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; (or one of its sibling routines for creating prepared statements) to try again to prepare a statement that failed with an error on the previous attempt.</source>
          <target state="translated">SQLITE_ERROR_RETRY는 내부적으로 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (또는 준비된 명령문을 작성하기위한 형제 루틴 중 하나 ) 를 유발 하여 이전 시도에서 오류로 실패한 명령문을 다시 시도하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ccb2dd2db61b6baf0b7083d2230974437265ca99" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_SNAPSHOT result code might be returned when attempting to start a read transaction on an historical version of the database by using the &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface. If the historical snapshot is no longer available, then the read transaction will fail with the SQLITE_ERROR_SNAPSHOT. This error code is only possible if SQLite is compiled with &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스를 사용하여 히스토리 버전의 데이터베이스에서 읽기 트랜잭션을 시작하려고 할 때 SQLITE_ERROR_SNAPSHOT 결과 코드가 리턴 될 수 있습니다 . 히스토리 스냅 샷을 더 이상 사용할 수 없으면 SQLITE_ERROR_SNAPSHOT과 함께 읽기 트랜잭션이 실패합니다. 이 오류 코드는 SQLite가 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 로 컴파일 된 경우에만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="4cbfe2b69087f0c646cf57766f8596a36d37fac1" translate="yes" xml:space="preserve">
          <source>The SQLITE_EXTRA_DURABLE compile-time option that used to cause the default &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting to be EXTRA, rather than FULL. This option is no longer supported. Use &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS=3&lt;/a&gt; instead.</source>
          <target state="translated">기본 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정을 FULL이 아닌 EXTRA로 설정 하는 데 사용 된 SQLITE_EXTRA_DURABLE 컴파일 타임 옵션 . 이 옵션은 더 이상 지원되지 않습니다. 대신 &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS = 3을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b13fb7c225046a481ec4f5c3de65895a35d5a534" translate="yes" xml:space="preserve">
          <source>The SQLITE_FORMAT error code is not currently used by SQLite.</source>
          <target state="translated">SQLITE_FORMAT 오류 코드는 현재 SQLite에서 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26b0edcf7878a4f55c879fd1aba1c1f540342aa6" translate="yes" xml:space="preserve">
          <source>The SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_FULL 결과 코드는 디스크가 가득 차서 쓰기를 완료 할 수 없음을 나타냅니다. 이 오류는 기본 데이터베이스 파일에 정보를 쓰려고 할 때 또는 &lt;a href=&quot;tempfiles&quot;&gt;임시 디스크 파일에&lt;/a&gt; 쓸 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52c86e9943e29fd3d57282b842d9c3bedce88e03" translate="yes" xml:space="preserve">
          <source>The SQLITE_HISTORY environment variable, if it exists, specifies the name of the command-line editing history file</source>
          <target state="translated">SQLITE_HISTORY 환경 변수 (있는 경우)는 명령 행 편집 히스토리 파일의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e10c2e4fcb65972fbd71d50bdb5c4ac5d88e54e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUS 플래그는 함수가 잘못 사용 되더라도 문제를 일으키지 않을 것임을 의미합니다. 무해한 함수는 부작용이 없어야하며 입력 매개 변수 이외의 값에 의존해서는 안됩니다. &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS () 함수는&lt;/a&gt; 무해한 함수의 예이다. &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 때문에 부작용 무해하지 않다.</target>
        </trans-unit>
        <trans-unit id="a3a2b2609c215ba1aae8c191414849f564b054dd" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUS 플래그는 함수가 잘못 사용 되더라도 문제를 일으키지 않을 것임을 의미합니다. 무해한 함수는 부작용이 없어야하며 입력 매개 변수 이외의 값에 의존해서는 안됩니다. &lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS () 함수는&lt;/a&gt; 무해한 함수의 예이다. &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 때문에 부작용 무해하지 않다.</target>
        </trans-unit>
        <trans-unit id="521e2762edbf8211c7cbb9d7bfb58da8a1f086c6" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.</source>
          <target state="translated">SQLITE_INTERNAL 결과 코드는 내부 오작동을 나타냅니다. 작업중인 SQLite 버전에서 응용 프로그램은이 결과 코드를 볼 수 없습니다. 응용 프로그램에서이 결과 코드가 발생하면 데이터베이스 엔진에 버그가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b38d579654b4f1182c07a8a6f5867deba9d19d28" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface. See also: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</source>
          <target state="translated">SQLITE_INTERRUPT 결과 코드는 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 인터페이스에 의해 작업이 중단되었음을 나타냅니다 . &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1b9bcba49ffcf44baa9a43853834f3537e3646" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC 속성은 모든 크기의 쓰기가 원자적임을 의미합니다. SQLITE_IOCAP_ATOMICnnn 값은 크기가 nnn 바이트이고 nnn의 정수배 인 주소에 정렬 된 블록의 쓰기는 원자적임을 의미합니다. SQLITE_IOCAP_SAFE_APPEND 값은 데이터가 파일에 추가 될 때 데이터가 먼저 추가 된 다음 파일 크기가 확장된다는 것을 의미합니다. SQLITE_IOCAP_SEQUENTIAL 속성은 xWrite () 호출과 동일한 순서로 정보가 디스크에 기록됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6cfdb556dc4a2d2c3aee5156579c0505409a3242" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC 속성은 모든 크기의 쓰기가 원자적임을 의미합니다. SQLITE_IOCAP_ATOMICnnn 값은 크기가 nnn 바이트이고 nnn의 정수배 인 주소에 정렬 된 블록의 쓰기는 원자적임을 의미합니다. SQLITE_IOCAP_SAFE_APPEND 값은 데이터가 파일에 추가 될 때 데이터가 먼저 추가 된 다음 파일 크기가 확장된다는 것을 의미합니다. SQLITE_IOCAP_SEQUENTIAL 속성은 xWrite () 호출과 동일한 순서로 정보가 디스크에 기록됨을 의미합니다. SQLITE_IOCAP_POWERSAFE_OVERWRITE 속성은 충돌 또는 전원 손실 후 재부팅 후 응용 프로그램 수준에서 작성된 파일의 바이트 만 변경 될 수 있으며 동일한 섹터 내의 바이트조차도 변경되지 않음을 의미합니다.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN 플래그는 파일을 열 때 파일을 삭제할 수 없음을 나타냅니다. SQLITE_IOCAP_IMMUTABLE 플래그는 파일이 읽기 전용 매체에 있으며 상승 된 권한을 가진 프로세스로도 변경할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d6e9041084560f5cee1cd0f7e8b2669a77b404b5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMIC 특성은 기본 쓰기 파일 시스템이 &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; 및 &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE에&lt;/a&gt; 의해 쓰기 조작이 브라켓 될 때 여러 쓰기 조작을 원자 적으로 수행하는 것을 지원함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7cb11acb1c9a7effbe4c566606f90f111aeaa51c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMIC 특성은 기본 쓰기 파일 시스템이 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; 및 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE에&lt;/a&gt; 의해 쓰기 조작이 브라켓 될 때 여러 쓰기 조작을 원자 적으로 수행하는 것을 지원함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="abba910b15531d36f82588d451d0981d7b760afc" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.</source>
          <target state="translated">SQLITE_IOERR 결과 코드는 운영 체제가 I / O 오류를보고하여 조작을 완료 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6217042802c9b2c3161cf544abc5162c5330d1de" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xAccess method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_ACCESS 오류 코드는 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xAccess 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="e2437ab6f22990f68cc3c6b6ab11345e11bf39ab" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xClose method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_ACCESS 오류 코드는 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xClose 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d2cdfe432186a7333ec15fb6eebac01e4168d421" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BLOCKED error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_BLOCKED 오류 코드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d52b5d2e176049b701cd38566a1ec537e178a582" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xCheckReservedLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_CHECKRESERVEDLOCK 오류 코드는 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xCheckReservedLock 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0ad717c7b1ad0bbb8f95440fa25c68effa605b2e" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed. See also: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</source>
          <target state="translated">SQLITE_IOERR_CONVPATH 오류 코드는 Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서만 사용되며 cygwin_conv_path () 시스템 호출이 실패했음을 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 참조 : &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1351f2d6333fe014b3d2efb02bea78fd2458ea8" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DELETE_NOENT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object failed because the file being deleted does not exist.</source>
          <target state="translated">SQLITE_IOERR_DELETE_NOENT 오류 코드는 삭제중인 파일이 없기 때문에 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xDelete 메소드가 실패 &lt;a href=&quot;rescode#ioerr&quot;&gt;했음을&lt;/a&gt; 나타내는 SQLITE_IOERR에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3d4ef8736b02588e9ecd702311e3b92f76c71f42" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_CLOSE error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_DIR_CLOSE 오류 코드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="257039837e1e28ae4885f94438deef37c72bcb03" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fsync() on a directory. The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().</source>
          <target state="translated">SQLITE_IOERR_DIR_FSYNC 오류 코드는 디렉토리에서 fsync ()를 호출하려고 시도하는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 특정 파일을 생성하거나 삭제 한 후 디렉토리가 fsync ()를 시도하여 전원 손실 또는 시스템 충돌 후 해당 파일이 파일 시스템에 계속 표시되도록합니다. 이 오류 코드는 해당 fsync ()를 수행하는 데 문제가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="703a40890c81baa50195428ead914670c8029bb4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSTAT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.</source>
          <target state="translated">SQLITE_IOERR_FSTAT 오류 코드는 파일 크기 또는 액세스 권한과 같은 정보를 판별하기 위해 파일에서 fstat () (또는 동등한 항목)를 호출하려고 시도하는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="4411956ede5824f9653b6f7288932d4d59a1407a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.</source>
          <target state="translated">SQLITE_IOERR_FSYNC 오류 코드는 이전에 작성된 내용을 OS 및 / 또는 디스크 제어 버퍼 및 영구 저장소로 플러시하려고 시도하는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 즉,이 코드는 Unix의 fsync () 시스템 호출 또는 Windows의 FlushFileBuffers () 시스템 호출에 문제가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1a80a6afbc34a7c330788ef9f803a0b5991e12c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_GETTEMPPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is unable to determine a suitable directory in which to place temporary files.</source>
          <target state="translated">SQLITE_IOERR_GETTEMPPATH 오류 코드는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 가 임시 파일을 배치 할 적절한 디렉토리를 결정할 수 없음을 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="cb09e15d8dd94c07c078d48b512a0e609b4a1ec7" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_LOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING lock&lt;/a&gt;. However it can also indicate miscellaneous locking errors on some of the specialized &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; used on Macs.</source>
          <target state="translated">SQLITE_IOERR_LOCK 오류 코드는 권고 파일 잠금 논리에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 일반적으로 SQLITE_IOERR_LOCK 오류는 &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING 잠금을&lt;/a&gt; 얻는 데 문제가 있음을 나타냅니다 . 그러나 Mac에서 사용되는 일부 특수 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서 기타 잠금 오류를 나타낼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="928b9fb773e51d9b98d4eea6c5ad41e7a120edb9" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_MMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xFetch or xUnfetch methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map or unmap part of the database file into the process address space.</source>
          <target state="translated">SQLITE_IOERR_MMAP 오류 코드는 데이터베이스 파일의 일부를 프로세스 주소 공간에 맵핑하거나 맵핑 해제하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xFetch 또는 xUnfetch 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f2e769d752ed0575abbf0db74e042a1d936197ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_NOMEM error code is sometimes returned by the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; by the higher layers of SQLite before being returned to the application.</source>
          <target state="translated">충분한 메모리를 할당 할 수 없어서 조작을 완료 할 수 없음을 나타 내기 위해 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층에서 SQLITE_IOERR_NOMEM 오류 코드를 리턴하는 경우가 있습니다. 이 오류 코드는 일반적으로 애플리케이션으로 리턴되기 전에 상위 계층의 SQLite에 의해 &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8545169dd7924f6c6604c36309fb09b48638942a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.</source>
          <target state="translated">SQLITE_IOERR_READ 오류 코드는 디스크의 파일에서 읽는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 의 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 이 오류는 하드웨어 오작동 또는 파일이 열려있는 동안 파일 시스템이 마운트 해제되어 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b973a2eb159aa040eee4609af08e2a1feaa8688" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SEEK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xRead or xWrite methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.</source>
          <target state="translated">SQLITE_IOERR_SEEK 오류 코드는 읽기 또는 쓰기가 발생할 파일의 시작점으로 파일 디스크립터를 찾으려고 시도하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xRead 또는 xWrite 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="105abf471dd5b51825236d9c7cd0fbb3eb6cb7cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMLOCK error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_SHMLOCK 오류 코드는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19454e66c26708e9c7b0cf7de58d9fc407f5f14b" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map a shared memory segment into the process address space.</source>
          <target state="translated">SQLITE_IOERR_SHMMAP 오류 코드는 공유 메모리 세그먼트를 프로세스 주소 공간에 맵핑하려고 시도하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xShmMap 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="2dc7d56b93948bb563eb131a1d4f4001df7a785f" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMOPEN error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to open a new shared memory segment.</source>
          <target state="translated">SQLITE_IOERR_SHMOPEN 오류 코드는 새로운 공유 메모리 세그먼트를 열려고 시도하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xShmMap 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="38683c7c8ec002f5c2268623f613c65a832d0744" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMSIZE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to enlarge a &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot; file&lt;/a&gt; as part of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; transaction processing. This error may indicate that the underlying filesystem volume is out of space.</source>
          <target state="translated">SQLITE_IOERR_SHMSIZE 오류 코드는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 트랜잭션 처리의 일부로 &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot;파일&lt;/a&gt; 을 확대하려고 시도하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xShmMap 메소드 내에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 이 오류는 기본 파일 시스템 볼륨에 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9742197ad61d509380008ae49be67afbc4a5ec72" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHORT_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that a read attempt in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.</source>
          <target state="translated">SQLITE_IOERR_SHORT_READ 오류 코드는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 의 읽기 시도 가 요청한 바이트 수를 얻을 수 없음을 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 파일이 잘 렸기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a04eeb47de957ef3978cba210956d9cb5d652c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_TRUNCATE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to truncate a file to a smaller size.</source>
          <target state="translated">SQLITE_IOERR_TRUNCATE 오류 코드는 파일을 더 작은 크기로 자르려고 시도하는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="fea43ead41e3ee8f14dc4f738a5d86af22fa9867" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_UNLOCK 오류 코드는 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트의 xDelete 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0b74fa52836b69d8f9666b0cd822fdd7307145f4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to obtain a read lock.</source>
          <target state="translated">SQLITE_IOERR_UNLOCK 오류 코드는 읽기 잠금을 확보하는 동안 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트의 xLock 메소드 내에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c346b35d66f482df6af0e3e742d33c4546a4dc99" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xUnlock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_UNLOCK 오류 코드는 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트의 xUnlock 메소드 내에서 I / O 오류를 표시하는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7f8d955a87bc68c4a0c5a3d4a1efee03acc84572" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_WRITE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.</source>
          <target state="translated">SQLITE_IOERR_WRITE 오류 코드는 디스크의 파일에 쓰려고 시도하는 동안 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 계층 에서 I / O 오류를 나타내는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR에&lt;/a&gt; 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 이 오류는 하드웨어 오작동 또는 파일이 열려있는 동안 파일 시스템이 마운트 해제되어 발생했을 수 있습니다. 해당 목적을 위해 별도의 오류 코드 (SQLITE_FULL)가 있으므로 파일 시스템이 가득 찬 경우이 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="81a8e9c53d139815a64f5839604fdd22fadaa0e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code differs from &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; in that SQLITE_LOCKED indicates a conflict on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or on a connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;) whereas &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; indicates a conflict with a different database connection, probably in a different process.</source>
          <target state="translated">에서 SQLITE_LOCKED 결과 코드 다릅니다 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 그 SQLITE_LOCKED에서 같은에 충돌 나타내는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (또는과의 연결에 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 반면)를 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY은&lt;/a&gt; 아마 다른 프로세스에서 다른 데이터베이스 연결과 충돌을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a782dd7cfb6d09bfdc0225cdd7b256e70fd078f6" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or a conflict with a different database connection that uses a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;.</source>
          <target state="translated">SQLITE_LOCKED 결과 코드는 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 내에서 충돌이 발생하거나 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 사용하는 다른 데이터베이스 연결과의 충돌로 인해 쓰기 작업을 계속할 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="82a5261f187f8bb18f86e6b8f8f93ccb09c0a9f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHARECACHE error code works very much like the &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.</source>
          <target state="translated">SQLITE_LOCKED_SHARECACHE 오류 코드는 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류 코드 와 매우 유사하게 작동 하지만 SQLITE_LOCKED_SHARECACHE는 캐시를 공유하는 별도의 데이터베이스 연결 용이고 SQLITE_BUSY는 동일한 캐시를 공유하지 않는 별도의 데이터베이스 연결의 경우보다 일반적입니다. 또한 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 인터페이스는 SQLITE_LOCKED_SHAREDCACHE 충돌을 해결하는 데 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43736bf56a426c4b58c2bec90f4d48ac9099897c" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicating that the locking conflict has occurred due to contention with a different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that happens to hold a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; with the database connection to which the error was returned. For example, if the other database connection is holding an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;exclusive lock&lt;/a&gt; on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; enabled.</source>
          <target state="translated">SQLITE_LOCKED_SHAREDCACHE 오류 코드는 오류가 리턴 된 데이터베이스 연결과 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 보유하는 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과의 경합으로 인해 잠금 충돌이 발생 &lt;a href=&quot;rescode#locked&quot;&gt;했음을&lt;/a&gt; 나타내는 SQLITE_LOCKED에 대한 &lt;a href=&quot;rescode#pve&quot;&gt;확장 오류 코드&lt;/a&gt; 입니다 . 예를 들어, 다른 데이터베이스 연결이 데이터베이스에서 &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;독점 잠금&lt;/a&gt; 을 보유하고있는 경우, 이 오류를 수신하는 데이터베이스 연결은 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma가&lt;/a&gt; 사용 가능 하지 않으면 데이터베이스 파일의 일부를 읽거나 쓸 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3cda10b684d70e57b826f0fa4c4df09ccba017aa" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_VTAB result code is not used by the SQLite core, but it is available for use by extensions. Virtual table implementations can return this result code to indicate that they cannot complete the current operation because of locks held by other threads or processes.</source>
          <target state="translated">SQLITE_LOCKED_VTAB 결과 코드는 SQLite 코어에서 사용되지 않지만 확장에서 사용할 수 있습니다. 가상 테이블 구현은이 결과 코드를 리턴하여 다른 스레드 또는 프로세스가 보유한 잠금으로 인해 현재 조작을 완료 할 수 없음을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51cbf2f4ccfc41ba0ad01c890bead2935bfa934" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCK_EXCLUSIVE lock must be held by a connection that wants to transition into our out of WAL mode. Transitioning into WAL mode is, therefore, just like any other write transaction, since every write transaction in rollback mode requires the SQLITE_LOCK_EXCLUSIVE lock. If the database file is already in WAL mode (hence if the desire it to change it back into rollback mode) and if there are two or more connections to the database, then each of these connections will be holding an SQLITE_LOCK_SHARED lock. That means that the SQLITE_LOCK_EXCLUSIVE cannot be obtained, and the transition out of WAL mode will not be allowed. This prevents one connection from deleting WAL mode out from under another. It also means that the only way to move a database from WAL mode into rollback mode is to close all but one connection to the database.</source>
          <target state="translated">SQLITE_LOCK_EXCLUSIVE 잠금은 WAL 모드 외부로 전환하려는 연결에 의해 유지되어야합니다. 따라서 롤백 모드의 모든 쓰기 트랜잭션에는 SQLITE_LOCK_EXCLUSIVE 잠금이 필요하므로 WAL 모드로 전환하는 작업은 다른 쓰기 트랜잭션과 같습니다. 데이터베이스 파일이 이미 WAL 모드에 있고 (따라서 롤백 모드로 다시 변경하려는 경우) 데이터베이스에 둘 이상의 연결이있는 경우 이러한 각 연결은 SQLITE_LOCK_SHARED 잠금을 보유합니다. 즉, SQLITE_LOCK_EXCLUSIVE를 얻을 수 없으며 WAL 모드에서 전환 할 수 없습니다. 이렇게하면 한 연결이 다른 연결에서 WAL 모드를 삭제하지 못합니다. 또한 데이터베이스를 WAL 모드에서 롤백 모드로 이동하는 유일한 방법은 데이터베이스에 대한 하나의 연결을 제외한 모든 연결을 닫는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc70544c321ca8a14f098bcf8a7d9ab71f0f189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_COLUMN compile-time parameter is used to set an upper bound on:</source>
          <target state="translated">SQLITE_MAX_COLUMN 컴파일 타임 매개 변수는 다음에 상한을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6525988f532e320cb712d12a43eb0921bdec4dc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_EXPR_DEPTH parameter determines the maximum expression tree depth. If the value is 0, then no limit is enforced. The current implementation has a default value of 1000.</source>
          <target state="translated">SQLITE_MAX_EXPR_DEPTH 매개 변수는 최대 표현식 트리 깊이를 결정합니다. 값이 0이면 제한이 적용되지 않습니다. 현재 구현의 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="87bafa8316c35e0283e8d900b37b61b6cd965c07" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_FUNCTION_ARG parameter determines the maximum number of parameters that can be passed to an SQL function. The default value of this limit is 100. SQLite should work with functions that have thousands of parameters. However, we suspect that anybody who tries to invoke a function with more than a few parameters is really trying to find security exploits in systems that use SQLite, not do useful work, and so for that reason we have set this parameter relatively low.</source>
          <target state="translated">SQLITE_MAX_FUNCTION_ARG 매개 변수는 SQL 함수에 전달할 수있는 최대 매개 변수 수를 결정합니다. 이 제한의 기본값은 100입니다. SQLite는 수천 개의 매개 변수가있는 함수와 함께 작동해야합니다. 그러나 우리는 몇 가지 이상의 매개 변수를 가진 함수를 호출하려고 시도하는 사람이 실제로 SQLite를 사용하는 시스템에서 유용한 작업을 수행하지 않는 보안 공격을 찾으려고 노력하고 있다고 생각 하므로이 매개 변수를 상대적으로 낮게 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="189922ac7fd95f7c9bc12f9ce7e9ab04f1adf79f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_PAGE_SIZE compile-time option is now silently ignored. The maximum page size is hard-coded at 65536 bytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_SIZE 컴파일 타임 옵션은 이제 자동으로 무시됩니다. 최대 페이지 크기는 65536 바이트로 하드 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="862c9c40eeff1a20092e93732416f94a8f2c333f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMDEBUG option causes an instrumented &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; to be used as the default memory allocator within SQLite. The instrumented memory allocator checks for misuse of dynamically allocated memory. Examples of misuse include using memory after it is freed, writing off the ends of a memory allocation, freeing memory not previously obtained from the memory allocator, or failing to initialize newly allocated memory.</source>
          <target state="translated">SQLITE_MEMDEBUG 옵션은 인스트루먼트 된 &lt;a href=&quot;malloc#memdebug&quot;&gt;디버깅 메모리 할당자가&lt;/a&gt; SQLite 내의 기본 메모리 할당 자로 사용되도록합니다. 인스트루먼트 된 메모리 할당자는 동적으로 할당 된 메모리의 오용을 점검합니다. 오용의 예로는 메모리가 해제 된 후 메모리 사용, 메모리 할당의 끝을 기록하거나, 메모리 할당 자로부터 이전에 얻지 못한 메모리를 해제하거나 새로 할당 된 메모리를 초기화하지 못하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d3984ec504895ac3fbb00da3cebcbba9dedbe7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT Virtual Table</source>
          <target state="translated">SQLITE_MEMSTAT 가상 테이블</target>
        </trans-unit>
        <trans-unit id="21d4cb84411a45f761656443b3561b46a357ff18" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">SQLITE_MEMSTAT 확장 은 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 대한 SQL 액세스를 제공 하는 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="aad795204ac31f320600f752e689de3d922a2bd2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT table appears to have the following schema:</source>
          <target state="translated">SQLITE_MEMSTAT 테이블에 다음 스키마가있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5c71018abf94b8f9efc3c61940d93dd9b424da6" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT virtual table is a read-only table that can be queried to determine performance characteristics (primarily the amount of memory being used) of the current instance of SQLite. The SQLITE_MEMSTATE table is essentially a wrapper around the C-language APIs &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;. If the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; source file is compiled with the -DSQLITE_ENABLE_ZIPVFS option, then SQLITE_MEMSTAT will also do some &lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; calls to extract memory usage information about the &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; subsystem, if that subsystem as been licensed, installed, and is in use.</source>
          <target state="translated">SQLITE_MEMSTAT 가상 테이블은 현재 SQLite 인스턴스의 성능 특성 (주로 사용되는 메모리 양)을 확인하기 위해 쿼리 할 수있는 읽기 전용 테이블입니다. SQLITE_MEMSTATE 테이블은 기본적으로 C 언어 API &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 주위의 랩퍼 입니다. &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; 소스 파일이 -DSQLITE_ENABLE_ZIPVFS 옵션으로 컴파일 된 경우, SQLITE_MEMSTAT 는 일부 &lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 호출을 수행하여 해당 서브 시스템이 라이센스가 부여되고 설치되어 사용중인 경우 &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; 서브 시스템 에 대한 메모리 사용량 정보를 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="3941fc28dfa25db6c38115ec794332d498f61a67" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISMATCH error code indicates a datatype mismatch.</source>
          <target state="translated">SQLITE_MISMATCH 오류 코드는 데이터 유형 불일치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="545fecc55ea90185cbbd63fd3b5f04d2c005fc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; after that prepared statement has been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; might result in an SQLITE_MISUSE error.</source>
          <target state="translated">애플리케이션이 정의되지 않거나 지원되지 않는 방식으로 SQLite 인터페이스를 사용하는 경우 SQLITE_MISUSE 리턴 코드가 리턴 될 수 있습니다. 예를 들어, 사용 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비가 문을&lt;/a&gt; 그 준비된 명령문이 된 후 &lt;a href=&quot;c3ref/finalize&quot;&gt;확정&lt;/a&gt; SQLITE_MISUSE 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7378cf4ec519f0105a315e8c418689ed2c8b9d03" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time option is no longer supported. Alternative mutex implementations can now be added at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb. *** Potentially incompatible change ***</source>
          <target state="translated">SQLITE_MUTEX_APPDEF 컴파일 타임 옵션은 더 이상 지원되지 않습니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 동사 와 함께 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 대체 뮤텍스 구현을 추가 할 수 있습니다 . *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="b652223c3c3d5b396101734631bda4e93654d297" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time parameter is no longer recognized. As a replacement, alternative &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementations&lt;/a&gt; may be created at runtime using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; operator and the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_MUTEX_APPDEF 컴파일 타임 매개 변수가 더 이상 인식되지 않습니다. 대체 방법으로 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 연산자 및 &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 객체 와 함께 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 사용하여 런타임에 대체 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;뮤텍스 구현을&lt;/a&gt; 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2c0584076e7e10d1a5a608c7c90ebdabce289b7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application. The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.</source>
          <target state="translated">SQLITE_MUTEX_NOOP 구현은 실제 잠금이없고 단일 스레드 응용 프로그램에 사용하기에 적합한 루틴 세트입니다. SQLITE_MUTEX_PTHREADS 및 SQLITE_MUTEX_W32 구현은 Unix 및 Windows에서 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8dd7fbf941fcd0cbf4106dee4f6ff2100d3cc081" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. &quot;NOLFS&quot; stands for &quot;NO Large File Support&quot;.</source>
          <target state="translated">데이터베이스가 파일 시스템이 처리 할 수있는 것보다 커질 때 큰 파일을 지원하지 않는 시스템에서는 SQLITE_NOLFS 오류가 리턴 될 수 있습니다. &quot;NOLFS&quot;는 &quot;NO Large File Support&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1cda63147d327bf25d081e640b795908860d57cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; has failed in a case where the memory being allocated was required in order to continue the operation.</source>
          <target state="translated">SQLITE_NOMEM 결과 코드는 SQLite가 작업을 완료하는 데 필요한 모든 메모리를 할당 할 수 없음을 나타냅니다. 즉, 작업을 계속하기 위해 할당되는 메모리가 필요한 경우 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()에&lt;/a&gt; 대한 내부 호출 이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="90348aff38a7fe2d16e98097b8d995eefcd13821" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.</source>
          <target state="translated">SQLITE_NOTFOUND 결과 코드는 SQLite 구현에서도 내부적으로 사용되지만 이러한 내부 용도는 응용 프로그램에 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04b892d49dde78c36512aea678380b1b3cb4740c" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface to indicate that the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;file control opcode&lt;/a&gt; passed as the third argument was not recognized by the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_NOTFOUND 결과 코드는 두 가지 컨텍스트에서 사용됩니다. &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스에서 SQLITE_NOTFOUND를 리턴 하여 세 번째 인수로 전달 된 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;파일 제어 opcode&lt;/a&gt; 가 기본 &lt;a href=&quot;vfs&quot;&gt;VFS에서&lt;/a&gt; 인식되지 않았 음을 표시 할 수 있습니다 . &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 오브젝트 의 xSetSystemCall () 메소드로 SQLITE_NOTFOUND를 리턴 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2006836e7cf841369d470c41165b6630c3c15ae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual operation is taking place.</source>
          <target state="translated">C / C ++ 인터페이스는 SQLITE_NOTICE 결과 코드를 리턴하지 않습니다. 그러나 SQLITE_NOTICE (또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 중 하나 )는 때때로 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 콜백 에서 첫 번째 인수로 사용되어 비정상적인 작업이 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="02cb61634cf3f64c55c04a76d9ecf0d6931de129" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; is rolled back.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;핫 저널&lt;/a&gt; 이 롤백 될 때 SQLITE_NOTICE_RECOVER_ROLLBACK 결과 코드가 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 의 콜백으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f198e3499c541e2a07f04094a1095a33b4f9550d" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file is recovered.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 파일이 복구 되면 SQLITE_NOTICE_RECOVER_WAL 결과 코드가 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 의 콜백으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee291eadebc9e5d4151fc8b157f062bbbf6ed568" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.</source>
          <target state="translated">SQLITE_OK 결과 코드는 작업이 성공했으며 오류가 없음을 의미합니다. 대부분의 다른 결과 코드는 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db1bbd15a81f09ee87a066e983ed6980b9d26517" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK_LOAD_PERMANENTLY return code is useful to &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; that register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, for example.</source>
          <target state="translated">SQLITE_OK_LOAD_PERMANENTLY 리턴 코드는 예를 들어 새 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 등록 하는 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장에&lt;/a&gt; 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6becbabbe4a84dad21c1b1544eb673040cac46e2" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_* options are unsupported. By this we mean that an SQLITE_OMIT_* option that omits code from the build in the current release might become a no-op in the next release. Or the other way around: an SQLITE_OMIT_* that is a no-op in the current release might cause code to be excluded in the next release. Also, not all SQLITE_OMIT_* options are tested. Some SQLITE_OMIT_* options might cause SQLite to malfunction and/or provide incorrect answers.</source>
          <target state="translated">SQLITE_OMIT_ * 옵션은 지원되지 않습니다. 이는 현재 릴리스의 빌드에서 코드를 생략하는 SQLITE_OMIT_ * 옵션이 다음 릴리스에서 작동하지 않을 수 있음을 의미합니다. 또는 다른 방법으로, 현재 릴리스에서 no-op 인 SQLITE_OMIT_ *로 인해 다음 릴리스에서 코드가 제외 될 수 있습니다. 또한 모든 SQLITE_OMIT_ * 옵션이 테스트되는 것은 아닙니다. 일부 SQLITE_OMIT_ * 옵션은 SQLite의 오작동 및 / 또는 오답을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d47886ed69e3788c34a2d6c9a632c5948855a34" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_MERGE_SORT option has been removed. The merge sorter is now a required component of SQLite.</source>
          <target state="translated">SQLITE_OMIT_MERGE_SORT 옵션이 제거되었습니다. 병합 분류기는 이제 SQLite의 필수 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2ace5bda746aeaa5497bcf0c7e8c12395a91c1c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.</source>
          <target state="translated">SQLITE_PERM 결과 코드는 새로 작성된 데이터베이스에 대해 요청 된 액세스 모드를 제공 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57074805a6a2909f8660b15999da8d8adc66e584" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZE 플래그는 작동하지 않습니다. 이 플래그는 &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 인터페이스 를 사용하려는 준비된 명령문에 필요했습니다 . 그러나 &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 인터페이스는 이제이 플래그의 사용 여부에 관계없이 모든 준비된 명령문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad4cab077701a7da0038bd41b3f79ceedfd12d8" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZE 플래그는 작동하지 않습니다. 이 플래그는 &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 인터페이스 를 사용하려는 준비된 명령문에 필요했습니다 . 그러나 &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 인터페이스는 이제이 플래그의 사용 여부에 관계없이 모든 준비된 명령문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0438ba55e3894ec50e9427fa15e7d877e35f842" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.</source>
          <target state="translated">명령문이 가상 테이블을 사용하는 경우 SQLITE_PREPARE_NO_VTAB 플래그로 인해 SQL 컴파일러는 오류 (오류 코드 SQLITE_ERROR)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="68c6b699083a20e7dac515dfb0a940a1d2fa1d0a" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENT 플래그는 준비된 명령문이 오랫동안 보유되어 여러 번 재사용 될 것이라는 쿼리 플래너의 힌트입니다. 이 플래그가 없으면 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 은 준비된 명령문이 한 번 또는 최대 몇 번 사용 된 후 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 비교적 빨리 제거 된다고 가정합니다 . 현재 구현은 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리&lt;/a&gt; 의 제한된 저장소를 고갈시키지 않도록 lookaside 메모리 의 사용을 피 함으로써이 힌트에 작용 합니다. 이후 버전의 SQLite는이 힌트에 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="799dbb7451dd41ca217be627d63018af5431d1bf" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENT 플래그는 준비된 명령문이 오랫동안 보유되어 여러 번 재사용 될 것이라는 쿼리 플래너의 힌트입니다. 이 플래그가 없으면 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 은 준비된 명령문이 한 번 또는 최대 몇 번 사용 된 후 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 비교적 빨리 제거 된다고 가정합니다 . 현재 구현은 &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside 메모리&lt;/a&gt; 의 제한된 저장소를 고갈시키지 않도록 lookaside 메모리 의 사용을 피 함으로써이 힌트에 작용 합니다. 이후 버전의 SQLite는이 힌트에 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c11fb868fc472e55f703cb835b3c6a27d603969" translate="yes" xml:space="preserve">
          <source>The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and attempting to start a new transaction. There is a race condition that can occur when two separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; both try to start a transaction at the same time in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.</source>
          <target state="translated">SQLITE_PROTOCOL 결과 코드는 SQLite에서 사용하는 파일 잠금 프로토콜에 문제가 있음을 나타냅니다. SQLITE_PROTOCOL 오류는 현재 &lt;a href=&quot;wal&quot;&gt;WAL 모드를&lt;/a&gt; 사용 하고 새 트랜잭션을 시작하려고 할 때만 리턴됩니다 . 두 개의 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 동시에 트랜잭션을 시작하려고 할 때 발생할 수있는 경쟁 조건이 있습니다 . 레이스의 패자는 잠시 후 잠시 후 다시 시도합니다. 동일한 연결에서 수 초에 걸쳐 수십 번의 잠금 경쟁이 중단되면 결국 SQLITE_PROTOCOL을 포기하고 반환합니다. SQLITE_PROTOCOL 오류는 실제로 매우 드물게 나타나며 동일한 데이터베이스에 쓰기 위해 경쟁하는 많은 개별 프로세스가있는 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2290c0085d649d3364cd3e13fd796218538f0c97" translate="yes" xml:space="preserve">
          <source>The SQLITE_RANGE error indices that the parameter number argument to one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; routines or the column number in one of the &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; routines is out of range.</source>
          <target state="translated">SQLITE_RANGE 오류는 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; 루틴 중 하나에 대한 매개 변수 번호 인수 또는 sqlite3_column 루틴 중 하나의 열 번호 가 범위를 벗어 &lt;a href=&quot;c3ref/column_blob&quot;&gt;났음&lt;/a&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="81db86b91239da795ab1877a821491920db31614" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.</source>
          <target state="translated">현재 데이터베이스 연결에 쓰기 권한이없는 일부 데이터를 변경하려고 시도하면 SQLITE_READONLY 결과 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20a2e61649ed0f39a9f887714e92e822fd9ead1d" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTINIT result code originates in the xShmMap method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to indicate that the shared memory region used by &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; exists buts its content is unreliable and unusable by the current process since the current process does not have write permission on the shared memory region. (The shared memory region for WAL mode is normally a file with a &quot;-wal&quot; suffix that is mmapped into the process space. If the current process does not have write permission on that file, then it cannot write into shared memory.)</source>
          <target state="translated">SQLITE_READONLY_CANTINIT 결과 코드는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xShmMap 메소드에서 시작 하여 &lt;a href=&quot;wal&quot;&gt;WAL 모드에서&lt;/a&gt; 사용하는 공유 메모리 영역 이 존재하지만 현재 프로세스에 공유 메모리 영역에 대한 쓰기 권한이 없으므로 해당 컨텐츠를 현재 프로세스에서 신뢰할 수없고 사용할 수 없음을 나타냅니다 . WAL 모드의 공유 메모리 영역은 일반적으로 프로세스 공간에 매핑되는 &quot;-wal&quot;접미사가있는 파일입니다. 현재 프로세스에 해당 파일에 대한 쓰기 권한이 없으면 공유 메모리에 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8cc5d69c49bd0049fa508081d686d1a3ef3d0153" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database because the shared-memory file associated with that database is read-only.</source>
          <target state="translated">SQLITE_READONLY_CANTLOCK 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . SQLITE_READONLY_CANTLOCK 오류 코드는 해당 데이터베이스와 연관된 공유 메모리 파일이 읽기 전용이므로 SQLite가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서 읽기 잠금을 얻을 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="19656bfe231a68e2b6cce42b55c5197d3d416be0" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DBMOVED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; would not be correctly named.</source>
          <target state="translated">SQLITE_READONLY_DBMOVED 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . SQLITE_READONLY_DBMOVED 오류 코드는 데이터베이스 파일이 열린 이후로 이동했기 때문에 데이터베이스를 수정할 수 없으므로 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널의&lt;/a&gt; 이름이 올바르게 지정되지 않아 프로세스가 충돌하는 경우 데이터베이스를 수정하려고하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ecb30affe77245ceb751ab6c0b2e9fce929efd" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DIRECTORY result code indicates that the database is read-only because process does not have permission to create a journal file in the same directory as the database and the creation of a journal file is a prerequisite for writing.</source>
          <target state="translated">SQLITE_READONLY_DIRECTORY 결과 코드는 데이터베이스와 동일한 디렉토리에 저널 파일을 작성할 수있는 권한이없고 저널 파일 작성이 쓰기 전제 조건이므로 데이터베이스가 읽기 전용임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2523ec31f0b9a2d33cf73109d61b1e043f8086c" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_RECOVERY error code indicates that a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.</source>
          <target state="translated">SQLITE_READONLY_RECOVERY 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . SQLITE_READONLY_RECOVERY 오류 코드는 데이터베이스 파일을 복구해야하고 복구에는 쓰기 액세스가 필요하지만 읽기 액세스 만 가능하므로 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스를 열 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ba838fe9f900034dae5111194ba7ea1d5270d1c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; that needs to be rolled back but cannot because the database is readonly.</source>
          <target state="translated">SQLITE_READONLY_ROLLBACK 오류 코드는입니다 &lt;a href=&quot;rescode#pve&quot;&gt;확장 된 오류 코드&lt;/a&gt; 에 대한 &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . SQLITE_READONLY_ROLLBACK 오류 코드는 롤백해야하는 &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;핫 저널&lt;/a&gt; 이 있기 때문에 데이터베이스를 열 수 없지만 데이터베이스가 읽기 전용이므로 데이터베이스를 열 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d25154fd2f20b85ded4823ebe97f48106c96d4d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ROW result code returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicates that another row of output is available.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 의해 리턴 된 SQLITE_ROW 결과 코드는 다른 출력 행이 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d91aee6732a465a4cc20090bf5eb9177f9e582c" translate="yes" xml:space="preserve">
          <source>The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that was generated using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.</source>
          <target state="translated">SQLITE_SCHEMA 결과 코드는 데이터베이스 스키마가 변경되었음을 나타냅니다. 이 결과 코드는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대해 리턴 될 수 있습니다 .&lt;a href=&quot;c3ref/prepare&quot;&gt; sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()을&lt;/a&gt; 사용하여 생성 된 . 명령문이 준비된 시간과 명령문이 실행 된 시간 사이에 다른 프로세스에 의해 데이터베이스 스키마가 변경된 경우이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bccaf372951fcf999b80b85d54115242255c5910" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT Virtual Table</source>
          <target state="translated">SQLITE_STMT 가상 테이블</target>
        </trans-unit>
        <trans-unit id="0210be179f988cfe689d56f75f4d1fa3e0b6bb8b" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; 의 소스 코드를 사용하여 확장을 공유 라이브러리 또는 DLL로 컴파일하여 SQLITE_STMT 확장을 런타임에로드 할 수도 있습니다. 하고 다음 지시 사항을 수행하여&lt;a href=&quot;loadext#build&quot;&gt; 로드 가능한 확장&lt;/a&gt; 을 컴파일 하는 방법 .</target>
        </trans-unit>
        <trans-unit id="c79456ebf36875bab38cefa2c6e55d9482f8dca7" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides information about all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT 확장 은 모든 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에 대한 정보를 제공 하는 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 을 구현합니다 . 은 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 연관된 합니다 .</target>
        </trans-unit>
        <trans-unit id="514c2473199b17afc5dd1d8c02362217c121606a" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT 확장은 기본 빌드에서 사용 가능합니다. &lt;a href=&quot;cli&quot;&gt; 명령 행 쉘&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e53abd5cd3368a9c18b0e2f006747b4e8c1e98ad" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; compile-time option to enable the SQLITE_STMT extension. The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT 확장은 기본적으로 비활성화되어 있지만 &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되어 있습니다. &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; 컴파일 시간 옵션을 사용하여 SQLITE_STMT 확장을 사용하십시오. &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; 의 소스 코드를 사용하여 공유 라이브러리 또는 DLL로 확장을 컴파일 하고 다음 지시 사항을 수행하여 SQLITE_STMT 확장을 런타임에로드 할 수도 있습니다. 어떻게&lt;a href=&quot;loadext#build&quot;&gt; 로드 가능한 확장 컴파일&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eff6d72f1420a16df254227915d0745e46f60ade" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table can also be used to access performance information about prepared statements, to aid in optimization an application. For example, to find out how much memory is being used by &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that have never been used, one could run:</source>
          <target state="translated">SQLITE_STMT 가상 테이블을 사용하여 준비된 명령문에 대한 성능 정보에 액세스하여 응용 프로그램을 최적화 할 수 있습니다. 예를 들어, 사용중인 메모리 양을 확인하려면&lt;a href=&quot;c3ref/stmt&quot;&gt;&lt;/a&gt; 적이없는 준비된 명령문 하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36a652edafe32e1a6a69623202e497c2b84971e5" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table is a read-only table that can be directly queried to access information about all prepared statements on the current database connection. For example:</source>
          <target state="translated">SQLITE_STMT 가상 테이블은 현재 데이터베이스 연결에서 준비된 모든 명령문에 대한 정보에 액세스하기 위해 직접 조회 할 수있는 읽기 전용 테이블입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c57e4bb46f13bf2108682321d36a64fbe9c7f037" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMTJRNL_SPILL compile-time option determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; start-time setting. That setting determines the size threshold above which &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journals&lt;/a&gt; are moved from memory to disk.</source>
          <target state="translated">SQLITE_STMTJRNL_SPILL 컴파일 타임 옵션은 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; 시작 시간 설정 의 기본 설정을 결정 합니다. 이 설정 은 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 이 메모리에서 디스크로 이동 되는 크기 임계 값을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="53aa1b2835c1a75b5cdfb5b24f66527df47e52af" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPE 플래그는 함수가 &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype ()을&lt;/a&gt; 호출 할 수 있음을 SQLite에 나타냅니다. 을 하여 인수의 하위 유형을 검사 . 이 플래그를 지정하면 스칼라 또는 집계 사용자 함수에 차이가 없습니다. 그러나 사용자 정의 창 함수에 대해 지정되지 않은 경우, 창 함수가 호출되기 전에 창 함수에 전달 된 인수에 속하는 하위 유형이 삭제 될 수 있습니다 (즉, sqlite3_value_subtype ()은 항상 0을 리턴 함).</target>
        </trans-unit>
        <trans-unit id="a9bfb18749058a748b6ef8d70f30272423e2e061" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPE 플래그는 함수가 &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; 을 호출 하여 인수의 하위 유형을 검사 할 수 있음을 SQLite에 나타냅니다 . 이 플래그를 지정하면 스칼라 또는 집계 사용자 함수에 차이가 없습니다. 그러나 사용자 정의 창 함수에 대해 지정되지 않은 경우, 창 함수가 호출되기 전에 창 함수에 전달 된 인수에 속하는 하위 유형이 삭제 될 수 있습니다 (즉, sqlite3_value_subtype ()은 항상 0을 리턴 함).</target>
        </trans-unit>
        <trans-unit id="eebb912b265a126853dad1960970bce68414c982" translate="yes" xml:space="preserve">
          <source>The SQLITE_TMPDIR environment variable</source>
          <target state="translated">SQLITE_TMPDIR 환경 변수</target>
        </trans-unit>
        <trans-unit id="c73fb526ebe5bd57bd3e299a92027075f6d77195" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; or at run-time using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,...).</source>
          <target state="translated">대형 SQL 문이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 인터페이스 중 하나로 전달 될 때 SQLITE_TOOBIG 오류 코드가 발생할 수도 있습니다 . SQL 문의 최대 길이는 기본적으로 1,000,000 바이트보다 훨씬 작은 값입니다. &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH를&lt;/a&gt; 사용하여 컴파일시 또는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH를&lt;/a&gt; 사용하여 런타임 시)에 최대 SQL 문 길이를 설정할 수 있습니다. 등을 .</target>
        </trans-unit>
        <trans-unit id="95a063038fc4fca17964bc0777d759cfc88b33bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; compile-time option, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.</source>
          <target state="translated">SQLITE_TOOBIG 오류 코드는 문자열 또는 BLOB가 너무 큼을 나타냅니다. SQLite에서 문자열 또는 BLOB의 기본 최대 길이는 1,000,000,000 바이트입니다. 이 최대 길이는 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 컴파일 타임 옵션을 사용하여 컴파일 타임에 또는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH를&lt;/a&gt; 사용하여 런타임 에 변경할 수 있음) , ...) 인터페이스를 . SQLite에서 컴파일 타임 또는 런타임 제한을 초과하는 문자열 또는 BLOB가 발생하면 SQLITE_TOOBIG 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b22248b709740e89a9f8d423ea84335819e1ee2a" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual and possibly ill-advised operation is taking place.</source>
          <target state="translated">C / C ++ 인터페이스는 SQLITE_WARNING 결과 코드를 리턴하지 않습니다. 그러나 SQLITE_WARNING (또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 중 하나 )은 때때로 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 콜백 의 첫 번째 인수로 사용되어 비정상적이고 어쩌면 조언이 필요한 작업이 수행되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bd54655a92d09c02b918de6e8114904fcbbd22b3" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; whenever &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; is used. This can serve as a warning to application designers that the database might benefit from additional indexes.</source>
          <target state="translated">SQLITE_WARNING_AUTOINDEX 결과 코드는 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인 작성&lt;/a&gt; 이 사용될 때마다 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 의 콜백으로 전달 됩니다. 이는 데이터베이스가 추가 인덱스의 이점을 얻을 수 있다는 것을 응용 프로그램 디자이너에게 경고하는 역할을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76259d82167d5f943a68fb0352bace5b64fab37" translate="yes" xml:space="preserve">
          <source>The SQLite Amalgamation</source>
          <target state="translated">SQLite 합병</target>
        </trans-unit>
        <trans-unit id="e5e12b48e05726457e7db136c89d439a466ab852" translate="yes" xml:space="preserve">
          <source>The SQLite Archive is a relatively new format. It was first described in in 2014. ZIP Archives and Tarballs, on the other hand, have been around for decades and are well-entrenched as standard formats. Most programmers know what a ZIP Archive or Tarball is, but if you say &quot;SQLite Archive&quot; you are more likely to get a reply of &quot;What?&quot; Tooling to process ZIP Archives and Tarballs is more likely to be installed on stock computers.</source>
          <target state="translated">SQLite Archive는 비교적 새로운 형식입니다. 반면에 ZIP Archives 및 Tarballs는 수십 년 동안 사용되어 왔으며 표준 형식으로 잘 정돈되어 있습니다. 대부분의 프로그래머는 ZIP 아카이브 또는 Tarball이 무엇인지 알고 있지만 &quot;SQLite Archive&quot;라고 말하면 &quot;What?&quot;라는 답변을받을 가능성이 높습니다. ZIP 보관 파일 및 타르볼을 처리하는 툴은 재고 컴퓨터에 설치 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="14b38e43f93cb1f6666b258c1070654e3f60d3ab" translate="yes" xml:space="preserve">
          <source>The SQLite Bytecode Engine</source>
          <target state="translated">SQLite 바이트 코드 엔진</target>
        </trans-unit>
        <trans-unit id="60d2d0a8c73ed165c49cdebcf186c3bd62509aba" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &quot;VFS&quot;</source>
          <target state="translated">SQLite OS 인터페이스 또는 &quot;VFS&quot;</target>
        </trans-unit>
        <trans-unit id="67edc3d607c153611c830c05dc44105c120df169" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &amp;quot;VFS&amp;quot;</source>
          <target state="translated">SQLite OS 인터페이스 또는 &quot;VFS&quot;</target>
        </trans-unit>
        <trans-unit id="eb768474c2c960b1f80b5ec4636fc5c556432ed7" translate="yes" xml:space="preserve">
          <source>The SQLite Query Optimizer Overview</source>
          <target state="translated">SQLite 쿼리 최적화 프로그램 개요</target>
        </trans-unit>
        <trans-unit id="656be9ece72b3b3c8af07774a0a4473889d5a0ca" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree Module</source>
          <target state="translated">SQLite R * Tree 모듈</target>
        </trans-unit>
        <trans-unit id="f7f3e9d21d121d5b3e8db61ea6e7dde70d17b4dd" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree module is implemented as a &lt;a href=&quot;c3ref/create_module&quot;&gt;virtual table&lt;/a&gt;. Each R*Tree index is a virtual table with an odd number of columns between 3 and 11. The first column is always a 64-bit signed integer primary key. The other columns are pairs, one pair per dimension, containing the minimum and maximum values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A 4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.</source>
          <target state="translated">SQLite R * Tree 모듈은 &lt;a href=&quot;c3ref/create_module&quot;&gt;가상 테이블&lt;/a&gt; 로 구현됩니다. . 각 R * Tree 인덱스는 홀수 개의 열이 3에서 11 사이 인 가상 테이블입니다. 첫 번째 열은 항상 64 비트 부호있는 정수 기본 키입니다. 다른 열은 해당 차원의 최소값과 최대 값을 각각 포함하는 한 쌍의 차원 당 한 쌍입니다. 따라서 1 차원 R * Tree에는 3 개의 열이 있습니다. 2 차원 R * Tree에는 5 개의 열이 있습니다. 3 차원 R * Tree에는 7 개의 열이 있습니다. 4 차원 R * Tree에는 9 개의 열이 있습니다. 5 차원 R * Tree에는 11 개의 열이 있습니다. SQLite R * Tree 구현은 5 차원보다 넓은 R * Tree를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d26287506df7d739659f92d570a45374e9d6b203" translate="yes" xml:space="preserve">
          <source>The SQLite Zipfile Module</source>
          <target state="translated">SQLite Zip 파일 모듈</target>
        </trans-unit>
        <trans-unit id="2a322992d7eadef1cbb665cdba826abcbe8d4bc9" translate="yes" xml:space="preserve">
          <source>The SQLite approach of storing the schema as text has advantages for an embedded relational database. For one, it means that the schema takes up less space in the database file. This is important since a common SQLite usage pattern is to have many small, separate database files instead of putting everything in one big global database file, which is the usual approach for client/server database engines. Since the schema is duplicated in each separate database file, it is important to keep the schema representation compact.</source>
          <target state="translated">스키마를 텍스트로 저장하는 SQLite 접근 방식은 임베디드 관계형 데이터베이스에 이점이 있습니다. 하나는 스키마가 데이터베이스 파일에서 더 적은 공간을 차지한다는 것을 의미합니다. 일반적인 SQLite 사용 패턴은 모든 것을 하나의 큰 글로벌 데이터베이스 파일에 저장하는 대신 작은 개별 데이터베이스 파일을 여러 개 갖는 것이 중요하므로 클라이언트 / 서버 데이터베이스 엔진에 대한 일반적인 접근 방식입니다. 스키마는 각각의 개별 데이터베이스 파일에 복제되므로 스키마 표현을 간결하게 유지하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4156bb8a5bb8b9775d5b39350cba56f0d4323350" translate="yes" xml:space="preserve">
          <source>The SQLite code is broken up into multiple repositories, each described in a separate section below.</source>
          <target state="translated">SQLite 코드는 여러 저장소로 나뉘며 각각 아래 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c10f7a2161303f10be1e978ecf9c20c8b5ff8a" translate="yes" xml:space="preserve">
          <source>The SQLite community has been a kind, welcoming and well-mannered community since its inception nearly two decades ago. In that time many of the qualities we've worked hard to bring to our project - safety, consistency, usability and integrity among them - have become part of our community's culture as well. Much like the care and effort we've put into securing the longevity of SQLite, we'd like to do the same for that community by clarifying our goals and expectations for all involved. To that end the SQLite project has officially adopted the &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participation Guidelines&lt;/a&gt; as its Code of Conduct with the exception that the reporting email address is changed to &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt;. While we are not doing so in reaction to any current or ongoing issues, we believe that this will be a helpful part of maintaining the long-term sustainability of the project.</source>
          <target state="translated">SQLite 커뮤니티는 거의 20 년 전에 시작된 이래 친절하고 친근하고 잘 관리 된 커뮤니티였습니다. 그 당시 우리는 안전, 일관성, 유용성 및 무결성과 같은 프로젝트에 가져 오기 위해 많은 노력을 기울여 커뮤니티 문화의 일부가되었습니다. SQLite의 수명을 연장하기 위해 노력한 노력과 마찬가지로, 관련된 모든 사람들의 목표와 기대를 명확하게하여 해당 커뮤니티에 대해서도 같은 일을하고 싶습니다. 이를 위해 SQLite 프로젝트는 보고 이메일 주소가 &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt; 로 변경되는 것을 제외 하고는 &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla 커뮤니티 참여 지침&lt;/a&gt; 을 공식적 으로 행동 강령 으로 채택했습니다.. 현재 또는 진행중인 문제에 대한 대응으로 그렇게하지는 않지만, 이것이 프로젝트의 장기 지속 가능성을 유지하는 데 도움이 될 것이라고 믿습니다.</target>
        </trans-unit>
        <trans-unit id="6e54c3c7cfbe74cbcff4d32cf11ceb85c2d59225" translate="yes" xml:space="preserve">
          <source>The SQLite core and its memory allocation subsystem provides the following capabilities:</source>
          <target state="translated">SQLite 코어 및 해당 메모리 할당 하위 시스템은 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a8db7c1ed47d07dc8525eeb4fe9e3c2cadccf8a" translate="yes" xml:space="preserve">
          <source>The SQLite core calls the xBestIndex method when it is compiling a query that involves a virtual table. In other words, SQLite calls this method when it is running &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or the equivalent. By calling this method, the SQLite core is saying to the virtual table that it needs to access some subset of the rows in the virtual table and it wants to know the most efficient way to do that access. The xBestIndex method replies with information that the SQLite core can then use to conduct an efficient search of the virtual table.</source>
          <target state="translated">SQLite 코어는 가상 테이블과 관련된 쿼리를 컴파일 할 때 xBestIndex 메서드를 호출합니다. 즉, SQLite는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 이와 동등한 것을 실행할 때이 메소드를 호출합니다 . 이 메소드를 호출함으로써 SQLite 코어는 가상 테이블에 가상 테이블의 행의 일부 하위 집합에 액세스해야하며 해당 액세스를 수행하는 가장 효율적인 방법을 알고 싶다고 말합니다. xBestIndex 메소드는 SQLite 코어가 가상 테이블을 효율적으로 검색하는 데 사용할 수있는 정보로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="0101337cc0cb6fad83f4b1e21e8fd59c6d10699a" translate="yes" xml:space="preserve">
          <source>The SQLite core communicates with the xBestIndex method by filling in certain fields of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure and passing a pointer to that structure into xBestIndex as the second parameter. The xBestIndex method fills out other fields of this structure which forms the reply. The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure looks like this:</source>
          <target state="translated">SQLite 코어는 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 특정 필드를 채우고 두 번째 매개 변수로 xBestIndex에 해당 구조에 대한 포인터를 전달 하여 xBestIndex 메소드와 통신합니다 . xBestIndex 메소드는 응답을 구성하는이 구조의 다른 필드를 채 웁니다. &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 이 같은 구조 외모 :</target>
        </trans-unit>
        <trans-unit id="d592f9a3c73be507b58cc4d8ef9e1e11527c40f2" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5665 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLite 코어에는 함수 전제 조건과 사후 조건을 확인하고 불변을 반복하는 5665 &lt;code&gt;assert()&lt;/code&gt; 문이 포함되어 있습니다 . Assert ()는 ANSI-C의 표준 부분 인 매크로입니다. 인수는 항상 참인 것으로 가정되는 부울 값입니다. 어설 션이 false이면 프로그램이 오류 메시지를 인쇄하고 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="7a7923d469bddb357e4bafd2e77a5357a3ce8703" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5855 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLite 코어에는 함수 전제 조건과 사후 조건 및 루프 불변을 확인하는 5855 &lt;code&gt;assert()&lt;/code&gt; 문이 포함되어 있습니다 . Assert ()는 ANSI-C의 표준 부분 인 매크로입니다. 인수는 항상 참이라고 가정하는 부울 값입니다. 어설 션이 거짓이면 프로그램은 오류 메시지를 인쇄하고 중지합니다.</target>
        </trans-unit>
        <trans-unit id="8a046e08f75eaccd925ae647cf15c7aa3a8226b9" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; to the VFS in place of a call to xSync if the database has &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF.</source>
          <target state="translated">데이터베이스에 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되어 있으면 xite에 대한 호출 대신 SQLite 코어가 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 를 VFS에 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9454a146cdf6bd63746f75afc554dedcf8a89f3d" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes this method in order to find the value for the N-th column of the current row. N is zero-based so the first column is numbered 0. The xColumn method may return its result back to SQLite using one of the following interface:</source>
          <target state="translated">SQLite 코어는 현재 행의 N 번째 열에 대한 값을 찾기 위해이 메소드를 호출합니다. N은 0부터 시작하므로 첫 번째 열의 번호는 0입니다. xColumn 메소드는 다음 인터페이스 중 하나를 사용하여 결과를 SQLite로 다시 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81909f2a4a51a96b134a34a4888c44983e2d76d3" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these routines for thread synchronization. Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.</source>
          <target state="translated">SQLite 코어는 이러한 루틴을 스레드 동기화에 사용합니다. 그것들은 SQLite에 의해 내부 용으로 만들어졌지만 SQLite와 링크되는 코드는 이러한 루틴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922f1172309b4b736f1e305e3916cca7c4256be1" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite 코어는 자체 내부 메모리 할당 요구 사항에 대해이 세 가지 루틴을 사용합니다. 앞 문장의 &quot;Core&quot;에는 운영 체제 별 &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; 구현이 포함되지 않습니다 . Windows VFS는 일부 작업에 기본 malloc () 및 free ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9334c44f83a523ef26ab7a77c74c4218d746143" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite 코어는 자체 내부 메모리 할당 요구 사항에 대해이 세 가지 루틴을 사용합니다. 앞 문장의 &quot;Core&quot;에는 운영 체제 별 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현이 포함되지 않습니다 . Windows VFS는 일부 작업에 기본 malloc () 및 free ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c22d82769d3da3cfaaf7c30bf60dfe3d4e431d6a" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific VFS implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLite 코어는이 세 가지 루틴을 자체 내부 메모리 할당 요구에 모두 사용합니다. 이전 문장의 &quot;Core&quot;에는 운영 체제 별 VFS 구현이 포함되어 있지 않습니다. Windows VFS는 일부 작업에 기본 malloc () 및 free ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="310e86b319144a9b8ab497d9dda0fd59a92fa402" translate="yes" xml:space="preserve">
          <source>The SQLite core will call &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; early. The auxiliary C code file can contain an implementation of sqlite3_initialize() that registers an appropriate VFS and also perhaps initializes an alternative mutex system (if mutexes are required) or does any memory allocation subsystem initialization that is required. The SQLite core never calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; but it is part of the official SQLite API and is not otherwise provided when compiled with -DSQLITE_OS_OTHER=1, so the auxiliary C code file should probably provide it for completeness.</source>
          <target state="translated">SQLite 코어는 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()를&lt;/a&gt; 일찍 호출 합니다. 보조 C 코드 파일에는 적절한 VFS를 등록하고 대체 뮤텍스 시스템을 초기화하거나 (뮤텍스가 필요한 경우) 필요한 메모리 할당 하위 시스템 초기화를 수행하는 sqlite3_initialize () 구현이 포함될 수 있습니다. SQLite 코어는 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()을&lt;/a&gt; 호출하지 않지만 공식 SQLite API의 일부이며 -DSQLITE_OS_OTHER = 1로 컴파일 할 때 제공되지 않으므로 보조 C 코드 파일이이를 완전성으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3389235261ef05c3ad08031ba3272b1839ea345" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="translated">유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS를&lt;/a&gt; 포함한 SQLite 코어 는 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 에서 100 % 분기 테스트 범위를 갖습니다.&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt; gcov&lt;/a&gt; 로 측정 한 기본 구성 에 . FTS3 및 RTree와 같은 확장은이 분석에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="25f0f08e26b5d1ff28a9d0772acbc6ec5d4dc8bf" translate="yes" xml:space="preserve">
          <source>The SQLite database allows multiple simultaneous readers or a single writer but not both. If any process is writing to the database no other process is allows to read or write. If any process is reading the database other processes are allowed to read but not write. The entire database shared a single lock.</source>
          <target state="translated">SQLite 데이터베이스는 여러 개의 동시 판독기 또는 단일 기록기를 허용하지만 둘 모두를 허용하지는 않습니다. 프로세스가 데이터베이스에 쓰는 중이면 다른 프로세스가 읽거나 쓸 수 없습니다. 프로세스가 데이터베이스를 읽고있는 경우 다른 프로세스는 읽을 수 있지만 쓸 수는 없습니다. 전체 데이터베이스가 단일 잠금을 공유했습니다.</target>
        </trans-unit>
        <trans-unit id="c9e7754ee2f8ef030d3e0c4851d0ab23e5bf681e" translate="yes" xml:space="preserve">
          <source>The SQLite database file (&quot;self2014.sqlar&quot;) is about a half percent smaller than the equivalent ODP file! How can this be? Apparently the ZIP archive generator logic in NeoOffice is not as efficient as it could be, because when the same pile-of-files is recompressed using the command-line &quot;zip&quot; utility, one gets a file (&quot;zip.odp&quot;) that is smaller still, by another half percent, as seen in the third line above. So, a well-written ZIP archive can be slightly smaller than the equivalent SQLite database, as one would expect. But the difference is slight. The key take-away is that an SQLite database is size-competitive with a ZIP archive.</source>
          <target state="translated">SQLite 데이터베이스 파일 ( &quot;self2014.sqlar&quot;)은 동등한 ODP 파일보다 약 0.5 % 작습니다! 어떻게 이럴 수있어? 명령 줄 &quot;zip&quot;유틸리티를 사용하여 동일한 파일 파일을 다시 압축하면 파일 ( &quot;zip.odp&quot;)을 가져 오기 때문에 NeoOffice의 ZIP 아카이브 생성기 논리는 그다지 효율적이지 않습니다. 위의 세 번째 줄에서 볼 수 있듯이 여전히 절반이 더 작습니다. 따라서 잘 작성된 ZIP 아카이브는 예상대로 동등한 SQLite 데이터베이스보다 약간 작을 수 있습니다. 그러나 그 차이는 미미합니다. 주요 테이크 아웃은 SQLite 데이터베이스가 ZIP 아카이브와 크기 경쟁력이 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="20b6f43ea15deb4c44a24b00c6944cb60a4b8d86" translate="yes" xml:space="preserve">
          <source>The SQLite database file format is also stable. All releases of SQLite version 3 can read and write database files created by the very first SQLite 3 release (version 3.0.0) going back to 2004-06-18. This is &quot;backwards compatibility&quot;. The developers promise to maintain backwards compatibility of the database file format for all future releases of SQLite 3. &quot;Forwards compatibility&quot; means that older releases of SQLite can also read and write databases created by newer releases. SQLite is usually, but not completely forwards compatible.</source>
          <target state="translated">SQLite 데이터베이스 파일 형식도 안정적입니다. SQLite 버전 3의 모든 릴리스는 2004-06-18로 돌아가는 최초의 SQLite 3 릴리스 (버전 3.0.0)에서 작성된 데이터베이스 파일을 읽고 쓸 수 있습니다. 이것은 &quot;이전 버전과의 호환성&quot;입니다. 개발자는 이후의 모든 SQLite 3 릴리스에 대해 데이터베이스 파일 형식의 이전 버전과의 호환성을 유지할 것을 약속합니다. &quot;순방향 호환성&quot;은 이전 버전의 SQLite도 최신 릴리스로 작성된 데이터베이스를 읽고 쓸 수 있음을 의미합니다. SQLite는 일반적으로 완전히 호환되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b9e7e4e72268ed8ff0aecd3bce3fa20aed32bae" translate="yes" xml:space="preserve">
          <source>The SQLite developers do not write CVEs. Any CVEs you find on SQLite are generated by third-parties, often without any input from the core developers. A common scenario is that someone will report a bug in SQLite, which will promptly be fixed, then weeks later a CVE for that bug will appear, unbeknownst to the developers.</source>
          <target state="translated">SQLite 개발자는 CVE를 작성하지 않습니다. SQLite에서 찾은 모든 CVE는 종종 핵심 개발자의 입력없이 타사에 의해 생성됩니다. 일반적인 시나리오는 누군가 SQLite에서 버그를보고하여 즉시 수정되고 몇 주 후에 개발자에게 알려지지 않은 상태로 해당 버그에 대한 CVE가 나타나는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9896b9f0acf4d53bbeb650db03c052b65e4b39c" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="translated">SQLite 개발자는 온라인 체크리스트를 사용하여 테스트 활동을 조정하고 모든 테스트가 각 SQLite 릴리스 이전에 통과하는지 확인합니다. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;과거 체크리스트&lt;/a&gt; 는 기록 참조 용으로 유지됩니다. 검사 목록은 익명의 인터넷 사용자에게는 읽기 전용이지만 개발자는 웹 브라우저에서 로그인하고 검사 목록 항목을 업데이트 할 수 있습니다. SQLite 테스트 및 기타 개발 활동을위한 검사 목록 사용은 영감을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="9c957f8bdf8ce50dc09723537398c60a4991b0ad" translate="yes" xml:space="preserve">
          <source>The SQLite development team fixes bugs promptly, usually within hours of discovery. New releases of SQLite are issued if the bug seems likely to impact real-world applications.</source>
          <target state="translated">SQLite 개발 팀은 일반적으로 발견 후 몇 시간 내에 즉시 버그를 수정합니다. 버그가 실제 응용 프로그램에 영향을 미칠 가능성이있는 경우 SQLite의 새 릴리스가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="4f35e69a2395e538db8157dc3dbb68d5b6f19b6e" translate="yes" xml:space="preserve">
          <source>The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and backwards compatible, so newer versions of SQLite can read and write older database files.</source>
          <target state="translated">SQLite 파일 형식은 크로스 플랫폼입니다. 한 머신에서 작성된 데이터베이스 파일은 다른 아키텍처의 다른 머신으로 복사하여 사용할 수 있습니다. 빅 엔디안 또는 리틀 엔디안, 32 비트 또는 64 비트는 중요하지 않습니다. 모든 머신은 동일한 파일 형식을 사용합니다. 또한 개발자는 파일 형식을 안정적으로 지원하고 이전 버전과의 호환성을 유지하기 위해 최신 버전의 SQLite는 오래된 데이터베이스 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a470f0b14147aeef040dd5381d7be5b2946cd2d3" translate="yes" xml:space="preserve">
          <source>The SQLite interface elements can be grouped into three categories:</source>
          <target state="translated">SQLite 인터페이스 요소는 세 가지 범주로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2127d3816b52817dc6b4ce63d16e29894ba0878" translate="yes" xml:space="preserve">
          <source>The SQLite library consists of 102 files of C code (as of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;Version 3.9.0&lt;/a&gt; - 2015-10-14) in the core with 32 additional files that implement the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. Of the 102 main source files, about 75% are C code and about 25% are C header files. Most of these are &quot;source&quot; files in the sense that they are stored in the &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite version control system&lt;/a&gt; and are edited manually in an ordinary text editor. But some of the C-language files are generated using scripts or auxiliary programs. For example, the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt; file contains an LALR(1) grammar of the SQL language which is compiled down into are parser in files &quot;parse.c&quot; and &quot;parse.h&quot; by the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;.</source>
          <target state="translated">SQLite 라이브러리는 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; , &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; , &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt; , &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt; 및 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장 을 구현하는 32 개의 추가 파일과 함께 코어 에 102 개의 C 코드 파일 ( &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 &lt;/a&gt;3.9.0-2015-10-14 기준 )로 구성 됩니다. 102 개의 주요 소스 파일 중 약 75 %는 C 코드이고 약 25 %는 C 헤더 파일입니다. 이들 대부분은 &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite 버전 관리 시스템에&lt;/a&gt; 저장되고 일반 텍스트 편집기에서 수동으로 편집 된다는 점에서 &quot;소스&quot;파일입니다 . 그러나 일부 C 언어 파일은 스크립트 또는 보조 프로그램을 사용하여 생성됩니다. 예를 들어, &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt;파일에는 &lt;a href=&quot;lemon&quot;&gt;레몬 구문 분석기 생성기&lt;/a&gt; &quot;parse.c&quot;및 &quot;parse.h&quot;파일의 구문 분석기로 컴파일 된 SQL 언어의 LALR (1) 문법이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fdfec2d5c500b7ac74b77876e6dfdaa2cdecb05" translate="yes" xml:space="preserve">
          <source>The SQLite library exports the string constant named &lt;b&gt;sqlite_version&lt;/b&gt; which contains the version number of the library. The header file contains a macro SQLITE_VERSION with the same information. If desired, a program can compare the SQLITE_VERSION macro against the &lt;b&gt;sqlite_version&lt;/b&gt; string constant to verify that the version number of the header file and the library match.</source>
          <target state="translated">SQLite 라이브러리는 라이브러리 의 버전 번호를 포함하는 &lt;b&gt;sqlite_version&lt;/b&gt; 이라는 문자열 상수를 내 보냅니다 . 헤더 파일에는 동일한 정보를 가진 매크로 SQLITE_VERSION이 포함되어 있습니다. 원하는 경우 프로그램은 SQLITE_VERSION 매크로를 &lt;b&gt;sqlite_version&lt;/b&gt; 문자열 상수 와 비교 하여 헤더 파일의 버전 번호와 라이브러리가 일치하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f89e1941b8b597af45ed78a7c716ad9e7232f89" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl or Tcl/Tk&lt;/a&gt; script. SQLite began as a &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl extension&lt;/a&gt; and the primary &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt; for SQLite is written in TCL. SQLite can be used with any programming language, but its connections to TCL run deep.</source>
          <target state="translated">SQLite 라이브러리는 &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl 또는 Tcl / Tk&lt;/a&gt; 스크립트 에서 사용하기 매우 쉽게 설계되었습니다 . SQLite는 &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl 확장&lt;/a&gt; 으로 시작했으며 SQLite 의 기본 &lt;a href=&quot;testing&quot;&gt;테스트 스위트&lt;/a&gt; 는 TCL로 작성되었습니다. SQLite는 모든 프로그래밍 언어와 함께 사용할 수 있지만 TCL에 대한 연결은 심도있게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e8965a9252a8aca8a477026acb0a17bd84805b" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a C or C++ program. This document gives an overview of the C/C++ programming interface.</source>
          <target state="translated">SQLite 라이브러리는 C 또는 C ++ 프로그램에서 사용하기 매우 쉽게 설계되었습니다. 이 문서는 C / C ++ 프로그래밍 인터페이스에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0602c28d1654d00a16d8fb7d7632cbb5225eb5e8" translate="yes" xml:space="preserve">
          <source>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</source>
          <target state="translated">SQLite 라이브러리는 운영 체제 페이지 캐시와 페이지를 공유하고 자체 작업 페이지 사본이 항상 필요한 것은 아니므로 RAM이 더 적게 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68ac5f0b4be242c75b75b113e85779b0d2d24fb" translate="yes" xml:space="preserve">
          <source>The SQLite library supplies the VDBE with a pointer to the callback function and the &lt;b&gt;pUserData&lt;/b&gt; pointer. (Both the callback and the user data were originally passed in as arguments to the &lt;b&gt;sqlite_exec()&lt;/b&gt; API function.) The job of the VDBE is to come up with values for &lt;b&gt;nColumn&lt;/b&gt;, &lt;b&gt;azData[]&lt;/b&gt;, and &lt;b&gt;azColumnName[]&lt;/b&gt;. &lt;b&gt;nColumn&lt;/b&gt; is the number of columns in the results, of course. &lt;b&gt;azColumnName[]&lt;/b&gt; is an array of strings where each string is the name of one of the result columns. &lt;b&gt;azData[]&lt;/b&gt; is an array of strings holding the actual data.</source>
          <target state="translated">SQLite 라이브러리는 VDBE에 콜백 함수에 대한 포인터 와 &lt;b&gt;pUserData&lt;/b&gt; 포인터를 제공합니다. 콜백과 사용자 데이터는 원래 &lt;b&gt;sqlite_exec ()&lt;/b&gt; API 함수에 인수로 전달되었습니다. &lt;b&gt;VDBE&lt;/b&gt; 의 작업은 &lt;b&gt;nColumn&lt;/b&gt; , &lt;b&gt;azData []&lt;/b&gt; 및 &lt;b&gt;azColumnName []의&lt;/b&gt; 값을 제공하는 것입니다 . &lt;b&gt;nColumn&lt;/b&gt; 은 물론 결과의 열 수입니다. &lt;b&gt;azColumnName []&lt;/b&gt; 은 각 문자열이 결과 열 중 하나의 이름 인 문자열 배열입니다. &lt;b&gt;azData []&lt;/b&gt; 는 실제 데이터를 보유하는 문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="bec59993baf9ef121d8c6051be0842d34bbcc286" translate="yes" xml:space="preserve">
          <source>The SQLite library was compiled with &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI=1&lt;/a&gt;.</source>
          <target state="translated">SQLite 라이브러리는 &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI = 1&lt;/a&gt; 로 컴파일되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e9d0a1ae4dbbafaabd699c25677e883038d9a262" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database or against a &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLite 프로젝트는 사용자가 SQLite 데이터베이스 또는 &lt;a href=&quot;#zipdb&quot;&gt;ZIP 아카이브&lt;/a&gt; 에 대해 SQL 문을 수동으로 입력하고 실행할 수 있도록하는 &lt;b&gt;sqlite3&lt;/b&gt; (또는 Windows의 경우 &lt;b&gt;sqlite3.exe)&lt;/b&gt; 라는 간단한 명령 줄 프로그램을 제공합니다 . 이 문서는 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램 을 사용하는 방법에 대한 간략한 소개를 제공합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3d928b1fc0f8261eeda1295ec9247d5985e38f7" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLite 프로젝트는 사용자가 SQLite 데이터베이스에 대해 SQL 문을 수동으로 입력하고 실행할 수있는 &lt;b&gt;sqlite3&lt;/b&gt; (또는 Windows의 경우 &lt;b&gt;sqlite3.exe)&lt;/b&gt; 이라는 간단한 명령 줄 프로그램을 제공 합니다. 이 문서는 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램 사용법에 대한 간략한 소개를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c372f90b5ac62e99b6357128106b66701a0411a3" translate="yes" xml:space="preserve">
          <source>The SQLite query planner will consider using an index on an expression when the expression that is indexed appears in the WHERE clause or in the ORDER BY clause of a query,</source>
          <target state="translated">SQLite 쿼리 플래너는 인덱싱 된식이 쿼리의 WHERE 절 또는 ORDER BY 절에 나타날 때 식에서 인덱스 사용을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="6dfbc1d18bbce16026bdcc86a5bffbbe6b1beb8b" translate="yes" xml:space="preserve">
          <source>The SQLite source code and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; are stored together in a single repository. This one repository is all that is required to build the SQLite. The source repository is public and is readable by anonymous passers by on the internet.</source>
          <target state="translated">SQLite 소스 코드와 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트&lt;/a&gt; 는 단일 저장소에 함께 저장됩니다. 이 하나의 저장소는 SQLite를 빌드하는 데 필요한 전부입니다. 소스 리포지토리는 공용이며 인터넷을 통해 익명의 발신자가 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038ea963840df99a058067d40caa3b0cbd33dedb" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 1084 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLite 소스 코드에는 1084 개의 &lt;code&gt;testcase()&lt;/code&gt; 매크로 사용이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1097f713df32cd3a870e17f648d7622d77d22cd2" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 992 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLite 소스 코드에는 &lt;code&gt;testcase()&lt;/code&gt; 매크로 가 992 개 사용되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="200e89ebce3af8e9c7c026a8d18cac87a1da0318" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains literally thousands of assert() statements used to verify internal assumptions and subroutine preconditions and postconditions. These assert() statements are normally turned off (they generate no code) since turning them on makes SQLite run approximately three times slower. But for testing and analysis, it is useful to turn the assert() statements on. The SQLITE_DEBUG compile-time option does this.</source>
          <target state="translated">SQLite 소스 코드에는 내부 가정과 서브 루틴 전제 조건 및 사후 조건을 확인하는 데 사용되는 수천 개의 assert () 문이 포함되어 있습니다. 이 assert () 문은 일반적으로 해제되어 있으며 (코드를 생성하지 않음) SQLite를 실행하면 SQLite가 약 3 배 느리게 실행되기 때문입니다. 그러나 테스트 및 분석의 경우 assert () 문을 켜는 것이 유용합니다. SQLITE_DEBUG 컴파일 타임 옵션이이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7203161cfe6b6f33980e05611daeaed418ec5ae9" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains multiple implementations of these mutex routines. An appropriate implementation is selected automatically at compile-time. The following implementations are available in the SQLite core:</source>
          <target state="translated">SQLite 소스 코드에는 이러한 뮤텍스 루틴의 여러 구현이 포함되어 있습니다. 컴파일시 적절한 구현이 자동으로 선택됩니다. SQLite 코어에서 다음 구현을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="519e11bf2b879a67e8b0e9134459d439da57e623" translate="yes" xml:space="preserve">
          <source>The SQLite source code includes several different memory allocation modules that can be selected at compile-time, or to a limited extent at start-time.</source>
          <target state="translated">SQLite 소스 코드에는 컴파일 타임 또는 시작 시간에 제한적으로 선택할 수있는 여러 가지 메모리 할당 모듈이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b459704fa1dc2f133cc1300473552a0909311a3d" translate="yes" xml:space="preserve">
          <source>The SQLite source code provides multiple implementations of these APIs, suitable for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag then a no-op mutex implementation that is fast but does no real mutual exclusion is provided. That implementation is suitable for use in single-threaded applications or applications that only use SQLite in a single thread. Other real mutex implementations are provided based on the underlying operating system.</source>
          <target state="translated">SQLite 소스 코드는 다양한 환경에 적합한 이러한 API의 다중 구현을 제공합니다. SQLite가 SQLITE_THREADSAFE = 0 플래그를 사용하여 컴파일 된 경우 빠르지 만 실제 상호 배제는없는 뮤텍스 구현이 제공되지 않습니다. 이 구현은 단일 스레드 응용 프로그램이나 단일 스레드에서만 SQLite를 사용하는 응용 프로그램에 사용하기에 적합합니다. 다른 실제 뮤텍스 구현은 기본 운영 체제를 기반으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4146cdfa0001cfa5a66203144506da17c3646968" translate="yes" xml:space="preserve">
          <source>The SQLite source tree actually contains multiple versions of the memory allocator. The default high-speed version found in the &quot;mem1.c&quot; source file is used for most builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator the &quot;mem2.c&quot; source file is used instead. The mem2.c allocator implements lots of hooks to do error checking and to simulate memory allocation failures for testing purposes. Both of these allocators use the malloc()/free() implementation in the standard C library.</source>
          <target state="translated">SQLite 소스 트리에는 실제로 여러 버전의 메모리 할당자가 있습니다. &quot;mem1.c&quot;소스 파일에있는 기본 고속 버전이 대부분의 빌드에 사용됩니다. 그러나 SQLITE_MEMDEBUG 플래그가 사용 가능한 경우 별도의 메모리 할당 자 &quot;mem2.c&quot;소스 파일이 대신 사용됩니다. mem2.c 할당자는 오류 점검을 수행하고 테스트 목적으로 메모리 할당 실패를 시뮬레이션하기 위해 많은 후크를 구현합니다. 이 두 할당 자 모두 표준 C 라이브러리에서 malloc () / free () 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4ba1f99040a37a507011c1205b1aef886c686eaf" translate="yes" xml:space="preserve">
          <source>The SQLite version identifier returned by the &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt; SQL function and the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C API and found in the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; macro is now a 64-digit SHA3-256 hash instead of a 40-digit SHA1 hash.</source>
          <target state="translated">에 의해 반환 SQLite는 버전 ID &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; SQL 함수 및 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C API 및 검색된 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID의&lt;/a&gt; 매크로 해주기 대신 40 자리 SHA1 해시 64 자리 SHA3-256 해시이다.</target>
        </trans-unit>
        <trans-unit id="0c3d7b8c49e09915f93340abac558621318ffacf" translate="yes" xml:space="preserve">
          <source>The SQLite website (&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;) uses SQLite itself, of course, and as of this writing (2015) it handles about 400K to 500K HTTP requests per day, about 15-20% of which are dynamic pages touching the database. Dynamic content uses &lt;a href=&quot;np1queryprob&quot;&gt;about 200 SQL statements per webpage&lt;/a&gt;. This setup runs on a single VM that shares a physical server with 23 others and yet still keeps the load average below 0.1 most of the time.</source>
          <target state="translated">SQLite 웹 사이트 ( &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; )는 물론 SQLite 자체를 사용 하며이 글을 쓰는 시점 (2015 년)에는 하루 약 400K ~ 500K HTTP 요청을 처리하며 그 중 약 15-20 %는 동적입니다 데이터베이스를 터치하는 페이지. 동적 컨텐츠는 &lt;a href=&quot;np1queryprob&quot;&gt;웹 페이지 당 약 200 개의 SQL 문을&lt;/a&gt; 사용합니다 . 이 설정은 23 개의 다른 서버와 물리적 서버를 공유하는 단일 VM에서 실행되지만 여전히로드 평균을 0.1 미만으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="dc3cc55be8b0168568fc5c682e636d1909810e07" translate="yes" xml:space="preserve">
          <source>The SQLite-specific printf() supports a new flag (!) called the &quot;alternate-form-2&quot; flag. The alternate-form-2 flag changes the processing of floating-point conversions in subtle ways so that the output is always an SQL-compatible text representation of a floating-point number - something that is not possible to achieve with standard-library printf(). For string substitutions, the alternate-form-2 flag causes the width and precision to be measured in characters instead of bytes, which simplifies processing of strings containing multi-byte UTF8 characters.</source>
          <target state="translated">SQLite 관련 printf ()는 &quot;alternate-form-2&quot;플래그라는 새로운 플래그 (!)를 지원합니다. alternate-form-2 플래그는 부동 소수점 변환 처리를 미묘한 방식으로 변경하여 출력이 항상 부동 소수점 숫자의 SQL 호환 텍스트 표현이되도록합니다. 표준 라이브러리 printf ( ). 문자열 대체의 경우 alternate-form-2 플래그는 너비와 정밀도를 바이트 대신 문자로 측정하여 멀티 바이트 UTF8 문자를 포함하는 문자열 처리를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="ab1ef24a2c3d89dbbf816b75c5ebad085546d51d" translate="yes" xml:space="preserve">
          <source>The SUM function detects integer overflow and converts to accumulating an approximate result using floating point numbers</source>
          <target state="translated">SUM 함수는 정수 오버플로를 감지하고 부동 소수점 숫자를 사용하여 대략적인 결과를 누적하도록 변환</target>
        </trans-unit>
        <trans-unit id="9d27464a9b4c0f0bdd924575293003beb50c81e1" translate="yes" xml:space="preserve">
          <source>The SUM() function throws an error on integer overflow.</source>
          <target state="translated">SUM () 함수는 정수 오버플로에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d583a21e8e6e4ba4fbb7f5a178c04bb7372f87c1" translate="yes" xml:space="preserve">
          <source>The Schema Table</source>
          <target state="translated">스키마 테이블</target>
        </trans-unit>
        <trans-unit id="7cc003a9427832539005b297ca058e10476ece22" translate="yes" xml:space="preserve">
          <source>The Session Extension</source>
          <target state="translated">세션 확장</target>
        </trans-unit>
        <trans-unit id="0aa8192c55de05490d2622bfdb109c271f14a02d" translate="yes" xml:space="preserve">
          <source>The Spellfix1 Virtual Table</source>
          <target state="translated">Spellfix1 가상 테이블</target>
        </trans-unit>
        <trans-unit id="7366e749b34cc79e46fd62658a2ec13bee8b7b92" translate="yes" xml:space="preserve">
          <source>The T argument is the name of the target database file. The A argument is the name of the RBU database file. The S argument is the name of a &quot;state database&quot; used to store state information needed to resume the update after an interruption. The S argument can be NULL in which case the state information is stored in the RBU database in various tables whose names all begin with &quot;rbu_&quot;.</source>
          <target state="translated">T 인수는 대상 데이터베이스 파일의 이름입니다. A 인수는 RBU 데이터베이스 파일의 이름입니다. S 인수는 중단 후 업데이트를 재개하는 데 필요한 상태 정보를 저장하는 데 사용되는 &quot;상태 데이터베이스&quot;의 이름입니다. S 인수는 NULL 일 수 있으며,이 경우 상태 정보는 이름이 모두 &quot;rbu_&quot;로 시작하는 다양한 테이블의 RBU 데이터베이스에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d051df5b386db985e4647bccdf4da6546279c0" translate="yes" xml:space="preserve">
          <source>The TCL bindings transfer data without necessarily doing a conversion to a string.</source>
          <target state="translated">TCL 바인딩은 문자열로 변환하지 않아도 데이터를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="65bc381e62f8723019edd6efca853c02189bf80a" translate="yes" xml:space="preserve">
          <source>The TCL interface for SQLite is a small module that is added into the regular amalgamation. The result is a new amalgamated source file called &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot;. This single source file is all that is needed to generate a shared library that can be loaded into a standard &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; or &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish&lt;/a&gt; using the &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load command&lt;/a&gt;, or to generate a standalone tclsh that comes with SQLite built in. A copy of the tcl amalgamation is included on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">SQLite 용 TCL 인터페이스는 일반 통합에 추가되는 작은 모듈입니다. 결과는 &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot; 라는 새로운 통합 소스 파일 입니다. 이 단일 소스 파일은 표준 &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; 로로드 하거나 &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load 명령을&lt;/a&gt; 사용하여 &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;원하는&lt;/a&gt; 공유 라이브러리 를 생성하거나 SQLite가 내장 된 독립형 tclsh 를 생성하는 데 필요한 모든 것입니다. tcl 합병의 사본은 다음과 같습니다. &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball에&lt;/a&gt; 파일로 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9e41f74fbcda169959b0e1c5ad24699dcf79aca" translate="yes" xml:space="preserve">
          <source>The TEMP database file is very similar to auxiliary database files added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement, though with a few special properties. The TEMP database is always automatically deleted when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed. The TEMP database always uses the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous=OFF&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=PERSIST&lt;/a&gt; PRAGMA settings. And, the TEMP database cannot be used with &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; nor can another process &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; the TEMP database.</source>
          <target state="translated">TEMP 데이터베이스 파일은 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문을 사용하여 추가 된 보조 데이터베이스 파일과 매우 유사 하지만 몇 가지 특수 특성이 있습니다. TEMP 데이터베이스는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 닫히면 항상 자동으로 삭제됩니다 . TEMP 데이터베이스는 항상 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous = OFF&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = PERSIST&lt;/a&gt; PRAGMA 설정을 사용합니다. 그리고, TEMP 데이터베이스는 사용할 수 없습니다 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 도 다른 프로세스는 수 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 임시 데이터베이스를.</target>
        </trans-unit>
        <trans-unit id="53f0498bc726c9a2250102fc1ce88dd0e04a9743" translate="yes" xml:space="preserve">
          <source>The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE keyword.</source>
          <target state="translated">TEMP 또는 TEMPORARY 키워드는 초기 CREATE 키워드 이후에 발생하면 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9ade3b04856b7f86ec94b71b3743aaff256ca8" translate="yes" xml:space="preserve">
          <source>The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral and is not expected to survive a power outage. Attempts to change the synchronous setting for TEMP are silently ignored.</source>
          <target state="translated">TEMP의 내용이 일시적이며 정전이 지속될 것으로 예상되지 않으므로 TEMP 스키마는 항상 synchronous = OFF를 갖습니다. TEMP의 동기 설정을 변경하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8090269fd066de5e15019d6f63ecc9dd8e6b9f" translate="yes" xml:space="preserve">
          <source>The TEMP_STORE and DEFAULT_TEMP_STORE pragmas now work.</source>
          <target state="translated">TEMP_STORE 및 DEFAULT_TEMP_STORE pragma가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5dbd6ac1d86267c3b2604d6573027830c458f6aa" translate="yes" xml:space="preserve">
          <source>The TH3 program generator is a TCL script named &quot;&lt;code&gt;mkth3.tcl&lt;/code&gt;&quot;. To generate a test program, one has merely to run this script and supply the names of files containing test modules and configurations on the command line. Test modules are files that use the &quot;&lt;code&gt;.test&lt;/code&gt;&quot; suffix and configurations are files that use the &quot;&lt;code&gt;.cfg&lt;/code&gt;&quot; suffix. A typical invocation of mkth3.tcl might look something like the following:</source>
          <target state="translated">TH3 프로그램 생성기는 &quot; &lt;code&gt;mkth3.tcl&lt;/code&gt; &quot; 이라는 TCL 스크립트 입니다. 테스트 프로그램을 생성하려면이 스크립트를 실행하고 테스트 모듈 및 구성을 포함하는 파일 이름을 명령 줄에 제공하면됩니다. 테스트 모듈은 &quot; &lt;code&gt;.test&lt;/code&gt; &quot;접미사를 사용하는 파일이고 구성은 &quot; &lt;code&gt;.cfg&lt;/code&gt; &quot;접미사 를 사용하는 파일입니다 . mkth3.tcl의 일반적인 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8c8240b8bebcede58e6b71d1007e7276f3ab838" translate="yes" xml:space="preserve">
          <source>The TH3 repository also includes the &quot;multitest.tcl&quot; script, another TCL script used to automate TH3 testing on workstations. Multitest.tcl automatically compiles SQLite, then runs ./th3make repeatedly with a variety of alignments, and captures the output in a succinct summary screen. A typical multitest.tcl run generates output that looks like this:</source>
          <target state="translated">TH3 저장소에는 워크 스테이션에서 TH3 테스트를 자동화하는 데 사용되는 또 다른 TCL 스크립트 인 &quot;multitest.tcl&quot;스크립트도 포함되어 있습니다. Multitest.tcl은 SQLite를 자동으로 컴파일 한 다음 다양한 정렬로 ./th3make를 반복적으로 실행하고 간결한 요약 화면에서 출력을 캡처합니다. 일반적인 multitest.tcl 실행은 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b6f9b2cda115a994b187cb0154afbb957f0c6ad7" translate="yes" xml:space="preserve">
          <source>The TH3 source tree contains a scripted name &quot;mutation-test.tcl&quot; that automates the process of &lt;a href=&quot;testing#mutationtests&quot;&gt;mutation testing&lt;/a&gt;.</source>
          <target state="translated">TH3 소스 트리에는 &lt;a href=&quot;testing#mutationtests&quot;&gt;돌연변이 테스트&lt;/a&gt; 프로세스를 자동화하는 스크립트 이름 &quot;mutation-test.tcl&quot;이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cdfe00d64176fc80b6e066f8b6b12526ed3a13b" translate="yes" xml:space="preserve">
          <source>The TH3 test harness needs to run on embedded systems that do not necessarily have the ability to spawn child processes, so it uses an in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to simulate crashes. The in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be rigged to make a snapshot of the entire filesystem after a set number of I/O operations. Crash tests run in a loop. On each iteration of the loop, the point at which a snapshot is made is advanced until the SQLite operations being tested run to completion without ever hitting a snapshot. Within the loop, after the SQLite operation under test has completed, the filesystem is reverted to the snapshot and random file damage is introduced that is characteristic of the kinds of damage one expects to see following a power loss. Then the database is opened and checks are made to ensure that it is well-formed and that the transaction either ran to completion or was completely rolled back. The interior of the loop is repeated multiple times for each snapshot with different random damage each time.</source>
          <target state="translated">TH3 테스트 하네스는 반드시 하위 프로세스를 생성 할 수있는 내장 시스템에서 실행해야하므로 메모리 내 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 사용하여 충돌을 시뮬레이션합니다. 인 메모리 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;설정된 수의 I / O 작업 후 전체 파일 시스템의 스냅 샷을 생성하도록 조작 할 수 있습니다. 충돌 테스트는 루프에서 실행됩니다. 루프가 반복 될 때마다 스냅 샷을 작성하지 않고 테스트중인 SQLite 조작이 완료 될 때까지 스냅 샷이 작성되는 지점이 진행됩니다. 루프 내에서 테스트중인 SQLite 작업이 완료된 후 파일 시스템이 스냅 샷으로 되돌아 가고 전원 손실 후 발생할 것으로 예상되는 손상 유형의 특성 인 임의의 파일 손상이 발생합니다. 그런 다음 데이터베이스가 열리고 점검이 잘 이루어 졌는지 확인하고 트랜잭션이 완료되었거나 완전히 롤백되었는지 확인합니다. 루프의 내부는 매번 다른 무작위 손상으로 각 스냅 샷에 대해 여러 번 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="17fbf6e9083452ddac2fd083a957049cd4961ff8" translate="yes" xml:space="preserve">
          <source>The TMPDIR environment variable</source>
          <target state="translated">TMPDIR 환경 변수</target>
        </trans-unit>
        <trans-unit id="03b5c9a4012ba043f6ac023992fea614e9559aac" translate="yes" xml:space="preserve">
          <source>The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it. On many systems, truncating a file is much faster than deleting the file since the containing directory does not need to be changed.</source>
          <target state="translated">TRUNCATE 저널링 모드는 롤백 저널을 삭제하지 않고 길이를 0으로 잘라서 트랜잭션을 커미트합니다. 많은 시스템에서 파일을 자르는 것이 포함 디렉토리를 변경할 필요가 없기 때문에 파일을 삭제하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8b6a576f2a0740b1d820bb0b389ef9405211a467" translate="yes" xml:space="preserve">
          <source>The Tcl interface to the SQLite library</source>
          <target state="translated">SQLite 라이브러리에 대한 Tcl 인터페이스</target>
        </trans-unit>
        <trans-unit id="ea435d43ff01f7eaaaed2d71b4ee7a4a7d014eaf" translate="yes" xml:space="preserve">
          <source>The Tcl script language is used to help translate canonical source code into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and to manage testing. Tcl is not used directly by SQLite itself (unless requested by a compile-time option). End users of the SQLite amalgamation sources do not need Tcl.</source>
          <target state="translated">Tcl 스크립트 언어는 표준 소스 코드를 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 으로 변환 하고 테스트를 관리 하는 데 사용됩니다 . Tcl은 컴파일 타임 옵션에 의해 요청되지 않는 한 SQLite 자체에서 직접 사용되지 않습니다. SQLite 합병 소스의 최종 사용자는 Tcl이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ea1be33d0917718998fde5f34057649d7f00dc5" translate="yes" xml:space="preserve">
          <source>The Truncate Optimization</source>
          <target state="translated">자르기 최적화</target>
        </trans-unit>
        <trans-unit id="3d540f11b167e73decc4798633f81039fc8fd06e" translate="yes" xml:space="preserve">
          <source>The UINT Collating Sequence</source>
          <target state="translated">UINT 배열 순서</target>
        </trans-unit>
        <trans-unit id="99f583c0fd53b39d9c80671b9d84a8130da53c96" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence is not a standard part of SQLite. It must be loaded as a separate extension. The source code to UINT is in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uint.c&quot;&gt;uint.c source file&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ folder&lt;/a&gt; of the SQLite source tree.</source>
          <target state="translated">UINT 조합 시퀀스는 SQLite의 표준 부분이 아닙니다. 별도의 확장으로로드해야합니다. UINT의 소스 코드 는 SQLite 소스 트리 의 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext / misc / 폴더&lt;/a&gt; 에있는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uint.c&quot;&gt;uint.c 소스 파일&lt;/a&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e7f80ab844fa425934b5fe17e1623d4db7a7ce" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence is not included in standard builds of the SQLite library, but it is loaded by default in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;. This is typical of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; which loads various extensions above and beyond what are available in the standard SQLite library.</source>
          <target state="translated">UINT 조합 시퀀스는 SQLite 라이브러리의 표준 빌드에 포함되지 않지만 기본적으로 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에로드됩니다 . 이것은 표준 SQLite 라이브러리에서 사용할 수있는 것 이상으로 다양한 확장을로드 하는 &lt;a href=&quot;cli&quot;&gt;CLI의&lt;/a&gt; 전형입니다 .</target>
        </trans-unit>
        <trans-unit id="324d9f9cbd074a1b691e1ceb95aebe8ed7a7d3f9" translate="yes" xml:space="preserve">
          <source>The UINT collating sequence works just like the default BINARY collating sequence for text, except that embedded strings of digits compare in numeric order.</source>
          <target state="translated">UINT 조합 시퀀스는 포함 된 숫자 문자열이 숫자 순서로 비교된다는 점을 제외하면 텍스트의 기본 BINARY 조합 시퀀스와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0a4b72a7cee3e902b5abc5c6a3d97ab02173e940" translate="yes" xml:space="preserve">
          <source>The UINT collating sequences is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; for SQLite that implements a new collating sequence that compares text containing unsigned integers in numeric order.</source>
          <target state="translated">UINT 조합 시퀀스는 부호없는 정수를 포함하는 텍스트를 숫자 순서로 비교하는 새로운 조합 시퀀스를 구현하는 SQLite 용 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="663111ce13348e029be0eb29fd78279aef78534e" translate="yes" xml:space="preserve">
          <source>The UNION Virtual Table</source>
          <target state="translated">UNION 가상 테이블</target>
        </trans-unit>
        <trans-unit id="83a6780922b4732cbc0add9d73d09070752444e6" translate="yes" xml:space="preserve">
          <source>The UNION operator for compound queries is implemented by creating a transient index in a temporary file and storing the results of the left and right subquery in the transient index, discarding duplicates. After both subqueries have been evaluated, the transient index is walked from beginning to end to generate the final output.</source>
          <target state="translated">복합 조회의 UNION 연산자는 임시 파일에 임시 색인을 작성하고 왼쪽 및 오른쪽 하위 조회의 결과를 임시 색인에 저장하여 중복을 삭제함으로써 구현됩니다. 두 하위 쿼리를 모두 평가 한 후에는 과도 색인을 처음부터 끝까지 걸어 최종 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7930c62c86f89ebc6a986709239760afad2bba9f" translate="yes" xml:space="preserve">
          <source>The UNION virtual table (hereafter: &quot;union-vtab&quot;) is a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that makes multiple independent &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; tables look like a single large table.</source>
          <target state="translated">UNION 가상 테이블 (이하 &quot;union-vtab&quot;)은 여러 개의 독립적 인 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 테이블을 하나의 큰 테이블처럼 보이게 하는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="16da95be83b926d661aef977fab4f723fc62a011" translate="yes" xml:space="preserve">
          <source>The UPDATE and DELETE statements are coded using a template that is very similar to the SELECT statement template. The main difference, of course, is that the end action is to modify the database rather than invoke a callback function. Because it modifies the database it will also use transactions. Let's begin by looking at a DELETE statement:</source>
          <target state="translated">UPDATE 및 DELETE 문은 SELECT 문 템플리트와 매우 유사한 템플리트를 사용하여 코딩됩니다. 물론 가장 큰 차이점은 최종 작업은 콜백 함수를 호출하지 않고 데이터베이스를 수정하는 것입니다. 데이터베이스를 수정하기 때문에 트랜잭션도 사용합니다. DELETE 문을 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="d012a450cb6e8a62342d872acae64f627c638672" translate="yes" xml:space="preserve">
          <source>The UPDATE statement was not working when the WHERE clause contained some terms that could be satisfied using indices and other terms that could not. Fixed.</source>
          <target state="translated">WHERE 절에 색인을 사용하여 만족할 수있는 일부 용어와 포함 할 수없는 다른 용어가 있으면 UPDATE 문이 작동하지 않았습니다. 결정된.</target>
        </trans-unit>
        <trans-unit id="33c2760fb2236b7ba6d326e49f2cb15eef8f0600" translate="yes" xml:space="preserve">
          <source>The UPDATE-FROM idea is an extension to SQL that allows an UPDATE statement to be driven by other tables in the database. The &quot;target&quot; table is the specific table that is being updated. With UPDATE-FROM you can join the target table against other tables in the database in order to help compute which rows need updating and what the new values should be on those rows. UPDATE-FROM is supported beginning in SQLite version 3.33.0 (2020-08-14).</source>
          <target state="translated">UPDATE-FROM 아이디어는 UPDATE 문이 데이터베이스의 다른 테이블에 의해 구동 될 수 있도록하는 SQL의 확장입니다. &quot;대상&quot;테이블은 업데이트되는 특정 테이블입니다. UPDATE-FROM을 사용하면 업데이트가 필요한 행과 해당 행에 새 값이 있어야하는 것을 계산하는 데 도움이되도록 데이터베이스의 다른 테이블에 대해 대상 테이블을 조인 할 수 있습니다. UPDATE-FROM은 SQLite 버전 3.33.0 (2020-08-14)부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a45a66b4cdc4b1cad87f2ad44961d2b0a1e7cb34" translate="yes" xml:space="preserve">
          <source>The Use Of assert() In SQLite</source>
          <target state="translated">SQLite에서 assert () 사용</target>
        </trans-unit>
        <trans-unit id="91cb86d3be85bb36d2918c344be4f7a7dbe55738" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command is transactional in the sense that the generated output database is a consistent snapshot of the original database. However, if the VACUUM INTO command is interrupted by an unplanned shutdown or power lose, then the generated output database might be incomplete and corrupt. Also, SQLite does not invoke fsync() or FlushFileBuffers() on the generated database to ensure that it has reached non-volatile storage before completing.</source>
          <target state="translated">VACUUM INTO 명령은 생성 된 출력 데이터베이스가 원래 데이터베이스의 일관된 스냅 샷이라는 의미에서 트랜잭션입니다. 그러나 계획되지 않은 종료 또는 정전으로 인해 VACUUM INTO 명령이 중단되면 생성 된 출력 데이터베이스가 불완전하고 손상되었을 수 있습니다. 또한 SQLite는 생성 된 데이터베이스에서 fsync () 또는 FlushFileBuffers ()를 호출하여 완료 전에 비 휘발성 저장소에 도달했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="122691010e5d737070edb247661b2776162b982c" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command works the same way except that it uses the file named on the INTO clause in place of the temporary database and omits the step of copying the vacuumed database back over top of the original database.</source>
          <target state="translated">VACUUM INTO 명령은 임시 데이터베이스 대신 INTO 절에 이름이 지정된 파일을 사용하고 원래 데이터베이스의 맨 위에 진공 데이터베이스를 다시 복사하는 단계를 생략한다는 점을 제외하고 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7b858ec9bacb824cb3d161c5dbed06b788759184" translate="yes" xml:space="preserve">
          <source>The VACUUM command may change the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; of entries in any tables that do not have an explicit &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">VACUUM 명령은 명시 적 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 가없는 테이블에서 항목 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41696dc3c99878e16f90bac54782d308e462d0f3" translate="yes" xml:space="preserve">
          <source>The VACUUM command now works with the non-callback API</source>
          <target state="translated">VACUUM 명령은 이제 비 콜백 API와 함께 작동합니다</target>
        </trans-unit>
        <trans-unit id="27866863317458114de851c82a30b86b318d52b6" translate="yes" xml:space="preserve">
          <source>The VACUUM command rebuilds the database file, repacking it into a minimal amount of disk space. There are several reasons an application might do this:</source>
          <target state="translated">VACUUM 명령은 데이터베이스 파일을 다시 작성하여 최소의 디스크 공간으로 다시 압축합니다. 애플리케이션이이를 수행 할 수있는 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aa5f71406817eba130230946d703a26da25090a" translate="yes" xml:space="preserve">
          <source>The VACUUM command with an INTO clause is an alternative to the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; for generating backup copies of a live database. The advantage of using VACUUM INTO is that the resulting backup database is minimal in size and hence the amount of filesystem I/O may be reduced. Also, all deleted content is purged from the backup, leaving behind no forensic traces. On the other hand, the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; uses fewer CPU cycles and can be executed incrementally.</source>
          <target state="translated">INTO 절이있는 VACUUM 명령 은 라이브 데이터베이스의 백업 사본을 생성 &lt;a href=&quot;backup&quot;&gt;하기&lt;/a&gt; 위한 백업 API 의 대안 입니다. VACUUM INTO를 사용하면 얻을 수있는 백업 데이터베이스의 크기가 최소화되므로 파일 시스템 I / O의 양이 줄어들 수 있습니다. 또한 삭제 된 모든 내용이 백업에서 제거되어 법 의학적 흔적이 남지 않습니다. 반면 &lt;a href=&quot;backup&quot;&gt;백업 API&lt;/a&gt; 는 더 적은 CPU주기를 사용하며 증 분식으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a189fd9e3d1e02aa0528451d9b2483299ef4e9" translate="yes" xml:space="preserve">
          <source>The VACUUM command works by copying the contents of the database into a temporary database file and then overwriting the original with the contents of the temporary file. When overwriting the original, a rollback journal or &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; WAL file is used just as it would be for any other database transaction. This means that when VACUUMing a database, as much as twice the size of the original database file is required in free disk space.</source>
          <target state="translated">VACUUM 명령은 데이터베이스의 내용을 임시 데이터베이스 파일로 복사 한 다음 임시 파일의 내용으로 원본을 덮어 쓰는 방식으로 작동합니다. 원본을 덮어 쓰면 롤백 저널 또는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; WAL 파일이 다른 데이터베이스 트랜잭션과 마찬가지로 사용됩니다. 이는 데이터베이스를 진공 처리 할 때 디스크 여유 공간에 원본 데이터베이스 파일 크기의 두 배가 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="778738485f953e3a9b76b31822d939e887b55074" translate="yes" xml:space="preserve">
          <source>The VALUE and HIWTR columns report the current value of the measure and its &quot;high-water mark&quot;. The high-water mark is the highest value ever seen for the measurement, at least since the last reset. The SQLITE_MEMSTAT virtual table does not provide a mechanism for resetting the high-water mark.</source>
          <target state="translated">VALUE 및 HIWTR 열은 측정 값의 현재 값과 해당 &quot;고수위 표시&quot;를보고합니다. 최고 수위 표시는 적어도 마지막 재설정 이후 측정에서 가장 높은 값입니다. SQLITE_MEMSTAT 가상 테이블은 최고 사용 표시 점 재설정 메커니즘을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b2ece5b4ab8b91b62ace8f0cc0040f19a643253" translate="yes" xml:space="preserve">
          <source>The VALUES clause</source>
          <target state="translated">VALUES 절</target>
        </trans-unit>
        <trans-unit id="b8a859f7de071f48cff5a7fe9193dabc82e472c2" translate="yes" xml:space="preserve">
          <source>The VALUES clause of an INSERT can now contain expressions, including scalar SELECT clauses.</source>
          <target state="translated">INSERT의 VALUES 절은 이제 스칼라 SELECT 절을 포함하여 표현식을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="222a8cea06637d3ca462a60582d77b6f51ecd46d" translate="yes" xml:space="preserve">
          <source>The VDBE code generated by the above statement looks like the following:</source>
          <target state="translated">위의 명령문으로 생성 된 VDBE 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="914b54584037bedb35946860061828500f1bc504" translate="yes" xml:space="preserve">
          <source>The VDBE code generated for this query is as follows:</source>
          <target state="translated">이 쿼리에 대해 생성 된 VDBE 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44e862e51e63dc8e6d2cfc4ebc01e6bf18bd5d5d" translate="yes" xml:space="preserve">
          <source>The VDBE implements a virtual computer that runs a program in its virtual machine language. The goal of each program is to interrogate or change the database. Toward this end, the machine language that the VDBE implements is specifically designed to search, read, and modify databases.</source>
          <target state="translated">VDBE는 가상 머신 언어로 프로그램을 실행하는 가상 컴퓨터를 구현합니다. 각 프로그램의 목표는 데이터베이스를 조사하거나 변경하는 것입니다. 이를 위해 VDBE가 구현하는 기계 언어는 데이터베이스를 검색, 읽기 및 수정하도록 특별히 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2dceeabf6f031eb26374896fc49e25ce44afb511" translate="yes" xml:space="preserve">
          <source>The VDBE program generated for this SQL statement is as follows:</source>
          <target state="translated">이 SQL 문에 대해 생성 된 VDBE 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80bc0b2de97d753f617c4eaf5d3c9b6776ea43cf" translate="yes" xml:space="preserve">
          <source>The VERSION table shown above has columns to record a check-in comment (presumably supplied by the user) and the time and date at which the File/Save action occurred. It also records the parent version to record the history of changes. Perhaps the manifest could be stored as a delta from the parent version, though typically the manifest will be small enough that storing a delta might be more trouble than it is worth. The SLIDE table also contains a derivedFrom column which could be used for delta encoding if it is determined that saving the slide content as a delta from its previous version is a worthwhile optimization.</source>
          <target state="translated">위에 표시된 VERSION 테이블에는 체크인 주석 (아마 사용자가 제공 한 것)과 파일 / 저장 작업이 발생한 시간 및 날짜를 ​​기록하는 열이 있습니다. 또한 변경 기록을 기록하기 위해 상위 버전을 기록합니다. 아마도 매니페스트는 상위 버전의 델타로 저장 될 수 있지만 일반적으로 매니페스트는 델타를 저장하는 것이 가치가있는 것보다 더 문제가 될 정도로 작을 것입니다. SLIDE 테이블에는 슬라이드 내용을 이전 버전의 델타로 저장하는 것이 가치가 있다고 판단되는 경우 델타 인코딩에 사용할 수있는 파생 된 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b59010289d2579bd6e51282e421f222dba65ae2" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that due to an oversight, the structure of the sqlite3_vfs object changed in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not increased.</source>
          <target state="translated">VFS 인터페이스는 때때로 끝에 새로운 메소드를 추가하여 확장됩니다. 이러한 확장이 발생할 때마다 iVersion 필드가 증가합니다. iVersion 값은 2007-09-04 에 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; 에서 1로 시작 하여 2010-07-21에 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; 에서 2로 증가한 다음 2011 년에 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;버전 3.7.6&lt;/a&gt; 에서 3으로 증가했습니다. -04-12. 추가 필드는 sqlite3_vfs 객체에 추가 될 수 있으며 iVersion 값은 SQLite의 향후 버전에서 다시 증가 할 수 있습니다. 감독으로 인해 sqlite3_vfs 객체의 구조가 2008-07-16에 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;버전 3.5.9&lt;/a&gt; 에서 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;버전 3.6.0&lt;/a&gt; 으로 전환하는 과정에서 변경 되었지만 iVersion 필드는 증가하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0766456a2002e4475782706d0b0fb713540038a5" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that the structure of the sqlite3_vfs object changes in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not modified.</source>
          <target state="translated">VFS 인터페이스는 때때로 새로운 메소드를 끝에 추가하여 확장됩니다. 이러한 확장이 발생할 때마다 iVersion 필드가 증가합니다. iVersion 값은 2007-09-04의 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; 에서 1로 시작한 다음 2010-07-21의 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; 에서는 2로 증가한 다음 2011 년 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;버전 3.7.6&lt;/a&gt; 에서는 3으로 증가했습니다. -04-12. 추가 필드가 sqlite3_vfs 오브젝트에 추가 될 수 있으며 향후 버전의 SQLite에서 iVersion 값이 다시 증가 할 수 있습니다. sqlite3_vfs 객체의 구조는 2008-07-16의 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;버전 3.5.9&lt;/a&gt; 에서 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;버전 3.6.0&lt;/a&gt; 으로 의 전환에서 변경 되었지만 iVersion 필드는 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9428f4f61873bedbb7fa546ce9da2878f0f6b46f" translate="yes" xml:space="preserve">
          <source>The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The default VFS is used if no VFS is specified otherwise.</source>
          <target state="translated">URI로 지정된 VFS의 우선 순위가 가장 높습니다. 그런 다음 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 의 네 번째 인수로 지정된 VFS가옵니다 . VFS를 지정하지 않으면 기본 VFS가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59f617b8350433543bfe3f6503e9062a84ed6414" translate="yes" xml:space="preserve">
          <source>The Virtual Database Engine of SQLite</source>
          <target state="translated">SQLite의 가상 데이터베이스 엔진</target>
        </trans-unit>
        <trans-unit id="2fc007776417aa54116dbc71f8065ab7e3ac76ea" translate="yes" xml:space="preserve">
          <source>The Virtual Table Mechanism Of SQLite</source>
          <target state="translated">SQLite의 가상 테이블 메커니즘</target>
        </trans-unit>
        <trans-unit id="4a47770692c502c7c39564cd0fc7b210860b676a" translate="yes" xml:space="preserve">
          <source>The WAL approach inverts this. The original content is preserved in the database file and the changes are appended into a separate WAL file. A &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when a special record indicating a commit is appended to the WAL. Thus a COMMIT can happen without ever writing to the original database, which allows readers to continue operating from the original unaltered database while changes are simultaneously being committed into the WAL. Multiple transactions can be appended to the end of a single WAL file.</source>
          <target state="translated">WAL 접근법은 이것을 뒤집습니다. 원본 내용은 데이터베이스 파일에 유지되며 변경 내용은 별도의 WAL 파일에 추가됩니다. A는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 커밋 나타내는 특별한 레코드가 WAL에 추가 될 때 발생합니다. 따라서 COMMIT는 원래 데이터베이스에 쓰지 않고도 발생할 수 있으므로 변경 사항이 WAL에 동시에 커밋되는 동안 독자는 변경되지 않은 원래 데이터베이스에서 계속 작업 할 수 있습니다. 단일 WAL 파일 끝에 여러 트랜잭션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b1501dab1e647276daeb770adadd0f94b39bd1" translate="yes" xml:space="preserve">
          <source>The WAL file can optionally be truncated on a reset, but it need not be. Performance is usually a little better if the WAL is not truncated, since filesystems generally will overwrite an existing file faster than they will grow a file.</source>
          <target state="translated">재설정시 WAL 파일은 선택적으로 잘릴 수 있지만 반드시 그럴 필요는 없습니다. 파일 시스템은 일반적으로 파일을 늘리는 것보다 기존 파일을 빠르게 덮어 쓰기 때문에 WAL이 잘리지 않으면 성능이 약간 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee114cc7fc43aace09ed2f31fdb137fc0cc57b0" translate="yes" xml:space="preserve">
          <source>The WAL file exists for as long as any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has the database open. Usually, the WAL file is deleted automatically when the last connection to the database closes. However, if the last process to have the database open exits without cleanly shutting down the database connection, or if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; is used, then the WAL file might be retained on disk after all connections to the database have been closed. The WAL file is part of the persistent state of the database and should be kept with the database if the database is copied or moved. If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interfaces then immediately close the database using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 데이터베이스가 열려 있는 한 WAL 파일이 존재합니다 . 일반적으로 WAL 파일은 데이터베이스에 대한 마지막 연결이 닫힐 때 자동으로 삭제됩니다. 그러나 데이터베이스 연결을 완전히 종료하지 않고 데이터베이스를 마지막으로 열 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;었던&lt;/a&gt; 프로세스가 종료되거나 SQLITE_FCNTL_PERSIST_WAL &lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어 인 경우&lt;/a&gt;를 사용하면 데이터베이스에 대한 모든 연결이 닫힌 후 WAL 파일이 디스크에 유지 될 수 있습니다. WAL 파일은 데이터베이스의 지속적 상태의 일부이며 데이터베이스를 복사하거나 이동하는 경우 데이터베이스와 함께 보관해야합니다. 데이터베이스 파일이 WAL 파일과 분리되면 이전에 데이터베이스에 커밋 된 트랜잭션이 손실되거나 데이터베이스 파일이 손상 될 수 있습니다. WAL 파일을 제거하는 유일한 안전한 방법은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 인터페이스 중 하나를 사용하여 데이터베이스 파일을 연 다음 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 데이터베이스를 즉시 닫는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="79014b745cf0a5f8595085db33b3a7e639f66d1c" translate="yes" xml:space="preserve">
          <source>The WAL header is 32 bytes in size and consists of the following eight big-endian 32-bit unsigned integer values:</source>
          <target state="translated">WAL 헤더의 크기는 32 바이트이며 다음 8 개의 빅 엔디안 32 비트 부호없는 정수 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad8fc65cf4c28a6553ebe75589fa3de09b97b25" translate="yes" xml:space="preserve">
          <source>The WAL journal mode will be set on all connections to the same database file if it is set on any one connection.</source>
          <target state="translated">WAL 저널 모드는 하나의 연결로 설정된 경우 동일한 데이터베이스 파일에 대한 모든 연결에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c2da5fc09a01446274895178b9f5584cc12d72c9" translate="yes" xml:space="preserve">
          <source>The WAL journaling mode uses a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; instead of a rollback journal to implement transactions. The WAL journaling mode is persistent; after being set it stays in effect across multiple database connections and after closing and reopening the database. A database in WAL journaling mode can only be accessed by SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21) or later.</source>
          <target state="translated">WAL 저널링 모드는 롤백 저널 대신 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 를 사용하여 트랜잭션을 구현합니다. WAL 저널링 모드는 지속적입니다. 설정 한 후에는 여러 데이터베이스 연결에서 그리고 데이터베이스를 닫았다가 다시 연 후에도 계속 유효합니다. WAL 저널링 모드의 데이터베이스는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21) 이상 에서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbeadb5beff9552e41ebfc0aed8339e43743fd64" translate="yes" xml:space="preserve">
          <source>The WAL-index format version number. Always 3007000.</source>
          <target state="translated">WAL 색인 형식 버전 번호입니다. 항상 3007000입니다.</target>
        </trans-unit>
        <trans-unit id="a0470594be37c3f0ff60237d02ae37bf43150bc8" translate="yes" xml:space="preserve">
          <source>The WAL-index or &quot;shm&quot; file is used to coordinate access to the database by multiple clients, and as a cache to help clients quickly locate frames within the wal file.</source>
          <target state="translated">WAL- 인덱스 또는 &quot;shm&quot;파일은 여러 클라이언트의 데이터베이스 액세스를 조정하고 클라이언트가 wal 파일 내에서 프레임을 빠르게 찾을 수 있도록 캐시로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa0bf716018ca8d2c184cf21d82cae1245d9415" translate="yes" xml:space="preserve">
          <source>The WAL_CKPT_LOCK is only locked exclusively. There is never a shared lock taken on WAL_CKPT_LOCK.</source>
          <target state="translated">WAL_CKPT_LOCK은 독점적으로 만 잠겨 있습니다. WAL_CKPT_LOCK에는 공유 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42d567271c4a4abf54f649e6218b2a342b7491c5" translate="yes" xml:space="preserve">
          <source>The WAL_RECOVER_LOCK is only locked exclusively. There is never a shared lock taken on WAL_RECOVER_LOCK.</source>
          <target state="translated">WAL_RECOVER_LOCK은 독점적으로 만 잠겨 있습니다. WAL_RECOVER_LOCK에는 공유 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f378361895c3312e72c176b00bbf1af957e8b29d" translate="yes" xml:space="preserve">
          <source>The WAL_WRITE_LOCK is only locked exclusively. There is never a shared lock taken on WAL_WRITE_LOCK.</source>
          <target state="translated">WAL_WRITE_LOCK은 독점적으로 만 잠겨 있습니다. WAL_WRITE_LOCK에는 공유 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cddb2fff96db0eb2561a8fa9288188bd61c4a17a" translate="yes" xml:space="preserve">
          <source>The WHERE clause is implemented by instructions 6 through 8. The job of the where clause is to skip the ListWrite if the WHERE condition is false. To this end, it jumps ahead to the Next instruction if the &quot;two&quot; column (extracted by the Column instruction) is greater than or equal to 50.</source>
          <target state="translated">WHERE 절은 명령 6-8로 구현됩니다. where 절의 작업은 WHERE 조건이 false 인 경우 ListWrite를 건너 뛰는 것입니다. 이를 위해 &quot;2&quot;열 (열 명령으로 추출)이 50보다 크거나 같으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="29f1ffc6e309ea1c4b2ff1d0678fe7459979e894" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separate by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="translated">쿼리의 WHERE 절은 AND 연산자에 의해 각 용어가 다른 용어와 분리되는 &quot;terms&quot;로 나뉩니다. WHERE 절이 OR 연산자에 의해 분리 된 제한 조건으로 구성된 경우 전체 절은 &lt;a href=&quot;#or_opt&quot;&gt;OR 절 최적화&lt;/a&gt; 가 적용되는 단일 &quot;term&quot;으로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="67af3225970c5961856bbb922d2677740529dd45" translate="yes" xml:space="preserve">
          <source>The WINDOW clause, when one is present, comes after any HAVING clause and before any ORDER BY.</source>
          <target state="translated">WINDOW 절은 존재하는 경우 HAVING 절 뒤에 그리고 ORDER BY 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="59f006cfccb1b0c07b582f38b2b03e476dd1faa4" translate="yes" xml:space="preserve">
          <source>The WITH Clause</source>
          <target state="translated">WITH 절</target>
        </trans-unit>
        <trans-unit id="49bb3b8074d7fe6469254452d39dc417f079e333" translate="yes" xml:space="preserve">
          <source>The WITH clause cannot be used within a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="translated">WITH 절은 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 내에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="469f423bf145b329a62c79e892ff06f00b735aaa" translate="yes" xml:space="preserve">
          <source>The WITH clause must appear at the beginning of a top-level &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement or at the beginning of a subquery. The WITH clause cannot be prepended to the second or subsequent SELECT statement of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;.</source>
          <target state="translated">WITH 절은 최상위 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 시작 또는 하위 쿼리의 시작에 나타나야합니다 . WITH 절은 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 select&lt;/a&gt; 의 두 번째 또는 후속 SELECT 문 앞에 추가 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0790118e4cc64a2949db095a0b8b9579da7d5654" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</source>
          <target state="translated">WITHOUT ROWID 최적화는 정수가 아닌 복합 (복수 열) 기본 키가 있고 큰 문자열 또는 BLOB를 저장하지 않는 테이블에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74650aa10ba4b42e039edd4a2cc74f6b68fb08b" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID syntax is an optimization. It provides no new capabilities. Anything that can be done using a WITHOUT ROWID table can also be done in exactly the same way, and exactly the same syntax, using an ordinary rowid table. The only advantage of a WITHOUT ROWID table is that it can sometimes use less disk space and/or perform a little faster than an ordinary rowid table.</source>
          <target state="translated">WITHOUT ROWID 구문은 최적화입니다. 새로운 기능을 제공하지 않습니다. WITHOUT ROWID 테이블을 사용하여 수행 할 수있는 모든 작업은 일반 rowid 테이블을 사용하여 정확히 동일한 방식으로, 동일한 구문으로 수행 할 수 있습니다. WITHOUT ROWID 테이블의 유일한 장점은 때때로 더 적은 디스크 공간을 사용하고 /하거나 일반 rowid 테이블보다 약간 더 빠르게 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5d979d02523b8b3c921a385853078f31581834f" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID table that has the same structure as the t1bc index would look like this:</source>
          <target state="translated">t1bc 인덱스와 동일한 구조를 갖는 WITHOUT ROWID 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebd241bcb9edacf4c26a21a11fc0d3a7cc0b5d00" translate="yes" xml:space="preserve">
          <source>The X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.</source>
          <target state="translated">마스크 M으로 식별 된 이벤트가 발생할 때마다 X 콜백이 호출됩니다. 콜백의 정수 반환 값은 현재 무시되지만 이후 릴리스에서 변경 될 수 있습니다. 향후 호환성을 보장하기 위해 콜백 구현은 0을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9560a5bff3ce71963e342a5450ede2debbbea82" translate="yes" xml:space="preserve">
          <source>The aConstraintUsage[] array contains one element for each of the nConstraint constraints in the inputs section of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. The aConstraintUsage[] array is used by xBestIndex to tell the core how it is using the constraints.</source>
          <target state="translated">aConstraintUsage [] 배열에는 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 입력 섹션에있는 각 nConstraint 제약 조건에 대한 요소가 하나씩 있습니다. aConstraintUsage [] 배열은 xBestIndex에서 코어에 제약 조건을 사용하는 방법을 알려주기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3276fd18c87b4e795759956677bbdc04f564672d" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array contains information about all constraints that apply to the virtual table. But some of the constraints might not be usable because of the way tables are ordered in a join. The xBestIndex method must therefore only consider constraints that have an aConstraint[].usable flag which is true.</source>
          <target state="translated">aConstraint [] 배열에는 가상 테이블에 적용되는 모든 제약 조건에 대한 정보가 포함됩니다. 그러나 테이블이 조인에서 정렬되는 방식으로 인해 일부 제약 조건을 사용할 수 없습니다. 따라서 xBestIndex 메소드는 aConstraint []. usable 플래그가 true 인 제한 조건 만 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="08f35e14867214bff1de15c06eccca3a8c64a445" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array records WHERE clause constraints of the form:</source>
          <target state="translated">aConstraint [] 배열은 다음 형식의 WHERE 절 제약 조건을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="cb4f46690b6dce470ed710606d550164c584726b" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">집계 및 테이블 반환 함수를 포함한 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 를 추가하는 기능.</target>
        </trans-unit>
        <trans-unit id="201991425b66ed2865e7a91ab0511b280556125f" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">집계 및 테이블 반환 함수를 포함하여 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 를 추가하는 기능</target>
        </trans-unit>
        <trans-unit id="a3094b48cb721d2768a7d14f0821434de8cd0a90" translate="yes" xml:space="preserve">
          <source>The ability to index expressions was added to SQLite with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). A database that uses an index on expressions will not be usable by earlier versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14)에 표현식을 색인화하는 기능이 추가되었습니다 . 식에서 인덱스를 사용하는 데이터베이스는 이전 버전의 SQLite에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e647580ce3a971bdf9683f9f823fdf4aa9345057" translate="yes" xml:space="preserve">
          <source>The ability to store BLOBs in indexed columns.</source>
          <target state="translated">색인화 된 열에 BLOB를 저장하는 기능</target>
        </trans-unit>
        <trans-unit id="2b4889307c133133bf332e84c716afd8e6689ea5" translate="yes" xml:space="preserve">
          <source>The ability to use keywords as identifiers promotes backwards compatibility. As new keywords are added, legacy schemas that just happen to use those keywords as table or column names continue to work. However, the ability to use a keyword as an identifier sometimes leads to surprising outcomes. For example:</source>
          <target state="translated">키워드를 식별자로 사용하는 기능은 이전 버전과의 호환성을 촉진합니다. 새 키워드가 추가되면 해당 키워드를 테이블 또는 열 이름으로 사용하는 레거시 스키마는 계속 작동합니다. 그러나 키워드를 식별자로 사용하는 기능은 때때로 놀라운 결과를 가져옵니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4e7fcdb984584a84897317afa23740edc4a933b7" translate="yes" xml:space="preserve">
          <source>The above code creates a new table named &lt;b&gt;t1&lt;/b&gt; with columns &lt;b&gt;a&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt;. What could be simpler?</source>
          <target state="translated">위의 코드 는 열 &lt;b&gt;a&lt;/b&gt; 와 &lt;b&gt;b가 &lt;/b&gt;&lt;b&gt;있는 &lt;/b&gt;&lt;b&gt;t1&lt;/b&gt; 이라는 새 테이블을 만듭니다 . 더 간단 할 수있는 것은 무엇입니까?&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e597cdc48d987ee3a37507f5f4f64e4eebc9821" translate="yes" xml:space="preserve">
          <source>The above command should be run from the MSVC Native Tools Command Prompt. If you have MSVC installed on your machine, you probably have multiple versions of this Command Prompt, for native builds for x86 and x64, and possibly also for cross-compiling to ARM. Use the appropriate Command Prompt depending on the desired DLL.</source>
          <target state="translated">위의 명령은 MSVC 기본 도구 명령 프롬프트에서 실행해야합니다. 컴퓨터에 MSVC를 설치 한 경우 x86 및 x64의 기본 빌드 및 ARM으로의 크로스 컴파일을 위해이 명령 프롬프트의 여러 버전이있을 수 있습니다. 원하는 DLL에 따라 적절한 명령 프롬프트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="40e5d3c82a1f28fca2d855ebabf947c2e6309d01" translate="yes" xml:space="preserve">
          <source>The above is all you really need to know in order to use SQLite in your C or C++ programs. There are other interface functions available (and described below) but we will begin by describing the core functions shown above.</source>
          <target state="translated">위의 내용은 C 또는 C ++ 프로그램에서 SQLite를 사용하기 위해 실제로 알아야 할 모든 것입니다. 사용 가능한 다른 인터페이스 기능이 있지만 아래에 설명 된 핵심 기능에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e1d8b560084e958b9b180ef1ea3e4c34811a8e33" translate="yes" xml:space="preserve">
          <source>The above means that executing the 'merge' command with a negative parameter until the before and after difference in the return value of &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is less than two optimizes the FTS index in the same way as the &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize command&lt;/a&gt;. However, if a new b-tree is added to the FTS index while this process is ongoing, FTS5 will move the new b-tree to the same level as the existing b-trees and restart the merge. To avoid this, only the first call to 'merge' should specify a negative parameter. Each subsequent call to 'merge' should specify a positive value so that the merge started by the first call is run to completion even if new b-trees are added to the FTS index.</source>
          <target state="translated">위의 내용은 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 의 반환 값의 전후 차이 가 2보다 작을 때까지 음수 매개 변수로 'merge'명령을 실행 하면 &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize 명령&lt;/a&gt; 과 같은 방식으로 FTS 인덱스를 최적화합니다 . 그러나이 프로세스가 진행되는 동안 새 b- 트리가 FTS 인덱스에 추가되면 FTS5는 새 b- 트리를 기존 b- 트리와 같은 수준으로 이동하고 병합을 다시 시작합니다. 이를 피하려면 '병합'에 대한 첫 번째 호출 만 음수 매개 변수를 지정해야합니다. 이후에 '병합'에 대한 각 호출은 양수 값을 지정하여 새 b- 트리가 FTS 인덱스에 추가 되더라도 첫 번째 호출로 시작된 병합이 완료 될 때까지 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9200726c1128b95e04b731c9b7e036f2a699198" translate="yes" xml:space="preserve">
          <source>The above two assumptions may be interpreted to mean that if a system failure occurs after file truncation but before the truncated file is</source>
          <target state="translated">위의 두 가지 가정은 파일 잘린 후 또는 잘린 파일이 끝나기 전에 시스템 오류가 발생하는 경우를 의미하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63e4faf9292fbb17cef84d7ffb499ec94358865c" translate="yes" xml:space="preserve">
          <source>The above will return something like this:</source>
          <target state="translated">위의 내용은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="0861e077c18aeb6848f0b5c9c63fbc9c90c17596" translate="yes" xml:space="preserve">
          <source>The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.</source>
          <target state="translated">abs (X) 함수는 숫자 인수 X의 절대 값을 반환합니다. Abs (X)는 X가 NULL이면 NULL을 반환합니다. X가 숫자 값으로 변환 할 수없는 문자열 또는 얼룩 인 경우 Abs (X)는 0.0을 반환합니다. X가 정수 -9223372036854775808이면 abs (X)는 동일한 양의 64 비트 2 보수 값이 없으므로 정수 오버 플로우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3eb517318225f5fe795733968275ce4a51bc681e" translate="yes" xml:space="preserve">
          <source>The absolute value of this integer argument is used as the (approximate) number of tokens to include in the returned text value. The maximum allowable absolute value is 64. The value of this argument is referred to as</source>
          <target state="translated">이 정수 인수의 절대 값은 리턴 된 텍스트 값에 포함 할 (대략) 토큰 수로 사용됩니다. 허용되는 최대 절대 값은 64입니다.이 인수의 값을</target>
        </trans-unit>
        <trans-unit id="85ca4a9788c6f1b476159c0eeb6719f0a0122577" translate="yes" xml:space="preserve">
          <source>The acctchng_magnitude index is over the account number (&quot;acct_no&quot;) and on the absolute value of the amount. This index allows one to do efficient queries over the magnitude of a change to the account. For example, to list all changes to account number $xyz that are more than $100.00, one can say:</source>
          <target state="translated">acctchng_magnitude 지수는 계좌 번호 ( &quot;acct_no&quot;)를 초과하고 금액의 절대 값을 초과합니다. 이 색인을 통해 계정 변경 규모에 대해 효율적인 쿼리를 수행 할 수 있습니다. 예를 들어 $ 100.00 이상의 계정 번호 $ xyz에 대한 모든 변경 사항을 나열하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e14d586171fc852b529e7898dae84a1afce65ec" translate="yes" xml:space="preserve">
          <source>The acronym RBU stands for &quot;Resumable Bulk Update&quot;.</source>
          <target state="translated">약어 RBU는 &quot;재개 가능한 대량 업데이트&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd26fea06f2a519581c858bc894c62df5370dfe9" translate="yes" xml:space="preserve">
          <source>The act of deleting a file is expensive on many systems. As an optimization, SQLite can be configured to truncate the journal file to zero bytes in length or overwrite the journal file header with zeros. In either case, the resulting journal file is no longer capable of rolling back and so the transaction still commits. Truncating a file to zero length, like deleting a file, is assumed to be an atomic operation from the point of view of a user process. Overwriting the header of the journal with zeros is not atomic, but if any part of the header is malformed the journal will not roll back. Hence, one can say that the commit occurs as soon as the header is sufficiently changed to make it invalid. Typically this happens as soon as the first byte of the header is zeroed.</source>
          <target state="translated">파일을 삭제하는 작업은 많은 시스템에서 비용이 많이 듭니다. 최적화로서, 저널 파일을 길이가 0 바이트로 자르거나 저널 파일 헤더를 0으로 겹쳐 쓰도록 SQLite를 구성 할 수 있습니다. 두 경우 모두 결과 저널 파일은 더 이상 롤백 할 수 없으므로 트랜잭션은 여전히 ​​커밋됩니다. 파일 삭제와 같이 파일을 길이가 0으로 자르는 것은 사용자 프로세스의 관점에서 원자적인 작업으로 가정합니다. 저널의 헤더를 0으로 겹쳐 쓰는 것은 원자 적이 지 않지만 헤더의 일부가 변형 된 경우 저널은 롤백되지 않습니다. 따라서 커밋이 유효하지 않게 헤더가 충분히 변경되는 즉시 커밋이 발생한다고 말할 수 있습니다. 일반적으로 이것은 헤더의 첫 바이트가 0이되는 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb72a7b6e0cde775aa0861a739588c085322d8b5" translate="yes" xml:space="preserve">
          <source>The action of the preupdate hook is similar to the &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; except that the callback is invoked before the change, not afterwards, and the preupdate hook interfaces are omitted unless this compile-time option is used.</source>
          <target state="translated">사전 &lt;a href=&quot;c3ref/update_hook&quot;&gt;업데이트 훅&lt;/a&gt; 의 동작은 업데이트 훅 과 유사하지만 ,이 컴파일 타임 옵션을 사용하지 않으면 변경 전에 콜백이 호출되고 사전 업데이트 훅 인터페이스가 생략된다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d730b41c0c65afc48bf2186d2e78971f79c0ae93" translate="yes" xml:space="preserve">
          <source>The actual remote head</source>
          <target state="translated">실제 원격 헤드</target>
        </trans-unit>
        <trans-unit id="d5942dd3b483843b4b3b13169967e9623c12cf60" translate="yes" xml:space="preserve">
          <source>The actual value of the automerge parameter determines the number of index segments merged simultaneously by an automatic inverted index merge. If the value is set to N, the system waits until there are at least N segments on a single level before beginning to incrementally merge them. Setting a lower value of N causes segments to be merged more quickly, which may speed up full-text queries and, if the workload contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk consumed by the full-text index. However, it also increases the amount of data written to disk.</source>
          <target state="translated">automerge 매개 변수의 실제 값은 자동 반전 된 인덱스 병합에 의해 동시에 병합 된 인덱스 세그먼트 수를 결정합니다. 값이 N으로 설정되면 시스템은 단일 레벨에 최소 N 개의 세그먼트가있을 때까지 기다렸다가 점진적으로 병합하기 시작합니다. N 값을 낮게 설정하면 세그먼트가 더 빨리 병합되어 전체 텍스트 쿼리 속도가 빨라지고 작업 부하에 INSERT뿐만 아니라 UPDATE 또는 DELETE 작업이 포함되어 있으면 전체 텍스트 인덱스에 사용되는 디스크 공간이 줄어 듭니다. 그러나 디스크에 기록되는 데이터의 양도 증가합니다.</target>
        </trans-unit>
        <trans-unit id="fcad8bd16dfc8bbae32259b89340b3c09c02938b" translate="yes" xml:space="preserve">
          <source>The address of the cell in the parent frame is determined by adding the value of the P1 argument to the value of the P1 argument to the calling &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction.</source>
          <target state="translated">상위 프레임의 셀 주소는 P1 인수의 값에 P1 인수의 값을 호출하는 &lt;a href=&quot;opcode#Program&quot;&gt;프로그램&lt;/a&gt; 명령 에 추가하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e600ae2c57bf2172dc311ec955786ffac68bdb53" translate="yes" xml:space="preserve">
          <source>The advantage of the table-valued function format is that the query can return just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate functions, and the table-valued function can be just one of several data sources in a join. For example, to get a list of all indexed columns in a schema, one could query:</source>
          <target state="translated">테이블 반환 함수 형식의 장점은 쿼리에서 PRAGMA 열의 하위 집합 만 반환하고 WHERE 절을 포함 할 수 있으며 집계 함수를 사용할 수 있으며 테이블 반환 함수는 여러 데이터 소스 중 하나 일 수 있다는 것입니다. 붙다. 예를 들어, 스키마의 모든 색인화 된 열 목록을 얻으려면 다음을 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d98ae93ba70e0ca59260993947a4e24c760765d2" translate="yes" xml:space="preserve">
          <source>The advantages of doing many smaller sorts instead of a single large sort are:</source>
          <target state="translated">하나의 큰 정렬 대신 많은 작은 정렬을 수행하면 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2daf3580eecc6fcaa952d18c4522913579884b0" translate="yes" xml:space="preserve">
          <source>The advertised consequence of most CVEs is &quot;denial of service&quot;, typically by causing a crash through a NULL pointer dereference or a division by zero, or similar.</source>
          <target state="translated">대부분의 CVE의 광고 결과는 &quot;서비스 거부&quot;로, 일반적으로 NULL 포인터 역 참조 또는 0으로 나누기 등을 통해 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="15b97dc5f9d1078668a6ce572dccbfb387883173" translate="yes" xml:space="preserve">
          <source>The affinity of a column is determined by the declared type of the column, according to the following rules in the order shown:</source>
          <target state="translated">열의 선호도는 표시된 순서대로 다음 규칙에 따라 선언 된 열 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="81c1ff1ba114ea49399c70cede12a7ccd08cc3d4" translate="yes" xml:space="preserve">
          <source>The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.</source>
          <target state="translated">v1.x는 t1.b에 직접 매핑되므로 v1.x 열의 선호도는 t1.b (TEXT)의 선호도와 동일합니다. 그러나 v1.y 및 v1.z 열은 선호도가 없습니다. 이러한 열은 식 a + c 및 42에 매핑되며 식에는 항상 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab16418452d7d68b0bd05abd8cefe39ddc38000d" translate="yes" xml:space="preserve">
          <source>The aggregate functions shown below are available by default. Additional aggregate functions written in C may be added using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">아래에 표시된 집계 기능은 기본적으로 사용 가능합니다. C로 작성된 추가 집계 함수는 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; API를 사용하여 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="084c900ab7b78b8fb14c15704a0ab2585c905626" translate="yes" xml:space="preserve">
          <source>The algorithm above works quite well for most cases, but there are exceptions. These exceptions can be dealt with by making additional entries in the virtual table using the &quot;soundslike&quot; column.</source>
          <target state="translated">위의 알고리즘은 대부분의 경우에 잘 작동하지만 예외가 있습니다. 이러한 예외는 &quot;soundslike&quot;열을 사용하여 가상 테이블에 추가 항목을 작성하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="db0be7814305eaba73945c0429fa38151c410e55" translate="yes" xml:space="preserve">
          <source>The algorithm specified in the OR clause of an INSERT or UPDATE overrides any algorithm specified in a CREATE TABLE. If no algorithm is specified anywhere, the ABORT algorithm is used.</source>
          <target state="translated">INSERT 또는 UPDATE의 OR 절에 지정된 알고리즘은 CREATE TABLE에 지정된 알고리즘을 대체합니다. 알고리즘이 지정되지 않은 경우 ABORT 알고리즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1bb5e260f6d6940f8038960690efd8a13241e0" translate="yes" xml:space="preserve">
          <source>The algorithm used by memsys5 can be called &quot;power-of-two, first-fit&quot;. The sizes of all memory allocation requests are rounded up to a power of two and the request is satisfied by the first free slot in pBuf that is large enough. Adjacent freed allocations are coalesced using a buddy system. When used appropriately, this algorithm provides mathematical guarantees against fragmentation and breakdown, as described further &lt;a href=&quot;#nofrag&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">memsys5에서 사용하는 알고리즘을 &quot;2의 거듭 제곱&quot;이라고 할 수 있습니다. 모든 메모리 할당 요청의 크기는 2의 거듭 제곱으로 반올림되며 요청은 충분히 큰 pBuf의 첫 번째 여유 슬롯에 의해 충족됩니다. 인접 해제 할당은 버디 시스템을 사용하여 통합됩니다. 적절하게 사용될 경우,이 알고리즘은 &lt;a href=&quot;#nofrag&quot;&gt;아래에&lt;/a&gt; 더 설명 된대로 조각화 및 분류에 대해 수학적 보장을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="91caf7e2c108fa5ca12a12fe7d7f1b642ba24d6e" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_prepare_v2() function is similar, except that step 4 (resetting the statement handle) is omitted.</source>
          <target state="translated">sqlite3_blocking_prepare_v2 () 함수에서 사용하는 알고리즘은 4 단계 (명령문 재설정)가 생략된다는 점을 제외하면 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="translated">sqlite3_blocking_step () 함수에서 사용하는 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="translated">alternate-form-2 플래그는 우리가 아는 한 다른 printf () 구현에서는 나타나지 않는 비표준 확장입니다.</target>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="translated">대체 페이지 캐시 메커니즘은 가장 까다로운 응용 프로그램에서만 필요한 극단적 인 측정입니다. 내장 페이지 캐시는 대부분의 용도로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="translated">위에 표시된 대체 쿼리 공식은 개념적인 것입니다. SQLite는 실제로 쿼리를 변환하지 않습니다. 실제 쿼리 계획은 다음과 같습니다. SQLite는 &quot;people&quot;에 대한 첫 번째 가능한 값을 찾습니다. &quot;people_idx1&quot;인덱스를 처음으로 되 감고 첫 번째 레코드를 읽어서 수행 할 수 있습니다. SQLite는이 첫 번째 &quot;역할&quot;값을 &quot;$ role&quot;이라고하는 내부 변수에 저장합니다. 그런 다음 SQLite는 &quot;SELECT name FROM people WHERE role = $ role AND height&amp;gt; = 180&quot;과 같은 쿼리를 실행합니다. 이 쿼리는 인덱스의 가장 왼쪽 열에 동등 제약 조건이 있으므로 인덱스를 사용하여 해당 쿼리를 해결할 수 있습니다. 해당 쿼리가 완료되면 SQLite는 &quot;people_idx1&quot;인덱스를 사용하여 논리적으로 &quot;와 유사한 코드를 사용하여&quot;role &quot;열의 다음 값을 찾습니다.사람에서 역할 선택 역할 : $ role LIMIT 1 &quot;.이 새로운&quot;역할 &quot;값은 $ role 변수를 덮어 쓰고&quot;역할 &quot;에 대해 가능한 모든 값을 검사 할 때까지 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="translated">amalgamation 및 sqlite3.h 헤더 파일은 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 sqlite-amalgamation-X.zip 파일로 제공되며 여기서 X는 적절한 버전 번호로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="translated">합병에는 SQLite를 더 큰 프로젝트에 통합하는 데 필요한 모든 것이 포함되어 있습니다. 합병을 소스 디렉토리에 복사하고 프로젝트의 다른 C 코드 파일과 함께 컴파일하십시오. (A &lt;a href=&quot;howtocompile&quot;&gt;에 대한 자세한 설명&lt;/a&gt; 컴파일 과정이 가능합니다.) 또한 SQLite는 대한 프로그래밍 API를 정의하는 &quot;sqlite3.h&quot;헤더 파일을 사용하도록 할 수 있습니다. sqlite3.h 헤더 파일은 별도로 제공됩니다. sqlite3.h 파일은 처음 몇 천 줄의 합병 내에 포함되어 있습니다. 따라서 sqlite3.c의 사본이 있지만 sqlite3.h를 찾을 수없는 경우에는 항상 합병에서 복사하여 붙여 넣어 sqlite3.h를 다시 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="translated">오버 플로우 페이지에 유출되는 페이로드의 양은 페이지 유형에 따라 다릅니다. 다음 계산의 경우 U를 데이터베이스 페이지의 사용 가능한 크기로 설정하십시오. 총 페이지 크기는 각 페이지 끝의 예약 된 공간보다 작습니다. 그리고 P를 페이로드 크기로 둡니다. 다음에서 기호 X는 오버플로 페이지에 흘리지 않고 b- 트리 페이지에 직접 저장할 수있는 최대 페이로드 양을 나타내고 기호 M은 흘림이 허용되기 전에 btree 페이지에 저장해야하는 최소 페이로드 양을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="cc7c17ba1fc473503228a1ad5223b1322c93e902" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context (C, N)에 의해 할당 된 공간의 양은 첫 번째 성공적인 호출의 N 매개 변수에 의해 결정됩니다. 동일한 집계 함수 인스턴스 내에서 sqlite3_aggregate_context ()에 대한 후속 호출에서 N 값을 변경해도 메모리 할당 크기가 조정되지 않습니다. xFinal 콜백 내에서 sqlite3_aggregate_context (C, N)에 대한 호출에서 N = 0을 설정하여 무의미한 메모리 할당이 발생하지 않도록하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context (C, N)에 의해 할당 된 공간의 양은 첫 번째 성공적인 호출에서 N 매개 변수에 의해 결정됩니다. 동일한 집계 함수 인스턴스 내에서 sqlite3_aggregate_context ()에 대한 후속 호출에서 N 값을 변경하면 메모리 할당 크기가 조정되지 않습니다. xFinal 콜백 내에서 의미없는 메모리 할당이 발생하지 않도록 sqlite3_aggregate_context (C, N)에 대한 호출에서 N = 0을 설정하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="translated">Galaxy S3의 성능 테스트는 무작위이기 때문에 쓰기 실험의 안드로이드 성능 수치는 생략되었습니다. 동일한 실험을 두 번 연속 실행하면 시간이 크게 달라집니다. 그리고 공정하게 말하면 안드로이드에서 SQLite의 성능은 디스크에 직접 쓰는 것보다 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="translated">응용 프로그램 파일은 모든 운영 체제, 32 비트 및 64 비트 및 빅 앤 리틀 엔디안 아키텍처에서 이식 가능합니다.</target>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="translated">응용 프로그램 에서 FTS3 / 4 가상 테이블을 사용하지 않고 &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS 새도우 테이블을&lt;/a&gt; 직접 변경 하여 새도우 테이블이 서로 동기화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 sqlite3_exec ()에 대한 첫 번째 매개 변수가 유효하고 열린 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 sqlite3_exec ()에 대한 첫 번째 매개 변수가 유효하고 열린 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">애플리케이션은 리소스 누수를 피하기 위해 모든 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 완료해야합니다 . 응용 프로그램이 완료된 후 준비된 명령문을 사용하려고하면 심각한 오류입니다. 완료된 후 준비된 명령문을 사용하면 segfault 및 힙 손상과 같은 정의되지 않은 바람직하지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">애플리케이션은 리소스 누수를 피하기 위해 모든 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 완료해야합니다 . 응용 프로그램이 완료된 후 준비된 명령문을 사용하려고하면 심각한 오류입니다. 완료된 후 준비된 명령문을 사용하면 segfault 및 힙 손상과 같은 정의되지 않은 바람직하지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">sqlite3_exec ()가 실행되는 동안 응용 프로그램은 sqlite3_exec ()에 대한 첫 번째 매개 변수로 지정된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 닫아서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">sqlite3_exec ()가 실행되는 동안 응용 프로그램은 sqlite3_exec ()에 대한 첫 번째 매개 변수로 지정된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 닫아서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">sqlite3_exec ()가 실행되는 동안 응용 프로그램은 sqlite3_exec ()의 두 번째 매개 변수로 전달 된 SQL 문 텍스트를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()을&lt;/a&gt; 사용하여 릴리스 된 후 응용 프로그램은 메모리 블록의 일부를 읽거나 쓰지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 또는 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()을&lt;/a&gt; 사용하여 릴리스 된 후 응용 프로그램은 메모리 블록의 일부를 읽거나 쓰지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="translated">응용 프로그램은 전체 파일을 읽고 메모리에 완전한 구문 분석을 유지하는 대신 필요한 데이터 만로드하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">응용 프로그램은 sqlite3_os_init () 또는 sqlite3_os_end ()를 직접 호출해서는 안됩니다. 응용 프로그램은 sqlite3_initialize () 및 sqlite3_shutdown () 만 호출해야합니다. sqlite3_os_init () 인터페이스는 sqlite3_initialize ()에 의해 자동으로 호출되고 sqlite3_os_end ()는 sqlite3_shutdown ()에 의해 호출됩니다. sqlite3_os_init () 및 sqlite3_os_end ()에 대한 적절한 구현은 Unix, Windows 또는 OS / 2 용으로 컴파일 될 때 SQLite에 내장되어 있습니다. 때 &lt;a href=&quot;../custombuild&quot;&gt;다른 플랫폼 구축&lt;/a&gt; 합니다 (사용 &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt; 응용 프로그램 sqlite3_os_init ()와 sqlite3_os_end에 적합한 구현 ()를 제공해야합니다 컴파일시 옵션). sqlite3_os_init () 또는 sqlite3_os_end ()의 응용 프로그램 제공 구현은 성공 및 기타 일부에서 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴해야합니다.&lt;a href=&quot;../rescode&quot;&gt;&lt;/a&gt;실패시 오류 코드 .</target>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">응용 프로그램은 sqlite3_os_init () 또는 sqlite3_os_end ()를 직접 호출해서는 안됩니다. 응용 프로그램은 sqlite3_initialize () 및 sqlite3_shutdown () 만 호출해야합니다. sqlite3_os_init () 인터페이스는 sqlite3_initialize ()에 의해 자동으로 호출되고 sqlite3_os_end ()는 sqlite3_shutdown ()에 의해 호출됩니다. sqlite3_os_init () 및 sqlite3_os_end ()에 대한 적절한 구현은 Unix, Windows 또는 OS / 2 용으로 컴파일 될 때 SQLite에 내장되어 있습니다. 때 &lt;a href=&quot;custombuild&quot;&gt;다른 플랫폼 구축&lt;/a&gt; 합니다 (사용 &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt; 응용 프로그램 sqlite3_os_init ()와 sqlite3_os_end에 적합한 구현 ()를 제공해야합니다 컴파일시 옵션). sqlite3_os_init () 또는 sqlite3_os_end ()의 응용 프로그램 제공 구현은 성공 및 기타 일부에서 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴해야합니다.&lt;a href=&quot;rescode&quot;&gt;&lt;/a&gt;실패시 오류 코드 .</target>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="translated">응용 프로그램이 다른 프로세스가 데이터베이스 파일에 액세스하지 못하게하려고합니다.</target>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">application_id PRAGMA는 오프셋 68에있는 32 비트 부호있는 빅 엔디안 &quot;애플리케이션 ID&quot;정수를 쿼리하거나 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더에&lt;/a&gt; 설정하는 데 사용됩니다 . SQLite를 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하는 응용 프로그램은 &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1)&lt;/a&gt; 과 같은 유틸리티가 &quot;SQLite3 데이터베이스&quot;를보고하지 않고 특정 파일 형식을 결정할 수 있도록 응용 프로그램 ID 정수를 고유 정수로 설정해야합니다 . SQLite 소스 저장소 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; 파일 을 참조하여 지정된 애플리케이션 ID 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="translated">이 데이터베이스를 사용하는 응용 프로그램은 응용 프로그램의 각 행에 대해</target>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="translated">argc 매개 변수는 argv 배열의 항목 수를 지정합니다. 순수 삭제 조작의 경우 argc 값은 1이고 삽입 또는 바꾸기 또는 업데이트의 경우 N + 2입니다. 여기서 N은 테이블의 열 수입니다. 이전 문장에서 N은 숨겨진 열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="translated">인수 N은 메모리 매핑 된 I / O를 사용하여 액세스 할 데이터베이스 파일의 최대 바이트 수입니다. N이 0이면 메모리 매핑 된 I / O가 비활성화됩니다. N이 음수 인 경우 한계는 가장 최근의 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; )에 의해 결정된 기본값 또는 시작 시간 한계가 설정되지 않은 경우 &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE에&lt;/a&gt; 의해 결정된 컴파일 시간 기본값으로 되돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="7500855ec2b0357e501bb580486bc273725ede2e" translate="yes" xml:space="preserve">
          <source>The argument can be either the text of an SQL statement, in which case the bytecode (or tables_used) for that statement is returned, or the argument can be a parameter such as ?1 or $stmt that is later bound to a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. Use a pointer type of &quot;stmt-pointer&quot; for the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface.</source>
          <target state="translated">인수는 SQL 문의 텍스트 일 ​​수 있으며,이 경우 해당 명령문에 대한 바이트 코드 (또는 tables_used)가 리턴되거나 나중에 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트에 바인드되는? 1 또는 $ stmt와 같은 매개 변수가 될 수 있습니다. &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 인터페이스를 사용합니다 . &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 인터페이스 에 &quot;stmt-pointer&quot;의 포인터 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="translated">인수는 10 진수로 표시되는 double입니다.</target>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="translated">인수는 보통 십진수 표기법으로 표시되거나 지수가 0에 가깝지 않은 경우 지수 표기법으로 표시되는 double입니다.</target>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="translated">인수는 지수 표기법으로 표시되는 double입니다. 지수 문자는 유형에 따라 'e'또는 'E'입니다.</target>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="translated">인수는 정수에 대한 포인터입니다. 이 대체 유형에 대해서는 아무것도 표시되지 않습니다. 대신 인수가 가리키는 정수는 생성 된 문자열에서 % n의 왼쪽에있는 모든 형식 기호의 결과 인 문자 수로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="translated">인수는 16 진 주소로 표시되는 포인터입니다. SQL 언어에는 포인터 개념이 없으므로 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf () SQL 함수&lt;/a&gt; 의 % p 대체 % x와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="translated">인수는 부호있는 정수이며 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="translated">인수는 0으로 끝나는 문자열입니다. C 언어 인터페이스의 % z 유형의 경우 &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 문자열이 출력으로 복사 된 후 문자열에서 호출됩니다. % s 및 % z 대체는 SQL printf () 함수에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="translated">인수는 0으로 끝나는 문자열입니다. 문자열은 모든 작은 따옴표 ( ') 문자가 두 배로 인쇄되어 문자열이 SQL 문자열 리터럴 안에 안전하게 나타날 수 있습니다. % Q 대체 유형은 또한 대체 문자열의 양쪽 끝에 작은 따옴표를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="translated">인수는 16 진으로 표시되는 정수입니다. 소문자 16 진수는 % x에 사용되고 대문자는 % X에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="translated">인수는 8 진수로 표시되는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="translated">인수는 부호없는 정수이며 10 진수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="translated">인수는 원하는 VFS의 기호 이름입니다. 인수가 NULL 포인터이면 기본 VFS가 리턴됩니다. 이 함수는 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs에&lt;/a&gt; 대한 포인터를 반환합니다 VFS를 구현하는 객체에 . 또는 검색 기준과 일치하는 개체를 찾을 수 없으면 NULL 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="translated">URI 파일 이름이 사용 가능한 경우 INTO에 대한 인수는 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 일 수 있습니다 . 다음 중 하나라도 해당되면 URL 파일 이름이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="translated">제한 시간 메소드에 대한 인수는 잠금이 해제 될 때까지 대기하는 최대 밀리 초 수입니다. 위의 예에서 최대 지연은 2 초입니다.</target>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="translated">&quot;tokenchars =&quot;또는 &quot;separators =&quot;옵션에 전달 된 인수는 대소 문자를 구분합니다. 위의 예에서 &quot;X&quot;를 구분 기호 문자로 지정해도 &quot;x&quot;처리 방식에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="translated">의 인수 &lt;b&gt;sqlite_busy_handler는&lt;/b&gt; 반환 된 불투명 한 구조이다 &lt;b&gt;sqlite_open&lt;/b&gt; , 바쁜 콜백 함수에 대한 포인터, 그리고 바쁜 콜백에 첫 번째 인수로 전달됩니다 일반적인 포인터. SQLite는 통화 중 콜백을 호출 할 때 세 개의 인수 , 즉 &lt;b&gt;sqlite_busy_handler에&lt;/b&gt; 세 번째 인수로 전달 된 일반 포인터 , 라이브러리가 액세스하려는 데이터베이스 테이블 또는 인덱스의 이름 및 라이브러리가 데이터베이스 테이블 또는 인덱스에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="translated">argv [0] 매개 변수는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid입니다&lt;/a&gt; 삭제할 가상 테이블에서 행 입니다. argv [0]이 SQL NULL이면 삭제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="translated">argv [1] 매개 변수는 가상 테이블에 삽입 할 새 행의 rowid입니다. argv [1]이 SQL NULL 인 경우 구현은 새로 삽입 된 행의 rowid를 선택해야합니다. 후속 argv [] 항목에는 가상 테이블의 열 값이 열이 선언 된 순서대로 포함됩니다. 열 수는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메소드가 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 호출을 사용하여 작성한 테이블 선언과 ​​일치합니다 . 모든 숨겨진 열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="translated">&quot;*&quot;로 표시된 작은 원의 화살표는 종속성없이 각 루프를 실행하는 비용을 나타냅니다. 외부 루프는이 * -cost를 사용해야합니다. 내부 루프는 다른 용어 중 하나가 외부 루프에 있다고 가정하면 *-비용 또는 비용을 사용할 수 있습니다. * 비용은 그래프의 다른 노드들 각각에서 하나의 다중 호를 나타내는 속기 표기법으로 생각할 수 있습니다. 따라서 그래프는 &quot;완료&quot;입니다. 즉, 그래프의 모든 노드 쌍 사이에 양방향으로 호 (일부 명시 적 및 묵시적)가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="translated">assert (X) 매크로는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;표준 C의 일부입니다&lt;/a&gt; &amp;lt;assert.h&amp;gt; 헤더 파일에서 . SQLite는 NEVER (X), ALWAYS (X) 및 testcase (X)라는 3 개의 다른 assert ()와 유사한 매크로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="translated">비동기 I / O VFS는 API 함수 sqlite3async_initialize () 및 sqlite3async_shutdown ()을 호출하여 등록 (및 등록 취소)됩니다. 자세한 내용은 &quot;컴파일 및 사용법&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="translated">비동기 IO VFS API는 sqlite3async.h의 주석에 자세히 설명되어 있습니다. API 사용은 일반적으로 다음 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">비동기 IO 확장은 C 파일의 단일 파일 (sqlite3async.c)과 &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; &lt;/a&gt; 하위 폴더에 있는 헤더 파일 (sqlite3async.h)로 구성됩니다. SQLite 소스 트리 에 , 이는 애플리케이션에서 사용하는 C API를 정의합니다. 모듈 기능을 활성화하고 제어합니다.</target>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="translated">이 테스트에서 비동기 SQLite는 MySQL보다 약간 느립니다. (MySQL은 특히 INSERT ... SELECT 문에 능숙한 것 같습니다.) PostgreSQL 엔진은 여전히 ​​작동 중입니다. 사용 된 61 초의 대부분은 디스크 I / O를 기다리는 데 소비되었습니다.</target>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="translated">SQLite의 원자 커밋 메커니즘은 강력한 것으로 입증되었지만 충분히 독창적 인 공격자 또는 충분히 깨진 운영 체제 구현으로 피할 수 있습니다. 이 섹션에서는 정전 또는 시스템 충돌로 인해 SQLite 데이터베이스가 손상 될 수있는 몇 가지 방법에 대해 설명합니다. (또한 &lt;a href=&quot;howtocorrupt&quot;&gt;데이터베이스 파일을 손상시키는 방법&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="be392afd276ea778d7374d96f033564d6dcc8ac2" translate="yes" xml:space="preserve">
          <source>The attacker can submit a maliciously crafted database file to the application that the application will then open and query.</source>
          <target state="translated">공격자는 악의적으로 제작 된 데이터베이스 파일을 응용 프로그램이 열고 쿼리 할 응용 프로그램에 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4da2591e4ae0c979cba5f61016108bf072266c8" translate="yes" xml:space="preserve">
          <source>The attacker can submit and run arbitrary SQL statements.</source>
          <target state="translated">공격자는 임의의 SQL 문을 제출하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="translated">Lemon and SQLite (Hipp)의 저자는 John Ousterhout의 원본 소스 코드를 Tcl로 연구함으로써 그의 C 프로그래밍 기술이 크게 향상되었다고보고했다. Hipp는 1993 년에 Tcl을 발견하고 연구했습니다. 레몬은 그 전에 쓰여졌 고 그 이후에는 SQLite입니다. 이 두 제품의 코딩 스타일에는 분명한 차이가 있으며, SQLite는보다 깨끗하고 읽기 쉽고 유지 관리가 용이 ​​해 보입니다.</target>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="translated">권한은 생략되거나 비어 있거나 &quot; &lt;code&gt;localhost&lt;/code&gt; &quot; 일 수 있습니다 . 다른 권한이 있으면 오류가 발생합니다. 예외 : SQLite가 &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; 로 컴파일 된 경우 &quot;localhost&quot;이외의 권한 값은 기본 운영 체제에 UNC 파일 이름으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">권한 부 여자 콜백은 권한 부 여자 콜백을 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 참고 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_step&quot;&gt;() sqlite3_step를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">권한 부 여자 콜백은 권한 부 여자 콜백을 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 참고 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma를&lt;/a&gt; 사용하여 런타임시 자동 색인 기능을 비활성화 할 수 있습니다 . 자동 인덱싱은 기본적으로 켜져 있지만 &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; 컴파일 타임 옵션을 사용하여 자동 인덱싱을 해제하도록 변경할 수 있습니다 . &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일하여 자동 인덱스 작성 기능을 완전히 사용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="translated">avg () 함수는 NULL이 아닌 모든 값의 평균값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="translated">b- 트리 알고리즘은 페이지 지향 저장 장치에서 고유 한 순서 키를 사용하여 키 / 데이터 저장 장치를 제공합니다. b- 트리에 대한 배경 정보는 Knuth, &lt;u&gt;컴퓨터 프로그래밍 기술&lt;/u&gt; , 제 3 권 &quot;정렬 및 검색&quot;, 471-479 페이지를 참조하십시오. SQLite는 두 종류의 b- 트리를 사용합니다. Knuth가 &quot;B * -Tree&quot;라고 부르는 알고리즘은 모든 데이터를 트리의 잎에 저장합니다. SQLite는 이러한 다양한 b- 트리를 &quot;테이블 b- 트리&quot;라고 부릅니다. Knuth가 단순히 &quot;B-Tree&quot;라고 부르는 알고리즘은 키와 데이터를 함께 잎과 내부 페이지에 모두 저장합니다. SQLite 구현에서 원래 B-Tree 알고리즘은 키만 저장하고 데이터를 완전히 생략하며 &quot;인덱스 b- 트리&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="d112311c7e2ccc4f400060b3e5337023ffd30dd4" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two variants of b-trees are used by SQLite. &quot;Table b-trees&quot; use a 64-bit signed integer key and store all data in the leaves. &quot;Index b-trees&quot; use arbitrary keys and store no data at all.</source>
          <target state="translated">b-tree 알고리즘은 페이지 지향 저장 장치에서 고유하고 순서가 지정된 키로 키 / 데이터 저장을 제공합니다. b- 트리에 대한 배경 정보는 Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt; , Volume 3 &quot;Sorting and Searching&quot;, 페이지 471-479를 참조하십시오. SQLite는 b- 트리의 두 가지 변형을 사용합니다. &quot;테이블 b- 트리&quot;는 64 비트 부호있는 정수 키를 사용하고 모든 데이터를 잎에 저장합니다. &quot;인덱스 b- 트리&quot;는 임의의 키를 사용하고 데이터를 전혀 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="translated">b- 트리 페이지 헤더의 크기는 리프 페이지의 경우 8 바이트이고 내부 페이지의 경우 12 바이트입니다. 페이지 헤더의 모든 멀티 바이트 값은 빅 엔디안입니다. b- 트리 페이지 헤더는 다음 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="translated">백업 API는 한 데이터베이스의 내용을 다른 데이터베이스로 복사합니다. 데이터베이스 백업을 작성하거나 인 메모리 데이터베이스를 영구 파일로 복사하거나 영구 파일에서 복사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="translated">backupDb () 함수는 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () 함수를 사용하여 사용자 제공 xProgress () 콜백을 통해 진행 상황을보고합니다. sqlite3_backup_remaining () 함수는 복사 할 남은 페이지 수를 리턴하고 sqlite3_backup_pagecount ()는 소스 데이터베이스 (이 경우 pDb가 연 데이터베이스)의 총 페이지 수를 리턴합니다. 따라서 프로세스 완료율은 다음과 같이 계산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="translated">기본 창은 프레임 사양을 지정하지 않을 수 있습니다. 프레임 사양은 새 창 사양에서만 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="translated">재귀 테이블의 내용을 계산하는 기본 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="translated">위에서 설명한 기본 원칙은 일반 rowid 테이블과 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 모두에 적용됩니다 . 유일한 차이점은 테이블의 키 역할을하고 인덱스에서 가장 오른쪽에있는 rowid 열이 PRIMARY KEY로 교체된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="translated">위의 기본 절차는 다음 추가 규칙에 의해 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="translated">AUTOINCREMENT 키워드로 구현 된 동작은 기본 동작과 약간 다릅니다. AUTOINCREMENT를 사용하면 자동으로 선택된 ROWID가있는 행은 동일한 데이터베이스의 동일한 테이블에서 이전에 사용 된 적이없는 ROWID를 갖습니다. 그리고 자동으로 생성 된 ROWID는 단조 증가합니다. 이들은 특정 응용 프로그램에서 중요한 속성입니다. 그러나 응용 프로그램에 이러한 속성이 필요하지 않은 경우 AUTOINCREMENT를 사용하려면 각 행이 삽입 될 때 추가 작업을 수행해야하므로 INSERT가 약간 느리게 실행되므로 기본 동작을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="translated">음수가 N 인 cache_size의 동작은 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; 이전에 다릅니다. (2012-01-16) . 이전 버전에서 캐시의 페이지 수는 절대 값 N으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2 ()의 동작과 그에 상응하는 스트리밍은 &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;지원되는 플래그&lt;/a&gt; 의 조합을 9 번째 매개 변수로 전달하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2 ()의 동작과 그에 상응하는 스트리밍은 &lt;a href=&quot;c_changesetapply_invert&quot;&gt;지원되는 플래그&lt;/a&gt; 의 조합을 9 번째 매개 변수로 전달하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2 ()의 동작과 동등한 스트리밍은 &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;지원되는 플래그&lt;/a&gt; 의 조합을 4 번째 매개 변수로 전달하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2 ()의 동작과 동등한 스트리밍은 &lt;a href=&quot;c_changesetstart_invert&quot;&gt;지원되는 플래그&lt;/a&gt; 의 조합을 4 번째 매개 변수로 전달하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma를 사용하여 격리 수준을 serialized (기본값)에서 read-uncommitted로 변경 하여 위에서 설명한 동작을 약간 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="translated">열 필터가 FTS 쿼리의 일부로 지정되고 열을 MATCH 연산자의 LHS로 사용하는 경우 쿼리의 동작은 약간 다릅니다. &quot;a&quot;및 &quot;b&quot;열이 있고 다음과 유사한 쿼리가있는 테이블의 경우 :</target>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="translated">SQLite 데이터베이스의 안정적인 백업 복사본을 만드는 가장 좋은 방법 은 SQLite 라이브러리의 일부인 &lt;a href=&quot;backup&quot;&gt;백업 API&lt;/a&gt; 를 사용 하는 것입니다. 실패하면 프로세스에서 진행중인 트랜잭션이없는 한 SQLite 데이터베이스 파일의 복사본을 만드는 것이 안전합니다. 이전 트랜잭션이 실패한 경우 롤백 저널 ( &lt;code&gt;*-journal&lt;/code&gt; 파일) 또는 미리 쓰기 로그 ( &lt;code&gt;*-wal&lt;/code&gt; 파일)를 데이터베이스 파일 자체와 함께 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="translated">에서 SQL의 가장 큰 특징 ( &lt;u&gt;모든&lt;/u&gt; SQLite뿐만 아니라 구현에서)</target>
        </trans-unit>
        <trans-unit id="0acc0c4a6e57763a2a98687d8dd5dae3b2f9935e" translate="yes" xml:space="preserve">
          <source>The best way to understand how SQL database engines work is to think of SQL as a programming language, not as a &quot;query language&quot;. Each SQL statement is a separate program. Applications construct SQL program source files and send them to the database engine. The database engine compiles the SQL source code into executable form, runs that executable, then sends the result back to the application.</source>
          <target state="translated">SQL 데이터베이스 엔진의 작동 방식을 이해하는 가장 좋은 방법은 SQL을 &quot;쿼리 언어&quot;가 아닌 프로그래밍 언어로 생각하는 것입니다. 각 SQL 문은 별도의 프로그램입니다. 애플리케이션은 SQL 프로그램 소스 파일을 구성하여 데이터베이스 엔진으로 보냅니다. 데이터베이스 엔진은 SQL 소스 코드를 실행 가능한 형식으로 컴파일하고 해당 실행 파일을 실행 한 다음 결과를 다시 응용 프로그램으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d79f775859b5387594a0b408b014948f69145bb6" translate="yes" xml:space="preserve">
          <source>The binary64 floating-point format uses 64 bits per number. Hence there are 1.845e+19 different possible floating point values. On the other hand there are infinitely many real numbers in the range of 1.7977e+308 and 4.9407e-324. It follows then that binary64 cannot possibly represent all possible real numbers within that range. Approximations are required.</source>
          <target state="translated">binary64 부동 소수점 형식은 숫자 당 64 비트를 사용합니다. 따라서 1.845e + 19 개의 다른 가능한 부동 소수점 값이 있습니다. 반면에 1.7977e + 308 및 4.9407e-324 범위에는 무한히 많은 실수가 있습니다. 그런 다음 binary64는 해당 범위 내에서 가능한 모든 실수를 나타낼 수 없습니다. 근사치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="translated">위의 블록은 단축 형식을 사용하여 외래 키 제약 조건을 만듭니다. &quot;참조&quot;첨부</target>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="translated">이 세그먼트 b- 트리에 속하는 가장 큰 blockid를 가진 리프 노드에 해당하는 blockid입니다. 전체 세그먼트 b- 트리가 루트 노드에 맞는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="translated">이 세그먼트 b- 트리에 속하는 가장 작은 blockid를 가진 노드에 해당하는 blockid입니다. 전체 세그먼트 b- 트리가 루트 노드에 맞는 경우 0입니다. 존재하는 경우이 노드는 항상 리프 노드입니다.</target>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="translated">부울 식별자 TRUE 및 FALSE는 일반적으로 각각 정수 값 1과 0에 대한 별칭 일뿐입니다. 그러나 TRUE 또는 FALSE가 IS 연산자의 오른쪽에 있으면 왼쪽에있는 피연산자의 부울 값을 테스트하는 새로운 단항 접두사 연산자 &quot;IS TRUE&quot;및 &quot;IS FALSE&quot;를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="translated">파일 형식과 응용 프로그램 형식 사이의 경계가 흐립니다. 이 기사에서는 JPEG를 파일 형식이라고하지만 이미지 편집기의 경우 JPEG를 응용 프로그램 형식으로 간주 할 수 있습니다. 상황에 따라 다릅니다. 이 기사에서는 파일 형식이 단일 개체를 저장하고 응용 프로그램 형식이 다양한 개체와 서로의 관계를 저장한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="translated">경계 설명 &quot;0 PRECEDING&quot;은 항상 &quot;CURRENT ROW&quot;와 동일한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="translated">빌드 프로세스는 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; 스크립팅 언어를 광범위하게 사용 합니다. 위의 make 대상이 작동하려면 TCL 사본이 설치되어 있어야합니다. 사용하기 쉬운 설치 프로그램은 &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt; 에서 얻을 수 있습니다 . . 많은 유닉스 워크 스테이션에는 기본적으로 Tcl이 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4e60a19016fc83307d1ede2e1aa59927cbae39" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif(x,y,z) SQL function&lt;/a&gt; is logically equivalent to &quot;CASE WHEN x THEN y ELSE z END&quot;. The iif() function is found in SQL Server and is included in SQLite for compatibility. Some developers prefer the iif() function because it is more concise.</source>
          <target state="translated">내장 &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif (x, y, z) SQL 함수&lt;/a&gt; 는 논리적으로 &quot;CASE WHEN x THEN y ELSE z END&quot;와 동일합니다. iif () 함수는 SQL Server에 있으며 호환성을 위해 SQLite에 포함되어 있습니다. 일부 개발자는 더 간결하기 때문에 iif () 함수를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">(가) 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 가에서 사용할 수 있도록 개선되었습니다 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 에서, &lt;a href=&quot;expridx&quot;&gt;표현의 인덱스&lt;/a&gt; 와에서의 조항 어디 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; , 그들은 '지금', '의 현지을'사용하지 않는 것이 제공 또는 'utc'키워드. &lt;a href=&quot;deterministic#dtexception&quot;&gt;자세한 정보&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2f201a6d744f00508ed72b40ed46b5c83f60f1" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allowed.</source>
          <target state="translated">SQLite 의 기본 제공 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 특별한 경우입니다. 이러한 함수는 일반적으로 결정적인 것으로 간주됩니다. 그러나 이러한 함수가 &quot;now&quot;문자열을 날짜로 사용하거나 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정 자&lt;/a&gt; 또는 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc 수정 &lt;/a&gt;자를 사용하는 경우 비 결정적인 것으로 간주됩니다. 함수 입력은 런타임까지 알 필요가 없기 때문에 날짜 / 시간 함수는 결정적 함수 만 허용되는 컨텍스트에서 비 결정적 기능을 만나면 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="translated">SQLite 의 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 특별한 경우입니다. 이러한 기능은 일반적으로 결정적인 것으로 간주됩니다. 그러나 이러한 함수가 &quot;now&quot;문자열을 날짜로 사용하거나 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정 자&lt;/a&gt; 또는 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc 수정 &lt;/a&gt;자를 사용하는 경우 결정적이지 않은 것으로 간주됩니다. 함수 입력은 런타임까지 반드시 알려질 필요는 없으므로 결정적 함수 만 허용되는 컨텍스트에서 비 결정적 기능을 발견하면 날짜 / 시간 함수에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="translated">SQLite 의 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 위의 모든 형식의 날짜 / 시간을 이해하며 자유롭게 변경할 수 있습니다. 사용하는 형식은 전적으로 응용 프로그램에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="translated">내장 된 BINARY 데이터 정렬은 표준 C 라이브러리의 memcmp () 함수를 사용하여 문자열을 바이트 단위로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="translated">내장 SQLite에는 printf () 기능을 신뢰할 수없는 사용자에게 노출시키는 응용 프로그램에 대한 서비스 거부 공격에 대한 방어를 제공하는 SQLITE_PRINTF_PRECISION_LIMIT와 같은 컴파일 타임 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="translated">가중치가 고정 된 내장 Wagner edit-distance 함수 는 &quot;edit_cost_table =&quot;을 지정하여 애플리케이션 정의 가중치 및 유니 코드를 지원 하는 &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3 ()&lt;/a&gt; edit-distance 함수 로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="translated">내장 보조 함수 bm25 ()는 현재 행이 전체 텍스트 쿼리와 얼마나 일치하는지 나타내는 실제 값을 반환합니다. 일치하는 것이 좋을수록 반환되는 값이 더 작습니다. 다음과 같은 쿼리를 사용하여 일치 항목을 가장 좋은 항목에서 가장 나쁜 항목으로 순서대로 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="translated">FTS5의 일부로 제공되는 내장 보조 기능은 다음 섹션에 설명되어 있습니다. 응용 프로그램은 &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;C에서 사용자 정의 보조 기능을&lt;/a&gt; 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">LIKE 및 GLOB를 구현하는 데 사용 된 내장 함수는 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; API를 사용하여 과부하되지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="translated">SQLite의 내장 메모리 할당자는 다음과 같은 추가 인터페이스도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="translated">내장 min () 및 max () 함수는 이제 NUMERIC과 TEXT 데이터 유형의 차이점을 존중합니다. 이전에는 min () 및 max ()가 항상 인수가 NUMERIC 유형 인 것으로 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="translated">내장 printf () 구현은 printf ()에 대한 인수 순서가 %-치환 순서와 다를 수 있도록하는 posix 위치 참조 수정자를 처리하지 않습니다. 내장 printf ()에서 인수의 순서는 %-치환의 순서와 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="translated">내장 printf () 구현은 추가 코드 공간 (GCC 5.4에서 -O를 사용하여 약 7800 바이트)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="translated">이 문서에 설명 된 내장 토크 나이저 및 보조 기능은 모두 아래 설명 된 공개 API를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="translated">사용 중 콜백은 사용 중 핸들러를 호출 한 데이터베이스 연결을 수정하는 조치를 수행하지 않아야합니다. 즉, 사용중인 처리기가 재진입되지 않습니다. 이러한 조치는 정의되지 않은 동작을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="translated">열 내에서 일치하는 용어의 바이트 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="05f015bc1e7204efce9fc81ea976f5bbb81740a9" translate="yes" xml:space="preserve">
          <source>The byte-order of UTF16 input text is determined by the byte-order mark (BOM, U+FEFF) found in first character, which is removed, or in the absence of a BOM the byte order is the native byte order of the host machine for sqlite3_bind_text16() or the byte order specified in the 6th parameter for sqlite3_bind_text64(). If UTF16 input text contains invalid unicode characters, then SQLite might change those invalid characters into the unicode replacement character: U+FFFD.</source>
          <target state="translated">UTF16 입력 텍스트의 바이트 순서는 제거 된 첫 번째 문자에서 찾은 바이트 순서 표시 (BOM, U + FEFF)에 의해 결정됩니다. 또는 BOM이없는 경우 바이트 순서는 호스트의 기본 바이트 순서입니다. sqlite3_bind_text16 () 또는 sqlite3_bind_text64 ()의 6 번째 매개 변수에 지정된 바이트 순서. UTF16 입력 텍스트에 잘못된 유니 코드 문자가 포함 된 경우 SQLite는 이러한 잘못된 문자를 유니 코드 대체 문자 인 U + FFFD로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f568127fbaa97f70cb703194692bb7bd81d899e" translate="yes" xml:space="preserve">
          <source>The bytecode and tables_used tables are only available if SQLite has been compiled with the &lt;a href=&quot;compile#enable_bytecode_vtab&quot;&gt;-DSQLITE_ENABLE_BYTECODE_VTAB&lt;/a&gt; compile-time option. The &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; has been compiled that way, and so you can use the standard &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; as a test platform to experiement.</source>
          <target state="translated">bytecode 및 tables_used 테이블은 SQLite가 &lt;a href=&quot;compile#enable_bytecode_vtab&quot;&gt;-DSQLITE_ENABLE_BYTECODE_VTAB&lt;/a&gt; 컴파일 시간 옵션 으로 컴파일 된 경우에만 사용할 수 있습니다. &lt;a href=&quot;cli&quot;&gt;CLI는&lt;/a&gt; 당신이 표준 사용할 수 있도록 그 방법을 컴파일하고있다 &lt;a href=&quot;cli&quot;&gt;CLI를&lt;/a&gt; 실험실 기능에 대한 테스트 플랫폼으로.</target>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="translated">바이트 코드 엔진은 명령 번호 0에서 실행을 시작합니다. &lt;a href=&quot;opcode#Halt&quot;&gt;중지&lt;/a&gt; 명령이 표시 될 때까지 또는 프로그램 카운터가 마지막 명령의 주소보다 커질 때까지 또는 오류가 발생할 때까지 실행이 계속 됩니다. 바이트 코드 엔진이 정지되면 할당 된 모든 메모리가 해제되고 열려 있던 모든 데이터베이스 커서가 닫힙니다. 오류로 인해 실행이 중지되면 보류중인 트랜잭션이 종료되고 데이터베이스에 대한 변경 사항이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="translated">바이트 코드 엔진에는 서브 루틴의 리턴 주소를 저장할 스택이 없습니다. 반송 주소는 레지스터에 저장해야합니다. 따라서 바이트 코드 서브 루틴은 재진입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="translated">바이트 코드 엔진은 SQLite의 API 가 &lt;u&gt;아닙니다&lt;/u&gt; . 바이트 코드 엔진에 대한 세부 사항은 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. SQLite를 사용하는 응용 프로그램은이 문서에있는 세부 사항에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e552468adf820f25d29531e1e14d99733690b86b" translate="yes" xml:space="preserve">
          <source>The bytecode generated by the code generator is called a &quot;&lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;&quot;. Translating SQL source text into a prepared statement is analogous to converting a C++ program into machine code by invoking gcc or clang. Human-readable source text (SQL or C++) goes in, and a machine readable executable (bytecode or machine code) comes out.</source>
          <target state="translated">코드 생성기에 의해 생성 된 바이트 코드를 &quot; &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; &quot;이라고합니다. SQL 소스 텍스트를 준비된 명령문으로 변환하는 것은 gcc 또는 clang을 호출하여 C ++ 프로그램을 기계어 코드로 변환하는 것과 유사합니다. 사람이 읽을 수있는 소스 텍스트 (SQL 또는 C ++)가 들어가고 기계가 읽을 수있는 실행 파일 (바이트 코드 또는 기계 코드)이 나옵니다.</target>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="translated">바이트 코드 가상 머신은 SQLite의 핵심입니다. SQLite의 내부 작동 방식을 이해하려는 프로그래머는 바이트 코드 엔진에 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="translated">cFrom 및 cTo 열에는 편집 변환 문자열이 표시됩니다. 두 열 중 하나 또는 둘 다에 둘 이상의 문자가 포함될 수 있습니다. 또는 두 열 중 하나만 빈 문자열을 보유 할 수 있습니다. cFrom이 비어 있으면 cTo를 삽입하는 비용입니다. cTo가 비어 있으면 cFrom을 삭제하는 비용입니다.</target>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="translated">캐시는 참조 카운트를 수행하지 않아야합니다. xUnpin ()에 대한 단일 호출은 xFetch ()에 대한 이전 호출 수에 관계없이 페이지를 고정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="translated">캐시 쿼리 매개 변수는 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드를 사용&lt;/a&gt; 하거나 개인 캐시를 사용하여 새 데이터베이스를 열지 여부를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="3b1d92f7c11891a9dfcf8a02bdb8e1d1b67e45d9" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">이 인터페이스에 의해 설정된 캐시 공유 모드는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 모든 후속 호출에 영향을줍니다 . 기존 데이터베이스 연결은 열렸을 때 적용되었던 공유 모드를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">이 인터페이스에서 설정 한 캐시 공유 모드는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 모든 후속 호출에 영향을줍니다 . 기존 데이터베이스 연결은 열린 시점에 유효한 공유 모드를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="84568a531cbb8fea84a45d0e913a15a98ad6bdd3" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">이 인터페이스에 의해 설정된 캐시 공유 모드는 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 모든 후속 호출에 영향을줍니다 . 기존 데이터베이스 연결은 열렸을 때 적용되었던 공유 모드를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">이 인터페이스에서 설정 한 캐시 공유 모드는 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()에&lt;/a&gt; 대한 모든 후속 호출에 영향을줍니다 . 기존 데이터베이스 연결은 열린 시점에 유효한 공유 모드를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="translated">cache-flush 메소드는 현재 캐시에있는 모든 준비된 명령문을 &lt;a href=&quot;c3ref/finalize&quot;&gt;마무리&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="translated">cache_spill pragma는 호출기에서 더티 캐시 페이지를 트랜잭션 중간에 데이터베이스 파일에 엎 지르는 기능을 활성화 또는 비활성화합니다. Cache_spill은 기본적으로 활성화되어 있으며 대부분의 응용 프로그램은 일반적으로 캐시 유출이 유리하므로 이러한 방식으로 두어야합니다. 그러나 캐시 유출은 데이터베이스 파일에 대한 &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;독점 잠금&lt;/a&gt; 을 획득하는 부작용이 있습니다. 따라서 오래 실행되는 트랜잭션이 많은 일부 응용 프로그램은 트랜잭션이 &lt;a href=&quot;lang_transaction&quot;&gt;커밋&lt;/a&gt; 될 때까지 응용 프로그램이 데이터베이스에 대한 독점 잠금을 획득하지 못하도록 캐시 유출을 비활성화하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="translated">콜백 함수는 쿼리 결과를받는 데 사용됩니다. 콜백 함수의 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">sqlite3_profile ()에 의해 등록 된 콜백 함수는 각 SQL 문이 완료 될 때 호출됩니다. 프로파일 콜백에는 원래 명령문 텍스트와 해당 명령문을 실행하는 데 걸린 시간의 벽시계 시간 추정치가 포함됩니다. 프로파일 콜백 시간은 나노초 단위이지만 현재 구현은 밀리 초 해상도 만 가능하므로 시간에서 가장 작은 6 자리 숫자는 의미가 없습니다. 이후 버전의 SQLite는 프로파일 러 콜백에서 더 큰 해상도를 제공 할 수 있습니다. 중 하나를 호출 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2은 ()&lt;/a&gt; 프로필 콜백을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">sqlite3_profile ()에 의해 등록 된 콜백 함수는 각 SQL 문이 완료 될 때 호출됩니다. 프로파일 콜백에는 원래 명령문 텍스트와 해당 명령문을 실행하는 데 걸린 시간의 벽시계 시간 추정치가 포함됩니다. 프로파일 콜백 시간은 나노초 단위이지만 현재 구현은 밀리 초 해상도 만 가능하므로 시간에서 가장 작은 6 자리 숫자는 의미가 없습니다. 이후 버전의 SQLite는 프로파일 러 콜백에서 더 큰 해상도를 제공 할 수 있습니다. 중 하나를 호출 &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 또는 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2은 ()&lt;/a&gt; 프로필 콜백을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">SQL 문에 의해 실행되고있을 때 sqlite3_trace에 의해 등록 된 콜백 함수 ()를 여러 번 호출 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; . 명령문이 처음 실행되기 시작하면 sqlite3_trace () 콜백이 SQL 문 텍스트의 UTF-8 렌더링으로 호출됩니다. 트리거 된 각 서브 프로그램이 입력 될 때 추가 sqlite3_trace () 콜백이 발생할 수 있습니다. 트리거의 콜백에는 트리거를 식별하는 UTF-8 SQL 주석이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">SQL 문에 의해 실행되고있을 때 sqlite3_trace에 의해 등록 된 콜백 함수 ()를 여러 번 호출 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; . 명령문이 처음 실행되기 시작하면 sqlite3_trace () 콜백이 SQL 문 텍스트의 UTF-8 렌더링으로 호출됩니다. 트리거 된 각 서브 프로그램이 입력 될 때 추가 sqlite3_trace () 콜백이 발생할 수 있습니다. 트리거의 콜백에는 트리거를 식별하는 UTF-8 SQL 주석이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="translated">콜백 함수는 일반적으로 0을 반환해야합니다. 콜백 함수가 0이 아닌 값을 반환하면 쿼리가 즉시 중단되고 &lt;b&gt;sqlite_exec&lt;/b&gt; 는 &lt;b&gt;SQLITE_ABORT&lt;/b&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">콜백 함수는 일반적으로 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 반환해야합니다 . 오류 코드가 리턴되면 해당 오류는 SQLite 코드 기반을 통해 다시 전파되어 커미트가 여전히 발생하더라도 콜백을 유발 한 명령문이 오류를보고하게합니다. 콜백이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 유효한 SQLite 오류 코드에 해당하지 않는 값을 리턴하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">콜백 함수는 일반적으로 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 반환해야합니다 . 오류 코드가 리턴되면 해당 오류는 SQLite 코드 기반을 통해 다시 전파되어 커미트가 여전히 발생하더라도 콜백을 유발 한 명령문이 오류를보고하게합니다. 콜백이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 유효한 SQLite 오류 코드에 해당하지 않는 값을 리턴하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">콜백 함수는 &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2 ()를&lt;/a&gt; 사용하여 원하는 데이터 정렬을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">콜백 함수는 &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; 또는 &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2 ()를&lt;/a&gt; 사용하여 원하는 데이터 정렬을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">커밋이 수행되고 데이터베이스에서 관련 쓰기 잠금이 해제 된 후 SQLite는 콜백을 호출하므로 구현시 필요에 따라 데이터베이스를 읽거나 쓰거나 &lt;a href=&quot;../wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">커밋이 수행되고 데이터베이스에서 관련 쓰기 잠금이 해제 된 후 SQLite는 콜백을 호출하므로 구현시 필요에 따라 데이터베이스를 읽거나 쓰거나 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="translated">콜백은 N 개의 가상 머신 작업마다 호출되며, 여기서 N은 &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; 의 두 번째 인수로 제공됩니다 . &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; 에 대한 세 번째 및 네 번째 인수 는 호출 할 루틴에 대한 포인터이고 첫 번째 인수로 전달 될 void 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">이 함수로 등록 된 콜백은 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용하여 등록 된 기존 콜백을 대체합니다 . 마찬가지로 &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용 하여 콜백을 등록하면 이 함수로 구성된 자동 체크 포인트 메커니즘이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">이 함수로 등록 된 콜백은 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용하여 등록 된 기존 콜백을 대체합니다 . 마찬가지로 &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용 하여 콜백을 등록하면 이 함수로 구성된 자동 체크 포인트 메커니즘이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="translated">호출자는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 를 사용하여이 특별한 &quot;DROP TABLE | INDEX&quot;사례와 다른 경우를 구별 할 수 있습니다 . &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 를 호출하는 것이 적절한 경우 확장 오류 코드는 SQLITE_LOCKED_SHAREDCACHE입니다. 그렇지 않으면 &quot;DROP TABLE | INDEX&quot;의 경우에는 일반 SQLITE_LOCKED입니다. 또 다른 솔루션은 단일 쿼리를 다시 시도 할 수있는 횟수를 제한하는 것입니다 (100). 이것이 원하는 것보다 비효율적이지만 문제의 상황이 자주 발생하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="translated">표준 FTS5 소스 코드는 SQLite 소스 트리의 &quot;ext / fts5&quot;디렉토리에있는 일련의 * .c 및 기타 파일로 구성됩니다. 빌드 프로세스는 이것을 &quot;fts5.c&quot;와 &quot;fts5.h&quot;라는 두 파일로 줄이며 SQLite로드 가능 확장을 빌드하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="translated">carray () 함수는 쿼리의 FROM 절에서 사용할 수 있습니다. 예를 들어, 주소 $ PTR의 C 언어 배열에서 가져온 rowid를 사용하여 OBJ 테이블에서 두 항목을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">carray () 함수는 기본적으로 SQLite로 컴파일되지 않습니다. &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt; 소스 파일 에서 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">carray () 함수는 두세 개의 인수를 취합니다. 첫 번째 인수는 배열에 대한 포인터입니다. 포인터 값은 SQL에서 직접 지정할 수 없으므로 첫 번째 인수는 포인터 유형 &quot;carray&quot;를 사용하는 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 인터페이스를 사용 하여 포인터 값에 바인드 되는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 여야합니다 . 두 번째 인수는 배열의 요소 수입니다. 선택적 세 번째 인수는 C 언어 배열에있는 요소의 데이터 유형을 결정하는 문자열입니다. 세 번째 인수에 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="translated">일반 독자는 위 목록의 일부를 이해하거나 기억하지 않아야합니다. 이 목록의 요점은 쿼리를 병합할지 여부를 결정하는 것이 복잡하다는 것을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="translated">셀 내용 영역</target>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="translated">셀 포인터 배열</target>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="translated">b- 트리 페이지의 셀 포인터 배열은 b- 트리 페이지 헤더 바로 뒤에옵니다. K를 btree의 셀 수라고하자. 셀 포인터 배열은 셀 내용에 대한 K 2 바이트 정수 오프셋으로 구성됩니다. 셀 포인터는 맨 왼쪽 셀 (가장 작은 키가있는 셀)부터 맨 오른쪽 셀 (가장 큰 키가있는 셀)부터 키 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="translated">cell_size_check pragma는 데이터베이스 b- 트리 페이지가 디스크에서 처음 읽혀질 때 추가적인 무결성 검사를 활성화 또는 비활성화합니다. 셀 크기 검사를 사용하면 데이터베이스 손상이 더 빨리 감지되고 &quot;확산&quot;될 가능성이 줄어 듭니다. 그러나 추가 검사를 수행하면 성능이 약간 저하되므로 셀 크기 검사는 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="translated">cg_anno.tcl 스크립트는 기본 캐시 그린 드 주석 출력에서 ​​불필요한 세부 사항을 제거하므로, diff를 사용하여 전후 보고서를 비교하여 미세 최적화 시도가 성능에 미치는 영향에 대한 특정 세부 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="translated">사용자 SQL 문의 결과가 아닌 SQL 트리거 또는 외래 키 조치로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="translated">변경 사항은 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 조작으로 만 구성되어야합니다 . CREATE 및 DROP 작업은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="translated">SQLite 버전 3의 잠금 및 동시성 제어 변경 사항은 SQL 언어 수준에서 트랜잭션이 작동하는 방식에 미묘한 변경 사항을 도입합니다. 기본적으로 SQLite 버전 3은 &lt;em&gt;자동 커밋&lt;/em&gt; 모드 에서 작동 합니다. 자동 커미트 모드에서 현재 데이터베이스 연결과 연관된 모든 조작이 완료 되 자마자 데이터베이스에 대한 모든 변경 사항이 커미트됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="translated">changes () 함수는 하위 레벨 트리거의 명령문을 제외하고 가장 최근에 완료된 INSERT, DELETE 또는 UPDATE 문에 의해 변경 또는 삽입 또는 삭제 된 데이터베이스 행 수를 리턴합니다. changes () SQL 함수는 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; C / C ++ 함수를 감싸는 래퍼 이므로 변경 사항을 계산할 때와 동일한 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="translated">char (X1, X2, ..., XN) 함수는 각각 유니 코드 코드 포인트 값이 정수 X1-XN 인 문자로 구성된 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="translated">아래 차트는 파일 시스템에서 직접 블로 브를 읽는 평균 시간과 SQLite 데이터베이스에서 동일한 블로 브를 읽는 데 필요한 시간을 보여줍니다. 실제 타이밍은 시스템마다 상당히 다릅니다 (예 : Ubuntu 데스크탑은 Galaxy S3 전화보다 훨씬 빠릅니다). 이 차트는 파일에서 블롭을 읽는 데 필요한 시간을 데이터베이스에서 필요한 시간으로 나눈 비율을 보여줍니다. 차트에서 가장 왼쪽 열은 참조 용으로 데이터베이스에서 읽는 정규화 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="translated">아래 차트는 5 개의 다른 시스템에서 &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; 를 사용하여 수집 된 데이터를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="translated">아래 차트는 x86_64의 Ubuntu 16.04.3에서 테스트 된 다양한 컴파일러 및 최적화 설정에 대해 2017-10-08 기준 SQLite의 상대적 크기 및 성능을 보여줍니다. 일반적인 관찰 :</target>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="translated">차트는 Windows10에서 디스크에서 직접 읽을 수있는 것보다 SQLite 데이터베이스에서 내용을 약 5 배 빠르게 읽을 수 있음을 보여줍니다. 안드로이드에서 SQLite는 디스크에서 읽는 것보다 약 35 % 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="translated">체크인에는 &quot;트렁크&quot;태그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="translated">체크인시 &quot;트렁크&quot;태그가있는 자식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="translated">체크인에는 &quot;트렁크&quot;태그가있는 부모가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dad224b0586b91e423315e1a7ef99941945ad20" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that adds an 8-byte checksum to the end of every page in an SQLite database. The checksum is added as each page is written and verified as each page is read. The checksum is intended to help detect database corruption caused by random bit-flips in the mass storage device.</source>
          <target state="translated">체크섬 VFS 확장은 SQLite 데이터베이스의 모든 페이지 끝에 8 바이트 체크섬을 추가하는 &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; 입니다. 체크섬은 각 페이지가 기록 될 때 추가되고 각 페이지를 읽을 때 확인됩니다. 체크섬은 대용량 저장 장치에서 임의의 비트 플립으로 인한 데이터베이스 손상을 감지하는 데 도움을주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="34c12f92dcc6b984c7dc0650d9da983b05acb095" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension requires SQLite version 3.32.0 (2020-05-22) or later. It will not work with earlier versions of SQLite.</source>
          <target state="translated">체크섬 VFS 확장에는 SQLite 버전 3.32.0 (2020-05-22) 이상이 필요합니다. 이전 버전의 SQLite에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0b70c1c0ff79721dae8d9a4e00e5b929e1563a7" translate="yes" xml:space="preserve">
          <source>The checksum VFS module is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. It is not included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It must be added to SQLite either at compile-time or at run-time. The source code to the checksum VFS module is in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/cksumvfs.c&quot;&gt;ext/misc/cksumvfs.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt;.</source>
          <target state="translated">체크섬 VFS 모듈은 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 입니다. 그것은 &lt;a href=&quot;amalgamation&quot;&gt;합병에&lt;/a&gt; 포함되지 않습니다 . 컴파일 타임이나 런타임에 SQLite에 추가해야합니다. 체크섬 VFS 모듈의 소스 코드 는 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite 소스 트리&lt;/a&gt; 의 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/cksumvfs.c&quot;&gt;ext / misc / cksumvfs.c&lt;/a&gt; 소스 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="translated">체크섬 알고리즘은 길이가 8 바이트의 배수 인 컨텐츠에 대해서만 작동합니다. 즉, 입력이 x (0)에서 x (N)까지이면 N은 홀수 여야합니다. 체크섬 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="translated">체크섬은 다음과 같이 계산 된 부호없는 32 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="translated">체크섬은 입력을 짝수의 부호없는 32 비트 정수 x (0)에서 x (N)로 해석하여 계산됩니다. WAL 헤더의 처음 4 바이트에있는 매직 번호가 0x377f0683이면 32 비트 정수는 빅 엔디안이고, 매직 번호가 0x377f0682이면 정수는 리틀 엔디안입니다. 체크섬 값은 체크섬을 계산하는 데 사용되는 바이트 순서에 관계없이 항상 프레임 헤더에 빅 엔디안 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="translated">체크섬 값은 정전 후 저널 페이지 레코드의 불완전한 쓰기를 방지하는 데 사용됩니다. 기록되지 않은 섹터가 우연히 이전 저널의 일부인 동일한 페이지의 데이터를 포함 할 수있는 위험을 최소화하기 위해 거래가 시작될 때마다 다른 임의의 논 스가 사용됩니다. 각 트랜잭션에 대해 nonce를 변경하면 디스크의 오래된 데이터가 여전히 잘못된 체크섬을 생성하고 높은 확률로 감지됩니다. 체크섬은 성능상의 이유로 데이터 레코드에서 32 비트 단어의 희소 샘플 만 사용합니다. SQLite 3.0.0의 계획 단계 동안의 설계 연구에서 전체 페이지를 체크섬하는 데 상당한 성능 저하가 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="translated">에 쓰여진 체크섬 값</target>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="translated">프레임 헤더의 마지막 8 바이트의 체크섬 값은 WAL 헤더의 첫 24 바이트와 첫 8 바이트 및 현재 프레임을 포함하여 모든 프레임의 내용에서 연속적으로 계산 된 체크섬과 정확히 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="translated">하위 테이블이 기본 키 열을 지정하지 않고 상위의 기본 키를 참조하고 상위의 기본 키 열 수가 하위 키 열의 수와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb680522ff952474c4763f726c9755f62f14ba34" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the heap limits may changes in future releases of SQLite.</source>
          <target state="translated">SQLite가 힙 제한을 적용하는 상황은 향후 SQLite 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="translated">SQLite가 소프트 힙 제한을 적용하는 환경은 향후 SQLite 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61459fdd1646e497264a92192cd0400ff16d21ef" translate="yes" xml:space="preserve">
          <source>The cksumvfs extension implements a new PRAGMA statement that can be used to disable, re-enable, or query the status of checksum verification:</source>
          <target state="translated">cksumvfs 확장은 체크섬 확인 상태를 비활성화, 다시 활성화 또는 쿼리하는 데 사용할 수있는 새로운 PRAGMA 문을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="translated">이전 단락의 주장은 운영 체제 충돌 및 정전의 데이터베이스 파일에 대한 영향을 시뮬레이션하는 특수 테스트 하네스를 사용하여 SQLite 회귀 테스트 스위트에서 광범위하게 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="translated">coalesce () 함수는 첫 번째 NULL이 아닌 인수의 사본을 리턴하거나 모든 인수가 NULL 인 경우 NULL을 리턴합니다. Coalesce ()에는 최소한 2 개의 인수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="translated">위의 코드는 일반적인 경우를위한 것입니다. 비 압축 또는 비 압축 컨텐츠 만 저장하는 SQLite 아카이브의 특수한 경우 (예 : JPEG, GIF 및 / 또는 PNG 이미지 만 저장하는 SQLite 아카이브에 나타날 수 있음) 컨텐츠를 삽입하고 추출 할 수 있습니다. sqlar_compress () 및 sqlar_uncompress () 함수를 사용하지 않고 데이터베이스에서 sqlar.c 확장자가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="translated">코드는 안정적으로 보이므로 이제 &quot;베타&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="translated">SQLite에서 메모리 할당 크기 계산이 오버플로되지 않도록하는 데 사용되는 코드 감사는 모든 SQLite 릴리스 전에 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">swarmvtab 가상 테이블의 코드는 기본 SQLite 소스 트리의 ext / misc / unionvtab.c 파일에 있습니다. 다음 과 같은 명령을 사용하여 SQLite &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">zipfile 모듈의 코드 는 &lt;a href=&quot;https://sqlite.org/src&quot;&gt;기본 SQLite 소스 트리&lt;/a&gt; 의 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext / misc / zipfile.c&lt;/a&gt; 파일에 있습니다. 다음 과 같은 명령을 사용하여 SQLite &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="translated">이 마지막 예에서 생성 된 코드는 추가 WHERE 및 HAVING 절을 구현하는 데 사용되는 두 개의 조건부 점프를 추가 한 것을 제외하고는 이전 코드와 동일합니다. WHERE 절은 쿼리 루프의 명령어 9 ~ 11에 의해 구현됩니다. HAVING 절은 출력 루프에서 명령 28-30으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="translated">이 마지막 쿼리를 구현하기 위해 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="translated">SQLite의 코드 생성기는 재귀 알고리즘을 사용하여 복합 SELECT 문을 처리합니다. 따라서 스택 크기를 제한하기 위해 복합 SELECT의 용어 수를 제한합니다. 최대 용어 수는 SQLITE_MAX_COMPOUND_SELECT이며 기본값은 500입니다. 실제로 복합 선택의 용어 수가 단일 자릿수를 초과하는 것을 거의 볼 수 없기 때문에 이것은 관대 한 할당량이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="translated">코드 생성기, 특히 &lt;b&gt;where * .c&lt;/b&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt; 의 논리 는 때때로&lt;a href=&quot;optoverview&quot;&gt; 쿼리 플래너&lt;/a&gt; . 특정 SQL 문의 경우 답을 계산하는 데 수백, 수천 또는 수백만 개의 서로 다른 알고리즘이있을 수 있습니다. 쿼리 플래너는 이러한 수많은 선택 중에서 최상의 알고리즘을 선택하기 위해 노력하는 AI입니다.</target>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="translated">&quot;fts5.c&quot;의 코드는로드 가능한 확장으로 컴파일되거나 &lt;a href=&quot;loadext#build&quot;&gt;로드 가능한 확장 컴파일에&lt;/a&gt; 설명 된대로 응용 프로그램에 정적으로 링크 될 수 있습니다. 있습니다. 두 개의 진입 점이 정의되어 있으며 둘 다 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="translated">이 기사의 코드는 최소한 두 가지 방법으로 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="translated">SQLite 라이브러리가 사용하는 코드 공간은 대상 플랫폼, 컴파일러 및 최적화 설정에 따라 다릅니다. 이러한 변수는 성능에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="translated">colUsed 필드는 현재 스캔에 필요할 수있는 가상 테이블의 열을 나타냅니다. 가상 테이블 컬럼은 sqlite3_declare_vtab ()에 전달 된 CREATE TABLE 문에 나타나는 순서대로 0부터 번호가 매겨집니다. 처음 63 개의 열 (열 0-62)의 경우 SQLite에서 열이 필요할 수있는 경우 colUsed 마스크 내에서 해당 비트가 설정됩니다. 테이블에 64 개 이상의 열이 있고 첫 번째 63의 오른쪽에있는 열이 필요한 경우 colUsed의 비트 63도 설정됩니다. 즉, 식 (colUsed &amp;amp; ((sqlite3_uint64) 1 &amp;lt;&amp;lt; (iCol&amp;gt; = 63? 63 : iCol)))이 0이 아닌 것으로 평가되면 열 iCol이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">조합 함수 콜백은 pArg 응용 프로그램 데이터 포인터의 사본과 eTextRep 인수로 지정된 인코딩에 두 개의 문자열로 호출됩니다. 배열 함수는 첫 번째 문자열이 각각 두 번째보다 작거나 같거나 큰 경우 음수, 0 또는 양의 정수를 반환해야합니다. 조합 함수는 동일한 입력이 주어지면 항상 동일한 응답을 반환해야합니다. 둘 이상의 조합 함수가 다른 조합의 eTextRep 값을 사용하여 동일한 조합 이름에 등록 된 경우 동등한 문자열로 호출 될 때 모두 동등한 응답을 제공해야합니다. 조합 함수는 모든 문자열 A, B 및 C에 대해 다음 특성을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a8a7f3b3c83ac2e3d1763414e674a2e2ca29ee7" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The two integer parameters to the collating function callback are the length of the two strings, in bytes. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">조합 함수 콜백은 pArg 애플리케이션 데이터 포인터의 복사본과 eTextRep 인수로 지정된 인코딩의 두 문자열을 사용하여 호출됩니다. 조합 함수 콜백에 대한 두 개의 정수 매개 변수는 두 문자열의 길이 (바이트)입니다. 데이터 정렬 함수는 첫 번째 문자열이 각각 두 번째 문자열보다 작거나 같거나 큰 경우 음수, 0 또는 양수인 정수를 반환해야합니다. 데이터 정렬 함수는 동일한 입력에 대해 항상 동일한 답변을 반환해야합니다. 둘 이상의 데이터 정렬 함수가 동일한 데이터 정렬 이름에 등록 된 경우 (다른 eTextRep 값 사용) 동일한 문자열로 호출 될 때 모두 동일한 응답을 제공해야합니다. 데이터 정렬 함수는 모든 문자열 A, B 및 C에 대해 다음 속성을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="translated">열은이 기능에 대한 두 번째, 세 번째 및 네 번째 매개 변수로 식별됩니다. 두 번째 매개 변수는 지정된 테이블을 포함하는 데이터베이스 이름 (예 : &quot;main&quot;, &quot;temp&quot;또는 연결된 데이터베이스)이거나 NULL입니다. NULL 인 경우, 데이터베이스 엔진에서 사용 된 것과 동일한 알고리즘을 사용하여 테이블에 대한 모든 첨부 된 데이터베이스를 검색하여 규정되지 않은 테이블 참조를 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="translated">&quot;.header&quot;도트 명령을 사용하여 처음 두 줄의 출력에 나타나는 열 레이블을 켜거나 끌 수 있습니다. 위의 예에서 열 레이블이 켜져 있습니다. 그것들을 끄려면 다음과 같이하십시오 :</target>
        </trans-unit>
        <trans-unit id="9b37c354a4343966405cb0363479fdc771c7551d" translate="yes" xml:space="preserve">
          <source>The column may not be &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;, though VIRTUAL columns are allowed.</source>
          <target state="translated">VIRTUAL 컬럼은 허용되지만 컬럼은 &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt; 가 아닐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">열에 PRIMARY KEY 또는 UNIQUE 제약 조건이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="translated">열에 기본값 CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP 또는 괄호 안의 표현식이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="translated">열 이름 및 정의</target>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 결과 세트의 열 이름 문의 경우에 따라 다른 SQL 데이터베이스 엔진처럼 작동하도록 조정되었습니다.</target>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="translated">가상 테이블의 열 이름은 주로 &lt;b&gt;schema =&lt;/b&gt; 인수에 의해 결정됩니다 . 는 IF &lt;b&gt;스키마 =&lt;/b&gt; 인수는 생략하지만, &lt;b&gt;헤더는&lt;/b&gt; 사실, 그 값은 열 이름이 될 CSV 파일의 첫 번째 줄에서 발견된다. 경우 &lt;b&gt;스키마 =&lt;/b&gt; 인수는 생략하고 &lt;b&gt;헤더&lt;/b&gt; 거짓 후 컬럼 등 &quot;C0&quot;, &quot;C1&quot;, &quot;C2&quot;라는하고있다.</target>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="translated">조인 서브 쿼리에 의해보고 된 컬럼 이름은 다른 데이터베이스 엔진과 유사하게 작동하도록 약간 수정되었습니다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">열 번호 (두 번째 가장 왼쪽 열의 경우 1 등) 이 필드는 열 0과 관련된 용어 오프셋 목록에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="translated">용어 인스턴스가 발생하는 열 번호 (FTS 테이블의 가장 왼쪽 열은 0, 다음 가장 왼쪽 열은 1 등)</target>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="translated">열 이름 목록 구문은 SQLite 버전 3.9.0 (2015-10-14)에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="translated">열은 SQLITE_STMT 가상 테이블에서 제공되며 여기에 표시된 가상 CREATE TABLE 문으로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="translated">부분 색인의 WHERE 절에서 참조되는 열은 색인화되는 열뿐만 아니라 테이블의 모든 열일 수 있습니다. 그러나 부분 인덱스의 WHERE 절식이 인덱스되는 열에 대한 간단한 식인 것이 매우 일반적입니다. 다음은 일반적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="translated">위의 명령은 새 분기를 만들었습니다. 그러나 체크 아웃은 여전히 ​​트렁크에 있습니다. 명령을 실행하면 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="translated">위의 명령은 SQLite의 전체 개발 기록을 컴퓨터의 &quot;sqlite.fossil&quot;파일에 복사합니다. 이 사본을 작성하는 데 약 1 분이 소요되며 약 32MB의 전송이 사용됩니다. 복사 한 후 다음을 입력하여 저장소를 &quot;열&quot;십시오.</target>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="translated">위의 명령은 쿼리 출력을 CSV로 임시 파일에 기록하고 CSV 파일 (일반적으로 Excel 또는 LibreOffice와 같은 기본 스프레드 시트 프로그램)의 기본 처리기를 호출 한 다음 임시 파일을 삭제합니다. 이것은 본질적으로 위에서 설명한 &quot;.csv&quot;, &quot;.once&quot;및 &quot;.system&quot;명령의 순서를 수행하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="translated">이 명령은 BLOB를 읽거나 쓰는 새로운 TCL 채널을 리턴합니다. 기본 &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; C 언어 인터페이스를 사용하여 채널이 열립니다 . 닫기를 사용하여 채널을 &lt;b&gt;닫습니다&lt;/b&gt;TCL 명령을 .</target>
        </trans-unit>
        <trans-unit id="988274d0addcbb9018970d10733f7b4052f070a2" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">명령 줄 셸 은 각각 파일의 내용을 테이블 열로 읽고 열의 내용을 파일에 쓰는 두 가지 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">명령 행 쉘은 두 개의 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수를&lt;/a&gt; 추가 합니다. 은 파일에서 컨텐츠를 테이블 컬럼으로 읽고 컬럼 컨텐츠를 파일에 각각 기록하는 데 도움이 를 .</target>
        </trans-unit>
        <trans-unit id="5a15969d303479025517006f69c3c3e87572075f" translate="yes" xml:space="preserve">
          <source>The command-line shell uses the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; to access ZIP archives. You can see this by running the &quot;.schema&quot; command when a ZIP archive is open:</source>
          <target state="translated">명령 줄 셸은 &lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블&lt;/a&gt; 을 사용하여 ZIP 아카이브에 액세스합니다. ZIP 아카이브가 열려있을 때 &quot;.schema&quot;명령을 실행하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">커밋 및 롤백 후크 콜백은 재진입되지 않습니다. 콜백 구현은 콜백을 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 처음에 커미트 또는 롤백 후크를 트리거 한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 지연되어야합니다 . SELECT 문을 포함하여 다른 SQL 문을 실행하거나 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 을 호출 하면이 단락에서 &quot;modify&quot;의 의미로 데이터베이스 연결이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">커밋 및 롤백 후크 콜백은 재진입되지 않습니다. 콜백 구현은 콜백을 호출 한 데이터베이스 연결을 수정하는 작업을 수행해서는 안됩니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 처음에 커미트 또는 롤백 후크를 트리거 한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 지연되어야합니다 . SELECT 문을 포함하여 다른 SQL 문을 실행하거나 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 을 호출 하면이 단락에서 &quot;modify&quot;의 의미로 데이터베이스 연결이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="translated">커밋 프로세스는 &lt;a href=&quot;#section_3_0&quot;&gt;섹션 3.0에 나와 있습니다.&lt;/a&gt; 할 때까지 모든 데이터베이스 변경 사항이 메모리에 적합하다고 가정합니다. 이것은 일반적인 경우입니다. 그러나 때때로 트랜잭션 커밋 이전에 더 큰 변경으로 인해 사용자 공간 캐시가 오버플로 될 수 있습니다. 이 경우, 트랜잭션이 완료되기 전에 캐시가 데이터베이스에 유출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="translated">공통 테이블 표현식은 확장을로드하지 않고도 작동합니다. 반면, 확장 프로그램은 프로그래밍이 쉽고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="translated">비교는 정렬 비교이므로 NULL은 동일하게 비교되고 NULL은 숫자보다 작고 숫자는 문자열보다 작으며 문자열은 블롭보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="translated">바로 위에 표시된 컴파일 단계는 단지 대표적인 것입니다. 작동하는 설치에서는 일반적으로 컴파일러 명령 줄에서 최적화 매개 변수 및 컴파일 타임 스위치를 지정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="translated">상한 설정을위한 컴파일 타임 옵션은 &lt;a href=&quot;limits&quot;&gt;별도로 문서화되어&lt;/a&gt; 있습니다. 다음은 사용 가능한 설정 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="translated">SQLite 데이터베이스의 전체 상태는 일반적으로 &quot;주 데이터베이스 파일&quot;이라는 디스크의 단일 파일에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="translated">완성 테이블은 대화식으로 사용하도록 설계되었습니다. 인간 타이핑에 적합한 속도로 답변을 반환합니다. 사용자 인터페이스에서 응답 시간이 거의 즉각적인 한, 비정상적으로 효율적으로 노력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="translated">완료 테이블은 유닉스 용 readline 또는 linenoise 입력 라인 편집 패키지와 함께 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 탭 완성을 구현하는 데 사용됩니다 . 예제 코드 는 &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; 소스 파일을 참조하십시오 . &quot;FROM 완료&quot;를 검색하여 관련 코드 섹션을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="translated">완료 테이블은 동일한 후보를 두 번 이상 리턴 할 수 있으며 임의의 순서로 후보를 리턴합니다. 위의 샘플 쿼리에서 DISTINCT 키워드와 ORDER BY가 추가되어 답변을 독특하고 사전 식 순서로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="translated">Git의 복잡성은 개발중인 소프트웨어에서주의를 산만하게합니다. Git 사용자는 다음 사항을 모두 염두에 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="translated">복합 SELECT 연산자 인 UNION, INTERSECT 및 EXCEPT는 값을 암시 적으로 비교합니다. UNION, INTERSECT 또는 EXCEPT와 관련된 암시 적 비교의 비교 피연산자에는 선호도가 적용되지 않습니다. 값은 그대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="translated">압축 및 압축 해제 옵션을 사용하면 FTS4 컨텐츠를 압축 된 형식으로 데이터베이스에 저장할 수 있습니다. 두 옵션 모두 단일 인수를 허용하는 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 을 사용하여 등록 된 SQL 스칼라 함수의 이름으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="translated">compress 함수는 전달 된 값의 압축 버전을 인수로 리턴해야합니다. 데이터가 FTS4 테이블에 기록 될 때마다 각 열 값은 압축 함수로 전달되고 결과 값은 데이터베이스에 저장됩니다. 압축 함수는 모든 유형의 SQLite 값 (blob, text, real, integer 또는 null)을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">압축 옵션은 압축 기능을 지정하는 데 사용됩니다. 압축 해제 기능을 지정하지 않고 압축 기능을 지정하면 오류가 발생합니다. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;자세한 내용은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="translated">compress =, uncompress = 및 languageid = 옵션을 사용할 수 없습니다. 아직 기능과 동등한 기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="translated">데이터를 압축하는 데 사용되는 압축 방법 (정수). 값 0은 데이터가 압축없이 zip 아카이브에 저장됨을 나타냅니다. 8은 원시 수축 알고리즘을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="translated">현지 시간의 계산은 정치인의 변덕에 크게 좌우되므로 모든 지역에 대해 정확한 정보를 얻는 것은 어렵습니다. 이 구현에서는 표준 C 라이브러리 함수 localtime_r ()을 사용하여 현지 시간을 계산합니다. localtime_r () C 함수는 일반적으로 1970 년에서 2037 년 사이의 기간 동안 만 작동합니다.이 범위 밖의 날짜의 경우 SQLite는 연도를이 범위 내의 동등한 연도로 매핑하려고 시도하고 계산 한 다음 연도를 다시 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="a84ddecfbfcfd1c573cf704dea12a071acade093" translate="yes" xml:space="preserve">
          <source>The concept of fuzz testing has been around for decades, but fuzz testing was not an effective way to find bugs until 2014 when Michal Zalewski invented the first practical profile-guided fuzzer, &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot;. Unlike prior fuzzers that blindly generate random inputs, AFL instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">퍼즈 테스트의 개념은 수십 년 동안 존재 해 왔지만, Michal Zalewski가 최초의 실용적인 프로파일 유도 퍼저 인 &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; 또는 &quot;AFL&quot;을 발명 한 2014 년까지는 퍼즈 테스트가 버그를 찾는 효과적인 방법이 아니 었습니다 . 무작위 입력을 맹목적으로 생성하는 이전 퍼저와 달리 AFL은 테스트중인 프로그램을 계측하고 (C 컴파일러의 어셈블리 언어 출력을 수정하여) 해당 계측을 사용하여 입력으로 인해 프로그램이 다른 작업을 수행하는시기를 감지하여 새로운 컨트롤을 따릅니다. 경로 또는 루프가 다른 횟수입니다. 새로운 행동을 유발하는 입력은 유지되고 추가로 변경됩니다. 이러한 방식으로 AFL은 설계자가 상상하지 못했던 동작을 포함하여 테스트중인 프로그램의 새로운 동작을 &quot;발견&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="translated">UNIX에서 configure 스크립트는 pread () 및 pwrite ()를 자동으로 감지하고 해당 OS 인터페이스를 사용할 수 있도록 컴파일 타임 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="translated">configure-make는 소스 트리 또는 통합 번들에서 표준 소스로 빌드하든 작동합니다. 의존성이 거의 없습니다. 표준 소스에서 빌드 할 때는 작동하는 &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; 가 필요합니다. 통합 번들을 사용하는 경우, tclsh가 일반적으로 수행하는 모든 사전 처리 작업이 이미 수행되었으며 일반적인 빌드 도구 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="translated">필수 PRIMARY KEY 필드가있는 행이 데이터베이스에 존재하지만 갱신에 의해 수정 된 하나 이상의 다른 (기본 키가 아닌) 필드가있는 경우 DELETE 또는 UPDATE 변경을 처리 할 때 CHANGESET_DATA를 두 번째 인수로 사용하여 충돌 핸들러가 호출됩니다. 예상되는 &quot;이전&quot;값을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="translated">필요한 PRIMARY KEY 필드가있는 행이 데이터베이스에없는 경우 DELETE 또는 UPDATE 변경을 처리 할 때 CHANGESET_NOTFOUND를 사용하여 충돌 핸들러가 두 번째 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="translated">이 경우 충돌하는 행은 일치하는 기본 키가있는 데이터베이스 행입니다.</target>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="translated">이 경우 충돌하는 행은 일치하는 기본 키가있는 데이터베이스 행입니다.</target>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="translated">연결은</target>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="translated">연결은 데이터가</target>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="translated">내용을 사용하면 인덱싱되는 텍스트를 FTS4 테이블과 다른 별도의 테이블에 저장하거나 심지어 SQLite 외부에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e0eda1c9ea11f507c054ff491306a6eca1ff67" translate="yes" xml:space="preserve">
          <source>The content in the sqlite_stat4 table cannot be computed with anything less than a full scan. Hence, if a non-zero analysis limit is specified, the sqlite_stat4 table is not computed.</source>
          <target state="translated">sqlite_stat4 테이블의 내용은 전체 스캔보다 적은 것으로 계산할 수 없습니다. 따라서 0이 아닌 분석 한계가 지정되면 sqlite_stat4 테이블이 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="translated">레지스터 P2에서 시작하는 P3 레지스터의 내용은 압축 해제 된 인덱스 키를 형성합니다. 이 opcode는 커서 P1에 의해 열린 색인에서 해당 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="translated">R * Tree 인덱스의 내용은 실제로 R * Tree의 이름에서 파생 된 이름을 가진 세 개의 일반 SQLite 테이블에 저장됩니다. 이 세 테이블을 &quot; &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; &quot;이라고합니다. 이것은 그들의 스키마입니다.</target>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="translated">각 SQL 테이블 행의 내용은 먼저 다양한 열의 값을 레코드 형식의 바이트 배열로 결합한 다음 해당 바이트 배열을 페이로드로 테이블 b- 트리의 항목에 저장하여 데이터베이스 파일에 저장됩니다. 레코드의 값 순서는 SQL 테이블 정의의 열 순서와 동일합니다. SQL 테이블에 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열 ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 별명 지정 )이 포함 된 경우 해당 열은 레코드에 NULL 값으로 나타납니다. SQLite는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열을 참조 할 때 항상 NULL 값 대신 테이블 b- 트리 키를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">각 롤백 저널의 내용은 마스터 저널 파일 이름이 롤백 저널 헤더에 기록되기 전후에 디스크로 플러시됩니다. 이 플러시를 모두 수행하는 것이 중요합니다. 다행히도 일반적으로 저널 파일의 단일 페이지 (첫 번째 페이지) 만 변경되었으므로 두 번째 플러시는 일반적으로 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="2c74d571015e1e1c51708cccb3ac9a7ab08632cc" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the super-journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">각 롤백 저널의 내용은 슈퍼 저널 파일 이름이 롤백 저널 헤더에 기록되기 전과 후에 디스크로 플러시됩니다. 이 두 가지 플러시를 모두 수행하는 것이 중요합니다. 다행히도 일반적으로 저널 파일의 한 페이지 (첫 번째 페이지) 만 변경되었으므로 두 번째 플러시는 일반적으로 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="translated">각 슬라이드의 내용은 여전히 ​​압축 된 XML로 저장 될 수 있습니다. 그러나 이제 각 페이지는 별도로 저장됩니다. 따라서 새 문서를 열 때 응용 프로그램을 간단히 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="translated">통계 테이블의 내용은 &lt;a href=&quot;lang_select&quot;&gt;SELECT를&lt;/a&gt; 사용하여 쿼리 할 수 있으며 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 및 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 명령을 사용하여 변경할 수 있습니다 . &lt;a href=&quot;lang_droptable&quot;&gt;테이블 삭제&lt;/a&gt; 명령은 SQLite는 버전 3.7.9 기준으로 통계 테이블에서 작동합니다. (2011-11-01) &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령은 통계 테이블에서 작동하지 않습니다. 유효하지 않은 컨텐츠로 인해 SQLite가 비효율적 인 쿼리 계획을 선택할 수 있으므로 통계 테이블의 컨텐츠를 변경할 때는 적절한주의가 필요합니다. 일반적으로, ANALYZE 명령을 호출하는 것 이외의 다른 메커니즘으로 통계 테이블의 내용을 수정해서는 안됩니다. 자세한 정보는 &quot; &lt;a href=&quot;optoverview#manctrl&quot;&gt;SQLITE_STAT 테이블을 사용한 조회 계획 수동 제어&lt;/a&gt; &quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="translated">내용 옵션을 사용하면 FTS4에서 색인을 생성 할 텍스트를 저장하는 것을 포기할 수 있습니다. 컨텐츠 옵션은 두 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="translated">컨텐츠 테이블은 다음과 같이 쿼리 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; API를 사용하여 작성된 반복자를 사용하여 변경 세트의 컨텐츠를 순회 할 수 있습니다 . &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; API를 사용하여 호환 가능한 스키마가있는 데이터베이스에 변경 세트를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; API를 사용하여 작성된 반복자를 사용하여 변경 세트의 컨텐츠를 순회 할 수 있습니다 . &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; API를 사용하여 호환 가능한 스키마가있는 데이터베이스에 변경 세트를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="translated">SQLite 데이터베이스 파일의 내용은 고정 크기 페이지 세트로 형식화됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="translated">UNINDEXED 열 옵션으로 규정 된 열의 내용은 FTS 인덱스에 추가되지 않습니다. 이는 MATCH 쿼리 및 &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 보조 함수&lt;/a&gt; 의 목적으로 열에 일치하는 토큰이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="translated">논리 전체 텍스트 인덱스의 내용은 모든 세그먼트 b- 트리의 내용을 병합하여 찾을 수 있습니다. 용어가 둘 이상의 세그먼트 b- 트리에있는 경우 각 개별 doclist의 합집합에 맵핑됩니다. 단일 용어에 대해 동일한 문서가 둘 이상의 문서 목록에서 발생하면 가장 최근에 작성된 세그먼트 b- 트리의 일부인 문서 목록 만 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2 구조의 내용을 호출하여 내 SQLite는 내부 버퍼에 복사 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; . 따라서 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 된 후 응용 프로그램은 매개 변수를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2 구조의 내용을 호출하여 내 SQLite는 내부 버퍼에 복사 &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; . 따라서 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 호출이 반환 된 후 응용 프로그램은 매개 변수를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL 함수가 실행되는 컨텍스트는 sqlite3_context 객체에 저장됩니다. sqlite3_context 객체에 대한 포인터는 항상 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수에 대한&lt;/a&gt; 첫 번째 매개 변수 입니다. 애플리케이션 정의 SQL 함수 구현은이 포인터를 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 호출로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="eb189ce529b8d7d0045783021bb7d8fd77526437" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL 함수가 실행되는 컨텍스트는 sqlite3_context 객체에 저장됩니다. sqlite3_context 객체에 대한 포인터는 항상 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수에 대한&lt;/a&gt; 첫 번째 매개 변수 입니다. 애플리케이션 정의 SQL 함수 구현은이 포인터를 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 에 대한 호출로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="53fb8a37d043abdf36747b3ab57dd8a44c62d486" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL 함수가 실행되는 컨텍스트는 sqlite3_context 객체에 저장됩니다. sqlite3_context 객체에 대한 포인터는 항상 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수에 대한&lt;/a&gt; 첫 번째 매개 변수 입니다. 애플리케이션 정의 SQL 함수 구현은이 포인터를 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 에 대한 호출로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL 함수가 실행되는 컨텍스트는 sqlite3_context 객체에 저장됩니다. sqlite3_context 객체에 대한 포인터는 항상 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수에 대한&lt;/a&gt; 첫 번째 매개 변수 입니다. 애플리케이션 정의 SQL 함수 구현은이 포인터를 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 호출로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="translated">사본은 분기 명령을 무 작동 또는 무조건 점프로 변경하도록 편집됩니다.</target>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="translated">copy 메소드는 &lt;b&gt;.import&lt;/b&gt; SQLite 쉘 명령 과 유사한 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="translated">sqlite3.s의 사본은 sqlite3.o로 조립 된 후 th3.o로 다시 링크되어 &quot;th3&quot;실행 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">아래에 표시된 핵심 기능은 기본적으로 사용 가능합니다. &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; , &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;창 함수&lt;/a&gt; 및 &lt;a href=&quot;json1&quot;&gt;JSON 함수&lt;/a&gt; 는 별도로 문서화됩니다. 응용 프로그램은 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; API를 사용하여 C로 작성되고 데이터베이스 엔진에 추가 된 추가 함수를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="translated">핵심 아이디어는 데이터베이스 변경 사항을 실행 취소 / 다시 실행하는 데 필요한 정보를 보유하는 특수 테이블 (예 : &quot;UNDOLOG&quot;)을 작성하는 것입니다. 실행 취소 / 다시 실행에 참여하려는 데이터베이스의 각 클래스 (테이블)에 대해 참여 클래스의 각 DELETE, INSERT 및 UPDATE에 대해 UNDOLOG 테이블에 항목을 작성하는 트리거가 작성됩니다. UNDOLOG 항목은 일반적인 SQL 문으로 구성되어 있으며 변경 사항을 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="translated">SELECT 문의 핵심은 아래의 &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; 및 &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; 구문 다이어그램에 표시된 &quot;간단한 SELECT&quot; 입니다. 실제로 대부분의 SELECT 문은 간단한 SELECT 문입니다.</target>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="translated">지점 타임 라인을 생성하는 데 사용되는 핵심 쿼리는 다음과 같습니다. 독자는이 쿼리의 세부 사항을 이해할 수 없습니다. 주석이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="translated">핵심 문자열 형식화 루틴은 &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; 소스 파일 에있는 sqlite3VXPrintf () 함수 입니다. 모든 다양한 인터페이스는이 하나의 핵심 기능을 (간접적으로) 호출합니다. sqlite3VXPrintf () 함수는 1980 년대 후반 Duke University의 대학원생이었던 최초의 SQLite ( &lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt; )가 작성한 코드로 시작되었습니다 . Hipp는 2000 년에 SQLite 작업을 시작할 때까지이 printf () 구현을 개인 도구 상자에 보관했습니다.이 코드는 SQLite 버전 1.0.9의 경우 &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; 의 SQLite 소스 트리에 통합되었습니다 .</target>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="translated">비용 표의 이름은 원하는대로 지정할 수 있으며 &quot;editcost&quot;라고 할 필요는 없습니다. 그리고 테이블에는 추가 열이 포함될 수 있습니다. 유일한 요구 사항은 테이블에 위에 표시된 네 개의 열과 정확히 표시된 이름을 포함해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="translated">비용은 그래프에 표시된 것처럼 단일 숫자가 아닌 여러 숫자로 구성됩니다. SQLite는 다른 시간에 적용되는 각 루프에 대해 여러 가지 다른 예상 비용을 계산합니다. 예를 들어 쿼리가 시작될 때 한 번만 발생하는 &quot;설정&quot;비용이 있습니다. 설정 비용은 아직 색인이없는 테이블에 대한 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인&lt;/a&gt; 을 계산하는 비용입니다 . 그런 다음 루프의 각 단계를 실행하는 비용이 있습니다. 마지막으로, 루프에 의해 생성 된 행 수의 추정치가 있는데, 이는 내부 루프의 비용을 추정하는 데 필요한 정보입니다. 쿼리에 ORDER BY 절이 있으면 정렬 비용이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="translated">count (X) 함수는 해당 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e9bf7bdd6a7e80adbfe374cd14df21073d0a490" translate="yes" xml:space="preserve">
          <source>The countStep() callback is invoked once for each row in the aggregate. As you can see, the count is incremented if either there are no arguments, or if the one argument is not NULL.</source>
          <target state="translated">countStep () 콜백은 집계의 각 행에 대해 한 번씩 호출됩니다. 보시다시피 인수가 없거나 하나의 인수가 NULL이 아니면 개수가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="translated">100 % 분기 테스트 적용 범위를 얻는 데 사용되는 cov1 테스트 세트는 현재 TH3를 사용하여 구현 된 테스트의 일부일뿐입니다. 새로운 테스트 모듈이 정기적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="translated">SQLite의 충돌 테스트는 복구 메커니즘에서 매우 미묘한 버그 (현재 수정 된)를 발견했습니다. 이러한 버그 중 일부는 매우 모호하여 코드 검사 및 분석 기술만으로는 발견되지 않았습니다. 이 경험을 통해 SQLite 개발자는 유사한 충돌 테스트 시스템을 사용하지 않는 다른 모든 데이터베이스 시스템에 감지되지 않은 버그가 포함되어 시스템 충돌 또는 정전 후에 데이터베이스가 손상 될 수 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="translated">누적 분포. 로 계산</target>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="translated">현재 SQLite 구현에서는 루프 조인 만 사용합니다. 즉, 조인은 중첩 루프로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="translated">이 JSON 라이브러리의 현재 구현은 재귀 강하 파서를 사용합니다. 과도한 스택 공간 사용을 피하기 위해 중첩 수준이 2000 개가 넘는 JSON 입력은 유효하지 않은 것으로 간주됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 섹션 9에&lt;/a&gt; 의해 JSON의 호환 가능한 구현에 대해 중첩 깊이에 대한 제한이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="translated">현재 구현은 최대 2 &lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt; -1 또는 2147483647 의 문자열 또는 BLOB 길이 만 지원합니다. hex ()와 같은 일부 내장 함수는 그 시점 이전에 실패 할 수 있습니다. 보안에 민감한 응용 프로그램에서는 최대 문자열 및 얼룩 길이를 늘리지 않는 것이 가장 좋습니다. 실제로 가능한 경우 최대 문자열 및 얼룩 길이를 몇 백만 범위의 값으로 낮추는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="translated">현재 행 RANGE 및 GROUPS 프레임 유형의 경우 EXCLUDE 절에서 특별히 제외하지 않는 한 현재 행의 피어도 프레임에 포함됩니다. CURRENT ROW가 시작 또는 끝 프레임 경계로 사용되는지 여부에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="translated">요청 된 매개 변수의 현재 값은 * pCur에 기록되고 가장 높은 순간 값은 * pHiwtr에 기록됩니다. resetFlg가 true이면 가장 높은 순간 값이 현재 값으로 다시 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="translated">현재 작업 디렉토리 ( &quot;.&quot;)</target>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="translated">현재 작가는 거래를 마친다.</target>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="translated">위의주기는 여러 번 반복 될 수 있습니다. 다이어그램은 3 번째 SQLite 릴리스 인 3.6.17 (6)을 보여줍니다. 개인 브랜치 관리자는 (4)에서 (6)으로 이동하는 변경 사항을 개인 브랜치에 통합하여 버전 (7)을 만들기 위해 다른 병합을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="translated">cachegrind가 제공하는주기 수는 실제 성능을위한 좋은 프록시이지만 100 % 정확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="translated">데이터 및 메소드 열은 위의 INSERT에 대해 설명 된대로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="translated">테이블 b- 트리 리프 페이지 및 인덱스 b- 트리 페이지의 키에 대한 데이터는 위에서 임의의 바이트 시퀀스로 특성화되었습니다. 이전의 논의에서는 하나의 키가 다른 것보다 작다는 것을 언급했지만 &quot;보다 작음&quot;의 의미를 정의하지는 않았습니다. 현재 섹션에서는 이러한 누락에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="translated">rowid 테이블의 데이터는 rowid 값을 키로 사용하여 각 테이블 행에 대한 하나의 항목을 포함하는 B-Tree 구조로 저장됩니다. 이것은 rowid로 레코드를 검색하거나 정렬하는 것이 빠르다는 것을 의미합니다. 특정 rowid를 가진 레코드 또는 지정된 범위 내의 rowid를 가진 모든 레코드를 검색하는 것은 다른 PRIMARY KEY 또는 색인 값을 지정하여 수행 한 유사한 검색보다 약 2 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="translated">data_ % 테이블에는 대상 테이블과 동일한 열과 &quot;rbu_control&quot;이라는 하나의 추가 열이 있어야합니다. data_ % 테이블에는 PRIMARY KEY 또는 UNIQUE 제약 조건이 없어야하지만 각 열은 대상 데이터베이스의 해당 열과 동일한 유형이어야합니다. rbu_control 컬럼에는 유형이 전혀 없어야합니다. 예를 들어, 대상 데이터베이스에 다음이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="translated">data_ % 테이블은 다음과 같이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="translated">data_ % 테이블 자체에는 PRIMARY KEY 선언이 없어야합니다. 그러나 &quot;rowid&quot;순서로 각 data_ % 테이블에서 행을 읽는 것이 해당 대상 데이터베이스 테이블의 PRIMARY KEY로 정렬 된 행을 읽는 것과 거의 동일한 경우 RBU가 더 효율적입니다. 즉, 행이 대상 테이블 PRIMARY KEY 필드를 사용하여 정렬되어 data_ % 테이블에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="translated">그런 다음 대상 데이터베이스 테이블 ccc에 대한 업데이트로 data_ccc 테이블을 정상적으로 채울 수 있습니다. RBU는 data0_ccc_fts보기에서 동일한 업데이트를 읽고 FTS 테이블 ccc_fts에 적용합니다. &quot;data0_ccc_fts&quot;가 &quot;data_ccc&quot;보다 작기 때문에 FTS 테이블이 먼저 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">정리 된 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="translated">데이터베이스 연결은 언제든지 전체 및 증분 자동 진공 모드간에 변경할 수 있습니다. 그러나 &quot;없음&quot;에서 &quot;전체&quot;또는 &quot;증분&quot;으로 변경하면 데이터베이스가 새로 작성되거나 (아직 테이블이 작성되지 않은 경우) &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령 을 실행해야만 발생할 수 있습니다 . 자동 진공 모드를 변경하려면 먼저 auto_vacuum pragma를 사용하여 원하는 새 모드를 설정 한 다음 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 호출 하여 전체 데이터베이스 파일을 재구성하십시오. &quot;full&quot;또는 &quot;incremental&quot;에서 &quot;none&quot; 으로 변경하려면 빈 데이터베이스에서도 항상 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM을&lt;/a&gt; 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;uri#uriimmutable&quot;&gt;불변 쿼리 매개 변수를&lt;/a&gt; 사용하여 데이터베이스 연결이 열립니다 .</target>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="translated">데이터베이스 파일 형식은 WAL 모드에서 변경되지 않습니다. 그러나 WAL 파일과 &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; 는 새로운 개념이므로 이전 버전의 SQLite는 충돌이 발생했을 때 WAL 모드에서 작동하던 충돌 된 SQLite 데이터베이스를 복구하는 방법을 알지 못합니다. 이전 버전의 SQLite (버전 3.7.0, 2010-07-22 이전)가 WAL 모드 데이터베이스를 복구하지 못하고 (더 나쁘게 만드는 경우) 데이터베이스 파일 형식 버전 번호 ( &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더의&lt;/a&gt; 바이트 18 및 19) )가 WAL 모드에서 1에서 2로 증가했습니다. 따라서 이전 버전의 SQLite가 WAL 모드에서 작동하는 SQLite 데이터베이스에 연결하려고하면 &quot;파일이 암호화되었거나 데이터베이스가 아닙니다&quot;행에 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="translated">데이터베이스 파일 형식은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="translated">데이터베이스 파일 헤더</target>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="translated">모든 업데이트가 영구 미디어에 안전하게 저장되도록 데이터베이스 파일이 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="translated">데이터베이스 파일이 잠금 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b3f3d4ba2117afe864ef2e2e3855b3dd6cb1ace" translate="yes" xml:space="preserve">
          <source>The database filename is not allowed to be a symbolic link</source>
          <target state="translated">데이터베이스 파일 이름은 심볼릭 링크가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="translated">TEMP 테이블의 데이터베이스는 필요할 때까지 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 핸들이 &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;자동 커미트 모드에&lt;/a&gt; 있지 않아야 합니다 .</target>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 핸들이 &lt;a href=&quot;get_autocommit&quot;&gt;자동 커미트 모드에&lt;/a&gt; 있지 않아야 합니다 .</target>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="translated">새 테이블이 작성되는 데이터베이스 기본 데이터베이스, 임시 데이터베이스 또는 연결된 데이터베이스에서 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="translated">데이터베이스는 트랜잭션에 의해 수정됩니다</target>
        </trans-unit>
        <trans-unit id="a60dcb2504ad2ca1f013e489bb243d5fba664847" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">데이터베이스가 열린 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시가&lt;/a&gt; 비활성화되어 &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에서&lt;/a&gt; 제공하는 기본 공유 캐시 설정을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4eaa608858923b8628e324d3b5e39f5d6ac0b6e8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">데이터베이스는 &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에서&lt;/a&gt; 제공하는 기본 공유 캐시 설정을 재정 의하여 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시가&lt;/a&gt; 활성화 되어 열립니다 .</target>
        </trans-unit>
        <trans-unit id="438e6e4f2464e93327c1c43679960b9033bba769" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">데이터베이스가 열린 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시가&lt;/a&gt; 비활성화되어 &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에서&lt;/a&gt; 제공하는 기본 공유 캐시 설정을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2866aa5f974824c8ab6f079d70d8228fd2d735a8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">데이터베이스는 &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에서&lt;/a&gt; 제공하는 기본 공유 캐시 설정을 재정 의하여 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시가&lt;/a&gt; 활성화 되어 열립니다 .</target>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="translated">데이터베이스는 가능하면 읽기 및 쓰기를 위해 열리거나 운영 체제가 파일을 쓰기 보호 한 경우에만 읽을 수 있습니다. 두 경우 모두 데이터베이스가 이미 존재해야합니다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="translated">데이터베이스는 읽고 쓰기 위해 열리고 아직없는 경우 만들어집니다. 이것은 sqlite3_open () 및 sqlite3_open16 ()에 항상 사용되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="translated">데이터베이스가 읽기 전용 모드로 열립니다. 데이터베이스가 존재하지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="translated">데이터베이스를 읽을 수는 있지만 쓸 수는 없습니다. 여러 프로세스가 동시에 SHARED 잠금을 보유 할 수 있으므로 동시 판독기가 많이있을 수 있습니다. 그러나 하나 이상의 SHARED 잠금이 활성화되어있는 동안 다른 스레드 나 프로세스는 데이터베이스 파일에 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="translated">데이터베이스 페이지 크기 (바이트) 또는 페이지 크기가 65536 인 경우 1</target>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="translated">데이터베이스 페이지 크기 (바이트)입니다. 512에서 32768 사이의 2의 거듭 제곱이거나 페이지 크기가 65536을 나타내는 값 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블 의 데이터베이스 스키마 는 일반적으로 해시에 포함되지 않지만 &quot;--schema&quot;옵션으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a6eadb07a326767237571a6c459f7de69f6f90" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">데이터베이스 스키마 ( &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 테이블에 있음)는 일반적으로 해시에 포함되지 않지만 &quot;--schema&quot;옵션으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="translated">데이터베이스 텍스트 인코딩 값 1은 UTF-8을 의미합니다. 값 2는 UTF-16le을 의미합니다. 3의 값은 UTF-16be를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e0c8f6d94e8860f110aff3d0dcf3dec439a12ec1" translate="yes" xml:space="preserve">
          <source>The database will be opened as an in-memory database. The database is named by the &quot;filename&quot; argument for the purposes of cache-sharing, if shared cache mode is enabled, but the &quot;filename&quot; is otherwise ignored.</source>
          <target state="translated">데이터베이스는 메모리 내 데이터베이스로 열립니다. 데이터베이스는 공유 캐시 모드가 활성화 된 경우 캐시 공유를 위해 &quot;filename&quot;인수에 의해 이름이 지정되지만 그렇지 않으면 &quot;filename&quot;이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d24a19630de1f62dd0aa22d7bd05ac2f4445ed6a" translate="yes" xml:space="preserve">
          <source>The datatype and &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; of the generated column are determined only by the datatype and &lt;a href=&quot;lang_createtable#collateclause&quot;&gt;COLLATE clause&lt;/a&gt; on the column definition. The datatype and collating sequence of the GENERATED ALWAYS AS expression have no affect on the datatype and collating sequence of the column itself.</source>
          <target state="translated">생성 된 열의 데이터 유형 및 데이터 &lt;a href=&quot;datatype3#collation&quot;&gt;정렬 순서&lt;/a&gt; 는 열 정의 의 데이터 유형 및 &lt;a href=&quot;lang_createtable#collateclause&quot;&gt;COLLATE 절&lt;/a&gt; 에 의해서만 결정됩니다 . GENERATED ALWAYS AS 표현식의 데이터 유형 및 배열 순서는 열 자체의 데이터 유형 및 배열 순서에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="translated">열의 데이터 유형이 콜백의 네 번째 인수에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">날짜 및 시간 함수는 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; 날짜 및 시간 형식 의 하위 세트를 사용합니다 . date () 함수는 날짜를 YYYY-MM-DD 형식으로 반환합니다. time () 함수는 시간을 HH : MM : SS로 반환합니다. datetime () 함수는 &quot;YYYY-MM-DD HH : MM : SS&quot;를 반환합니다. julianday () 함수는 BC 4714 년 11 월 24 일 그리니치에서 정오 이후의 일 수인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian 일을&lt;/a&gt; 리턴합니다 (Proleptic &lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Gregorian calendar&lt;/a&gt; ). strftime () 루틴은 첫 번째 인수로 지정된 형식 문자열에 따라 형식화 된 날짜를 리턴합니다. 형식 문자열은 표준 C 라이브러리 의 &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime () 함수&lt;/a&gt; 에서 발견 된 가장 일반적인 대체 와 두 개의 새로운 대체, % f 및 % J를 지원합니다. 다음은 유효한 strftime () 대체의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">db 매개 변수는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 실행하는 SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터 입니다. pAux 인수는 &lt;a href=&quot;c3ref/module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 을 등록한 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 호출 에 대한 네 번째 인수 인 클라이언트 데이터 포인터의 사본입니다 . argv 매개 변수는 널 종료 문자열에 대한 argc 포인터의 배열입니다. 첫 번째 문자열 인 argv [0]은 호출되는 모듈의 이름입니다. 모듈 이름은 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()에&lt;/a&gt; 대한 두 번째 인수 및 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 의 USING 절에 대한 인수로 제공되는 이름입니다.실행중인 문. 두 번째 argv [1]은 새 가상 테이블이 작성되는 데이터베이스의 이름입니다. 데이터베이스 이름은 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 데이터베이스의 경우 &quot;temp&quot;이거나 연결된 데이터베이스 의 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 끝에 주어진 이름 입니다. 배열의 세 번째 요소 인 argv [2]는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문 에서 TABLE 키워드 다음에 지정된 새 가상 테이블의 이름입니다 . 있는 경우 argv [] 배열의 네 번째 및 후속 문자열은 인수를 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문 에서 모듈 이름으로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="translated">dbhash bsdhash.hashopen에 프로그램이 호출 C 코드의 단일 파일에 의해 구현된다 &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt; . dbhash 프로그램을 수동으로 빌드하려면 dbhash.c 소스 파일을 컴파일하여 SQLite 라이브러리에 링크하십시오.</target>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="translated">dbhash.exe 유틸리티 프로그램</target>
        </trans-unit>
        <trans-unit id="825612a3619e0d061fa775e13b4301fdfc5c4d06" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer has been so successful at hardening the SQLite code base against malicious attack that it is now considered one of the four primary test harnesses for SQLite.</source>
          <target state="translated">dbsqlfuzz fuzzer는 악의적 인 공격으로부터 SQLite 코드 기반을 강화하는 데 매우 성공적이어서 이제는 SQLite의 4 가지 주요 테스트 도구 중 하나로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="translated">dbsqlfuzz fuzzer는 SQL 입력과 데이터베이스 파일을 동시에 변경합니다. Dbsqlfuzz는 입력 데이터베이스와 해당 데이터베이스에 대해 실행할 SQL 텍스트를 모두 정의하는 특수 입력 파일에서 사용자 정의 &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;구조 인식&lt;/a&gt; 변경자를 사용 합니다. 입력 데이터베이스와 입력 SQL을 동시에 변경하기 때문에 dbsqlfuzz는 SQLite 또는 데이터베이스 파일 만 변경 한 이전 퍼 저가 놓친 SQLite에서 모호한 오류를 찾을 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="e0f01bd5981d7e05e25eea466d94ddbb29381d04" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file. The SQLite developers usually leave an instance or two of dbsqlfuzz running on the latest trunk code of SQLite whenever they are away from the office for an extended period, such as overnight.</source>
          <target state="translated">dbsqlfuzz fuzzer는 SQL 입력과 데이터베이스 파일을 동시에 변경합니다. Dbsqlfuzz는 해당 데이터베이스에 대해 실행할 입력 데이터베이스와 SQL 텍스트를 모두 정의하는 특수 입력 파일에서 사용자 지정 &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;구조 인식 Mutator&lt;/a&gt; 를 사용합니다. 입력 데이터베이스와 입력 SQL을 동시에 변경하기 때문에 dbsqlfuzz는 SQL 입력 만 변경하거나 데이터베이스 파일 만 변경 한 이전 fuzzer가 놓친 SQLite에서 일부 모호한 오류를 찾을 수있었습니다. SQLite 개발자는 일반적으로 밤새도록 사무실에서 멀리 떨어져있을 때마다 SQLite의 최신 트렁크 코드에서 실행되는 dbsqlfuzz 인스턴스를 한두 개 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">dbstat와 가상 테이블은이다 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; 이 실행할 필요가 없습니다 의미 &lt;a href=&quot;lang_createvtab&quot;&gt;VIRTUAL TABLE CREATE&lt;/a&gt; 를 사용하기 전에 dbstat와 가상 테이블의 인스턴스를 만들 수 있습니다. &quot;dbstat&quot;모듈 이름은 마치 dbstat 가상 테이블을 직접 쿼리하기위한 테이블 이름 인 것처럼 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e223099b7354d29f8974670689fc48600a955fe9" translate="yes" xml:space="preserve">
          <source>The decimal extension is not (currently) part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. However, it is included in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;.</source>
          <target state="translated">십진수 확장자는 (현재) SQLite &lt;a href=&quot;amalgamation&quot;&gt;합병의&lt;/a&gt; 일부가 아닙니다 . 그러나 &lt;a href=&quot;cli&quot;&gt;CLI에&lt;/a&gt; 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf449afd5954b4d824e05da84c86a3c14eb17489" translate="yes" xml:space="preserve">
          <source>The decimal extension provides arbitrary-precision decimal arithmetic on numbers stored as text strings. Because the numbers are stored to arbitrary precision and as text, no approximations are needed. Computations can be done exactly.</source>
          <target state="translated">10 진수 확장은 텍스트 문자열로 저장된 숫자에 대해 임의 정밀도 10 진수 산술을 제공합니다. 숫자는 임의의 정밀도로 텍스트로 저장되기 때문에 근사치가 필요하지 않습니다. 계산은 정확하게 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e61a5a7c6ccc546025a4d388dfa7ed2605e38bb" translate="yes" xml:space="preserve">
          <source>The decimal_sum(X) function is an aggregate, like the built-in &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum() aggregate function&lt;/a&gt;, except that decimal_sum() computes its result to arbitrary precision and is therefore precise.</source>
          <target state="translated">decimal_sum (X) 함수는 decimal_sum ()이 결과를 임의 정밀도로 계산하므로 정확하다는 점을 제외 하면 내장 &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum () 집계 함수&lt;/a&gt; 와 같은 집계 입니다.</target>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="translated">FROM- 절 서브 쿼리를 공동 루틴으로 구현할 것인지 또는 &lt;a href=&quot;optoverview#flattening&quot;&gt;쿼리 병합을&lt;/a&gt; 사용할 것인지에 대한 결정은 이제 외부 쿼리의 결과 세트가 &quot;복잡한&quot;(함수 또는 표현식 서브 쿼리를 포함하는 경우) 여부를 고려합니다. 복잡한 결과 집합은 공동 루틴 사용에 대한 결정을 편향시킵니다.</target>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="translated">사용할 조합 순서 결정은 SQL의 COLLATE 절에 의해 제어됩니다. COLLATE 절은 테이블 정의, 테이블 컬럼 또는 인덱스 필드 또는 SELECT 문의 ORDER BY 절에 기본 배열 순서를 정의하기 위해 발생할 수 있습니다. SQLite의 계획된 향상 기능은 표준 CAST () 구문을 포함하여 표현식의 조합 순서를 정의 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="translated">테이블에서 각 열의 선언 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="translated">기본 'crisismerge'값은 16입니다. 최대 제한은 없습니다. 'crisismerge'매개 변수를 0 또는 1의 값으로 설정하는 것은 기본값 (16)으로 설정하는 것과 같습니다. 'crisismerge'옵션을 음수 값으로 설정하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="translated">기본 &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식 번호&lt;/a&gt; 가 1에서 4로 변경되었습니다. 이는 &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format = ON&lt;/a&gt; 문을 실행 하지 않으면 새로 만들어진 데이터베이스 파일을 3.3.0 (2006-01-10) 이전의 SQLite 버전에서 읽을 수 없음을 의미합니다. 또한 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;내림차순 인덱스&lt;/a&gt; 가 기본적으로 활성화되어 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="translated">새 데이터베이스 파일을 작성할 때 SQLite가 사용하는 기본 &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식 번호&lt;/a&gt; 는이 매크로에 의해 설정됩니다. 스키마 형식은 모두 매우 유사합니다. 형식 1과 4의 차이점은 형식 4는 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;내림차순 인덱스를&lt;/a&gt; 이해 하고 부울 값에 대한 인코딩이 더 엄격 하다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="translated">기본 마스크는 항상 0xfffe입니다. 0xfffe 마스크는 디버그 모드를 제외하고 위에 나열된 모든 최적화를 수행함을 의미합니다. 미래에 새로운 최적화가 추가되어 기본적으로 해제되어 있으면 새 최적화에는 0x10000 이상의 마스크가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 두 번째 매개 변수가 1 인 VFS를 등록하거나 다시 등록하면 기본 VFS를 변경할 수 있습니다 . 따라서 (unix) 프로세스가 항상 &quot;unix-nolock&quot;VFS를 사용하려는 경우 &quot; 유닉스 &quot;, 다음 코드가 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">로드 가능한 확장의 기본 동작은 원래 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()을&lt;/a&gt; 호출 한 데이터베이스 연결이 닫힐 때 프로세스 메모리에서 언로드되는 것입니다 . 즉, 데이터베이스 연결이 닫힐 때 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xDlUnload 메소드가 모든 확장에 대해 호출됩니다. 그러나 초기화 프로 시저가 &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK&lt;/a&gt; 대신 SQLITE_OK_LOAD_PERMANENTLY 를 리턴 하면 확장이 언로드되지 않습니다 (xDlClose가 호출되지 않음) 확장은 프로세스 메모리에 무한정 남아 있습니다. SQLITE_OK_LOAD_PERMANENTLY 반환 값은 새 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 등록하려는 확장에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="translated">기본 동작은 다음과 같은 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="translated">표준 C에서 assert (X)의 기본 동작은 릴리스 빌드에 사용 가능하다는 것입니다. 이것은 합리적인 기본값입니다. 그러나 SQLite 코드베이스에는 코드의 성능에 민감한 영역에 많은 assert () 문이 있습니다. assert (X)를 켜두면 SQLite가 약 3 배 느리게 실행됩니다. 또한 SQLite는 제공된 구성으로 100 % MC / DC를 제공하기 위해 노력하고 있으며 assert (X) 문이 활성화되어 있으면 불가능합니다. 이러한 이유로 assert (X)는 SQLite에서 릴리스 빌드를위한 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 의 기본 동작은 ASCII 문자의 대소 문자를 무시하는 것입니다. 따라서 기본적 &lt;b&gt;으로 'a'LIKE 'A'&lt;/b&gt; 는 true입니다. case_sensitive_like pragma는 case_sensitive_like pragma의 값에 따라 대 / 소문자를 구분하거나 구분하지 않는 새로운 응용 프로그램 정의 LIKE 함수를 설치합니다. case_sensitive_like가 비활성화되면 기본 LIKE 동작이 표현됩니다. case_sensitive_like를 사용하면 대소 문자가 중요해집니다. 예를 들어, &lt;b&gt;'a'LIKE 'A'&lt;/b&gt; 는 false이지만 &lt;b&gt;'a'LIKE 'a'&lt;/b&gt; 는 여전히 참입니다.</target>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="translated">Unix, Windows 및 OS / 2에서 SQLite의 기본 빌드에는 대상 플랫폼에 적합한 VFS가 포함됩니다. 다른 운영 체제에 대한 SQLite 빌드에는 기본적으로 VFS가 포함되어 있지 않지만 응용 프로그램은 런타임에 하나 이상을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="translated">기본 통화 중 콜백은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">모든 문자열의 기본 데이터 정렬 기능은 BINARY입니다. 테이블 열에 대한 대체 데이터 정렬 함수 는 &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;열 정의&lt;/a&gt; 에서 COLLATE 절을 사용하여 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 지정할 수 있습니다 . 열이 색인화 될 때 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문에 지정된 동일한 조합 함수 가 기본적으로 색인의 열에 사용되지만 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문의 COLLATE 절을 사용하여 겹쳐 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="translated">SQLite의 기본 구성은 대부분의 응용 프로그램에 적합합니다. 그러나 개발자는 약간 더 많은 성능을 발휘하거나 모호한 기능을 활용하기 위해 설정을 조정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="translated">SQLite의 기본 구성은 기본 파일 시스템이 긴 파일 이름을 지원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="translated">SQLite의 기본 구성은 ASCII 문자의 대소 문자를 구분하지 않는 비교 만 지원합니다. 그 이유는 유니 코드 대 / 소문자를 구분하지 않고 대 / 소문자 변환을 수행하려면 SQLite 라이브러리 크기의 거의 두 배인 테이블과 논리가 필요하기 때문입니다. SQLite 개발자는 완전한 유니 코드 사례 지원이 필요한 응용 프로그램에 이미 필요한 테이블과 함수가있을 수 있으므로 SQLite는이 기능을 복제하기 위해 공간을 차지하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="translated">기본 데이터 유형은 'int32'입니다.</target>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="translated">기본 삭제 비용</target>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="translated">임시 파일의 기본 디렉토리는 OS에 따라 다릅니다. 일부 OS 인터페이스는이 변수를 무시하고 여기에 지정된 디렉토리와 다른 일부 디렉토리에 임시 파일을 배치하도록 선택할 수 있습니다. 그런 의미에서이 pragma는 자문 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="translated">sqlite3_open () 또는 sqlite3_open_v2 ()를 사용하여 작성된 데이터베이스의 기본 인코딩은 UTF-8입니다. sqlite3_open16 ()을 사용하여 생성 된 데이터베이스의 기본 인코딩은 기본 바이트 순서로 UTF-16입니다.</target>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="translated">기본 파일 형식은 이제 1입니다.</target>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="translated">기본 파일 형식은 &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; 컴파일 타임 옵션으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="translated">기본 프레임 사양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">기본 구현은 모든 통계를 &quot; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &quot; 이라는 단일 테이블에 저장합니다 . SQLite는이 컴파일되면 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3의&lt;/a&gt; 옵션과 않고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4의&lt;/a&gt; 옵션을 추가 한 다음, 히스토그램 데이터를 수집 및 저장된다 &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; . SQLite가 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 옵션으로 컴파일되면 추가 막대 그래프 데이터가 수집되어 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4에&lt;/a&gt; 저장됩니다 . 이전 버전의 SQLite는 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2로&lt;/a&gt; 컴파일 할 때 &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; 테이블 을 사용 하지만 모든 최신 SQLite 버전은 sqlite_stat2 테이블을 무시합니다. 향후 향상으로 추가 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블&lt;/a&gt; 이 생성 될 수 있음&quot;4&quot;보다 큰 최종 자릿수를 제외하고 동일한 이름 패턴으로 이러한 모든 테이블을 통칭하여 &quot;통계 테이블&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="2000f471d1e2f9fad888fbe96454c85325906ea0" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table or &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;, but all recent versions of SQLite ignore the sqlite_stat2 and sqlite_stat3 tables. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">기본 구현은 &quot; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &quot; 이라는 단일 테이블에 모든 통계를 저장합니다 . SQLite가 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 옵션으로 컴파일되면 추가 히스토그램 데이터가 수집되어 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4에&lt;/a&gt; 저장됩니다 . 이전 버전의 SQLite는 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3로&lt;/a&gt; 컴파일 할 때 &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; 테이블 또는 &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; 테이블을 사용 하지만 SQLite의 모든 최신 버전은 sqlite_stat2 및 sqlite_stat3 테이블을 무시합니다. 향후 개선으로 인해 추가 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블&lt;/a&gt; 이 생성 될 수 있습니다.마지막 숫자가 &quot;4&quot;보다 큰 것을 제외하고 동일한 이름 패턴을 사용합니다. 이러한 모든 테이블을 통칭하여 &quot;통계 테이블&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="translated">기본 삽입 비용</target>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="translated">Unix 플랫폼에서 SQLite가 사용하는 기본 잠금 메커니즘은 POSIX 권고 잠금이지만 다른 옵션이 있습니다. &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스를 사용하여 대체 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 를 선택하면 응용 프로그램은 특정 파일 시스템에 더 적합한 다른 잠금 프로토콜을 사용할 수 있습니다. 예를 들어, POS 파일 권고 잠금을 지원하지 않는 NFS 파일 시스템에서 실행해야하는 응용 프로그램에서 사용하기 위해 도트 파일 잠금이 선택 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="translated">UNIX 플랫폼에서 SQLite가 사용하는 기본 잠금 메커니즘은 POSIX 권고 잠금입니다. 불행히도 POSIX 권고 잠금에는 오용과 실패가 발생하기 쉬운 설계 문제가 있습니다. 특히, POSIX 권고 잠금을 보유하고있는 파일 디스크립터가있는 동일한 프로세스의 스레드는 다른 파일 디스크립터를 사용하여 해당 잠금을 대체 할 수 있습니다. 특히 중요한 문제 중 하나는 &lt;code&gt;close()&lt;/code&gt; 시스템 호출이 프로세스의 모든 스레드 및 모든 파일 설명자에 대해 동일한 파일의 모든 POSIX 권고 잠금을 취소한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07275b3b33b4fa68f4e8147d7f962856df7d7bd0" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration has changed from 100 slots of 1200 bytes each (120KB) to be 40 slots of 1200 bytes each (48KB). This space ends up being allocated as 93 slots of 128 bytes each and 30 slots of 1200 bytes each. So more lookaside slots are available but much less heap space is used.</source>
          <target state="translated">기본 lookaside 구성이 각 1200 바이트 (120KB)의 100 개 슬롯에서 각 1200 바이트 (48KB)의 슬롯 40 개로 변경되었습니다. 이 공간은 각각 128 바이트의 93 개 슬롯과 각각 1200 바이트의 30 개 슬롯으로 할당됩니다. 따라서 더 많은 lookaside 슬롯을 사용할 수 있지만 훨씬 적은 힙 공간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e313113e047c2f26bfe18f713c540368922a076" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration, the size of the small-slots, and the details of how heap space is allocated between small-slots and big-slots, are all subject to change from one release to the next.</source>
          <target state="translated">기본 lookaside 구성, 작은 슬롯의 크기 및 작은 슬롯과 큰 슬롯 사이에 힙 공간이 할당되는 방법에 대한 세부 사항은 모두 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="translated">테이블에 대한 순위 열의 기본 매핑은 &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 순위 구성 옵션을&lt;/a&gt; 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="translated">기본 최대 트리거 재귀 깊이는 1000입니다.</target>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="translated">디폴트는 집계 창 함수가 파티션의 시작부터 현재 행 및 피어를 포함하여 모든 행을 읽음을 의미합니다. 이것은 모든 ORDER BY 표현식에 대해 동일한 값을 갖는 행이 창 함수의 결과에 대해 동일한 값을 갖음을 의미합니다 (윈도우 프레임이 동일하므로). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="translated">SQLite가 데이터베이스 디스크 파일에 액세스하고 업데이트하는 기본 메커니즘은 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS 객체 의 xRead () 및 xWrite () 메서드입니다 . 이러한 메소드는 일반적으로 &quot;read ()&quot;및 &quot;write ()&quot;시스템 호출로 구현되어 운영 체제가 커널 버퍼 캐시와 사용자 공간간에 디스크 컨텐츠를 복사하게합니다.</target>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="translated">SQLite의 기본 메모리 할당 설정은 대부분의 응용 프로그램에 적합합니다. 그러나 비정상적이거나 특히 엄격한 요구 사항을 가진 응용 프로그램은 SQLite를 필요에보다 가깝게 맞추기 위해 구성을 조정하려고 할 수 있습니다. 컴파일 타임 및 시작 시간 구성 옵션을 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="translated">대부분의 응용 프로그램에는 기본 메모리 할당자가 권장됩니다. 대체 메모리 할당자를 사용해야 할 필요가 없으면 기본값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;atomiccommit&quot;&gt;원자 커밋 및 롤백을&lt;/a&gt; 구현하는 기본 방법 은 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 입니다. &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21) 부터는 새로운 &quot;쓰기 우선 로그&quot;옵션 (이하 &quot;WAL&quot;이라고 함)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="translated">기본 모드는 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="translated">유닉스에서 새로 생성 된 데이터베이스 파일에 대한 기본 숫자 파일 권한. 지정하지 않으면 기본값은 0644이며 파일을 전체적으로 읽을 수 있지만 작성자 만 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="translated">edit ()의 기본 조작은 텍스트 편집기를 호출하는 것입니다. 그러나 두 번째 인수에서 대체 편집 프로그램을 사용하면 이미지 또는 기타 텍스트가 아닌 리소스를 편집 할 수도 있습니다. 예를 들어, 테이블 필드에 저장되는 JPEG 이미지를 수정하려는 경우 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="translated">조인에서 중첩 루프의 기본 순서는 FROM 절의 가장 왼쪽 테이블이 외부 루프를 형성하고 가장 오른쪽 테이블이 내부 루프를 형성하는 것입니다. 그러나 SQLite는 루프를 다른 순서로 중첩하여 더 나은 인덱스를 선택하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">기본 출력 모드는 &quot;list&quot;입니다. 목록 모드에서 쿼리 결과의 각 행은 한 줄의 출력으로 작성되며 해당 행의 각 열은 특정 구분자 문자열로 구분됩니다. 기본 구분 기호는 파이프 기호 ( &quot;|&quot;)입니다. 목록 모드는 추가 처리를 위해 쿼리 출력을 다른 프로그램 (예 : AWK)으로 보낼 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="translated">기본 출력은 각 구성 및 테스트 모듈 조합의 시작과 끝을 보여줍니다. 위의 예에서 &quot;c1&quot;및 &quot;64k&quot;는 구성이고 &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;등은 테스트 모듈입니다. 컴파일 시간 및 런타임 옵션을 사용하여 출력량을 늘리거나 줄일 수 있습니다. 각 테스트 모듈 내에서 각 테스트 사례를 표시하여 출력을 늘릴 수 있습니다. 테스트 모듈을 시작 및 중지하거나 구성 시작 및 중지를 생략하고 마지막으로 모든 출력을 생략하면 출력을도 단위로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="translated">기본 페이지 캐시 구현은 한 번에 전체 양의 캐시 메모리를 할당하지 않습니다. 캐시 메모리는 필요에 따라 더 작은 청크로 할당됩니다. page_cache 설정은 항상 사용할 메모리 양이 아니라 캐시가 사용할 수있는 메모리 양에 대한 (제안 된) 상한입니다. 이것은 기본 페이지 캐시 구현의 동작이지만 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 는 원하는 경우 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5d7962d2b50c7baceb7ed65dad81e0058ad64b" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">기본 페이지 캐시는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에&lt;/a&gt; 의해 할당 된 것 이상의 메모리 사용을 피하기 위해 더 열심히 노력 합니다. 또는 페이지 캐시를 사용하여 힙에서 할당하는 경우 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 가 설정되지 않은 경우에도 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()를&lt;/a&gt; 넘지 않도록 노력합니다 .</target>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">기본 페이지 캐시는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에&lt;/a&gt; 의해 할당 된 것 이상의 메모리 사용을 피하기 위해 더욱 부지런히 노력 합니다. 또는 페이지 캐시 사용이 힙에서 할당되는 경우 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 가 설정되지 않은 경우에도 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 로 넘어 가지 않도록 노력합니다 .</target>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="translated">창의 기본 페이지 크기는 기본 파일 시스템의 기능과 일치하도록 자동으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="translated">SQLITE_MAX_COLUMN의 기본 설정은 2000입니다. 컴파일시이를 32767만큼 큰 값으로 변경할 수 있습니다. 반면에 경험이 많은 데이터베이스 디자이너는 정규화 된 데이터베이스가 테이블에 열을 100 개 이상 필요로하지 않을 것이라고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="translated">&lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; 컴파일 타임 옵션을 사용 하지 않는 한 자동 진공의 기본 설정은 0 또는 &quot;없음&quot; 입니다. &quot;없음&quot;설정은 자동 진공이 비활성화되었음을 의미합니다. 자동 진공이 비활성화되고 데이터베이스에서 데이터가 삭제되면 데이터베이스 파일의 크기는 동일하게 유지됩니다. 사용하지 않은 데이터베이스 파일 페이지가 &quot; &lt;a href=&quot;fileformat2#freelist&quot;&gt;프리리스트&lt;/a&gt; &quot;에 추가되고 후속 삽입에 재사용됩니다. 따라서 데이터베이스 파일 공간이 손실되지 않습니다. 그러나 데이터베이스 파일은 축소되지 않습니다. 이 모드에서 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 사용하여 전체 데이터베이스 파일을 다시 작성하여 사용되지 않은 디스크 공간을 회수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 의 기본 설정 은 0이며 이는 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 권장 사항을 따르는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="translated">이 pragma의 기본 설정은 OFF입니다. 이는 스키마의 모든 위치에있는 테이블에 대한 모든 참조가 새 이름으로 변환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="translated">기본 설정은 1입니다. 추가 정보는 &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="translated">기본 정렬 절차는 궁극적으로 &quot;레코드&quot;로 출력 될 모든 정보를 수집하고 해당 전체 레코드를 분류기로 전달하는 것입니다. 그러나 일부 경우, 예를 들어 일부 출력 열이 큰 BLOB 값으로 구성되는 경우 각 레코드의 크기가 클 수 있으므로 분류 기가 더 많은 메모리를 사용하거나 더 많은 내용을 임시 저장소에 써야합니다. .</target>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="translated">기본 전략은 WAL의 크기가 약 1000 페이지가 될 때까지 연속 쓰기 트랜잭션이 WAL을 증가시킨 다음 WAL이 1000 페이지보다 작게 재설정 될 때까지 각 후속 COMMIT에 대해 검사 점 작업을 실행하는 것입니다. 기본적으로 검사 점은 WAL을 크기 제한을 초과하는 COMMIT와 동일한 스레드에서 자동으로 실행됩니다. 이는 대부분의 COMMIT 조작이 매우 빠르지 만 가끔 COMMIT (체크 포인트를 트리거하는)가 훨씬 느리게하는 효과가 있습니다. 이 효과가 바람직하지 않은 경우 응용 프로그램은 자동 검사 점을 비활성화하고 별도의 스레드 또는 별도의 프로세스에서 주기적 검사 점을 실행할 수 있습니다. 이를 수행하기위한 명령 및 인터페이스에 대한 링크가 &lt;a href=&quot;#how_to_checkpoint&quot;&gt;아래&lt;/a&gt; 에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="translated">기본 대체 비용</target>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="translated">기본 동기 설정이 가득 찼으므로 위와 같은 경우가 일반적입니다. 그러나 동기 설정이 &quot;정상&quot;으로 낮아지면 SQLite는 페이지 수를 쓴 후 롤백 저널을 한 번만 플러시합니다. 모든 데이터가 수정되기 전에 수정 된 (0이 아닌) 페이지 수가 디스크 표면에 도달 할 수 있으므로 손상 될 위험이 있습니다. 데이터는 먼저 기록되지만 SQLite는 기본 파일 시스템이 쓰기 요청을 다시 정렬 할 수 있으며 쓰기 요청이 마지막으로 발생하더라도 페이지 수를 먼저 산화물로 레코딩 할 수 있다고 가정합니다. 따라서 두 번째 방어선으로 SQLite는 롤백 저널의 모든 데이터 페이지에서 32 비트 체크섬을 사용합니다. 이 체크섬은 &lt;a href=&quot;#section_4_4&quot;&gt;4.4 절에&lt;/a&gt; 설명 된대로 저널을 롤백하는 동안 롤백 중 각 페이지에 대해 평가됩니다.. 잘못된 체크섬이 표시되면 롤백이 취소됩니다. 체크섬은 데이터가 손상 되더라도 체크섬이 정확할 가능성은 작지만 유한 할 가능성이 있기 때문에 페이지 데이터가 정확하다는 것을 보증하지 않습니다. 그러나 체크섬은 적어도 그러한 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="095be1a2c22dcc1b72f1d8ee5a80821a8e3ba1f7" translate="yes" xml:space="preserve">
          <source>The default value for SQLITE_PRINTF_PRECISION_LIMIT is 2147483647 (0x7fffffff).</source>
          <target state="translated">SQLITE_PRINTF_PRECISION_LIMIT의 기본값은 2147483647 (0x7fffffff)입니다.</target>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="translated">languageid의 기본값은 0입니다. 대체 언어가 WHERE 절 제약 조건에 지정된 경우 대체 언어는 0 대신 사용됩니다. 쿼리 당 하나의 languageid 만있을 수 있습니다. 즉, WHERE 절은 languageid에 대한 범위 제한 조건 또는 IN 연산자를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="translated">languageid 열의 기본값은 0입니다. languageid 열에 삽입 된 모든 값은 32 비트 (64 아님) 부호있는 정수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 기본값 은 1이며, 이는 임시 파일을 디스크에 저장하지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma를&lt;/a&gt; 사용하여 작동을 대체하는 옵션을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="translated">usermerge 옵션의 기본값은 4입니다. 허용되는 최소값은 2이고 최대 값은 16입니다.</target>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="translated">기본 가상 테이블 ( &quot;rtree&quot;)은 일반적으로 좌표를 단정도 (4 바이트) 부동 소수점 숫자로 저장합니다. 정수 좌표가 필요한 경우 &quot;rtree_i32&quot;를 대신 사용하여 테이블을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="translated">데모 코드는 SQLite 데이터베이스가 &quot;db&quot;라는 데이터베이스 개체로 사용 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="translated">아래 데모 코드에는 취소 또는 다시 실행할 항목이 있는지 여부에 따라 실행 취소 및 다시 실행 버튼과 메뉴 항목이 회색으로 표시되거나 활성화되는 status_refresh 메소드가 포함되어 있습니다. 응용 프로그램에서 실행 취소 및 다시 실행 단추를 제어하려면이 방법을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="translated">트리거의 재귀 깊이에는 &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; 컴파일 시간 옵션에 의해 설정된 하드 상한 과 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit에&lt;/a&gt; 의해 설정된 런타임 제한 (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; , ...)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="translated">OpenOffice의 자손은 상용 경쟁 업체보다 더 자주 segfault하는 경향이 있습니다. 이러한 이유로 OpenOffice 포크는 메모리 내 문서를 정기적으로 백업하여 불가피한 응용 프로그램 충돌이 발생할 때 사용자가 보류중인 편집 내용을 모두 잃지 않도록합니다. 이로 인해 각 백업이 수행되는 동안 몇 초 동안 응용 프로그램에서 좌절 일시 중지가 발생합니다. 충돌에서 다시 시작하면 복구 프로세스를 안내하는 대화 상자가 표시됩니다. 이러한 방식으로 응급 복구를 관리하려면 많은 추가 응용 프로그램 논리가 필요하며 일반적으로 사용자에게 성가신 일입니다.</target>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="translated">설계된 쿼리 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="translated">detail 옵션은 &quot;full&quot;(기본값), &quot;column&quot;또는 &quot;none&quot;으로 설정 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="translated">이 pragma에 의해 수행 된 최적화의 세부 사항은 시간이 지남에 따라 변경되고 개선 될 것으로 예상됩니다. 애플리케이션은이 pragma가 향후 릴리스에서 새로운 최적화를 수행 할 것으로 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">sqlite3_step () 인터페이스의 동작의 세부 사항은 문이 새로운 &quot;VX&quot;인터페이스를 사용하여 준비 여부에 따라 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 이전 레거시 인터페이스 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16를 ()&lt;/a&gt; . 새로운 응용 프로그램에는 새로운 &quot;vX&quot;인터페이스를 사용하는 것이 좋지만 기존 인터페이스는 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">sqlite3_step () 인터페이스의 동작의 세부 사항은 문이 새로운 &quot;VX&quot;인터페이스를 사용하여 준비 여부에 따라 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 이전 레거시 인터페이스 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16를 ()&lt;/a&gt; . 새로운 응용 프로그램에는 새로운 &quot;vX&quot;인터페이스를 사용하는 것이 좋지만 기존 인터페이스는 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d328873bfc7a5d2f8f59abeab740350558a37fbf" translate="yes" xml:space="preserve">
          <source>The details of the effects of the analysis limit described in the previous paragraph are subject to change in future versions of SQLite. But the core idea will remain the same. An analysis limit of N will strive to limit the number of rows visited in each index to approximately N.</source>
          <target state="translated">이전 단락에서 설명한 분석 한계의 영향에 대한 세부 사항은 SQLite의 향후 버전에서 변경 될 수 있습니다. 그러나 핵심 아이디어는 동일하게 유지됩니다. 분석 제한 N은 각 인덱스에서 방문한 행 수를 약 N으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="translated">작동 코드의 세부 사항, 의미, 사용하는 매개 변수 및 수행하는 작업은 모두 예고없이 변경 될 수 있습니다. 대부분의 SQLite API와 달리이 함수는 한 릴리스에서 다음 릴리스로 일관되게 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="translated">개발자는 커밋 메커니즘을 최적화하는 새로운 방법을 모색하고 있습니다. Unix (Linux 및 Mac OS X) 및 Windows에 대한 현재 VFS 구현은 해당 시스템의 동작에 대해 비관적 인 가정을합니다. 이러한 시스템의 작동 방식에 대해 전문가와상의 한 후 시스템에 대한 일부 가정을 완화하고 더 빠르게 실행할 수 있습니다. 특히, 우리는 대부분의 최신 파일 시스템이 안전한 추가 속성을 나타내며 대부분이 원자 섹터 쓰기를 지원할 수 있다고 생각합니다. 그러나 이것이 확실하게 알려질 때까지 SQLite는 보수적 인 접근 방식을 취하고 최악의 상황을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e4066095f770552d7d59a59bea4105aa7d61a017" translate="yes" xml:space="preserve">
          <source>The developers have no editorial influence on the content of CVEs, and they do not like to be controlled by groups in which they have no voice.</source>
          <target state="translated">개발자는 CVE의 내용에 대한 편집 영향이 없으며 자신이 발언권이없는 그룹에 의해 제어되는 것을 좋아하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="translated">SQLite 개발자는 자동 테스트 절차를 통해 SQLite가 시뮬레이션 된 전력 손실을 복구 할 수있는 능력에 대한 광범위한 검사를 수행하므로 정전 및 시스템 충돌시 강력하다고 확신합니다. 이를 &quot;충돌 테스트&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="translated">SQLite 개발자는 전체 범위 테스트가 버그를 찾고 예방하는 데 매우 효과적인 방법이라는 것을 알게되었습니다. SQLite 핵심 코드의 모든 단일 분기 명령어는 테스트 사례에 의해 다루어 지므로 개발자는 코드의 한 부분에서 변경 한 내용이 다른 코드 부분에서 의도하지 않은 결과를 초래하지 않는다고 확신 할 수 있습니다. 최근 몇 년 동안 SQLite에 추가 된 많은 새로운 기능과 성능 향상은 가용성 전체 범위 테스트 없이는 불가능했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="translated">SQLite 개발자는 2050 년까지 제품을 지원할 계획입니다.이를 위해 소스 코드는 신중하게 문서화되어 장기적인 유지 보수성을 향상시킵니다. 트렌디하고 최첨단보다 성숙하고 안정적인 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="6b11572798416066a74cf3226912c7c4d4e245c6" translate="yes" xml:space="preserve">
          <source>The developers often do not find out about CVEs until long after the bug is fixed. You can see this by the fact that many CVEs reference the bug fix in their initial report.</source>
          <target state="translated">개발자는 버그가 수정 된 지 오래 될 때까지 CVE에 대해 알아 내지 못하는 경우가 많습니다. 많은 CVE가 초기 보고서에서 버그 수정을 참조한다는 사실을 통해이를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="translated">위의 다이어그램은 SQLite가 모든 rowid를 먼저 계산 한 다음 원래 테이블에서 rowid 조회를 시작하기 전에 통합 작업과 결합 함을 의미합니다. 실제로, rowid 조회는 rowid 계산과 함께 산재되어 있습니다. SQLite는 한 번에 하나의 인덱스를 사용하여 중복을 피하기 위해 이전에 본 rowid를 기억하면서 rowid를 찾습니다. 그러나 그것은 단지 구현 세부 사항입니다. 이 다이어그램은 100 % 정확하지는 않지만 진행 상황을 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="translated">오른쪽 다이어그램은 개념을 보여줍니다. 하나는 표준 SQLite 릴리스로 시작합니다. 예를 들어, SQLite 버전 3.6.15에서 개인 분기를 작성한다고 가정하십시오. 다이어그램에서 이것은 버전 (1)입니다. 관리자는 버전 (2)으로 표시된 기본 SQLite를 분기 공간에 정확하게 복사합니다. (1)과 (2)는 정확히 동일합니다. 그런 다음 관리자는 개인 변경 사항을 버전 (2)에 적용하여 버전 (3)을 만듭니다. 즉, 버전 (3)은 SQLite 버전 3.6.15와 편집 내용입니다.</target>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="translated">순위 열에서 읽는 것과 쿼리 내에서 직접 bm25 () 함수를 사용하는 것의 차이는 반환 된 값을 기준으로 정렬 할 때만 중요합니다. 이 경우 &quot;rank&quot;를 사용하는 것이 bm25 ()를 사용하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="translated">이 옵션과 'automerge'옵션의 차이점은 'automerge'제한에 도달하면 FTS5 만 b- 트리를 병합하기 시작한다는 것입니다. 대부분의 작업은 후속 INSERT, UPDATE 또는 DELETE 작업의 일부로 수행됩니다. 'crisismerge'한계에 도달하면 문제가되는 b- 트리는 모두 즉시 병합됩니다. 이는 위기 병합을 트리거하는 INSERT, UPDATE 또는 DELETE를 완료하는 데 시간이 오래 걸릴 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="translated">차이점은 기존 가상 테이블에 대한 새로운 연결을 설정하기 위해 xConnect가 호출되는 반면 xCreate는 처음부터 새로운 가상 테이블을 생성하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="translated">패치 세트와 변경 세트의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="translated">의 차이 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB의&lt;/a&gt; 데이터베이스와 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB의&lt;/a&gt; 데이터베이스는이 경우 : &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB은&lt;/a&gt; (는 CREATE TEMP 표 구문을 사용하여) 명시 적으로 선언하고 이름이 TEMP 테이블에 사용하거나 파일 이름으로 데이터베이스를 열어 생성되는 임시 데이터베이스의 이름 테이블에있다 그것은 빈 문자열입니다. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB는&lt;/a&gt; SQLite는 절 BY 하위 쿼리 또는 ORDER BY 또는 GROUP을 평가하기 위해 자동으로 생성하는 데이터베이스 테이블을 보유하고 있습니다. TEMP_DB 및 TRANSIENT_DB 데이터베이스는 모두 개인용이며 자동으로 삭제됩니다. TEMP_DB 데이터베이스는 데이터베이스 연결 기간 동안 지속됩니다. TRANSIENT_DB 데이터베이스는 단일 SQL 문 기간 동안 만 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="translated">디스크에 직접 쓰기는 fopen () / fwrite () / fclose ()를 사용하여 수행됩니다. 기본적으로 아래에 표시된 모든 결과에서 OS 파일 시스템 버퍼는 fsync () 또는 FlushFileBuffers ()를 사용하여 영구 저장소로 플러시되지 않습니다. 다시 말해 디스크에 직접 쓰기를 트랜잭션 또는 전원 안전으로 만들려는 시도는 없습니다. 작성된 각 파일에서 fsync () 또는 FlushFileBuffers ()를 호출하면 디스크에 직접 스토리지가 SQLite에 쓰는 것보다 약 10 배 이상 느려집니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
