<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="crystal">
    <body>
      <group id="crystal">
        <trans-unit id="2dce443fc82545ac8deb87af8402c994251dd6e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://crystal-lang.org/api/Nil.html&quot;&gt;Nil&lt;/a&gt; type is used to represent the absence of a value, similar to &lt;code&gt;null&lt;/code&gt; in other languages. It only has a single value:</source>
          <target state="translated">&lt;a href=&quot;http://crystal-lang.org/api/Nil.html&quot;&gt;Nil&lt;/a&gt; 유형은 다른 언어에서 &lt;code&gt;null&lt;/code&gt; 과 유사한 값 이 없음 을 나타내는 데 사용 됩니다. 단일 값만 있습니다.</target>
        </trans-unit>
        <trans-unit id="17c4a5ba983843f5aea4e11e5a0fc1f27ac55eb0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc2822&quot;&gt;RFC 2822&lt;/a&gt; datetime format.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2822&quot;&gt;RFC 2822&lt;/a&gt; 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="4ab4eff1bdc42eaac909d9835213e75bfab5898a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt; datetime format (&lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601&lt;/a&gt; profile).</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt; 날짜 포맷 ( &lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601&lt;/a&gt; 프로파일).</target>
        </trans-unit>
        <trans-unit id="fcc87f605187cae7714783b0008eb3aeb91780a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;macros#type-information&quot;&gt;&lt;code&gt;@type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macros#method-information&quot;&gt;&lt;code&gt;@def&lt;/code&gt;&lt;/a&gt; variables can be used to get a &lt;code&gt;TypeNode&lt;/code&gt; or &lt;code&gt;Def&lt;/code&gt; object to use the &lt;code&gt;.annotation&lt;/code&gt; method on. However, it is also possible to get &lt;code&gt;TypeNode&lt;/code&gt;/&lt;code&gt;Def&lt;/code&gt; types using other methods on &lt;code&gt;TypeNode&lt;/code&gt;. For example &lt;code&gt;TypeNode.all_subclasses&lt;/code&gt; or &lt;code&gt;TypeNode.methods&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;a href=&quot;macros#type-information&quot;&gt; &lt;code&gt;@type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;macros#method-information&quot;&gt; &lt;code&gt;@def&lt;/code&gt; &lt;/a&gt; 변수는 가져올 수 있습니다 &lt;code&gt;TypeNode&lt;/code&gt; 또는 &lt;code&gt;Def&lt;/code&gt; 객체가 사용하는 &lt;code&gt;.annotation&lt;/code&gt; 의 에 방법을. 그러나, 얻을 수도 있습니다 &lt;code&gt;TypeNode&lt;/code&gt; / &lt;code&gt;Def&lt;/code&gt; 에 다른 방법을 사용하여 유형을 &lt;code&gt;TypeNode&lt;/code&gt; 을 . 예를 들어 &lt;code&gt;TypeNode.all_subclasses&lt;/code&gt; 또는 &lt;code&gt;TypeNode.methods&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e285c46b0b0caa88d830ae22cec9c07461edbc2a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;new,_initialize_and_allocate&quot;&gt;allocate&lt;/a&gt; class method.</source>
          <target state="translated">는 &lt;a href=&quot;new,_initialize_and_allocate&quot;&gt;할당&lt;/a&gt; 클래스 메소드를.</target>
        </trans-unit>
        <trans-unit id="4a5ddc72996f1445364e8e166d40e3844178b506" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ternary_if&quot;&gt;conditional operator (&lt;code&gt;? :&lt;/code&gt;)&lt;/a&gt; is internally rewritten to an &lt;code&gt;if&lt;/code&gt; expression by the compiler.</source>
          <target state="translated">The &lt;a href=&quot;ternary_if&quot;&gt;conditional operator ( &lt;code&gt;? :&lt;/code&gt; )&lt;/a&gt; is internally rewritten to an &lt;code&gt;if&lt;/code&gt; expression by the compiler.</target>
        </trans-unit>
        <trans-unit id="d4f72334cc91327c1234f2b172d59aa15c18d9ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ternary_if&quot;&gt;conditional operator (&lt;code&gt;? :&lt;/code&gt;)&lt;/a&gt; is the only ternary operator. It not parsed as a method, and its meaning cannot be changed. The compiler transforms it to an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">The &lt;a href=&quot;ternary_if&quot;&gt;conditional operator ( &lt;code&gt;? :&lt;/code&gt; )&lt;/a&gt; is the only ternary operator. It not parsed as a method, and its meaning cannot be changed. The compiler transforms it to an &lt;code&gt;if&lt;/code&gt; expression.</target>
        </trans-unit>
        <trans-unit id="96253c38579dc948c432deceeb44fa844060b4e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; operator returns a &lt;code&gt;Bool&lt;/code&gt; that results from negating the &lt;a href=&quot;truthy_and_falsey_values&quot;&gt;truthiness&lt;/a&gt; of a value.</source>
          <target state="translated">The &lt;code&gt;!&lt;/code&gt; operator returns a &lt;code&gt;Bool&lt;/code&gt; that results from negating the &lt;a href=&quot;truthy_and_falsey_values&quot;&gt;truthiness&lt;/a&gt; of a value.</target>
        </trans-unit>
        <trans-unit id="8ffe618e2a8ef01a20272c5e56b48b0b333e5993" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; operator returns a &lt;code&gt;Bool&lt;/code&gt; that results from negating the &lt;a href=&quot;truthy_and_falsey_values&quot;&gt;truthyness&lt;/a&gt; of a value.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 연산자는 값 의 &lt;a href=&quot;truthy_and_falsey_values&quot;&gt;진실성&lt;/a&gt; 을 부정한 결과 &lt;code&gt;Bool&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="490b93fa8a1e27c8567b9c416cb939c87b9f2632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--static&lt;/code&gt; flag can be used to build a statically-linked executable:</source>
          <target state="translated">&lt;code&gt;--static&lt;/code&gt; 플래그는 정적으로 링크 된 실행 파일을 작성하는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ea6e15fc185b6dfeac938fd9a1ffd46ffc3d358a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; to which output is written.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 출력이 기록되는.</target>
        </trans-unit>
        <trans-unit id="ac6f996083ee75513b9c0622ab116bc40fbbfd0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; to which output is written. This can be changed/wrapped to filter the response body (for example to compress the output).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 출력이 기록되는. 응답 본문을 필터링하기 위해 변경 / 랩핑 할 수 있습니다 (예 : 출력 압축).</target>
        </trans-unit>
        <trans-unit id="3d606796b7ffef005975a53d91be2922acb7c88a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; class raises on this method, but some subclasses, notable &lt;code&gt;&lt;a href=&quot;filedescriptor&quot;&gt;IO::FileDescriptor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; implement it.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; class raises on this method, but some subclasses, notable &lt;code&gt;&lt;a href=&quot;filedescriptor&quot;&gt;IO::FileDescriptor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; implement it.</target>
        </trans-unit>
        <trans-unit id="2bfb537ff65327de4be88b51937e23fd9a3c3222" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; starts at position zero for reading.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 읽기 위해 위치 0에서 시작.</target>
        </trans-unit>
        <trans-unit id="a2d8623f015a9cb39650eea2561c1944b60bbbe4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; to process.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; 방법에 관한 것이다.</target>
        </trans-unit>
        <trans-unit id="2449083bb09518a3085fda8069a88dd99b5c3ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;base64&quot;&gt;Base64&lt;/a&gt;&lt;/code&gt; module provides for the encoding (&lt;code&gt;&lt;a href=&quot;base64#encode(data,io:IO)-instance-method&quot;&gt;#encode&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;base64#strict_encode(data,io:IO)-instance-method&quot;&gt;#strict_encode&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;base64#urlsafe_encode(data,io:IO)-instance-method&quot;&gt;#urlsafe_encode&lt;/a&gt;&lt;/code&gt;) and decoding (&lt;code&gt;&lt;a href=&quot;base64#decode(data,io:IO)-instance-method&quot;&gt;#decode&lt;/a&gt;&lt;/code&gt;) of binary data using a base64 representation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;base64&quot;&gt;Base64&lt;/a&gt;&lt;/code&gt; 로 모듈은 부호화 (제공 &lt;code&gt;&lt;a href=&quot;base64#encode(data,io:IO)-instance-method&quot;&gt;#encode&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;base64#strict_encode(data,io:IO)-instance-method&quot;&gt;#strict_encode&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;base64#urlsafe_encode(data,io:IO)-instance-method&quot;&gt;#urlsafe_encode&lt;/a&gt;&lt;/code&gt; ) 및 디코딩 ( &lt;code&gt;&lt;a href=&quot;base64#decode(data,io:IO)-instance-method&quot;&gt;#decode&lt;/a&gt;&lt;/code&gt; base64로 표현을 사용하여 이진 데이터).</target>
        </trans-unit>
        <trans-unit id="a6ee35869cac14a531a7b253e35d51d63147cd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;buffered&quot;&gt;IO::Buffered&lt;/a&gt;&lt;/code&gt; mixin enhances an &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; with input/output buffering.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;buffered&quot;&gt;IO::Buffered&lt;/a&gt;&lt;/code&gt; 믹스 인은 향상 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 입력 / 출력 버퍼링.</target>
        </trans-unit>
        <trans-unit id="a4baf8b05e49b63254c86b0bfb6a0362441300b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;class#===(other)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; method is used in a &lt;code&gt;case ... when ... end&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;class#===(other)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; 방법이 사용된다 &lt;code&gt;case ... when ... end&lt;/code&gt; 식.</target>
        </trans-unit>
        <trans-unit id="5d24ad40f5b83fac23ce884f3cf12cda69553f89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;comparable&quot;&gt;Comparable&lt;/a&gt;&lt;/code&gt; mixin is used by classes whose objects may be ordered.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;comparable&quot;&gt;Comparable&lt;/a&gt;&lt;/code&gt; 믹스 인은 그 개체 정렬 될 수 클래스가 사용된다.</target>
        </trans-unit>
        <trans-unit id="376b7efcb75448c308ba7fb6037def1bb1b983be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;crystal#main(&amp;amp;)-class-method&quot;&gt;Crystal.main&lt;/a&gt;&lt;/code&gt; can also be passed as a callback:</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;crystal#main(&amp;amp;)-class-method&quot;&gt;Crystal.main&lt;/a&gt;&lt;/code&gt; can also be passed as a callback:</target>
        </trans-unit>
        <trans-unit id="ad8290bb90b5f1437858cfc323146ec24775e9b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;crystal#main(&amp;amp;block)-class-method&quot;&gt;Crystal.main&lt;/a&gt;&lt;/code&gt; can also be passed as a callback:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;crystal#main(&amp;amp;block)-class-method&quot;&gt;Crystal.main&lt;/a&gt;&lt;/code&gt; 은 또한 콜백으로 전달 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="e2dd8eefa52d45bf3a68c64c8b6b0cedf86a5ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ecr#embed(filename,io_name)-macro&quot;&gt;ECR.embed&lt;/a&gt;&lt;/code&gt; line basically generates this Crystal code:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ecr#embed(filename,io_name)-macro&quot;&gt;ECR.embed&lt;/a&gt;&lt;/code&gt; 의 라인은 기본적으로이 크리스탈 코드를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="d212ff4d4b9a5d2a262b63edb9e728cd1a862022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ecr#render(filename)-macro&quot;&gt;ECR.render&lt;/a&gt;&lt;/code&gt; basically generates this Crystal code:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ecr#render(filename)-macro&quot;&gt;ECR.render&lt;/a&gt;&lt;/code&gt; 는 기본적으로이 크리스탈 코드를 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="a29e0025fd93ab543490b6942bf347c950434113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;enumerable&quot;&gt;Enumerable&lt;/a&gt;&lt;/code&gt; mixin provides collection classes with several traversal, searching, filtering and querying methods.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;enumerable&quot;&gt;Enumerable&lt;/a&gt;&lt;/code&gt; 에서 믹스 인은 필터링 및 검색 방법을 쿼리 여러 순회으로 컬렉션 클래스를 제공한다.</target>
        </trans-unit>
        <trans-unit id="89001ef56839eb3ae93f9aab3105d47bc183f8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; class is the basis for all input and output in Crystal.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 클래스는 크리스탈의 모든 입력과 출력의 기초가된다.</target>
        </trans-unit>
        <trans-unit id="3d97a52980050bd221d532fed1a43c7e655ca59f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; class raises on this method, but some subclasses, notable &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; implement it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 클래스는이 방법에 제기하지만, 일부 서브 클래스, 주목할만한 &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bdaab05f0c1838055646bb0617187a2febb2cccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; class raises on this method, but some subclasses, notable &lt;code&gt;&lt;a href=&quot;io/filedescriptor&quot;&gt;IO::FileDescriptor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; implement it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 이 방법에 급 인상,하지만 일부 서브 클래스, 주목할만한 &lt;code&gt;&lt;a href=&quot;io/filedescriptor&quot;&gt;IO::FileDescriptor&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e66da5ecce6c6e96db5f8e4765ae5c097d33c613" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;iterable&quot;&gt;Iterable&lt;/a&gt;&lt;/code&gt; mixin provides convenience methods to collection classes that provide an &lt;code&gt;&lt;a href=&quot;iterable#each-instance-method&quot;&gt;#each&lt;/a&gt;&lt;/code&gt; method that returns an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; over the collection.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;iterable&quot;&gt;Iterable&lt;/a&gt;&lt;/code&gt; 믹스 인은 제공 컬렉션 클래스에 편리한 방법을 제공합니다 &lt;code&gt;&lt;a href=&quot;iterable#each-instance-method&quot;&gt;#each&lt;/a&gt;&lt;/code&gt; 의 반환 방법 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 를 컬렉션에 걸쳐있다.</target>
        </trans-unit>
        <trans-unit id="f36f5d1994a6867a3e2f50a5f5be8afac215659f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; macro defines how an object is mapped to JSON.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; 매크로 정의는 객체를 JSON에 매핑되는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0916309fbd2e5a0b9ab03c37d215c0445540109b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;log&quot;&gt;Log&lt;/a&gt;&lt;/code&gt; class provides a logging utility that you can use to output messages.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;log&quot;&gt;Log&lt;/a&gt;&lt;/code&gt; class provides a logging utility that you can use to output messages.</target>
        </trans-unit>
        <trans-unit id="d5cf6b45cfcd7d76e10e9132b2e9c19b5a51a967" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;log/entrieschecker&quot;&gt;EntriesChecker&lt;/a&gt;&lt;/code&gt; will hold a list of emitted entries.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;log/entrieschecker&quot;&gt;EntriesChecker&lt;/a&gt;&lt;/code&gt; will hold a list of emitted entries.</target>
        </trans-unit>
        <trans-unit id="014421491d70ac6b110faecf08d5240d3ff0fe32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; class provides a simple but sophisticated logging utility that you can use to output messages.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; 클래스는 출력 메시지에 사용할 수있는 간단하지만 정교한 로깅 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38e8da265a75e7cd0e55b8ead7b933806679cfbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;macros&quot;&gt;Macros&lt;/a&gt;&lt;/code&gt; module is a fictitious module used to document macros and macro methods.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;macros&quot;&gt;Macros&lt;/a&gt;&lt;/code&gt; 모듈은 문서의 매크로와 매크로 방법에 사용되는 가상의 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="ef3cc6f44cf00521552efdff0ffaccd2b27cc9d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;macros#run(filename,*args):MacroId-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; macro is useful when the subset of available macro methods are not enough for your purposes and you need something more powerful. With &lt;code&gt;&lt;a href=&quot;macros#run(filename,*args):MacroId-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; you can read files at compile time, connect to the internet or to a database.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;macros#run(filename,*args):MacroId-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; 의 사용 가능한 매크로 방법의 부분 집합이 당신의 목적을 위해 충분하지 않습니다 당신이 더 강력한 무언가를 필요로 할 때 매크로 유용합니다. &lt;code&gt;&lt;a href=&quot;macros#run(filename,*args):MacroId-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; 을 사용하면 컴파일 타임에 파일을 읽고 인터넷이나 데이터베이스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4ee1bfa6b4f83e99821f279a58d860dc36da7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;multipart&quot;&gt;MIME::Multipart&lt;/a&gt;&lt;/code&gt; module contains utilities for parsing MIME multipart messages, which contain multiple body parts, each containing a header section and binary body. The &lt;code&gt;multipart/form-data&lt;/code&gt; content-type has a separate set of utilities in the &lt;code&gt;&lt;a href=&quot;../http/formdata&quot;&gt;HTTP::FormData&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;multipart&quot;&gt;MIME::Multipart&lt;/a&gt;&lt;/code&gt; 모듈은 각각 헤더 섹션 진 몸을 포함, 여러 신체 부위를 포함하는 MIME의 다중 메시지를 구문 분석 유틸리티가 포함되어 있습니다. &lt;code&gt;multipart/form-data&lt;/code&gt; 내용 유형은에서 유틸리티 별도의 설정이 &lt;code&gt;&lt;a href=&quot;../http/formdata&quot;&gt;HTTP::FormData&lt;/a&gt;&lt;/code&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="fa9e51617d0ad128757f472750772087db256fa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; type has only one possible value: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; : 유형은 하나의 가능한 값이 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78aab377343729c1663654f961a01fd4ecf2a0dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;object#===(other:JSON::Any)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; method is used in a &lt;code&gt;case ... when ... end&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;object#===(other:JSON::Any)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; 방법이 사용된다 &lt;code&gt;case ... when ... end&lt;/code&gt; 식.</target>
        </trans-unit>
        <trans-unit id="f40a434b8438c33291cb8865734695ab8703dc78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;partialcomparable&quot;&gt;PartialComparable&lt;/a&gt;&lt;/code&gt; mixin is used by classes whose objects may be partially ordered.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;partialcomparable&quot;&gt;PartialComparable&lt;/a&gt;&lt;/code&gt; 믹스 인은 그 개체의 일부 주문할 수 클래스가 사용된다.</target>
        </trans-unit>
        <trans-unit id="c7c09b196866b6574ae333546e8a67f52b3f88ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;proc#===(other:self)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; method is used in a &lt;code&gt;case ... when ... end&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;proc#===(other:self)-instance-method&quot;&gt;#===&lt;/a&gt;&lt;/code&gt; 방법이 사용된다 &lt;code&gt;case ... when ... end&lt;/code&gt; 식.</target>
        </trans-unit>
        <trans-unit id="56f748afe57b86f344e57a94faaf29a894bcfb7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; is a write-only &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, so all &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; methods are available in it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 쓰기 전용입니다 &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , 그래서 모든 &lt;code&gt;&lt;a href=&quot;../../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 방법이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f22660ac8d42e93feed30daded69488777847c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; to configure and write to.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 을 구성하고 쓰기에.</target>
        </trans-unit>
        <trans-unit id="7b4eddb6add6350ed80b4785e1894f732898b535" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;serializable&quot;&gt;JSON::Serializable&lt;/a&gt;&lt;/code&gt; module automatically generates methods for JSON serialization when included.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;serializable&quot;&gt;JSON::Serializable&lt;/a&gt;&lt;/code&gt; 포함 할 때 모듈은 자동으로 JSON 직렬화 방법을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="75fe18a3714f0812cf8057f8e6835b0ed0d25d90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;serializable&quot;&gt;YAML::Serializable&lt;/a&gt;&lt;/code&gt; module automatically generates methods for YAML serialization when included.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;serializable&quot;&gt;YAML::Serializable&lt;/a&gt;&lt;/code&gt; 포함 할 때 모듈은 자동으로 YAML 직렬화하는 방법을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77f52696379fafc552f322224eb96d3c5b2a9bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; is a write-only &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, so all &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; methods are available on it for sending the response body.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 쓰기 전용입니다 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , 그래서 모든 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 메소드는 응답 본문을 보내는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e4c8345788aed6fad6d47b4bce5124005fdcff72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; object has &lt;code&gt;status&lt;/code&gt; and &lt;code&gt;headers&lt;/code&gt; properties that can be configured before writing the response body. Once any response output has been written, changing the &lt;code&gt;status&lt;/code&gt; and &lt;code&gt;headers&lt;/code&gt; properties has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 객체가 &lt;code&gt;status&lt;/code&gt; 및 &lt;code&gt;headers&lt;/code&gt; 응답 본체를 작성하기 전에 구성 할 수있는 속성을. 응답 출력이 작성된 후에는 &lt;code&gt;status&lt;/code&gt; 및 &lt;code&gt;headers&lt;/code&gt; 속성을 변경해 도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="136d0870e5c874f19d02d21425b27db16d59ca13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;token/kind&quot;&gt;Kind&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;token/kind&quot;&gt;Kind&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9c3ef6a4b6c110967f8aa9adbdac35c23ad7701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; macro defines how an object is mapped to YAML.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; 매크로를 정의가 개체는 YAML에 매핑되는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f942e7c831d9e0546a5c9c83000e42a6e941c257" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; operator syntax sugar is also available to setters and indexers. Note that &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use the &lt;code&gt;[]?&lt;/code&gt; method to check for key presence.</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 연산자 신택스는 세터 및 인덱서로 사용할 수있다. 그 주 &lt;code&gt;||&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 사용 &lt;code&gt;[]?&lt;/code&gt; 키가 있는지 확인하는 방법.</target>
        </trans-unit>
        <trans-unit id="a61b8948bb1cbdac7600998768b7bd5447d1eaf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@[Flags]&lt;/code&gt; attribute makes the first constant's value be &lt;code&gt;1&lt;/code&gt;, and successive constants are multiplied by &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@[Flags]&lt;/code&gt; 속성은 상기 제 상수의 값이 될 수있게 &lt;code&gt;1&lt;/code&gt; , 연속 한 정수를 곱하여 &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c426dfe2ef0e17e729dcdbe617dd04191cfe70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@[ThreadLocal]&lt;/code&gt; attribute can be applied to class variables and C external variables. It makes them be thread local.</source>
          <target state="translated">&lt;code&gt;@[ThreadLocal]&lt;/code&gt; 속성은 클래스 변수 C 외부 변수에 적용될 수있다. 스레드 로컬이됩니다.</target>
        </trans-unit>
        <trans-unit id="75f6774d031682ec26bb77e23ce1ef7148016bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Array#map&lt;/code&gt; method uses the block's type as the generic type for the Array. Without the &lt;code&gt;as&lt;/code&gt; pseudo-method, the inferred type would have been &lt;code&gt;Int32&lt;/code&gt; and we wouldn't have been able to add a &lt;code&gt;Float64&lt;/code&gt; into it.</source>
          <target state="translated">&lt;code&gt;Array#map&lt;/code&gt; 방법은 배열의 일반적인 유형으로 블록의 형식을 사용합니다. 포함하지 않는 &lt;code&gt;as&lt;/code&gt; 의사 방법, 추정 된 유형했을 &lt;code&gt;Int32&lt;/code&gt; 그리고 우리는 추가 할 수 없었을 것이다 &lt;code&gt;Float64&lt;/code&gt; 을 그것으로.</target>
        </trans-unit>
        <trans-unit id="02d67663b426c4e4ee4f49cf674951a5c07b82e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TypeNode.instance_vars&lt;/code&gt; can be used to get an array of instance variable &lt;code&gt;MetaVar&lt;/code&gt; objects that would allow reading annotations defined on those instance variables.</source>
          <target state="translated">&lt;code&gt;TypeNode.instance_vars&lt;/code&gt; 는 인스턴스 변수의 배열을 가져올 수 있습니다 &lt;code&gt;MetaVar&lt;/code&gt; 의 그 인스턴스 변수에 정의 된 주석을 읽을 수 있도록 할 개체를.</target>
        </trans-unit>
        <trans-unit id="c1c71c557cb5fd0dfc5542f6e3e69672bbc48e5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; method can be used to read all positional arguments on an annotation as a &lt;code&gt;TupleLiteral&lt;/code&gt;. This method is defined on all annotations by default, and is unique to each applied annotation.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 방법은 같은 주석의 모든 위치 인수를 읽을 수 있습니다 &lt;code&gt;TupleLiteral&lt;/code&gt; . 이 방법은 기본적으로 모든 주석에 정의되어 있으며 적용된 각 주석에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="ff32ae2e211e5b829fc4b02241f187117313fb6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; pseudo-method also allows to cast between pointer types:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 의사 방법은 포인터 유형 간의 캐스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9cf0bccfbd5465269b0fc897a739f18a7f32078e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; pseudo-method can be used to cast an expression to a &quot;bigger&quot; type. For example:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 의사 방법은 &quot;더 큰&quot;형식으로 식을 캐스팅 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bf4746dbe840506cfd688dcb7378d52bf83d129" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; pseudo-method performs a runtime check: if &lt;code&gt;a&lt;/code&gt; wasn't an &lt;code&gt;Int32&lt;/code&gt;, an &lt;a href=&quot;exception_handling&quot;&gt;exception&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 유사 방법을 수행 런타임 검사 : 만약 &lt;code&gt;a&lt;/code&gt; 아니었다 &lt;code&gt;Int32&lt;/code&gt; , &lt;a href=&quot;exception_handling&quot;&gt;예외가&lt;/a&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="b7083725c498987142961bc69f0999a8244ccbcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; pseudo-method restricts the types of an expression. For example:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 유사 방법은 식의 종류를 제한한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d693b0558df5298a67bda8eeaab65d621969f9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as?&lt;/code&gt; pseudo-method is similar to &lt;code&gt;as&lt;/code&gt;, except that it returns &lt;code&gt;nil&lt;/code&gt; instead of raising an exception when the type doesn't match. It also can't be used to cast between pointer types and other types.</source>
          <target state="translated">&lt;code&gt;as?&lt;/code&gt; 의사 방법은 다음과 유사 &lt;code&gt;as&lt;/code&gt; 는 반환 것을 제외하고, &lt;code&gt;nil&lt;/code&gt; 대신 유형이 일치하지 않는 예외를 발생시키는의. 또한 포인터 유형과 다른 유형 사이에 캐스트하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="11271dbd4a41bb6c28e6c54c4a9891f7760b2a50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;before_script&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt; keys in the file are for running the same script in every job (&lt;code&gt;shards install&lt;/code&gt;) and for hanging onto the files that were created (&lt;code&gt;cache&lt;/code&gt;). They're not necessary if your shard doesn't have any dependencies.</source>
          <target state="translated">The &lt;code&gt;before_script&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt; keys in the file are for running the same script in every job ( &lt;code&gt;shards install&lt;/code&gt; ) and for hanging onto the files that were created ( &lt;code&gt;cache&lt;/code&gt; ). They're not necessary if your shard doesn't have any dependencies.</target>
        </trans-unit>
        <trans-unit id="3d86936accd4124dfa11b13017f14d802e431fe8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;colorize&lt;/code&gt; method returns a &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;&lt;/code&gt; instance, which allows chaining methods together:</source>
          <target state="translated">&lt;code&gt;colorize&lt;/code&gt; 방법은 반환 &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;&lt;/code&gt; 체인 방법을 함께 할 수 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="cfca9acc6bc8418967a49de47b0288f159aedc8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal build&lt;/code&gt; command builds a dynamically-linked binary executable.</source>
          <target state="translated">&lt;code&gt;crystal build&lt;/code&gt; 명령은 동적으로 링크 된 바이너리 실행 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="60221ce8357bf9321701766410a8923a503e839e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal docs&lt;/code&gt; command generates API documentation from inline docstrings in Crystal files (see &lt;a href=&quot;../conventions/documenting_code&quot;&gt;documenting code&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;crystal docs&lt;/code&gt; 명령은 수정 파일에서 인라인 문서화 문자열 (참조에서 API 문서를 생성 &lt;a href=&quot;../conventions/documenting_code&quot;&gt;문서화 코드&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8c7d32d461b915e078b01a181c6ef731e1790e95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal docs&lt;/code&gt; command generates API documentation from inline docstrings in Crystal files (see &lt;a href=&quot;https://crystal-lang.org/conventions/documenting_code.html&quot;&gt;documenting code&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;crystal docs&lt;/code&gt; 명령은 수정 파일에서 인라인 문서화 문자열 (참조에서 API 문서를 생성 &lt;a href=&quot;https://crystal-lang.org/conventions/documenting_code.html&quot;&gt;문서화 코드&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a2c6ba6f58687334d3ce5f4efc30d9224dd3394b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal env&lt;/code&gt; command prints environment variables used by Crystal.</source>
          <target state="translated">&lt;code&gt;crystal env&lt;/code&gt; 명령은 크리스탈에 의해 사용되는 환경 변수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0448efad7e7e9e9d6b2b2403e407507671bde6b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal eval&lt;/code&gt; command reads Crystal source code from command line or stdin, compiles it to a binary executable and immediately runs it.</source>
          <target state="translated">&lt;code&gt;crystal eval&lt;/code&gt; 명령은 명령 줄이나 표준 입력에서 크리스탈 소스 코드를 읽어 바이너리 실행 파일로 컴파일하고 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b4766b0e054c96a1444b51194810fba9b9ca962d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal init&lt;/code&gt; command initializes a Crystal project folder.</source>
          <target state="translated">&lt;code&gt;crystal init&lt;/code&gt; 명령은 크리스탈 프로젝트 폴더를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="314bbca54f3cda66d2f8a21d16cd2b1ddb8452d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal play&lt;/code&gt; command starts a webserver serving an interactive Crystal playground.</source>
          <target state="translated">&lt;code&gt;crystal play&lt;/code&gt; 명령은 대화 형 크리스탈 놀이터를 제공하는 웹 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="079101a55486986035bb64f5bf65982ae4a436f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal spec&lt;/code&gt; command compiles and runs a Crystal spec suite.</source>
          <target state="translated">&lt;code&gt;crystal spec&lt;/code&gt; 명령 컴파일 및 실행하는 크리스탈 사양 스위트.</target>
        </trans-unit>
        <trans-unit id="5b9dd66653d154a0ea34d6e3ef2e24d3481cc389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal tool format&lt;/code&gt; command applies default format to Crystal source files.</source>
          <target state="translated">&lt;code&gt;crystal tool format&lt;/code&gt; 명령은 크리스탈 소스 파일에 기본 포맷을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="59a50dec667b4c30684788f9d54879f6a7c8ef68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crystal version&lt;/code&gt; command prints the Crystal version, LLVM version and default target triple.</source>
          <target state="translated">&lt;code&gt;crystal version&lt;/code&gt; 명령은 크리스탈 버전, 트리플 LLVM 버전 및 기본 대상을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="963b27b62eb97bed4b0c40e8b7b3272de351411e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;describe&lt;/code&gt;/&lt;code&gt;context&lt;/code&gt; that wraps this example or example group.</source>
          <target state="translated">The &lt;code&gt;describe&lt;/code&gt; / &lt;code&gt;context&lt;/code&gt; that wraps this example or example group.</target>
        </trans-unit>
        <trans-unit id="0344dc160755c1bdcfefcc0e04e8d1c88539a83f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method will only be invoked once the object has been fully initialized via the &lt;code&gt;initialize&lt;/code&gt; method. If an exception is raised inside the &lt;code&gt;initialize&lt;/code&gt; method, &lt;code&gt;finalize&lt;/code&gt; won't be invoked. If your class defines a &lt;code&gt;finalize&lt;/code&gt; method, be sure to catch any exceptions that might be raised in the &lt;code&gt;initialize&lt;/code&gt; methods and free resources.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 개체가 완전히 통해 초기화되고 나면 메소드는 호출 될 것이다 &lt;code&gt;initialize&lt;/code&gt; 방법. &lt;code&gt;initialize&lt;/code&gt; 메소드 내에서 예외가 발생 하면 &lt;code&gt;finalize&lt;/code&gt; 가 호출되지 않습니다. 클래스가 &lt;code&gt;finalize&lt;/code&gt; 메소드를 정의하는 경우 &lt;code&gt;initialize&lt;/code&gt; 메소드 및 여유 자원 에서 발생할 수있는 예외를 포착하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dc586d8c7772c2c755777f82871627e4adcf488" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; variable in the above example is optional.</source>
          <target state="translated">위 예제 의 &lt;code&gt;index&lt;/code&gt; 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="828105cb7c8e8451e77576d83d5623cb1be400bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initial_capacity&lt;/code&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If you have an estimate of the maximum number of elements a deque will hold, you should initialize it with that capacity for improved execution performance.</source>
          <target state="translated">&lt;code&gt;initial_capacity&lt;/code&gt; 는 성장의 경우에는 내부 버퍼가 불필요하게 재 할당을 회피하는 데에 유용하다. deque가 보유 할 최대 요소 수의 추정치가있는 경우, 실행 성능 향상을 위해 해당 용량으로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="04b8e83cea5b8056c015a394838a2e84063296b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance_sizeof&lt;/code&gt; expression returns an &lt;code&gt;Int32&lt;/code&gt; with the instance size of a given class. For example:</source>
          <target state="translated">&lt;code&gt;instance_sizeof&lt;/code&gt; 의 표현은 반환 &lt;code&gt;Int32&lt;/code&gt; 지정된 클래스의 인스턴스 크기. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86e9f68437efb6eb33253ee818d7638c1e457ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;named_args&lt;/code&gt; method can be used to read all key/value pairs on an annotation as a &lt;code&gt;NamedTupleLiteral&lt;/code&gt;. This method is defined on all annotations by default, and is unique to each applied annotation.</source>
          <target state="translated">&lt;code&gt;named_args&lt;/code&gt; 방법은 같은 주석 모든 키 / 값 쌍을 판독하는데 사용될 수있다 &lt;code&gt;NamedTupleLiteral&lt;/code&gt; . 이 방법은 기본적으로 모든 주석에 정의되어 있으며 적용된 각 주석에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="5d1ce040c9328b66d9cae0bb66bf2d14c5a09455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; expression accepts arguments, and these give the value of the &lt;code&gt;yield&lt;/code&gt; expression that invoked the block:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 표현식은 인수를 받아,이는 값주고 &lt;code&gt;yield&lt;/code&gt; 블록을 호출 표현 :</target>
        </trans-unit>
        <trans-unit id="f4ede1d2e182ddeaf133f3b20cd92f8fe7ba0c4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; expression inside a block exits early from the block (not the method). For example:</source>
          <target state="translated">블록 내부 의 &lt;code&gt;next&lt;/code&gt; 표현식은 블록에서 일찍 종료됩니다 (메소드가 아님). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59f8b8a3b88edee4251d8666694afb2946c6ee92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pointerof&lt;/code&gt; expression returns a &lt;a href=&quot;http://crystal-lang.org/api/Pointer.html&quot;&gt;Pointer&lt;/a&gt; that points to the contents of a variable or instance variable.</source>
          <target state="translated">&lt;code&gt;pointerof&lt;/code&gt; 의 표현 리턴한다 &lt;a href=&quot;http://crystal-lang.org/api/Pointer.html&quot;&gt;포인터&lt;/a&gt; 가 변수 또는 인스턴스 변수의 내용을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="640e2f0e04734dc60523f591a269ce6ea2deeb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_methods&lt;/code&gt; macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of &lt;code&gt;Foo&lt;/code&gt; is compiled the &lt;code&gt;finished&lt;/code&gt; macro will be run, which will print &lt;code&gt;[bar]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;print_methods&lt;/code&gt; 의 그 시점에서 정의 된 방법이없는 것처럼 빈 목록을 출력합니다 - 매크로가 발견되는 즉시 실행됩니다. &lt;code&gt;Foo&lt;/code&gt; 의 두 번째 선언 이 컴파일되면 &lt;code&gt;finished&lt;/code&gt; 매크로가 실행되고 &lt;code&gt;[bar]&lt;/code&gt; 가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="7769a33217f60d148a4093f91a18ee3f3d9cb487" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command compiles a source file to a binary executable and immediately runs it.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 명령은 바이너리 실행 파일에 소스 파일을 컴파일하고 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6626f886032f0831007e66731f4767216020a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command compiles the source file &lt;code&gt;hello_world.cr&lt;/code&gt; to a binary executable in a temporary location and immediately executes it.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 명령은 소스 파일을 컴파일 &lt;code&gt;hello_world.cr&lt;/code&gt; 임시 위치에서 바이너리 실행 파일을하고 즉시 실행합니다.</target>
        </trans-unit>
        <trans-unit id="476c39fdfd41c30f38a5774c70eeba5ebe895ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; methods may sporadically fail with &lt;code&gt;&lt;a href=&quot;errno#ECONNREFUSED&quot;&gt;Errno::ECONNREFUSED&lt;/a&gt;&lt;/code&gt; when sending datagrams to a non-listening server. Wrap with an exception handler to prevent raising. Example:</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 방법은 산발적으로 실패 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;errno#ECONNREFUSED&quot;&gt;Errno::ECONNREFUSED&lt;/a&gt;&lt;/code&gt; 가 아닌 청취 서버에 데이터 그램을 보낼 때. 발생을 막기 위해 예외 처리기로 감싸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="53312acf6ae771222e3c1652706e0816074f801e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; methods may sporadically fail with &lt;code&gt;&lt;a href=&quot;socket/connecterror&quot;&gt;Socket::ConnectError&lt;/a&gt;&lt;/code&gt; when sending datagrams to a non-listening server. Wrap with an exception handler to prevent raising. Example:</source>
          <target state="translated">The &lt;code&gt;send&lt;/code&gt; methods may sporadically fail with &lt;code&gt;&lt;a href=&quot;socket/connecterror&quot;&gt;Socket::ConnectError&lt;/a&gt;&lt;/code&gt; when sending datagrams to a non-listening server. Wrap with an exception handler to prevent raising. Example:</target>
        </trans-unit>
        <trans-unit id="a36cde71d7e58f2803f86c4457bfeab51950dc07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sizeof&lt;/code&gt; expression returns an &lt;code&gt;Int32&lt;/code&gt; with the size in bytes of a given type. For example:</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 표현은 반환 &lt;code&gt;Int32&lt;/code&gt; 지정된 유형의 바이트 크기. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="050175522f85efb6178a3193491b00060fcd72c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; expression returns the type of an expression:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 표현 식의 유형을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="f23b20935a9489a4485479be788dd6cd79706638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uri&lt;/code&gt; for this example is &lt;code&gt;mysql://root:root@localhost/test&lt;/code&gt;, and so the module will use the &lt;code&gt;mysql driver&lt;/code&gt; to connect to the MySQL database.</source>
          <target state="translated">The &lt;code&gt;uri&lt;/code&gt; for this example is &lt;code&gt;mysql://root:root@localhost/test&lt;/code&gt; , and so the module will use the &lt;code&gt;mysql driver&lt;/code&gt; to connect to the MySQL database.</target>
        </trans-unit>
        <trans-unit id="c494b62b15d69a92665ae4b4ff266e06fe21f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; expression is similar to a call and can receive arguments. For example:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 표현은 호출과 유사하며 인수를받을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0274a3410c672dca60fd3803cdf66a4f06d7a20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; expression itself has a value: the last expression of the block. For example:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 블록의 마지막 식 : 식 자체의 값을 갖는다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84f2a4702b412b7487dc6196411fce9ee9b4f5e8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If the number of elements a hash will hold is known, the hash should be initialized with that capacity for improved performance. Otherwise, the default is 11 and inputs less than 11 are ignored.</source>
          <target state="translated">&lt;em&gt;initial_capacity는&lt;/em&gt; 성장의 경우에는 내부 버퍼가 불필요하게 재 할당을 회피하는 데에 유용하다. 해시가 보유 할 요소의 수를 알고있는 경우 성능 향상을 위해 해시를 해당 용량으로 초기화해야합니다. 그렇지 않으면 기본값은 11이고 11 미만의 입력은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c6da883de0395a540f3169fd41268ac260cf90f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If the number of elements a hash will hold is known, the hash should be initialized with that capacity for improved performance. Otherwise, the default is 8. Inputs lower than 8 are ignored.</source>
          <target state="translated">The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If the number of elements a hash will hold is known, the hash should be initialized with that capacity for improved performance. Otherwise, the default is 8. Inputs lower than 8 are ignored.</target>
        </trans-unit>
        <trans-unit id="2ed78875a62987193980f5047120cbd761267d03" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffer in case of growth. If you have an estimate of the maximum number of elements an array will hold, the array should be initialized with that capacity for improved performance.</source>
          <target state="translated">&lt;em&gt;initial_capacity는&lt;/em&gt; 성장의 경우에는 내부 버퍼가 불필요하게 재 할당을 회피하는 데에 유용하다. 어레이가 보유 할 최대 요소 수의 추정치가있는 경우 성능 향상을 위해 해당 용량으로 어레이를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7baf271fb624856a3469e176c34f8fa3b89283f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initial_capacity&lt;/em&gt; is useful to avoid unnecessary reallocations of the internal buffers in case of growth. If you have an estimate of the maximum number of elements the pool will hold it should be initialized with that capacity for improved performance.</source>
          <target state="translated">&lt;em&gt;initial_capacity는&lt;/em&gt; 성장의 경우에는 내부 버퍼가 불필요하게 재 할당을 방지하는 데 유용하다. 풀에 보유 할 최대 요소 수를 예상하면 성능을 향상시키기 위해 해당 용량으로 풀을 보유해야합니다.</target>
        </trans-unit>
        <trans-unit id="082a9afbda2cb1b0f6552fd53000193048db0545" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;invalid&lt;/em&gt; argument can be:</source>
          <target state="translated">&lt;em&gt;유효하지 않은&lt;/em&gt; 인수가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="116ceb0ceef4ca1cee47533c2e118c6a52fb9b9a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;other&lt;/em&gt; must have the same or fewer elements than this set, and all of elements in the &lt;em&gt;other&lt;/em&gt; set must be present in this set.</source>
          <target state="translated">&lt;em&gt;다른&lt;/em&gt; 세트와 같거나 적은 요소를 가지고 있어야하고, 모든 요소에 &lt;em&gt;다른&lt;/em&gt; 세트는이 세트에 존재한다.</target>
        </trans-unit>
        <trans-unit id="6ffc77fd23d96be3ef2345da029c01227c05e67f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;padding&lt;/em&gt; parameter defaults to &lt;code&gt;true&lt;/code&gt;. When &lt;code&gt;false&lt;/code&gt;, enough &lt;code&gt;=&lt;/code&gt; characters are not added to make the output divisible by 4.</source>
          <target state="translated">&lt;em&gt;패딩&lt;/em&gt; 기본값 매개 변수 &lt;code&gt;true&lt;/code&gt; . 때 &lt;code&gt;false&lt;/code&gt; , 충분한 &lt;code&gt;=&lt;/code&gt; 의 문자는 4 출력 나눌 수 있도록 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45ed0a950ff4677992ea3425dd1059324956f95b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;start&lt;/em&gt; argument can be negative to start counting from the end of the string.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 인수는 문자열의 끝에서 계산을 시작하는 음수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c74a8102f56eb2c014c035dc7e9ffee86aa61e" translate="yes" xml:space="preserve">
          <source>The Benchmark module provides methods for benchmarking Crystal code, giving detailed reports on the time and memory taken for each task.</source>
          <target state="translated">벤치 마크 모듈은 Crystal 코드 벤치마킹 방법을 제공하여 각 작업에 소요되는 시간과 메모리에 대한 자세한 보고서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="43eea8c10c8c90a84f34a4b4355976aab9f9896e" translate="yes" xml:space="preserve">
          <source>The C name can be put in quotes to be able to write a name that is not a valid identifier:</source>
          <target state="translated">유효한 식별자가 아닌 이름을 쓸 수 있도록 C 이름을 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b113212ff65a376be85230db339448ba08baf9" translate="yes" xml:space="preserve">
          <source>The Compress::Zip module contains readers and writers of the zip file format, described at &lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE's site&lt;/a&gt;.</source>
          <target state="translated">The Compress::Zip module contains readers and writers of the zip file format, described at &lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE's site&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="aa2f817b2d97c10cf60b8f8fbcf0b8338c76aec2" translate="yes" xml:space="preserve">
          <source>The Compress::Zlib module contains readers and writers of zlib format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;.</source>
          <target state="translated">The Compress::Zlib module contains readers and writers of zlib format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ebded078f2c9bc998559ff22d6a51ef0c260511f" translate="yes" xml:space="preserve">
          <source>The Crystal &lt;a href=&quot;https://crystal-lang.org/api&quot;&gt;Standard Library&lt;/a&gt; provides macros which simplify the definition of getter and setter methods:</source>
          <target state="translated">Crystal &lt;a href=&quot;https://crystal-lang.org/api&quot;&gt;Standard Library&lt;/a&gt; 는 getter 및 setter 메소드의 정의를 단순화하는 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="11bcce27589af8645d623b8e1591692cd37533a1" translate="yes" xml:space="preserve">
          <source>The Crystal compiler doesn't run on Windows &lt;em&gt;yet&lt;/em&gt;. But Crystal can be used with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Windows Subsystem for Linux&lt;/a&gt;, a compatibility-layer for Linux executables running natively on Windows 10.</source>
          <target state="translated">Crystal 컴파일러는 &lt;em&gt;아직&lt;/em&gt; Windows에서 실행되지 않습니다 . 그러나 Crystal은 Windows 10에서 기본적으로 실행되는 Linux 실행 파일 용 호환성 계층 인 &lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/about&quot;&gt;Linux 용 Windows 하위 시스템&lt;/a&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="246a934abe5eec85f56c980a571d87666319f371" translate="yes" xml:space="preserve">
          <source>The Crystal compiler has a &lt;code&gt;spec&lt;/code&gt; command with tools to constrain which examples get run and tailor the output.</source>
          <target state="translated">Crystal 컴파일러에는 실행되는 예제를 제한하고 출력을 조정하는 도구 가 포함 된 &lt;code&gt;spec&lt;/code&gt; 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9f8bc907d9554b2d118c48b43c52ba78e9435e" translate="yes" xml:space="preserve">
          <source>The Crystal compiler has a &lt;code&gt;spec&lt;/code&gt; command with tools to constrain which examples get run and tailor the output. All specs of a project are compiled and executed through the command &lt;code&gt;crystal spec&lt;/code&gt;.</source>
          <target state="translated">Crystal 컴파일러에는 실행되는 예제를 제한하고 출력을 조정하는 도구 가 포함 된 &lt;code&gt;spec&lt;/code&gt; 명령이 있습니다. 프로젝트의 모든 스펙은 &lt;code&gt;crystal spec&lt;/code&gt; 명령을 통해 컴파일되고 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2853e9df7bba5ea8d57e5fe8ef5ae7ad099086e" translate="yes" xml:space="preserve">
          <source>The Crystal compiler will by default use pkg-config to find the locations of libraries to link with.</source>
          <target state="translated">Crystal 컴파일러는 기본적으로 pkg-config를 사용하여 연결할 라이브러리 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e8ec4c6d13530e32fb0a267e4fcd82138d0748b0" translate="yes" xml:space="preserve">
          <source>The Crystal repository is hosted at &lt;a href=&quot;https://github.com/crystal-lang/crystal&quot;&gt;crystal-lang/crystal&lt;/a&gt; on GitHub.</source>
          <target state="translated">The Crystal repository is hosted at &lt;a href=&quot;https://github.com/crystal-lang/crystal&quot;&gt;crystal-lang/crystal&lt;/a&gt; on GitHub.</target>
        </trans-unit>
        <trans-unit id="496565dce03820f56e8fc9474e24b5e134107258" translate="yes" xml:space="preserve">
          <source>The Crystal standard library includes some pre-defined annotations:</source>
          <target state="translated">Crystal 표준 라이브러리에는 몇 가지 사전 정의 된 주석이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="513ed30279f67f9dd200d1c674eced1ee2bd6317" translate="yes" xml:space="preserve">
          <source>The DB module, is our place to stand when working with databases in Crystal. As written in the documentation: &lt;em&gt;is a unified interface for database access&lt;/em&gt;.</source>
          <target state="translated">The DB module, is our place to stand when working with databases in Crystal. As written in the documentation: &lt;em&gt;is a unified interface for database access&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="167999917301411bb58f0f7dfb463b58db11dbc9" translate="yes" xml:space="preserve">
          <source>The Digest module contains implementations of hashing algorithms like &lt;code&gt;&lt;a href=&quot;digest/md5&quot;&gt;Digest::MD5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;digest/sha1&quot;&gt;Digest::SHA1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The Digest module contains implementations of hashing algorithms like &lt;code&gt;&lt;a href=&quot;digest/md5&quot;&gt;Digest::MD5&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;digest/sha1&quot;&gt;Digest::SHA1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aaa7997408fd8ef83f3611fed91d6c095d4826b" translate="yes" xml:space="preserve">
          <source>The Event Loop, which is just another fiber, being in charge of async tasks, like for example files, sockets, pipes, signals and timers (like doing a &lt;code&gt;sleep&lt;/code&gt;).</source>
          <target state="translated">이벤트 루프는 파일, 소켓, 파이프, 신호 및 타이머와 같은 비동기 작업 (예 : &lt;code&gt;sleep&lt;/code&gt; ) 을 담당하는 또 다른 광섬유 입니다.</target>
        </trans-unit>
        <trans-unit id="2932829212c0aedee2b68bf1bf885f260e8e48c8" translate="yes" xml:space="preserve">
          <source>The Flate module contains readers and writers of DEFLATE format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951&lt;/a&gt;.</source>
          <target state="translated">Flate 모듈에는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1951.txt&quot;&gt;RFC 1951에&lt;/a&gt; 지정된 DEFLATE 형식 압축 데이터의 리더 및 기록기가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1a3a6862df64d2244b0c478f207f1efd99cc6a8" translate="yes" xml:space="preserve">
          <source>The Gzip module contains readers and writers of gzip format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952&lt;/a&gt;.</source>
          <target state="translated">Gzip 모듈에는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1952.txt&quot;&gt;RFC 1952에&lt;/a&gt; 지정된 gzip 형식 압축 데이터의 리더 및 기록기가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80874a7a6067509ab808ed784692c5048c982967" translate="yes" xml:space="preserve">
          <source>The HTTP module contains &lt;code&gt;&lt;a href=&quot;http/client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http/server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http/websocket&quot;&gt;HTTP::WebSocket&lt;/a&gt;&lt;/code&gt; implementations.</source>
          <target state="translated">HTTP 모듈에는 &lt;code&gt;&lt;a href=&quot;http/client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;http/server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http/websocket&quot;&gt;HTTP::WebSocket&lt;/a&gt;&lt;/code&gt; 구현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7210a8d45812f1f6ad2d64962710554d301159a0" translate="yes" xml:space="preserve">
          <source>The IEC standard prefixes (&lt;code&gt;Ki&lt;/code&gt;, &lt;code&gt;Mi&lt;/code&gt;, &lt;code&gt;Gi&lt;/code&gt;, &lt;code&gt;Ti&lt;/code&gt;, &lt;code&gt;Pi&lt;/code&gt;, &lt;code&gt;Ei&lt;/code&gt;, &lt;code&gt;Zi&lt;/code&gt;, &lt;code&gt;Yi&lt;/code&gt;) based on powers of 1000.</source>
          <target state="translated">IEC 표준 접두사 ( &lt;code&gt;Ki&lt;/code&gt; , &lt;code&gt;Mi&lt;/code&gt; , &lt;code&gt;Gi&lt;/code&gt; , &lt;code&gt;Ti&lt;/code&gt; , &lt;code&gt;Pi&lt;/code&gt; , &lt;code&gt;Ei&lt;/code&gt; , &lt;code&gt;Zi&lt;/code&gt; , &lt;code&gt;Yi&lt;/code&gt; )는 1000의 거듭 제곱을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="17b7c182b134c533f4686ee776344c3a59482ff5" translate="yes" xml:space="preserve">
          <source>The IO starts at position zero for reading.</source>
          <target state="translated">IO는 읽기 위해 위치 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6bafde48904d0ae0de3bcde7c34c01518d44c6c9" translate="yes" xml:space="preserve">
          <source>The ISO 8601 date format.</source>
          <target state="translated">ISO 8601 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a04d481795c047179a2ee48089b718eba567f7e5" translate="yes" xml:space="preserve">
          <source>The ISO 8601 date time format.</source>
          <target state="translated">ISO 8601 날짜 시간 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1c961e8e18cc38295c61b2a7222c42aefba3c770" translate="yes" xml:space="preserve">
          <source>The ISO 8601 time format.</source>
          <target state="translated">ISO 8601 시간 형식입니다.</target>
        </trans-unit>
        <trans-unit id="43ed1dc44d29b51880fe516a3a988e2cf78bc72f" translate="yes" xml:space="preserve">
          <source>The ISO calendar year to which the week belongs is not always in the same as the year of the regular calendar date. The first three days of January sometimes belong to week 52 (or 53) of the previous year; equally the last three days of December sometimes are already in week 1 of the following year.</source>
          <target state="translated">주가 속한 ISO 달력 연도가 항상 일반 달력 날짜의 연도와 동일하지는 않습니다. 1 월 첫 3 일은 전년도 52 주 (또는 53 주)에 속합니다. 12 월의 마지막 3 일은 때때로 이미 다음 해 1 주차에 있습니다.</target>
        </trans-unit>
        <trans-unit id="228dafd6179d5875e92d7f01e81f1934d3aa42c8" translate="yes" xml:space="preserve">
          <source>The JSON format itself does not specify a time data type, this method just assumes that a string holding a ISO 8601 time format can be interpreted as a time value.</source>
          <target state="translated">JSON 형식 자체는 시간 데이터 유형을 지정하지 않으며,이 방법은 ISO 8601 시간 형식을 보유한 문자열을 시간 값으로 해석 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1185e96419d9d1ed2f07417c50469963555dc1b6" translate="yes" xml:space="preserve">
          <source>The JSON format itself does not specify a time data type, this method just assumes that a string holding a RFC 3339 time format will be interpreted as a time value.</source>
          <target state="translated">JSON 형식 자체는 시간 데이터 유형을 지정하지 않으며,이 방법은 RFC 3339 시간 형식을 보유한 문자열이 시간 값으로 해석된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e3f3b7b16cf17dc7e84258d17d1db205edf18511" translate="yes" xml:space="preserve">
          <source>The JSON module allows parsing and generating &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; documents.</source>
          <target state="translated">JSON 모듈을 사용하면 &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; 문서를 구문 분석하고 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f5c6c0766cb92bf425f36b14da6f837c49d4740" translate="yes" xml:space="preserve">
          <source>The OAuth module provides an &lt;code&gt;&lt;a href=&quot;oauth/consumer&quot;&gt;OAuth::Consumer&lt;/a&gt;&lt;/code&gt; as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;.</source>
          <target state="translated">OAuth 모듈은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849에&lt;/a&gt; 지정된 &lt;code&gt;&lt;a href=&quot;oauth/consumer&quot;&gt;OAuth::Consumer&lt;/a&gt;&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5e0019e40cebf225476af7fc5485763fd0ab22a9" translate="yes" xml:space="preserve">
          <source>The OAuth module provides an &lt;code&gt;&lt;a href=&quot;oauth2/client&quot;&gt;OAuth2::Client&lt;/a&gt;&lt;/code&gt; as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;.</source>
          <target state="translated">OAuth 모듈은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749에&lt;/a&gt; 지정된 &lt;code&gt;&lt;a href=&quot;oauth2/client&quot;&gt;OAuth2::Client&lt;/a&gt;&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e3d5ad4cc469d2e7b77356056225510ee84b1bf1" translate="yes" xml:space="preserve">
          <source>The Proc type</source>
          <target state="translated">Proc 유형</target>
        </trans-unit>
        <trans-unit id="fce18036495868d9659f03df3d44dfcec351c534" translate="yes" xml:space="preserve">
          <source>The Program</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="3f4b331987b1aaf724056fe853e6d70f80673e09" translate="yes" xml:space="preserve">
          <source>The Runtime Scheduler</source>
          <target state="translated">런타임 스케줄러</target>
        </trans-unit>
        <trans-unit id="102e2b07fdae53df53734526fd9c2db526c4e21b" translate="yes" xml:space="preserve">
          <source>The Runtime Scheduler, in charge of executing all fibers when the time is right.</source>
          <target state="translated">적절한 시간에 모든 파이버를 실행하는 런타임 스케줄러.</target>
        </trans-unit>
        <trans-unit id="e127a192f2256e22ef64756febf709a2977a36a8" translate="yes" xml:space="preserve">
          <source>The SSL server wraps a &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; listening on &lt;code&gt;host:port&lt;/code&gt;.</source>
          <target state="translated">SSL 서버 는 &lt;code&gt;host:port&lt;/code&gt; 에서 수신 대기 하는 &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="993cd52af8f852fbc873f8473c1d225a3a5acc7e" translate="yes" xml:space="preserve">
          <source>The SSL server wraps a &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; listening on an unused port on &lt;em&gt;host&lt;/em&gt;.</source>
          <target state="translated">SSL 서버 는 &lt;em&gt;호스트&lt;/em&gt; 에서 사용되지 않는 포트에서 수신 대기 하는 &lt;code&gt;&lt;a href=&quot;../tcpserver&quot;&gt;TCPServer&lt;/a&gt;&lt;/code&gt; 를 랩핑 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c1595db4bc4b8523c7b00f405e76d7d591c1dd0a" translate="yes" xml:space="preserve">
          <source>The String version just creates a new &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt; instance with that message.</source>
          <target state="translated">문자열 버전 은 해당 메시지 로 새 &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;예외&lt;/a&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8c80d2df18a6198b85456576a2042aee2a69b82d" translate="yes" xml:space="preserve">
          <source>The XML module allows parsing and generating &lt;a href=&quot;https://www.w3.org/XML/&quot;&gt;XML&lt;/a&gt; documents.</source>
          <target state="translated">XML 모듈을 사용하면 &lt;a href=&quot;https://www.w3.org/XML/&quot;&gt;XML&lt;/a&gt; 문서를 구문 분석하고 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb09953e062ea577b5ddb247457a645d3fb45fa" translate="yes" xml:space="preserve">
          <source>The YAML module provides serialization and deserialization of YAML version 1.1 to/from native Crystal data structures, with the additional independent types specified in http://yaml.org/type/</source>
          <target state="translated">YAML 모듈은 http://yaml.org/type/에 지정된 추가 독립 유형을 사용하여 기본 Crystal 데이터 구조와의 YAML 버전 1.1 직렬화 및 역 직렬화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a44017a79d04272fe9a78e56baad945f7ca46c5b" translate="yes" xml:space="preserve">
          <source>The YAML::Nodes module provides an implementation of an in-memory YAML document tree. This tree can be generated with the &lt;code&gt;&lt;a href=&quot;nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; method or created with a &lt;code&gt;&lt;a href=&quot;nodes/builder&quot;&gt;YAML::Nodes::Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">YAML :: Nodes 모듈은 메모리 내 YAML 문서 트리의 구현을 제공합니다. 이 트리는 &lt;code&gt;&lt;a href=&quot;nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; 메소드로 생성하거나 &lt;code&gt;&lt;a href=&quot;nodes/builder&quot;&gt;YAML::Nodes::Builder&lt;/a&gt;&lt;/code&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c8dbee7cb1cee8bef1459835cb0aff74e8e33f2" translate="yes" xml:space="preserve">
          <source>The Zip module contains readers and writers of the zip file format, described at &lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE's site&lt;/a&gt;.</source>
          <target state="translated">Zip 모듈에는 &lt;a href=&quot;https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.3.TXT&quot;&gt;PKWARE 사이트에&lt;/a&gt; 설명 된 zip 파일 형식의 리더 및 기록기가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ce59e4bdd57d98f027a247e2e6e5544e94683b0" translate="yes" xml:space="preserve">
          <source>The Zlib module contains readers and writers of zlib format compressed data, as specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950&lt;/a&gt;.</source>
          <target state="translated">Zlib 모듈에는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1950.txt&quot;&gt;RFC 1950에&lt;/a&gt; 지정된 zlib 형식 압축 데이터의 리더 및 기록기가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04ab87542e1530d800ac1df658fae4cbe6b51c49" translate="yes" xml:space="preserve">
          <source>The ability of having immediate feedback on what we are working should be one of the most important characteristics in software development. Imagine making one change to our source code and having to wait 2 weeks to see if it broke something? oh! That would be a nightmare! For this, Continuous Integration will help a team to have immediate and frequent feedback about the status of what they are building.</source>
          <target state="translated">The ability of having immediate feedback on what we are working should be one of the most important characteristics in software development. Imagine making one change to our source code and having to wait 2 weeks to see if it broke something? oh! That would be a nightmare! For this, Continuous Integration will help a team to have immediate and frequent feedback about the status of what they are building.</target>
        </trans-unit>
        <trans-unit id="4b5f00738405f1ed3933e935ceb50dd3dea27652" translate="yes" xml:space="preserve">
          <source>The above &lt;strong&gt;doesn&amp;rsquo;t&lt;/strong&gt; work with instance variables or class variables. To work with these, first assign them to a variable:</source>
          <target state="translated">위의 인스턴스 변수 또는 클래스 변수 &lt;strong&gt;에는&lt;/strong&gt; 작동 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 이 작업을 수행하려면 먼저 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a804ccbb78c43a03510970e8c8f2e9338d5413d2" translate="yes" xml:space="preserve">
          <source>The above also works if there are ands (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) in the condition:</source>
          <target state="translated">위 의 조건에 ands ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; )가있는 경우에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="54c602bba78ff08495ac576d900850a987bc8493" translate="yes" xml:space="preserve">
          <source>The above code captures the block of code passed to &lt;code&gt;int_to_int&lt;/code&gt; in the &lt;code&gt;block&lt;/code&gt; variable, and returns it from the method. The type of &lt;code&gt;proc&lt;/code&gt; is &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc(Int32, Int32)&lt;/a&gt;, a function that accepts a single &lt;code&gt;Int32&lt;/code&gt; argument and returns an &lt;code&gt;Int32&lt;/code&gt;.</source>
          <target state="translated">위의 코드는 &lt;code&gt;block&lt;/code&gt; 변수 에서 &lt;code&gt;int_to_int&lt;/code&gt; 에 전달 된 코드 블록을 캡처 하여 메소드에서 반환합니다. 의 타입 &lt;code&gt;proc&lt;/code&gt; 있다 &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;PROC (INT32, INT32)&lt;/a&gt; 단일받는 기능 &lt;code&gt;Int32&lt;/code&gt; 인수 및 반환 &lt;code&gt;Int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="482726665ac9e182f65bd69d3da115ac7a67df13" translate="yes" xml:space="preserve">
          <source>The above code gives this compile error:</source>
          <target state="translated">위의 코드는이 컴파일 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6405d5019e9bc272db6cdff6739c053f2522b0b" translate="yes" xml:space="preserve">
          <source>The above code will make sense once you read the whole language reference, but we can already learn some things.</source>
          <target state="translated">위의 코드는 전체 언어 참조를 읽으면 의미가 있지만 이미 몇 가지 사항을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5706d80d8aec1ab71b41a3a63a014d3965e051b9" translate="yes" xml:space="preserve">
          <source>The above could also be implemented with a Symbol:</source>
          <target state="translated">위의 기호를 사용하여 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c83f99c41c0bff6b77243fc1d08e0f9b2324ef9" translate="yes" xml:space="preserve">
          <source>The above examples use unbuffered channels: when sending a value, if a fiber is waiting on that channel then execution continues on that fiber.</source>
          <target state="translated">위의 예는 버퍼되지 않은 채널을 사용합니다. 값을 보낼 때 파이버가 해당 채널을 기다리는 경우 해당 파이버에서 실행이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="656d5d691a11dc89cab934b727b7b657f2a26bf2" translate="yes" xml:space="preserve">
          <source>The above generates a program that will have the contents of &lt;code&gt;some_file.txt&lt;/code&gt;. The file, however, is read at compile time and will not be needed at runtime.</source>
          <target state="translated">위의 내용은 &lt;code&gt;some_file.txt&lt;/code&gt; 의 내용을 가진 프로그램을 생성합니다 . 그러나 파일은 컴파일 타임에 읽 히며 런타임에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6c433adda1b56a97e3e970be41047634b01806e" translate="yes" xml:space="preserve">
          <source>The above happens even if &lt;code&gt;something_dangerous_that_returns_Int32&lt;/code&gt; never raises, or if &lt;code&gt;a&lt;/code&gt; was assigned a value and then a method that potentially raises is executed:</source>
          <target state="translated">위는 경우에도 발생 &lt;code&gt;something_dangerous_that_returns_Int32&lt;/code&gt; 가 제기되지 않을 경우, 또는 &lt;code&gt;a&lt;/code&gt; 다음 값과 잠재적으로 실행 제기하는 방법을 할당 :</target>
        </trans-unit>
        <trans-unit id="bcb9caec3740c65229c0b2a54051836485d126ee" translate="yes" xml:space="preserve">
          <source>The above is mostly useful with flag enums.</source>
          <target state="translated">위의 내용은 주로 플래그 열거 형에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1621fe8a8f7d10296061ab3f96abd962a66da91a" translate="yes" xml:space="preserve">
          <source>The above is simply rewritten to:</source>
          <target state="translated">위의 내용은 간단히 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9768279392033a963a63cadc30475985e7e4b6bb" translate="yes" xml:space="preserve">
          <source>The above is simply syntax sugar of this:</source>
          <target state="translated">위는 단순히 이것의 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="2a07a4b43f1d70c3a43cc842b0248805bbd090f0" translate="yes" xml:space="preserve">
          <source>The above is the same as this:</source>
          <target state="translated">위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57a8c9f43fefd72d2d0f7808adbb754a2c6bc9c7" translate="yes" xml:space="preserve">
          <source>The above is useful for providing overloads based on types, not instances:</source>
          <target state="translated">위의 예는 인스턴스가 아닌 유형을 기반으로 과부하를 제공하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dbbbdd4bb540a3091716b8351544904cd0edd01b" translate="yes" xml:space="preserve">
          <source>The above logic works &lt;strong&gt;only for local variables&lt;/strong&gt;. It doesn&amp;rsquo;t work with instance variables, class variables, or variables bound in a closure. The value of these kinds of variables could potentially be affected by another fiber after the condition was checked, rendering it &lt;code&gt;nil&lt;/code&gt;. It also does not work with constants.</source>
          <target state="translated">위의 논리는 &lt;strong&gt;지역 변수에만&lt;/strong&gt; 적용 &lt;strong&gt;됩니다&lt;/strong&gt; . 인스턴스 변수, 클래스 변수 또는 클로저에 바인딩 된 변수에서는 작동하지 않습니다. 이러한 종류의 변수 값은 조건을 확인한 후 다른 섬유의 영향을 받아 잠재적으로 &lt;code&gt;nil&lt;/code&gt; 이 될 수 있습니다. 상수에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a6b864cceaad721862897225ec878ce0958f539" translate="yes" xml:space="preserve">
          <source>The above methods delegate to a &lt;code&gt;&lt;a href=&quot;random&quot;&gt;Random&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">위의 메소드는 &lt;code&gt;&lt;a href=&quot;random&quot;&gt;Random&lt;/a&gt;&lt;/code&gt; 인스턴스에 위임 합니다.</target>
        </trans-unit>
        <trans-unit id="b46c5f49ab483965caa577aae8f803d42b87ba7e" translate="yes" xml:space="preserve">
          <source>The above might not seem to be useful, but it is when, for example, mapping an array of elements:</source>
          <target state="translated">위의 내용은 유용하지 않을 수도 있지만 예를 들어 요소 배열을 매핑하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="2832d8248ae199f774368b1d496760735fcebca3" translate="yes" xml:space="preserve">
          <source>The above prints &quot;2&quot; and &quot;3&quot;.</source>
          <target state="translated">위는 &quot;2&quot;와 &quot;3&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d90554e7b062fa330c4bc308bb8a055de1f577ae" translate="yes" xml:space="preserve">
          <source>The above prints &quot;Before 1&quot; and &quot;Before 2&quot;. The &lt;code&gt;thrice&lt;/code&gt; method didn't execute the &lt;code&gt;puts &quot;Before 3&quot;&lt;/code&gt; expression because of the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 &quot;Before 1&quot;과 &quot;Before 2&quot;를 인쇄합니다. &lt;code&gt;thrice&lt;/code&gt; 방법은 실행하지 못했습니다 &lt;code&gt;puts &quot;Before 3&quot;&lt;/code&gt; 때문에 발현 &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3beb91c1e0a6c3144834c6803392d4652beaa01a" translate="yes" xml:space="preserve">
          <source>The above prints &quot;Got 1&quot; and &quot;Got 2&quot;.</source>
          <target state="translated">위의 &quot;Got 1&quot;및 &quot;Got 2&quot;가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b44d7fd3b0fe5efd71b4f239ad69d0fc010d3afb" translate="yes" xml:space="preserve">
          <source>The above produces:</source>
          <target state="translated">위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ca4589dcb158eaa50f8ae74813c4cf8260fdaa6" translate="yes" xml:space="preserve">
          <source>The above program prints &quot;10&quot; ten times. The problem is that there's only one variable &lt;code&gt;i&lt;/code&gt; that all spawned fibers refer to, and when &lt;code&gt;Fiber.yield&lt;/code&gt; is executed its value is 10.</source>
          <target state="translated">위의 프로그램은 &quot;10&quot;을 10 번 인쇄합니다. 문제는 모든 스폰 된 파이버가 참조하는 변수 &lt;code&gt;i&lt;/code&gt; 가 하나 &lt;code&gt;Fiber.yield&lt;/code&gt; 가 실행될 때 그 값은 10이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="54d023ab647646c46ff7e0e093c24819eab0a23a" translate="yes" xml:space="preserve">
          <source>The above program prints &quot;Hello!&quot; twice, once for each &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">위의 프로그램은 &quot;Hello!&quot;를 인쇄합니다. 각 &lt;code&gt;yield&lt;/code&gt; 에 대해 두 번, 한 번 .</target>
        </trans-unit>
        <trans-unit id="078b0861ba82af5a528dc088249014a70f5efb1d" translate="yes" xml:space="preserve">
          <source>The above program spawns two fibers. The first one creates a TCPServer, accepts one connection and reads lines from it, sending them to the channel. There's a second fiber reading lines from standard input. The main fiber reads the first 3 messages sent to the channel, either from the socket or stdin, then the program exits. The &lt;code&gt;gets&lt;/code&gt; calls will block the fibers and tell the Event Loop to continue from there if data comes.</source>
          <target state="translated">위의 프로그램은 두 개의 섬유를 생성합니다. 첫 번째는 TCPServer를 작성하고 한 개의 연결을 승인 한 후 회선을 읽어 채널로 보냅니다. 표준 입력에서 두 번째 광섬유 판독 라인이 있습니다. 메인 파이버는 소켓 또는 stdin에서 채널로 전송 된 처음 3 개의 메시지를 읽은 다음 프로그램이 종료됩니다. 은 &lt;code&gt;gets&lt;/code&gt; 호출이 섬유를 차단하고 데이터가 오면 거기에서 계속 이벤트 루프를 말할 것이다.</target>
        </trans-unit>
        <trans-unit id="11999f0a14eb703100105bc7165779496f6db462" translate="yes" xml:space="preserve">
          <source>The above program works but has a big performance problem: on every iteration a new array is created for &lt;code&gt;[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]&lt;/code&gt;. Remember: an array literal is just syntax sugar for creating an instance of an array and adding some values to it, and this will happen over and over on each iteration.</source>
          <target state="translated">위의 프로그램은 작동하지만 큰 성능 문제가 있습니다. 반복 할 때마다 &lt;code&gt;[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]&lt;/code&gt; 대해 새 배열이 작성됩니다 . 기억하십시오 : 배열 리터럴은 배열의 인스턴스를 생성하고 그것에 값을 추가하기위한 구문 설탕 일뿐이며, 각 반복마다 반복적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7e34974f2e9b5ad2ea8f1d31587680590b5c371" translate="yes" xml:space="preserve">
          <source>The above works, but creates many intermediate arrays: one for the &lt;em&gt;select&lt;/em&gt; call, one for the &lt;em&gt;map&lt;/em&gt; call and one for the &lt;em&gt;take&lt;/em&gt; call. A more efficient way is to invoke &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; without a block, which gives us an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; so we can process the operations lazily:</source>
          <target state="translated">The above works, but creates many intermediate arrays: one for the &lt;em&gt;select&lt;/em&gt; call, one for the &lt;em&gt;map&lt;/em&gt; call and one for the &lt;em&gt;take&lt;/em&gt; call. A more efficient way is to invoke &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; without a block, which gives us an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; so we can process the operations lazily:</target>
        </trans-unit>
        <trans-unit id="7a7ff822add2855066bbeb49a4b5413bd1d285fb" translate="yes" xml:space="preserve">
          <source>The above works, but creates many intermediate arrays: one for the &lt;em&gt;select&lt;/em&gt; call, one for the &lt;em&gt;map&lt;/em&gt; call and one for the &lt;em&gt;take&lt;/em&gt; call. A more efficient way is to invoke &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;block):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; without a block, which gives us an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; so we can process the operations lazily:</source>
          <target state="translated">위의 방법은 작동하지만 &lt;em&gt;선택&lt;/em&gt; 호출, &lt;em&gt;맵&lt;/em&gt; 호출 및 &lt;em&gt;테이크&lt;/em&gt; 콜에 대한 여러 중간 배열을 만듭니다 . 보다 효율적인 방법은 블록없이 &lt;code&gt;&lt;a href=&quot;range#each(&amp;amp;block):Nil-instance-method&quot;&gt;Range#each&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 를 제공 하여 작업을 느리게 처리 할 수 ​​있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4319040e3f3e88a7eb1830b2d394e99ce08e01cf" translate="yes" xml:space="preserve">
          <source>The advantage of being cooperative is that a lot of the overhead of doing a context switch (switching between threads) is gone.</source>
          <target state="translated">협력적인 장점은 컨텍스트 전환 (스레드 간 전환)을 수행하는 데 따른 많은 오버 헤드가 사라 졌다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0483a1a0c683c09f20ecc1fd6d2bcfd420e1d72" translate="yes" xml:space="preserve">
          <source>The algorithm has a maximum password length limit of 71 characters (see &lt;a href=&quot;https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length#answer-39851&quot;&gt;this comment&lt;/a&gt; on stackoverflow).</source>
          <target state="translated">알고리즘의 최대 비밀번호 길이는 71 자로 제한 됩니다 (스택 오버 &lt;a href=&quot;https://security.stackexchange.com/questions/39849/does-bcrypt-have-a-maximum-password-length#answer-39851&quot;&gt;플로우&lt;/a&gt; 에 대한 주석 참조 ).</target>
        </trans-unit>
        <trans-unit id="3294db75e75614f5dd83452e28cedbf76148708a" translate="yes" xml:space="preserve">
          <source>The alphabet uses &lt;code&gt;'-'&lt;/code&gt; instead of &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'_'&lt;/code&gt; instead of &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">알파벳 사용하는 &lt;code&gt;'-'&lt;/code&gt; 대신에 &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;'_'&lt;/code&gt; 대신 &lt;code&gt;'/'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="035793fc19fac18085aa0de163c96552ee327c1a" translate="yes" xml:space="preserve">
          <source>The amount of time in seconds between keepalive probes.</source>
          <target state="translated">Keepalive 프로브 사이의 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="33aeecac47306b5c4fc40f7e0d08938931d0cd08" translate="yes" xml:space="preserve">
          <source>The amount of time in seconds the connection must be idle before sending keepalive probes.</source>
          <target state="translated">연결 유지 프로브를 보내기 전에 연결이 유휴 상태 여야하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="3194bc97bbc1a908e06eeb6fcf94b91e73e87ffb" translate="yes" xml:space="preserve">
          <source>The annotation can then be applied to various items, including:</source>
          <target state="translated">그런 다음 주석을 포함하여 다양한 항목에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d085207e361cfeb24b4e38a7420e6c26047be8ad" translate="yes" xml:space="preserve">
          <source>The answer is that when we defined an &lt;code&gt;initialize&lt;/code&gt; method Crystal defined a &lt;code&gt;new&lt;/code&gt; method for us, like this:</source>
          <target state="translated">대답은 &lt;code&gt;initialize&lt;/code&gt; 메소드를 정의 할 때 Crystal 이 다음과 같이 &lt;code&gt;new&lt;/code&gt; 메소드를 정의한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5ee68dc06a5633f096fb966481951f55ea2e0bc" translate="yes" xml:space="preserve">
          <source>The argument to sizeof is a &lt;a href=&quot;type_grammar&quot;&gt;type&lt;/a&gt; and is often combined with &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;:</source>
          <target state="translated">sizeof에 대한 인수는 &lt;a href=&quot;type_grammar&quot;&gt;유형&lt;/a&gt; 이며 종종 &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt; 와 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="323085345e91d82985e77cff6266ff2095686196" translate="yes" xml:space="preserve">
          <source>The argument to the expression is a &lt;a href=&quot;type_grammar&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">표현식에 대한 인수는 &lt;a href=&quot;type_grammar&quot;&gt;유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da9759706afb143256972cc4ed251794bf1313f8" translate="yes" xml:space="preserve">
          <source>The arguments are packed into an &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt;&lt;code&gt;ArrayLiteral&lt;/code&gt;&lt;/a&gt; and passed to the macro.</source>
          <target state="translated">인수는 &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt; &lt;code&gt;ArrayLiteral&lt;/code&gt; 에&lt;/a&gt; 압축되어 매크로에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a91dcd292727eb9f345153e9183d1ce699549f42" translate="yes" xml:space="preserve">
          <source>The arguments can be string literals, symbol literals or plain names:</source>
          <target state="translated">인수는 문자열 리터럴, 기호 리터럴 또는 일반 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a636e8953678708ca0f21117f0ec983b750f49f3" translate="yes" xml:space="preserve">
          <source>The array's generic type argument &lt;code&gt;T&lt;/code&gt; is inferred from the types of the elements inside the literal. When all elements of the array have the same type, &lt;code&gt;T&lt;/code&gt; equals to that. Otherwise it will be a union of all element types.</source>
          <target state="translated">배열의 제네릭 형식 인수 &lt;code&gt;T&lt;/code&gt; 는 리터럴 내의 요소 형식에서 유추됩니다. 배열의 모든 요소가 동일한 유형을 갖는 경우 &lt;code&gt;T&lt;/code&gt; 는 해당 유형과 같습니다. 그렇지 않으면 모든 요소 유형의 합집합이됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7094e46a09112bb790b3b6e2395450f11027f3" translate="yes" xml:space="preserve">
          <source>The assignment operator &lt;code&gt;=&lt;/code&gt; assigns the value of the second operand to the first operand. The first operand is either a variable (in this case the operator can't be redefined) or a call (in this case the operator can be redefined). See &lt;a href=&quot;assignment&quot;&gt;assignment&lt;/a&gt; for details.</source>
          <target state="translated">The assignment operator &lt;code&gt;=&lt;/code&gt; assigns the value of the second operand to the first operand. The first operand is either a variable (in this case the operator can't be redefined) or a call (in this case the operator can be redefined). See &lt;a href=&quot;assignment&quot;&gt;assignment&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="d0e4d47921b9b0ea4286891ab14c908e3d50fef4" translate="yes" xml:space="preserve">
          <source>The assignment operator &lt;code&gt;=&lt;/code&gt; is the basis for all operators that combine an operator with assignment. The general form is &lt;code&gt;a &amp;lt;op&amp;gt;= b&lt;/code&gt; and the compiler transform that into &lt;code&gt;a = a &amp;lt;op&amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">The assignment operator &lt;code&gt;=&lt;/code&gt; is the basis for all operators that combine an operator with assignment. The general form is &lt;code&gt;a &amp;lt;op&amp;gt;= b&lt;/code&gt; and the compiler transform that into &lt;code&gt;a = a &amp;lt;op&amp;gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02666c97b2fb79ea47a69ae6a189d86846914eff" translate="yes" xml:space="preserve">
          <source>The backslash character \ can be used to escape ^ or - and is otherwise ignored unless it appears at the end of a range or set.</source>
          <target state="translated">백 슬래시 문자 \는 ^ 또는-를 이스케이프하는 데 사용될 수 있으며 범위 나 세트의 끝에 표시되지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5d86a5e86d7e691edfb9db88221d3ee7f764eb3b" translate="yes" xml:space="preserve">
          <source>The begin and end values do not necessarily need to be of the same type: &lt;code&gt;true..1&lt;/code&gt; is a valid range, although pretty useless &lt;code&gt;Enumerable&lt;/code&gt; methods won't work with incompatible types. They need at least to be comparable.</source>
          <target state="translated">begin 및 end 값은 반드시 같은 유형일 필요는 없습니다. &lt;code&gt;true..1&lt;/code&gt; 은 유효한 범위이지만, 쓸모없는 &lt;code&gt;Enumerable&lt;/code&gt; 메소드는 호환되지 않는 유형에서는 작동하지 않습니다. 그들은 적어도 비교할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cd4ddc951b26d069c0e772446bd498bd0bee508a" translate="yes" xml:space="preserve">
          <source>The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI.</source>
          <target state="translated">풀의 동작은 연결 URI에서 쿼리 문자열로 표시 될 수있는 매개 변수 집합에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669ab7eefaa697304280f141aa155d3622171703" translate="yes" xml:space="preserve">
          <source>The binary representation of this enum is defined to be same representation as the permission bits of a unix &lt;code&gt;st_mode&lt;/code&gt; field. &lt;code&gt;&lt;a href=&quot;permissions&quot;&gt;File::Permissions&lt;/a&gt;&lt;/code&gt; can also be compared to its underlying bitset, for example &lt;code&gt;File::Permissions::All == 0o777&lt;/code&gt; will always be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 열거의 이진 표현은 unix &lt;code&gt;st_mode&lt;/code&gt; 필드 의 허가 비트와 동일한 표현으로 정의됩니다 . &lt;code&gt;&lt;a href=&quot;permissions&quot;&gt;File::Permissions&lt;/a&gt;&lt;/code&gt; 는 기본 &lt;code&gt;File::Permissions::All == 0o777&lt;/code&gt; 와 비교할 수도 있습니다 (예 : File :: Permissions :: All == 0o777 은 항상 &lt;code&gt;true&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="1ab2f00524963337e2687e919d2ba4266b9852d6" translate="yes" xml:space="preserve">
          <source>The block is called for each ascii character (codepoint less than &lt;code&gt;0x80&lt;/code&gt;) and determines whether the value is to be encoded. When the return value is falsey, the character is encoded. Non-ASCII characters are always encoded.</source>
          <target state="translated">블록은 각 ASCII 문자 ( &lt;code&gt;0x80&lt;/code&gt; 미만의 코드 포인트)에 대해 호출 되며 값을 인코딩할지 여부를 결정합니다. 반환 값이 거짓이면 문자가 인코딩됩니다. 비 ASCII 문자는 항상 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8735c5f0fae248dce7382e805df5c3e5cb97abe9" translate="yes" xml:space="preserve">
          <source>The block is called for each percent-encoded ASCII character and determines whether the value is to be decoded. When the return value is falsey, the character is decoded. Non-ASCII characters are always decoded.</source>
          <target state="translated">퍼센트 인코딩 된 각 ASCII 문자에 대해 블록이 호출되며 값을 디코딩할지 여부를 결정합니다. 반환 값이 거짓이면 문자가 디코딩됩니다. 비 ASCII 문자는 항상 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b678bb8396299b5eef554b024d236c7cd2a38419" translate="yes" xml:space="preserve">
          <source>The block is only evaluated if the current message is to be emitted to some &lt;code&gt;&lt;a href=&quot;log/backend&quot;&gt;Log::Backend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The block is only evaluated if the current message is to be emitted to some &lt;code&gt;&lt;a href=&quot;log/backend&quot;&gt;Log::Backend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8043c4c54dcf85a8a523df43794f910f810416a4" translate="yes" xml:space="preserve">
          <source>The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;&lt;a href=&quot;example/procsy&quot;&gt;Example::Procsy&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;&lt;a href=&quot;example/procsy&quot;&gt;Example::Procsy&lt;/a&gt;&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="170bf1c092f78ac38eb3948095b650af7a241e1f" translate="yes" xml:space="preserve">
          <source>The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;&lt;a href=&quot;spec/example/procsy&quot;&gt;Example::Procsy&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;&lt;a href=&quot;spec/example/procsy&quot;&gt;Example::Procsy&lt;/a&gt;&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="36ae9e679c7dc429ba208022cdd5e73ce2ddbf96" translate="yes" xml:space="preserve">
          <source>The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;Context::Procsy&lt;/code&gt; object.</source>
          <target state="translated">The block must call &lt;code&gt;run&lt;/code&gt; on the given &lt;code&gt;Context::Procsy&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="b40db3eab6d1f82e10559b92e03e896430461fe8" translate="yes" xml:space="preserve">
          <source>The block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">블록은 두 요소 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이의 비교를 구현해야합니다 . 여기서 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 을 , &lt;code&gt;a == b&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 , &lt;code&gt;a &amp;gt; b&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 비교 연산자 &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9315c1524c78e7c0ddfc771ed7729a661d31c6" translate="yes" xml:space="preserve">
          <source>The block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">블록은 두 요소 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이의 비교를 구현해야합니다 . 여기서 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 을 , &lt;code&gt;a == b&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 , &lt;code&gt;a &amp;gt; b&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 비교 연산자 &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4af3fea31bddb946015db5a49cbbc1446d44eaf" translate="yes" xml:space="preserve">
          <source>The block variable &lt;code&gt;second&lt;/code&gt; also includes the &lt;code&gt;Nil&lt;/code&gt; type because the last &lt;code&gt;yield&lt;/code&gt; expression didn't include a second argument.</source>
          <target state="translated">마지막 &lt;code&gt;yield&lt;/code&gt; 표현식에 두 번째 인수가 포함되지 않았 으므로 블록 변수 &lt;code&gt;second&lt;/code&gt; 에도 &lt;code&gt;Nil&lt;/code&gt; 유형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="65004e032fc6f16412331ec9e39888aa714ed45c" translate="yes" xml:space="preserve">
          <source>The buffer is allocated on the stack, avoiding a heap allocation.</source>
          <target state="translated">버퍼는 힙 할당을 피하면서 스택에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="5e281794f250e6bc9b7f49810850e5b085ce50f5" translate="yes" xml:space="preserve">
          <source>The buffering behaviour can be turned on/off with the &lt;code&gt;&lt;a href=&quot;buffered#sync=(sync)-instance-method&quot;&gt;#sync=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;buffered#read_buffering=(read_buffering)-instance-method&quot;&gt;#read_buffering=&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">버퍼링 동작은 &lt;code&gt;&lt;a href=&quot;buffered#sync=(sync)-instance-method&quot;&gt;#sync=&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;buffered#read_buffering=(read_buffering)-instance-method&quot;&gt;#read_buffering=&lt;/a&gt;&lt;/code&gt; 메소드를 사용하여 켜거나 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5fac4f5ddc22b92b6edab3ab53e0bf3578ea340" translate="yes" xml:space="preserve">
          <source>The build metadata of this semantic version</source>
          <target state="translated">이 시맨틱 버전의 빌드 메타 데이터</target>
        </trans-unit>
        <trans-unit id="8c028c8d7c168ec897f0714ce745b6b98bb2fdf8" translate="yes" xml:space="preserve">
          <source>The byte following the end of this slice (but not included in it) is defined to be zero. This allows passing the result of this function into C functions that expect a null-terminated &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;*&lt;/code&gt;.</source>
          <target state="translated">이 슬라이스의 끝을 따르는 바이트 (포함되지는 않음)는 0으로 정의됩니다. 이를 통해이 함수의 결과를 널 종료 &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;*&lt;/code&gt; C 함수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12a7044b83e5b65e1f3f0799be7549d67873e29d" translate="yes" xml:space="preserve">
          <source>The bytes are encoded into a string of two-digit hexadecimal number (00-ff) per byte.</source>
          <target state="translated">바이트는 바이트 당 2 자리 16 진수 (00-ff) 문자열로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b1dc181c589c2c81315127fbf5bd01314efb8a97" translate="yes" xml:space="preserve">
          <source>The bytesize returned by the block must be less than or equal to the capacity given to this String, otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">블록에서 반환 된 바이트 크기는이 문자열에 지정된 용량보다 작거나 같아야합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ac8f2a086d4777e7a9b6e99489d3c44dad2d5b4" translate="yes" xml:space="preserve">
          <source>The calculation defaults to 5 seconds. During this stage we run the block in sets of the size calculated in the warmup stage. The measurements for those sets are then used to calculate the mean and standard deviation, which are then reported. Additionally we compare the means to that of the fastest.</source>
          <target state="translated">계산의 기본값은 5 초입니다. 이 단계에서는 예열 단계에서 계산 된 크기의 세트로 블록을 실행합니다. 그런 다음 해당 세트의 측정 값을 사용하여 평균 및 표준 편차를 계산 한 다음보고합니다. 또한 우리는 평균을 가장 빠른 방법과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="59713a7aaa52a5d1c1bd0110014985176aee3f58" translate="yes" xml:space="preserve">
          <source>The calendaric calculations are based on the rules of the proleptic Gregorian calendar as specified in &lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601&lt;/a&gt;. Leap seconds are ignored.</source>
          <target state="translated">달력 계산은 &lt;a href=&quot;http://xml.coverpages.org/ISO-FDIS-8601.pdf&quot;&gt;ISO 8601에&lt;/a&gt; 지정된 다발성 Gregorian 달력의 규칙을 기반으로합니다 . 윤초는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e3e66a336341e952658cec3e2d3462555ba10f88" translate="yes" xml:space="preserve">
          <source>The chained assignment is not only available to &lt;a href=&quot;local_variables&quot;&gt;local variables&lt;/a&gt; but also to &lt;a href=&quot;methods_and_instance_variables&quot;&gt;instance variables&lt;/a&gt;, &lt;a href=&quot;class_variables&quot;&gt;class variables&lt;/a&gt; and setter methods (methods that end with &lt;code&gt;=&lt;/code&gt;).</source>
          <target state="translated">체인 할당은 &lt;a href=&quot;local_variables&quot;&gt;로컬 변수&lt;/a&gt; 뿐만 아니라 &lt;a href=&quot;methods_and_instance_variables&quot;&gt;인스턴스 변수&lt;/a&gt; , &lt;a href=&quot;class_variables&quot;&gt;클래스 변수&lt;/a&gt; 및 setter 메서드 ( &lt;code&gt;=&lt;/code&gt; 로 끝나는 메서드 )에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a8e6b73f0e3868ba4897491ad122eaaa7fc6aa" translate="yes" xml:space="preserve">
          <source>The character representing the end of a C string.</source>
          <target state="translated">C 문자열의 끝을 나타내는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="c910e16543eb6089a1ced423cb3d9a507173e278" translate="yes" xml:space="preserve">
          <source>The child method can use &lt;code&gt;:inherit:&lt;/code&gt; to explicitly copy the parent's documentation, without the &lt;code&gt;Description copied from ...&lt;/code&gt; text. &lt;code&gt;:inherit:&lt;/code&gt; can also be used to inject the parent's documentation into additional documentation on the child.</source>
          <target state="translated">The child method can use &lt;code&gt;:inherit:&lt;/code&gt; to explicitly copy the parent's documentation, without the &lt;code&gt;Description copied from ...&lt;/code&gt; text. &lt;code&gt;:inherit:&lt;/code&gt; can also be used to inject the parent's documentation into additional documentation on the child.</target>
        </trans-unit>
        <trans-unit id="208619b92138c118ddc080424dc40dd23a936289" translate="yes" xml:space="preserve">
          <source>The class that signals that there are no more elements in an &lt;code&gt;&lt;a href=&quot;../iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 에 더 이상 요소가 없음을 알리는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="246e83a0b2cce47050e6415df87dfb215152ad82" translate="yes" xml:space="preserve">
          <source>The classic &quot;hello world&quot; program looks like this in Crystal:</source>
          <target state="translated">Crystal에서 고전적인 &quot;hello world&quot;프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14e81c614990e3fc64f551193ff5594abcd10c89" translate="yes" xml:space="preserve">
          <source>The closing delimiter may be followed by a number of optional modifiers to adjust the matching behaviour of the regular expression.</source>
          <target state="translated">닫는 분리 문자 다음에는 정규 표현식의 일치 동작을 조정하기위한 여러 선택적 수정자가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7486c68cd22b715cee9aba70b79ecf03143997ff" translate="yes" xml:space="preserve">
          <source>The code you write is up to you, but how you write it impacts whether people want to use your library and/or help you maintain it.</source>
          <target state="translated">작성하는 코드는 사용자에게 달려 있지만 작성 방법은 사람들이 라이브러리를 사용 하려는지 및 / 또는 유지 관리하는 데 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="60347285fa183e9559a829be9b82c53c06646d0f" translate="yes" xml:space="preserve">
          <source>The codepoint is the integer representation. The Universal Coded Character Set (UCS) standard, commonly known as Unicode, assigns names and meanings to numbers, these numbers are called codepoints.</source>
          <target state="translated">코드 포인트는 정수 표현입니다. 일반적으로 유니 코드라고하는 UCS (Universal Coded Character Set) 표준은 이름과 의미를 숫자에 할당하며이 숫자를 코드 포인트라고합니다.</target>
        </trans-unit>
        <trans-unit id="330d01950261d11e512866b0d0ec968a379ddfe6" translate="yes" xml:space="preserve">
          <source>The color &lt;code&gt;:default&lt;/code&gt; will just leave the object as it is (but it's an &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;(&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; then). That's handy in for example conditions:</source>
          <target state="translated">color &lt;code&gt;:default&lt;/code&gt; 는 객체를 그대로 둡니다 (그러나 &lt;code&gt;&lt;a href=&quot;colorize/object&quot;&gt;Colorize::Object&lt;/a&gt;(&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; ). 예를 들어 조건에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="abea7844f29e40b2cc5ce68386f0a7ee86b755a3" translate="yes" xml:space="preserve">
          <source>The column where this node ends.</source>
          <target state="translated">이 노드가 끝나는 열입니다.</target>
        </trans-unit>
        <trans-unit id="660441ea48991c5819506361f40f8e3d2e10c1f2" translate="yes" xml:space="preserve">
          <source>The column where this node starts.</source>
          <target state="translated">이 노드가 시작되는 열입니다.</target>
        </trans-unit>
        <trans-unit id="6ec5d7f24e502f7603f8d48f715a8f383deed6ff" translate="yes" xml:space="preserve">
          <source>The command creates a static website in &lt;code&gt;output_dir&lt;/code&gt; (default &lt;code&gt;./docs&lt;/code&gt;), consisting of HTML files for each Crystal type, in a folder structure mirroring the Crystal namespaces. The entrypoint &lt;code&gt;docs/index.html&lt;/code&gt; can be opened by any web browser. The entire API docs are also stored as a JSON document in &lt;code&gt;$output_dir/index.json&lt;/code&gt;.</source>
          <target state="translated">이 명령은 Crystal 네임 스페이스를 미러링하는 폴더 구조에서 각 Crystal 유형에 대한 HTML 파일로 구성된 &lt;code&gt;output_dir&lt;/code&gt; (기본 &lt;code&gt;./docs&lt;/code&gt; ) 에 정적 웹 사이트를 만듭니다 . 시작점 &lt;code&gt;docs/index.html&lt;/code&gt; 은 모든 웹 브라우저에서 열 수 있습니다. 전체 API 문서도 &lt;code&gt;$output_dir/index.json&lt;/code&gt; 에 JSON 문서로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d213795e162c8a7f9cc897850b304185dc131844" translate="yes" xml:space="preserve">
          <source>The comparison is based on the instant time-line, even if the local date-time representation (wall clock) would compare differently.</source>
          <target state="translated">로컬 날짜-시간 표시 (월 시계)가 다르게 비교 되더라도 비교는 인스턴트 타임 라인을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="bccff557d651a67be956e45704f6c6d9373e2852" translate="yes" xml:space="preserve">
          <source>The comparison is performed strictly lexically: &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;./foo&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; treated as equal. To compare paths semantically, they need to be normalized and converted to the same kind.</source>
          <target state="translated">비교는 어휘 적으로 엄격하게 수행됩니다. &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;./foo&lt;/code&gt; 는 동일하게 취급 &lt;em&gt;되지 않습니다&lt;/em&gt; . 경로를 의미 적으로 비교하려면 경로를 정규화하고 동일한 종류로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c5e704caf82b468bda81e87129e91c0a1ad8163" translate="yes" xml:space="preserve">
          <source>The comparison operator is usually used to sort values:</source>
          <target state="translated">비교 연산자는 일반적으로 값을 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f30e226d5c7e4d38dd234fed09b1a41dc52b2ae" translate="yes" xml:space="preserve">
          <source>The comparison operator.</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="0fa25ea08f80503e909fd965e8fb970b9b1b0f4e" translate="yes" xml:space="preserve">
          <source>The comparison operator. Returns &lt;code&gt;0&lt;/code&gt; if the two objects are equal, a negative number if this object is considered less than &lt;em&gt;other&lt;/em&gt;, a positive number if this object is considered greter than &lt;em&gt;other&lt;/em&gt;, or &lt;code&gt;nil&lt;/code&gt; if the two objects are not comparable.</source>
          <target state="translated">비교 연산자 반환 &lt;code&gt;0&lt;/code&gt; 개의 오브젝트가 동일한 경우, 이러한 목적은 이하의 것으로 간주되는 경우 음수 &lt;em&gt;다른&lt;/em&gt; , 이러한 목적은보다 greter 간주하는 경우 양수 &lt;em&gt;다른&lt;/em&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 두 개체가 대등하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0b20f37bebb82e98c5c70ee9f85d2cc23547b285" translate="yes" xml:space="preserve">
          <source>The compile-time type can be seen by using &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt;:</source>
          <target state="translated">컴파일 타임 유형은 &lt;a href=&quot;typeof&quot;&gt;typeof&lt;/a&gt; 를 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="901b23955e8f736b478daa8b55c41b490c08a203" translate="yes" xml:space="preserve">
          <source>The compiler infers this attribute for a method if it invokes a method that is marked as &lt;code&gt;@[Raises]&lt;/code&gt; or raises (recursively).</source>
          <target state="translated">컴파일러는 &lt;code&gt;@[Raises]&lt;/code&gt; 로 표시 되거나 올린 (재귀 적으로) 메소드를 호출하는 경우 메소드에 대해이 속성을 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="4f88ccffd3e268d871f2056efb1090cfcf65873f" translate="yes" xml:space="preserve">
          <source>The compiler is usually moderately smart about the type of local variables. For example:</source>
          <target state="translated">컴파일러는 일반적으로 로컬 변수 유형에 대해 적당합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e296b93503486e9e50ffce4c0ba5d7e1f49d91f4" translate="yes" xml:space="preserve">
          <source>The compiler knows that after the block, &lt;code&gt;x&lt;/code&gt; can be Int32 or String (it could know that it will always be String because the method always yields; this may improve in the future).</source>
          <target state="translated">컴파일러는 블록 뒤에 &lt;code&gt;x&lt;/code&gt; 가 Int32 또는 String 일 수 있음을 알고 있습니다 (메소드가 항상 생성되므로 항상 String 일 것임을 알 수 있습니다. 향후에는 개선 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="53f8ad6624549840c274a29bc1f7426230ff0a0e" translate="yes" xml:space="preserve">
          <source>The compiler knows what types are in each key, so when indexing a named tuple with a symbol literal the compiler will return the value for that key and with the expected type, like in the above snippet. Indexing with a symbol literal for which there's no key will give a compile-time error.</source>
          <target state="translated">컴파일러는 각 키에 어떤 유형이 있는지 알고 있으므로 기호 리터럴을 사용하여 명명 된 튜플을 인덱싱 할 때 컴파일러는 위의 스 니펫과 같이 해당 키의 값과 예상되는 유형의 값을 반환합니다. 키가없는 기호 리터럴로 인덱싱하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bc6bfc0d4c299392bdbd27356b3219c7f083103" translate="yes" xml:space="preserve">
          <source>The compiler knows what types are in each position, so when indexing a tuple with an integer literal the compiler will return the value in that index and with the expected type, like in the above snippet. Indexing with an integer literal outside the bounds of the tuple will give a compile-time error.</source>
          <target state="translated">컴파일러는 각 위치에 어떤 유형이 있는지 알고 있으므로 정수 리터럴로 튜플을 인덱싱 할 때 컴파일러는 위의 스 니펫과 같이 해당 인덱스의 값과 예상 된 유형의 값을 반환합니다. 튜플의 범위를 벗어난 정수 리터럴을 사용하여 인덱싱하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bbe6a33fa8b555c81cd9d23de5cc4566013ad8b2" translate="yes" xml:space="preserve">
          <source>The compiler recognizes that in case &lt;code&gt;string&lt;/code&gt; is &lt;code&gt;Nil&lt;/code&gt;, the right hand side of the expression &lt;code&gt;string || raise&lt;/code&gt; will be evaluated. Since &lt;code&gt;typeof(raise &quot;Empty input&quot;)&lt;/code&gt; is &lt;code&gt;NoReturn&lt;/code&gt; the execution would not return to the current scope in that case. That leaves only &lt;code&gt;String&lt;/code&gt; as resulting type of the expression.</source>
          <target state="translated">컴파일러는 &lt;code&gt;string&lt;/code&gt; 이 &lt;code&gt;Nil&lt;/code&gt; 인 경우 표현식 &lt;code&gt;string || raise&lt;/code&gt; 의 오른쪽 || 인상 이 평가됩니다. 이후 &lt;code&gt;typeof(raise &quot;Empty input&quot;)&lt;/code&gt; 이다 &lt;code&gt;NoReturn&lt;/code&gt; 실행은이 경우에서의 전류 범위를 반환 할 것이다. 그 결과 표현식의 결과 유형으로 &lt;code&gt;String&lt;/code&gt; 만 남습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd63548bcd1f9432f120809cb637de7949597f1" translate="yes" xml:space="preserve">
          <source>The compiler uses the &lt;code&gt;CRYSTAL_LIBRARY_PATH&lt;/code&gt; environment variable as a first lookup destination for static and dynamic libraries that are to be linked. This can be used to provide static versions of libraries that are also available as dynamic libraries.</source>
          <target state="translated">컴파일러는 &lt;code&gt;CRYSTAL_LIBRARY_PATH&lt;/code&gt; 환경 변수를 링크 될 정적 및 동적 라이브러리의 첫 번째 검색 대상으로 사용합니다 . 동적 라이브러리로 사용 가능한 정적 버전의 라이브러리를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d112ea3968e90628ecef4e96c3f030557bcc29d4" translate="yes" xml:space="preserve">
          <source>The compiler will always do this for classes and structs under the same hierarchy: it will find the first superclass from which all types inherit from (excluding &lt;code&gt;Reference&lt;/code&gt;, &lt;code&gt;Value&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt;). If it can't find one, the type union remains.</source>
          <target state="translated">컴파일러는 항상 동일한 계층 구조에서 클래스와 구조체에 대해이 작업을 수행합니다. 모든 유형이 상속되는 첫 번째 슈퍼 클래스 ( &lt;code&gt;Reference&lt;/code&gt; , &lt;code&gt;Value&lt;/code&gt; , &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;Float&lt;/code&gt; 제외)를 찾습니다 . 찾을 수없는 경우 유형 공용체가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9aa42ab2fbe7576856d80d14142091ab932b6491" translate="yes" xml:space="preserve">
          <source>The compiler will always resolve a type union to a virtual type if they are under the same hierarchy:</source>
          <target state="translated">컴파일러는 동일한 계층 구조에있는 경우 항상 유형 통합을 가상 유형으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="f6a828022c5a606925e47b002f9dc2a5f92de454" translate="yes" xml:space="preserve">
          <source>The compiler will automatically declare a &lt;code&gt;status_ptr&lt;/code&gt; variable of type &lt;code&gt;Int32&lt;/code&gt;, because the argument is an &lt;code&gt;Int32*&lt;/code&gt;.</source>
          <target state="translated">인수는 &lt;code&gt;Int32*&lt;/code&gt; 이므로 컴파일러는 &lt;code&gt;Int32&lt;/code&gt; 유형 의 &lt;code&gt;status_ptr&lt;/code&gt; 변수를 자동으로 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="7116ec73e25c2ce43e86e6ce030554ec2d346a16" translate="yes" xml:space="preserve">
          <source>The compiler will try to be as smart as possible to require less explicit type restrictions. For example, if assigning an &lt;code&gt;if&lt;/code&gt; expression, type will be inferred from the &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; branches:</source>
          <target state="translated">컴파일러는 명시적인 유형 제한을 덜 요구하기 위해 가능한 한 현명하게 노력합니다. 예를 들어 &lt;code&gt;if&lt;/code&gt; 표현식을 할당 하면 &lt;code&gt;then&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 분기 에서 type이 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="a27fbf176c173a4869ddaa838718beb1520d753e" translate="yes" xml:space="preserve">
          <source>The condition is first tested and, if &lt;em&gt;truthy&lt;/em&gt;, the body is executed. That is, the body might never be executed.</source>
          <target state="translated">조건이 먼저 테스트되고, &lt;em&gt;진실&lt;/em&gt; 이라면 본문이 실행됩니다. 즉, 본문이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d26e86bf874f16afbe8a5db86b9dcf4fbd0f35" translate="yes" xml:space="preserve">
          <source>The current event kind.</source>
          <target state="translated">현재 이벤트 종류.</target>
        </trans-unit>
        <trans-unit id="16bde7a043bf01f1b6c0a902d4c5a199b7b8753b" translate="yes" xml:space="preserve">
          <source>The current fiber will resume after a period of time and have the property &lt;code&gt;timed_out&lt;/code&gt; set to true.</source>
          <target state="translated">The current fiber will resume after a period of time and have the property &lt;code&gt;timed_out&lt;/code&gt; set to true.</target>
        </trans-unit>
        <trans-unit id="fc0b1ad9eec889bdcd71bc817e8e53befda88330" translate="yes" xml:space="preserve">
          <source>The current fiber will resume after a period of time and have the property &lt;code&gt;timed_out&lt;/code&gt; set to true. The timeout can be cancelled with &lt;code&gt;&lt;a href=&quot;fiber#cancel_timeout-class-method&quot;&gt;.cancel_timeout&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">The current fiber will resume after a period of time and have the property &lt;code&gt;timed_out&lt;/code&gt; set to true. The timeout can be cancelled with &lt;code&gt;&lt;a href=&quot;fiber#cancel_timeout-class-method&quot;&gt;.cancel_timeout&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bef575a1ccf5aba6c5ce468bf3a521910a0c63c5" translate="yes" xml:space="preserve">
          <source>The data format must follow the format of &lt;code&gt;mime.types&lt;/code&gt;: Each line declares a MIME type followed by a whitespace-separated list of extensions mapped to this type. Everything following a &lt;code&gt;#&lt;/code&gt; is considered a comment until the end of line. Empty lines are ignored.</source>
          <target state="translated">The data format must follow the format of &lt;code&gt;mime.types&lt;/code&gt; : Each line declares a MIME type followed by a whitespace-separated list of extensions mapped to this type. Everything following a &lt;code&gt;#&lt;/code&gt; is considered a comment until the end of line. Empty lines are ignored.</target>
        </trans-unit>
        <trans-unit id="e5b5bca50bbcb72e98e43922b4012518a5698ff3" translate="yes" xml:space="preserve">
          <source>The data format must follow the format of &lt;code&gt;mime.types&lt;/code&gt;: Each line declares a MIME type followed by a whitespace-separated list of extensions mapped to this type. Everything following a &lt;code&gt;#&lt;/code&gt; is considered a comment until the end of line. Empy line are ignored.</source>
          <target state="translated">데이터 형식은 &lt;code&gt;mime.types&lt;/code&gt; 형식을 따라야합니다 . 각 줄은 MIME 형식을 선언하고이 형식에 매핑 된 공백으로 구분 된 확장 목록을 따릅니다. &lt;code&gt;#&lt;/code&gt; 다음에 나오는 모든 것은 줄 끝까지 주석으로 간주됩니다. Empy 라인은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ac557b14252defbc297671bb0f85f77d4fcb5f" translate="yes" xml:space="preserve">
          <source>The default PRNG is &lt;code&gt;&lt;a href=&quot;random/pcg32&quot;&gt;Random::PCG32&lt;/a&gt;&lt;/code&gt; which has a good overall statistical distribution (low bias of generated numbers) and is fast for overall usages on different platforms, but isn't cryptographically secure. If a third party has access to some generated numbers, she may deduce incoming numbers, putting your application at risk.</source>
          <target state="translated">기본 PRNG는 &lt;code&gt;&lt;a href=&quot;random/pcg32&quot;&gt;Random::PCG32&lt;/a&gt;&lt;/code&gt; 이며 전체 통계 분포가 양호하고 (생성 된 수의 바이어스가 적음) 다른 플랫폼에서 전체적으로 사용하기에는 빠르지 만 암호화 적으로 안전하지는 않습니다. 제 3자가 생성 된 일부 번호에 액세스 할 수 있으면 수신 번호를 추론하여 애플리케이션이 위험에 처할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd51ac360b10bcd84b0c8f91e4e2989fd2773ff" translate="yes" xml:space="preserve">
          <source>The default behaviour is to load the internal defaults as well as the OS-provided MIME database. This can be disabled with &lt;em&gt;load_defaults&lt;/em&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본 동작은 OS 제공 MIME 데이터베이스뿐만 아니라 내부 기본값을로드하는 것입니다. &lt;em&gt;load_defaults&lt;/em&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dad7af7b0f876da9aa949c42f24000929273f588" translate="yes" xml:space="preserve">
          <source>The default formatter outputs the file and line style command for failing specs which makes it easy to rerun just this individual spec.</source>
          <target state="translated">기본 포맷터는 실패한 스펙에 대한 파일 및 라인 스타일 명령을 출력하므로이 개별 스펙 만 쉽게 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b8cc0309c25e817367b59837ebb7571042e378" translate="yes" xml:space="preserve">
          <source>The default receiver within a captured block can't be changed by using &lt;code&gt;with ... yield&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;with ... yield&lt;/code&gt; 를 사용하여 캡처 된 블록 내의 기본 수신기를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f44188190e8ff07b62a15512f4e2653bbf1da67d" translate="yes" xml:space="preserve">
          <source>The default value can also be a &lt;code&gt;Type.new(...)&lt;/code&gt; method or a class method with a return type restriction.</source>
          <target state="translated">기본값은 &lt;code&gt;Type.new(...)&lt;/code&gt; 메서드 또는 반환 형식 제한이있는 클래스 메서드 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af976fa886c4f7b664fc57e291778fd6b49e246c" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2405836e0455b607d437f1441a12ee51443e3dfc" translate="yes" xml:space="preserve">
          <source>The definitions of &quot;concurrency&quot; and &quot;parallelism&quot; sometimes get mixed up, but they are not the same.</source>
          <target state="translated">&quot;동시성&quot;과 &quot;병행 성&quot;의 정의는 때때로 혼동되지만 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="56cc8132a44e585c5a836cac7589ad9dd027f5da" translate="yes" xml:space="preserve">
          <source>The delimiter character &lt;code&gt;/&lt;/code&gt; must be escaped inside slash-delimited regular expression literals. Note that special characters of the PCRE syntax need to be escaped if they are intended as literal characters.</source>
          <target state="translated">구분 문자 &lt;code&gt;/&lt;/code&gt; 는 슬래시로 구분 된 정규 표현식 리터럴 내에서 이스케이프되어야합니다. 리터럴 문자로 의도 된 경우 PCRE 구문의 특수 문자를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9653a8d1e950042ca9213746780e7bc8b914379" translate="yes" xml:space="preserve">
          <source>The development is possible thanks to the community's effort and the continued support of &lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt;, &lt;a href=&quot;https://nikolamotor.com/&quot;&gt;Nikola Motor Company&lt;/a&gt; and every other &lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;sponsor&lt;/a&gt;.</source>
          <target state="translated">The development is possible thanks to the community's effort and the continued support of &lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt;, &lt;a href=&quot;https://nikolamotor.com/&quot;&gt;Nikola Motor Company&lt;/a&gt; and every other &lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;sponsor&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="005cdeadc39a856e459e5bd8473d96fd7f82d81a" translate="yes" xml:space="preserve">
          <source>The development is possible thanks to the community's effort, &lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt;' support, and every &lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;BountySource supporter&lt;/a&gt;.</source>
          <target state="translated">개발은 지역 사회의 노력 덕분에 가능하다 &lt;a href=&quot;https://www.84codes.com/&quot;&gt;84codes&lt;/a&gt; '지원, 모든 &lt;a href=&quot;https://crystal-lang.org/sponsors&quot;&gt;바운티 소스 후원자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7896d2ab08699e91d14ae92a8d97f1b60ffffbf" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;do ... end&lt;/code&gt; and &lt;code&gt;{ ... }&lt;/code&gt; is that &lt;code&gt;do ... end&lt;/code&gt; binds to the left-most call, while &lt;code&gt;{ ... }&lt;/code&gt; binds to the right-most call:</source>
          <target state="translated">사용의 차이 &lt;code&gt;do ... end&lt;/code&gt; 과 &lt;code&gt;{ ... }&lt;/code&gt; 즉 &lt;code&gt;do ... end&lt;/code&gt; 가장 왼쪽의 호출에 바인딩 반면, &lt;code&gt;{ ... }&lt;/code&gt; 가장 오른쪽의 호출에 바인딩 :</target>
        </trans-unit>
        <trans-unit id="d932293ad1229ee6d59947cbf56bffd1ddfe6045" translate="yes" xml:space="preserve">
          <source>The directives are:</source>
          <target state="translated">지시문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3bece92e462e673997e5de7aea3061108ec3fdb" translate="yes" xml:space="preserve">
          <source>The directory used in these examples contains the two regular files (&lt;code&gt;config.h&lt;/code&gt; and &lt;code&gt;main.rb&lt;/code&gt;), the parent directory (&lt;code&gt;..&lt;/code&gt;), and the directory itself (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">이 예제에 사용 된 디렉토리에는 두 개의 일반 파일 ( &lt;code&gt;config.h&lt;/code&gt; 및 &lt;code&gt;main.rb&lt;/code&gt; ), 상위 디렉토리 ( &lt;code&gt;..&lt;/code&gt; ) 및 디렉토리 자체 ( &lt;code&gt;.&lt;/code&gt; )가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6593ecc33a17f47a51d532e371454d0a2e960a" translate="yes" xml:space="preserve">
          <source>The document this builder builds.</source>
          <target state="translated">이 빌더가 빌드 한 문서.</target>
        </trans-unit>
        <trans-unit id="dc120a6a054db66ae816e454062bb51eeda15057" translate="yes" xml:space="preserve">
          <source>The documentation for &lt;code&gt;Child#id&lt;/code&gt; would be:</source>
          <target state="translated">The documentation for &lt;code&gt;Child#id&lt;/code&gt; would be:</target>
        </trans-unit>
        <trans-unit id="b848e705cf22eebab3ac54f82de9a55a1df65b7b" translate="yes" xml:space="preserve">
          <source>The documentation for &lt;code&gt;Unicorn#name&lt;/code&gt; would be:</source>
          <target state="translated">The documentation for &lt;code&gt;Unicorn#name&lt;/code&gt; would be:</target>
        </trans-unit>
        <trans-unit id="a72fae4adb9e9233849f2511abb367174fc0113f" translate="yes" xml:space="preserve">
          <source>The documentation of a method is included into the method summary and the method details. The former includes only the first line, the latter includes the entire documentation. In short, it is preferred to:</source>
          <target state="translated">분석법 문서는 분석법 요약 및 분석법 세부 사항에 포함되어 있습니다. 전자는 첫 번째 줄만 포함하고 후자는 전체 문서를 포함합니다. 즉, 다음을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="0937a36b3d81ac8458f6ad89ee30d846b74b3e12" translate="yes" xml:space="preserve">
          <source>The documentation of the function says:</source>
          <target state="translated">이 기능에 대한 문서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f728086ed3dbe17bdbffeaac3d2343ad483c9c5f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) usually put between receiver and method name (i.e. the &lt;em&gt;operator&lt;/em&gt;) can be omitted.</source>
          <target state="translated">The dot ( &lt;code&gt;.&lt;/code&gt; ) usually put between receiver and method name (i.e. the &lt;em&gt;operator&lt;/em&gt;) can be omitted.</target>
        </trans-unit>
        <trans-unit id="672cec25fd6cd4f425093ea7d30c2cab847d8cd3" translate="yes" xml:space="preserve">
          <source>The duration amounts to the actual time elapsed between both instances, on the instant time-line. The difference between local date-time representations may equal to a different duration, depending on time zone transitions.</source>
          <target state="translated">지속 시간은 인스턴스 타임 라인에서 두 인스턴스간에 경과 된 실제 시간에 해당합니다. 현지 날짜-시간 표현의 차이는 시간대 전환에 따라 다른 지속 시간과 동일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c37ea0ffdf358cedefc364ad6f8b92588cd577ca" translate="yes" xml:space="preserve">
          <source>The easiest, but probably most tedious, way is to use explicit type restrictions.</source>
          <target state="translated">가장 쉽지만 가장 지루한 방법은 명시적인 유형 제한을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="63bbeb85167187d17ca0803b3e824665527089f0" translate="yes" xml:space="preserve">
          <source>The empty node. Similar to a &lt;code&gt;&lt;a href=&quot;nilliteral&quot;&gt;NilLiteral&lt;/a&gt;&lt;/code&gt; but its textual representation is the empty string. This corresponds, for example, to the missing &lt;code&gt;else&lt;/code&gt; branch of an &lt;code&gt;if&lt;/code&gt; without an &lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">빈 노드. &lt;code&gt;&lt;a href=&quot;nilliteral&quot;&gt;NilLiteral&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 텍스트 표현은 빈 문자열입니다. 이 대응, 예를 들어, 누락에 &lt;code&gt;else&lt;/code&gt; 지점의 &lt;code&gt;if&lt;/code&gt; 없이 &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f0e9c0ed65ebb143261ec014d66c5e246230b63" translate="yes" xml:space="preserve">
          <source>The encoded string returned from this method can be used as name or value components for a &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; format serialization. &lt;code&gt;&lt;a href=&quot;http/params&quot;&gt;HTTP::Params&lt;/a&gt;&lt;/code&gt; provides a higher-level API for this use case.</source>
          <target state="translated">이 메소드에서 리턴 된 인코딩 된 문자열은 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 형식 직렬화의 이름 또는 값 구성 요소로 사용될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;http/params&quot;&gt;HTTP::Params&lt;/a&gt;&lt;/code&gt; 는이 사용 사례에 대한 상위 레벨 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19a501ac3170a7625cc3d06fca03beaa27abcd04" translate="yes" xml:space="preserve">
          <source>The enumeration follows the order the keys were inserted.</source>
          <target state="translated">열거는 키가 삽입 된 순서를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="334b8883ac89ea1d46fa3c575e4dc24d15abe6b9" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;&lt;a href=&quot;../env&quot;&gt;ENV&lt;/a&gt;[&quot;TZ&quot;]&lt;/code&gt; is consulted for finding the time zone to use.</source>
          <target state="translated">사용할 시간대를 찾기 위해 환경 변수 &lt;code&gt;&lt;a href=&quot;../env&quot;&gt;ENV&lt;/a&gt;[&quot;TZ&quot;]&lt;/code&gt; 를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="20eff9782cd8ee2b8d19c2f0c13ee7dcc10fba8b" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;LOG_LEVEL&lt;/code&gt; is used to indicate which severity level to emit. By default entries from all sources with &lt;code&gt;Info&lt;/code&gt; and above severity will be logged to &lt;code&gt;&lt;a href=&quot;toplevel#STDOUT&quot;&gt;STDOUT&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;log/iobackend&quot;&gt;Log::IOBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The environment variable &lt;code&gt;LOG_LEVEL&lt;/code&gt; is used to indicate which severity level to emit. By default entries from all sources with &lt;code&gt;Info&lt;/code&gt; and above severity will be logged to &lt;code&gt;&lt;a href=&quot;toplevel#STDOUT&quot;&gt;STDOUT&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;log/iobackend&quot;&gt;Log::IOBackend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d576bfb871feb5067668752916908d478022d4d5" translate="yes" xml:space="preserve">
          <source>The event loop is responsible for keeping track of sleeping fibers waiting for notifications that IO is ready or a timeout reached. When a fiber can be woken, the event loop enqueues it in the scheduler</source>
          <target state="translated">The event loop is responsible for keeping track of sleeping fibers waiting for notifications that IO is ready or a timeout reached. When a fiber can be woken, the event loop enqueues it in the scheduler</target>
        </trans-unit>
        <trans-unit id="289939042a809d4b4c05c5f43058ca29ae965fdf" translate="yes" xml:space="preserve">
          <source>The event loop: which is another fiber. When there are no other fibers ready to be executed, the event loop checks if there is any async operation that is ready, and then executes the fiber waiting for that operation. The event loop is currently implemented with &lt;code&gt;libevent&lt;/code&gt;, which is an abstraction of other event mechanisms like &lt;code&gt;epoll&lt;/code&gt; and &lt;code&gt;kqueue&lt;/code&gt;.</source>
          <target state="translated">이벤트 루프 : 다른 파이버입니다. 실행할 준비가 된 다른 파이버가없는 경우 이벤트 루프는 준비된 비동기 작업이 있는지 확인한 다음 해당 작업을 기다리는 파이버를 실행합니다. 이벤트 루프는 현재 &lt;code&gt;libevent&lt;/code&gt; 로 구현되며 , 이는 &lt;code&gt;epoll&lt;/code&gt; 및 &lt;code&gt;kqueue&lt;/code&gt; 와 같은 다른 이벤트 메커니즘의 추상화입니다 .</target>
        </trans-unit>
        <trans-unit id="6511f81d54c1d1f0e5e4fd06a18a8fbc9143e415" translate="yes" xml:space="preserve">
          <source>The example application</source>
          <target state="translated">The example application</target>
        </trans-unit>
        <trans-unit id="a6d3f4ac0f6da0eaae0f6daef5498357f181fbab" translate="yes" xml:space="preserve">
          <source>The example or example group's description.</source>
          <target state="translated">The example or example group's description.</target>
        </trans-unit>
        <trans-unit id="c26aa8f871e400d70954a0adeef1d6debf5c615c" translate="yes" xml:space="preserve">
          <source>The example that will eventually run when calling &lt;code&gt;&lt;a href=&quot;procsy#run-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The example that will eventually run when calling &lt;code&gt;&lt;a href=&quot;procsy#run-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfbe06a290759cb035c2f02fdd4943aed0c8dcec" translate="yes" xml:space="preserve">
          <source>The executable path will be canonicalized (all symlinks and relative paths will be expanded).</source>
          <target state="translated">실행 가능 경로는 정규화됩니다 (모든 심볼릭 링크 및 상대 경로가 확장 됨).</target>
        </trans-unit>
        <trans-unit id="599aa940baa0b3158257fa7fb63e0524db4d0bad" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b7e3538d35750a6c80b1f95878fe176505dfa93" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1bfa0e0ddd888170dfb91065ef7f439d633802bf" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">블록의 실행 시간은 &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; 를 사용하여 측정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89a823a74578974bd0a0c7713f0c6c71b0b85cc0" translate="yes" xml:space="preserve">
          <source>The execution time of a block can be measured using &lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time#measure(&amp;amp;block):Time::Span-class-method&quot;&gt;.measure&lt;/a&gt;&lt;/code&gt; 를 사용하여 블록의 실행 시간을 측정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59153738139b6eac2a19ed68700b834e55f846f3" translate="yes" xml:space="preserve">
          <source>The exit status code that will be returned by this program is passed to the block as its first argument. In case of any unhandled exception, it is passed as the second argument to the block, if the program terminates normally or &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; is called explicitly, then the second argument will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">The exit status code that will be returned by this program is passed to the block as its first argument. In case of any unhandled exception, it is passed as the second argument to the block, if the program terminates normally or &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; is called explicitly, then the second argument will be &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fd89c2a234ddba0ffc9a9f1fae9c1be8096dcb" translate="yes" xml:space="preserve">
          <source>The exit status code that will be returned by this program is passed to the block as its first argument. In case of any unhandled exception, it is passed as the second argument to the block, if the program terminates normally or &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; is called explicitly, then the second argument will be nil.</source>
          <target state="translated">이 프로그램에 의해 리턴 될 종료 상태 코드는 첫 번째 인수로 블록에 전달됩니다. 처리되지 않은 예외의 경우 프로그램이 정상적으로 종료되거나 &lt;code&gt;&lt;a href=&quot;toplevel#exit(status=0):NoReturn-class-method&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; 가 명시 적으로 호출 되면 두 번째 인수는 블록에 전달됩니다. 두 번째 인수는 nil입니다.</target>
        </trans-unit>
        <trans-unit id="4a045abc5c5e3370ee556095656967fe483ef308" translate="yes" xml:space="preserve">
          <source>The expression above will result in no output.</source>
          <target state="translated">The expression above will result in no output.</target>
        </trans-unit>
        <trans-unit id="14a80cbc06cf77621027d850abe1bc366da3c3a6" translate="yes" xml:space="preserve">
          <source>The expressions passed as arguments to &lt;code&gt;&lt;a href=&quot;toplevel#typeof(*expression):Class-class-method&quot;&gt;typeof&lt;/a&gt;&lt;/code&gt; do not evaluate. The compiler only analyzes their return type.</source>
          <target state="translated">The expressions passed as arguments to &lt;code&gt;&lt;a href=&quot;toplevel#typeof(*expression):Class-class-method&quot;&gt;typeof&lt;/a&gt;&lt;/code&gt; do not evaluate. The compiler only analyzes their return type.</target>
        </trans-unit>
        <trans-unit id="9f46241c26ff01da7f3b3d6385013f970c5e0bdc" translate="yes" xml:space="preserve">
          <source>The fiber's proc has terminated, and the fiber is now considered dead.</source>
          <target state="translated">파이버의 proc 프로세스가 종료되었으며 이제 파이버는 죽은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4c121cdb610ad81756083bed036f80561110e6" translate="yes" xml:space="preserve">
          <source>The fiber's proc has terminated, and the fiber is now considered dead. The fiber is impossible to resume, ever.</source>
          <target state="translated">파이버의 proc 프로세스가 종료되었으며 이제 파이버는 죽은 것으로 간주됩니다. 섬유는 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0d403944bf6fed71d4adbaf5d43a604d67a030f" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently not running and fully saved its context.</source>
          <target state="translated">파이버의 proc이 현재 실행 중이 아니며 컨텍스트를 완전히 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="50ad807d3af39a32f5f08b0259dde9b52a3b978b" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently not running and fully saved its context. The fiber can be resumed safely.</source>
          <target state="translated">파이버의 proc이 현재 실행 중이 아니며 컨텍스트를 완전히 저장했습니다. 섬유는 안전하게 재개 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6f5ccd21c6daa06fd34c08cdb6f256203067ea" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently running or didn't fully save its context.</source>
          <target state="translated">파이버의 proc이 현재 실행 중이거나 컨텍스트를 완전히 저장하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a786767a12553cf62d379e1ba32bb2dc888b542c" translate="yes" xml:space="preserve">
          <source>The fiber's proc is currently running or didn't fully save its context. The fiber can't be resumed.</source>
          <target state="translated">파이버의 proc이 현재 실행 중이거나 컨텍스트를 완전히 저장하지 않았습니다. 광섬유를 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bee5d440fe98063654d400b6134543e61b6bc0d" translate="yes" xml:space="preserve">
          <source>The field type characters are:</source>
          <target state="translated">필드 유형 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afe1f9f4b67401c1810db8891ab5bbcec3861b72" translate="yes" xml:space="preserve">
          <source>The field type controls how the corresponding &lt;code&gt;&lt;a href=&quot;toplevel#sprintf(format_string,args:Array%7CTuple):String-class-method&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; argument is to be interpreted, while the flags modify that interpretation.</source>
          <target state="translated">필드 유형은 해당 &lt;code&gt;&lt;a href=&quot;toplevel#sprintf(format_string,args:Array%7CTuple):String-class-method&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 인수를 해석 하는 방법을 제어 하고 플래그는 해당 해석을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3d0cabb0dec3924f84ac20c0ab88719a5fa4fc4b" translate="yes" xml:space="preserve">
          <source>The field width is an optional integer, followed optionally by a period and a precision. The width specifies the minimum number of characters that will be written to the result for this field.</source>
          <target state="translated">필드 너비는 선택적 정수이며, 선택적으로 마침표와 정밀도입니다. 너비는이 필드의 결과에 기록 될 최소 문자 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4b6d10aefdcc16f0633d9b2f1665f19c6f5de57f" translate="yes" xml:space="preserve">
          <source>The file denoted by &lt;em&gt;filename&lt;/em&gt; must be a valid Crystal program. This macro invocation passes &lt;em&gt;args&lt;/em&gt; to the program as regular program arguments. The program must output a valid Crystal expression. This output is the result of this macro invocation, as a &lt;code&gt;&lt;a href=&quot;macros/macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename으로&lt;/em&gt; 표시된 &lt;em&gt;파일&lt;/em&gt; 은 유효한 Crystal 프로그램이어야합니다. 이 매크로 호출은 &lt;em&gt;args&lt;/em&gt; 를 일반 프로그램 인수로 프로그램에 전달합니다. 프로그램은 유효한 Crystal 식을 출력해야합니다. 이 출력은 &lt;code&gt;&lt;a href=&quot;macros/macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; 로서이 매크로 호출의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="e84e468fa38ebbfa041310765aa747a443561fed" translate="yes" xml:space="preserve">
          <source>The file where the example or example group is defined.</source>
          <target state="translated">The file where the example or example group is defined.</target>
        </trans-unit>
        <trans-unit id="4bb08622a576d8d4f5169eceb64b0143f36aba6f" translate="yes" xml:space="preserve">
          <source>The file will be placed in &lt;em&gt;dir&lt;/em&gt; which defaults to the standard temporary directory &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일은 표준 임시 디렉토리 &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt; 로 기본 설정 되는 &lt;em&gt;dir에&lt;/em&gt; 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7f1640403d9f182a77e3019950bddcdb6697b5b" translate="yes" xml:space="preserve">
          <source>The file/directory separator character. &lt;code&gt;'/'&lt;/code&gt; on all platforms.</source>
          <target state="translated">파일 / 디렉토리 구분 문자 모든 플랫폼에서 &lt;code&gt;'/'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30c3dc3998a9c5f84132da6d3eec00f1eb4d2eba" translate="yes" xml:space="preserve">
          <source>The file/directory separator characters of the current platform. &lt;code&gt;{'/'}&lt;/code&gt; on POSIX, &lt;code&gt;{'\\', '/'}&lt;/code&gt; on Windows.</source>
          <target state="translated">현재 플랫폼의 파일 / 디렉토리 구분 문자 &lt;code&gt;{'/'}&lt;/code&gt; POSIX에, &lt;code&gt;{'\\', '/'}&lt;/code&gt; Windows에서.</target>
        </trans-unit>
        <trans-unit id="ef624ff911ca746c85289883981086d69233acc2" translate="yes" xml:space="preserve">
          <source>The file/directory separator string. &lt;code&gt;&quot;/&quot;&lt;/code&gt; on all platforms.</source>
          <target state="translated">파일 / 디렉토리 구분자 문자열 모든 플랫폼에서 &lt;code&gt;&quot;/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3d50190f7ff29511807626569fb6160233f5396" translate="yes" xml:space="preserve">
          <source>The first alternative is long and cumbersome, while the second one is much easier.</source>
          <target state="translated">첫 번째 대안은 길고 번거롭지 만 두 번째 대안은 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="31061b68dd407b09235c7c1ef9a26c76d6b04315" translate="yes" xml:space="preserve">
          <source>The first argument is either &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;app&lt;/code&gt;. A &lt;code&gt;lib&lt;/code&gt; is a reusable library whereas &lt;code&gt;app&lt;/code&gt; describes an application not intended to be used as a dependency. A library doesn't have a &lt;code&gt;shard.lock&lt;/code&gt; file in its repository and no build target in &lt;code&gt;shard.yml&lt;/code&gt;, but instructions for using it as a dependency.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;lib&lt;/code&gt; 또는 &lt;code&gt;app&lt;/code&gt; 입니다. &lt;code&gt;lib&lt;/code&gt; 반면 재사용 라이브러리 &lt;code&gt;app&lt;/code&gt; 하지 종속성으로 사용하기위한 어플리케이션을 설명한다. 라이브러리에는 저장소에 &lt;code&gt;shard.lock&lt;/code&gt; 파일이없고 &lt;code&gt;shard.yml&lt;/code&gt; 에 빌드 대상이 없지만 종속으로 사용하기위한 지시 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f2b0f830f3e3c9d2c0fadd8f67d8f7eed5680ed" translate="yes" xml:space="preserve">
          <source>The first call's value is 3 because the last expression of the &lt;code&gt;twice&lt;/code&gt; method is &lt;code&gt;yield&lt;/code&gt;, which gets the value of the block. The second call's value is &quot;hello&quot; because a &lt;code&gt;break&lt;/code&gt; was performed.</source>
          <target state="translated">의 마지막 식 때문에 첫 번째 통화의 값은 3 &lt;code&gt;twice&lt;/code&gt; 방법은 &lt;code&gt;yield&lt;/code&gt; 블록의 값을 얻는다. &lt;code&gt;break&lt;/code&gt; 가 수행 되었으므로 두 번째 호출 값은 &quot;hello&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="3fbfa33b37cfbb072d1b127aa2dce98fa6f5e510" translate="yes" xml:space="preserve">
          <source>The first column number in a line is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">행의 첫 번째 열 번호는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cf05659ff2d94c8303ab1881055ee47c442c275" translate="yes" xml:space="preserve">
          <source>The first line number in a file is 1.</source>
          <target state="translated">파일의 첫 번째 줄 번호는 1입니다.</target>
        </trans-unit>
        <trans-unit id="29746ec8cc3c8ed07d200a43767fe0becddc922c" translate="yes" xml:space="preserve">
          <source>The first line number in a file is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">파일의 첫 번째 줄 번호는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ad2055a017dbc22ca82f59ff581b5668a2f7435" translate="yes" xml:space="preserve">
          <source>The first two operators also have inversion operators (&lt;code&gt;!=&lt;/code&gt; and &lt;code&gt;!~&lt;/code&gt;) whose semantical intention is just the inverse of the base operator: &lt;code&gt;a != b&lt;/code&gt; is supposed to be equivalent to &lt;code&gt;!(a == b)&lt;/code&gt; and &lt;code&gt;a !~ b&lt;/code&gt; to &lt;code&gt;!(a =~ b)&lt;/code&gt;. Nevertheless, these inversions can be defined with a custom implementation. This can be useful for example to improve performance (non-equality can often be proven faster than equality).</source>
          <target state="translated">The first two operators also have inversion operators ( &lt;code&gt;!=&lt;/code&gt; and &lt;code&gt;!~&lt;/code&gt; ) whose semantical intention is just the inverse of the base operator: &lt;code&gt;a != b&lt;/code&gt; is supposed to be equivalent to &lt;code&gt;!(a == b)&lt;/code&gt; and &lt;code&gt;a !~ b&lt;/code&gt; to &lt;code&gt;!(a =~ b)&lt;/code&gt; . Nevertheless, these inversions can be defined with a custom implementation. This can be useful for example to improve performance (non-equality can often be proven faster than equality).</target>
        </trans-unit>
        <trans-unit id="7282b6d781cdedc397bb9f92b08cb71c689472a6" translate="yes" xml:space="preserve">
          <source>The first use case is using keywords as named arguments:</source>
          <target state="translated">첫 번째 사용 사례는 키워드를 명명 된 인수로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="944607c5718cd118bb1cd25f452f563fd505d548" translate="yes" xml:space="preserve">
          <source>The flags modifies the behavior of the formats. The flag characters are:</source>
          <target state="translated">플래그는 형식의 동작을 수정합니다. 플래그 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9db0de34324fd35a0db1036bf4e44f8fe23ba11" translate="yes" xml:space="preserve">
          <source>The following configuration will setup for all sources to emit warnings (or higher) to &lt;code&gt;&lt;a href=&quot;toplevel#STDOUT&quot;&gt;STDOUT&lt;/a&gt;&lt;/code&gt;, allow any of the &lt;code&gt;db.*&lt;/code&gt; and nested source to emit debug (or higher), and to also emit for all sources errors (or higher) to an elasticsearch backend.</source>
          <target state="translated">The following configuration will setup for all sources to emit warnings (or higher) to &lt;code&gt;&lt;a href=&quot;toplevel#STDOUT&quot;&gt;STDOUT&lt;/a&gt;&lt;/code&gt; , allow any of the &lt;code&gt;db.*&lt;/code&gt; and nested source to emit debug (or higher), and to also emit for all sources errors (or higher) to an elasticsearch backend.</target>
        </trans-unit>
        <trans-unit id="e6efa2cf6ab96201c82623d35b55f95ec36e4f81" translate="yes" xml:space="preserve">
          <source>The following environment variables are used by the Crystal compiler if set in the environment. Otherwise the compiler will populate them with default values. Their values can be inspected using &lt;a href=&quot;#crystal-env&quot;&gt;&lt;code&gt;crystal env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경에 설정된 경우 Crystal 컴파일러는 다음 환경 변수를 사용합니다. 그렇지 않으면 컴파일러가 기본값으로 채 웁니다. 이들의 값은 &lt;a href=&quot;#crystal-env&quot;&gt; &lt;code&gt;crystal env&lt;/code&gt; &lt;/a&gt; 를 사용하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7401660e992738d61209507d4a620dd6d6b26e3" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the &lt;code&gt;Vector2&lt;/code&gt; type as a two-dimensional vector with a binary operator method &lt;code&gt;+&lt;/code&gt; for vector addition.</source>
          <target state="translated">The following example demonstrates the &lt;code&gt;Vector2&lt;/code&gt; type as a two-dimensional vector with a binary operator method &lt;code&gt;+&lt;/code&gt; for vector addition.</target>
        </trans-unit>
        <trans-unit id="979ce118433b9e43e3a661e508d42f6d8e9b0d8f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the &lt;code&gt;Vector2&lt;/code&gt; type as a two-dimensional vector with a unary operator method &lt;code&gt;-&lt;/code&gt; for vector inversion.</source>
          <target state="translated">The following example demonstrates the &lt;code&gt;Vector2&lt;/code&gt; type as a two-dimensional vector with a unary operator method &lt;code&gt;-&lt;/code&gt; for vector inversion.</target>
        </trans-unit>
        <trans-unit id="3983fe891f5d77f5ef28a06038cb3661047a64b0" translate="yes" xml:space="preserve">
          <source>The following example is the classic Hello World. In Crystal it looks like this:</source>
          <target state="translated">The following example is the classic Hello World. In Crystal it looks like this:</target>
        </trans-unit>
        <trans-unit id="9cc7eb726ec3a5d3307d840aa0563e35c2723422" translate="yes" xml:space="preserve">
          <source>The following key values have special meaning:</source>
          <target state="translated">다음 키 값은 특별한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d7023ad60a85970889177c2463c53776a3c26ce2" translate="yes" xml:space="preserve">
          <source>The following normalizations are applied to the individual components (if available):</source>
          <target state="translated">개별 구성 요소에 다음 정규화가 적용됩니다 (사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="32d153db4deb3628c27875d40cf8d305733ccd36" translate="yes" xml:space="preserve">
          <source>The following options can be combined to filter the list of specs to run.</source>
          <target state="translated">The following options can be combined to filter the list of specs to run.</target>
        </trans-unit>
        <trans-unit id="0016c7b15769c3e1fd83dd79375297c7acf71246" translate="yes" xml:space="preserve">
          <source>The following packages are compliant with crystal-db</source>
          <target state="translated">다음 패키지는 crystal-db와 호환됩니다</target>
        </trans-unit>
        <trans-unit id="ed4a566b4ccf42840a4e12dadfcc10d7098e35b2" translate="yes" xml:space="preserve">
          <source>The following packages are not required, but recommended for using the respective features in the standard library:</source>
          <target state="translated">다음 패키지는 필요하지 않지만 표준 라이브러리에서 각 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df2f6f226ab11b061d48e88e2f779470aed4df0a" translate="yes" xml:space="preserve">
          <source>The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions.</source>
          <target state="translated">다음 프로그램은 MySQL에서 현재 시간을 인쇄하지만 연결이 끊어 지거나 전체 서버가 몇 초 동안 다운되면 프로그램은 예외를 발생시키지 않고 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f65de8007c538aaa6706cdfae0b7fef84f90beff" translate="yes" xml:space="preserve">
          <source>The following rules only mention instance variables, but they apply to class variables as well. They are:</source>
          <target state="translated">다음 규칙은 인스턴스 변수 만 언급하지만 클래스 변수에도 적용됩니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="0dbd1e5907988d5a9b86e8a44f0b23026d0438da" translate="yes" xml:space="preserve">
          <source>The format follows that of &lt;code&gt;mime.types&lt;/code&gt;: Each line is list of MIME type and zero or more extensions, separated by whitespace.</source>
          <target state="translated">형식은 &lt;code&gt;mime.types&lt;/code&gt; 형식을 따릅니다 . 각 줄은 MIME 형식의 목록이며 공백으로 구분 된 0 개 이상의 확장명입니다.</target>
        </trans-unit>
        <trans-unit id="4236b918ce2dedb4ff39d640ea5ef84abf8e19ea" translate="yes" xml:space="preserve">
          <source>The formatted &lt;em&gt;offset&lt;/em&gt; is used as name.</source>
          <target state="translated">형식화 된 &lt;em&gt;오프셋&lt;/em&gt; 이 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9084c0683429eb40329f37c13c0d6d200d202a" translate="yes" xml:space="preserve">
          <source>The formatter is also fast, so very little time is lost if you format the entire project instead of a single file.</source>
          <target state="translated">포맷터도 빠르므로 단일 파일 대신 전체 프로젝트를 포맷하면 시간이 거의 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05b48edc5cca42e2789ffc8837a2004918c00d01" translate="yes" xml:space="preserve">
          <source>The fourth rule is the second rule applied to the third rule.</source>
          <target state="translated">네 번째 규칙은 세 번째 규칙에 적용되는 두 번째 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="875553d741f0131d3a1471771af261d1e9e2f076" translate="yes" xml:space="preserve">
          <source>The general idea and some of the arithmetic algorithms were adapted from the MIT/APACHE-licensed &lt;a href=&quot;https://github.com/akubera/bigdecimal-rs&quot;&gt;bigdecimal-rs&lt;/a&gt;.</source>
          <target state="translated">The general idea and some of the arithmetic algorithms were adapted from the MIT/APACHE-licensed &lt;a href=&quot;https://github.com/akubera/bigdecimal-rs&quot;&gt;bigdecimal-rs&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bc894b0b17eb5fe1f8d04334d39d3eabd11f375d" translate="yes" xml:space="preserve">
          <source>The general type-safe interface for parsing JSON is to invoke &lt;code&gt;T.from_json&lt;/code&gt; on a target type &lt;code&gt;T&lt;/code&gt; and pass either a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; as an argument.</source>
          <target state="translated">JSON 구문 분석을위한 일반적인 유형 안전 인터페이스 는 대상 유형 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;T.from_json&lt;/code&gt; 을 호출 하고 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 인수로 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e33ed10eb7e2b4410d4055c2b4e5f7f6dff7cad5" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; method has a &lt;code&gt;self&lt;/code&gt; restriction.</source>
          <target state="translated">생성 된 &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; 메소드에는 &lt;code&gt;self&lt;/code&gt; 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="161b9b9b4d7ee5f3338616ad526cac2a1b891f99" translate="yes" xml:space="preserve">
          <source>The generated code is the result of translating the contents of the ECR file to Crystal, a program that appends to an IO and returns a string.</source>
          <target state="translated">생성 된 코드는 ECR 파일의 내용을 IO에 추가하고 문자열을 반환하는 프로그램 인 Crystal로 변환 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="850640a99607c250d09463c5d4d44a7952067ec8" translate="yes" xml:space="preserve">
          <source>The generated code is the result of translating the contents of the ECR file to Crystal, a program that appends to an IO.</source>
          <target state="translated">생성 된 코드는 ECR 파일의 내용을 IO에 추가하는 프로그램 인 Crystal로 변환 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="d2927bf521c3240a458f018c8d8c7f2666a4b79c" translate="yes" xml:space="preserve">
          <source>The generated struct has a constructor with the given properties in the same order as declared. The struct only provides getters, not setters, making it immutable by default.</source>
          <target state="translated">생성 된 구조체에는 선언 된 순서와 동일한 순서로 지정된 속성을 가진 생성자가 있습니다. 구조체는 setter가 아닌 getter 만 제공하므로 기본적으로 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea3417d731136bbc84a172b8a9ec5bb44115268" translate="yes" xml:space="preserve">
          <source>The generic argument type &lt;code&gt;N&lt;/code&gt; is a special case in the type grammar as it doesn't specify a type but a size. Its value can be an &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; literal or constant.</source>
          <target state="translated">일반 인수 유형 &lt;code&gt;N&lt;/code&gt; 은 유형이 아니라 크기를 지정하므로 유형 문법에서 특별한 경우입니다. 그 값은 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 리터럴 또는 상수 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83da50509ca833b11f166b7098db606858beaa10" translate="yes" xml:space="preserve">
          <source>The generic type arguments for keys &lt;code&gt;K&lt;/code&gt; and values &lt;code&gt;V&lt;/code&gt; are inferred from the types of the keys or values inside the literal, respectively. When all have the same type, &lt;code&gt;K&lt;/code&gt;/&lt;code&gt;V&lt;/code&gt; equals to that. Otherwise it will be a union of all key types or value types respectively.</source>
          <target state="translated">키 &lt;code&gt;K&lt;/code&gt; 및 값 &lt;code&gt;V&lt;/code&gt; 에 대한 일반 유형 인수는 각각 리터럴 내부의 키 또는 값 유형에서 유추됩니다. 모든 유형 이 같으면 &lt;code&gt;K&lt;/code&gt; / &lt;code&gt;V&lt;/code&gt; 는 해당 유형과 같습니다. 그렇지 않으면 모든 키 유형 또는 값 유형이 각각 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="c0f491fd27dcca34e08785bd778bcdd9fbc7d310" translate="yes" xml:space="preserve">
          <source>The given block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">주어진 블록은 두 요소 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이의 비교를 구현해야합니다 . 여기서 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 을 , &lt;code&gt;a == b&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 , &lt;code&gt;a &amp;gt; b&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 이를 위해 비교 연산자 &lt;code&gt;&lt;a href=&quot;array#(other:Array)-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2c2765b46b6a78d9039aea25933b142ce4dcdb" translate="yes" xml:space="preserve">
          <source>The given block must implement a comparison between two elements &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, where &lt;code&gt;a &amp;lt; b&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;a == b&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;a &amp;gt; b&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. The comparison operator &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; can be used for this.</source>
          <target state="translated">주어진 블록은 두 요소 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 사이의 비교를 구현해야합니다 . 여기서 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 을 , &lt;code&gt;a == b&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 , &lt;code&gt;a &amp;gt; b&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 이를 위해 비교 연산자 &lt;code&gt;&lt;a href=&quot;slice#(other:Slice(U))forallU-instance-method&quot;&gt;#&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba3c60d8e4ce8ec19e0181810c4cfbaaedf9003" translate="yes" xml:space="preserve">
          <source>The group ID that the file belongs to.</source>
          <target state="translated">파일이 속한 그룹 ID입니다.</target>
        </trans-unit>
        <trans-unit id="5235400099bafbbbc2e0e548c45b0be465ae73c6" translate="yes" xml:space="preserve">
          <source>The group that will eventually run when calling &lt;code&gt;&lt;a href=&quot;procsy#run-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The group that will eventually run when calling &lt;code&gt;&lt;a href=&quot;procsy#run-instance-method&quot;&gt;#run&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d63cffc2e9e719f4e3ebd2eeb037ae1637a0fb0" translate="yes" xml:space="preserve">
          <source>The group's identifier.</source>
          <target state="translated">그룹의 식별자</target>
        </trans-unit>
        <trans-unit id="f305e58025f637bd1bb3abad3fefbca0047ef4dc" translate="yes" xml:space="preserve">
          <source>The group's name.</source>
          <target state="translated">그룹 이름</target>
        </trans-unit>
        <trans-unit id="2052a3c1bb6b28b6bc273e30084593c5dba96709" translate="yes" xml:space="preserve">
          <source>The handler chain receives an instance of &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; that holds the &lt;code&gt;&lt;a href=&quot;request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; to process and a &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; which it can configure and write to.</source>
          <target state="translated">처리기 체인은 처리 할 &lt;code&gt;&lt;a href=&quot;request&quot;&gt;HTTP::Request&lt;/a&gt;&lt;/code&gt; 및 구성하고 쓸 수 있는 &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 를 보유하는 &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; 의 인스턴스를받습니다 .</target>
        </trans-unit>
        <trans-unit id="3281389107b6c7f72f81900bfaa5b500e9cdeb5a" translate="yes" xml:space="preserve">
          <source>The handler given to a server can simply be a block that receives an &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt;, or it can be an instance of &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; has a &lt;code&gt;#next&lt;/code&gt; method to forward processing to the next handler in the chain.</source>
          <target state="translated">서버에 제공된 핸들러는 단순히 &lt;code&gt;&lt;a href=&quot;server/context&quot;&gt;HTTP::Server::Context&lt;/a&gt;&lt;/code&gt; 를 수신하는 블록 이거나 &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; 의 인스턴스 일 수 있습니다 . &lt;code&gt;&lt;a href=&quot;handler&quot;&gt;HTTP::Handler&lt;/a&gt;&lt;/code&gt; 갖는다 &lt;code&gt;#next&lt;/code&gt; 체인의 다음 핸들러 전방 처리 방법.</target>
        </trans-unit>
        <trans-unit id="e7fca7732240d34903abd174e4d0486dc5880a17" translate="yes" xml:space="preserve">
          <source>The hash value is used along with &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; by the &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; class to determine if two objects reference the same hash key.</source>
          <target state="translated">해시 값이 함께 사용된다 &lt;code&gt;&lt;a href=&quot;object#==(other)-instance-method&quot;&gt;#==&lt;/a&gt;&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 두 물체가 동일한 해시 키를 참조하는 경우에 결정하는 클래스.</target>
        </trans-unit>
        <trans-unit id="4296f7705e65b93fe2d747f546b9085bc93e071d" translate="yes" xml:space="preserve">
          <source>The hash value is used along with &lt;code&gt;==&lt;/code&gt; by the &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; class to determine if two objects reference the same hash key.</source>
          <target state="translated">해시 값이 함께 사용된다 &lt;code&gt;==&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 두 물체가 동일한 해시 키를 참조하는 경우에 결정하는 클래스.</target>
        </trans-unit>
        <trans-unit id="16d3793c30a780cf4f54bb683fa465b418aa48f7" translate="yes" xml:space="preserve">
          <source>The header to write to the gzip stream.</source>
          <target state="translated">gzip 스트림에 쓸 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="fcc96ce881395326c49c3bd18847ce9208819136" translate="yes" xml:space="preserve">
          <source>The header to write to the gzip stream. It will be written just before the first write to this writer. Changes to the header after the first write are ignored.</source>
          <target state="translated">gzip 스트림에 쓸 헤더입니다. 이 작가에게 첫 번째 쓰기 직전에 쓰여질 것입니다. 첫 번째 쓰기 이후의 헤더 변경은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="22aee03c041742fe85df9b9e026008d04cf773b8" translate="yes" xml:space="preserve">
          <source>The implementation uses a list of system-specifc paths to look for a time zone database. The first time zone database entry matching the given name that is successfully loaded and parsed is returned. Typical paths on Unix-based operating systems are &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt;, &lt;code&gt;/usr/share/lib/zoneinfo/&lt;/code&gt;, or &lt;code&gt;/usr/lib/locale/TZ/&lt;/code&gt;.</source>
          <target state="translated">구현시 시스템 특정 경로 목록을 사용하여 시간대 데이터베이스를 찾습니다. 성공적으로로드되고 구문 분석 된 주어진 이름과 일치하는 첫 번째 시간대 데이터베이스 항목이 리턴됩니다. Unix 기반 운영 체제의 일반적인 경로는 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; , &lt;code&gt;/usr/share/lib/zoneinfo/&lt;/code&gt; 또는 &lt;code&gt;/usr/lib/locale/TZ/&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="551883aa2990efd8eb5d4be92ebed96eae1f59aa" translate="yes" xml:space="preserve">
          <source>The initial value depends on the current application environment, see &lt;code&gt;&lt;a href=&quot;location#load_local:Location-class-method&quot;&gt;.load_local&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">초기 값은 현재 애플리케이션 환경에 따라 다릅니다 . 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;location#load_local:Location-class-method&quot;&gt;.load_local&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7029c3307fafac8110eb16f73429676ca35bcb88" translate="yes" xml:space="preserve">
          <source>The integers must be uniformly distributed between &lt;code&gt;0&lt;/code&gt; and the maximal value for the chosen type.</source>
          <target state="translated">정수는 &lt;code&gt;0&lt;/code&gt; 과 선택한 유형의 최대 값 사이에 균일하게 분포되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="926dd5e448113cba2500b56bfc57b8b5d6768ae8" translate="yes" xml:space="preserve">
          <source>The internal bindings to the &lt;code&gt;LibCrypto&lt;/code&gt; digest operations sometimes require a hash algorithm implementation to be passed as one of the arguments.</source>
          <target state="translated">&lt;code&gt;LibCrypto&lt;/code&gt; 다이제스트 작업에 대한 내부 바인딩 에는 때때로 해시 알고리즘 구현이 인수 중 하나로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25f7c6863f521bdd9ec42e3a206a1f95cdfc1cf8" translate="yes" xml:space="preserve">
          <source>The internal buffer can be resizeable and/or writeable depending on how an &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; is constructed.</source>
          <target state="translated">내부 버퍼는 &lt;code&gt;&lt;a href=&quot;memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 구성 방법에 따라 크기 및 / 또는 쓰기 가능할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45606955e8cce931909a6c69d5ede679a4b15aee" translate="yes" xml:space="preserve">
          <source>The iteration will be stopped once the block returns something that isn't an &lt;code&gt;&lt;a href=&quot;../exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; (e.g. a &lt;code&gt;&lt;a href=&quot;../socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;).</source>
          <target state="translated">블록이 &lt;code&gt;&lt;a href=&quot;../exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 가 아닌 것을 반환하면 (예 : &lt;code&gt;&lt;a href=&quot;../socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; ) 반복이 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="3de70595cf93069e85ebe84d6457f06c459c743c" translate="yes" xml:space="preserve">
          <source>The label associated with this measure</source>
          <target state="translated">이 측정과 관련된 레이블</target>
        </trans-unit>
        <trans-unit id="57d320a91ddd2ac3c63bd9cb42a7f749663eebb6" translate="yes" xml:space="preserve">
          <source>The language and the standard library provide short, readable, easy ways to deal with &lt;code&gt;nil&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">The language and the standard library provide short, readable, easy ways to deal with &lt;code&gt;nil&lt;/code&gt; , such as &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c961f49abfbcb5c3bb290b23e0091e5688b3672" translate="yes" xml:space="preserve">
          <source>The language and the standard library provide short, readable, easy ways to deal with &lt;code&gt;nil&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;block)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">언어와 표준 라이브러리는 &lt;code&gt;&lt;a href=&quot;object#try(&amp;amp;block)-instance-method&quot;&gt;Object#try&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;object#not_nil!-instance-method&quot;&gt;Object#not_nil!&lt;/a&gt;&lt;/code&gt; 과 같이 짧고 읽기 쉽고 간단한 &lt;code&gt;nil&lt;/code&gt; 처리 방법을 제공합니다 ! :</target>
        </trans-unit>
        <trans-unit id="627158d44810f0a6c7e5859fc56380ad01ee04a5" translate="yes" xml:space="preserve">
          <source>The last time this file was modified.</source>
          <target state="translated">이 파일이 마지막으로 수정 된 시간.</target>
        </trans-unit>
        <trans-unit id="c51aa65ff430b4020b0598581342b2d9c53c76cc" translate="yes" xml:space="preserve">
          <source>The last two definitions are invalid and so will give a compile-time error.</source>
          <target state="translated">마지막 두 정의는 유효하지 않으므로 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d46ef3cd6d700f9d2f8be43c61a3e6f036414ea" translate="yes" xml:space="preserve">
          <source>The latest files can be found on the Releases page at GitHub: &lt;a href=&quot;https://github.com/crystal-lang/crystal/releases&quot;&gt;https://github.com/crystal-lang/crystal/releases&lt;/a&gt;</source>
          <target state="translated">최신 파일은 GitHub의 릴리스 페이지에서 확인할 수 있습니다 : &lt;a href=&quot;https://github.com/crystal-lang/crystal/releases&quot;&gt;https://github.com/crystal-lang/crystal/releases&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e45bae2af6044b01904d8c087fbbd7d764ef7120" translate="yes" xml:space="preserve">
          <source>The line where the example or example group ends.</source>
          <target state="translated">The line where the example or example group ends.</target>
        </trans-unit>
        <trans-unit id="f950369918dda495a30052c744c751fa7e48ac2c" translate="yes" xml:space="preserve">
          <source>The line where the example or example group starts.</source>
          <target state="translated">The line where the example or example group starts.</target>
        </trans-unit>
        <trans-unit id="35dbb84b4256926f3ab51300c4ed1ac0f729b277" translate="yes" xml:space="preserve">
          <source>The line where this node ends.</source>
          <target state="translated">이 노드가 끝나는 라인.</target>
        </trans-unit>
        <trans-unit id="4a892453dc7603d33c3517f69db5942483971c7d" translate="yes" xml:space="preserve">
          <source>The line where this node starts.</source>
          <target state="translated">이 노드가 시작되는 라인.</target>
        </trans-unit>
        <trans-unit id="bedd54aa13c2cb76927bb6b0d17610a9102fc5b2" translate="yes" xml:space="preserve">
          <source>The list of secure ciphers (intermediate security) as of May 2016 as per https://wiki.mozilla.org/Security/Server_Side_TLS</source>
          <target state="translated">https://wiki.mozilla.org/Security/Server_Side_TLS에 따라 2016 년 5 월 기준 보안 암호 목록 (중간 보안)</target>
        </trans-unit>
        <trans-unit id="334ab5a5dd9046b31057b4fa736050116313f335" translate="yes" xml:space="preserve">
          <source>The list of secure ciphers on &lt;strong&gt;intermediate&lt;/strong&gt; compatibility level as per Mozilla recommendations.</source>
          <target state="translated">The list of secure ciphers on &lt;strong&gt;intermediate&lt;/strong&gt; compatibility level as per Mozilla recommendations.</target>
        </trans-unit>
        <trans-unit id="9bec8b58159c32b70423479e67a93fef86c51316" translate="yes" xml:space="preserve">
          <source>The list of secure ciphers on &lt;strong&gt;modern&lt;/strong&gt; compatibility level as per Mozilla recommendations.</source>
          <target state="translated">The list of secure ciphers on &lt;strong&gt;modern&lt;/strong&gt; compatibility level as per Mozilla recommendations.</target>
        </trans-unit>
        <trans-unit id="8f1d5f708715ea37c51acf659245c003d445345d" translate="yes" xml:space="preserve">
          <source>The list of secure ciphers on &lt;strong&gt;old&lt;/strong&gt; compatibility level as per Mozilla recommendations.</source>
          <target state="translated">The list of secure ciphers on &lt;strong&gt;old&lt;/strong&gt; compatibility level as per Mozilla recommendations.</target>
        </trans-unit>
        <trans-unit id="2f7f1512675cd07ffa18f48d9a4fccdb4ae2ec35" translate="yes" xml:space="preserve">
          <source>The list of valid call conventions is:</source>
          <target state="translated">유효한 통화 규칙 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="837ef61d38d181f259cc57a7840d151fb3ec7fb2" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;x..y&lt;/code&gt; is semantically equivalent to the explicit constructor &lt;code&gt;Range.new(x, y)&lt;/code&gt; and &lt;code&gt;x...y&lt;/code&gt; to &lt;code&gt;Range.new(x, y, true)&lt;/code&gt;.</source>
          <target state="translated">리터럴 &lt;code&gt;x..y&lt;/code&gt; 는 의미 론적 생성자 &lt;code&gt;Range.new(x, y)&lt;/code&gt; 및 &lt;code&gt;x...y&lt;/code&gt; to &lt;code&gt;Range.new(x, y, true)&lt;/code&gt; 와 의미 적으로 같습니다 .</target>
        </trans-unit>
        <trans-unit id="443382cb3c25faa904e8e39d00f50b9475f6c0fc" translate="yes" xml:space="preserve">
          <source>The local date-time is formatted as date string &lt;code&gt;YYYY-MM-DD HH:mm:ss +ZZ:ZZ:ZZ&lt;/code&gt;. Nanoseconds are always omitted. When the location is &lt;code&gt;UTC&lt;/code&gt;, the offset is replaced with the string &lt;code&gt;UTC&lt;/code&gt;. Offset seconds are omitted if &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">로컬 날짜-시간은 날짜 문자열 &lt;code&gt;YYYY-MM-DD HH:mm:ss +ZZ:ZZ:ZZ&lt;/code&gt; 로 형식이 지정됩니다 . 나노초는 항상 생략됩니다. 위치가 &lt;code&gt;UTC&lt;/code&gt; 인 경우 오프셋은 문자열 &lt;code&gt;UTC&lt;/code&gt; 로 바뀝니다 . &lt;code&gt;0&lt;/code&gt; 이면 오프셋 초가 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="b65b3c1c821ed13bb28df926804f32c12f3596c8" translate="yes" xml:space="preserve">
          <source>The local date-time is formatted as date string &lt;code&gt;YYYY-MM-DD HH:mm:ss.nnnnnnnnn +ZZ:ZZ:ZZ&lt;/code&gt;. Nanoseconds are omitted if &lt;em&gt;with_nanoseconds&lt;/em&gt; is &lt;code&gt;false&lt;/code&gt;. When the location is &lt;code&gt;UTC&lt;/code&gt;, the offset is omitted. Offset seconds are omitted if &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">로컬 날짜-시간은 날짜 문자열 &lt;code&gt;YYYY-MM-DD HH:mm:ss.nnnnnnnnn +ZZ:ZZ:ZZ&lt;/code&gt; 로 형식이 지정됩니다 . &lt;em&gt;with_nanoseconds&lt;/em&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 나노초는 생략됩니다 . 위치가 &lt;code&gt;UTC&lt;/code&gt; 이면 오프셋이 생략됩니다. &lt;code&gt;0&lt;/code&gt; 이면 오프셋 초가 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="184d719b08c2753a11c73738ee57380c402105b8" translate="yes" xml:space="preserve">
          <source>The local date-time representation is resolved to a single instant based on the offset observed in the &lt;em&gt;location&lt;/em&gt; at this time.</source>
          <target state="translated">현지 날짜-시간 표현은 현재 &lt;em&gt;위치&lt;/em&gt; 에서 관찰 된 오프셋을 기반으로 단일 인스턴트로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2875926d172f8d83bdeccbac97d0322873b8baa" translate="yes" xml:space="preserve">
          <source>The local time zone can be accessed as &lt;code&gt;&lt;a href=&quot;location#local-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현지 시간대는 &lt;code&gt;&lt;a href=&quot;location#local-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28617c980adc3b58be7a49ee8fd40b74ec9bb1ec" translate="yes" xml:space="preserve">
          <source>The local time zone can be accessed as &lt;code&gt;&lt;a href=&quot;location#local:Location?-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The local time zone can be accessed as &lt;code&gt;&lt;a href=&quot;location#local:Location?-class-method&quot;&gt;Time::Location.local&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90eeed6293d92c74a1e69b07b8426101885fd4b8" translate="yes" xml:space="preserve">
          <source>The lookup goes like this:</source>
          <target state="translated">조회는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb7ce699e9b0bc8557c425725e6e5fe9464c66ee" translate="yes" xml:space="preserve">
          <source>The machine epsilon (difference between 1.0 and the next representable value)</source>
          <target state="translated">기계 엡실론 (1.0과 다음 표현 가능한 값의 차이)</target>
        </trans-unit>
        <trans-unit id="c390bce9391403d5c083998ebdf467a8babab09a" translate="yes" xml:space="preserve">
          <source>The macro basically defines a constructor accepting a &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; that reads from it and initializes this type's instance variables. It also defines a &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; method by invoking &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; on each of the properties (unless a converter is specified, in which case &lt;code&gt;to_json(value, &lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; is invoked).</source>
          <target state="translated">매크로는 기본적으로 &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; 를 받아들이고이 유형의 인스턴스 변수를 초기화 하는 JSON을 허용하는 생성자를 정의 합니다. 또한 각 속성에서 &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;json/builder&quot;&gt;JSON :: Builder&lt;/a&gt; ) 을 호출 하여 &lt;code&gt;to_json(&lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; 메소드를 정의합니다 ( 컨버터가 지정되지 않은 경우 &lt;code&gt;to_json(value, &lt;a href=&quot;json/builder&quot;&gt;JSON::Builder&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;json/builder&quot;&gt;JSON :: Builder&lt;/a&gt; ) 가 호출 됨).</target>
        </trans-unit>
        <trans-unit id="613f7556e399e351df8b8582fba7c1a7af627c5d" translate="yes" xml:space="preserve">
          <source>The macro basically defines a constructor accepting a &lt;code&gt;&lt;a href=&quot;yaml/pullparser&quot;&gt;YAML::PullParser&lt;/a&gt;&lt;/code&gt; that reads from it and initializes this type's instance variables.</source>
          <target state="translated">이 매크로는 기본적으로 &lt;code&gt;&lt;a href=&quot;yaml/pullparser&quot;&gt;YAML::PullParser&lt;/a&gt;&lt;/code&gt; 를 받아들이고이 유형의 인스턴스 변수를 초기화 하는 생성자를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="66bec5e4d79d31c55fd05c99468c37789fb1e9e9" translate="yes" xml:space="preserve">
          <source>The macro basically translates the text inside the given file to Crystal code that appends to the IO:</source>
          <target state="translated">매크로는 기본적으로 주어진 파일 내의 텍스트를 IO에 추가하는 Crystal 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="24cc5d7baa9f7f8a604002182c5829a497d36738" translate="yes" xml:space="preserve">
          <source>The main difference is that &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; encodes reserved characters (see &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt;), while &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; does not. The decode methods are identical except for the handling of &lt;code&gt;+&lt;/code&gt; characters.</source>
          <target state="translated">주요 차이점은 &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; 은 예약 문자 ( &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt; 참조)를 인코딩 하지만 &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; 는 인코딩 하지 않는다는 것입니다. &lt;code&gt;+&lt;/code&gt; 문자 처리를 제외하고는 디코딩 방법이 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="477ff84a12e6ba25cdd1acfd1d9c58d4ff17d1cb" translate="yes" xml:space="preserve">
          <source>The main difference is that &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; encodes reserved characters (see &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt;), while &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; does not. The decode methods are identical except for the handling of &lt;code&gt;+&lt;/code&gt; characters.</source>
          <target state="translated">The main difference is that &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;.encode_www_form&lt;/a&gt;&lt;/code&gt; encodes reserved characters (see &lt;code&gt;&lt;a href=&quot;uri#reserved?(byte):Bool-class-method&quot;&gt;.reserved?&lt;/a&gt;&lt;/code&gt; ), while &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,io:IO,*,space_to_plus:Bool=false):Nil-class-method&quot;&gt;.encode&lt;/a&gt;&lt;/code&gt; does not. The decode methods are identical except for the handling of &lt;code&gt;+&lt;/code&gt; characters.</target>
        </trans-unit>
        <trans-unit id="0fd8c5f9386095d91293b8f358c5e30735f376f5" translate="yes" xml:space="preserve">
          <source>The main differences between Windows and POSIX paths:</source>
          <target state="translated">Windows와 POSIX 경로의 주요 차이점 :</target>
        </trans-unit>
        <trans-unit id="92b88c577a0a19817b0fd3b6204cf9c516c60358" translate="yes" xml:space="preserve">
          <source>The major version of this semantic version</source>
          <target state="translated">이 시맨틱 버전의 메이저 버전</target>
        </trans-unit>
        <trans-unit id="a542a8312c005e7f8ee22608266bfa27fba9017c" translate="yes" xml:space="preserve">
          <source>The maximum character.</source>
          <target state="translated">최대 문자</target>
        </trans-unit>
        <trans-unit id="2e7ee3b80c77b27f4c54e9f5e5f26120adf74568" translate="yes" xml:space="preserve">
          <source>The maximum possible normal power of 2 exponent</source>
          <target state="translated">2 지수의 최대 가능한 정상 거듭 제곱</target>
        </trans-unit>
        <trans-unit id="5d749b04f26091a11fffc09985e539c3f4376a94" translate="yes" xml:space="preserve">
          <source>The maximum possible power of 10 exponent (such that 10**MAX_10_EXP is representable)</source>
          <target state="translated">10 지수의 최대 거듭 제곱 (10 ** MAX_10_EXP가 표현 가능함)</target>
        </trans-unit>
        <trans-unit id="efacea0a3e6d127c843098e6e5a8441a58d7fe7e" translate="yes" xml:space="preserve">
          <source>The maximum valid codepoint for a character.</source>
          <target state="translated">문자의 최대 유효 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="4f1540445e5df2982cad31413cb4389367488faa" translate="yes" xml:space="preserve">
          <source>The measurement relies on the monotonic clock and is not affected by fluctuations of the system clock (see &lt;code&gt;&lt;a href=&quot;time#monotonic:Time::Span-class-method&quot;&gt;#monotonic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">측정은 단조 클록에 의존하며 시스템 클록의 변동에 영향을받지 않습니다 ( &lt;code&gt;&lt;a href=&quot;time#monotonic:Time::Span-class-method&quot;&gt;#monotonic&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9785cceeff3afbae34b0159f6356ee230b9c1dbf" translate="yes" xml:space="preserve">
          <source>The memory is allocated by the &lt;code&gt;&lt;a href=&quot;gc&quot;&gt;GC&lt;/a&gt;&lt;/code&gt;, so when there are no pointers to this memory, it will be automatically freed.</source>
          <target state="translated">메모리는 &lt;code&gt;&lt;a href=&quot;gc&quot;&gt;GC&lt;/a&gt;&lt;/code&gt; 에 의해 할당 되므로이 메모리에 대한 포인터가 없으면 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9acbe90587d703a07c3a5d3669e351d458e4b9" translate="yes" xml:space="preserve">
          <source>The messages have associated levels, such as &lt;code&gt;&lt;a href=&quot;logger#INFO&quot;&gt;INFO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#ERROR&quot;&gt;ERROR&lt;/a&gt;&lt;/code&gt; that indicate their importance. You can then give the &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; a level, and only messages at that level or higher will be printed.</source>
          <target state="translated">메시지에는 관련 &lt;code&gt;&lt;a href=&quot;logger#INFO&quot;&gt;INFO&lt;/a&gt;&lt;/code&gt; 예 : INFO 또는 &lt;code&gt;&lt;a href=&quot;logger#ERROR&quot;&gt;ERROR&lt;/a&gt;&lt;/code&gt; ) 가 중요도를 나타냅니다. 그런 다음 &lt;code&gt;&lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt;&lt;/code&gt; 에 수준 을 부여하면 해당 수준 이상의 메시지 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="85073eca0fab4ff6430711f9a21a414a7b80bc72" translate="yes" xml:space="preserve">
          <source>The messages, or &lt;code&gt;&lt;a href=&quot;log/entry&quot;&gt;Log::Entry&lt;/a&gt;&lt;/code&gt; have associated levels, such as &lt;code&gt;Info&lt;/code&gt; or &lt;code&gt;Error&lt;/code&gt; that indicate their importance. See &lt;code&gt;&lt;a href=&quot;log/severity&quot;&gt;Log::Severity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The messages, or &lt;code&gt;&lt;a href=&quot;log/entry&quot;&gt;Log::Entry&lt;/a&gt;&lt;/code&gt; have associated levels, such as &lt;code&gt;Info&lt;/code&gt; or &lt;code&gt;Error&lt;/code&gt; that indicate their importance. See &lt;code&gt;&lt;a href=&quot;log/severity&quot;&gt;Log::Severity&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a325dabdd4e7156d25135a862cc70b6e8c694cf" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;https://crystal-lang.org/api/latest/toplevel.html#gets%28*args,**options%29-class-method&quot;&gt;&lt;code&gt;gets&lt;/code&gt;&lt;/a&gt; will &lt;strong&gt;pause&lt;/strong&gt; the execution of the application, until the user finishes entering the input (pressing the &lt;code&gt;Enter&lt;/code&gt; key). When the user presses &lt;code&gt;Enter&lt;/code&gt;, then the execution will continue and &lt;code&gt;user_input&lt;/code&gt; will have the user value.</source>
          <target state="translated">The method &lt;a href=&quot;https://crystal-lang.org/api/latest/toplevel.html#gets%28*args,**options%29-class-method&quot;&gt; &lt;code&gt;gets&lt;/code&gt; &lt;/a&gt; will &lt;strong&gt;pause&lt;/strong&gt; the execution of the application, until the user finishes entering the input (pressing the &lt;code&gt;Enter&lt;/code&gt; key). When the user presses &lt;code&gt;Enter&lt;/code&gt; , then the execution will continue and &lt;code&gt;user_input&lt;/code&gt; will have the user value.</target>
        </trans-unit>
        <trans-unit id="79059b37ccde55e0de51ec59b6bc7015df02202c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;time#to_s(format:String):String-instance-method&quot;&gt;#to_s&lt;/a&gt;&lt;/code&gt; formats the date-time according to a specified pattern.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time#to_s(format:String):String-instance-method&quot;&gt;#to_s&lt;/a&gt;&lt;/code&gt; 메소드 는 지정된 패턴에 따라 날짜-시간의 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b5f1647fa4d472453be3476f0555d8c316c55797" translate="yes" xml:space="preserve">
          <source>The minimum possible normal power of 2 exponent</source>
          <target state="translated">최소 지수 2의 지수</target>
        </trans-unit>
        <trans-unit id="26806f6ed283af57d43319fb6240eff3c52738e3" translate="yes" xml:space="preserve">
          <source>The minimum possible power of 10 exponent (such that 10**MIN_10_EXP is representable)</source>
          <target state="translated">10 지수의 가능한 최소 거듭 제곱 (10 ** MIN_10_EXP가 표시 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="02879b0ef4ab29b6647d81af88e6c64df344a41b" translate="yes" xml:space="preserve">
          <source>The minor version of this semantic version</source>
          <target state="translated">이 시맨틱 버전의 부 버전</target>
        </trans-unit>
        <trans-unit id="699d0fce28e9c2d7583b258bd7c662d9d3baaac5" translate="yes" xml:space="preserve">
          <source>The most typical use case of a Deque is a queue: use &lt;code&gt;&lt;a href=&quot;deque#push(value:T)-instance-method&quot;&gt;#push&lt;/a&gt;&lt;/code&gt; to add items to the end of the queue and &lt;code&gt;&lt;a href=&quot;deque#shift-instance-method&quot;&gt;#shift&lt;/a&gt;&lt;/code&gt; to get and remove the item at the beginning of the queue.</source>
          <target state="translated">Deque의 가장 일반적인 유스 케이스는 큐입니다. &lt;code&gt;&lt;a href=&quot;deque#push(value:T)-instance-method&quot;&gt;#push&lt;/a&gt;&lt;/code&gt; 를 사용 하여 큐 끝에 항목을 추가하고 &lt;code&gt;&lt;a href=&quot;deque#shift-instance-method&quot;&gt;#shift&lt;/a&gt;&lt;/code&gt; 를 사용하여 큐 시작시 항목을 가져오고 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ab75b012f87e2f58693175b5170d0957e5f7aa7a" translate="yes" xml:space="preserve">
          <source>The multicast hops option controls the &lt;code&gt;hoplimit&lt;/code&gt; field on uni-cast packets.</source>
          <target state="translated">멀티 캐스트 홉 옵션은 유니 캐스트 패킷 의 &lt;code&gt;hoplimit&lt;/code&gt; 필드를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="376fe9ebc2a1cd19b33ca38e7c489c42078eb66c" translate="yes" xml:space="preserve">
          <source>The multicast hops option controls the &lt;code&gt;hoplimit&lt;/code&gt; field on uni-cast packets. If &lt;code&gt;-1&lt;/code&gt; is specified, the kernel will use a default value. If a value of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; is specified, the packet will have the specified value as &lt;code&gt;hoplimit&lt;/code&gt;. Other values are considered invalid and &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; will be raised. Datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; are not forwarded beyond the local network. Multicast datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt; will not be transmitted on any network, but may be delivered locally if the sending host belongs to the destination group and multicast loopback is enabled.</source>
          <target state="translated">멀티 캐스트 홉 옵션은 유니 캐스트 패킷 의 &lt;code&gt;hoplimit&lt;/code&gt; 필드를 제어합니다 . 경우 &lt;code&gt;-1&lt;/code&gt; 을 지정, 커널은 디폴트 값을 사용합니다. &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;255&lt;/code&gt; 사이 의 값을 지정하면 패킷에 지정된 값이 &lt;code&gt;hoplimit&lt;/code&gt; 로 지정됩니다 . 다른 값은 유효하지 않은 것으로 간주되며 &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;hoplimit&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 인 데이터 그램 은 로컬 네트워크를 넘어 전달되지 않습니다. &lt;code&gt;hoplimit&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 인 멀티 캐스트 데이터 그램은 네트워크에서 전송되지 않지만 송신 호스트가 대상 그룹에 속하고 멀티 캐스트 루프백이 활성화 된 경우 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc418ba88e0fe15c8a9672a23317d75e2a4acef4" translate="yes" xml:space="preserve">
          <source>The multicast hops option controls the &lt;code&gt;hoplimit&lt;/code&gt; field on uni-cast packets. If &lt;code&gt;-1&lt;/code&gt; is specified, the kernel will use a default value. If a value of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; is specified, the packet will have the specified value as &lt;code&gt;hoplimit&lt;/code&gt;. Other values are considered invalid and &lt;code&gt;&lt;a href=&quot;socket/error&quot;&gt;Socket::Error&lt;/a&gt;&lt;/code&gt; will be raised. Datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; are not forwarded beyond the local network. Multicast datagrams with a &lt;code&gt;hoplimit&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt; will not be transmitted on any network, but may be delivered locally if the sending host belongs to the destination group and multicast loopback is enabled.</source>
          <target state="translated">멀티 캐스트 홉 옵션은 유니 캐스트 패킷 의 &lt;code&gt;hoplimit&lt;/code&gt; 필드를 제어합니다 . 경우 &lt;code&gt;-1&lt;/code&gt; 을 지정, 커널은 디폴트 값을 사용합니다. &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;255&lt;/code&gt; 사이 의 값을 지정하면 패킷은 &lt;code&gt;hoplimit&lt;/code&gt; 로 지정된 값을 갖게 됩니다. 다른 값은 유효하지 않은 것으로 간주되며 &lt;code&gt;&lt;a href=&quot;socket/error&quot;&gt;Socket::Error&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;hoplimit&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 인 데이터 그램 은 로컬 네트워크를 넘어 전달되지 않습니다. &lt;code&gt;hoplimit&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 멀티 캐스트 데이터 그램은 네트워크에서 전송되지 않지만 보내는 호스트가 대상 그룹에 속하고 멀티 캐스트 루프백이 활성화 된 경우 로컬로 배달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104f47f2cc5a5abd173a75e9507ec460a87beeaa" translate="yes" xml:space="preserve">
          <source>The name of the fiber, used as internal reference.</source>
          <target state="translated">내부 참조로 사용되는 광섬유의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4e758fd8fecf2be686c56b541c8c809b3067485d" translate="yes" xml:space="preserve">
          <source>The name of the location is appended unless it is a fixed zone offset.</source>
          <target state="translated">고정 구역 오프셋이 아닌 경우 위치 이름이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bb028927b758c34b9bde7df608f21b7744ef223a" translate="yes" xml:space="preserve">
          <source>The name of the null device on the host platform. &lt;code&gt;/dev/null&lt;/code&gt; on UNIX and &lt;code&gt;NUL&lt;/code&gt; on win32.</source>
          <target state="translated">호스트 플랫폼에서 널 장치의 이름입니다. UNIX의 경우 &lt;code&gt;/dev/null&lt;/code&gt; , win32의 경우 &lt;code&gt;NUL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03761e66dc106f1ff0d2f9d8bf80811bd74655c6" translate="yes" xml:space="preserve">
          <source>The name, the program was called with.</source>
          <target state="translated">프로그램이 호출 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="998e11cdecb726392509593efacde54c0ef63c06" translate="yes" xml:space="preserve">
          <source>The names of required named arguments</source>
          <target state="translated">필요한 명명 된 인수의 이름</target>
        </trans-unit>
        <trans-unit id="fe3101e5381913cbe1fe94ba506dd0a8d9967d33" translate="yes" xml:space="preserve">
          <source>The network address that sent the request to an HTTP server.</source>
          <target state="translated">요청을 HTTP 서버로 보낸 네트워크 주소입니다.</target>
        </trans-unit>
        <trans-unit id="eeaf65de799d8a96e82b49ec64d24bf6f6adcc89" translate="yes" xml:space="preserve">
          <source>The newly created fiber doesn't run as soon as spawned.</source>
          <target state="translated">새로 생성 된 파이버는 생성 되 자마자 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78546fe92ed6fb2bc339f577731c0dfa103602db" translate="yes" xml:space="preserve">
          <source>The next sections will assume you know what &lt;a href=&quot;http://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;object oriented programming&lt;/a&gt; is, as well as the concepts of &lt;a href=&quot;http://en.wikipedia.org/wiki/Class_%28computer_programming%29&quot;&gt;classes&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Method_%28computer_programming%29&quot;&gt;methods&lt;/a&gt;.</source>
          <target state="translated">다음 섹션에서는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;객체 지향 프로그래밍&lt;/a&gt; 이 무엇인지 , &lt;a href=&quot;http://en.wikipedia.org/wiki/Class_%28computer_programming%29&quot;&gt;클래스&lt;/a&gt; 와 &lt;a href=&quot;http://en.wikipedia.org/wiki/Method_%28computer_programming%29&quot;&gt;메소드&lt;/a&gt; 의 개념을 알고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="84b6a8ec5662f00d33bad19190ac9fa3fe3b584b" translate="yes" xml:space="preserve">
          <source>The nil literal.</source>
          <target state="translated">nil 리터럴.</target>
        </trans-unit>
        <trans-unit id="9b372dff10b7db41b2b38e60b2637ac657fa7e7d" translate="yes" xml:space="preserve">
          <source>The node this alias points to.</source>
          <target state="translated">이 별명이 가리키는 노드.</target>
        </trans-unit>
        <trans-unit id="a5d79ff59503ed5a2b6e2a0095ca398a969d5aed" translate="yes" xml:space="preserve">
          <source>The node this alias points to. This is set by &lt;code&gt;&lt;a href=&quot;../nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt;, and is &lt;code&gt;nil&lt;/code&gt; by default.</source>
          <target state="translated">이 별명이 가리키는 노드. 이 설정되어 &lt;code&gt;&lt;a href=&quot;../nodes#parse(string_or_io:String%7CIO):Document-class-method&quot;&gt;YAML::Nodes.parse&lt;/a&gt;&lt;/code&gt; 하고있다 &lt;code&gt;nil&lt;/code&gt; 을 기본적으로.</target>
        </trans-unit>
        <trans-unit id="28778dee70b04f98759125cf3fc5bb7f4cbd09e0" translate="yes" xml:space="preserve">
          <source>The nodes in this sequence.</source>
          <target state="translated">이 순서의 노드</target>
        </trans-unit>
        <trans-unit id="4f34511776ef20fe5fe37858e9a7500523697d6f" translate="yes" xml:space="preserve">
          <source>The nodes inside this document.</source>
          <target state="translated">이 문서 내의 노드.</target>
        </trans-unit>
        <trans-unit id="2e01fbb822b433fee2ee41c5d94d65e6bee0ae25" translate="yes" xml:space="preserve">
          <source>The nodes inside this mapping, stored linearly as key1 - value1 - key2 - value2 - etc.</source>
          <target state="translated">이 맵핑 내부의 노드는 key1-value1-key2-value2-등으로 선형으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3d8239dccc739a59a3b15148a539406e9882bd09" translate="yes" xml:space="preserve">
          <source>The number of arguments</source>
          <target state="translated">인수의 수</target>
        </trans-unit>
        <trans-unit id="2d7047afe7f2ecf95be173685099de7fb2d47de5" translate="yes" xml:space="preserve">
          <source>The number of bits the BitArray stores</source>
          <target state="translated">BitArray가 저장하는 비트 수</target>
        </trans-unit>
        <trans-unit id="932f50d2358bc832f13ffe65aea2d8ccd4f87f12" translate="yes" xml:space="preserve">
          <source>The number of decimal digits that can be represented without losing precision</source>
          <target state="translated">정밀도를 잃지 않고 표현할 수있는 소수 자릿수</target>
        </trans-unit>
        <trans-unit id="149402a56e543f699a338dcf5bd5983e726d28d9" translate="yes" xml:space="preserve">
          <source>The number of digits that can be represented without losing precision (in base RADIX)</source>
          <target state="translated">정밀도를 잃지 않고 표현할 수있는 자릿수 (기본 RADIX)</target>
        </trans-unit>
        <trans-unit id="d7af8f92e80d575a308150c0f91dc9b8fb13e781" translate="yes" xml:space="preserve">
          <source>The number of months.</source>
          <target state="translated">개월 수</target>
        </trans-unit>
        <trans-unit id="c16a1a82cd0e589217f9fa691b14825aefa0cf34" translate="yes" xml:space="preserve">
          <source>The number of probes sent, without response before dropping the connection.</source>
          <target state="translated">연결을 끊기 전에 응답없이 보낸 프로브 수입니다.</target>
        </trans-unit>
        <trans-unit id="d3811a0131b55024431ec7bed658225d7b97cb55" translate="yes" xml:space="preserve">
          <source>The number of remaining bytes to be read.</source>
          <target state="translated">읽을 나머지 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf43a2809ea6d373d29ac2cdaad4c2c1bd4d6349" translate="yes" xml:space="preserve">
          <source>The oldest clients supported by this configuration are:</source>
          <target state="translated">이 구성에서 지원하는 가장 오래된 클라이언트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f338fe73db5a49e1625a8e98ce8a3f1c3f45295a" translate="yes" xml:space="preserve">
          <source>The only difference is that the first error message is a little more clear, but both definitions are safe in that you will get a compile time error anyway. So, in general, it's preferable not to specify type restrictions and almost only use them to define different method overloads. This results in more generic, reusable code. For example, if we define a class that has a &lt;code&gt;+&lt;/code&gt; method but isn't a &lt;code&gt;Number&lt;/code&gt;, we can use the &lt;code&gt;add&lt;/code&gt; method that doesn't have type restrictions, but we can't use the &lt;code&gt;add&lt;/code&gt; method that has restrictions.</source>
          <target state="translated">유일한 차이점은 첫 번째 오류 메시지가 조금 더 명확하다는 것입니다. 그러나 어쨌든 컴파일 시간 오류가 발생한다는 점에서 두 정의 모두 안전합니다. 따라서 일반적으로 유형 제한을 지정하지 않고 다른 방법 오버로드를 정의하는 데 거의 제한 만 사용하는 것이 좋습니다. 보다 일반적인 재사용 가능한 코드가 생성됩니다. 예를 들어, 우리는이 클래스를 정의하는 경우 &lt;code&gt;+&lt;/code&gt; 의 방법을하지만,없는 &lt;code&gt;Number&lt;/code&gt; , 우리가 사용할 수있는 &lt;code&gt;add&lt;/code&gt; 유형 제한이없는 방법을, 그러나 우리는 사용할 수 없습니다 &lt;code&gt;add&lt;/code&gt; 제한이 방법을.</target>
        </trans-unit>
        <trans-unit id="f16ae79b25ed11b7aa9209daf53be8357e5448f0" translate="yes" xml:space="preserve">
          <source>The only falsey values are &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and null pointers (pointers whose memory address is zero). Any other value is truthy.</source>
          <target state="translated">유일한 잘못된 값은 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 및 null 포인터 (메모리 주소가 0 인 포인터)입니다. 다른 가치는 진실입니다.</target>
        </trans-unit>
        <trans-unit id="d2ba520fa51fd8d8b9e4a636c0e3159d95a00a2a" translate="yes" xml:space="preserve">
          <source>The only requirement for a type including the &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; module is to define these two methods:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모듈을 포함한 유형에 대한 유일한 요구 사항은 다음 두 가지 방법을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35c3020364682ec2b277f82b96428ea6e1c5b328" translate="yes" xml:space="preserve">
          <source>The only time zone offset in this location is &lt;code&gt;&lt;a href=&quot;location/zone#UTC&quot;&gt;Zone::UTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 위치에서 유일한 시간대 오프셋은 &lt;code&gt;&lt;a href=&quot;location/zone#UTC&quot;&gt;Zone::UTC&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bad3c4ba1e595dfe6ef41f8dda662776cbc13df2" translate="yes" xml:space="preserve">
          <source>The optional anchor of a node.</source>
          <target state="translated">노드의 선택적 앵커입니다.</target>
        </trans-unit>
        <trans-unit id="a23d3869181b7966eed7da248d4c565267255680" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;em&gt;calculation&lt;/em&gt; and &lt;em&gt;warmup&lt;/em&gt; set the duration of those stages in seconds. For more detail on these stages see &lt;code&gt;&lt;a href=&quot;benchmark/ips&quot;&gt;Benchmark::IPS&lt;/a&gt;&lt;/code&gt;. When the &lt;em&gt;interactive&lt;/em&gt; parameter is &lt;code&gt;true&lt;/code&gt;, results are displayed and updated as they are calculated, otherwise all at once.</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;계산&lt;/em&gt; 및 &lt;em&gt;예열&lt;/em&gt; 은 해당 단계의 지속 시간을 초 단위로 설정합니다. 이러한 단계에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;benchmark/ips&quot;&gt;Benchmark::IPS&lt;/a&gt;&lt;/code&gt; 참조하십시오 . 때 &lt;em&gt;대화 형&lt;/em&gt; 매개 변수가 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 모두 한 번에, 결과가 표시됩니다 그들이 계산으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="908488df9900589a734ddda7befd0be561a2bb36" translate="yes" xml:space="preserve">
          <source>The optional tag of a node.</source>
          <target state="translated">노드의 선택적 태그입니다.</target>
        </trans-unit>
        <trans-unit id="95ea40b7b8d6666434328bce32ed79b31e257999" translate="yes" xml:space="preserve">
          <source>The order of the array follows the order the keys were inserted in the Hash.</source>
          <target state="translated">배열의 순서는 키가 해시에 삽입 된 순서를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bcd1e063d92bbe1e8714e2ac9c830c4af18736b0" translate="yes" xml:space="preserve">
          <source>The parser doesn't create this nodes. Instead, you create them by invoking &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; on some nodes. For example, invoking &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; returns a &lt;code&gt;&lt;a href=&quot;macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; for the string's content. Similarly, invoking ID on a &lt;code&gt;&lt;a href=&quot;symbolliteral&quot;&gt;SymbolLiteral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;call&quot;&gt;Call&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;var&quot;&gt;Var&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path&quot;&gt;Path&lt;/a&gt;&lt;/code&gt; return MacroIds for the node's content.</source>
          <target state="translated">파서는이 노드를 만들지 않습니다. 대신 일부 노드에서 &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; 를 호출하여 생성합니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;macroid#id:MacroId-instance-method&quot;&gt;#id&lt;/a&gt;&lt;/code&gt; 를 호출 하면 문자열 내용에 대한 &lt;code&gt;&lt;a href=&quot;macroid&quot;&gt;MacroId&lt;/a&gt;&lt;/code&gt; 가 반환 됩니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;symbolliteral&quot;&gt;SymbolLiteral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;call&quot;&gt;Call&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;var&quot;&gt;Var&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;path&quot;&gt;Path&lt;/a&gt;&lt;/code&gt; 에서 ID를 호출 하면 노드 내용에 대한 MacroId가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9c6ed999e32833699167efee30205c6dfdd62852" translate="yes" xml:space="preserve">
          <source>The passed arguments become a &lt;a href=&quot;http://crystal-lang.org/api/Tuple.html&quot;&gt;Tuple&lt;/a&gt; in the method's body:</source>
          <target state="translated">전달 된 인수 는 메소드 본문에서 &lt;a href=&quot;http://crystal-lang.org/api/Tuple.html&quot;&gt;Tuple이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a7cc3f4b05b7a37abb5d8eddb88666e0d6ce2da3" translate="yes" xml:space="preserve">
          <source>The patch version of this semantic version</source>
          <target state="translated">이 시맨틱 버전의 패치 버전</target>
        </trans-unit>
        <trans-unit id="abef7a9a36ac8826e0db03a19e466cedc6f95840" translate="yes" xml:space="preserve">
          <source>The path will be placed in &lt;em&gt;dir&lt;/em&gt; which defaults to the standard temporary directory &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경로는 &lt;em&gt;dir에&lt;/em&gt; 배치되며 기본 디렉토리는 표준 임시 디렉토리 &lt;code&gt;&lt;a href=&quot;dir#tempdir:String-class-method&quot;&gt;Dir.tempdir&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a42b6a28a3631b4b8690c59ec23c2cf33ba5461" translate="yes" xml:space="preserve">
          <source>The pattern of a format is a &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with directives. Directives being with a percent (&lt;code&gt;%&lt;/code&gt;) character. Any text not listed as a directive will be passed/parsed through the output/input string.</source>
          <target state="translated">형식의 패턴은 지시문 이있는 &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 입니다. 지시문은 백분율 ( &lt;code&gt;%&lt;/code&gt; ) 문자를 사용합니다. 지시문으로 나열되지 않은 모든 텍스트는 출력 / 입력 문자열을 통해 전달 / 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="63fcbfebaa791ff8cd52d2e73c34aadd82558129" translate="yes" xml:space="preserve">
          <source>The pattern syntax is similar to shell filename globbing, see &lt;code&gt;&lt;a href=&quot;file#match?(pattern:String,path:Path%7CString)-class-method&quot;&gt;File.match?&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">패턴 구문은 쉘 파일 이름 globbing과 유사합니다. &lt;code&gt;&lt;a href=&quot;file#match?(pattern:String,path:Path%7CString)-class-method&quot;&gt;File.match?&lt;/a&gt;&lt;/code&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="b8c653ef61db759eaee9f377523533373a490dfb" translate="yes" xml:space="preserve">
          <source>The pattern syntax is similar to shell filename globbing. It may contain the following metacharacters:</source>
          <target state="translated">패턴 구문은 쉘 파일 이름 globbing과 유사합니다. 다음과 같은 메타 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cfa925e735950ad01227d0c7931b35b21fdca9" translate="yes" xml:space="preserve">
          <source>The permissions of the file.</source>
          <target state="translated">파일의 권한</target>
        </trans-unit>
        <trans-unit id="2cb51394b11ccdeba5fb3a77769718aec470abb3" translate="yes" xml:space="preserve">
          <source>The pipe (&lt;code&gt;|&lt;/code&gt;) in types creates a union type. &lt;code&gt;Int32 | String&lt;/code&gt; is read &quot;Int32 or String&quot;. In regular code, &lt;code&gt;Int32 | String&lt;/code&gt; means invoking the method &lt;code&gt;|&lt;/code&gt; on &lt;code&gt;Int32&lt;/code&gt; with &lt;code&gt;String&lt;/code&gt; as an argument.</source>
          <target state="translated">유형 의 파이프 ( &lt;code&gt;|&lt;/code&gt; )는 공용체 유형을 작성합니다. &lt;code&gt;Int32 | String&lt;/code&gt; 은 &quot;Int32 또는 String&quot;입니다. 일반 코드에서 &lt;code&gt;Int32 | String&lt;/code&gt; 은 메소드를 호출하는 것을 의미합니다 &lt;code&gt;|&lt;/code&gt; 에 &lt;code&gt;Int32&lt;/code&gt; 와 &lt;code&gt;String&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="233339fd0b1f8ab1f56c72f3df860dc75ecd12fd" translate="yes" xml:space="preserve">
          <source>The port of the HTTP server is set by using the method bind_tcp on the object HTTP::Server (the port set to 8080).</source>
          <target state="translated">HTTP 서버의 포트는 HTTP :: Server 오브젝트에서 포트 bind_tcp 메소드를 사용하여 설정됩니다 (포트는 8080으로 설정 됨).</target>
        </trans-unit>
        <trans-unit id="32fc4b8244c63bfc760d47d4cab241e356f6f852" translate="yes" xml:space="preserve">
          <source>The pre-release version of this semantic version</source>
          <target state="translated">이 시맨틱 버전의 시험판 버전</target>
        </trans-unit>
        <trans-unit id="05a899a7976a7c20096dbfcb3e00d17266d2e22d" translate="yes" xml:space="preserve">
          <source>The primary purpose of this method is to &quot;tap into&quot; a method chain, in order to perform operations on intermediate results within the chain.</source>
          <target state="translated">이 방법의 주요 목적은 체인 내 중간 결과에 대한 작업을 수행하기 위해 분석법 체인을 &quot;탭핑&quot;하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ff2bfab5292b6da8c94127d4e62ad66fb860ebee" translate="yes" xml:space="preserve">
          <source>The program is a global object in which you can define types, methods and file-local variables.</source>
          <target state="translated">프로그램은 유형, 메소드 및 파일 로컬 변수를 정의 할 수있는 글로벌 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="d250f1a238217f17d5b9bf9fa4b3b314cfefb9d7" translate="yes" xml:space="preserve">
          <source>The program name used for log entries</source>
          <target state="translated">로그 항목에 사용되는 프로그램 이름</target>
        </trans-unit>
        <trans-unit id="410f4045bdc9aa8c631b549d702681603bdcd1db" translate="yes" xml:space="preserve">
          <source>The program&amp;rsquo;s source code must be encoded in UTF-8.</source>
          <target state="translated">프로그램의 소스 코드는 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2b5672b6507164d54702ad6643e33f901bb8b66" translate="yes" xml:space="preserve">
          <source>The properties can be type declarations or assignments.</source>
          <target state="translated">속성은 형식 선언 또는 할당 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41aac7aa54673bdaa8c5b39c8053f16352cd59e1" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;is_a?&lt;/code&gt; determines whether an expression's runtime type inherits or includes another type. For example:</source>
          <target state="translated">의사 방법 &lt;code&gt;is_a?&lt;/code&gt; 식의 런타임 형식이 다른 형식을 상속하는지 또는 다른 형식을 포함하는지 여부를 결정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f507cd5dd906a5abf05bd1ee75a2fac5c1c15a6" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;nil?&lt;/code&gt; determines whether an expression's runtime type is &lt;code&gt;Nil&lt;/code&gt;. For example:</source>
          <target state="translated">의사 방법은 &lt;code&gt;nil?&lt;/code&gt; 표현식의 런타임 유형이 &lt;code&gt;Nil&lt;/code&gt; 인지 여부를 판별합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="932b82bb016d54d7c862b35543ed93ac64fae6f3" translate="yes" xml:space="preserve">
          <source>The pseudo-method &lt;code&gt;responds_to?&lt;/code&gt; determines whether a type has a method with the given name. For example:</source>
          <target state="translated">의사 방법이 &lt;code&gt;responds_to?&lt;/code&gt; 유형에 주어진 이름의 메소드가 있는지 판별합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f110f55fd959c5e5afa44c1cdba8507d00eed545" translate="yes" xml:space="preserve">
          <source>The purpose of using base64 to encode data is that it translates any binary data into purely printable characters.</source>
          <target state="translated">base64를 사용하여 데이터를 인코딩하는 목적은 이진 데이터를 순전히 인쇄 가능한 문자로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="20db04bff4ecb2dbf646dff1c64a3b517788a585" translate="yes" xml:space="preserve">
          <source>The radix or integer base used by the internal representation</source>
          <target state="translated">내부 표현에 사용되는 기수 또는 정수 기수</target>
        </trans-unit>
        <trans-unit id="b879630d8049f81a21f22cfc58e5f4bc5cb9d8da" translate="yes" xml:space="preserve">
          <source>The range operators are used in &lt;a href=&quot;literals/range&quot;&gt;Range&lt;/a&gt; literals.</source>
          <target state="translated">범위 연산자는 &lt;a href=&quot;literals/range&quot;&gt;범위&lt;/a&gt; 리터럴 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d428f13bac087ac4e3400df32671a4193fd24329" translate="yes" xml:space="preserve">
          <source>The raw file-descriptor.</source>
          <target state="translated">원시 파일 디스크립터</target>
        </trans-unit>
        <trans-unit id="b778b37dfbc8f3ee7e3ed2bdf2dd7305706404db" translate="yes" xml:space="preserve">
          <source>The raw file-descriptor. It is defined to be an &lt;code&gt;&lt;a href=&quot;../int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, but its size is platform-specific.</source>
          <target state="translated">원시 파일 디스크립터 &lt;code&gt;&lt;a href=&quot;../int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 정의 되었지만 크기는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8db9410acd7129114bee57055d831caef51f8eca" translate="yes" xml:space="preserve">
          <source>The real reason the compiler does this is to be able to compile programs faster by not creating all kinds of different similar unions, also making the generated code smaller in size. But, on the other hand, it makes sense: classes under the same hierarchy should behave in a similar way.</source>
          <target state="translated">컴파일러가이를 수행하는 실제 이유는 모든 종류의 서로 다른 유사한 공용체를 만들지 않고 생성 된 코드의 크기를 더 작게 만들어 프로그램을 더 빠르게 컴파일 할 수 있기 때문입니다. 그러나 반면에 동일한 계층 구조의 클래스는 비슷한 방식으로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="76a389bb689114456985a25fbbce6ca4de3e5f74" translate="yes" xml:space="preserve">
          <source>The reason for allowing strings that don't have a valid UTF-8 sequence is that the world is full of content that isn't properly encoded, and having a program raise an exception or stop because of this is not good. It's better if programs are more resilient, but show a replacement character when there's an error in incoming data.</source>
          <target state="translated">유효한 UTF-8 시퀀스가없는 문자열을 허용하는 이유는 세계가 올바르게 인코딩되지 않은 내용으로 가득 차 있고 프로그램으로 인해 예외가 발생하거나 중지되어 좋지 않기 때문입니다. 프로그램이보다 탄력적이지만 수신 데이터에 오류가있는 경우 대체 문자를 표시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32f40650fb7ccf8892e0237620999a8152370e25" translate="yes" xml:space="preserve">
          <source>The reason for this is that a fiber is not executed as soon as it is spawned. So, the main fiber, the one that spawns the above fiber, finishes its execution and the program exits.</source>
          <target state="translated">그 이유는 파이버가 생성 되 자마자 실행되지 않기 때문입니다. 따라서 위의 광섬유를 생성하는 주 광섬유는 실행을 마치고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ff10dcb440a08b16e31eefc8ffaede37d73590f0" translate="yes" xml:space="preserve">
          <source>The reason for this is to allow creating Domain Specific Languages (DSLs) using &lt;code&gt;do ... end&lt;/code&gt; to have them be read as plain English:</source>
          <target state="translated">그 이유는 &lt;code&gt;do ... end&lt;/code&gt; 를 사용하여 DSL (Domain Specific Languages)을 작성하여 일반 영어로 읽을 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d78935ddfd4649c6aa2826ace20fab5bbc112bc0" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;socket.gets&lt;/code&gt; and &lt;code&gt;sleep&lt;/code&gt; behave like this is because their implementations talk directly with the Runtime Scheduler and the Event Loop, there's nothing magical about it. In general, the standard library already takes care of doing all of this so you don't have to.</source>
          <target state="translated">이유 &lt;code&gt;socket.gets&lt;/code&gt; 및 &lt;code&gt;sleep&lt;/code&gt; 자신의 구현 런타임 스케줄러 및 이벤트 루프와 직접 대화하기 때문에이처럼 행동은 그것에 대해 아무것도 마법이있다. 일반적으로 표준 라이브러리는 이미이 모든 작업을 수행하므로 사용자는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="574c2ce94e0fe34bb694689f6855ce71540ac54a" translate="yes" xml:space="preserve">
          <source>The receiver can't be anything else than a variable or call.</source>
          <target state="translated">수신자는 변수 또는 호출 이외의 것이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="871034b7273a5a75ceafcc5e70590aba4b1c957a" translate="yes" xml:space="preserve">
          <source>The recommended thing to do is to use enums whenever possible, only use symbols for the internal implementation of an API, and avoid symbols for public APIs. But you are free to do what you want.</source>
          <target state="translated">권장되는 것은 가능할 때마다 열거 형을 사용하고 API의 내부 구현에 기호 만 사용하고 공용 API에 대한 기호는 사용하지 않는 것입니다. 그러나 원하는 것을 자유롭게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87e3477255e26528fbd308bbff78570c498d50ce" translate="yes" xml:space="preserve">
          <source>The reentrant protection maintains a lock count. Attempting to re-lock the mutex from the same fiber will increment the lock count. Attempting to unlock the counter from the same fiber will decrement the lock count, eventually releasing the lock when the lock count returns to 0. Attempting to unlock an unlocked mutex, or a mutex locked by another fiber will raise an exception.</source>
          <target state="translated">재진입 보호는 잠금 수를 유지합니다. 동일한 광섬유에서 뮤텍스를 다시 잠그려고하면 잠금 수가 증가합니다. 동일한 파이버에서 카운터를 잠금 해제하려고하면 잠금 카운트가 감소하고 결국 잠금 카운트가 0으로 돌아 오면 잠금이 해제됩니다. 잠금 해제 된 뮤텍스를 잠금 해제하려고 시도하거나 다른 파이버에 의해 잠긴 뮤텍스가 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ed914447670b399ebc6cc6e220541dba265b2d70" translate="yes" xml:space="preserve">
          <source>The registry will be populated with some default values (see &lt;code&gt;&lt;a href=&quot;mime#DEFAULT_TYPES&quot;&gt;DEFAULT_TYPES&lt;/a&gt;&lt;/code&gt;) as well as the operating system's MIME database.</source>
          <target state="translated">레지스트리 에는 운영 체제의 MIME 데이터베이스뿐만 아니라 일부 기본값 ( &lt;code&gt;&lt;a href=&quot;mime#DEFAULT_TYPES&quot;&gt;DEFAULT_TYPES&lt;/a&gt;&lt;/code&gt; 참조 ) 이 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="4b847bda892ee576c2c6d6db160250aaf567ab70" translate="yes" xml:space="preserve">
          <source>The regular expression language can be used to match much more than just the static substrings in the above examples. Certain characters, called &lt;a href=&quot;http://www.pcre.org/original/doc/html/pcrepattern.html#SEC4&quot;&gt;metacharacters&lt;/a&gt;, are given special treatment in regular expressions, and can be used to describe more complex patterns. To match metacharacters literally in a regular expression, they must be escaped by being preceded with a backslash (&lt;code&gt;\&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;regex#escape(str):String-class-method&quot;&gt;.escape&lt;/a&gt;&lt;/code&gt; will do this automatically for a given String.</source>
          <target state="translated">정규 표현식 언어는 위의 예제에서 정적 하위 문자열보다 훨씬 더 일치하는 데 사용될 수 있습니다. &lt;a href=&quot;http://www.pcre.org/original/doc/html/pcrepattern.html#SEC4&quot;&gt;metacharacters&lt;/a&gt; 라는 특정 문자 는 정규식으로 특수 처리되며보다 복잡한 패턴을 설명하는 데 사용될 수 있습니다. 정규식에서 메타 문자를 문자 그대로 일치 시키려면 앞에 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )를 붙여서 이스케이프해야합니다 . &lt;code&gt;&lt;a href=&quot;regex#escape(str):String-class-method&quot;&gt;.escape&lt;/a&gt;&lt;/code&gt; 는 주어진 문자열에 대해 자동 으로이 작업 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e24cf27decc46c3ee89d81610dfaa54465672459" translate="yes" xml:space="preserve">
          <source>The replacement character, used on invalid UTF-8 byte sequences.</source>
          <target state="translated">잘못된 UTF-8 바이트 시퀀스에서 사용되는 대체 문자입니다.</target>
        </trans-unit>
        <trans-unit id="d1b8275b80e6086dd1f4f8d0cc0a9b6f3288eaa7" translate="yes" xml:space="preserve">
          <source>The request line is the first line of a request, consisting of method, resource and HTTP version and the delimiting line break. If the request line has a larger byte size than the permitted size, the server responds with the status code &lt;code&gt;414 &lt;a href=&quot;../uri&quot;&gt;URI&lt;/a&gt; Too Long&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;status#URI_TOO_LONG&quot;&gt;HTTP::Status::URI_TOO_LONG&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">요청 라인은 요청의 첫 번째 라인으로, 메소드, 자원 및 HTTP 버전 및 구분 된 줄 바꿈으로 구성됩니다. 요청 라인의 크기가 허용 된 크기보다 큰 경우, 서버는 상태 코드 &lt;code&gt;414 &lt;a href=&quot;../uri&quot;&gt;URI&lt;/a&gt; Too Long&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;status#URI_TOO_LONG&quot;&gt;HTTP::Status::URI_TOO_LONG&lt;/a&gt;&lt;/code&gt; ( HTTP :: Status :: URI_TOO_LONG 참조 ).</target>
        </trans-unit>
        <trans-unit id="e105b4ab54d3af5634616d46ec5b245306ef0d26" translate="yes" xml:space="preserve">
          <source>The request processor supports reusing a connection for subsequent requests. This is used by default for HTTP/1.1 or when requested by the &lt;code&gt;Connection: keep-alive&lt;/code&gt; header. This is signalled by this header being set on the &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; when it's passed into the handler chain.</source>
          <target state="translated">요청 프로세서는 후속 요청에 대한 연결 재사용을 지원합니다. 기본적으로 HTTP / 1.1 또는 &lt;code&gt;Connection: keep-alive&lt;/code&gt; 헤더 에서 요청할 때 사용됩니다 . 이것은 처리기 체인으로 전달 될 때이 헤더가 &lt;code&gt;&lt;a href=&quot;server/response&quot;&gt;HTTP::Server::Response&lt;/a&gt;&lt;/code&gt; 에 설정되어 있음을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="b88ba33ed5a8577d60c284544ff80c1a4e44897f" translate="yes" xml:space="preserve">
          <source>The response &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; must be configured before writing the response body. Once response output is written, changing the &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; properties has no effect.</source>
          <target state="translated">응답 본문을 작성하기 전에 응답 &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; 를 구성해야합니다. 응답 출력이 작성된 후에는 &lt;code&gt;&lt;a href=&quot;response#status:HTTP::Status-instance-method&quot;&gt;#status&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;response#headers:HTTP::Headers-instance-method&quot;&gt;#headers&lt;/a&gt;&lt;/code&gt; 속성을 변경해 도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="47dfc21a6b581b0ebea4ce9ed874b44dcdaf9b21" translate="yes" xml:space="preserve">
          <source>The response headers (&lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">응답 헤더 ( &lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ea18b79598116138833c1343a63330dce641f749" translate="yes" xml:space="preserve">
          <source>The response headers (&lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt;). These must be set before writing to the response.</source>
          <target state="translated">응답 헤더 ( &lt;code&gt;&lt;a href=&quot;../headers&quot;&gt;HTTP::Headers&lt;/a&gt;&lt;/code&gt; ) 응답에 쓰기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b8a7f07b6cad51f233e3cc0b531514a07faa6f1" translate="yes" xml:space="preserve">
          <source>The response to configure and write to in an &lt;code&gt;&lt;a href=&quot;../server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; handler.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server&quot;&gt;HTTP::Server&lt;/a&gt;&lt;/code&gt; 핸들러 에서 구성 및 쓰기에 대한 응답 입니다.</target>
        </trans-unit>
        <trans-unit id="8ea472b957543179abb9f5f5e9132e8059deb490" translate="yes" xml:space="preserve">
          <source>The result of naming this job &lt;code&gt;pages&lt;/code&gt; and putting our docs in the &lt;code&gt;public&lt;/code&gt; directory and specifying it as an &lt;code&gt;artifact&lt;/code&gt; is that GitLab will deploy the site in that directory to the default URL &lt;code&gt;https://&amp;lt;YOUR-GITLAB-USERNAME&amp;gt;.gitlab.io/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 작업 &lt;code&gt;pages&lt;/code&gt; 의 이름을 지정 하고 문서를 &lt;code&gt;public&lt;/code&gt; 디렉토리 에 넣고 &lt;code&gt;artifact&lt;/code&gt; 로 지정하면 GitLab이 해당 디렉토리의 사이트를 기본 URL &lt;code&gt;https://&amp;lt;YOUR-GITLAB-USERNAME&amp;gt;.gitlab.io/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e077049fc5824d3c9902b59488bdf5a911e88436" translate="yes" xml:space="preserve">
          <source>The result of the last expression is &lt;code&gt;2&lt;/code&gt; because the last expression of the &lt;code&gt;transform&lt;/code&gt; method is &lt;code&gt;yield&lt;/code&gt;, whose value is the last expression of the block.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; 메소드 의 마지막 표현식 은 &lt;code&gt;yield&lt;/code&gt; 이므로 값은 블록 의 마지막 표현식이므로 마지막 표현식의 결과는 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="733d3c8c44e34a101276d18fb937671155352537" translate="yes" xml:space="preserve">
          <source>The result will be of the same type as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;self&lt;/code&gt; 와 동일한 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="5a1e8d996521c557bb0b6c523dcd3bbfc54c3cbb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; could be anything, even negative, if the computer's wall clock has changed between both calls.</source>
          <target state="translated">컴퓨터의 벽시계가 두 통화 사이에서 변경된 경우 결과 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; 은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1374f2a214fc29ec026b6560950190d2f27a5380" translate="yes" xml:space="preserve">
          <source>The retry logic only happens when the statement is sent through the &lt;code&gt;DB::Database&lt;/code&gt; . If it is sent through a &lt;code&gt;DB::Connection&lt;/code&gt; or &lt;code&gt;DB::Transaction&lt;/code&gt; no retry is performed since the code will state that certain connection object was expected to be used.</source>
          <target state="translated">재시도 로직은 명령문이 &lt;code&gt;DB::Database&lt;/code&gt; 통해 전송 될 때만 발생합니다 . &lt;code&gt;DB::Connection&lt;/code&gt; 또는 &lt;code&gt;DB::Transaction&lt;/code&gt; 통해 전송 된 경우 코드에서 특정 연결 개체가 사용될 것으로 예상되므로 다시 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8540bd690510195f15e7931fe703f354a5f3b1d" translate="yes" xml:space="preserve">
          <source>The return type (&lt;code&gt;R&lt;/code&gt;) is inferred from the proc's body.</source>
          <target state="translated">반환 유형 ( &lt;code&gt;R&lt;/code&gt; )은 proc의 본문에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="758c3df4fe5522cca716f4959d3984d4de00a83d" translate="yes" xml:space="preserve">
          <source>The return type always matches the supplied argument.</source>
          <target state="translated">반환 유형은 항상 제공된 인수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3448118a3edd919f25ef0f0dc09cb242f5fb6078" translate="yes" xml:space="preserve">
          <source>The return type follows the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">리턴 유형은 &lt;a href=&quot;type_grammar&quot;&gt;grammar&lt;/a&gt; 유형을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="d6e8f1d3f064b877d12e7e77276c1b261bc1301c" translate="yes" xml:space="preserve">
          <source>The return type is inferred from the proc's body.</source>
          <target state="translated">반환 유형은 proc의 본문에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="ba15146dddd3805e6aafd90ca92392fc02411153" translate="yes" xml:space="preserve">
          <source>The return value is URL encoded (see &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">반환 값은 URL로 인코딩됩니다 ( &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7ae265c92e23255384e92fcba0e93a3397ca8705" translate="yes" xml:space="preserve">
          <source>The return value is URL encoded (see &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">반환 값은 URL로 인코딩됩니다 ( &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;#encode_www_form&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a41b98c60f13bd33f50de5987af41c1bc1f24355" translate="yes" xml:space="preserve">
          <source>The returned bytes are only valid data until a next call to any method that reads from this IO is invoked.</source>
          <target state="translated">리턴 된 바이트는이 IO에서 읽는 메소드에 대한 다음 호출이 호출 될 때까지 유효한 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ca10f5bd23d19910cc3b5a5821662339a7fc01fd" translate="yes" xml:space="preserve">
          <source>The returned iterator keeps a reference to &lt;code&gt;self&lt;/code&gt;. If the array changes, the returned values of the iterator will change as well.</source>
          <target state="translated">리턴 된 반복자는 &lt;code&gt;self&lt;/code&gt; 에 대한 참조를 유지합니다 . 배열이 변경되면 이터레이터의 반환 값도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c163c2e4a8684eaec7ec7ef40e2ef6f82f70a679" translate="yes" xml:space="preserve">
          <source>The returned iterator keeps a reference to &lt;code&gt;self&lt;/code&gt;: if the array changes, the returned values of the iterator change as well.</source>
          <target state="translated">반환 된 반복자는 &lt;code&gt;self&lt;/code&gt; 에 대한 참조를 유지 합니다. 배열이 변경되면 반환 된 반복자의 값도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="eaaf8298a043e29b9f15d7afcbed3821bc33033d" translate="yes" xml:space="preserve">
          <source>The returned path ends in a slash only if it is the root (&lt;code&gt;&quot;/&quot;&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, or &lt;code&gt;C:\&lt;/code&gt;).</source>
          <target state="translated">반환 된 경로는 루트 ( &lt;code&gt;&quot;/&quot;&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; 또는 &lt;code&gt;C:\&lt;/code&gt; ) 인 경우에만 슬래시로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="246aef20e15ba401b3f48ea6131daf88f05508b9" translate="yes" xml:space="preserve">
          <source>The returned path is in normalized form.</source>
          <target state="translated">반환 된 경로는 정규화 된 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7ba84998e4083bf39c469e9128922bd4627ee050" translate="yes" xml:space="preserve">
          <source>The returned slice is read-only.</source>
          <target state="translated">반환 된 슬라이스는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="b0aa3484b0f403290cf3456d517f45e1f05be144" translate="yes" xml:space="preserve">
          <source>The returned value is either &lt;code&gt;28&lt;/code&gt;, &lt;code&gt;29&lt;/code&gt;, &lt;code&gt;30&lt;/code&gt; or &lt;code&gt;31&lt;/code&gt; depending on the month and whether &lt;em&gt;year&lt;/em&gt; is leap.</source>
          <target state="translated">반환되는 값은 월과 &lt;em&gt;연도&lt;/em&gt; 에 따라 &lt;code&gt;28&lt;/code&gt; , &lt;code&gt;29&lt;/code&gt; , &lt;code&gt;30&lt;/code&gt; 또는 &lt;code&gt;31&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60f43ae195a0414e9e0d780a03fd061aa5077ba3" translate="yes" xml:space="preserve">
          <source>The returned value is the memory address of this object.</source>
          <target state="translated">반환 값은이 객체의 메모리 주소입니다.</target>
        </trans-unit>
        <trans-unit id="817be2696fc8bda33f1d0dfcf9b344691071ceb3" translate="yes" xml:space="preserve">
          <source>The rollback place in the &lt;code&gt;outer_tx&lt;/code&gt; block, rolled back all the changes including the ones in the &lt;code&gt;inner_tx&lt;/code&gt; block (the same happens if we use an &lt;strong&gt;explicit&lt;/strong&gt; rollback).</source>
          <target state="translated">에서 롤백 장소 &lt;code&gt;outer_tx&lt;/code&gt; 블록은 다시 모든에있는 사람을 포함하여 변경 압연 &lt;code&gt;inner_tx&lt;/code&gt; 블록 (우리가 사용하는 경우 같은 일이 발생 &lt;strong&gt;명시 적&lt;/strong&gt; 롤백).</target>
        </trans-unit>
        <trans-unit id="4aaf57eeda40665f5d6ffd28fb9d4804a63cc6dc" translate="yes" xml:space="preserve">
          <source>The rules are many, but usually the first three are most used. There's no need to remember them all. If the compiler gives an error saying that the type of an instance variable can't be inferred you can always add an explicit type restriction.</source>
          <target state="translated">규칙은 많지만 일반적으로 처음 세 가지가 가장 많이 사용됩니다. 그것들을 모두 기억할 필요는 없습니다. 컴파일러가 인스턴스 변수의 유형을 유추 할 수 없다는 오류를 표시하면 항상 명시적인 유형 제한을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fbfc3c71a4a49bb24ab10244af977b1a02a7857" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;string#escaping&quot;&gt;escaping&lt;/a&gt; and &lt;a href=&quot;string#interpolation&quot;&gt;interpolation rules&lt;/a&gt; apply as for regular strings.</source>
          <target state="translated">일반 문자열 과 동일한 &lt;a href=&quot;string#escaping&quot;&gt;이스케이프&lt;/a&gt; 및 &lt;a href=&quot;string#interpolation&quot;&gt;보간 규칙이&lt;/a&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b5de9d90094355e321e66335957f0ad9d297b31" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;iterator#chain(other:Iterator(U))forallU-instance-method&quot;&gt;#chain&lt;/a&gt;&lt;/code&gt;, but have better performance when the quantity of iterators to chain is large (usually greater than 4) or undetermined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;iterator#chain(other:Iterator(U))forallU-instance-method&quot;&gt;#chain&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 체인에 반복기의 수가 많거나 (보통 4보다 큰) 결정되지 않은 경우 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a69615b60b24353d9e889ae458216733c9db37" translate="yes" xml:space="preserve">
          <source>The same happens if a &lt;code&gt;DB::Rollback&lt;/code&gt; exception is raised in the &lt;code&gt;inner-transaction&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;inner-transaction&lt;/code&gt; 블록 에서 &lt;code&gt;DB::Rollback&lt;/code&gt; 예외가 발생 하는 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="aa6a16ecf1926d76b19dc30a2621c84ff610a5f5" translate="yes" xml:space="preserve">
          <source>The scheduler has a queue of:</source>
          <target state="translated">스케줄러의 대기열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5faa60b79497768401699ecbc6952402943aa59" translate="yes" xml:space="preserve">
          <source>The second point has a reason to it: a struct has a very well defined memory layout. For example, the above &lt;code&gt;Point&lt;/code&gt; struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer:</source>
          <target state="translated">두 번째 요점은 그 이유가 있습니다. 구조체에는 매우 잘 정의 된 메모리 레이아웃이 있습니다. 예를 들어, 위의 &lt;code&gt;Point&lt;/code&gt; 구조체는 8 바이트를 차지합니다. 포인트 배열이있는 경우 해당 포인트는 배열의 버퍼 안에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="58837c746502875a30ca81ecee4f35665f085248" translate="yes" xml:space="preserve">
          <source>The second rule means that in addition to having this:</source>
          <target state="translated">두 번째 규칙은 다음과 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="280264e5f00aefda967a507dcc2d0993a8f297f0" translate="yes" xml:space="preserve">
          <source>The second use case is making a method argument more readable inside a method body:</source>
          <target state="translated">두 번째 사용 사례는 메소드 본문 내에서 메소드 인수를 더 읽기 쉽게 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7815aa7b63e5cf450e5da058b4fe88113046ac95" translate="yes" xml:space="preserve">
          <source>The server can be bound to one ore more server sockets (see &lt;code&gt;&lt;a href=&quot;server#bind(socket:Socket::Server):Nil-instance-method&quot;&gt;#bind&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">서버는 하나 이상의 서버 소켓에 바인딩 될 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;server#bind(socket:Socket::Server):Nil-instance-method&quot;&gt;#bind&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3c269eabfaf8d5876dd6cce873c27fe43e504a55" translate="yes" xml:space="preserve">
          <source>The server is closed after the block returns.</source>
          <target state="translated">블록이 반환 된 후 서버가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8e2c928c628330386116b324976d603f532b3d1e" translate="yes" xml:space="preserve">
          <source>The server is of stream type by default, but this can be changed for another type. For example datagram messages:</source>
          <target state="translated">서버는 기본적으로 스트림 유형이지만 다른 유형으로 변경할 수 있습니다. 예를 들어 데이터 그램 메시지 :</target>
        </trans-unit>
        <trans-unit id="1d8d131af24fedcb05379bb424565311ccabb7b4" translate="yes" xml:space="preserve">
          <source>The set of possible valid body types.</source>
          <target state="translated">가능한 유효한 신체 유형 세트.</target>
        </trans-unit>
        <trans-unit id="e0a0f26cd8826d6609eb76ff98b7304117eb9322" translate="yes" xml:space="preserve">
          <source>The shards command</source>
          <target state="translated">샤드 명령</target>
        </trans-unit>
        <trans-unit id="d360149d4d7970bf59a8f5f65d6616a53b982bb0" translate="yes" xml:space="preserve">
          <source>The slice is allocated on the heap.</source>
          <target state="translated">슬라이스는 힙에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="6e9e1697b3dfa252df86406c37c107a81b41c91e" translate="yes" xml:space="preserve">
          <source>The source can be used to identify the module or part of the application that is logging. You can configure for each source a different level to filter the messages.</source>
          <target state="translated">소스는 로깅중인 애플리케이션의 일부 또는 모듈을 식별하는 데 사용할 수 있습니다. 각 소스에 대해 다른 수준을 구성하여 메시지를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a6e46f46717c7f49e7376a0bdbcc3ffb03b2720" translate="yes" xml:space="preserve">
          <source>The special flags this file has set.</source>
          <target state="translated">이 파일이 설정 한 특수 플래그.</target>
        </trans-unit>
        <trans-unit id="115ebf7822765608fcd39b3ed96add2129447699" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$?&lt;/code&gt; holds the exit status of the command as a &lt;a href=&quot;https://crystal-lang.org/api/0.27.0/Process/Status.html&quot;&gt;&lt;code&gt;Process::Status&lt;/code&gt;&lt;/a&gt;. It is only available in the same scope as the command literal.</source>
          <target state="translated">특수 변수 &lt;code&gt;$?&lt;/code&gt; 명령의 종료 상태를 &lt;a href=&quot;https://crystal-lang.org/api/0.27.0/Process/Status.html&quot;&gt; &lt;code&gt;Process::Status&lt;/code&gt; &lt;/a&gt; 로 보유합니다 . 명령 리터럴과 동일한 범위에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e3557d004003192cd5542d3fc51ebf51e51916e" translate="yes" xml:space="preserve">
          <source>The splat argument can also be left unnamed, with the meaning &quot;after this, named arguments follow&quot;:</source>
          <target state="translated">splat 인수는 &quot;이 뒤에 이름이 지정된 인수가옵니다&quot;라는 의미로 이름을 지정하지 않은 채로 둘 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1dc669a05db5c0342be9ec8b5a7d8be9bb1fd07" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; configuration of a process.</source>
          <target state="translated">프로세스 의 표준 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 구성</target>
        </trans-unit>
        <trans-unit id="06ccce70ab599789110874bf990f283bccb902c9" translate="yes" xml:space="preserve">
          <source>The standard error file descriptor.</source>
          <target state="translated">표준 오류 파일 설명자</target>
        </trans-unit>
        <trans-unit id="ed95cff6c55ece7cd2f7db46939b98071cc0bd1d" translate="yes" xml:space="preserve">
          <source>The standard input file descriptor. Contains data piped to the program.</source>
          <target state="translated">표준 입력 파일 설명자 프로그램으로 파이프 된 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0647c890a1da53d6297b74b407afd68f13114f12" translate="yes" xml:space="preserve">
          <source>The standard library defines the &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr&quot;&gt;LibC&lt;/a&gt; lib with aliases for common C types, like &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;size_t&lt;/code&gt;. Use them in bindings like this:</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;size_t&lt;/code&gt; 와 같은 일반적인 C 유형에 대한 별명으로 &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr&quot;&gt;LibC&lt;/a&gt; 라이브러리를 정의합니다 . 다음과 같이 바인딩에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b7487ca8fa2486d67a8aee18fce65b6a02c53afb" translate="yes" xml:space="preserve">
          <source>The standard library provides a useful &lt;code&gt;&lt;a href=&quot;toplevel#record(name,*properties)-macro&quot;&gt;record&lt;/a&gt;&lt;/code&gt; macro that allows you to create immutable structs with some fields, similar to a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;&lt;/code&gt; but using names instead of indices.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 인덱스 대신 이름을 사용하여 일부 필드로 불변 구조체를 만들 수 있는 유용한 &lt;code&gt;&lt;a href=&quot;toplevel#record(name,*properties)-macro&quot;&gt;record&lt;/a&gt;&lt;/code&gt; 매크로를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9ad70d1504d698d2fa851744f3b13ca5f52cdae4" translate="yes" xml:space="preserve">
          <source>The standard library provides iterators for many classes, like &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. Usually to get an iterator you invoke a method that would usually yield elements to a block, but without passing a block: &lt;code&gt;Array#each&lt;/code&gt;, &lt;code&gt;Array#each_index&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash#each(&amp;amp;block):Nil-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 와 같은 많은 클래스에 반복자를 제공합니다 . 일반적으로 반복자를 얻으려면 일반적으로 블록에 요소를 생성하지만 블록을 전달하지 않는 메소드를 호출합니다. &lt;code&gt;Array#each&lt;/code&gt; , &lt;code&gt;Array#each_index&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;hash#each(&amp;amp;block):Nil-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="57c7d853af4150be9eafe1bc5efbbf1b8a0b9b22" translate="yes" xml:space="preserve">
          <source>The standard library provides iterators for many classes, like &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. Usually to get an iterator you invoke a method that would usually yield elements to a block, but without passing a block: &lt;code&gt;Array#each&lt;/code&gt;, &lt;code&gt;Array#each_index&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;hash#each-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 와 같은 많은 클래스에 대한 반복자를 제공합니다 . 일반적으로 반복자를 얻으려면 일반적으로 블록에 요소를 생성하지만 블록을 전달하지 않는 메서드를 호출합니다 : &lt;code&gt;Array#each&lt;/code&gt; , &lt;code&gt;Array#each_index&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;hash#each-instance-method&quot;&gt;Hash#each&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;string#each_char-instance-method&quot;&gt;String#each_char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#each_line(*args,**options,&amp;amp;block:String-%3E):Nil-instance-method&quot;&gt;IO#each_line&lt;/a&gt;&lt;/code&gt; 등.</target>
        </trans-unit>
        <trans-unit id="f60661aded41cff7237ed66bcbec411c36098f17" translate="yes" xml:space="preserve">
          <source>The standard library usually provides a couple of methods to accomplish something: one raises, one returns &lt;code&gt;nil&lt;/code&gt;. For example:</source>
          <target state="translated">표준 라이브러리는 일반적으로 무언가를 달성하기위한 몇 가지 메소드를 제공합니다. 하나는 올리고, 하나는 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="515a59cec9777bfc48a2ecc2cc13aa8b380be2d0" translate="yes" xml:space="preserve">
          <source>The standard output file descriptor.</source>
          <target state="translated">표준 출력 파일 디스크립터</target>
        </trans-unit>
        <trans-unit id="85ba3435f5bade942bd58c3feaaf3b56970c4fd2" translate="yes" xml:space="preserve">
          <source>The status code of this response, which must be set before writing the response body.</source>
          <target state="translated">응답 본문을 작성하기 전에 설정해야하는이 응답의 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c59be19bf92d9ab26cce394a18e174fd9a969f08" translate="yes" xml:space="preserve">
          <source>The status code of this response, which must be set before writing the response body. If not set, the default value is 200 (OK).</source>
          <target state="translated">응답 본문을 작성하기 전에 설정해야하는이 응답의 상태 코드입니다. 설정하지 않으면 기본값은 200 (확인)입니다.</target>
        </trans-unit>
        <trans-unit id="3a11fe500e3f850f00e6cd9e0bba9dd68f20ab69" translate="yes" xml:space="preserve">
          <source>The status of a terminated process.</source>
          <target state="translated">종료 된 프로세스의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="8692cd6c1e460d8d56975cc9b8b1ff056ccf3461" translate="yes" xml:space="preserve">
          <source>The status of a terminated process. Returned by &lt;code&gt;&lt;a href=&quot;../process#wait:Process::Status-instance-method&quot;&gt;Process#wait&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종료 된 프로세스의 상태입니다. &lt;code&gt;&lt;a href=&quot;../process#wait:Process::Status-instance-method&quot;&gt;Process#wait&lt;/a&gt;&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">문자열 값</target>
        </trans-unit>
        <trans-unit id="abd29b3ac753265d0c8451b4c56af4a5829cf90f" translate="yes" xml:space="preserve">
          <source>The string value. Only makes sense for a &lt;code&gt;Cell&lt;/code&gt;.</source>
          <target state="translated">문자열 값 &lt;code&gt;Cell&lt;/code&gt; 에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef8dbcb6094fea728ae1348a427a648823eaecf" translate="yes" xml:space="preserve">
          <source>The style of this scalar.</source>
          <target state="translated">이 스칼라의 스타일.</target>
        </trans-unit>
        <trans-unit id="61ed4a1fd638ad01f7858319d3a71c8d51e79551" translate="yes" xml:space="preserve">
          <source>The style of this sequence.</source>
          <target state="translated">이 순서의 스타일.</target>
        </trans-unit>
        <trans-unit id="5b14384994a6a3814e57411408f7f21ea58ef302" translate="yes" xml:space="preserve">
          <source>The supported date range is &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; to &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; in any local time zone.</source>
          <target state="translated">지원되는 날짜 범위는 현지 시간대 로 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; ~ &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4503a73f7c127c408ab781d1b0fac75a8017a56c" translate="yes" xml:space="preserve">
          <source>The supported flag keywords are:</source>
          <target state="translated">지원되는 플래그 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e218ceebba6ea54e2006ba0c7c6e7def70ac615" translate="yes" xml:space="preserve">
          <source>The syntax for a format specifier is:</source>
          <target state="translated">형식 지정자의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0021c19912d1e999084687b97057bfc0b4788f8" translate="yes" xml:space="preserve">
          <source>The tags defined on this example or example group</source>
          <target state="translated">이 예제 또는 예제 그룹에 정의 된 태그</target>
        </trans-unit>
        <trans-unit id="55bd38b7daa1bdf9cc8a6ed62f94bd5f0ddb042f" translate="yes" xml:space="preserve">
          <source>The techniques described above for instance variables will also work for proc and method calls.</source>
          <target state="translated">예를 들어 변수에 대해 위에서 설명한 기술은 proc 및 메소드 호출에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a5f08511b105744daa389a7297da93cef97ae79c" translate="yes" xml:space="preserve">
          <source>The ternary &lt;code&gt;if&lt;/code&gt; allows writing an &lt;code&gt;if&lt;/code&gt; in a shorter way:</source>
          <target state="translated">삼항 &lt;code&gt;if&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 를 더 짧은 방식으로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bd92a9a3ced6519c7c84778a4996693c92e674e" translate="yes" xml:space="preserve">
          <source>The test is performed by the block supplied to &lt;em&gt;&amp;amp;block&lt;/em&gt;.</source>
          <target state="translated">테스트는 &lt;em&gt;&amp;amp; block에&lt;/em&gt; 공급 된 블록에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3496448917ada5aa324a728463e698336aac5477" translate="yes" xml:space="preserve">
          <source>The test stage of the pipeline will either pass (each element of the array returned a healthy exit code) or it will fail (one of the elements returned an error).</source>
          <target state="translated">파이프 라인의 테스트 단계는 통과하거나 (배열의 각 요소가 정상 종료 코드를 반환 함) 실패합니다 (요소 중 하나가 오류를 반환 함).</target>
        </trans-unit>
        <trans-unit id="30e4b606f413274e66088db5b0b29adc0fbe5ce6" translate="yes" xml:space="preserve">
          <source>The third rule is very convenient because of the typical directory structure of a project:</source>
          <target state="translated">세 번째 규칙은 프로젝트의 일반적인 디렉토리 구조로 인해 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a8fa55a537511eec3a9b51c9a830cf74f0aa2604" translate="yes" xml:space="preserve">
          <source>The time span is negative if &lt;code&gt;self&lt;/code&gt; is before &lt;em&gt;other&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;em&gt;다른&lt;/em&gt; 것보다 앞에 있으면 시간 범위가 음수 입니다.</target>
        </trans-unit>
        <trans-unit id="741a69c6248954ce047ac81f471742b0273d79f3" translate="yes" xml:space="preserve">
          <source>The time zone is always UTC.</source>
          <target state="translated">시간대는 항상 UTC입니다.</target>
        </trans-unit>
        <trans-unit id="cebb87b4a01c495d99b26ca4cb0c3f1e5a6a37dd" translate="yes" xml:space="preserve">
          <source>The time-of-day can be omitted and defaults to midnight (start of day):</source>
          <target state="translated">시간은 생략 할 수 있으며 기본적으로 자정 (시작)으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64ebdf1f1b3c564f37485bf9df3d06ef472ab0fb" translate="yes" xml:space="preserve">
          <source>The top-level number type.</source>
          <target state="translated">최상위 숫자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1b33f83ef6cfe3aff507232296b953456b923ac8" translate="yes" xml:space="preserve">
          <source>The type after the &lt;code&gt;uninitialized&lt;/code&gt; keyword follows the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">애프터 유형 &lt;code&gt;uninitialized&lt;/code&gt; 키워드는 다음 &lt;a href=&quot;type_grammar&quot;&gt;유형의 문법을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15070dd3707e9d802a1fc0d25b1367c6f1003eef" translate="yes" xml:space="preserve">
          <source>The type arguments can be explicitly specified as part of the type name:</source>
          <target state="translated">형식 인수는 형식 이름의 일부로 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c4c08c93b67fc8ff8e11b395e7bcf85287380e" translate="yes" xml:space="preserve">
          <source>The type declaration can also include an initial value:</source>
          <target state="translated">형식 선언에는 초기 값도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6319b04ab143b210e9d97f792b86ed20bfe9f3d5" translate="yes" xml:space="preserve">
          <source>The type is not obvious for a human reading the code: they would also have to check all uses of &lt;code&gt;Person&lt;/code&gt; to find this out.</source>
          <target state="translated">이 코드는 사람이 코드를 읽는 데있어 분명하지 않습니다. 또한이 코드 를 찾으려면 &lt;code&gt;Person&lt;/code&gt; 의 모든 사용을 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="108c562214c93f386be1f162f0a0650b00bb7835" translate="yes" xml:space="preserve">
          <source>The type of a proc or block argument, like &lt;code&gt;&lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; -&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; -&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 와 같은 proc 또는 block 인수의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2c42ac6401595769255c826b0b78eead029847e3" translate="yes" xml:space="preserve">
          <source>The type of a variable after a &lt;code&gt;while&lt;/code&gt; depends on the type it had before the &lt;code&gt;while&lt;/code&gt; and the type it had before leaving the &lt;code&gt;while&lt;/code&gt;'s body:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 후 변수 의 유형은 &lt;code&gt;while&lt;/code&gt; 이전 의 유형과 &lt;code&gt;while&lt;/code&gt; 의 본문을 떠나기 전의 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="259c38c35a5373fad42e97eeb369785d902a0de1" translate="yes" xml:space="preserve">
          <source>The type of a variable or expression can consist of multiple types. This is called a union type. For example, when assigning to a same variable inside different &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; branches:</source>
          <target state="translated">변수 또는 표현식의 유형은 여러 유형으로 구성 될 수 있습니다. 이것을 유니온 타입이라고합니다. 예를 들어 분기가 다른 &lt;a href=&quot;if&quot;&gt;경우&lt;/a&gt; 동일한 변수에 지정할 때 :</target>
        </trans-unit>
        <trans-unit id="857e9dd350d838b33e88e5bbd6617c80d3f3dee6" translate="yes" xml:space="preserve">
          <source>The type of an enum member is &lt;code&gt;Int32&lt;/code&gt; by default, even if you specify a different type in a constant value:</source>
          <target state="translated">상수 값에 다른 유형을 지정하더라도 열거 형 멤버의 유형은 기본적으로 &lt;code&gt;Int32&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="22138fae9fc7f0f887fdce6335e5ef6cec7cbfa5" translate="yes" xml:space="preserve">
          <source>The type of the block in a method that uses &lt;code&gt;yield&lt;/code&gt; can be restricted using the &lt;code&gt;&amp;amp;block&lt;/code&gt; syntax. For example:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 를 사용하는 메소드의 블록 유형은 &lt;code&gt;&amp;amp;block&lt;/code&gt; 구문을 사용하여 제한 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb4be47d081c9f00e1e008293842739b1e591c97" translate="yes" xml:space="preserve">
          <source>The type of the file.</source>
          <target state="translated">파일의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f81c742ee16652716e8606c185384a6c25c4887b" translate="yes" xml:space="preserve">
          <source>The type of the literal: &lt;code&gt;:i32&lt;/code&gt;, &lt;code&gt;:u16&lt;/code&gt;, &lt;code&gt;:f32&lt;/code&gt;, &lt;code&gt;:f64&lt;/code&gt;, etc.</source>
          <target state="translated">리터럴의 유형 : &lt;code&gt;:i32&lt;/code&gt; , &lt;code&gt;:u16&lt;/code&gt; , &lt;code&gt;:f32&lt;/code&gt; , &lt;code&gt;:f64&lt;/code&gt; f64 등</target>
        </trans-unit>
        <trans-unit id="7aae3e7ec12ca924c59121098a0fb5438695876c" translate="yes" xml:space="preserve">
          <source>The type of the value is &lt;code&gt;Int32&lt;/code&gt; by default but can be changed:</source>
          <target state="translated">값의 유형은 기본적으로 &lt;code&gt;Int32&lt;/code&gt; 이지만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07407b35ba208a8a320f5b6e55c3b67f2dcba23e" translate="yes" xml:space="preserve">
          <source>The type of this expression is restricted to &lt;em&gt;type&lt;/em&gt; by the compiler. &lt;em&gt;type&lt;/em&gt; must be a constant or &lt;code&gt;typeof()&lt;/code&gt; expression. It cannot be evaluated at runtime.</source>
          <target state="translated">이 표현식의 유형은 컴파일러에 의해 &lt;em&gt;유형&lt;/em&gt; 으로 제한됩니다 . &lt;em&gt;type&lt;/em&gt; 은 상수 또는 &lt;code&gt;typeof()&lt;/code&gt; 표현식 이어야합니다 . 런타임에 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe7ab94d37aed65c7576f1ca405c59ffc8aee667" translate="yes" xml:space="preserve">
          <source>The type of this expression is restricted to &lt;em&gt;type&lt;/em&gt; by the compiler. If &lt;em&gt;type&lt;/em&gt; is not a valid type restriction for the expression type, then it is restricted to &lt;code&gt;&lt;a href=&quot;nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;type&lt;/em&gt; must be a constant or &lt;code&gt;typeof()&lt;/code&gt; expression. It cannot be evaluated at runtime.</source>
          <target state="translated">이 표현식의 유형은 컴파일러에 의해 &lt;em&gt;유형&lt;/em&gt; 으로 제한됩니다 . &lt;em&gt;type&lt;/em&gt; 이 표현식 유형에 대해 유효한 유형 제한이 아닌 경우 &lt;code&gt;&lt;a href=&quot;nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; 로 제한됩니다 . &lt;em&gt;type&lt;/em&gt; 은 상수 또는 &lt;code&gt;typeof()&lt;/code&gt; 표현식 이어야합니다 . 런타임에 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d710c89f96aa8fa61f94c283654a65cfc9df9fb9" translate="yes" xml:space="preserve">
          <source>The type restrictions applied to arguments</source>
          <target state="translated">인수에 적용되는 유형 제한</target>
        </trans-unit>
        <trans-unit id="781e05338a9f46dedea33ad16c1f22747e5115a6" translate="yes" xml:space="preserve">
          <source>The types of the arguments (&lt;code&gt;T&lt;/code&gt;) are mandatory, except when directly sending a proc literal to a lib fun in C bindings.</source>
          <target state="translated">C 바인딩의 lib fun에 proc 리터럴을 직접 보내는 경우를 제외하고 인수 유형 ( &lt;code&gt;T&lt;/code&gt; )은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="754e54b54ea2a8a8e371a7eb0db016dac368170a" translate="yes" xml:space="preserve">
          <source>The types of the arguments are mandatory, except when directly sending a proc literal to a lib &lt;code&gt;fun&lt;/code&gt; in C bindings.</source>
          <target state="translated">C 바인딩에서 proc 리터럴을 lib &lt;code&gt;fun&lt;/code&gt; 에 직접 보낼 때를 제외하고 인수의 유형은 필수 입니다.</target>
        </trans-unit>
        <trans-unit id="ba85644bef24b13fb47d42733d7413b1308f1b35" translate="yes" xml:space="preserve">
          <source>The typical time representation provided by the operating system is based on a &quot;wall clock&quot; which is subject to changes for clock synchronization. This can result in discontinuous jumps in the time-line making it not suitable for accurately measuring elapsed time.</source>
          <target state="translated">운영 체제에서 제공하는 일반적인 시간 표현은 &quot;월 클록&quot;을 기반으로하며 클록 동기화를 위해 변경 될 수 있습니다. 이로 인해 타임 라인에서 불연속 점프가 발생하여 경과 시간을 정확하게 측정하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f96074085125d1425fe1b8d9419c01d3ff9fddb" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; before the suffix is optional.</source>
          <target state="translated">접미사 앞 의 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="067ddac2edd17a7efd366d05bd39d5795ee39b9c" translate="yes" xml:space="preserve">
          <source>The union of two named tuples with the same keys (regardless of their order) results in a named tuple type that has the union of the types in each key. The order of the keys will be the ones from the tuple on the left hand side.</source>
          <target state="translated">순서에 관계없이 동일한 키를 가진 두 개의 명명 된 튜플을 통합하면 각 키의 유형이 통합 된 명명 된 튜플 유형이 생성됩니다. 키의 순서는 왼쪽의 튜플에있는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="4f2e60460d67626b22b346567f965156512777d3" translate="yes" xml:space="preserve">
          <source>The union of two tuples of the same size results in a tuple type that has the union of the types in each position.</source>
          <target state="translated">동일한 크기의 두 개의 튜플의 합집합은 각 위치에서 유형의 합집합을 갖는 튜플 유형을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8afd92c5041f6e9ec4f4074058c75c942c73b7bb" translate="yes" xml:space="preserve">
          <source>The user ID of the file's owner.</source>
          <target state="translated">파일 소유자의 사용자 ID</target>
        </trans-unit>
        <trans-unit id="ef454f879d517fb81ee7f5054a2b34243db1f835" translate="yes" xml:space="preserve">
          <source>The user ID that the file belongs to.</source>
          <target state="translated">파일이 속한 사용자 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2b0c36a0d949f9008775425905192f1ed66ad726" translate="yes" xml:space="preserve">
          <source>The user's home directory.</source>
          <target state="translated">사용자의 홈 디렉토리</target>
        </trans-unit>
        <trans-unit id="69297ec8c8b14f2c05921e647c9fc36149e74468" translate="yes" xml:space="preserve">
          <source>The user's identifier.</source>
          <target state="translated">사용자의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="168516e5f12f280f75fdcbfbaef516955a0c5e4c" translate="yes" xml:space="preserve">
          <source>The user's login shell.</source>
          <target state="translated">사용자의 로그인 쉘.</target>
        </trans-unit>
        <trans-unit id="f398a07d224999258456b0de430a4e0072f6caf7" translate="yes" xml:space="preserve">
          <source>The user's primary group identifier.</source>
          <target state="translated">사용자의 기본 그룹 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="4ff9593149ef2ba9900fb804c6007eb3805c2cb2" translate="yes" xml:space="preserve">
          <source>The user's real or full name.</source>
          <target state="translated">사용자의 실명 또는 성명</target>
        </trans-unit>
        <trans-unit id="1ca94ead58af110ad6f863fda49b90f7d5569c70" translate="yes" xml:space="preserve">
          <source>The user's username.</source>
          <target state="translated">사용자의 사용자 이름</target>
        </trans-unit>
        <trans-unit id="b7ab44265ee3c1a2128b252ac0fbcaf236e9b12e" translate="yes" xml:space="preserve">
          <source>The usual convention is to provide an alternative &quot;question&quot; method to signal that this variant of the method returns &lt;code&gt;nil&lt;/code&gt; instead of raising. This lets the user choose whether she wants to deal with exceptions or with &lt;code&gt;nil&lt;/code&gt;. Note, however, that this is not available for every method out there, as exceptions are still the preferred way because they don't pollute the code with error handling logic.</source>
          <target state="translated">일반적인 규칙은이 방법의 변형이 발생 &lt;code&gt;nil&lt;/code&gt; 않고 nil 을 반환한다는 신호를 보내기 위해 대체 &quot;질문&quot;방법을 제공하는 것입니다. 이를 통해 사용자는 예외를 처리할지 또는 &lt;code&gt;nil&lt;/code&gt; 을 처리 할지를 선택할 수 있습니다 . 그러나 예외 처리는 오류 처리 로직으로 코드를 오염시키지 않기 때문에 여전히 선호되는 방법이므로 예외는 모든 방법에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="59ce3a47e8cc9701295cd89ed345c7526071cbbd" translate="yes" xml:space="preserve">
          <source>The valid types to use in C bindings are:</source>
          <target state="translated">C 바인딩에 사용할 수있는 유효한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a20a0d836d43b221dba43e371e3ece40ad64b317" translate="yes" xml:space="preserve">
          <source>The value assigned to the variable, if any.</source>
          <target state="translated">변수에 지정된 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="fcfa57e04fde68f0ab4098abfb5554b71327e65b" translate="yes" xml:space="preserve">
          <source>The value can also be another hash literal with the following options:</source>
          <target state="translated">다음 옵션을 사용하여 값을 다른 해시 리터럴로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="913440c9a45b0fb480154450d045729b273b2aef" translate="yes" xml:space="preserve">
          <source>The value can be changed to overwrite the system default:</source>
          <target state="translated">시스템 기본값을 덮어 쓰도록 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc06e0ddb6f726f165264966f85aba06f284c6aa" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;1&lt;/code&gt; 에 대한 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 에 대한 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf5b165e811f3256ead60c619f132cce199cb310" translate="yes" xml:space="preserve">
          <source>The value of an &lt;code&gt;if&lt;/code&gt; is the value of the last expression found in each of its branches:</source>
          <target state="translated">의 값 &lt;code&gt;if&lt;/code&gt; 마지막 식의 값이 그 가지의 각각에서 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5eed3fa4c0b1823d58a8c6bf72da684208a7433b" translate="yes" xml:space="preserve">
          <source>The value of each key can be a type. Primitive types (numbers, string, boolean and nil) are supported, as well as custom objects which use &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; or define a &lt;code&gt;new&lt;/code&gt; method that accepts a &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; and returns an object from it. Union types are supported, if multiple types in the union can be mapped from the JSON, it is undefined which one will be chosen.</source>
          <target state="translated">각 키의 값은 유형일 수 있습니다. 기본 유형 (숫자, 문자열, 부울 및 nil)과 &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; 을 사용하는 사용자 정의 객체뿐만 아니라 &lt;code&gt;&lt;a href=&quot;json/pullparser&quot;&gt;JSON::PullParser&lt;/a&gt;&lt;/code&gt; 를 허용하고 객체에서 객체를 반환하는 &lt;code&gt;new&lt;/code&gt; 메소드를 정의 하는 객체도 지원됩니다. 유니온 유형이 지원되며, 유니온의 여러 유형을 JSON에서 맵핑 할 수있는 경우 어떤 유형을 선택할지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d00003fd331dd99edd991c23f3a360f8d0b8a9c" translate="yes" xml:space="preserve">
          <source>The value of this scalar.</source>
          <target state="translated">이 스칼라의 값입니다.</target>
        </trans-unit>
        <trans-unit id="506a8109e608aea8ae4ab3b097dd3374dd8ab16e" translate="yes" xml:space="preserve">
          <source>The value range is &lt;code&gt;1..365&lt;/code&gt; in normal yars and &lt;code&gt;1..366&lt;/code&gt; in leap years.</source>
          <target state="translated">값 범위는 &lt;code&gt;1..365&lt;/code&gt; 정상 YARS 및 &lt;code&gt;1..366&lt;/code&gt; 윤년이다.</target>
        </trans-unit>
        <trans-unit id="737d355efb7ce1fb61687ce2dd59678f249b6230" translate="yes" xml:space="preserve">
          <source>The values of annotation key/value pairs can be accessed at compile time via the &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/Annotation.html#%5B%5D%28name%3ASymbolLiteral%7CStringLiteral%7CMacroId%29%3AASTNode-instance-method&quot;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주석 키 / 값 쌍의 값은 컴파일시 &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/Annotation.html#%5B%5D%28name%3ASymbolLiteral%7CStringLiteral%7CMacroId%29%3AASTNode-instance-method&quot;&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="069c7c9593f2e7c47e6a8c7723ea194ef1eba5fb" translate="yes" xml:space="preserve">
          <source>The version of the HTTP::Request that created this response.</source>
          <target state="translated">이 응답을 작성한 HTTP :: Request의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="22c5f3a3c46bff9cadece027c89e96d0529eb330" translate="yes" xml:space="preserve">
          <source>The warmup phase defaults to 2 seconds. During this stage we figure out how many cycles are needed to run the block for roughly 100ms, and record it.</source>
          <target state="translated">예열 단계의 기본값은 2 초입니다. 이 단계에서 약 100ms 동안 블록을 실행하는 데 필요한 사이클 수를 파악하고 기록합니다.</target>
        </trans-unit>
        <trans-unit id="46266782916c37f0489de1ece340ef09c81505e3" translate="yes" xml:space="preserve">
          <source>The way to improve performance in this case is to either use one of the iteration methods (&lt;code&gt;each_char&lt;/code&gt;, &lt;code&gt;each_byte&lt;/code&gt;, &lt;code&gt;each_codepoint&lt;/code&gt;), or use the more low-level &lt;code&gt;Char::Reader&lt;/code&gt; struct. For example, using &lt;code&gt;each_char&lt;/code&gt;:</source>
          <target state="translated">이 경우 성능을 향상시키는 방법은 반복 방법 중 하나 ( &lt;code&gt;each_char&lt;/code&gt; , &lt;code&gt;each_byte&lt;/code&gt; , &lt;code&gt;each_codepoint&lt;/code&gt; )를 사용하거나보다 낮은 수준의 &lt;code&gt;Char::Reader&lt;/code&gt; 구조체를 사용하는 것입니다. 예를 들어 &lt;code&gt;each_char&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="337ea97d4e3978ad9ffa54460e9435b596c6f608" translate="yes" xml:space="preserve">
          <source>The yielded object has an &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; method that accepts two arguments, a key (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) and a value (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt;). Keys and values are escaped using &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">생성 된 객체에는 키 ( &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )와 값 ( &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; )의 두 인수를 허용 하는 &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; 메소드가 있습니다. 키와 값은 &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt; 을 사용하여 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f5b823543dd77d3734be23420eece15b05c269d" translate="yes" xml:space="preserve">
          <source>The yielded object has an &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; method that accepts two arguments, a key (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) and a value (&lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt;). Keys and values are escaped using &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">생성 된 객체에는 키 ( &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )와 값 ( &lt;code&gt;&lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; )의 두 인수를 받는 &lt;code&gt;&lt;a href=&quot;params#add(name,value)-instance-method&quot;&gt;#add&lt;/a&gt;&lt;/code&gt; 메서드가 있습니다. 키와 값은 &lt;code&gt;&lt;a href=&quot;../uri#encode_www_form(string:String,io:IO,*,space_to_plus:Bool=true):Nil-class-method&quot;&gt;URI.encode_www_form&lt;/a&gt;&lt;/code&gt; 을 사용하여 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="aaad6ca40d977cb492cea395430d88e3875865bb" translate="yes" xml:space="preserve">
          <source>Their type is inferred from their usage, not only from their initializer. In general, they are just value holders associated with the type that the programmer expects them to have according to their location and usage on the program.</source>
          <target state="translated">그들의 유형은 초기화 프로그램뿐만 아니라 사용법에서 유추됩니다. 일반적으로 프로그래머는 위치와 프로그램 사용에 따라 프로그래머가 기대하는 유형과 관련된 가치 보유자입니다.</target>
        </trans-unit>
        <trans-unit id="ed36c8d7efa814982a1bcb38f471b6e7b33b12f3" translate="yes" xml:space="preserve">
          <source>Their type is inferred using the &lt;a href=&quot;type_inference&quot;&gt;global type inference algorithm&lt;/a&gt;.</source>
          <target state="translated">그들의 타입은 &lt;a href=&quot;type_inference&quot;&gt;전역 타입 추론 알고리즘을&lt;/a&gt; 사용하여 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="a596befb5ab412bfec59b1ee23ba998b1572a8fb" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;add&lt;/code&gt; &amp;amp; &lt;code&gt;commit&lt;/code&gt; to start tracking the files with Git:</source>
          <target state="translated">그런 다음 &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;commit&lt;/code&gt; 힘내으로 파일을 추적 시작 :</target>
        </trans-unit>
        <trans-unit id="53aa884bdfb9b146ca586b2f1bff6004bcea5458" translate="yes" xml:space="preserve">
          <source>Then it can be get and set:</source>
          <target state="translated">그런 다음 가져오고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7ac9a6a4d85e91d8fdcbb9eda94da14e4434ce" translate="yes" xml:space="preserve">
          <source>Then named arguments are matched, by name, with any argument in the method (it can be before or after the splat method argument). If an argument was already filled by a positional argument then it's an error.</source>
          <target state="translated">그런 다음 이름이 지정된 인수는 이름을 기준으로 메소드의 인수와 일치합니다 (splat 메소드 인수 앞이나 뒤에있을 수 있음). 인수가 이미 위치 인수로 채워져 있으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7fb23335a8cb62994b6de5487ae6e83d8d3c186a" translate="yes" xml:space="preserve">
          <source>Then you can invoke the compiler by just typing &lt;code&gt;crystal&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;crystal&lt;/code&gt; 을 입력하여 컴파일러를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37e885ec74c274941734c4f9ff31dd391af29e2" translate="yes" xml:space="preserve">
          <source>Then you can pass a function (a &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc&lt;/a&gt;) like this:</source>
          <target state="translated">그런 다음 다음 과 같은 함수 ( &lt;a href=&quot;http://crystal-lang.org/api/Proc.html&quot;&gt;Proc&lt;/a&gt; )를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4a5cfd422762c83f968181fb2673335ae29b56" translate="yes" xml:space="preserve">
          <source>There are  and  syntax. The former will render returned values. The latter will not, but instead serve to control the structure as we do in Crystal.</source>
          <target state="translated">구문이 있습니다. 전자는 반환 값을 렌더링합니다. 후자는 Crystal에서하는 것처럼 구조를 제어하지 않고 대신 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1bacc9714424057814e44c792dedc8e0a456c143" translate="yes" xml:space="preserve">
          <source>There are also two special methods for converting to UTC and local time zone:</source>
          <target state="translated">UTC와 현지 시간대로 변환하는 두 가지 특별한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="842520affd12c1e57a52e3ffbca245c2ee663233" translate="yes" xml:space="preserve">
          <source>There are alternative ways to change the foreground color:</source>
          <target state="translated">전경색을 변경하는 다른 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="922c400cf5752073dc87977a7821e90bef8e3f64" translate="yes" xml:space="preserve">
          <source>There are four signed integer types, and four unsigned integer types:</source>
          <target state="translated">4 개의 부호있는 정수 유형과 4 개의 부호없는 정수 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6ef70215a67446a14d9e7e800fc787c86aba718" translate="yes" xml:space="preserve">
          <source>There are four signed integer types: &lt;code&gt;&lt;a href=&quot;int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;, being able to represent numbers of 8, 16, 32 and 64 bits respectively. There are four unsigned integer types: &lt;code&gt;&lt;a href=&quot;uint8&quot;&gt;UInt8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;uint32&quot;&gt;UInt32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uint64&quot;&gt;UInt64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 의 네 가지 부호있는 정수 유형이 있으며 각각 8, 16, 32 및 64 비트의 숫자를 나타낼 수 있습니다. &lt;code&gt;&lt;a href=&quot;uint8&quot;&gt;UInt8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;uint16&quot;&gt;UInt16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;uint32&quot;&gt;UInt32&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;uint64&quot;&gt;UInt64&lt;/a&gt;&lt;/code&gt; 의 부호없는 정수 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="840dc3d87218acf0124cec8936faf4397855ab70" translate="yes" xml:space="preserve">
          <source>There are however some special rules regarding operator syntax:</source>
          <target state="translated">그러나 연산자 구문과 관련된 몇 가지 특별한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="512b0b0a764ab382af28ad714d03b3b1b5f90a88" translate="yes" xml:space="preserve">
          <source>There are many convenient query methods built on top of &lt;code&gt;#query&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#query&lt;/code&gt; 위에는 편리한 쿼리 방법이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0540a12666f72e39d5c840798fd1cf96d9186e81" translate="yes" xml:space="preserve">
          <source>There are methods to create expectations which test for equivalence (&lt;code&gt;eq&lt;/code&gt;), identity (&lt;code&gt;be&lt;/code&gt;), type (&lt;code&gt;be_a&lt;/code&gt;), and nil (&lt;code&gt;be_nil&lt;/code&gt;). Note that the identity expectation uses &lt;code&gt;.same?&lt;/code&gt; which tests if &lt;a href=&quot;https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method&quot;&gt;&lt;code&gt;#object_id&lt;/code&gt;&lt;/a&gt; are identical. This is only true if the expected value points to &lt;em&gt;the same object&lt;/em&gt; instead of &lt;em&gt;an equivalent one&lt;/em&gt;. This is only possible for reference types and won't work for value types like structs or numbers.</source>
          <target state="translated">동등성 ( &lt;code&gt;eq&lt;/code&gt; ), 동일성 ( &lt;code&gt;be&lt;/code&gt; ), 유형 ( &lt;code&gt;be_a&lt;/code&gt; ) 및 nil ( &lt;code&gt;be_nil&lt;/code&gt; ) 을 테스트하는 기대치를 작성하는 방법이 있습니다 . 신원 기대는 &lt;code&gt;.same?&lt;/code&gt; &lt;a href=&quot;https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method&quot;&gt; &lt;code&gt;#object_id&lt;/code&gt; &lt;/a&gt; 가 동일한 지 테스트 합니다. (가) 가치 점을 예상 경우에만 사실 &lt;em&gt;같은 객체&lt;/em&gt; 대신에 &lt;em&gt;상응하는 하나&lt;/em&gt; . 이것은 참조 유형에만 가능하며 구조체 또는 숫자와 같은 값 유형에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25508cf1fa434da49c56f3aa2985851460362c8c" translate="yes" xml:space="preserve">
          <source>There are no provisions for resuming the current fiber (where this method is called). Unless it is explicitly added for rescheduling (for example using &lt;code&gt;&lt;a href=&quot;fiber#enqueue-instance-method&quot;&gt;#enqueue&lt;/a&gt;&lt;/code&gt;) the current fiber won't ever reach any instructions after the call to this method.</source>
          <target state="translated">현재 파이버를 재개하기위한 조항이 없습니다 (이 방법이 호출되는 곳). 일정 변경을 위해 명시 적으로 추가하지 않는 한 (예 : &lt;code&gt;&lt;a href=&quot;fiber#enqueue-instance-method&quot;&gt;#enqueue&lt;/a&gt;&lt;/code&gt; 사용 ) 현재 광섬유는이 메서드를 호출 한 후 어떤 명령에도 도달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8665b9ce7005cbef306e0775d40ccc93ff049b72" translate="yes" xml:space="preserve">
          <source>There are people looking for the &lt;em&gt;exact&lt;/em&gt; functionality of our library and the &lt;em&gt;general&lt;/em&gt; functionality of our library. e.g. Bob needs a palindrome library, but Felipe is just looking for libraries involving text and Susan is looking for libraries involving spelling.</source>
          <target state="translated">도서관 의 &lt;em&gt;정확한&lt;/em&gt; 기능과 도서관의 &lt;em&gt;일반적인&lt;/em&gt; 기능을 찾는 사람들이 있습니다 . 예를 들어 Bob은 회문 라이브러리가 필요하지만 Felipe는 텍스트가 포함 된 라이브러리 만 찾고 Susan은 철자가 포함 된 라이브러리를 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="15833e4fae44677e5aef19597668e8b099aa34dd" translate="yes" xml:space="preserve">
          <source>There are several methods to retrieve a &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; instance representing the current time:</source>
          <target state="translated">현재 시간을 나타내는 &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; 인스턴스 를 검색하는 몇 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e831d0e1ff9abcb6d2f8ca9921871d9cff763b05" translate="yes" xml:space="preserve">
          <source>There are several ways to avoid heap memory allocations. The standard library is designed in a way to help you do that.</source>
          <target state="translated">힙 메모리 할당을 피하는 방법에는 여러 가지가 있습니다. 표준 라이브러리는이를 수행 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2975438e927a4d7f9683bb1a51e8eb7ce9c022ce" translate="yes" xml:space="preserve">
          <source>There are several ways to let Crystal know this.</source>
          <target state="translated">이를 Crystal에 알리는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a72b96ca552df5e83dc14ec3a46f7f9ea7c5609" translate="yes" xml:space="preserve">
          <source>There are two floating point types, &lt;a href=&quot;http://crystal-lang.org/api/Float32.html&quot;&gt;Float32&lt;/a&gt; and &lt;a href=&quot;http://crystal-lang.org/api/Float64.html&quot;&gt;Float64&lt;/a&gt;, which correspond to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; types defined by IEEE.</source>
          <target state="translated">&lt;a href=&quot;http://crystal-lang.org/api/Float32.html&quot;&gt;Float32&lt;/a&gt; 및 &lt;a href=&quot;http://crystal-lang.org/api/Float64.html&quot;&gt;Float64의&lt;/a&gt; 두 가지 부동 소수점 유형이 있으며 , IEEE에 의해 정의 된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; 유형에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="35b8024484d51c08919d7d33510f5de3f987837e" translate="yes" xml:space="preserve">
          <source>There are two floating point types, &lt;code&gt;&lt;a href=&quot;float32&quot;&gt;Float32&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;float64&quot;&gt;Float64&lt;/a&gt;&lt;/code&gt;, which correspond to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; types defined by IEEE.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;float32&quot;&gt;Float32&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;float64&quot;&gt;Float64&lt;/a&gt;&lt;/code&gt; 의 두 가지 부동 소수점 유형이 있으며 , IEEE에 의해 정의 된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Single_precision_floating-point_format&quot;&gt;binary32&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Double_precision_floating-point_format&quot;&gt;binary64&lt;/a&gt; 유형에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="e806e5ba2d29799e2dcd9daf07237f2d6c0ef4cc" translate="yes" xml:space="preserve">
          <source>There are two main topics when building a CLI application:</source>
          <target state="translated">CLI 애플리케이션을 빌드 할 때 두 가지 주요 주제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="697020fc37bddf0093745ab213eb084879041a18" translate="yes" xml:space="preserve">
          <source>There are two ways to solve this:</source>
          <target state="translated">이 문제를 해결하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b372dc0271f26d904bde368ff92af43659289eda" translate="yes" xml:space="preserve">
          <source>There is a way to rollback the changes in the &lt;code&gt;inner-transaction&lt;/code&gt; but keep the ones in the &lt;code&gt;outer-transaction&lt;/code&gt;. Use &lt;code&gt;rollback&lt;/code&gt; in the &lt;code&gt;inner_tx&lt;/code&gt; object. This will rollback &lt;strong&gt;only&lt;/strong&gt; then inner-transaction. Here is the example:</source>
          <target state="translated">&lt;code&gt;inner-transaction&lt;/code&gt; 의 변경 사항을 롤백 하지만 &lt;code&gt;outer-transaction&lt;/code&gt; 트랜잭션 의 변경 사항을 유지하는 방법 이 있습니다 . &lt;code&gt;inner_tx&lt;/code&gt; 객체 에서 &lt;code&gt;rollback&lt;/code&gt; 을 사용하십시오 . 내부 트랜잭션 &lt;strong&gt;만&lt;/strong&gt; 롤백 합니다. 예를 들면 다음과 같습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7e08c01da28270c73ccef2c650dfccc7946fbdc" translate="yes" xml:space="preserve">
          <source>There is also a helper macro to generate these formatters. Here's an example that generates the same result:</source>
          <target state="translated">이러한 포맷터를 생성하는 도우미 매크로도 있습니다. 다음은 동일한 결과를 생성하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="55ea1e248c53f4931fd7f81fa204e9b44e81271d" translate="yes" xml:space="preserve">
          <source>There is another special case when &lt;code&gt;a&lt;/code&gt; is an index accessor (&lt;code&gt;[]&lt;/code&gt;), it is changed to the nilable variant (&lt;code&gt;[]?&lt;/code&gt; on the right hand side:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 인덱스 접근 자 ( &lt;code&gt;[]&lt;/code&gt; ) 인 경우 또 다른 특별한 경우 가 있으며 오른쪽에있는 nilable 변형 ( &lt;code&gt;[]?&lt;/code&gt; ) 으로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1fc1a4586629630f7e45274573602d5fbf3b217" translate="yes" xml:space="preserve">
          <source>There is no explicit limit on the input values but the addition must result in a valid time between &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; and &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">입력 값에는 명시적인 제한이 없지만 추가로 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; 에서 &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 사이의 유효한 시간이 발생해야합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb5bf545a7e2854b2d0be84ded507a04958791e2" translate="yes" xml:space="preserve">
          <source>There is no explicit limit on the input values but the shift must result in a valid time between &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; and &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt;. Otherwise &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">입력 값에는 명시적인 제한이 없지만 시프트는 &lt;code&gt;0001-01-01 00:00:00.0&lt;/code&gt; 에서 &lt;code&gt;9999-12-31 23:59:59.999_999_999&lt;/code&gt; 사이의 유효한 시간이어야합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;argumenterror&quot;&gt;ArgumentError&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f38cee4e5f6d302c1d80d85a1a600c40b70cebce" translate="yes" xml:space="preserve">
          <source>There is no need to explicitly require &lt;code&gt;crystal-lang/crystal-db&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;crystal-lang/crystal-db&lt;/code&gt; 를 명시 적으로 요구할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06b30029a569ea96f99cdff82bb1a1a33f5f5175" translate="yes" xml:space="preserve">
          <source>There is one &lt;code&gt;exception&lt;/code&gt; with a different behaviour. If a &lt;code&gt;DB::Rollback&lt;/code&gt; is raised within the block, the implicit rollback will happen, but the exception will not be raised outside the block.</source>
          <target state="translated">하나 개가 &lt;code&gt;exception&lt;/code&gt; 다른 행동은. 경우 &lt;code&gt;DB::Rollback&lt;/code&gt; 블록 내에서 발생, 암시 적 롤백이 발생합니다,하지만 예외는 블록 외부에서 제기되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d04f34bb755ae26b5dfd48d5d9baf367179e79c" translate="yes" xml:space="preserve">
          <source>There's a second problem with the above: computing the &lt;code&gt;size&lt;/code&gt; of a String is also slow, because it's not simply the number of bytes in the string (the &lt;code&gt;bytesize&lt;/code&gt;). However, once a String's size has been computed, it is cached.</source>
          <target state="translated">위의 두 번째 문제 가 있습니다. 문자열 의 &lt;code&gt;size&lt;/code&gt; 를 계산하는 것도 느립니다. 문자열의 바이트 수 ( &lt;code&gt;bytesize&lt;/code&gt; ) 가 아니기 때문 입니다. 그러나 일단 문자열 크기가 계산되면 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="4704a94ef37f1a3b7256f98864eae80e83c79302" translate="yes" xml:space="preserve">
          <source>There's a simpler way to write the above by using an &lt;code&gt;out&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 매개 변수 를 사용하여 위의 내용을 작성하는 간단한 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="833d4e9abecd6e3e8399fe0f3887e1d1cf701417" translate="yes" xml:space="preserve">
          <source>There's also the possibility of making a method only receive named arguments (and list them), by placing the star at the beginning:</source>
          <target state="translated">별표를 시작 부분에 배치하여 이름 지정된 인수 만 수신하고 나열하는 메소드를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f16baa65237c3959bd05d621bb9f4b7195f62a93" translate="yes" xml:space="preserve">
          <source>Therefore structs are mostly useful for immutable data types and/or stateless wrappers of other types, usually for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient (for more details, see the &lt;a href=&quot;../guides/performance#use-structs-when-possible&quot;&gt;performance guide&lt;/a&gt;).</source>
          <target state="translated">따라서 구조체는 불변의 데이터 유형 및 / 또는 다른 유형의 상태 비 저장 래퍼에 주로 유용합니다. 일반적으로 작은 복사본을 전달할 때 많은 작은 메모리 할당을 피하는 성능상의 이유로 더 효율적일 수 있습니다 (자세한 내용은 &lt;a href=&quot;../guides/performance#use-structs-when-possible&quot;&gt;성능 안내서&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f61f8922910bd58a08bdaaffc3decb97c2516227" translate="yes" xml:space="preserve">
          <source>Therefore, HTTP Basic is preferred, and Request Body should only be used if the server does not support HTTP Basic.</source>
          <target state="translated">따라서 HTTP Basic이 선호되며 서버가 HTTP Basic을 지원하지 않는 경우에만 Request Body를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eee92756be584f64d5bc56365f0f367ad17d2a42" translate="yes" xml:space="preserve">
          <source>These alternate between &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; for the plaintext parts and &lt;code&gt;&lt;a href=&quot;astnode&quot;&gt;ASTNode&lt;/a&gt;&lt;/code&gt;s of any type for the interpolated expressions.</source>
          <target state="translated">이것들 은 평문 부분에 대한 &lt;code&gt;&lt;a href=&quot;stringliteral&quot;&gt;StringLiteral&lt;/a&gt;&lt;/code&gt; 과 보간 된 표현식에 대한 모든 유형의 &lt;code&gt;&lt;a href=&quot;astnode&quot;&gt;ASTNode&lt;/a&gt;&lt;/code&gt; 사이에서 번갈아 나타 납니다 .</target>
        </trans-unit>
        <trans-unit id="52462b1c60032326e14014f4c5bfcae1c58f65f3" translate="yes" xml:space="preserve">
          <source>These are defined without arguments. For example</source>
          <target state="translated">이들은 인수없이 정의됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e8180d4636bc06ee71ab5679ae69e58040058d3e" translate="yes" xml:space="preserve">
          <source>These are handy to write regular expressions that include slashes which would have to be escaped in slash-delimited literals.</source>
          <target state="translated">슬래시로 구분 된 리터럴로 이스케이프해야하는 슬래시를 포함하는 정규식을 작성하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="dc10ca4e01d7a135d8ffb35a404ded61daa207f4" translate="yes" xml:space="preserve">
          <source>These are handy to write strings that include double quotes which would have to be escaped in double-quoted strings.</source>
          <target state="translated">큰 따옴표로 묶어야하는 큰 따옴표가 포함 된 문자열을 작성하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ba592af6e825f0110f0417c77a0807b693560" translate="yes" xml:space="preserve">
          <source>These can be included into classes:</source>
          <target state="translated">이들은 수업에 포함될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c5ac138599d0a4f2720ae8403888c676ba7af7ba" translate="yes" xml:space="preserve">
          <source>These flags are generally used in C bindings to conditionally define types and functions. For example, the very well known &lt;code&gt;size_t&lt;/code&gt; type is defined like this in Crystal:</source>
          <target state="translated">이 플래그는 일반적으로 C 바인딩에서 유형 및 함수를 조건부로 정의하는 데 사용됩니다. 예를 들어, 잘 알려진 &lt;code&gt;size_t&lt;/code&gt; 유형은 Crystal에서 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3328184f79d428d1cdba1a7b601e49684f8db2d1" translate="yes" xml:space="preserve">
          <source>These matchers run a block and pass if it raises a certain exception.</source>
          <target state="translated">이 매처는 특정 예외가 발생하면 블록을 실행하고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0c9e9b99ed1db33822e0001fe19d63beb30df5f0" translate="yes" xml:space="preserve">
          <source>These methods usually imply a side effect.</source>
          <target state="translated">이러한 방법은 일반적으로 부작용을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="ec6ca5f54090a8947e07a52adbdec5ff5edfd58a" translate="yes" xml:space="preserve">
          <source>These parts of the language are considered unsafe:</source>
          <target state="translated">이 언어 부분은 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5cb449c652a8d3cad8971a908adf09c5315ce6" translate="yes" xml:space="preserve">
          <source>These tools not only will let us build and test our code each time the source has changed but also deploy the result (if the build was successful) or use automatic builds, and maybe test against different platforms, to mention a few.</source>
          <target state="translated">이러한 도구를 사용하면 소스가 변경 될 때마다 코드를 빌드하고 테스트 할 수있을뿐만 아니라 결과를 배포하거나 (빌드가 성공한 경우) 자동 빌드를 사용하고, 몇 가지를 언급 ​​할 때 다른 플랫폼에 대해 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2b6a3e66f06b30694b98b640803a3ea88b27ad" translate="yes" xml:space="preserve">
          <source>They allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures.</source>
          <target state="translated">메모리를 공유하지 않고 잠금, 세마포어 또는 기타 특수 구조에 대해 걱정할 필요없이 광섬유간에 데이터를 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f394867a5d293f5b8d8a58cc4a912b45c6a8578" translate="yes" xml:space="preserve">
          <source>They are explained &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">여기에 설명되어 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a79d299bb92be8426f3c6903a9d162db6534c06" translate="yes" xml:space="preserve">
          <source>They can also be defined in classes and modules, and are visible in those scopes. Macros are also looked-up in the ancestors chain (superclasses and included modules).</source>
          <target state="translated">또한 클래스와 모듈로 정의 할 수 있으며 해당 범위에서 볼 수 있습니다. 매크로는 또한 조상 체인 (수퍼 클래스 및 포함 된 모듈)에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="804bc537ae6f4a7386c98efeb9e2fc19229f8bd5" translate="yes" xml:space="preserve">
          <source>They return the rescued exception so it can be used for further expectations, for example to verify specific properties of the exception.</source>
          <target state="translated">그들은 구출 된 예외를 반환하여 예외의 특정 속성을 확인하는 등의 추가 기대에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="940284502d1ed20ae98c767eff3b9d5f29075a3e" translate="yes" xml:space="preserve">
          <source>This Deque is implemented with a &lt;a href=&quot;http://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;dynamic array&lt;/a&gt; used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_buffer&quot;&gt;circular buffer&lt;/a&gt;.</source>
          <target state="translated">이 Deque는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_buffer&quot;&gt;순환 버퍼&lt;/a&gt; 로서 사용되는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dynamic_array&quot;&gt;동적 배열&lt;/a&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="d00e2309d8d14a793dd4162170eeeb8a6389e487" translate="yes" xml:space="preserve">
          <source>This affects only TLSv1.2 and below.</source>
          <target state="translated">이는 TLSv1.2 이하에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4a893c0c045eb46234c00e09d1504b97ad0f7082" translate="yes" xml:space="preserve">
          <source>This allocates a new object and copies the contents of &lt;code&gt;self&lt;/code&gt; into it.</source>
          <target state="translated">새 객체를 할당하고 &lt;code&gt;self&lt;/code&gt; 내용을 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="8772cd98aed338697c76d9394bc311fe22b0e008" translate="yes" xml:space="preserve">
          <source>This allocates the struct on the stack.</source>
          <target state="translated">스택에 구조체를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="45a0cdda2fbf946e775052aa4818961d112501a1" translate="yes" xml:space="preserve">
          <source>This allocates the union on the stack.</source>
          <target state="translated">스택에 공용체를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="cd5b485625c53ffbb51fbc1a22e7e9d6dde6937a" translate="yes" xml:space="preserve">
          <source>This allows you to define arrays and methods based on module type instead of class:</source>
          <target state="translated">이를 통해 클래스 대신 모듈 유형을 기반으로 배열과 메소드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89252758af63a847860957aa9da7700be5c4f8f0" translate="yes" xml:space="preserve">
          <source>This allows you to define helper methods in a file that will only be known in that file.</source>
          <target state="translated">이를 통해 파일에서만 알려진 헬퍼 메소드를 파일에 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43896ca6eada4a6a152d7197dc01153de171de19" translate="yes" xml:space="preserve">
          <source>This allows you to easily pass a hash as individual named arguments to a method.</source>
          <target state="translated">이를 통해 개별 명명 된 인수로 해시를 메소드에 쉽게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bda246c4232e755a841e76ef71277dbce3590e" translate="yes" xml:space="preserve">
          <source>This allows you to easily pass an array as individual arguments to a method.</source>
          <target state="translated">이를 통해 배열을 개별 인수로 메소드에 쉽게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c1f0225f2fc4dc9ae274431682ca45cbdc6094" translate="yes" xml:space="preserve">
          <source>This allows you to treat strings, symbols, variables and calls uniformly. For example:</source>
          <target state="translated">이를 통해 문자열, 기호, 변수 및 호출을 균일하게 처리 할 수 ​​있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="985c89bbce1f242112f0eea387ee135995956f57" translate="yes" xml:space="preserve">
          <source>This also applies when a variable is assigned in an &lt;code&gt;if&lt;/code&gt;'s condition:</source>
          <target state="translated">이는 &lt;code&gt;if&lt;/code&gt; 조건 에서 변수가 할당 된 경우에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7525704cb029c1388cb3009876fa72ad59abdf42" translate="yes" xml:space="preserve">
          <source>This also happens with regular proc literals, even if it's evident that the proc wasn't invoked or stored:</source>
          <target state="translated">proc이 호출되거나 저장되지 않은 것이 분명하더라도 일반 proc 리터럴에서도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9988407bcb9d63feae9fc976466e9bdd7ad12705" translate="yes" xml:space="preserve">
          <source>This also is applied to generic types. Here &lt;code&gt;@values&lt;/code&gt; is inferred to be &lt;code&gt;Array(Int32)&lt;/code&gt;.</source>
          <target state="translated">이것은 제네릭 형식에도 적용됩니다. 여기서 &lt;code&gt;@values&lt;/code&gt; 는 &lt;code&gt;Array(Int32)&lt;/code&gt; 것으로 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b7f7f4a266adf1c28f807ca3c9ed3978e576578" translate="yes" xml:space="preserve">
          <source>This annotation marks methods, classes, constants, and macros as deprecated.</source>
          <target state="translated">이 주석은 메서드, 클래스, 상수 및 매크로를 더 이상 사용되지 않음으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4751c5f627c499e44007864f299d67e531169b3b" translate="yes" xml:space="preserve">
          <source>This annotation marks methods, classes, constants, and macros as experimental.</source>
          <target state="translated">이 주석은 메서드, 클래스, 상수 및 매크로를 실험적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a59ff08fc13601d64759154db5c0018630125c45" translate="yes" xml:space="preserve">
          <source>This annotations marks methods, classes, constants, and macros as deprecated.</source>
          <target state="translated">이 주석은 메소드, 클래스, 상수 및 매크로를 더 이상 사용되지 않는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81bec1181a948a798dc2a1e99836a1c9b7bcc142" translate="yes" xml:space="preserve">
          <source>This appends this char's bytes as encoded by UTF-8 to the given &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 UTF-8에 의해 인코딩 된이 char 바이트를 주어진 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="da0f7f0a8e3f8df5455b6557aee9dc259a631d6a" translate="yes" xml:space="preserve">
          <source>This backend is not to be used explicitly. It is used by &lt;code&gt;&lt;a href=&quot;builder&quot;&gt;Log::Builder&lt;/a&gt;&lt;/code&gt; configuration to allow a given source to emit to multiple backends.</source>
          <target state="translated">이 백엔드는 명시 적으로 사용되지 않습니다. 에 의해 사용되는 &lt;code&gt;&lt;a href=&quot;builder&quot;&gt;Log::Builder&lt;/a&gt;&lt;/code&gt; 주어진 소스가 여러 백엔드에 방출 할 수 있도록 구성.</target>
        </trans-unit>
        <trans-unit id="248796d8d9934bbe14e20f2b2504914ba28d35bf" translate="yes" xml:space="preserve">
          <source>This builder is similar to &lt;code&gt;&lt;a href=&quot;../builder&quot;&gt;YAML::Builder&lt;/a&gt;&lt;/code&gt;, but instead of directly emitting the output to an IO it builds a YAML document tree in memory.</source>
          <target state="translated">이 빌더는 &lt;code&gt;&lt;a href=&quot;../builder&quot;&gt;YAML::Builder&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 출력을 IO로 직접 방출하는 대신 YAML 문서 트리를 메모리에 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="d2fa87d3879858b4853188bf95255ef603ec97a9" translate="yes" xml:space="preserve">
          <source>This can also be used to give shorter, nicer names to C functions, as these tend to be long and are usually prefixed with the library name.</source>
          <target state="translated">또한 C 함수에 길고 경향이 있으며 일반적으로 라이브러리 이름이 앞에 붙기 때문에 C 함수에 더 짧고 멋진 이름을 지정하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="507eacbc1bf0d16243a0bb3a476918e772e63734" translate="yes" xml:space="preserve">
          <source>This can be circumvented by assigning the value to a new local variable:</source>
          <target state="translated">새로운 지역 변수에 값을 할당하여 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2bc8c72bc0aa46c1e0d9852985b434e6d7d9a8" translate="yes" xml:space="preserve">
          <source>This can be found at &lt;code&gt;https://github.com/&amp;lt;YOUR-GITHUB-NAME&amp;gt;/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;/releases&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;https://github.com/&amp;lt;YOUR-GITHUB-NAME&amp;gt;/&amp;lt;YOUR-REPOSITORY-NAME&amp;gt;/releases&lt;/code&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd27003f6f34584a3555328bd566670a8fde55d" translate="yes" xml:space="preserve">
          <source>This can be mitigated by using the nilable version of the above: $N?, (e.g., $1? $2?, $3?, ...). Changing the above to use &lt;code&gt;$2?&lt;/code&gt; instead of &lt;code&gt;$2&lt;/code&gt; would return &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;$2?.nil?&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">위의 $ N? (예 : $ 1? $ 2 ?, $ 3 ?, ...)을 사용하여이를 완화 할 수 있습니다. &lt;code&gt;$2?&lt;/code&gt; 를 사용하기 위해 위의 내용을 변경 하시겠습니까? &lt;code&gt;$2&lt;/code&gt; 대신 &lt;code&gt;nil&lt;/code&gt; 이 반환 됩니다. &lt;code&gt;$2?.nil?&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="12b21e5f6bdac9d403b7334eaf4f7413aa131f10" translate="yes" xml:space="preserve">
          <source>This can be used either to stub out method bodies, or when the method is not implemented on the current platform.</source>
          <target state="translated">메소드 본문을 스텁 아웃하거나 메소드가 현재 플랫폼에서 구현되지 않은 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f0e0dd5e017f72f1e84e12688991f21509576ec" translate="yes" xml:space="preserve">
          <source>This can be used to create efficient formatters:</source>
          <target state="translated">이것은 효율적인 포맷터를 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="290297a08de042185c1c84c038c10066109d7785" translate="yes" xml:space="preserve">
          <source>This can be used to prevent many memory allocations when each slice of interest is to be used in a read-only fashion.</source>
          <target state="translated">이것은 각 관심 슬라이스가 읽기 전용 방식으로 사용될 때 많은 메모리 할당을 막기 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb50edfa23bcef6f6011e63d4071b8d122b296f0" translate="yes" xml:space="preserve">
          <source>This can sometimes be useful to avoid repetitive code by deliberately reading/writing local variables, but can also overwrite local variables by mistake. To avoid this, fresh variables can be declared with &lt;code&gt;%name&lt;/code&gt;:</source>
          <target state="translated">로컬 변수를 고의로 읽고 쓰는 방식으로 반복적 인 코드를 피하는 데 유용 할 수 있지만 실수로 로컬 변수를 덮어 쓸 수도 있습니다. 이를 피하기 위해 &lt;code&gt;%name&lt;/code&gt; 으로 새로운 변수를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c74e7cb6f57fd33f489fc0dd5d3e1634927b4408" translate="yes" xml:space="preserve">
          <source>This capture will even work if there are currently no backends configured, effectively adding a temporary backend.</source>
          <target state="translated">이 캡처는 현재 구성된 백엔드가없는 경우에도 작동하여 효과적으로 임시 백엔드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9d0016fb953e5977cad8c4754588413f0a3ed185" translate="yes" xml:space="preserve">
          <source>This class allows you to consume JSON on demand, token by token.</source>
          <target state="translated">이 클래스를 사용하면 필요에 따라 토큰별로 토큰을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fddc331d6ec149095268659cb395c5d85a698137" translate="yes" xml:space="preserve">
          <source>This class also provides methods to build authorize URIs and get access tokens with different methods, as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 또한 &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot;&gt;RFC 6749에&lt;/a&gt; 지정된대로 URI를 작성하고 다른 메소드로 액세스 토큰을 얻는 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="51830efb40e10d23f3abf190c9ab320a6da39cdd" translate="yes" xml:space="preserve">
          <source>This class also provides methods to get request tokens, build authorize URIs and get access tokens, as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5849&quot;&gt;RFC 5849에&lt;/a&gt; 지정된대로 요청 토큰을 가져오고 URI를 작성하며 액세스 토큰을 얻는 메소드도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="005e91e2755cb7746b08c1fd6a1089edd3980f74" translate="yes" xml:space="preserve">
          <source>This class implements a pretty printing algorithm. It finds line breaks and nice indentations for grouped structure.</source>
          <target state="translated">이 클래스는 예쁜 인쇄 알고리즘을 구현합니다. 그룹화 된 구조에 대한 줄 바꿈과 멋진 들여 쓰기를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7b193332d3e7ac21a2ef720c48e8a13290f8da7e" translate="yes" xml:space="preserve">
          <source>This class is inherited by types like &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; and provides many useful methods for reading from and writing to an IO, like &lt;code&gt;&lt;a href=&quot;io#print(*objects:UNDERSCORE):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 와 같은 유형으로 상속되며 &lt;code&gt;&lt;a href=&quot;io#print(*objects:UNDERSCORE):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt; 와 같은 IO에서 읽고 쓰는 데 유용한 많은 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cb43ad97c50ed3f8a3e7b1cb45900cadd876d9c6" translate="yes" xml:space="preserve">
          <source>This class is inherited by types like &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; and provides many useful methods for reading from and writing to an IO, like &lt;code&gt;&lt;a href=&quot;io#print(*objects:_):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;&lt;a href=&quot;file&quot;&gt;File&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io/memory&quot;&gt;IO::Memory&lt;/a&gt;&lt;/code&gt; 와 같은 유형으로 상속되며 &lt;code&gt;&lt;a href=&quot;io#print(*objects:_):Nil-instance-method&quot;&gt;#print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#puts:Nil-instance-method&quot;&gt;#puts&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#gets(delimiter:Char,limit:Int,chomp=false):String?-instance-method&quot;&gt;#gets&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;io#printf(format_string,*args):Nil-instance-method&quot;&gt;#printf&lt;/a&gt;&lt;/code&gt; 와 같이 IO에서 읽고 쓰기위한 많은 유용한 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="31bbc4cb995f23a911d22e5e5e2b913518e6c310" translate="yes" xml:space="preserve">
          <source>This class is the exception thrown when errno errors are encountered.</source>
          <target state="translated">이 클래스는 errno 오류가 발생할 때 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="5abeadb5bb3efabaad829e19c08976dd58b3d9fd" translate="yes" xml:space="preserve">
          <source>This class provides a number of methods for encoding and decoding strings using URL Encoding (also known as Percent Encoding) as defined in &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; as well as &lt;a href=&quot;https://url.spec.whatwg.org/#urlencoded-serializing&quot;&gt;&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt; 및 &lt;a href=&quot;https://url.spec.whatwg.org/#urlencoded-serializing&quot;&gt; &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; 에&lt;/a&gt; 정의 된 URL 인코딩 (백분율 인코딩이라고도 함)을 사용하여 문자열을 인코딩 및 디코딩하기위한 여러 가지 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="176d7dbe8031aa71aff24aca941ce1ab05a1d3d0" translate="yes" xml:space="preserve">
          <source>This class provides constructors for creating URI instances from their components or by parsing their string forms and methods for accessing the various components of an instance.</source>
          <target state="translated">이 클래스는 컴포넌트에서 URI 인스턴스를 작성하거나 인스턴스의 다양한 컴포넌트에 액세스하기위한 문자열 양식 및 메소드를 구문 분석하여 생성자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82500e146b4ef44a1f1dda0397e58e0120ec75b0" translate="yes" xml:space="preserve">
          <source>This class represents a URI reference as defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986: Uniform Resource Identifier (URI): Generic Syntax&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986 : URI (Uniform Resource Identifier) ​​: Generic Syntax에&lt;/a&gt; 의해 정의 된 URI 참조를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d92467a1ebd54ee2626a8826007b25b0ab9f1b59" translate="yes" xml:space="preserve">
          <source>This class staples together two unidirectional &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;s to form a single, bidirectional &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 두 개의 단방향 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 스테이플 링 하여 단일 양방향 &lt;code&gt;&lt;a href=&quot;../io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="e73af425ad3a2ff6fa73d0afa1e584f684932012" translate="yes" xml:space="preserve">
          <source>This class wraps another &lt;code&gt;&lt;a href=&quot;../../socket/server&quot;&gt;::Socket::Server&lt;/a&gt;&lt;/code&gt; in an SSL layer.</source>
          <target state="translated">이 클래스는 다른 &lt;code&gt;&lt;a href=&quot;../../socket/server&quot;&gt;::Socket::Server&lt;/a&gt;&lt;/code&gt; 를 SSL 계층으로 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="1776e307c121681e53f8c19a0a7a184cfe531a3e" translate="yes" xml:space="preserve">
          <source>This clock should be independent from discontinuous jumps in the system time, such as leap seconds, time zone adjustments or manual changes to the computer's clock.</source>
          <target state="translated">이 시계는 윤초, 시간대 조정 또는 컴퓨터 시계의 수동 변경과 같은 시스템 시간의 불연속 점프와는 독립적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d28537f2d1d725c35f1636b8d0c2dfbe4ba0c293" translate="yes" xml:space="preserve">
          <source>This command will write &lt;code&gt;hello&lt;/code&gt; and subsequently delete all files and folders in the current working directory.</source>
          <target state="translated">이 명령은 &lt;code&gt;hello&lt;/code&gt; 를 쓰고 현재 작업 디렉토리의 모든 파일과 폴더를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e7ff54e18af98cd3ffdf3df24c6450032d8767e8" translate="yes" xml:space="preserve">
          <source>This constant is defined to be &quot;1970-01-01 00:00:00 UTC&quot;. Can be used to create a &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; that represents an Unix Epoch time duration.</source>
          <target state="translated">이 상수는 &quot;1970-01-01 00:00:00 UTC&quot;로 정의됩니다. Unix Epoch 시간을 나타내는 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; 을 만드는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a45bd7af59946b2a334031775a47a6e9a021531c" translate="yes" xml:space="preserve">
          <source>This constructor will &lt;em&gt;ignore&lt;/em&gt; any path or query segments in the URI as those will need to be passed to the client when a request is made.</source>
          <target state="translated">이 생성자는 요청시 클라이언트에 전달되어야하므로 URI의 경로 또는 쿼리 세그먼트를 &lt;em&gt;무시&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a3406bd6a5b767e93fac04fc21d6da07c89f17e6" translate="yes" xml:space="preserve">
          <source>This constructor will raise an exception if any scheme but HTTP or HTTPS is used.</source>
          <target state="translated">HTTP 또는 HTTPS 이외의 스키마를 사용하는 경우이 생성자는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fd7237b6baa5ece029d338b82602580b42a87ed0" translate="yes" xml:space="preserve">
          <source>This covers two uses cases.</source>
          <target state="translated">여기에는 두 가지 사용 사례가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d71e26587af83aa7ce2d4b43555f5703ec675c25" translate="yes" xml:space="preserve">
          <source>This creates a new instance with the same string representation but with &lt;code&gt;&lt;a href=&quot;path/kind#WINDOWS&quot;&gt;Kind::WINDOWS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 표현은 같지만 &lt;code&gt;&lt;a href=&quot;path/kind#WINDOWS&quot;&gt;Kind::WINDOWS&lt;/a&gt;&lt;/code&gt; 새 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="91f087610a2831cfacb8986f5510f43514a450a4" translate="yes" xml:space="preserve">
          <source>This creates two jobs. The first one is titled &quot;spec &amp;amp; format&quot; (you can use any name you like) and by default goes in the &quot;test&quot; stage of the pipeline. It just runs the array of commands in &lt;code&gt;script&lt;/code&gt; on a brand new instance of the docker container specified by &lt;code&gt;image&lt;/code&gt;. You'll probably want to lock that container to the version of crystal you're using (the one specified in your shard.yml) but for this example we'll just use the &lt;code&gt;latest&lt;/code&gt; tag.</source>
          <target state="translated">이것은 두 가지 직업을 만듭니다. 첫 번째 이름은 &quot;사양 및 형식&quot;(원하는 이름을 사용할 수 있음)이며 기본적으로 파이프 라인의 &quot;테스트&quot;단계로 이동합니다. &lt;code&gt;image&lt;/code&gt; 로 지정된 docker 컨테이너의 새로운 인스턴스 에서 &lt;code&gt;script&lt;/code&gt; 의 명령 배열을 실행합니다 . 해당 컨테이너를 사용중인 크리스탈 버전 (shard.yml에 지정된 버전)에 고정하고 싶을 수 있지만이 예제에서는 &lt;code&gt;latest&lt;/code&gt; 태그 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="29b9aa4580cc6ed55353a8702da056f1635f9be3" translate="yes" xml:space="preserve">
          <source>This document tree can then be converted to YAML be invoking &lt;code&gt;to_yaml&lt;/code&gt; on the document object.</source>
          <target state="translated">그런 다음이 문서 트리를 YAML로 변환 하여 문서 객체에서 &lt;code&gt;to_yaml&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39154e3473a0dc991c568ac27b3f2440313ad34a" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;&lt;a href=&quot;object#to_s(io:IO):Nil-instance-method&quot;&gt;Object#to_s(IO)&lt;/a&gt;&lt;/code&gt; on each expression enclosed by &lt;code&gt;#{...}&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;#{...}&lt;/code&gt; 로 묶인 각 표현식에서 &lt;code&gt;&lt;a href=&quot;object#to_s(io:IO):Nil-instance-method&quot;&gt;Object#to_s(IO)&lt;/a&gt;&lt;/code&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="060c58baa29e1fcb98dcf6a86e23ec4c882ea63c" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;object.to_io(self, format)&lt;/code&gt;, so any object defining a &lt;code&gt;to_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; method can be written in this way.</source>
          <target state="translated">그러면 &lt;code&gt;object.to_io(self, format)&lt;/code&gt; 이 호출 되어 &lt;code&gt;to_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; 메서드를 정의하는 모든 객체 를 이런 방식으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5dc44fe685bf23c6f2a42b59ae9f6d1d4af375" translate="yes" xml:space="preserve">
          <source>This ends up invoking &lt;code&gt;type.from_io(self, format)&lt;/code&gt;, so any type defining a &lt;code&gt;from_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; method can be read in this way.</source>
          <target state="translated">&lt;code&gt;type.from_io(self, format)&lt;/code&gt; 호출 하므로 &lt;code&gt;from_io(io : &lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;, format : &lt;a href=&quot;io/byteformat&quot;&gt;IO::ByteFormat&lt;/a&gt; = &lt;a href=&quot;io/byteformat/systemendian&quot;&gt;IO::ByteFormat::SystemEndian&lt;/a&gt;)&lt;/code&gt; 메소드를 정의하는 모든 유형 을 이런 방식으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848435bb3324ae976c11c3cb776d5fc697e9bd2d" translate="yes" xml:space="preserve">
          <source>This equates to the results from &lt;code&gt;&lt;a href=&quot;time#calendar_week:Tuple(Int32,Int32)-instance-method&quot;&gt;#calendar_week&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;time#calendar_week:Tuple(Int32,Int32)-instance-method&quot;&gt;#calendar_week&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; 의 결과 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="afbaccbf56819a8b62afa62f6cd2562c851e8ae5" translate="yes" xml:space="preserve">
          <source>This essentially scaps off &lt;code&gt;nanoseconds&lt;/code&gt;.</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;nanoseconds&lt;/code&gt; 뛰어 넘습니다 .</target>
        </trans-unit>
        <trans-unit id="721d4c9ca7c16a340c6aae88c2f31873c331a514" translate="yes" xml:space="preserve">
          <source>This evaluation applies to both interpolation and directives. As a result of this, macros cannot be commented out.</source>
          <target state="translated">이 평가는 보간 및 지시문 모두에 적용됩니다. 따라서 매크로를 주석 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="ffc1b3edbbf38b05a0ee3f094ab36d4fb3ce5295" translate="yes" xml:space="preserve">
          <source>This explanation should include a few examples along with subheadings.</source>
          <target state="translated">이 설명에는 소제목과 함께 몇 가지 예가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8aa426b4a863c63113851317019c903a9b399921" translate="yes" xml:space="preserve">
          <source>This expression is also available in the &lt;a href=&quot;type_grammar&quot;&gt;type grammar&lt;/a&gt;.</source>
          <target state="translated">이 표현식은 &lt;a href=&quot;type_grammar&quot;&gt;grammar 유형으로&lt;/a&gt; 도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b72baa812d61ece5decfb24ec25e9c34062d798" translate="yes" xml:space="preserve">
          <source>This extra rule is very convenient because it's very common to have &quot;constructor-like&quot; class methods in addition to &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">이 추가 규칙은 &lt;code&gt;new&lt;/code&gt; 와 함께 &quot;생성자 같은&quot;클래스 메소드를 갖는 것이 일반적이기 때문에 매우 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="88a8efe3fa756c00e20ace6147aa9004dfe45bf9" translate="yes" xml:space="preserve">
          <source>This file is used to require &lt;code&gt;spec&lt;/code&gt; and other includes like code from the project needed for every spec file. This is also a good place to define global helper methods that make writing specs easier and avoid code duplication.</source>
          <target state="translated">이 파일은 &lt;code&gt;spec&lt;/code&gt; 을 요구하는 데 사용되며 모든 스펙 파일에 필요한 프로젝트의 코드와 같은 기타 코드가 포함됩니다. 또한 스펙 작성을보다 쉽게하고 코드 중복을 피할 수있는 글로벌 헬퍼 메소드를 정의하기에 좋은 곳입니다.</target>
        </trans-unit>
        <trans-unit id="c68257bbe42e4b6932347e56617681dc1006cd33" translate="yes" xml:space="preserve">
          <source>This form allows you to specify the return type and to check it against the proc's body.</source>
          <target state="translated">이 형식을 사용하면 반환 유형을 지정하고 proc 본문과 비교하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="685485e2edc62b0420c3e833489e240b8333d814" translate="yes" xml:space="preserve">
          <source>This generates the following output showing the mean iterations per second, the mean times per iteration, the standard deviation relative to the mean, and a comparison:</source>
          <target state="translated">이는 초당 평균 반복, 평균 반복 횟수, 평균에 대한 표준 편차 및 비교를 표시하는 다음 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cef42efc62c5a598403b41b6864adca576c540ce" translate="yes" xml:space="preserve">
          <source>This generates the following output:</source>
          <target state="translated">다음과 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8563101441b8caea1f946cd2dcc00e0fff6fd76e" translate="yes" xml:space="preserve">
          <source>This guide presents the api of crystal-db, the sql commands might need to be adapted for the concrete driver due to differences between postgres, mysql and sqlite.</source>
          <target state="translated">이 안내서는 crystal-db의 API를 보여줍니다. sql 명령은 postgres, mysql 및 sqlite의 차이로 인해 구체적인 드라이버에 맞게 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c26d06eed479af9c1fb47b4dd6229529ea3f80" translate="yes" xml:space="preserve">
          <source>This handler also logs the exceptions to the specified logger or the logger for the source &quot;http.server&quot; by default.</source>
          <target state="translated">이 핸들러는 또한 기본적으로 소스 &quot;http.server&quot;에 대해 지정된 로거 또는 로거에 예외를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="96ed9d68319f2b0bd7158dce5969429c473b2c10" translate="yes" xml:space="preserve">
          <source>This implementation of Bcrypt is currently 50% slower than pure C solutions, so keep this in mind when selecting your cost. It may be wise to test with Ruby's &lt;a href=&quot;https://github.com/codahale/bcrypt-ruby&quot;&gt;bcrypt gem&lt;/a&gt; which is a binding to OpenBSD's implementation.</source>
          <target state="translated">이 Bcrypt 구현은 현재 순수 C 솔루션보다 50 % 느리므로 비용을 선택할 때이 점을 명심하십시오. OpenBSD의 구현에 대한 바인딩 인 Ruby의 &lt;a href=&quot;https://github.com/codahale/bcrypt-ruby&quot;&gt;bcrypt gem&lt;/a&gt; 으로 테스트하는 것이 현명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67d51a88c6db05098f9b5a707ccc79ae0d34eaf5" translate="yes" xml:space="preserve">
          <source>This implementation supports both IPv4 and IPv6 addresses. For IPv4 addresses you must use &lt;code&gt;&lt;a href=&quot;socket/family#INET&quot;&gt;Socket::Family::INET&lt;/a&gt;&lt;/code&gt; family (default) or &lt;code&gt;&lt;a href=&quot;socket/family#INET6&quot;&gt;Socket::Family::INET6&lt;/a&gt;&lt;/code&gt; for IPv6 # addresses.</source>
          <target state="translated">이 구현은 IPv4 및 IPv6 주소를 모두 지원합니다. IPv4 주소의 경우 IPv6 # 주소에 &lt;code&gt;&lt;a href=&quot;socket/family#INET&quot;&gt;Socket::Family::INET&lt;/a&gt;&lt;/code&gt; 제품군 (기본값) 또는 &lt;code&gt;&lt;a href=&quot;socket/family#INET6&quot;&gt;Socket::Family::INET6&lt;/a&gt;&lt;/code&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e6ce8e3e44aae5b88d2909e4c16dca95dba30407" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;unsafe&quot;&gt;unsafe&lt;/a&gt; code and is almost always used in low-level code for declaring uninitialized &lt;a href=&quot;http://crystal-lang.org/api/StaticArray.html&quot;&gt;StaticArray&lt;/a&gt; buffers without a performance penalty:</source>
          <target state="translated">이것은 &lt;a href=&quot;unsafe&quot;&gt;안전하지 않은&lt;/a&gt; 코드이며 성능 저하없이 초기화되지 않은 &lt;a href=&quot;http://crystal-lang.org/api/StaticArray.html&quot;&gt;StaticArray&lt;/a&gt; 버퍼 를 선언하기 위해 저수준 코드에서 거의 항상 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="632a34c3007c26c97734bd84e5e0be3f30f8d0e3" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;Int#times&lt;/code&gt; definition:</source>
          <target state="translated">이것은 &lt;code&gt;Int#times&lt;/code&gt; 정의입니다.</target>
        </trans-unit>
        <trans-unit id="c668fa989e55efeeecfc94f0c60618b6423f1d4d" translate="yes" xml:space="preserve">
          <source>This is a convenience method to allow invoking &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; with named arguments instead of with a hash/named-tuple literal.</source>
          <target state="translated">해시 / 명명 된 튜플 리터럴 대신 명명 된 인수로 &lt;code&gt;&lt;a href=&quot;json#mapping(**_properties_)-macro&quot;&gt;JSON.mapping&lt;/a&gt;&lt;/code&gt; 을 호출 할 수있는 편리한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="6ef92f89c3db410d172018d00077e09a212a4874" translate="yes" xml:space="preserve">
          <source>This is a convenience method to allow invoking &lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; with named arguments instead of with a hash/named-tuple literal.</source>
          <target state="translated">해시 / 명명 된 튜플 리터럴 대신 명명 된 인수로 &lt;code&gt;&lt;a href=&quot;yaml#mapping(**_properties_)-macro&quot;&gt;YAML.mapping&lt;/a&gt;&lt;/code&gt; 을 호출 할 수있는 편리한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="30d559b41aae00e4148c999f88a873b235e4915a" translate="yes" xml:space="preserve">
          <source>This is a low-level primitive and only useful if a C API needs to directly interface with the data layout of a Crystal type.</source>
          <target state="translated">이것은 저수준 프리미티브이며 C API가 Crystal 유형의 데이터 레이아웃과 직접 인터페이스해야하는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0b974d586221716666c5b40df54db4b1a11dfcda" translate="yes" xml:space="preserve">
          <source>This is a push mirror and that means changes will only propagate one way. So be sure to let potential collaborators know that pull requests and issues should be submitted to your GitLab project.</source>
          <target state="translated">이것은 푸시 미러이며 변경 사항이 한 방향으로 만 전파됨을 의미합니다. 따라서 잠재적 인 공동 작업자에게 풀 요청 및 문제가 GitLab 프로젝트에 제출되어야 함을 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="73ddca3219f717b051a6ded485d83b6fa803e12f" translate="yes" xml:space="preserve">
          <source>This is also compatible to &lt;a href=&quot;https://tools.ietf.org/html/rfc882&quot;&gt;RFC 882&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc1123#page-55&quot;&gt;RFC 1123&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc882&quot;&gt;RFC 882&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123#page-55&quot;&gt;RFC 1123&lt;/a&gt; 과도 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8eab074e1c7ffcac7682224edeb76f35f174906a" translate="yes" xml:space="preserve">
          <source>This is because a &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;Reference&lt;/a&gt;&lt;/code&gt;'s memory is allocated on the heap and a pointer to it is passed around. The size of a class on the heap can be determined using &lt;code&gt;&lt;a href=&quot;toplevel#instance_sizeof(type:Class):Int32-class-method&quot;&gt;#instance_sizeof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;Reference&lt;/a&gt;&lt;/code&gt; 의 메모리가 힙에 할당되고 이에 대한 포인터가 전달되기 때문입니다. 힙에있는 클래스의 크기는 &lt;code&gt;&lt;a href=&quot;toplevel#instance_sizeof(type:Class):Int32-class-method&quot;&gt;#instance_sizeof&lt;/a&gt;&lt;/code&gt; 를 사용하여 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c68376c0667e18f7a382b86a544065d7e53d580b" translate="yes" xml:space="preserve">
          <source>This is because a Reference's memory is allocated on the heap and a pointer to it is passed around. To get the effective size of a class, use &lt;a href=&quot;instance_sizeof&quot;&gt;instance_sizeof&lt;/a&gt;.</source>
          <target state="translated">이는 Reference의 메모리가 힙에 할당되고 이에 대한 포인터가 전달되기 때문입니다. 클래스의 유효 크기를 얻으려면 &lt;a href=&quot;instance_sizeof&quot;&gt;instance_sizeof를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eca2fa8fad65eb1231ee4c3f04f7c430eebc7ac" translate="yes" xml:space="preserve">
          <source>This is because in the first case all spawned fibers refer to the same local variable, while in the second example copies of &lt;em&gt;i&lt;/em&gt; are passed to a &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; that eventually invokes the call.</source>
          <target state="translated">이는 첫 번째 경우에 생성 된 모든 파이버가 동일한 로컬 변수를 참조하는 반면, 두 번째 예에서 &lt;em&gt;i의&lt;/em&gt; 사본은 결국 호출을 호출 하는 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 로 전달되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="fcd7f3ba18ba9e17570b1b0e53cc1b5e8d8b9512" translate="yes" xml:space="preserve">
          <source>This is because the captured block could have been potentially stored in a class or instance variable and invoked in a separate thread in between the instructions. The compiler doesn't do an exhaustive analysis of this: it just assumes that if a variable is captured by a proc, the time of that proc invocation is unknown.</source>
          <target state="translated">캡처 된 블록이 클래스 또는 인스턴스 변수에 저장되어 명령 사이의 별도 스레드에서 호출 될 수 있기 때문입니다. 컴파일러는 이것에 대한 철저한 분석을 수행하지 않습니다. 변수가 proc에 의해 캡처되면 해당 proc 호출 시간을 알 수 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fd54023c6204f1d90016305f2a3d17147b84f8e2" translate="yes" xml:space="preserve">
          <source>This is because when you invoke &lt;code&gt;add&lt;/code&gt;, it is instantiated with the types of the arguments: every method invocation with a different type combination results in a different method instantiation.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 호출 할 때 인수의 유형으로 인스턴스화 되기 때문 입니다. 다른 유형 조합을 사용하는 모든 메소드 호출은 다른 메소드 인스턴스화를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="af7abaf72beea84936719d7cea52eba04777347e" translate="yes" xml:space="preserve">
          <source>This is better understood with an example:</source>
          <target state="translated">이것은 예제를 통해 더 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="b18c7290adfec84504b1a4877c69b353776ca115" translate="yes" xml:space="preserve">
          <source>This is done automatically when &lt;code&gt;crystal tool format&lt;/code&gt; is invoked, which will automatically format all &lt;code&gt;.cr&lt;/code&gt; files in current directory.</source>
          <target state="translated">때 자동으로 이루어집니다 &lt;code&gt;crystal tool format&lt;/code&gt; 자동으로 모든 포맷되는, 호출 &lt;code&gt;.cr&lt;/code&gt; 의 현재 디렉토리에있는 파일을.</target>
        </trans-unit>
        <trans-unit id="e59cd3a6458de6c686b54b8d0400a89e9b601941" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;sleep 0.seconds&lt;/code&gt;. It gives the scheduler an option to interrupt the current fiber's execution. If no other fibers are ready to be resumed, it immediately resumes the current fiber.</source>
          <target state="translated">이것은 &lt;code&gt;sleep 0.seconds&lt;/code&gt; 와 동일합니다 . 스케줄러에게 현재 광섬유의 실행을 중단하는 옵션을 제공합니다. 재개 할 준비가 된 다른 광 섬유가 없으면 즉시 현재 광 섬유를 재개합니다.</target>
        </trans-unit>
        <trans-unit id="91073a8ebd255c745f3396ef35b162c27b3bb870" translate="yes" xml:space="preserve">
          <source>This is equivalent to creating a &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; from the time-of-day fields:</source>
          <target state="translated">이것은 시간 필드에서 &lt;code&gt;&lt;a href=&quot;time/span&quot;&gt;Time::Span&lt;/a&gt;&lt;/code&gt; 을 작성하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bba1b6acebcc63f3157a11d36c9e5fc224d8357e" translate="yes" xml:space="preserve">
          <source>This is essentially a &lt;code&gt;&lt;a href=&quot;methods#before_all(&amp;amp;block)-instance-method&quot;&gt;#before_all&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;methods#after_all(&amp;amp;block)-instance-method&quot;&gt;#after_all&lt;/a&gt;&lt;/code&gt; hook combined into one. It is useful for example when setup and teardown steps need shared state.</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;&lt;a href=&quot;methods#before_all(&amp;amp;block)-instance-method&quot;&gt;#before_all&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;methods#after_all(&amp;amp;block)-instance-method&quot;&gt;#after_all&lt;/a&gt;&lt;/code&gt; 후크가 하나로 결합 된 것입니다. 예를 들어 설정 및 해체 단계에 공유 상태가 필요할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63941e9cd5a357b71dbeada9aac198d75d33cb45" translate="yes" xml:space="preserve">
          <source>This is essentially a &lt;code&gt;&lt;a href=&quot;methods#before_each(&amp;amp;block)-instance-method&quot;&gt;#before_each&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;methods#after_each(&amp;amp;block)-instance-method&quot;&gt;#after_each&lt;/a&gt;&lt;/code&gt; hook combined into one. It is useful for example when setup and teardown steps need shared state.</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;&lt;a href=&quot;methods#before_each(&amp;amp;block)-instance-method&quot;&gt;#before_each&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;methods#after_each(&amp;amp;block)-instance-method&quot;&gt;#after_each&lt;/a&gt;&lt;/code&gt; 후크가 하나로 결합 된 것입니다. 예를 들어 설정 및 해체 단계에 공유 상태가 필요할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dfca88e8493ed6d6c8920bcc9d7e06f379cc0d79" translate="yes" xml:space="preserve">
          <source>This is everything you can know about an object: its type and whether it responds to some method.</source>
          <target state="translated">이것은 객체에 대해 알 수있는 모든 것입니다. 객체의 유형과 일부 메서드에 응답하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="664081d7cf972a751025c22c5dc7255042548b08" translate="yes" xml:space="preserve">
          <source>This is for example useful for deconstructing union types:</source>
          <target state="translated">예를 들어 유니온 유형을 해체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79f0d29001d1769f206501b875fe2a4be959d263" translate="yes" xml:space="preserve">
          <source>This is implemented with &lt;code&gt;&lt;a href=&quot;http/client#before_request(&amp;amp;callback:HTTP::Request-%3E)-instance-method&quot;&gt;HTTP::Client#before_request&lt;/a&gt;&lt;/code&gt; to add an authorization header to every request.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;http/client#before_request(&amp;amp;callback:HTTP::Request-%3E)-instance-method&quot;&gt;HTTP::Client#before_request&lt;/a&gt;&lt;/code&gt; 구현됩니다. 모든 요청에 ​​인증 헤더를 추가하기 위해 로 .</target>
        </trans-unit>
        <trans-unit id="93c98b3533b696f4b265f2ddae4194beb8d972a7" translate="yes" xml:space="preserve">
          <source>This is just one type (Array) and one operation (assignment), the logic of the above will be applied differently for other types and assignments, in general &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;Covariance and Contravariance&lt;/a&gt; is not fully supported.</source>
          <target state="translated">이것은 하나의 유형 (배열)과 하나의 작업 (할당)이며 위의 논리는 일반적으로 다른 유형 및 할당에 대해 다르게 적용됩니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;&lt;/a&gt; 됩니다. 공분산 및 공분산 은 완전히 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce0c6cf5aa7169f819d2d736ee90776ca387cefc" translate="yes" xml:space="preserve">
          <source>This is mostly useful with local variables that change at iterations. This doesn't happen with block arguments. For example, this works as expected:</source>
          <target state="translated">이것은 주로 반복에서 변경되는 지역 변수에 유용합니다. 이것은 블록 인수에서 발생하지 않습니다. 예를 들어, 이것은 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5a0992e1a80d3e4aab5a27e49eddb6a4c8048563" translate="yes" xml:space="preserve">
          <source>This is particularly useful if a number can have a wide value range and the &lt;em&gt;exact&lt;/em&gt; value is less relevant.</source>
          <target state="translated">숫자가 넓은 범위와 &lt;em&gt;정확한&lt;/em&gt; 값을 가질 수있는 경우에 특히 유용합니다&lt;em&gt;&lt;/em&gt; 값이 관련이없는 .</target>
        </trans-unit>
        <trans-unit id="5364ea4cf5554cdeb55193ac67c0fb4222bb4698" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; but RFC 3339 defines a more strict format. In ISO 8601 for examples, field delimiters (&lt;code&gt;&lt;a href=&quot;time#-(other:Time):Time::Span-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;) are optional.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 RFC 3339는보다 엄격한 형식을 정의합니다. 예를 들어 ISO 8601에서 필드 구분 기호 ( &lt;code&gt;&lt;a href=&quot;time#-(other:Time):Time::Span-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; ) 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="52223d3b04e04f466e8a8705f6a156d0834f52fc" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; but RFC 3339 defines a more strict format. In ISO 8601 for examples, field delimiters (&lt;code&gt;&lt;a href=&quot;time#-(span:Time::MonthSpan):Time-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;) are optional.</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;time#parse_rfc3339(time:String)-class-method&quot;&gt;.parse_rfc3339&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 RFC 3339는보다 엄격한 형식을 정의합니다. 예, 필드 구분 기호에 대한 ISO 8601 년 ( &lt;code&gt;&lt;a href=&quot;time#-(span:Time::MonthSpan):Time-instance-method&quot;&gt;#-&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; ) 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="250bf5a8b00d1f7cd791eee40b73a5cf04cfc0a2" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;&lt;a href=&quot;zone#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; time zone with offset &lt;code&gt;+00:00&lt;/code&gt;.</source>
          <target state="translated">이것은 오프셋이 &lt;code&gt;+00:00&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;zone#UTC&quot;&gt;UTC&lt;/a&gt;&lt;/code&gt; 시간대입니다 .</target>
        </trans-unit>
        <trans-unit id="8048727c8234993d8a5603cf23d4eb243123a864" translate="yes" xml:space="preserve">
          <source>This is the base class of all AST nodes. This methods are available to all AST nodes.</source>
          <target state="translated">이것은 모든 AST 노드의 기본 클래스입니다. 이 방법은 모든 AST 노드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98b840bba8d77d2469d9697df6f696e784ce6c1c" translate="yes" xml:space="preserve">
          <source>This is the formal specification of method and call arguments.</source>
          <target state="translated">이것은 메소드 및 호출 인수의 공식 스펙입니다.</target>
        </trans-unit>
        <trans-unit id="3a96f07459b7208207e134ed71189ac50df50dea" translate="yes" xml:space="preserve">
          <source>This is the language reference for the Crystal programming language.</source>
          <target state="translated">Crystal 프로그래밍 언어의 언어 참조입니다.</target>
        </trans-unit>
        <trans-unit id="545dbbaa58655b1b054f6a7d8c72f5c89bb6c9d0" translate="yes" xml:space="preserve">
          <source>This is the only unsafe type in Crystal. If you are using a pointer, you are writing unsafe code because a pointer doesn't know where it's pointing to nor how much memory starting from it is valid. However, pointers make it possible to interface with C and to implement efficient data structures. For example, both &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; are implemented using pointers.</source>
          <target state="translated">Crystal에서 유일하게 안전하지 않은 유형입니다. 포인터를 사용하는 경우 포인터가 가리키는 위치 나 포인터가 유효한 메모리 양을 알 수 없으므로 안전하지 않은 코드를 작성하는 것입니다. 그러나 포인터를 사용하면 C와 인터페이스하고 효율적인 데이터 구조를 구현할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt;&lt;/code&gt; 는 모두 포인터를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4515edf50a067229e0e7eda1b93dee9d3077b41c" translate="yes" xml:space="preserve">
          <source>This is the same as using &lt;code&gt;as&lt;/code&gt;, but allows the class to be passed around as an argument. See the &lt;a href=&quot;../../docs/syntax_and_semantics/as&quot;&gt;documentation on as&lt;/a&gt; for more information.</source>
          <target state="translated">이 사용하는 것과 같습니다 &lt;code&gt;as&lt;/code&gt; 하지만, 클래스는 인수로 건네 줄 수가 있습니다. 자세한 내용은 &lt;a href=&quot;../../docs/syntax_and_semantics/as&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc2db5d64c33ec2d824900edde2cb9c586a6ad28" translate="yes" xml:space="preserve">
          <source>This is then safe to pass as part of the command when using &lt;code&gt;shell: true&lt;/code&gt; or &lt;code&gt;system()&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;shell: true&lt;/code&gt; 또는 &lt;code&gt;system()&lt;/code&gt; 사용할 때 명령의 일부로 전달해도 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="eea165f9532b9c9354b0282961da26042d18ca1c" translate="yes" xml:space="preserve">
          <source>This is then safe to pass to a POSIX shell.</source>
          <target state="translated">그러면 POSIX 셸로 전달해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="39052dac05dacfea2b321976622c6881f8fee6d2" translate="yes" xml:space="preserve">
          <source>This is useful for exposing part of an underlying stream to a client.</source>
          <target state="translated">이것은 기본 스트림의 일부를 클라이언트에 노출시키는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40d1de068db96b91cef4b055764a503963b9cf23" translate="yes" xml:space="preserve">
          <source>This is useful for two reasons:</source>
          <target state="translated">두 가지 이유로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d89f4023c0e9b9c432dcbf2c74989c25293766ca" translate="yes" xml:space="preserve">
          <source>This is very convenient in &lt;code&gt;case&lt;/code&gt; expressions:</source>
          <target state="translated">다음과 같은 &lt;code&gt;case&lt;/code&gt; 매우 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="0a50b57903b64f2c7c8a3d039dbee7449f283aac" translate="yes" xml:space="preserve">
          <source>This is very useful for defining wrappers of C types without having to explicitly transform them to their wrapped values.</source>
          <target state="translated">이는 래핑 된 값으로 명시 적으로 변환하지 않고 C 유형의 래퍼를 정의 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ff9edea32baf1a3bdb16cc51fbf9af7d8477d4c" translate="yes" xml:space="preserve">
          <source>This list is sorted by precedence, so upper entries bind stronger than lower ones.</source>
          <target state="translated">이 목록은 우선 순위에 따라 정렬되므로 상위 항목은 하위 항목보다 더 강력하게 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="64848e0279f58a2eb76664c7ab73ea64be03b44b" translate="yes" xml:space="preserve">
          <source>This list represents version 5.4 of the intermediate configuration available at https://ssl-config.mozilla.org/guidelines/5.4.json.</source>
          <target state="translated">이 목록은 https://ssl-config.mozilla.org/guidelines/5.4.json에서 사용 가능한 중간 구성의 버전 5.4를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aaf9e6c6eddc2b3bf36927462d1a0da634ae14d8" translate="yes" xml:space="preserve">
          <source>This list represents version 5.4 of the modern configuration available at https://ssl-config.mozilla.org/guidelines/5.4.json.</source>
          <target state="translated">이 목록은 https://ssl-config.mozilla.org/guidelines/5.4.json에서 사용 가능한 최신 구성의 버전 5.4를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4457be54a4d18cef857e53c4a4056932ba0e1e3d" translate="yes" xml:space="preserve">
          <source>This list represents version 5.4 of the old configuration available at https://ssl-config.mozilla.org/guidelines/5.4.json.</source>
          <target state="translated">이 목록은 https://ssl-config.mozilla.org/guidelines/5.4.json에서 사용 가능한 이전 구성의 버전 5.4를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf97a41abfcb211c83d6d5b49f2e738fde8a0d1a" translate="yes" xml:space="preserve">
          <source>This literal can be used with any type as long as it has an argless constructor and responds to &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">이 리터럴은 argless 생성자가 있고 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 에 응답하는 한 모든 유형에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3b7949166254a30289854bd34a8746a15f08640" translate="yes" xml:space="preserve">
          <source>This literal can be used with any type as long as it has an argless constructor and responds to &lt;code&gt;[]=&lt;/code&gt;.</source>
          <target state="translated">이 리터럴은 argless 생성자가 있고 &lt;code&gt;[]=&lt;/code&gt; 에 응답하는 한 모든 유형에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e04e4dfcae0f1da86f93f68805a481ead2f3cf3" translate="yes" xml:space="preserve">
          <source>This logic also applies if there are ands (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) in the condition:</source>
          <target state="translated">이 논리는 조건에 ands ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; )가있는 경우에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e0d40403d0fb3af87493347eb75affb4d82e65c" translate="yes" xml:space="preserve">
          <source>This looks up &quot;filename&quot; in the require path.</source>
          <target state="translated">이것은 필수 경로에서 &quot;파일 이름&quot;을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="02b666351739e8df630e195dd5876f8ab2fbf2d7" translate="yes" xml:space="preserve">
          <source>This looks up &quot;filename&quot; relative to the file containing the require expression.</source>
          <target state="translated">필수 표현식이 포함 된 파일을 기준으로 &quot;파일 이름&quot;을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2ab59e555766a52026ea5b3d2c2a19fd4e20a6af" translate="yes" xml:space="preserve">
          <source>This looks very fancy, but is it as fast as a C for loop? The answer is: yes!</source>
          <target state="translated">이것은 매우 멋져 보이지만 C for 루프만큼 빠릅니다. 대답은 : 예!</target>
        </trans-unit>
        <trans-unit id="8b6184f21171f25107a2ac683d8c6894f82542b9" translate="yes" xml:space="preserve">
          <source>This macro also declares instance variables of the types given in the mapping.</source>
          <target state="translated">이 매크로는 매핑에 지정된 유형의 인스턴스 변수도 선언합니다.</target>
        </trans-unit>
        <trans-unit id="b2d0d78d660060de2cbed03d7173e382c1204b9d" translate="yes" xml:space="preserve">
          <source>This macro also provides a &lt;code&gt;copy_with&lt;/code&gt; method which returns a copy of the record with the provided properties altered.</source>
          <target state="translated">이 매크로는 제공된 속성이 변경된 레코드의 복사본을 반환 하는 &lt;code&gt;copy_with&lt;/code&gt; 메서드 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d81c22d82ab054ab6073357b0043598ce14efbcc" translate="yes" xml:space="preserve">
          <source>This macro by default defines getters and setters for each variable (this can be overrided with &lt;em&gt;setter&lt;/em&gt; and &lt;em&gt;getter&lt;/em&gt;). The mapping doesn't define a constructor accepting these variables as arguments, but you can provide an overload.</source>
          <target state="translated">이 매크로는 기본적으로 각 변수에 대한 getter 및 setter를 정의합니다 ( &lt;em&gt;setter&lt;/em&gt; 및 &lt;em&gt;getter&lt;/em&gt; 로 대체 할 수 있음 ). 매핑은 이러한 변수를 인수로 허용하는 생성자를 정의하지 않지만 오버로드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49b61072cd1f4d994675e912b4c5252a36758cb" translate="yes" xml:space="preserve">
          <source>This method allocates memory for the slice copy and duplicates the values.</source>
          <target state="translated">이 방법은 슬라이스 사본에 메모리를 할당하고 값을 복제합니다.</target>
        </trans-unit>
        <trans-unit id="1fc1ff3b014b53619b8bfb952dda2082d153d03a" translate="yes" xml:space="preserve">
          <source>This method allocates memory for the slice copy and stores the return values from calling &lt;code&gt;&lt;a href=&quot;slice#clone-instance-method&quot;&gt;#clone&lt;/a&gt;&lt;/code&gt; on each item.</source>
          <target state="translated">이 메소드는 슬라이스 사본에 메모리를 할당 하고 각 항목 에서 &lt;code&gt;&lt;a href=&quot;slice#clone-instance-method&quot;&gt;#clone&lt;/a&gt;&lt;/code&gt; 을 호출하여 리턴 값을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="3ffc762b0fa54672474374b2e8dff624af1fbed0" translate="yes" xml:space="preserve">
          <source>This method allows creating a &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; of chars.</source>
          <target state="translated">이 방법은 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; 문자의합니다.</target>
        </trans-unit>
        <trans-unit id="de40eee84880ab1581a5f5076ca5d5b101ef5a29" translate="yes" xml:space="preserve">
          <source>This method also accepts &lt;code&gt;0&lt;/code&gt; to identify &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt;&lt;/code&gt; in order to be compliant with the &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt; = 0&lt;/code&gt; numbering. All other days are equal in both formats.</source>
          <target state="translated">이 방법은 또한 &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt; = 0&lt;/code&gt; = 0 번호 매기기를 준수하기 위해 &lt;code&gt;&lt;a href=&quot;dayofweek#Sunday&quot;&gt;Sunday&lt;/a&gt;&lt;/code&gt; 을 식별하기 위해 &lt;code&gt;0&lt;/code&gt; 을 허용 합니다. 다른 모든 요일은 두 형식 모두에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a804975c90be266f4bd9934431ac6b0117a7a3c1" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;#reset&lt;/code&gt; to remove any previous settings and writes the given &lt;em&gt;status&lt;/em&gt; and &lt;em&gt;message&lt;/em&gt; to the response IO. Finally, it closes the response.</source>
          <target state="translated">이 메소드는 &lt;code&gt;#reset&lt;/code&gt; 을 호출 하여 이전 설정을 제거하고 주어진 &lt;em&gt;상태&lt;/em&gt; 와 &lt;em&gt;메시지&lt;/em&gt; 를 응답 IO에 씁니다 . 마지막으로 응답을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="876ed2a7e2571907a92804ebfdfb5c32fcf2d101" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;@wrapped&lt;a href=&quot;server#accept:OpenSSL::SSL::Socket::Server-instance-method&quot;&gt;.accept&lt;/a&gt;&lt;/code&gt; and wraps the resulting IO in a SSL socket (&lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt;) with &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">이 메소드는 &lt;code&gt;@wrapped&lt;a href=&quot;server#accept:OpenSSL::SSL::Socket::Server-instance-method&quot;&gt;.accept&lt;/a&gt;&lt;/code&gt; 호출 하고 결과 IO 를 &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; 구성 을 사용하여 SSL 소켓 ( &lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt; )에 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="80fa8b3ce296002e2382ec789a479a1aec82c056" translate="yes" xml:space="preserve">
          <source>This method calls &lt;code&gt;@wrapped&lt;a href=&quot;server#accept?:OpenSSL::SSL::Socket::Server?-instance-method&quot;&gt;.accept?&lt;/a&gt;&lt;/code&gt; and wraps the resulting IO in a SSL socket (&lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt;) with &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">이 메소드는 &lt;code&gt;@wrapped&lt;a href=&quot;server#accept?:OpenSSL::SSL::Socket::Server?-instance-method&quot;&gt;.accept?&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;server#context:OpenSSL::SSL::Context::Server-instance-method&quot;&gt;#context&lt;/a&gt;&lt;/code&gt; 구성을 사용 하여 결과 IO를 SSL 소켓 ( &lt;code&gt;&lt;a href=&quot;socket/server&quot;&gt;OpenSSL::SSL::Socket::Server&lt;/a&gt;&lt;/code&gt; )에 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="110bbb23114f80368a621ef48c06272849dba2f9" translate="yes" xml:space="preserve">
          <source>This method can also be used to write the name of an object field.</source>
          <target state="translated">이 방법을 사용하여 객체 필드의 이름을 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43eccd5c568a2a2f76820b8c8229fa24a237d06" translate="yes" xml:space="preserve">
          <source>This method can be invoked if you need to define a custom main (as in C main) function, doing all the above steps.</source>
          <target state="translated">위의 모든 단계를 수행하여 C 기본에서와 같이 사용자 정의 기본 기능을 정의해야하는 경우이 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c49154a6dfeb600685b04ea81731ffbadfa9d7" translate="yes" xml:space="preserve">
          <source>This method can be used to manually fail an example defined in an &lt;code&gt;#it&lt;/code&gt; block.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;#it&lt;/code&gt; 블록에 정의 된 예제를 수동으로 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7ab759482e3724d677024c80dfa4d1df68a0b87" translate="yes" xml:space="preserve">
          <source>This method can only be called once and raises &lt;code&gt;&lt;a href=&quot;finalizederror&quot;&gt;FinalizedError&lt;/a&gt;&lt;/code&gt; on subsequent calls.</source>
          <target state="translated">이 메서드는 한 번만 호출 할 수 있으며 후속 호출에서 &lt;code&gt;&lt;a href=&quot;finalizederror&quot;&gt;FinalizedError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8a3b403803b3e2898c855162b3d133ab7e6aaad3" translate="yes" xml:space="preserve">
          <source>This method changes the time zone and retains the instant, which will usually result in a different representation of local date-time (unless both locations have the same offset).</source>
          <target state="translated">이 방법은 시간대를 변경하고 순간을 유지하므로 일반적으로 현지 날짜-시간이 다르게 표시됩니다 (두 위치가 동일한 오프셋을 갖지 않는 한).</target>
        </trans-unit>
        <trans-unit id="71254f8f1f1ac03231cb7a3a2658052200785c63" translate="yes" xml:space="preserve">
          <source>This method enables some customization, but typical use cases can be implemented by either &lt;code&gt;&lt;a href=&quot;uri#decode(string:String,*,plus_to_space:Bool=false):String-class-method&quot;&gt;.decode(string : String, *, plus_to_space : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;.deode_www_form(string : String, *, plus_to_space : Bool = true) : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 방법을 사용하면 약간의 사용자 정의가 가능하지만 일반적인 사용 사례는 &lt;code&gt;&lt;a href=&quot;uri#decode(string:String,*,plus_to_space:Bool=false):String-class-method&quot;&gt;.decode(string : String, *, plus_to_space : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;.deode_www_form(string : String, *, plus_to_space : Bool = true) : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구현할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="66fb97869fc5212ab96dadd23532f875642eb2d8" translate="yes" xml:space="preserve">
          <source>This method enables some customization, but typical use cases can be implemented by either &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,*,space_to_plus:Bool=false):String-class-method&quot;&gt;.encode(string : String, *, space_to_plus : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form(string : String, *, space_to_plus : Bool = true)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 방법을 사용하면 약간의 사용자 정의가 가능하지만 일반적인 사용 사례는 &lt;code&gt;&lt;a href=&quot;uri#encode(string:String,*,space_to_plus:Bool=false):String-class-method&quot;&gt;.encode(string : String, *, space_to_plus : Bool = false)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;uri#encode_www_form(string:String,*,space_to_plus:Bool=true):String-class-method&quot;&gt;.encode_www_form(string : String, *, space_to_plus : Bool = true)&lt;/a&gt; : &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구현할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="543c64a9546cd1816d1a00aa3905da29065cb26c" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt; because it behaves unpredictably when the given &lt;code&gt;type&lt;/code&gt; doesn't have the same bytesize as the receiver, or when the given &lt;code&gt;type&lt;/code&gt; representation doesn't semantically match the underlying bytes.</source>
          <target state="translated">이 메소드는 주어진 &lt;code&gt;type&lt;/code&gt; 이 수신자와 동일한 바이트 크기를 갖지 않거나 주어진 &lt;code&gt;type&lt;/code&gt; 표시가 기본적으로 바이트와 일치하지 않을 때 예상치 않게 작동하기 때문에 &lt;strong&gt;안전&lt;/strong&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5cbc5a629094572b5cae34df050919f9fe50bca" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt; because it returns a pointer, and the pointed might eventually not be that of &lt;code&gt;self&lt;/code&gt; if the array grows and its internal buffer is reallocated.</source>
          <target state="translated">이 메소드는 포인터를 리턴하기 때문에 &lt;strong&gt;안전하지&lt;/strong&gt; 않으며 , 배열이 커지고 내부 버퍼가 재 할당 될 경우 결국 &lt;code&gt;self&lt;/code&gt; 것이 아닐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bcfc5121e3fcaeeab6ad40e3bd6aee85d973a99" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt;, but is usually used to initialize the buffer by passing it to a C function.</source>
          <target state="translated">이 메소드는 &lt;strong&gt;안전하지&lt;/strong&gt; 않지만 일반적으로 버퍼를 C 함수에 전달하여 버퍼를 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14321e39d197f6c1679a31b60eb9fba345489c89" translate="yes" xml:space="preserve">
          <source>This method is &lt;strong&gt;unsafe&lt;/strong&gt;: the pointer must point to data that eventually contains a zero byte that indicates the ends of the string. Otherwise, the result of this method is undefined and might cause a segmentation fault.</source>
          <target state="translated">이 방법은 &lt;strong&gt;안전하지 않습니다&lt;/strong&gt; . 포인터는 결국 문자열의 끝을 나타내는 0 바이트를 포함하는 데이터를 가리켜 야합니다. 그렇지 않으면이 메소드의 결과가 정의되지 않아 세그먼트 화 결함이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85f0df7d857e88bebe2fa6338a1727a05b52dcc" translate="yes" xml:space="preserve">
          <source>This method is a unary operator and usually written in prefix notation (&lt;code&gt;!foo&lt;/code&gt;) but it can also be written as a regular method call (&lt;code&gt;foo&lt;a href=&quot;object#!:Bool-instance-method&quot;&gt;.!&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 메서드는 단항 연산자이며 일반적으로 접두사 표기법 ( &lt;code&gt;!foo&lt;/code&gt; )으로 작성되지만 일반 메서드 호출 ( &lt;code&gt;foo&lt;a href=&quot;object#!:Bool-instance-method&quot;&gt;.!&lt;/a&gt;&lt;/code&gt; ) 로 작성 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ab980b8075db8f065c8f6c51a0c2bd59a577ec5" translate="yes" xml:space="preserve">
          <source>This method is always safe to call, and the resulting string will have the contents and size of the slice.</source>
          <target state="translated">이 메소드는 항상 호출하는 것이 안전하며 결과 문자열은 슬라이스의 내용과 크기를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cf8c7ff1e18f6211fa80b57a21af687888058dc1" translate="yes" xml:space="preserve">
          <source>This method is automatically invoked for you, so you don't need to invoke it.</source>
          <target state="translated">이 메소드는 자동으로 호출되므로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="29a475f6a3debf4758fd938d8d77eeedfddd2709" translate="yes" xml:space="preserve">
          <source>This method is equivalent to &lt;code&gt;&lt;a href=&quot;object#is_a?(type:Class):Bool-instance-method&quot;&gt;#is_a?(Nil)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;&lt;a href=&quot;object#is_a?(type:Class):Bool-instance-method&quot;&gt;#is_a?(Nil)&lt;/a&gt;&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1d83bafe31e3643b12d002caba871495df77db30" translate="yes" xml:space="preserve">
          <source>This method is mainly intended to convert integers from C to enums in Crystal.</source>
          <target state="translated">이 방법은 주로 정수에서 C 정수를 열거 형으로 변환하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b7e65fc77b25a08e2a12b71af2dcd0ece534fd6" translate="yes" xml:space="preserve">
          <source>This method is particularly useful to break up tight loops which are only computation intensive and don't offer natural opportunities for swapping fibers as with IO operations.</source>
          <target state="translated">이 방법은 계산 집약적이며 IO 작업 에서처럼 광섬유를 교체 할 수있는 자연스러운 기회를 제공하지 않는 타이트한 루프를 분리하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="10fc8f745b12a33607325325d055ac6d307f9324" translate="yes" xml:space="preserve">
          <source>This method is the inverse operation to &lt;code&gt;&lt;a href=&quot;uri#relativize(uri:URI%7CString):URI-instance-method&quot;&gt;#relativize&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;Resolution and Relativization&lt;/a&gt;).</source>
          <target state="translated">이 방법은 &lt;code&gt;&lt;a href=&quot;uri#relativize(uri:URI%7CString):URI-instance-method&quot;&gt;#relativize&lt;/a&gt;&lt;/code&gt; 에 대한 역 연산입니다 ( &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;해상도 및 관계 화&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="79f2ef5ab90e3a8738a37aed767115a397e15aba" translate="yes" xml:space="preserve">
          <source>This method is the inverse operation to &lt;code&gt;&lt;a href=&quot;uri#resolve(uri:URI%7CString):URI-instance-method&quot;&gt;#resolve&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;Resolution and Relativization&lt;/a&gt;).</source>
          <target state="translated">이 방법은 &lt;code&gt;&lt;a href=&quot;uri#resolve(uri:URI%7CString):URI-instance-method&quot;&gt;#resolve&lt;/a&gt;&lt;/code&gt; 에 대한 역 연산입니다 ( &lt;a href=&quot;#Resolution%20and%20Relativization&quot;&gt;해상도 및 &lt;/a&gt;재배치 참조 ).</target>
        </trans-unit>
        <trans-unit id="a666cc527ca8b43282f1ede4f1744600df5f756b" translate="yes" xml:space="preserve">
          <source>This method is the same as &lt;code&gt;&lt;a href=&quot;stringscanner#scan(pattern)-instance-method&quot;&gt;#scan&lt;/a&gt;&lt;/code&gt;, but without returning the matched string.</source>
          <target state="translated">이 메서드는 &lt;code&gt;&lt;a href=&quot;stringscanner#scan(pattern)-instance-method&quot;&gt;#scan&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 일치하는 문자열을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c8c40735837bf50315a9cfb6667abdad0d7f275" translate="yes" xml:space="preserve">
          <source>This method is the same as &lt;code&gt;&lt;a href=&quot;stringscanner#scan_until(pattern)-instance-method&quot;&gt;#scan_until&lt;/a&gt;&lt;/code&gt;, but without returning the matched string.</source>
          <target state="translated">이 메서드는 &lt;code&gt;&lt;a href=&quot;stringscanner#scan_until(pattern)-instance-method&quot;&gt;#scan_until&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 일치하는 문자열을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bb21be8b188c3a362afbdf538e490cfff2b5a0a" translate="yes" xml:space="preserve">
          <source>This method is typically used in C bindings, where you get a &lt;code&gt;char*&lt;/code&gt; from a library and the library guarantees that this pointer eventually has an ending zero byte.</source>
          <target state="translated">이 메소드는 일반적으로 라이브러리에서 &lt;code&gt;char*&lt;/code&gt; 가져 오는 라이브러리 에서 C 바인딩에 사용되며 라이브러리는이 포인터에 결국 0 바이트가 있음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="bc47d62663f52dafb03da6c2b69547adb50f68fa" translate="yes" xml:space="preserve">
          <source>This method is useful for dealing with nilable types, to safely perform operations only when the value is not &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 nilable 유형을 처리하고 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 안전하게 작업을 수행하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d52e6cffffcfea09e2979e5b48f2c15d49e1eac0" translate="yes" xml:space="preserve">
          <source>This method is useful in macros and generic code because with it you can create empty tuples, something that you can't do with a tuple literal.</source>
          <target state="translated">이 방법은 매크로와 일반 코드에 유용합니다. 빈 튜플을 만들 수 있기 때문에 튜플 리터럴로는 할 수없는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e189ba2199c84eed3718c288cd96471cb504b30" translate="yes" xml:space="preserve">
          <source>This method is useful in macros and generic code because with it you can creates empty named tuples, something that you can't do with a tuple literal.</source>
          <target state="translated">이 방법은 매크로와 일반 코드에 유용합니다.이 방법을 사용하면 비어있는 명명 된 튜플을 만들 수 있으므로 튜플 리터럴로는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c912bee98c99ac38403dfcb10a3bd634650f827b" translate="yes" xml:space="preserve">
          <source>This method is useful to treat a type that is represented as a chunk of bytes as another type where those bytes convey useful information. As an example, you can check the individual bytes of an &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 방법은 바이트 단위로 표시되는 유형을 유용한 정보를 전달하는 다른 유형으로 취급하는 데 유용합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 의 개별 바이트를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19eea505855cc0210c1b92472e2a60293b570c37" translate="yes" xml:space="preserve">
          <source>This method isn't usually used directly. Instead, &lt;code&gt;&lt;a href=&quot;box#box(r:Reference?):Pointer(Void)-class-method&quot;&gt;Box.box&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">이 방법은 일반적으로 직접 사용되지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;box#box(r:Reference?):Pointer(Void)-class-method&quot;&gt;Box.box&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1197afc812e6fc70baa998134563bed7f2085c44" translate="yes" xml:space="preserve">
          <source>This method must have the property that &lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;a&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메소드에는 &lt;code&gt;a == b&lt;/code&gt; &lt;code&gt;a&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;entry#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt; 암시 하는 특성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="47729461eef607d08960810a64f22def6ef8a562" translate="yes" xml:space="preserve">
          <source>This method must have the property that &lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;a&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메소드에는 &lt;code&gt;a == b&lt;/code&gt; &lt;code&gt;a&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt; == b&lt;a href=&quot;object#hash-instance-method&quot;&gt;.hash&lt;/a&gt;&lt;/code&gt; 암시 하는 특성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8a90186c6146674e3e7ef361cc7cc1b26068df08" translate="yes" xml:space="preserve">
          <source>This method only performs a read to return peek data if the current buffer is empty: otherwise no read is performed and whatever is in the buffer is returned.</source>
          <target state="translated">이 메소드는 현재 버퍼가 비어있는 경우 읽기 데이터 만 리턴하여 읽기를 수행합니다. 그렇지 않으면 읽기가 수행되지 않고 버퍼에있는 모든 것이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2a383fb699dde9e1533f4af7a6692504f3bb02" translate="yes" xml:space="preserve">
          <source>This method returns the same namespaces as &lt;code&gt;&lt;a href=&quot;node#namespace_scopes-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;node#namespace_scopes-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt; 와 동일한 네임 스페이스를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="565497f6eca43074a894d5151d278bb80e8c5904" translate="yes" xml:space="preserve">
          <source>This method returns the same namespaces as &lt;code&gt;&lt;a href=&quot;node#namespace_scopes:Array(Namespace)-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;&lt;a href=&quot;node#namespace_scopes:Array(Namespace)-instance-method&quot;&gt;#namespace_scopes&lt;/a&gt;&lt;/code&gt; 와 동일한 네임 스페이스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4c0089422223e3efc08acb13dca4fc182fc6047a" translate="yes" xml:space="preserve">
          <source>This method should be avoided, unless the string is proven to be ASCII-only (for example &lt;code&gt;&lt;a href=&quot;string#ascii_only?-instance-method&quot;&gt;#ascii_only?&lt;/a&gt;&lt;/code&gt;), or the byte positions are known to be at character boundaries. Otherwise, multi-byte characters may be split, leading to an invalid UTF-8 encoding.</source>
          <target state="translated">문자열이 ASCII 전용 인 것으로 입증 되거나 (예 : &lt;code&gt;&lt;a href=&quot;string#ascii_only?-instance-method&quot;&gt;#ascii_only?&lt;/a&gt;&lt;/code&gt; ) 바이트 위치가 문자 경계에 있다고 알려진 경우가 아니면이 방법은 사용하지 않아야합니다 . 그렇지 않으면 다중 바이트 문자가 분할되어 유효하지 않은 UTF-8 인코딩이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d1ee8cd64f3b3676979d7591c596fc8ed6d870" translate="yes" xml:space="preserve">
          <source>This method should only be directly invoked if you are absolutely sure the index is in bounds, to avoid a bounds check for a small boost of performance.</source>
          <target state="translated">성능이 약간 향상되는 범위 검사를 피하기 위해 인덱스가 범위 내에 있는지 확실하게 확인한 경우에만이 메소드를 직접 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5b1576a5fca213095e97f27f1bbc043c9560882" translate="yes" xml:space="preserve">
          <source>This method should sometimes be called before passing a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to a C function.</source>
          <target state="translated">이 메소드는 때때로 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 전달하기 전에 호출되어야합니다. 을 C 함수에 .</target>
        </trans-unit>
        <trans-unit id="a4e0deb49c8f4340fdd9a131432eaf0af24b6109" translate="yes" xml:space="preserve">
          <source>This method takes into account the possibility that an downcase version of a char might result in multiple chars, like for 'İ', which results in 'i' and a dot mark.</source>
          <target state="translated">이 방법은 문자의 소문자 버전으로 인해 'İ'와 같이 여러 문자가 생겨 'i'와 점이 표시 될 수있는 가능성을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="cc68b5f7db9e81404c09ccaa273be5676eccd6d8" translate="yes" xml:space="preserve">
          <source>This method takes into account the possibility that an upcase version of a char might result in multiple chars, like for 'ﬄ', which results in 'F', 'F' and 'L'.</source>
          <target state="translated">이 방법은 문자의 대문자 버전이 'ﬄ'과 같이 여러 문자를 생성하여 'F', 'F'및 'L'이 될 가능성을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="1e00cd560926f03ce357aa52106e39137e95ab6c" translate="yes" xml:space="preserve">
          <source>This method usually doesn't need to be called explicitly when the default behaviour is expected. It will be called implicitly with &lt;code&gt;load_defaults: true&lt;/code&gt; when a query method is called and the MIME database has not been initialized before.</source>
          <target state="translated">기본 동작이 예상 될 때 일반적으로이 메소드를 명시 적으로 호출 할 필요는 없습니다. 암시 적으로 호출됩니다 &lt;code&gt;load_defaults: true&lt;/code&gt; 됩니다. 쿼리 메소드가 호출되고 MIME 데이터베이스가 이전에 초기화되지 않은 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="3a5edfda3cb0e0e647d156b5a991a6b768edd899" translate="yes" xml:space="preserve">
          <source>This method yields once instead of returning the values, because the IO object yielded to the block is only valid while the block is executing. The IO object will be closed as soon as the block returns. To store the content of the body part for longer than the block, the IO must be read into memory.</source>
          <target state="translated">블록에 생성 된 IO 개체는 블록이 실행되는 동안에 만 유효하므로이 방법은 값을 반환하는 대신 한 번만 생성합니다. 블록이 반환 되 자마자 IO 개체가 닫힙니다. 블록보다 오래 본문 부분의 내용을 저장하려면 IO를 메모리로 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="51e8c2a0cd5329af392ba2518f88ca9cf8a35b80" translate="yes" xml:space="preserve">
          <source>This methods yields the order of magnitude and &lt;code&gt;self&lt;/code&gt; and expects the block to return a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;(&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;, _)&lt;/code&gt; containing the (adjusted) magnitude and unit. The magnitude is typically adjusted to a multiple of &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">이 방법은 크기 및 순서 산출 &lt;code&gt;self&lt;/code&gt; 및 블록이 반환 기대 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;Tuple&lt;/a&gt;(&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;, _)&lt;/code&gt; 제 (조정) 크기 및 단위를 함유한다. 크기는 일반적으로 &lt;code&gt;3&lt;/code&gt; 의 배수로 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="62426ddc1b8c4721acf93078455ae0f39d239320" translate="yes" xml:space="preserve">
          <source>This module also defines a global method &lt;code&gt;&lt;a href=&quot;random#rand:Float64-instance-method&quot;&gt;#rand&lt;/a&gt;&lt;/code&gt;, which &lt;code&gt;&lt;a href=&quot;array#sample(n:Int,random=Random::DEFAULT)-instance-method&quot;&gt;Array#sample&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;array#shuffle(random=Random::DEFAULT)-instance-method&quot;&gt;Array#shuffle&lt;/a&gt;&lt;/code&gt; delegates.</source>
          <target state="translated">이 모듈은 또한 글로벌 방법의 정의 &lt;code&gt;&lt;a href=&quot;random#rand:Float64-instance-method&quot;&gt;#rand&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;array#sample(n:Int,random=Random::DEFAULT)-instance-method&quot;&gt;Array#sample&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;array#shuffle(random=Random::DEFAULT)-instance-method&quot;&gt;Array#shuffle&lt;/a&gt;&lt;/code&gt; 대표를.</target>
        </trans-unit>
        <trans-unit id="4edc0be33dff41532ff7a2c915d58dbe8012b79c" translate="yes" xml:space="preserve">
          <source>This module can be included in any &lt;code&gt;&lt;a href=&quot;exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; subclass that is used to wrap some system error (&lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;WinError&lt;/code&gt;)</source>
          <target state="translated">이 모듈은 일부 시스템 오류 ( &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;WinError&lt;/code&gt; ) 를 래핑하는 데 사용되는 모든 &lt;code&gt;&lt;a href=&quot;exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 하위 클래스에 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75bda1245302220c674f57b233bbd6c1619cbf1b" translate="yes" xml:space="preserve">
          <source>This module conforms to &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC 4180을&lt;/a&gt; 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="f36bf7fc88f3d7e2acf2d7488c604ff22c154e16" translate="yes" xml:space="preserve">
          <source>This module defines a number of methods to create expectations, which are automatically included into the top level namespace.</source>
          <target state="translated">이 모듈은 최상위 네임 스페이스에 자동으로 포함되는 기대치를 만드는 여러 가지 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8ef2aac295915a70eb298437ad90c977a8e82a34" translate="yes" xml:space="preserve">
          <source>This module implements a global MIME registry.</source>
          <target state="translated">이 모듈은 글로벌 MIME 레지스트리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="97ee9e8267f97333d03d6d7ac70d5aec355de137" translate="yes" xml:space="preserve">
          <source>This monotonic clock should always be used for measuring elapsed time.</source>
          <target state="translated">이 단조로운 시계는 항상 경과 시간을 측정하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="76eed7e1078f4676da5877d91557fa7850731a4a" translate="yes" xml:space="preserve">
          <source>This of course also works with the short syntax:</source>
          <target state="translated">이것은 물론 짧은 구문에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bb9ed4011966335dc5ee5afee070bdb3ee3a010c" translate="yes" xml:space="preserve">
          <source>This operates on the instant time-line, such that adding the equivalent of one hour will always be a duration of one hour later. The local date-time representation may change by a different amount, depending on time zone transitions.</source>
          <target state="translated">이는 즉시 타임 라인에서 작동하므로 1 시간에 해당하는 시간을 추가하면 항상 1 시간 후에 지속됩니다. 현지 날짜-시간 표시는 시간대 전환에 따라 다른 양으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689b61b343ffbccdbdcb0fa7201504543e3cd9c8" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenation of the result will be apart by the specified amounts, but the elapsed time between both instances might not equal to the combined default durations This is the case for example when adding a day over a daylight-savings time change:</source>
          <target state="translated">이는 로컬 타임 라인에서 작동하므로 결과의 로컬 날짜-시간 표시가 지정된 양만큼 차이가 나지만 두 인스턴스 간의 경과 시간이 결합 된 기본 지속 시간과 같지 않을 수 있습니다. 예를 들어 일광 절약 시간제 변경으로 하루 추가 :</target>
        </trans-unit>
        <trans-unit id="8054f1719741cee4f425263c3995947f7fa96063" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenations of month and year are decreased by the specified amount.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동하므로 월과 연도의 현지 날짜-시간 표시가 지정된 양만큼 감소합니다.</target>
        </trans-unit>
        <trans-unit id="f79406c77945d14f81970afd66d037ffdbb5eda0" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time represenations of month and year are increased by the specified amount.</source>
          <target state="translated">이것은 현지 타임 라인에서 작동하므로 월과 연도의 현지 날짜-시간 표시가 지정된 양만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="0cba38acc0940abf0c7fbacb6a6afe3ac1c1933e" translate="yes" xml:space="preserve">
          <source>This operates on the local time-line, such that the local date-time representation of the result will be apart by the specified amounts, but the elapsed time between both instances might not equal to the combined default durations This is the case for example when adding a day over a daylight-savings time change:</source>
          <target state="translated">이는 로컬 타임 라인에서 작동하므로 결과의 로컬 날짜-시간 표현이 지정된 양만큼 떨어져 있지만 두 인스턴스 간의 경과 시간이 결합 된 기본 기간과 같지 않을 수 있습니다. 일광 절약 시간제 변경에 하루 추가 :</target>
        </trans-unit>
        <trans-unit id="4dcf0ee2f6fdf3917e32df47707c61c1e54afb89" translate="yes" xml:space="preserve">
          <source>This operation is often useful when constructing a document containing URIs that must be made relative to the base URI of the document wherever possible.</source>
          <target state="translated">이 작업은 가능한 경우 문서의 기본 URI를 기준으로 만들어야하는 URI를 포함하는 문서를 구성 할 때 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="244bd5d3f005fbcff84b4546a3b5a36d42fd938e" translate="yes" xml:space="preserve">
          <source>This overload returns a value whose type is restricted to be not &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">이 오버로드는 유형이 &lt;code&gt;&lt;a href=&quot;../nil&quot;&gt;Nil&lt;/a&gt;&lt;/code&gt; 이 아니도록 제한된 값을 반환합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3ff9c4601b6718642cc9f79cc1c96305eab52780" translate="yes" xml:space="preserve">
          <source>This overload returns a value whose type is restricted to exclude the given type in &lt;code&gt;should_not be_a&lt;/code&gt;. For example:</source>
          <target state="translated">이 오버로드는 &lt;code&gt;should_not be_a&lt;/code&gt; 에 지정된 유형을 제외하도록 유형이 제한된 값을 반환합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2f847bfbabbc47c3bc11bc794d7bda974b507b0c" translate="yes" xml:space="preserve">
          <source>This overload returns a value whose type is restricted to the expected type. For example:</source>
          <target state="translated">이 오버로드는 유형이 예상 유형으로 제한된 값을 반환합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0358a14c793d7b599d3ce27a3c57a46685678281" translate="yes" xml:space="preserve">
          <source>This philosophy of appending to an IO instead of returning an intermediate string results in better performance than handling intermediate strings. You should use this strategy in your API definitions too.</source>
          <target state="translated">중간 문자열을 반환하는 대신 IO에 추가한다는이 철학은 중간 문자열을 처리하는 것보다 성능이 향상됩니다. 이 전략은 API 정의에서도 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="0731dc79f56c5a5399cdd125c11e0e16381f03fa" translate="yes" xml:space="preserve">
          <source>This procedure is usually done with the compiler itself to port it to new platforms where a compiler is not yet available. Because in order to compile a Crystal compiler we need an older Crystal compiler, the only two ways to generate a compiler for a system where there isn't a compiler yet are:</source>
          <target state="translated">이 절차는 보통 컴파일러를 사용하여 아직 컴파일러를 사용할 수없는 새 플랫폼으로 이식하기 위해 수행됩니다. Crystal 컴파일러를 컴파일하려면 구형 Crystal 컴파일러가 필요하기 때문에 아직 컴파일러가없는 시스템의 컴파일러를 생성하는 유일한 두 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4f30c3e0066d3a8e63a8ffbeed56fdd87c8d84a" translate="yes" xml:space="preserve">
          <source>This process can sometimes be ambiguous, mostly due skipping or repeating times at time zone transitions. For example, in &lt;code&gt;America/New_York&lt;/code&gt; the date-time &lt;code&gt;2011-03-13 02:15:00&lt;/code&gt; never occurred, there is a gap between time zones. In return, &lt;code&gt;2011-11-06 01:15:00&lt;/code&gt; occurred twice because of overlapping time zones.</source>
          <target state="translated">이 프로세스는 때때로 시간대 전환시 건너 뛰기 또는 반복 시간으로 인해 모호 할 수 있습니다. 예를 들어, &lt;code&gt;America/New_York&lt;/code&gt; 에서 날짜-시간 &lt;code&gt;2011-03-13 02:15:00&lt;/code&gt; 이 발생하지 않은 경우 시간대간에 차이가 있습니다. 그 대가로 &lt;code&gt;2011-11-06 01:15:00&lt;/code&gt; 시간대가 중복되어 두 번 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="7da89f81a6359e1270db436a8688ea3526540d3d" translate="yes" xml:space="preserve">
          <source>This program will now print &quot;Hello!&quot; for one second and then exit. This is because the &lt;code&gt;sleep&lt;/code&gt; call will schedule the main fiber to be executed in a second, and then executes another &quot;ready to execute&quot; fiber, which in this case is the one above.</source>
          <target state="translated">이 프로그램은 이제 &quot;Hello!&quot;를 인쇄합니다. 잠시 후 종료하십시오. &lt;code&gt;sleep&lt;/code&gt; 때문이다 호출이 메인 파이버가 1 초 안에 실행되도록 예약 한 다음 또 다른 &quot;실행 준비&quot;파이버를 실행하기 때문입니다 (이 경우 위의 것).</target>
        </trans-unit>
        <trans-unit id="74c0ac4de62bc9d3b7a85cce5fd828fd7bb4a2b0" translate="yes" xml:space="preserve">
          <source>This property is not used by &lt;code&gt;&lt;a href=&quot;client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;&lt;a href=&quot;client&quot;&gt;HTTP::Client&lt;/a&gt;&lt;/code&gt; 사용되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="c8794cafe5b797061ff826222c6c552391384571" translate="yes" xml:space="preserve">
          <source>This refers to the key type after brackets in &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt; 의 {} 에서 괄호 뒤에 키 유형을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="c7278b89ebc4f3fabb567a7bd24e0a5313fc445f" translate="yes" xml:space="preserve">
          <source>This refers to the part after brackets in &lt;code&gt;[] of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;[] of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; [] 에서 괄호 뒤의 부분을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="697d7116d5f364c69ea8f55b62982b8f1f4059b9" translate="yes" xml:space="preserve">
          <source>This refers to the part before brackets in &lt;code&gt;MyArray{1, 2, 3}&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;MyArray{1, 2, 3}&lt;/code&gt; 에서 괄호 앞 부분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7bc977bb2fc0b4c01d75516a5a45dde31530727e" translate="yes" xml:space="preserve">
          <source>This refers to the part before brackets in &lt;code&gt;MyHash{'a' =&amp;gt; 1, 'b' =&amp;gt; 2}&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;MyHash{'a' =&amp;gt; 1, 'b' =&amp;gt; 2}&lt;/code&gt; 에서 괄호 앞 부분을 나타 냅니다 { 'a'=&amp;gt; 1, 'b'=&amp;gt; 2}</target>
        </trans-unit>
        <trans-unit id="e5f920536af30024ac5594d12b099fada1081a08" translate="yes" xml:space="preserve">
          <source>This refers to the value type after brackets in &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;{} of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; =&amp;gt; &lt;a href=&quot;../../int32&quot;&gt;Int32&lt;/a&gt; 의 {} 에서 괄호 뒤에 값 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2e61f408c66d2ef06ad806d64eaa7b58ca292228" translate="yes" xml:space="preserve">
          <source>This relative is mostly used inside a project to refer to other files inside it. It is also used to refer to code from &lt;a href=&quot;../guides/testing&quot;&gt;specs&lt;/a&gt;:</source>
          <target state="translated">이 친척은 대부분 프로젝트 내부에서 다른 파일을 참조하기 위해 사용됩니다. 또한 &lt;a href=&quot;../guides/testing&quot;&gt;스펙의&lt;/a&gt; 코드를 참조하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ea34ae3b77ad69c508d28fc2b46f4924528c9b8" translate="yes" xml:space="preserve">
          <source>This report shows the user CPU time, system CPU time, the sum of the user and system CPU times, and the elapsed real time. The unit of time is seconds.</source>
          <target state="translated">이 보고서는 사용자 CPU 시간, 시스템 CPU 시간, 사용자 및 시스템 CPU 시간의 합계 및 경과 된 실시간을 보여줍니다. 시간 단위는 초입니다.</target>
        </trans-unit>
        <trans-unit id="28c2258bbc71d1f49bb9629ab15d81f27a6243cb" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if this string has &lt;code&gt;'\\'&lt;/code&gt; in it.</source>
          <target state="translated">이 문자열에 &lt;code&gt;'\\'&lt;/code&gt; 가 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0d63ed5386acee7fbcae7bcc58193fbf54c6d7a4" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;true&lt;/code&gt; if this string has &lt;code&gt;'\\'&lt;/code&gt; in it. It might not be a back reference, but &lt;code&gt;'\\'&lt;/code&gt; is probably used for back references, so this check is faster than parsing the whole thing.</source>
          <target state="translated">이 문자열에 &lt;code&gt;'\\'&lt;/code&gt; 가 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 역 참조가 아닐 수도 있지만 &lt;code&gt;'\\'&lt;/code&gt; 는 역 참조에 사용될 수 있으므로이 검사는 전체를 구문 분석하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="be08ec13ad9411238deedacbc59aa2fdcd06dff9" translate="yes" xml:space="preserve">
          <source>This rule, and every following rule, will also be applied in methods other than &lt;code&gt;initialize&lt;/code&gt;. For example:</source>
          <target state="translated">이 규칙과 모든 다음 규칙은 &lt;code&gt;initialize&lt;/code&gt; 이외의 방법에도 적용됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35fd6a2d0fbee4824cffb18179c1cc6fe1309793" translate="yes" xml:space="preserve">
          <source>This set must have fewer elements than the &lt;em&gt;other&lt;/em&gt; set, and all of elements in this set must be present in the &lt;em&gt;other&lt;/em&gt; set.</source>
          <target state="translated">이 세트는 &lt;em&gt;다른&lt;/em&gt; 세트 보다 적은 수의 요소를 가져야하며이 세트의 모든 요소는 &lt;em&gt;다른&lt;/em&gt; 세트 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4e39714594b95b24fdb97211c25e93b7a6033812" translate="yes" xml:space="preserve">
          <source>This set must have the same or fewer elements than the &lt;em&gt;other&lt;/em&gt; set, and all of elements in this set must be present in the &lt;em&gt;other&lt;/em&gt; set.</source>
          <target state="translated">이 세트는 &lt;em&gt;다른&lt;/em&gt; 세트 와 같거나 적은 요소를 가져야하며이 세트의 모든 요소가 &lt;em&gt;다른&lt;/em&gt; 세트 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd46145a937322b3092ef850ea2e72579163510e" translate="yes" xml:space="preserve">
          <source>This setups up the GC, invokes your program, rescuing any handled exception, and then runs &lt;code&gt;at_exit&lt;/code&gt; handlers.</source>
          <target state="translated">이것은 GC를 설정하고, 프로그램을 호출하고, 처리 된 예외를 구조 한 다음 &lt;code&gt;at_exit&lt;/code&gt; 핸들러 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="aff6a2d80bc83a410080ff7846bfd3daa91e2627" translate="yes" xml:space="preserve">
          <source>This signals to the scheduler that the fiber is eligible for being resumed the next time it has the opportunity to reschedule to an other fiber. There are no guarantees when that will happen.</source>
          <target state="translated">이는 다음에 다른 광섬유로 일정을 다시 잡을 기회가있을 때 광섬유가 재개 될 자격이 있음을 스케줄러에 알립니다. 그것이 언제 일어날 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d49f58b302655fd388385ae9fd8b219fde17efe" translate="yes" xml:space="preserve">
          <source>This sometimes leads to code that is more natural to read.</source>
          <target state="translated">이것은 때때로 더 자연스러운 코드로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="93bbe2592bf3a8fdab8e221dd33651441190a20c" translate="yes" xml:space="preserve">
          <source>This style is used in the standard library. You can use it in your own project to make it familiar to other developers.</source>
          <target state="translated">이 스타일은 표준 라이브러리에서 사용됩니다. 자신의 프로젝트에서 사용하여 다른 개발자에게 친숙하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3e7e5d2187cbc2ccc0a5384d88c714acaa4e8d6" translate="yes" xml:space="preserve">
          <source>This takes time and, on the other hand, these libraries might not change as often as our application, so it looks like we may cache them and save time.</source>
          <target state="translated">이 작업에는 시간이 걸리며, 반면에 이러한 라이브러리는 애플리케이션만큼 자주 변경되지 않을 수 있으므로 캐시하고 시간을 절약 할 수있는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="f79ff816778bb65cd18c1cfa96c8948218bf293e" translate="yes" xml:space="preserve">
          <source>This tells Travis CI to generate your documentation.</source>
          <target state="translated">그러면 Travis CI가 문서를 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="359fdc4110e121a56bf92d5d6db9ba14ec114d47" translate="yes" xml:space="preserve">
          <source>This tells Travis CI to run your tests. Accordingly with the outcome of this command, Travis CI will return a &lt;a href=&quot;https://docs.travis-ci.com/user/for-beginners/#breaking-the-build&quot;&gt;build status&lt;/a&gt; of &quot;passed&quot;, &quot;errored&quot;, &quot;failed&quot; or &quot;canceled&quot;.</source>
          <target state="translated">Travis CI에 테스트를 실행하도록 지시합니다. 따라서이 명령의 결과에 따라 Travis CI는 &quot;통과&quot;, &quot;오류&quot;, &quot;실패&quot;또는 &quot;취소&quot; 의 &lt;a href=&quot;https://docs.travis-ci.com/user/for-beginners/#breaking-the-build&quot;&gt;빌드 상태&lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="35c7ea27f4db8675a4d025c0b83e21b4e148643b" translate="yes" xml:space="preserve">
          <source>This time &lt;code&gt;Fiber.yield&lt;/code&gt; will tell the scheduler to execute the other fiber. This will print &quot;Hello!&quot; until the standard output blocks (the system call will tell us we have to wait until the output is ready), and then execution continues with the main fiber and the program exits. Here the standard output &lt;em&gt;might&lt;/em&gt; never block so the program will continue executing forever.</source>
          <target state="translated">이번에는 &lt;code&gt;Fiber.yield&lt;/code&gt; 가 스케줄러에게 다른 광섬유를 실행하도록 지시합니다. &quot;Hello!&quot;라고 인쇄됩니다. 표준 출력이 차단 될 때까지 (시스템 호출에서 출력이 준비 될 때까지 기다려야한다는 메시지가 표시됨) 주 광섬유로 실행이 계속되고 프로그램이 종료됩니다. 여기서 표준 출력 &lt;em&gt;은&lt;/em&gt; 절대로 차단되지 않으므로 프로그램은 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="71fb327098b7baf0cc66d1daba9db4e0db057454" translate="yes" xml:space="preserve">
          <source>This topic covers all things related to:</source>
          <target state="translated">이 항목에서는 다음과 관련된 모든 내용을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a01b739b2d64e03fccf6df0598fa7fde0aa0b5d2" translate="yes" xml:space="preserve">
          <source>This type can also be expressed as &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;[3]&lt;/code&gt; (only in type grammar). A typical use case is in combination with &lt;code&gt;uninitialized&lt;/code&gt;:</source>
          <target state="translated">이 유형은 &lt;code&gt;&lt;a href=&quot;int32&quot;&gt;Int32&lt;/a&gt;[3]&lt;/code&gt; 으로 표현 될 수도 있습니다 (문법 유형에서만). 일반적인 사용 사례는 &lt;code&gt;uninitialized&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6229a1a148d5519da2a6720bbf382ade9765c401" translate="yes" xml:space="preserve">
          <source>This uses floored division.</source>
          <target state="translated">이것은 바닥 구분을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b7718aa3828a878d42553e8a71799c5eb9b69d5f" translate="yes" xml:space="preserve">
          <source>This uses truncated division.</source>
          <target state="translated">잘린 나누기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16aca72f740ab8cf3e740de83d1220c1fdd6dc05" translate="yes" xml:space="preserve">
          <source>This way, you can group the different options in an easier to read way.</source>
          <target state="translated">이렇게하면 다양한 옵션을보다 읽기 쉽게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa64b75c35bfed1e3e6a283a8c2f966dab1cb82" translate="yes" xml:space="preserve">
          <source>This will generate a &lt;code&gt;.o&lt;/code&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Object_file&quot;&gt;Object file&lt;/a&gt;) and will print a line with a command to execute on the system we are trying to cross-compile to. For example:</source>
          <target state="translated">이것은 &lt;code&gt;.o&lt;/code&gt; ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Object_file&quot;&gt;Object file&lt;/a&gt; ) 를 생성하고 크로스 컴파일하려는 시스템에서 실행할 명령이있는 줄을 인쇄합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a3848df82fc2fd9b15053b5a8fb1d53ba4f2d64" translate="yes" xml:space="preserve">
          <source>This will initialize &lt;code&gt;@age&lt;/code&gt; to zero in every constructor. This is useful to avoid duplication, but also to avoid the &lt;code&gt;Nil&lt;/code&gt; type when reopening a class and adding instance variables to it.</source>
          <target state="translated">모든 생성자에서 &lt;code&gt;@age&lt;/code&gt; 를 0으로 초기화 합니다. 이는 중복을 피할뿐만 아니라 클래스를 다시 열고 인스턴스 변수를 추가 할 때 &lt;code&gt;Nil&lt;/code&gt; 유형 을 피하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="f6862c62808e64a2961983e12fec5639b646a395" translate="yes" xml:space="preserve">
          <source>This will neither load the internal defaults nor the OS-provided MIME database, only the database at &lt;em&gt;filename&lt;/em&gt; (using &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">내부 기본값이나 OS 제공 MIME 데이터베이스를로드하지 않으며 &lt;em&gt;파일 이름&lt;/em&gt; 의 데이터베이스 ( &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; 사용) 만 로드 합니다.</target>
        </trans-unit>
        <trans-unit id="8e4a064d6bf07aff1893264ade18bd386c01f8fd" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;&lt;a href=&quot;divisionbyzeroerror&quot;&gt;DivisionByZeroError&lt;/a&gt;&lt;/code&gt; if rational is 0 and &lt;em&gt;other&lt;/em&gt; is negative.</source>
          <target state="translated">이것은 올릴 것이다 &lt;code&gt;&lt;a href=&quot;divisionbyzeroerror&quot;&gt;DivisionByZeroError&lt;/a&gt;&lt;/code&gt; 을 합리적는 0이고 경우 &lt;em&gt;다른&lt;/em&gt; 부정적이다.</target>
        </trans-unit>
        <trans-unit id="540e962c82e56e9933ab55514ce46937307ada13" translate="yes" xml:space="preserve">
          <source>This will raise an exception if rational is 0.</source>
          <target state="translated">합리적인 값이 0 인 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d0cf7b07e430ad34c34e0cf85d620cc7694ee5a" translate="yes" xml:space="preserve">
          <source>This will set the exception's callstack if it hasn't been already. Re-raising a previously catched exception won't replace the callstack.</source>
          <target state="translated">예외의 콜 스택이 아직 설정되지 않은 경우이를 설정합니다. 이전에 포착 된 예외를 다시 발생시키는 것은 호출 스택을 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="809c1055c5940964d4d7581463d92e0e6d06f1df" translate="yes" xml:space="preserve">
          <source>This will work for any type, as long as the argument is a pointer of that type (and, of course, as long as the function does fill the value the pointer is pointing to).</source>
          <target state="translated">인수가 해당 유형의 포인터 인 한 (그리고 함수가 포인터가 가리키는 값을 채우는 한) 모든 유형에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fbfcd91687de411957f59850ee0cc89d23d975f4" translate="yes" xml:space="preserve">
          <source>This writes the severity in uppercase and left padded with enough space so all the severities fit</source>
          <target state="translated">이것은 심각도를 대문자로 작성하고 모든 심각도가 맞도록 충분한 공간으로 왼쪽으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="fbf56acd9949ce8c53320dc8f269c4b59f93aa99" translate="yes" xml:space="preserve">
          <source>ThreadLocal is used in the standard library to implement the runtime and shouldn't be needed or used outside it.</source>
          <target state="translated">ThreadLocal은 표준 라이브러리에서 런타임을 구현하는 데 사용되며 외부에서 필요하거나 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e7ba2c5a63488f6f05a58bcd2c92172f79cbad" translate="yes" xml:space="preserve">
          <source>Three base operators test equality:</source>
          <target state="translated">세 가지 기본 연산자가 동등성을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="998f079f3e9b6086578875da92b3d4bf7fe6c208" translate="yes" xml:space="preserve">
          <source>Thus, a &lt;code&gt;type&lt;/code&gt; declaration is useful for opaque types that are created by the C library you are wrapping. An example of this is the C &lt;code&gt;FILE&lt;/code&gt; type, which you can obtain with &lt;code&gt;fopen&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;type&lt;/code&gt; 선언은 줄 바꿈하는 C 라이브러리에서 만든 불투명 한 형식에 유용합니다. 이에 대한 예는 &lt;code&gt;fopen&lt;/code&gt; 으로 얻을 수 있는 C &lt;code&gt;FILE&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="fd6da341ee1e31055bdb0caea844b3bc49547757" translate="yes" xml:space="preserve">
          <source>Time Zones</source>
          <target state="translated">시간대</target>
        </trans-unit>
        <trans-unit id="45f7f84e23d3cbf45aa1ad361f6150ffb2c92505" translate="yes" xml:space="preserve">
          <source>Time#+</source>
          <target state="translated">Time#+</target>
        </trans-unit>
        <trans-unit id="82f05dbf9bd40d142582cbabaf13c9ec714f7fc8" translate="yes" xml:space="preserve">
          <source>Time#-</source>
          <target state="translated">Time#-</target>
        </trans-unit>
        <trans-unit id="59b32578d4ec6a3cc2791de03553ad374274f316" translate="yes" xml:space="preserve">
          <source>Time#==</source>
          <target state="translated">Time#==</target>
        </trans-unit>
        <trans-unit id="f2feb8d3a9f9729c7dd237750cf97897794db323" translate="yes" xml:space="preserve">
          <source>Time#date</source>
          <target state="translated">Time#date</target>
        </trans-unit>
        <trans-unit id="0b05268d69de72bf3cf71eb5d37bad28df9f4d08" translate="yes" xml:space="preserve">
          <source>Time#day</source>
          <target state="translated">Time#day</target>
        </trans-unit>
        <trans-unit id="05b0096476e0652794d07097242aab93643f47d1" translate="yes" xml:space="preserve">
          <source>Time#hash</source>
          <target state="translated">Time#hash</target>
        </trans-unit>
        <trans-unit id="bbe5b4f8a1918bd78d0f9bd714e6515621591498" translate="yes" xml:space="preserve">
          <source>Time#hour</source>
          <target state="translated">Time#hour</target>
        </trans-unit>
        <trans-unit id="f49e737bf31856a03111c5200f6835d9c041ed09" translate="yes" xml:space="preserve">
          <source>Time#in</source>
          <target state="translated">Time#in</target>
        </trans-unit>
        <trans-unit id="9a4fe8b3bc5da5b531b4d49404f6219c94b730de" translate="yes" xml:space="preserve">
          <source>Time#to_s</source>
          <target state="translated">Time#to_s</target>
        </trans-unit>
        <trans-unit id="d9d23eef1492cd8ad949d2ff8fad84b96a1a3b02" translate="yes" xml:space="preserve">
          <source>Time#utc?</source>
          <target state="translated">Time#utc?</target>
        </trans-unit>
        <trans-unit id="040f33dd2545d6fa394e0ef9c046c373098a5df7" translate="yes" xml:space="preserve">
          <source>Time#year</source>
          <target state="translated">Time#year</target>
        </trans-unit>
        <trans-unit id="31815efc02346bf97f32722d1e3c12ed1375078e" translate="yes" xml:space="preserve">
          <source>Time#zone</source>
          <target state="translated">Time#zone</target>
        </trans-unit>
        <trans-unit id="d69c277d397226ffd5d29be1efa076fab3595c89" translate="yes" xml:space="preserve">
          <source>Time.new</source>
          <target state="translated">Time.new</target>
        </trans-unit>
        <trans-unit id="e767cb22ffdfe0fac52dd6a3515aa1c63ca17a9f" translate="yes" xml:space="preserve">
          <source>Time.now</source>
          <target state="translated">Time.now</target>
        </trans-unit>
        <trans-unit id="21e0e4ac341fddd059f695dd40bcae69f90c407a" translate="yes" xml:space="preserve">
          <source>Time.unix</source>
          <target state="translated">Time.unix</target>
        </trans-unit>
        <trans-unit id="a9fcd04edaf1c5d8460989020bfddb6579a8bdbd" translate="yes" xml:space="preserve">
          <source>Time.utc</source>
          <target state="translated">Time.utc</target>
        </trans-unit>
        <trans-unit id="f44b0e0a08860f6a162180fdf57208b3bcce3d0d" translate="yes" xml:space="preserve">
          <source>Time::FloatingTimeConversionError</source>
          <target state="translated">Time::FloatingTimeConversionError</target>
        </trans-unit>
        <trans-unit id="7a098ad63e917713957bcae62de5cd5c1c449249" translate="yes" xml:space="preserve">
          <source>Time::Format</source>
          <target state="translated">Time::Format</target>
        </trans-unit>
        <trans-unit id="56710586bed64419abaf48d0f831ee9464ec508c" translate="yes" xml:space="preserve">
          <source>Time::Format::Error</source>
          <target state="translated">Time::Format::Error</target>
        </trans-unit>
        <trans-unit id="baa031128f6b2507a115abee138b00d81a633515" translate="yes" xml:space="preserve">
          <source>Time::Location</source>
          <target state="translated">Time::Location</target>
        </trans-unit>
        <trans-unit id="dc6a2efc72278c880fc60060c2d08d93e23c1e28" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError</source>
          <target state="translated">Time::Location::InvalidLocationNameError</target>
        </trans-unit>
        <trans-unit id="f91332a9279dc7d848b29b5473e36752d4953473" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError#name</source>
          <target state="translated">Time::Location::InvalidLocationNameError#name</target>
        </trans-unit>
        <trans-unit id="a948227bdbd25b65a4e9af5b7b937de5629c59d7" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError#source</source>
          <target state="translated">Time::Location::InvalidLocationNameError#source</target>
        </trans-unit>
        <trans-unit id="4ea7211d3230d3f1ecdc1167c8550e981df7a4db" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidLocationNameError.new</source>
          <target state="translated">Time::Location::InvalidLocationNameError.new</target>
        </trans-unit>
        <trans-unit id="0fdcacac6a1e9187d91ce20efc85545810f229dd" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTZDataError</source>
          <target state="translated">Time::Location::InvalidTZDataError</target>
        </trans-unit>
        <trans-unit id="bc216615b11bf27a3151249129f35639ad5d24a5" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTZDataError.initialize</source>
          <target state="translated">Time::Location::InvalidTZDataError.initialize</target>
        </trans-unit>
        <trans-unit id="65d4d84ecc4be644dad457ad4fafa880dd536fb7" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTimezoneOffsetError</source>
          <target state="translated">Time::Location::InvalidTimezoneOffsetError</target>
        </trans-unit>
        <trans-unit id="19f9453978106d020ce7026eeab03b75ae3add7c" translate="yes" xml:space="preserve">
          <source>Time::Location::InvalidTimezoneOffsetError.new</source>
          <target state="translated">Time::Location::InvalidTimezoneOffsetError.new</target>
        </trans-unit>
        <trans-unit id="29a9bbf22513f625f690aa9a2dd33414751923ef" translate="yes" xml:space="preserve">
          <source>Time::Location::Zone</source>
          <target state="translated">Time::Location::Zone</target>
        </trans-unit>
        <trans-unit id="2be65a98e315e2bb7f266f763512cf37b737e902" translate="yes" xml:space="preserve">
          <source>Time::MonthSpan</source>
          <target state="translated">Time::MonthSpan</target>
        </trans-unit>
        <trans-unit id="8583045f3f38250efb8a738945625c5346eda8aa" translate="yes" xml:space="preserve">
          <source>Time::Span</source>
          <target state="translated">Time::Span</target>
        </trans-unit>
        <trans-unit id="cdc7c35cf55f4f5cb04b709316c1a34f12493114" translate="yes" xml:space="preserve">
          <source>Timeout keyword for use in &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 에서 사용할 시간 초과 키워드입니다 .</target>
        </trans-unit>
        <trans-unit id="5b1360323be02bac91d3fb16b5e60a2642cebe3c" translate="yes" xml:space="preserve">
          <source>Tms#clone</source>
          <target state="translated">Tms#clone</target>
        </trans-unit>
        <trans-unit id="b6b38b40d8ade3a34b035c71c1043de1e9b15483" translate="yes" xml:space="preserve">
          <source>Tms#copy_with</source>
          <target state="translated">Tms#copy_with</target>
        </trans-unit>
        <trans-unit id="237d7decf7e22ee908bb0f7d2580488ded837f85" translate="yes" xml:space="preserve">
          <source>Tms#cstime</source>
          <target state="translated">Tms#cstime</target>
        </trans-unit>
        <trans-unit id="2fc0591049ba9e9822a714f7d969af278d50111d" translate="yes" xml:space="preserve">
          <source>Tms#cutime</source>
          <target state="translated">Tms#cutime</target>
        </trans-unit>
        <trans-unit id="8422313ae0bab325ba717d9618a6e293996e28c7" translate="yes" xml:space="preserve">
          <source>Tms#stime</source>
          <target state="translated">Tms#stime</target>
        </trans-unit>
        <trans-unit id="5662c42e96a18176be559403c86b70887bc97b8f" translate="yes" xml:space="preserve">
          <source>Tms#utime</source>
          <target state="translated">Tms#utime</target>
        </trans-unit>
        <trans-unit id="f34a4c31f00cf9686ba812c79c21089d8e554f3b" translate="yes" xml:space="preserve">
          <source>Tms.new</source>
          <target state="translated">Tms.new</target>
        </trans-unit>
        <trans-unit id="3e157859d37349b0562be4bb6321220fc506e6b4" translate="yes" xml:space="preserve">
          <source>To access a relational database you will need a shard designed for the database server you want to use. The package &lt;a href=&quot;https://github.com/crystal-lang/crystal-db&quot;&gt;crystal-lang/crystal-db&lt;/a&gt; offers a unified api across different drivers.</source>
          <target state="translated">관계형 데이터베이스에 액세스하려면 사용하려는 데이터베이스 서버용으로 설계된 샤드가 필요합니다. &lt;a href=&quot;https://github.com/crystal-lang/crystal-db&quot;&gt;crystal-lang / crystal-db&lt;/a&gt; 패키지 는 다양한 드라이버에서 통일 된 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="afd01e7ef4d7b6612c6ee2c6d02466e6f5171167" translate="yes" xml:space="preserve">
          <source>To access the rescued exception you can specify a variable in the &lt;code&gt;rescue&lt;/code&gt; clause:</source>
          <target state="translated">구조 예외에 액세스하려면 &lt;code&gt;rescue&lt;/code&gt; 절 에서 변수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="485f36f282d6385c195446ef9544721f3cd84e71" translate="yes" xml:space="preserve">
          <source>To accomplish this we are going to use a &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile&lt;/a&gt;:</source>
          <target state="translated">이를 수행하기 위해 &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile&lt;/a&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d11efe79bc139c0303e61a991e7d650d3715247a" translate="yes" xml:space="preserve">
          <source>To achieve concurrency, Crystal has fibers. A fiber is in a way similar to an operating system thread except that it's much more lightweight and its execution is managed internally by the process. So, a program will spawn multiple fibers and Crystal will make sure to execute them when the time is right.</source>
          <target state="translated">동시성을 달성하기 위해 Crystal에는 섬유가 있습니다. 파이버는 운영 체제 스레드와 유사한 방식으로 훨씬 더 가벼우 며 실행은 프로세스에 의해 내부적으로 관리됩니다. 따라서 프로그램은 여러 개의 파이버를 생성하고 Crystal은 시간이 적절할 때이를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="67026b084ea2754e35875e26a4f20b44f35af95e" translate="yes" xml:space="preserve">
          <source>To add a page, create a markdown file in the desired location. Example: &lt;code&gt;overview/hello_world.md&lt;/code&gt;. Then, add a link in the &lt;code&gt;SUMMARY.md&lt;/code&gt; file which acts as the navigation for the language reference.</source>
          <target state="translated">페이지를 추가하려면 원하는 위치에 마크 다운 파일을 만듭니다. 예 : &lt;code&gt;overview/hello_world.md&lt;/code&gt; . 그런 다음 &lt;code&gt;SUMMARY.md&lt;/code&gt; 파일에 언어 참조의 탐색 역할을 하는 링크를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="0b64c6371e377e492837b9076a1171925657b851" translate="yes" xml:space="preserve">
          <source>To add structured information to the message you can use the &lt;code&gt;&lt;a href=&quot;log/context&quot;&gt;Log::Context&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메시지에 구조화 된 정보를 추가하려면 &lt;code&gt;&lt;a href=&quot;log/context&quot;&gt;Log::Context&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fcf706c2c28fa515134ca8b1587dbba1a669bda" translate="yes" xml:space="preserve">
          <source>To address this issues usually a connection pool is a neat solution.</source>
          <target state="translated">이 문제를 해결하려면 일반적으로 연결 풀이 깔끔한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="f68c28137aed34c8af3b6b0d8658e573eb903aa1" translate="yes" xml:space="preserve">
          <source>To automatically link to methods in other types, do &lt;code&gt;OtherType#method(arg1, arg2)&lt;/code&gt; or just &lt;code&gt;OtherType#method&lt;/code&gt;, and enclose it with single backticks.</source>
          <target state="translated">다른 유형의 메소드에 자동으로 링크하려면 &lt;code&gt;OtherType#method(arg1, arg2)&lt;/code&gt; 또는 &lt;code&gt;OtherType#method&lt;/code&gt; 를 수행하고 단일 백틱으로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="581260c43f5d38d9836815f60285c1c4b50711b8" translate="yes" xml:space="preserve">
          <source>To automatically link to methods of the currently documented type, use a hash like &lt;code&gt;#horns&lt;/code&gt; or &lt;code&gt;#index(char)&lt;/code&gt;, and enclose it with single backticks.</source>
          <target state="translated">현재 문서화 된 유형의 메소드에 자동으로 링크하려면 &lt;code&gt;#horns&lt;/code&gt; 또는 &lt;code&gt;#index(char)&lt;/code&gt; 와 같은 해시를 사용하고 단일 백틱으로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="1b0c5080015c4d51b4b12f087aef38376e409c4f" translate="yes" xml:space="preserve">
          <source>To automatically link to other types, enclose them with single backticks.</source>
          <target state="translated">다른 유형에 자동으로 연결하려면 단일 백틱으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="5538505ba55a925f0515271f09e67414b274967a" translate="yes" xml:space="preserve">
          <source>To avoid &lt;a href=&quot;https://owasp.org/www-community/attacks/SQL_Injection&quot;&gt;SQL injection&lt;/a&gt; values can be provided as query parameters. The syntax for using query parameters depends on the database driver because they are typically just passed through to the database. MySQL uses &lt;code&gt;?&lt;/code&gt; for parameter expansion and assignment is based on argument order. PostgreSQL uses &lt;code&gt;$n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the ordinal number of the argument (starting with 1).</source>
          <target state="translated">&lt;a href=&quot;https://owasp.org/www-community/attacks/SQL_Injection&quot;&gt;SQL 주입&lt;/a&gt; 을 방지하기 위해 쿼리 매개 변수로 값을 제공 할 수 있습니다. 쿼리 매개 변수를 사용하는 구문은 일반적으로 데이터베이스로 전달되기 때문에 데이터베이스 드라이버에 따라 다릅니다. MySQL은 &lt;code&gt;?&lt;/code&gt; 매개 변수 확장 및 할당은 인수 순서를 기반으로합니다. PostgreSQL은 &lt;code&gt;$n&lt;/code&gt; 사용합니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 인수의 서수 (1로 시작)입니다.</target>
        </trans-unit>
        <trans-unit id="4c0b6097d8e06f6d4ca904661bd25a30521d1f51" translate="yes" xml:space="preserve">
          <source>To avoid all this boilerplate, the standard library provides a &lt;code&gt;spawn&lt;/code&gt; macro that accepts a call expression and basically rewrites it to do the above. Using it, we end up with:</source>
          <target state="translated">이 상용구를 피하기 위해 표준 라이브러리는 호출 표현식을 허용하고 기본적으로 위의 작업을 수행하도록 다시 &lt;code&gt;spawn&lt;/code&gt; 하는 스폰 매크로를 제공합니다 . 이를 사용하여 다음과 같이 끝납니다.</target>
        </trans-unit>
        <trans-unit id="ba2c1ad65898fb4badaeeacba3a01797c503475c" translate="yes" xml:space="preserve">
          <source>To avoid building LLVM from source (which can take a long time), you can first install it from binary packages if you don't have it installed yet:</source>
          <target state="translated">소스에서 LLVM을 빌드하지 않으려면 (시간이 오래 걸릴 수 있음), 아직 설치하지 않은 경우 바이너리 패키지에서 LLVM을 먼저 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f543192a4e6afdf161421377c7d153c8ec5f89" translate="yes" xml:space="preserve">
          <source>To avoid sql injection use parameters to submit data</source>
          <target state="translated">SQL 주입을 피하려면 매개 변수를 사용하여 데이터를 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="8b6fd1bdb4498ebccf26ab096a8e4ad5d4c1e3fe" translate="yes" xml:space="preserve">
          <source>To avoid this initialization you can use &lt;code&gt;uninitialized&lt;/code&gt;:</source>
          <target state="translated">이 초기화를 피하기 위해 초기화 &lt;code&gt;uninitialized&lt;/code&gt; 것을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b407f439ed92707a8a3b7a8453a6a3a14dbcf57" translate="yes" xml:space="preserve">
          <source>To avoid this, command literals should generally not be used with interpolated user input. &lt;a href=&quot;https://crystal-lang.org/api/latest/Process.html&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; from the standard library offers a safe way to provide user input as command arguments:</source>
          <target state="translated">이를 피하기 위해 일반적으로 명령 리터럴을 보간 된 사용자 입력과 함께 사용해서는 안됩니다. 표준 라이브러리의 &lt;a href=&quot;https://crystal-lang.org/api/latest/Process.html&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 는 사용자 입력을 명령 인수로 제공하는 안전한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b62a2f24708e08a5a378dfd1f86978c3a1616b1b" translate="yes" xml:space="preserve">
          <source>To capture a block you must specify it as a method's block argument, give it a name and specify the input and output types. For example:</source>
          <target state="translated">블록을 캡처하려면 블록을 메소드의 블록 인수로 지정하고 이름을 지정하고 입력 및 출력 유형을 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="160feb3e042b4da9fdc2ead43043bf7e99340f12" translate="yes" xml:space="preserve">
          <source>To change how individual instance variables are parsed and serialized, the annotation &lt;code&gt;&lt;a href=&quot;field&quot;&gt;JSON::Field&lt;/a&gt;&lt;/code&gt; can be placed on the instance variable. Annotating property, getter and setter macros is also allowed.</source>
          <target state="translated">개별 인스턴스 변수의 구문 분석 및 직렬화 방법을 변경하기 위해 &lt;code&gt;&lt;a href=&quot;field&quot;&gt;JSON::Field&lt;/a&gt;&lt;/code&gt; 주석을 인스턴스 변수에 배치 할 수 있습니다. 속성, 게터 및 세터 매크로에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee29fe879b2d99217a00125d95417eef2ee23ca" translate="yes" xml:space="preserve">
          <source>To change how individual instance variables are parsed and serialized, the annotation &lt;code&gt;&lt;a href=&quot;field&quot;&gt;YAML::Field&lt;/a&gt;&lt;/code&gt; can be placed on the instance variable. Annotating property, getter and setter macros is also allowed.</source>
          <target state="translated">개별 인스턴스 변수의 구문 분석 및 직렬화 방법을 변경하기 위해 인스턴스 변수에 주석 &lt;code&gt;&lt;a href=&quot;field&quot;&gt;YAML::Field&lt;/a&gt;&lt;/code&gt; 를 배치 할 수 있습니다. 속성, 게터 및 세터 매크로에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ab23358f7d8d3dae6e24847de5cb10278825ac" translate="yes" xml:space="preserve">
          <source>To change the background color, the following methods are available:</source>
          <target state="translated">배경색을 변경하려면 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4163aca474633e5717845a8aebd70e703b0a1f2e" translate="yes" xml:space="preserve">
          <source>To change the level and sources change the environment variable value:</source>
          <target state="translated">레벨 및 소스를 변경하려면 환경 변수 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="dcf9239dd07dc7a3b710ae0004aa9dd56dd5b6c3" translate="yes" xml:space="preserve">
          <source>To check if your code is formatted correctly, or to check if using the formatter wouldn't produce any changes, simply add &lt;code&gt;--check&lt;/code&gt; to the end of this command.</source>
          <target state="translated">코드의 형식이 올바른지 확인하거나 포맷터를 사용하여 변경 내용이 생성되지 않는지 확인하려면 이 명령 끝에 &lt;code&gt;--check&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd470d9cfaf6bbd3411722b1e8f56b0dd5d4031" translate="yes" xml:space="preserve">
          <source>To compile and run a program in a single shot, invoke &lt;a href=&quot;#crystal-run&quot;&gt;&lt;code&gt;crystal run&lt;/code&gt;&lt;/a&gt; with a single filename:</source>
          <target state="translated">단일 샷에서 프로그램을 컴파일하고 실행하려면 단일 파일 이름으로 &lt;a href=&quot;#crystal-run&quot;&gt; &lt;code&gt;crystal run&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee5e4fe90a5757a251d6078cc3599bc18d661c5e" translate="yes" xml:space="preserve">
          <source>To create CSV data, check &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">CSV 데이터를 생성하려면 &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; 클래스를 확인하세요.</target>
        </trans-unit>
        <trans-unit id="44f2e55e263cca82d33245736b0aa7d4658e8c9f" translate="yes" xml:space="preserve">
          <source>To create CSV data, check &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;block):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">CSV 데이터를 만들려면 CSV &lt;code&gt;&lt;a href=&quot;csv#build(separator:Char=DEFAULT_SEPARATOR,quote_char:Char=DEFAULT_QUOTE_CHAR,quoting:Builder::Quoting=Builder::Quoting::RFC,&amp;amp;block):String-class-method&quot;&gt;CSV#build&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;csv/builder&quot;&gt;CSV::Builder&lt;/a&gt;&lt;/code&gt; 클래스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1da599af8bc9b4e0cbb7f31d925a8a7cb6b6a0f3" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with embedded expressions, you can use string interpolation:</source>
          <target state="translated">식이 포함 된 &lt;code&gt;&lt;a href=&quot;string&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 만들려면 문자열 보간을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bff9cf19307860dba9215ea04d96d1210e0995" translate="yes" xml:space="preserve">
          <source>To create a method that accepts a type name, rather than an instance of a type, append &lt;code&gt;.class&lt;/code&gt; to a free variable in the type restriction:</source>
          <target state="translated">형식의 인스턴스가 아닌 형식 이름을 허용하는 메서드를 만들려면 형식 제한에서 사용 가능한 변수에 &lt;code&gt;.class&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c822a10e2a69e24f65e61788603a1e03389c38e6" translate="yes" xml:space="preserve">
          <source>To create an empty tuple use &lt;a href=&quot;https://crystal-lang.org/api/Tuple.html#new%28%2Aargs%3A%2AT%29-class-method&quot;&gt;Tuple.new&lt;/a&gt;.</source>
          <target state="translated">빈 튜플을 만들려면 &lt;a href=&quot;https://crystal-lang.org/api/Tuple.html#new%28%2Aargs%3A%2AT%29-class-method&quot;&gt;Tuple.new를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8875b0739c4c85a3fbe08d2001dc0bd7dd888845" translate="yes" xml:space="preserve">
          <source>To create an instance of a struct use &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">구조체의 인스턴스를 만들려면 &lt;code&gt;new&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff87c259e02405c350bf039b75adf461c67217e4" translate="yes" xml:space="preserve">
          <source>To create an instance of a union use &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">공용체 인스턴스를 만들려면 &lt;code&gt;new&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="350576382e03e71cf1d7dddb1d7d574b2c7d0619" translate="yes" xml:space="preserve">
          <source>To define a custom exception type, just subclass from &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt;:</source>
          <target state="translated">사용자 정의 예외 유형을 정의하려면 &lt;a href=&quot;http://crystal-lang.org/api/Exception.html&quot;&gt;Exception&lt;/a&gt; 에서 서브 클래스 로만 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d09b37f33a49d1e11a96eff487e9e19489b722" translate="yes" xml:space="preserve">
          <source>To define a flag, simply use the &lt;code&gt;--define&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, like so:</source>
          <target state="translated">플래그를 정의하려면 다음 과 같이 &lt;code&gt;--define&lt;/code&gt; 또는 &lt;code&gt;-D&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="157c11d641b035bf1f8f85fd5664cf15e55f25af" translate="yes" xml:space="preserve">
          <source>To define a method that receives a block, simply use &lt;code&gt;yield&lt;/code&gt; inside it and the compiler will know. You can make this more evident by declaring a dummy block argument, indicated as a last argument prefixed with ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):</source>
          <target state="translated">블록을받는 메소드를 정의하려면 그 안에 &lt;code&gt;yield&lt;/code&gt; 를 사용 하면 컴파일러가 알게됩니다. 앰퍼샌드 ( &lt;code&gt;&amp;amp;&lt;/code&gt; )로 시작하는 마지막 인수로 표시되는 더미 블록 인수를 선언하여이를보다 분명하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b22016984dbb7347b880cb3c69445ba7cb4dd72" translate="yes" xml:space="preserve">
          <source>To denote a Proc type you can write:</source>
          <target state="translated">Proc 유형을 나타내려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7550aab501a1c8caaa7d7d6ad482e4e9849b0dc6" translate="yes" xml:space="preserve">
          <source>To denote a heredoc without interpolation or escapes, the opening heredoc identifier is enclosed in single quotes:</source>
          <target state="translated">보간이나 이스케이프없이 heredoc을 나타 내기 위해 여는 heredoc 식별자는 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="867f43768b0ef892faffb539b98358d23d37336f" translate="yes" xml:space="preserve">
          <source>To denote a named tuple type you can write:</source>
          <target state="translated">명명 된 튜플 형식을 나타내려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfcf8fce49c52dfd01caebb8edf932202a5222a3" translate="yes" xml:space="preserve">
          <source>To denote a tuple type you can write:</source>
          <target state="translated">튜플 유형을 나타내려면 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="874d6e0e60d2b081647b4a3151910755d832a726" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on Mac you can use &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;.</source>
          <target state="translated">Mac에 Crystal을 쉽게 설치하려면 &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a3fa055e9dd3433646539ae53ec5d897352e5be" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on a Linux distribution you can use &lt;a href=&quot;http://linuxbrew.sh/&quot;&gt;Linuxbrew&lt;/a&gt;.</source>
          <target state="translated">Linux 배포판에 Crystal을 쉽게 설치하기 위해 &lt;a href=&quot;http://linuxbrew.sh/&quot;&gt;Linuxbrew&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c154d82a6009b78a7be6f3cf9c32009f998413fd" translate="yes" xml:space="preserve">
          <source>To easily install Crystal on a Linux distribution you can use &lt;a href=&quot;https://snapcraft.io/crystal&quot;&gt;Snap&lt;/a&gt;. See the &lt;a href=&quot;https://crystal-lang.org/2019/06/19/snapcraft-summit-montreal.html&quot;&gt;blog post&lt;/a&gt; for additional information.</source>
          <target state="translated">Linux 배포판에 Crystal을 쉽게 설치하기 위해 &lt;a href=&quot;https://snapcraft.io/crystal&quot;&gt;Snap&lt;/a&gt; 을 사용할 수 있습니다 . 추가 정보 는 &lt;a href=&quot;https://crystal-lang.org/2019/06/19/snapcraft-summit-montreal.html&quot;&gt;블로그 게시물&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28c3747ada5d17d819f9d3db87e61e5c3e1bcc22" translate="yes" xml:space="preserve">
          <source>To ensure the comparison is also true for local wall clock, both date-times need to be transformed to the same time zone.</source>
          <target state="translated">로컬 벽시계에 대한 비교도 가능하게하려면 두 날짜-시간을 동일한 시간대로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="650afee4ead30a5ced59297b61e986072d1af295" translate="yes" xml:space="preserve">
          <source>To establish certain contexts - think &lt;em&gt;empty array&lt;/em&gt; versus &lt;em&gt;array with elements&lt;/em&gt; - the &lt;code&gt;context&lt;/code&gt; method may be used to communicate this to the reader. It has a different name, but behaves exactly like &lt;code&gt;describe&lt;/code&gt;.</source>
          <target state="translated">특정 상황을 설정하려면 - 생각 &lt;em&gt;빈 배열&lt;/em&gt; 대 &lt;em&gt;요소와 배열&lt;/em&gt; - &lt;code&gt;context&lt;/code&gt; 방법을 독자에게이를 전달하기 위해 사용될 수있다. 이름은 다르지만 &lt;code&gt;describe&lt;/code&gt; 와 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a8d04d4c0059669e92d410cfdc7170b492ceca11" translate="yes" xml:space="preserve">
          <source>To execute sql statements you can use &lt;code&gt;Database#exec&lt;/code&gt;</source>
          <target state="translated">SQL 문을 실행하려면 &lt;code&gt;Database#exec&lt;/code&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f3c3d6cbb8ad73ed8673d578519609dac05fb0b" translate="yes" xml:space="preserve">
          <source>To format a single file:</source>
          <target state="translated">단일 파일을 포맷하려면</target>
        </trans-unit>
        <trans-unit id="dd173ad1b26365da78f9985ee0d8bc437bbc72e8" translate="yes" xml:space="preserve">
          <source>To format all &lt;code&gt;.cr&lt;/code&gt; files within a directory:</source>
          <target state="translated">디렉토리 내의 모든 &lt;code&gt;.cr&lt;/code&gt; 파일 을 형식화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d47e60f3725574c7685439648f00bc798ba7db18" translate="yes" xml:space="preserve">
          <source>To forward captured blocks, you use a block argument, prefixing an expression with &lt;code&gt;&amp;amp;&lt;/code&gt;:</source>
          <target state="translated">캡처 된 블록을 전달하려면 블록 접두사를 사용하고 식 앞에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 붙이십시오 .</target>
        </trans-unit>
        <trans-unit id="ff327c417e5ee0740965ae1df0f9c2cc10df560e" translate="yes" xml:space="preserve">
          <source>To forward non-captured blocks, you must use &lt;code&gt;yield&lt;/code&gt;:</source>
          <target state="translated">캡처되지 않은 블록을 전달하려면 &lt;code&gt;yield&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef3de580f601e1866d1a7c3fc757cd95fea67d7b" translate="yes" xml:space="preserve">
          <source>To generate documentation for a project, invoke &lt;code&gt;crystal docs&lt;/code&gt;. By default this will create a &lt;code&gt;docs&lt;/code&gt; directory, with a &lt;code&gt;docs/index.html&lt;/code&gt; entry point. For more details see &lt;a href=&quot;../using_the_compiler#crystal-docs&quot;&gt;Using the compiler &amp;ndash; Creating documentation&lt;/a&gt;.</source>
          <target state="translated">프로젝트 문서를 생성하려면 &lt;code&gt;crystal docs&lt;/code&gt; 를 호출하십시오 . 기본적 으로 &lt;code&gt;docs/index.html&lt;/code&gt; 진입 점이 있는 &lt;code&gt;docs&lt;/code&gt; 디렉토리 가 생성 됩니다. 자세한 내용은 &lt;a href=&quot;../using_the_compiler#crystal-docs&quot;&gt;컴파일러 사용 &amp;ndash; 설명서 작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="248654c867c4cd2b5e014eb06664ec1f3e491240" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;--target&lt;/code&gt; flags you can execute &lt;code&gt;llvm-config --host-target&lt;/code&gt; using an installed LLVM 3.5. For example on a Linux it could say &quot;x86_64-unknown-linux-gnu&quot;.</source>
          <target state="translated">&lt;code&gt;--target&lt;/code&gt; 플래그 를 얻으려면 설치된 LLVM 3.5를 사용하여 &lt;code&gt;llvm-config --host-target&lt;/code&gt; 을 실행할 수 있습니다 . 예를 들어 Linux에서는 &quot;x86_64-unknown-linux-gnu&quot;라고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1140041b350e878a7ace6222c96112b7b9f8fd1" translate="yes" xml:space="preserve">
          <source>To get the underlying value you invoke &lt;code&gt;value&lt;/code&gt; on it:</source>
          <target state="translated">당신이 호출 기본 값을 얻으려면 &lt;code&gt;value&lt;/code&gt; 그것에를 :</target>
        </trans-unit>
        <trans-unit id="a2ed1097eb466585fe9e191ffed061144745c522" translate="yes" xml:space="preserve">
          <source>To get the underlying value you invoke value on it:</source>
          <target state="translated">기본 값을 얻으려면 값을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="1f7d011bd62bfc3a881899fea0b04442b2c5f1d9" translate="yes" xml:space="preserve">
          <source>To have something returned, either specify the return type or use an underscore to allow any return type:</source>
          <target state="translated">무언가를 반환하려면 반환 유형을 지정하거나 밑줄을 사용하여 반환 유형을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="cffc6af7d2caf539b014cbd60280db9027e87ed1" translate="yes" xml:space="preserve">
          <source>To implement an &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; you need to define a &lt;code&gt;&lt;a href=&quot;iterator#next-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; method that must return the next element in the sequence or &lt;code&gt;&lt;a href=&quot;iterator/stop#INSTANCE&quot;&gt;Iterator::Stop::INSTANCE&lt;/a&gt;&lt;/code&gt;, which signals the end of the sequence (you can invoke &lt;code&gt;&lt;a href=&quot;iterator#stop-instance-method&quot;&gt;#stop&lt;/a&gt;&lt;/code&gt; inside an iterator as a shortcut).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;Iterator&lt;/a&gt;&lt;/code&gt; 를 구현하려면 시퀀스의 다음 요소를 반환 &lt;code&gt;&lt;a href=&quot;iterator#next-instance-method&quot;&gt;#next&lt;/a&gt;&lt;/code&gt; 메소드 또는 시퀀스 의 끝을 알리는 &lt;code&gt;&lt;a href=&quot;iterator/stop#INSTANCE&quot;&gt;Iterator::Stop::INSTANCE&lt;/a&gt;&lt;/code&gt; 를 정의 해야합니다 ( 반복자로 내부에서 &lt;code&gt;&lt;a href=&quot;iterator#stop-instance-method&quot;&gt;#stop&lt;/a&gt;&lt;/code&gt; 을 바로 가기로 호출 할 수 있음 ) .</target>
        </trans-unit>
        <trans-unit id="f4fe39b7728eb47d6e1caa2547de31807a3cdf50" translate="yes" xml:space="preserve">
          <source>To install from source, download or clone &lt;a href=&quot;https://github.com/crystal-lang/shards&quot;&gt;the repository&lt;/a&gt; and run &lt;code&gt;make CRFLAGS=--release&lt;/code&gt;. The compiled binary is in &lt;code&gt;bin/shards&lt;/code&gt; and should be added to &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">소스에서 설치하려면 &lt;a href=&quot;https://github.com/crystal-lang/shards&quot;&gt;저장소를&lt;/a&gt; 다운로드하거나 복제 한 후 &lt;code&gt;make CRFLAGS=--release&lt;/code&gt; 실행하십시오 . 컴파일 된 바이너리는 &lt;code&gt;bin/shards&lt;/code&gt; 에 있으며 &lt;code&gt;PATH&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fadaa3d53eae8935a4ae8c1d26caff6cc0eeacdc" translate="yes" xml:space="preserve">
          <source>To invoke a Proc, you invoke the &lt;code&gt;call&lt;/code&gt; method on it. The number of arguments must match the proc's type:</source>
          <target state="translated">Proc을 호출하려면 &lt;code&gt;call&lt;/code&gt; 메소드 를 호출하십시오 . 인수의 개수는 proc 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="727bae5340494da603d5e1ee3f857c54bc1e0f53" translate="yes" xml:space="preserve">
          <source>To invoke a method and pass a block, you use &lt;code&gt;do ... end&lt;/code&gt; or &lt;code&gt;{ ... }&lt;/code&gt;. All of these are equivalent:</source>
          <target state="translated">메소드를 호출하고 블록을 전달하려면 &lt;code&gt;do ... end&lt;/code&gt; 또는 &lt;code&gt;{ ... }&lt;/code&gt; . 이들은 모두 동등합니다 :</target>
        </trans-unit>
        <trans-unit id="c1261081dc0aed6d942e1635fc8e72e85dcb6bfa" translate="yes" xml:space="preserve">
          <source>To iterate a &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/HashLiteral.html&quot;&gt;&lt;code&gt;HashLiteral&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반복 &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/HashLiteral.html&quot;&gt; &lt;code&gt;HashLiteral&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b7cdf18a9a50a75deff88f7987d095f62acaf389" translate="yes" xml:space="preserve">
          <source>To iterate an &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt;&lt;code&gt;ArrayLiteral&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반복하려면 &lt;a href=&quot;https://crystal-lang.org/api/Crystal/Macros/ArrayLiteral.html&quot;&gt; &lt;code&gt;ArrayLiteral&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcdcd4f5025f01cc6bd68254afdb203a18abe523" translate="yes" xml:space="preserve">
          <source>To load a custom MIME database, &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; can be called with an &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; to read the database from.</source>
          <target state="translated">사용자 정의 MIME 데이터베이스를로드하기 위해 &lt;code&gt;&lt;a href=&quot;io&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;mime#load_mime_database(io:IO):Nil-class-method&quot;&gt;.load_mime_database&lt;/a&gt;&lt;/code&gt; 를 호출 하여 데이터베이스를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="239781e06d7d9d2d3050b58686eccae3afc7f7a1" translate="yes" xml:space="preserve">
          <source>To log a message &lt;code&gt;&lt;a href=&quot;log#trace(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;log#debug(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#debug&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;log#info(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#info&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;log#notice(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#notice&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;log#warn(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#warn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;log#error(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;log#fatal(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#fatal&lt;/a&gt;&lt;/code&gt; methods can be used. They expect a block that will evaluate to the message of the entry.</source>
          <target state="translated">메시지를 기록하기 위해 &lt;code&gt;&lt;a href=&quot;log#trace(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#trace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;log#debug(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#debug&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;log#info(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#info&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;log#notice(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#notice&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;log#warn(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#warn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;log#error(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;log#fatal(*,exception:Exception?=nil,&amp;amp;)-instance-method&quot;&gt;#fatal&lt;/a&gt;&lt;/code&gt; 메소드를 사용할 수 있습니다. 그들은 항목의 메시지로 평가 될 블록을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="a9d586ad9a3f3a11302d206a41a30e2de70ae3f7" translate="yes" xml:space="preserve">
          <source>To make date-time instances exchangeable between different computer systems or readable to humans, they are usually converted to and from a string representation.</source>
          <target state="translated">날짜-시간 인스턴스를 다른 컴퓨터 시스템간에 교환하거나 사람이 읽을 수 있도록하기 위해 일반적으로 문자열 표현으로 변환하거나 문자열 표현에서 변환합니다.</target>
        </trans-unit>
        <trans-unit id="62f08f3614272636ba328403e5b5b95a15d91b34" translate="yes" xml:space="preserve">
          <source>To make it appear in documentation comments</source>
          <target state="translated">문서 주석에 표시하려면</target>
        </trans-unit>
        <trans-unit id="a018c8727d46091a749a9a7c72774cc49a12f392" translate="yes" xml:space="preserve">
          <source>To make it more explicit that an &lt;code&gt;Animal&lt;/code&gt; must define a &lt;code&gt;talk&lt;/code&gt; method, we can add it to &lt;code&gt;Animal&lt;/code&gt; as an abstract method:</source>
          <target state="translated">&lt;code&gt;Animal&lt;/code&gt; 이 &lt;code&gt;talk&lt;/code&gt; 방법을 정의해야 한다는 것을보다 명확하게 하기 위해 &lt;code&gt;Animal&lt;/code&gt; 에 추상 방법으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e838d807157c0c216a557a02e8791944341a904c" translate="yes" xml:space="preserve">
          <source>To make it simpler to use, you can create a symbolic link available in the path:</source>
          <target state="translated">보다 사용하기 쉽도록 경로에서 사용 가능한 심볼릭 링크를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e56e7d982e727b8efdaec27e50d073b21555a3" translate="yes" xml:space="preserve">
          <source>To make sure that the method returns the type that you want</source>
          <target state="translated">메소드가 원하는 유형을 리턴하는지 확인하려면</target>
        </trans-unit>
        <trans-unit id="e18e86a8ee0876d3e85736a18888d23b54e9ec6b" translate="yes" xml:space="preserve">
          <source>To make the compiler process other files you use &lt;code&gt;require &quot;...&quot;&lt;/code&gt;. It accepts a single argument, a string literal, and it can come in many flavors.</source>
          <target state="translated">컴파일러가 사용하는 다른 파일을 처리하게 &lt;code&gt;require &quot;...&quot;&lt;/code&gt; . 단일 인수, 문자열 리터럴을 허용하며 여러 가지 맛이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c490ef83c83d8cde412be2d4b0ce1919c2a8f36" translate="yes" xml:space="preserve">
          <source>To parse a CSV in an efficient way, optionally being able to access row values from header names, create an instance of a &lt;code&gt;&lt;a href=&quot;csv&quot;&gt;CSV&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">선택적 헤더 이름에서 액세스 행 값을 수있는 효율적인 방법으로 CSV를 구문 분석하려면 인스턴스 생성 &lt;code&gt;&lt;a href=&quot;csv&quot;&gt;CSV&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="52203019ab16fe64462b71ebbcafca3fc553e030" translate="yes" xml:space="preserve">
          <source>To parse and get an &lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;, use the block-less overload.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 구문 분석하고 가져 오려면 블록리스 과부하를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab29093970d13acb8d97742fb04af5b62b673fae" translate="yes" xml:space="preserve">
          <source>To perform a query and get the result set use &lt;code&gt;Database#query&lt;/code&gt;, arguments can be used as in &lt;code&gt;Database#exec&lt;/code&gt;.</source>
          <target state="translated">쿼리를 수행하고 결과 집합을 얻으려면 &lt;code&gt;Database#query&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;Database#exec&lt;/code&gt; 에서와 같이 인수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00a19595f306c6540d920f1a69b4294225e2b20c" translate="yes" xml:space="preserve">
          <source>To print a number to the standard output you write:</source>
          <target state="translated">표준 출력으로 숫자를 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="97c76781da7eebfc5ea1337f129276882395075e" translate="yes" xml:space="preserve">
          <source>To properly define a wrapper for this function we must send the &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; as the callback data, and then convert that callback data to the &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; and finally invoke it.</source>
          <target state="translated">이 함수에 대한 래퍼를 올바르게 정의하려면 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 를 콜백 데이터로 보낸 다음 해당 콜백 데이터를 &lt;code&gt;&lt;a href=&quot;proc&quot;&gt;Proc&lt;/a&gt;&lt;/code&gt; 로 변환 하고 마지막으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="caa9d763bb22b3320770353054692e18f01408eb" translate="yes" xml:space="preserve">
          <source>To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it.</source>
          <target state="translated">이 함수에 대한 래퍼를 올바르게 정의하려면 Proc를 콜백 데이터로 보낸 다음 해당 콜백 데이터를 Proc로 변환하고 마지막으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f00b4a1fc6440105d7c1a5bd08dc07fc67c647f" translate="yes" xml:space="preserve">
          <source>To read a file relative to where the macro is defined, use:</source>
          <target state="translated">매크로가 정의 된 위치를 기준으로 파일을 읽으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50b99d4c097d2ca1857411e52eccf76e190c65e4" translate="yes" xml:space="preserve">
          <source>To reduce the binary size for distributable files, the &lt;code&gt;--no-debug&lt;/code&gt; flag can be used. This removes debug symbols reducing file size, but obviously making debugging more difficult.</source>
          <target state="translated">배포 가능 파일의 이진 크기를 줄이려면 &lt;code&gt;--no-debug&lt;/code&gt; 플래그를 사용할 수 있습니다. 이렇게하면 디버그 기호가 제거되어 파일 크기가 줄어들지 만 분명히 디버깅이 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="34c625702ae15f9abda81ae4dc740dd2d4f61545" translate="yes" xml:space="preserve">
          <source>To rescue any exception use a &lt;code&gt;begin ... rescue ... end&lt;/code&gt; expression:</source>
          <target state="translated">예외를 구하려면 &lt;code&gt;begin ... rescue ... end&lt;/code&gt; expression을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="38e0d8a6b1edffe2a3499f0ea80fd4de2f3c4b84" translate="yes" xml:space="preserve">
          <source>To rescue just one type of exception (or any of its subclasses):</source>
          <target state="translated">한 가지 유형의 예외 (또는 해당 하위 클래스) 만 구제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="de1a957059f77f9b151934d63ec30dd084b5a782" translate="yes" xml:space="preserve">
          <source>To see the available options for a particular command, use &lt;code&gt;--help&lt;/code&gt; after a command.</source>
          <target state="translated">특정 명령에 사용 가능한 옵션을 보려면 명령 뒤에 &lt;code&gt;--help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="abea0f3f8704b252835992cf74a7b160fd5dca6b" translate="yes" xml:space="preserve">
          <source>To see the available options for a particular command, use &lt;code&gt;--help&lt;/code&gt; after a command:</source>
          <target state="translated">특정 명령에 사용 가능한 옵션을 보려면 명령 뒤에 &lt;code&gt;--help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc556fd1593f459d4e76eb134a04736eab2ee31d" translate="yes" xml:space="preserve">
          <source>To show the value of an expression inside code blocks, use &lt;code&gt;# =&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">코드 블록 내에서 표현식의 값을 표시하려면 &lt;code&gt;# =&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5197526bb89db50ae33697f518e18c00cd24f7c2" translate="yes" xml:space="preserve">
          <source>To solve this, we can do this:</source>
          <target state="translated">이를 해결하기 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5446868b005c13d5d7b309de1bd1152d9a70bc94" translate="yes" xml:space="preserve">
          <source>To spawn a fiber you use &lt;code&gt;spawn&lt;/code&gt; with a block:</source>
          <target state="translated">파이버를 스폰하려면 블록과 함께 &lt;code&gt;spawn&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da33071868fade85d0fe07f4580a14e41e9a2a15" translate="yes" xml:space="preserve">
          <source>To specify a Proc without arguments:</source>
          <target state="translated">인수없이 Proc를 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="afd1c83afd3d5a833f4853a56d5f08a35feb7737" translate="yes" xml:space="preserve">
          <source>To specify multiple arguments:</source>
          <target state="translated">여러 인수를 지정하려면</target>
        </trans-unit>
        <trans-unit id="088c3e80b57c909c8767e72f28da62eb02f87994" translate="yes" xml:space="preserve">
          <source>To switch to &lt;code&gt;latest&lt;/code&gt; for quicker updates, create a file &lt;code&gt;/usr/local/etc/pkg/repos/FreeBSD.conf&lt;/code&gt; with the following contents:</source>
          <target state="translated">빠른 업데이트 를 위해 &lt;code&gt;latest&lt;/code&gt; 전환하려면 다음 내용으로 &lt;code&gt;/usr/local/etc/pkg/repos/FreeBSD.conf&lt;/code&gt; 파일을 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="52c20d34160a9b32c0b4c932b0bee8121b1c10f9" translate="yes" xml:space="preserve">
          <source>To test the server, use the curl command below.</source>
          <target state="translated">서버를 테스트하려면 아래 curl 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="09f10fcb8b3a6c3a4fb5c4cea8db86560eaefebe" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the persons who contributed to this workhave waived</source>
          <target state="translated">법에 따라 가능한 한이 작업에 기여한 사람은 포기했습니다.</target>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">이에:</target>
        </trans-unit>
        <trans-unit id="fd18bcd9d849c73003b6bfe85fe99d038af363d3" translate="yes" xml:space="preserve">
          <source>To use a module as a partial type you use &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;extend&lt;/code&gt;.</source>
          <target state="translated">모듈을 부분 유형으로 사용하려면 &lt;code&gt;include&lt;/code&gt; 또는 &lt;code&gt;extend&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3341895f45bd304e9e010d592eace0f802d01add" translate="yes" xml:space="preserve">
          <source>To use a value:</source>
          <target state="translated">값을 사용하려면</target>
        </trans-unit>
        <trans-unit id="40d041eb687c5d9c41332d8805009da93eeabd18" translate="yes" xml:space="preserve">
          <source>To use it, include this module in your iterator and make sure that the wrapped iterator is stored in the &lt;code&gt;@iterator&lt;/code&gt; instance variable.</source>
          <target state="translated">이를 사용하려면이 모듈을 반복자에 포함시키고 랩된 반복자가 &lt;code&gt;@iterator&lt;/code&gt; 인스턴스 변수에 저장되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="da553b1420ac33bfd3b0e4ce859b7b021ea74786" translate="yes" xml:space="preserve">
          <source>To use the spec module and DSL, you need to add &lt;code&gt;require &quot;spec&quot;&lt;/code&gt; to your spec files. Many projects use a custom &lt;a href=&quot;#spec-helper&quot;&gt;spec helper&lt;/a&gt; which organizes these includes.</source>
          <target state="translated">스펙 모듈 및 DSL을 사용하려면 스펙 파일에 &lt;code&gt;require &quot;spec&quot;&lt;/code&gt; 을 추가 해야 합니다. 많은 프로젝트에서 이러한 포함을 구성 하는 사용자 지정 &lt;a href=&quot;#spec-helper&quot;&gt;사양 도우미&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1296b2b434113e871db7177e5a43c2f292a8a353" translate="yes" xml:space="preserve">
          <source>To wait for it to finish, invoke &lt;code&gt;&lt;a href=&quot;process#wait:Process::Status-instance-method&quot;&gt;#wait&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">완료 될 때까지 기다리려면 &lt;code&gt;&lt;a href=&quot;process#wait:Process::Status-instance-method&quot;&gt;#wait&lt;/a&gt;&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f177b9ae2819b53c30fb23a3369899b07f15a314" translate="yes" xml:space="preserve">
          <source>To write a chain of if-else-if you use &lt;code&gt;elsif&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;elsif&lt;/code&gt; 를 사용하는 경우 if -else- if 체인을 작성하려면 .</target>
        </trans-unit>
        <trans-unit id="be6716112727391fe917c145b829f2ba915eba9e" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; this represents a specific day as commercial or week date format &lt;code&gt;year, week, day_of_week&lt;/code&gt; in the same way as the typical format &lt;code&gt;year, month, day&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;time#week_date(year:Int32,week:Int32,day_of_week:Int32%7CDayOfWeek,hour:Int32=0,minute:Int32=0,second:Int32=0,*,nanosecond:Int32=0,location:Location=Location.local):self-class-method&quot;&gt;.week_date&lt;/a&gt;&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; instance from a week date.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;time#day_of_week:Time::DayOfWeek-instance-method&quot;&gt;#day_of_week&lt;/a&gt;&lt;/code&gt; 와 함께 이것은 특정 형식 의 일을 일반적인 형식 &lt;code&gt;year, month, day&lt;/code&gt; 같은 방식으로 상업 또는 주 날짜 형식 &lt;code&gt;year, week, day_of_week&lt;/code&gt; 로 나타냅니다 . &lt;code&gt;&lt;a href=&quot;time#week_date(year:Int32,week:Int32,day_of_week:Int32%7CDayOfWeek,hour:Int32=0,minute:Int32=0,second:Int32=0,*,nanosecond:Int32=0,location:Location=Location.local):self-class-method&quot;&gt;.week_date&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;time&quot;&gt;Time&lt;/a&gt;&lt;/code&gt; 만듭니다 는 요일로부터 인스턴스를 .</target>
        </trans-unit>
        <trans-unit id="a1f392b8b5ec3e60f49fefbec4147b99fae2de08" translate="yes" xml:space="preserve">
          <source>Toggles the bit at the given &lt;em&gt;index&lt;/em&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;인덱스&lt;/em&gt; 에서 비트를 토글합니다.&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0245b740561399d7d6391e6c13b4b6c4f785ce9c" translate="yes" xml:space="preserve">
          <source>Toggles the bit at the given &lt;em&gt;index&lt;/em&gt;. A false bit becomes a &lt;code&gt;true&lt;/code&gt; bit, and vice versa. Negative indices can be used to start counting from the end of the array. Raises &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt; if trying to access a bit outside the array's range.</source>
          <target state="translated">주어진 &lt;em&gt;인덱스&lt;/em&gt; 에서 비트를 토글합니다 . 거짓 비트는 &lt;code&gt;true&lt;/code&gt; 비트가되고 그 반대도 마찬가지입니다. 음의 인덱스를 사용하여 배열 끝부터 계산을 시작할 수 있습니다. 발생시킵니다 &lt;code&gt;&lt;a href=&quot;indexerror&quot;&gt;IndexError&lt;/a&gt;&lt;/code&gt; 은 배열의 범위를 벗어난 약간에 액세스하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bd6413c51a2682c3fc71e1e55728f7a0d5fc6168" translate="yes" xml:space="preserve">
          <source>Token kinds.</source>
          <target state="translated">토큰 종류.</target>
        </trans-unit>
        <trans-unit id="a8d651139915c982a0b3682ed05931830cbc6c96" translate="yes" xml:space="preserve">
          <source>Token#column_number</source>
          <target state="translated">Token#column_number</target>
        </trans-unit>
        <trans-unit id="8ec5045436899dd388aa1e7fc879c39da59e262b" translate="yes" xml:space="preserve">
          <source>Token#column_number=</source>
          <target state="translated">Token#column_number=</target>
        </trans-unit>
        <trans-unit id="d39b811b08f82972dd235985343deaaa58f35c2b" translate="yes" xml:space="preserve">
          <source>Token#float_value</source>
          <target state="translated">Token#float_value</target>
        </trans-unit>
        <trans-unit id="d342122f36d8b6d8811f0494ad27ff6b590794dd" translate="yes" xml:space="preserve">
          <source>Token#float_value=</source>
          <target state="translated">Token#float_value=</target>
        </trans-unit>
        <trans-unit id="5dee9f081919dd845e1ff2e0f5b8c13a5b48f46e" translate="yes" xml:space="preserve">
          <source>Token#int_value</source>
          <target state="translated">Token#int_value</target>
        </trans-unit>
        <trans-unit id="ec620ba967a2b92b4ee8eff86dda4b0baf4978eb" translate="yes" xml:space="preserve">
          <source>Token#int_value=</source>
          <target state="translated">Token#int_value=</target>
        </trans-unit>
        <trans-unit id="c2e204c23faca8bb6370e1f51ef9203d99341a52" translate="yes" xml:space="preserve">
          <source>Token#kind</source>
          <target state="translated">Token#kind</target>
        </trans-unit>
        <trans-unit id="0544e63aaf05664475d71b90f1a1f71e39da6b17" translate="yes" xml:space="preserve">
          <source>Token#kind=</source>
          <target state="translated">Token#kind=</target>
        </trans-unit>
        <trans-unit id="832350d7582bb9914ec219c2cbf5287e5764dc96" translate="yes" xml:space="preserve">
          <source>Token#line_number</source>
          <target state="translated">Token#line_number</target>
        </trans-unit>
        <trans-unit id="fea18a586a4238217c56f770e6bfcda4223dcecf" translate="yes" xml:space="preserve">
          <source>Token#line_number=</source>
          <target state="translated">Token#line_number=</target>
        </trans-unit>
        <trans-unit id="49955717130865e9b711c81801a573db2917d445" translate="yes" xml:space="preserve">
          <source>Token#raw_value</source>
          <target state="translated">Token#raw_value</target>
        </trans-unit>
        <trans-unit id="6793f0b4c84e3891c93500ae8ef1a128e57724e9" translate="yes" xml:space="preserve">
          <source>Token#raw_value=</source>
          <target state="translated">Token#raw_value=</target>
        </trans-unit>
        <trans-unit id="e5e5b69ff19589f626f983a5dbd4a48b9a076b73" translate="yes" xml:space="preserve">
          <source>Token#string_value</source>
          <target state="translated">Token#string_value</target>
        </trans-unit>
        <trans-unit id="31380e9a9615e0e4947d968c30bf17dfdb3c45cd" translate="yes" xml:space="preserve">
          <source>Token#string_value=</source>
          <target state="translated">Token#string_value=</target>
        </trans-unit>
        <trans-unit id="c29acfefaadea10b896c4e948c662ab0fe3d7fcb" translate="yes" xml:space="preserve">
          <source>Token#to_s</source>
          <target state="translated">Token#to_s</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
