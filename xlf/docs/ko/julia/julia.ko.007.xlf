<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="c646760ea02101dd2c78e156bd67fbc1e7939279" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than With Underbar</source>
          <target state="translated">언더 바가 포함 된 이중 중첩리스</target>
        </trans-unit>
        <trans-unit id="da273e33c1593b23cc1baf0841e4eb0696481ab6" translate="yes" xml:space="preserve">
          <source>Double Plus</source>
          <target state="translated">더블 플러스</target>
        </trans-unit>
        <trans-unit id="a4eb216c233e5e31eaaa029b5a6659a1175205bf" translate="yes" xml:space="preserve">
          <source>Double Precedes</source>
          <target state="translated">이중 전치사</target>
        </trans-unit>
        <trans-unit id="94596af0b897ecaa403e2b29d5442ffc485744fa" translate="yes" xml:space="preserve">
          <source>Double Prime</source>
          <target state="translated">더블 프라임</target>
        </trans-unit>
        <trans-unit id="d4bb3033b81e3e5bf5fe1b3d95ec1e84254a8648" translate="yes" xml:space="preserve">
          <source>Double Square Intersection</source>
          <target state="translated">더블 스퀘어 교차로</target>
        </trans-unit>
        <trans-unit id="1cdd297d02a50e98fc796a7bb474ae2cbf5b341e" translate="yes" xml:space="preserve">
          <source>Double Square Union</source>
          <target state="translated">더블 스퀘어 유니언</target>
        </trans-unit>
        <trans-unit id="8bec3a437a2b0935e9467004616a12d8b9bac5b1" translate="yes" xml:space="preserve">
          <source>Double Subset</source>
          <target state="translated">더블 서브 세트</target>
        </trans-unit>
        <trans-unit id="1f4f518e5cace96063fb6e4842b29d3c3a0bf8a6" translate="yes" xml:space="preserve">
          <source>Double Succeeds</source>
          <target state="translated">더블 성공</target>
        </trans-unit>
        <trans-unit id="f64b087e350913f39a60133fc102b9f0f94189cc" translate="yes" xml:space="preserve">
          <source>Double Superset</source>
          <target state="translated">더블 수퍼 셋</target>
        </trans-unit>
        <trans-unit id="ca2705c17942fca00d32bc39c06af31f76ecd340" translate="yes" xml:space="preserve">
          <source>Double Union</source>
          <target state="translated">더블 유니언</target>
        </trans-unit>
        <trans-unit id="f7eafda32018eb8216c74731243d8bcf503ebd15" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">두 배 수직 막대기 두 배 오른쪽 십자형 회전식 문</target>
        </trans-unit>
        <trans-unit id="4e0938d334e779c3d4385d240fa933a4aa60bab1" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Left Turnstile</source>
          <target state="translated">두 배 수직 막대기 좌 십자형 회전식 문</target>
        </trans-unit>
        <trans-unit id="bc9a2fa0502c305faf46fd54f952ef44d055b6f5" translate="yes" xml:space="preserve">
          <source>Double Vertical Line / Double Vertical Bar</source>
          <target state="translated">이중 수직선 / 이중 수직 막대</target>
        </trans-unit>
        <trans-unit id="0c24baa17889b7dd7c44e226a4bfc6668ff9bdeb" translate="yes" xml:space="preserve">
          <source>Double-Ended Multimap</source>
          <target state="translated">이중 종단 멀티 맵</target>
        </trans-unit>
        <trans-unit id="5fab79944c7fc8e86540423312b6958371754001" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Greater-Than</source>
          <target state="translated">이중선과 같거나 큰 것</target>
        </trans-unit>
        <trans-unit id="09e23fb3335770ae7a2fab59103015e6204ac1a9" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Less-Than</source>
          <target state="translated">이중 선 이하</target>
        </trans-unit>
        <trans-unit id="81443422e1dbb876dc01a2f2800e2f313209c209" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Greater-Than</source>
          <target state="translated">이중선 경사 또는 동등 이상</target>
        </trans-unit>
        <trans-unit id="298a11392e511e8c4817b6337e56afa525bb120d" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Less-Than</source>
          <target state="translated">이중선 경사 이하</target>
        </trans-unit>
        <trans-unit id="a39c2d49b33b8171f0335f4d62c054ebe50e2949" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Greater-Than Or Equal To</source>
          <target state="translated">이중선 경사보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="1a8936fc614fa8b11ad34af0ae168622fd04d79a" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Less-Than Or Equal To</source>
          <target state="translated">이중선 경사보다 작거나 같음</target>
        </trans-unit>
        <trans-unit id="5fcd17070ab099bf225ba4ec089d10cd5befd0d0" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital C / Double-Struck C</source>
          <target state="translated">이중 타격 자본 C / 이중 타격 C</target>
        </trans-unit>
        <trans-unit id="7fe3d74449be0c8a16270734ac281959d2434acb" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Gamma</source>
          <target state="translated">이중 타격 자본 감마</target>
        </trans-unit>
        <trans-unit id="2bc51683b00bc656e8387c2a5971b20973b2e68d" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital H / Double-Struck H</source>
          <target state="translated">이중 타격 자본 H / 이중 타격 H</target>
        </trans-unit>
        <trans-unit id="77f2a8e846cb9408cb76519191f8677c811ec6c2" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital N / Double-Struck N</source>
          <target state="translated">이중 타격 자본 N / 이중 타격 N</target>
        </trans-unit>
        <trans-unit id="3d9ff0d995aa97605586bd26332422b375e0d4da" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital P / Double-Struck P</source>
          <target state="translated">이중 타격 자본 P / 이중 타격 P</target>
        </trans-unit>
        <trans-unit id="8e8bbccb682c6db82d059047113f028c1e9e4935" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Pi</source>
          <target state="translated">이중 타격 자본 파이</target>
        </trans-unit>
        <trans-unit id="43fb013cca9c4a4a8b1a6e51423770297967de57" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Q / Double-Struck Q</source>
          <target state="translated">이중 타격 자본 Q / 이중 타격 Q</target>
        </trans-unit>
        <trans-unit id="a7d9b7fa137bc84092b6dbae26b457a275ea3624" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital R / Double-Struck R</source>
          <target state="translated">이중 타격 자본 R / 이중 타격 R</target>
        </trans-unit>
        <trans-unit id="31b7923fbdad31f1ec3bcd8a5c5055fe73e937d5" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Z / Double-Struck Z</source>
          <target state="translated">이중 타격 자본 Z / 이중 타격 Z</target>
        </trans-unit>
        <trans-unit id="22b10852f9529884fb8ade41480e3db571e4dab1" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Capital D</source>
          <target state="translated">이중 타격 이탤릭 대문자 D</target>
        </trans-unit>
        <trans-unit id="96df4e88f2bfb97c5cf111112b6793cdf4963d06" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small D</source>
          <target state="translated">이중 타격 이탤릭체 작은 D</target>
        </trans-unit>
        <trans-unit id="0ba03aedaaff708d7df7636d4094ce50661bf52b" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small E</source>
          <target state="translated">이중 타격 이탤릭체 소형 E</target>
        </trans-unit>
        <trans-unit id="33fd110b35ce2a0d08df3e940965ae2eec73859f" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small I</source>
          <target state="translated">이중 타격 이탤릭체 작은 I</target>
        </trans-unit>
        <trans-unit id="e7b00a215e1cd74b1415dfeb4e53c76b770b6715" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small J</source>
          <target state="translated">이중 타격 이탤릭체 작은 J</target>
        </trans-unit>
        <trans-unit id="78f6994be690e96f674586766d03abe261a0d6c0" translate="yes" xml:space="preserve">
          <source>Double-Struck N-Ary Summation</source>
          <target state="translated">이중 타격 N-Ary 요약</target>
        </trans-unit>
        <trans-unit id="7522a251652bf308c1e54e228103454ad9e38cf3" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Gamma</source>
          <target state="translated">이중 타격 작은 감마</target>
        </trans-unit>
        <trans-unit id="e9209c0ddacbb74a712ae08d417871541bc2ed5d" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Pi</source>
          <target state="translated">이중 타격 소형 파이</target>
        </trans-unit>
        <trans-unit id="e32b900891654ad41d9a370dd7666e75c72537ec" translate="yes" xml:space="preserve">
          <source>Doughnut</source>
          <target state="translated">Doughnut</target>
        </trans-unit>
        <trans-unit id="74b33dde33775abd34211cfb4e20f9d6bde3c7a7" translate="yes" xml:space="preserve">
          <source>Down Right Diagonal Ellipsis</source>
          <target state="translated">오른쪽 대각선 줄임표</target>
        </trans-unit>
        <trans-unit id="b621fc7da134ad1633ff77f53544dd0b2c6c5e6d" translate="yes" xml:space="preserve">
          <source>Down Tack</source>
          <target state="translated">다운 택</target>
        </trans-unit>
        <trans-unit id="05c8ca1a817444b080cfc3aca96ff10f7d2bd3d0" translate="yes" xml:space="preserve">
          <source>Down arrow, &lt;code&gt;^N&lt;/code&gt;</source>
          <target state="translated">아래쪽 화살표, &lt;code&gt;^N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c538452cf7c33c2e1a7c6f852e565ccc86225406" translate="yes" xml:space="preserve">
          <source>Down-Pointing Red Triangle</source>
          <target state="translated">아래쪽 빨간색 삼각형</target>
        </trans-unit>
        <trans-unit id="8bfd316beaffb49e3a9febd43df2eb2cb5afaace" translate="yes" xml:space="preserve">
          <source>Down-Pointing Small Red Triangle</source>
          <target state="translated">아래쪽 작은 빨간색 삼각형</target>
        </trans-unit>
        <trans-unit id="17cff6f253715144bf846cc6cb0ca961d48c99f6" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations.</source>
          <target state="translated">벡터 &lt;code&gt;v&lt;/code&gt; 로 Cholesky 인수 분해 &lt;code&gt;C&lt;/code&gt; 를 다운 데이트하십시오 . 경우 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 다음 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 그러나의 계산 &lt;code&gt;CC&lt;/code&gt; 는 단지 사용 &lt;code&gt;O(n^2)&lt;/code&gt; 동작.</target>
        </trans-unit>
        <trans-unit id="b97c3860e18211639f16883b11f27c780f8f632f" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations. The input factorization &lt;code&gt;C&lt;/code&gt; is updated in place such that on exit &lt;code&gt;C == CC&lt;/code&gt;. The vector &lt;code&gt;v&lt;/code&gt; is destroyed during the computation.</source>
          <target state="translated">벡터 &lt;code&gt;v&lt;/code&gt; 로 hole 레 스키 인수 분해 &lt;code&gt;C&lt;/code&gt; 를 다운 데이트하십시오 . 경우 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 다음 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 그러나의 계산 &lt;code&gt;CC&lt;/code&gt; 는 단지 사용 &lt;code&gt;O(n^2)&lt;/code&gt; 동작. 입력 인수 분해 &lt;code&gt;C&lt;/code&gt; 는 종료 &lt;code&gt;C == CC&lt;/code&gt; 가되도록 업데이트됩니다 . 벡터 &lt;code&gt;v&lt;/code&gt; 는 계산 중에 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="d64fb6577c643a1a98bcc4d17dd77adc7d4f3749" translate="yes" xml:space="preserve">
          <source>Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;fetch&lt;/code&gt; to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.</source>
          <target state="translated">제공된 URL에서 파일을 다운로드하고 선택적으로 지정된 로컬 파일 이름으로 이름을 바꿉니다. 파일 이름을 지정하지 않으면 임시 디렉토리의 무작위로 이름이 지정된 파일로 다운로드됩니다. 이 기능은 &lt;code&gt;curl&lt;/code&gt; , &lt;code&gt;wget&lt;/code&gt; 또는 &lt;code&gt;fetch&lt;/code&gt; 와 같은 외부 도구를 사용 하여 파일을 다운로드 할 수 있으며 편의를 위해 제공됩니다. 프로덕션 사용 또는 추가 옵션이 필요한 상황에서는 원하는 기능을 제공하는 패키지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="08c3c7d3645a4ce6730f3721ad47fc2949dc976a" translate="yes" xml:space="preserve">
          <source>Downwards Arrow / Down Arrow</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="7dce0d557028c5dea3dace158554e15d9784698b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow From Bar / Down Arrow From Bar</source>
          <target state="translated">바에서 아래쪽 화살표 / 바에서 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="0d1345aef883b3624d484df6c78fa1499f363962" translate="yes" xml:space="preserve">
          <source>Downwards Arrow Leftwards Of Upwards Arrow</source>
          <target state="translated">아래쪽 화살표 위쪽 화살표의 왼쪽</target>
        </trans-unit>
        <trans-unit id="2156bac33a07bff1c6168c184044e461147f3221" translate="yes" xml:space="preserve">
          <source>Downwards Arrow To Bar</source>
          <target state="translated">아래쪽 화살표 막대</target>
        </trans-unit>
        <trans-unit id="6a3f0e1b85e70e46f52c461b297ce3b234dd2b8e" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left</source>
          <target state="translated">모서리가 왼쪽 인 아래쪽 화살표 / 모서리가 왼쪽 인 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="22f12c6b38c168555c766d9ecd689bee73798e7b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Double Stroke / Down Arrow With Double Stroke</source>
          <target state="translated">이중 스트로크가있는 아래쪽 화살표 / 이중 스트로크가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="3e70b3fbb5e1272dbfb2768c6abc80ebc34f5538" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Horizontal Stroke</source>
          <target state="translated">수평 스트로크가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c1bc962d484f0e77f2bb2b3688fdfa2d1422bc61" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left</source>
          <target state="translated">팁이 왼쪽 인 아래쪽 화살표 / 팁이 왼쪽 인 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="6f17c4c1d048a9705300c820118cf36a53d197eb" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right</source>
          <target state="translated">오른쪽 화살표가있는 아래쪽 화살표 / 오른쪽 화살표가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="77827f24b06007c8351d7b42f91be0b4d539c6de" translate="yes" xml:space="preserve">
          <source>Downwards Black Arrow</source>
          <target state="translated">아래쪽 검은 색 화살표</target>
        </trans-unit>
        <trans-unit id="b75b010ebb988c0b894244b49f47de83c298a210" translate="yes" xml:space="preserve">
          <source>Downwards Dashed Arrow / Down Dashed Arrow</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b052c2e01abe8207481638ce404112cf6c895155" translate="yes" xml:space="preserve">
          <source>Downwards Double Arrow / Down Double Arrow</source>
          <target state="translated">아래쪽 이중 화살표 / 아래쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="39618206cc6f04a2548c6e3a46f1c96431d17934" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 아래쪽 작살 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="61e7d9beabf27ce96043173d50a1ffbcb3c8f195" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 아래쪽 작살 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="8f99b76aec3d61f79f81cc67881ebb3880b49671" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left From Bar</source>
          <target state="translated">바에서 왼쪽 바브로 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="0a957078126f861ff70d4cccc6ee4961501ca412" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left To Bar</source>
          <target state="translated">왼쪽 막대가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="20016dc34aed751d644d5eba1c2ce94f4ccb571f" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left</source>
          <target state="translated">왼쪽으로 바브가있는 아래쪽 작살 / 왼쪽으로 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="43ff08d740eada07edb33d8b4d43a32fe54cdb0c" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right From Bar</source>
          <target state="translated">바에서 바로 바브와 함께 아래쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="fdcd989ee2f4eed7638bcc66aefc50676e2d0de3" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right To Bar</source>
          <target state="translated">바 오른쪽 바를 가진 아래쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="70698ae85402133e06db357acf28e4adb5132348" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right</source>
          <target state="translated">오른쪽 바브가있는 아래쪽 작살 / 오른쪽 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="e991bdc2966ff71e9f056a8cb1f209c18137ee66" translate="yes" xml:space="preserve">
          <source>Downwards Paired Arrows / Down Paired Arrows</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="708fb5fb1095e517bca56d05c3a07607b86eea24" translate="yes" xml:space="preserve">
          <source>Downwards Quadruple Arrow</source>
          <target state="translated">하향 쿼드 러플 화살표</target>
        </trans-unit>
        <trans-unit id="7832bc44c221f296a0a3557341bf5711ce0ad13e" translate="yes" xml:space="preserve">
          <source>Downwards Triple Arrow</source>
          <target state="translated">아래쪽 트리플 화살표</target>
        </trans-unit>
        <trans-unit id="71c2a3e9e5d53ca7e448be0dc997a3840d8ffbe4" translate="yes" xml:space="preserve">
          <source>Downwards Two Headed Arrow / Down Two Headed Arrow</source>
          <target state="translated">아래쪽으로 향하는 화살표 / 아래쪽으로 향하는 화살표</target>
        </trans-unit>
        <trans-unit id="20bd273f7536e79d1e647c7a4805a10cc0a6024f" translate="yes" xml:space="preserve">
          <source>Downwards White Arrow / White Down Arrow</source>
          <target state="translated">아래쪽 흰색 화살표 / 흰색 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="dee70c16d9a7402c3ff7c179d417c02524182f20" translate="yes" xml:space="preserve">
          <source>Downwards Zigzag Arrow / Down Zigzag Arrow</source>
          <target state="translated">아래쪽 지그재그 화살표 / 아래쪽 지그재그 화살표</target>
        </trans-unit>
        <trans-unit id="0f0c13b35658b4610aac908bd6f900baccfacc2c" translate="yes" xml:space="preserve">
          <source>Drafting Point Rightwards Arrow / Drafting Point Right Arrow</source>
          <target state="translated">제도 점 오른쪽 화살표 / 제도 점 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="eb22c5e28adf024cfee08804c00ddb9ac2973892" translate="yes" xml:space="preserve">
          <source>Dragon</source>
          <target state="translated">Dragon</target>
        </trans-unit>
        <trans-unit id="b1d5fd0950f3316f4c616ebe016d1f72cbdff89e" translate="yes" xml:space="preserve">
          <source>Dragon Face</source>
          <target state="translated">용의 얼굴</target>
        </trans-unit>
        <trans-unit id="f61e33bf74dc6cb23e31a4742f4452d5d238daaf" translate="yes" xml:space="preserve">
          <source>Dress</source>
          <target state="translated">Dress</target>
        </trans-unit>
        <trans-unit id="eaae1cbe655bd67615f32293502367c2637ee817" translate="yes" xml:space="preserve">
          <source>Dromedary Camel</source>
          <target state="translated">단봉 낙타</target>
        </trans-unit>
        <trans-unit id="f9b83daeec2460cd138ef6a2f12cc6f1f9046683" translate="yes" xml:space="preserve">
          <source>Droplet</source>
          <target state="translated">Droplet</target>
        </trans-unit>
        <trans-unit id="5462217de65ccce13656393863d3f8b9357c723d" translate="yes" xml:space="preserve">
          <source>Due to its packed storage format, concurrent access to the elements of a &lt;code&gt;BitArray&lt;/code&gt; where at least one of them is a write is not thread safe.</source>
          <target state="translated">압축 된 저장 형식으로 인해 &lt;code&gt;BitArray&lt;/code&gt; 요소 중 하나 이상이 쓰기 인 경우 동시 액세스 는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4743db582f1472d30e534715a34bc56d951fe4b6" translate="yes" xml:space="preserve">
          <source>Due to the colloquial usage of &lt;code&gt;sha256&lt;/code&gt; to refer to &lt;code&gt;sha2_256&lt;/code&gt;, convenience functions are provided, mapping &lt;code&gt;shaxxx()&lt;/code&gt; function calls to &lt;code&gt;sha2_xxx()&lt;/code&gt;. For SHA-3, no such colloquialisms exist and the user must use the full &lt;code&gt;sha3_xxx()&lt;/code&gt; names.</source>
          <target state="translated">&lt;code&gt;sha2_256&lt;/code&gt; 을 참조하는 &lt;code&gt;sha256&lt;/code&gt; 의 구어체 사용으로 인해 &lt;code&gt;shaxxx()&lt;/code&gt; 함수 호출을 &lt;code&gt;sha2_xxx()&lt;/code&gt; 매핑하는 편리한 함수가 제공됩니다 . SHA-3의 경우 이러한 구어체가 없으며 사용자는 전체 &lt;code&gt;sha3_xxx()&lt;/code&gt; 이름을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ede46a500ade748ac355337b865cbc0acd19bf6" translate="yes" xml:space="preserve">
          <source>Durations/Comparisons</source>
          <target state="translated">Durations/Comparisons</target>
        </trans-unit>
        <trans-unit id="9dfdb39c23a955cc3f51336a0530f2307a456f87" translate="yes" xml:space="preserve">
          <source>Dvd</source>
          <target state="translated">Dvd</target>
        </trans-unit>
        <trans-unit id="34b40a7ef9ec304a622a57c3ab20b2c39518c944" translate="yes" xml:space="preserve">
          <source>Dynamic Linker</source>
          <target state="translated">동적 링커</target>
        </trans-unit>
        <trans-unit id="dc0def730e20d274cc00210435f7d12be805f16c" translate="yes" xml:space="preserve">
          <source>Dynamic documentation</source>
          <target state="translated">동적 문서</target>
        </trans-unit>
        <trans-unit id="085752d538f762ff5754a9aa26842e80bb0818e2" translate="yes" xml:space="preserve">
          <source>E-Mail Symbol</source>
          <target state="translated">이메일 기호</target>
        </trans-unit>
        <trans-unit id="7e7d5355c188b846aca335184bbeb5367a48b580" translate="yes" xml:space="preserve">
          <source>E.g., if &lt;code&gt;A&lt;/code&gt; is a matrix, &lt;code&gt;dims=1&lt;/code&gt; will sort rows, &lt;code&gt;dims=2&lt;/code&gt; will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</source>
          <target state="translated">예를 들어 &lt;code&gt;A&lt;/code&gt; 가 행렬 인 경우 &lt;code&gt;dims=1&lt;/code&gt; 은 행을 정렬하고 &lt;code&gt;dims=2&lt;/code&gt; 는 열을 정렬합니다. 1 차원 조각의 기본 비교 기능은 사전 식으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8872365c161a3e67efcc3a61e6bdd7bd82ccf5" translate="yes" xml:space="preserve">
          <source>ENDIAN_BOM</source>
          <target state="translated">ENDIAN_BOM</target>
        </trans-unit>
        <trans-unit id="086bfb42cb0e1f0682c42f25c92a8f7e76b5bda4" translate="yes" xml:space="preserve">
          <source>ENV</source>
          <target state="translated">ENV</target>
        </trans-unit>
        <trans-unit id="7b9e6e531c95a34720d1a8d1d5a2c5f1c560afeb" translate="yes" xml:space="preserve">
          <source>EOFError</source>
          <target state="translated">EOFError</target>
        </trans-unit>
        <trans-unit id="6c745d78cc4826efc22c10c011aab3cf174ad141" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">각 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; 에는 함수 이름, 파일 이름, 줄 번호, 람다 정보, 프레임이 인라인되었는지 여부를 나타내는 플래그, C 함수인지를 나타내는 플래그 (기본적으로 C 함수가 스택 추적에 나타나지 않음)가 포함됩니다. , &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; 가&lt;/a&gt; 반환 한 포인터의 정수 표현 :</target>
        </trans-unit>
        <trans-unit id="a765a9a50809d8eeae2747483abc88ca1bb085e7" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4b43a1b63da011682c91ea2326629ce626a8f4ec" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;ArgumentValue&lt;/code&gt; to &lt;code&gt;llvmcall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;ArgumentType&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;ArgumentValue&lt;/code&gt; 에 &lt;code&gt;llvmcall&lt;/code&gt; 는 해당 변환한다 &lt;code&gt;ArgumentType&lt;/code&gt; 에 호출을 자동 삽입함으로써 &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt; . (자세한 내용은 &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.) 대부분의 경우 간단히 &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3efd270aff2961e629ca01262fed000c080a030f" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to &lt;code&gt;@ccall&lt;/code&gt; is converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;argvalue&lt;/code&gt; 에 &lt;code&gt;@ccall&lt;/code&gt; 는 대응으로 변환된다 &lt;code&gt;argtype&lt;/code&gt; 자동 호출 삽입하여 &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt; . (자세한 내용은 &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; 에&lt;/a&gt; 대한 설명서를 참조 하십시오.) 대부분의 경우 이로 인해 단순히 &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt; 호출이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="16639880e3d78941c163af0b97ffa26b4ba639e4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to the &lt;code&gt;ccall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;argvalue&lt;/code&gt; 받는 &lt;code&gt;ccall&lt;/code&gt; 는 해당 변환한다 &lt;code&gt;argtype&lt;/code&gt; 자동 호출 삽입하여 &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt; . (자세한 내용은 &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.) 대부분의 경우 단순히 &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt; 호출이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="87cceae9fc7cfd4af0f8243a86a72515045e2992" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;lock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 &lt;code&gt;lock&lt;/code&gt; 는 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a58a43e2467e832b243587c5b856d542f30f944" translate="yes" xml:space="preserve">
          <source>Each Julia process thus has 31 communication tasks.</source>
          <target state="translated">따라서 각 Julia 프로세스에는 31 개의 통신 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="90eeb77500114235cd36d8d57b969eb1e5584ef6" translate="yes" xml:space="preserve">
          <source>Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data first:</source>
          <target state="translated">각 이벤트는 몇 가지 데이터를 생성하며 일부는 사용자가 제공하고 일부는 자동으로 추출됩니다. 먼저 사용자 정의 데이터를 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="6afa6a3549818bce117962a7026f18062cf8f803" translate="yes" xml:space="preserve">
          <source>Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a &lt;code&gt;ByteString&lt;/code&gt; or an &lt;code&gt;IO&lt;/code&gt; object. This makes it trivial to checksum a file:</source>
          <target state="translated">(이 기입시, (384) 및 (512)의 기능이 구현되는 SHA-1, SHA-2 (224), 256, 384, 512 및 SHA-3 224, 256) 각각의 수출 기능은 어느 취하는 &lt;code&gt;Array{UInt8}&lt;/code&gt; , &lt;code&gt;ByteString&lt;/code&gt; 또는 &lt;code&gt;IO&lt;/code&gt; 의 객체입니다. 이렇게하면 파일을 체크섬하는 것이 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a27894f5ec437e16c54a81d270d486f77eb240c6" translate="yes" xml:space="preserve">
          <source>Each kind of environment defines these three maps differently, as detailed in the following sections.</source>
          <target state="translated">각 환경에서는 다음 섹션에서 자세히 설명하는 것처럼이 세 가지 맵을 다르게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1ff693f28cccaa9f352f467474efbdadbcecc29f" translate="yes" xml:space="preserve">
          <source>Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first &quot;field&quot; is the number of backtraces (samples) taken &lt;em&gt;at this line or in any functions executed by this line&lt;/em&gt;. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this example yourself.</source>
          <target state="translated">이 디스플레이의 각 줄은 코드에서 특정 지점 (줄 번호)을 나타냅니다. 들여 쓰기는 중첩 된 함수 호출 시퀀스를 나타내는 데 사용되며,보다 들여 쓰기 된 행은 호출 시퀀스에서 더 깊습니다. 각 라인에서 첫 번째 &quot;필드&quot;는 &lt;em&gt;이 라인 또는이 라인에 의해 실행 된 함수에서&lt;/em&gt; 취한 역 추적 (샘플)의 수입니다 . 두 번째 필드는 파일 이름과 줄 번호이고 세 번째 필드는 함수 이름입니다. Julia의 코드가 변경되면 특정 행 번호가 변경 될 수 있습니다. 따라하고 싶다면이 예제를 직접 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01a2902c277d245e34b708c7aa314c4d33622ac3" translate="yes" xml:space="preserve">
          <source>Each method of a generated function has its own view of defined functions:</source>
          <target state="translated">생성 된 함수의 각 메소드에는 자체 정의 된 함수보기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b280a43cc4fcfe2d9e44a5ed377411ad6dd61b84" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules&amp;mdash;there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt; as well as a first-class data structure associating names with values. Note that while variable bindings can be read externally, they can only be changed within the module to which they belong. As an escape hatch, you can always evaluate code inside that module to modify a variable; this guarantees, in particular, that module bindings cannot be modified externally by code that never calls &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">각 모듈은 다른 모든 모듈의 전역 범위와는 별도로 새로운 전역 범위를 도입합니다. 모두를 포괄하는 전역 범위는 없습니다. 모듈은 &lt;a href=&quot;../modules/index#modules&quot;&gt;using 또는 import&lt;/a&gt; 문을 통해 또는 점 표기법을 사용하는 정규화 된 액세스를 통해 다른 모듈의 변수를 범위에 도입 할 수 있습니다 . 즉, 각 모듈은 이름과 값을 연결하는 일류 데이터 구조 일뿐만 아니라 소위 &lt;em&gt;네임 스페이스&lt;/em&gt; 입니다. 변수 바인딩은 외부에서 읽을 수 있지만 속한 모듈 내에서만 변경할 수 있습니다. 이스케이프 해치로서 항상 해당 모듈 내부의 코드를 평가하여 변수를 수정할 수 있습니다. 이는 특히 모듈 바인딩이 &lt;code&gt;eval&lt;/code&gt; 을 호출하지 않는 코드에 의해 외부 적으로 수정 될 수 없음을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="3717f137bf0edf07318a78ca822c93213e8ab5c5" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt;. Note that variable bindings can only be changed within their global scope and not from an outside module.</source>
          <target state="translated">각 모듈은 다른 모든 모듈의 글로벌 범위와 별도로 새로운 글로벌 범위를 도입합니다. 포괄적 인 글로벌 범위는 없습니다. 모듈은 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using 또는 import&lt;/a&gt; 문을 통해 또는 점 표기법을 사용하는 정규화 된 액세스를 통해 다른 모듈의 변수를 해당 범위에 도입 할 수 있습니다 . 즉, 각 모듈은 이른바 &lt;em&gt;네임 스페이스&lt;/em&gt; 입니다. 변수 바인딩은 전역 범위 내에서만 변경할 수 있으며 외부 모듈에서는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf0da81b3dc87a0fd15f25539852984a31877c54" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.</source>
          <target state="translated">각 프로세스에는 관련 식별자가 있습니다. 대화 형 Julia 프롬프트를 제공하는 프로세스의 &lt;code&gt;id&lt;/code&gt; 는 항상 1입니다. 병렬 작업에 기본적으로 사용되는 프로세스를 &quot;작업자&quot;라고합니다. 프로세스가 하나만있는 경우 프로세스 1은 작업자로 간주됩니다. 그렇지 않으면 작업자는 프로세스 1 이외의 모든 프로세스로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf2bd42913eae23239a3ca6155fa30e146609bc" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods like &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt;. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.</source>
          <target state="translated">각 프로세스에는 연관된 식별자가 있습니다. 대화 형 Julia 프롬프트를 제공하는 프로세스의 &lt;code&gt;id&lt;/code&gt; 는 항상 1입니다. 병렬 작업에 기본적으로 사용되는 프로세스를 &quot;작업자&quot;라고합니다. 프로세스가 하나만있는 경우 프로세스 1은 작업자로 간주됩니다. 그렇지 않으면 작업자는 프로세스 1이 아닌 모든 프로세스로 간주됩니다. 따라서 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; 과 같은 병렬 처리 방법의 이점을 얻으려면 2 개 이상의 프로세스를 추가해야합니다 . 작업자에서 긴 계산이 실행되는 동안 주 프로세스에서 다른 작업을 수행하려는 경우 단일 프로세스를 추가하면 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4df120cd43c18561cb64b8f7f625bd660e549595" translate="yes" xml:space="preserve">
          <source>Each scope must have only one call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. Hence, if all variables cannot be pushed once by a single call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</source>
          <target state="translated">각 범위에는 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 호출이 하나만 있어야합니다 . 따라서 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 에 대한 단일 호출로 모든 변수를 한 번 푸시 할 수 없거나 푸시 할 변수 가 6 개 이상이고 인수 배열을 사용하는 것이 옵션이 아닌 경우 내부 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d282bb8a2c865839d970ad58b137b93bc00c7f72" translate="yes" xml:space="preserve">
          <source>Each successful &lt;code&gt;trylock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">성공한 각 &lt;code&gt;trylock&lt;/code&gt; 은 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22844561d348de2a6b27cf89433a65f8efbcb6b9" translate="yes" xml:space="preserve">
          <source>Each task handles all incoming messages from a single remote worker in a message-processing loop.</source>
          <target state="translated">각 작업은 단일 원격 작업자의 모든 수신 메시지를 메시지 처리 루프에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="959d90366413778f223799834532da2e5d798af8" translate="yes" xml:space="preserve">
          <source>Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.</source>
          <target state="translated">각 작업자는 로컬 인터페이스 중 하나에 만 바인딩하고 OS에서 할당 한 임시 포트 번호를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="7f33a61e2ebfeda0d2e414fecf682c309512f02f" translate="yes" xml:space="preserve">
          <source>Each worker connects to all workers whose &lt;code&gt;id&lt;/code&gt; is less than the worker's own &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">각 근로자는 자신의 &lt;code&gt;id&lt;/code&gt; 보다 &lt;code&gt;id&lt;/code&gt; 가 작은 모든 근로자에게 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="296ff54bedf2c4c2f12fadf9f3d4dae7319b0178" translate="yes" xml:space="preserve">
          <source>Each worker starts listening on a free port and writes out its host and port information to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 작업자는 사용 가능한 포트에서 청취를 시작하고 호스트 및 포트 정보를 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 에&lt;/a&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d4b6573c03375a2d09bcdcc1d5adf31597eebb48" translate="yes" xml:space="preserve">
          <source>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</source>
          <target state="translated">게으른 매트릭스 전치 / 접근을 열심히 평가합니다. 조옮김은 요소에 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="27b938020515cf5bb6d2984093bfbe7ab6d70ad5" translate="yes" xml:space="preserve">
          <source>Ear</source>
          <target state="translated">Ear</target>
        </trans-unit>
        <trans-unit id="f97bff7e2b8198bfce99e20d9dc3037ca7cb582c" translate="yes" xml:space="preserve">
          <source>Ear Of Maize</source>
          <target state="translated">옥수수의 귀</target>
        </trans-unit>
        <trans-unit id="3d9d70794f61bff1149af95c6f4cc244fdd11015" translate="yes" xml:space="preserve">
          <source>Ear Of Rice</source>
          <target state="translated">쌀 귀</target>
        </trans-unit>
        <trans-unit id="b212969dc9e512428d09170cadc608095d96ef4b" translate="yes" xml:space="preserve">
          <source>Early filtering and message handling</source>
          <target state="translated">조기 필터링 및 메시지 처리</target>
        </trans-unit>
        <trans-unit id="02013cc67046fdd1aae8de2e9297f90c75b1d103" translate="yes" xml:space="preserve">
          <source>Early filtering of events</source>
          <target state="translated">이벤트의 조기 필터링</target>
        </trans-unit>
        <trans-unit id="45ba28d774fd86488ce1c503089d1e80918e6cda" translate="yes" xml:space="preserve">
          <source>Earth Globe Americas</source>
          <target state="translated">지구 지구 아메리카</target>
        </trans-unit>
        <trans-unit id="32a31b8413404bbe823a0be0f2215daa04efa961" translate="yes" xml:space="preserve">
          <source>Earth Globe Asia-Australia</source>
          <target state="translated">지구 지구 아시아-호주</target>
        </trans-unit>
        <trans-unit id="e225e5febaa3e5d132e6c4f42f17f6e28d6415c5" translate="yes" xml:space="preserve">
          <source>Earth Globe Europe-Africa</source>
          <target state="translated">지구 지구 유럽-아프리카</target>
        </trans-unit>
        <trans-unit id="38a01a67cf8e4d332986b68f2fc71763c696a896" translate="yes" xml:space="preserve">
          <source>Edit a file or directory optionally providing a line number to edit the file at. Return to the &lt;code&gt;julia&lt;/code&gt; prompt when you quit the editor. The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">선택적으로 파일을 편집 할 행 번호를 제공하는 파일 또는 디렉토리를 편집하십시오. 편집기를 종료 하면 &lt;code&gt;julia&lt;/code&gt; 프롬프트로 돌아갑니다 . &lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; 또는 &lt;code&gt;EDITOR&lt;/code&gt; 를 환경 변수로 설정하여 편집기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96bf75cf90aee425bd296ba4a82e787d511340ac" translate="yes" xml:space="preserve">
          <source>Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; first.</source>
          <target state="translated">선택적으로 편집 할 메소드를 표시하기 위해 유형의 튜플을 지정하여 함수의 정의를 편집하십시오. 모듈의 경우 기본 소스 파일을여십시오. 먼저 모듈을 &lt;code&gt;using&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 모듈을로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f916e6f9856dcbd1006ae78298c4b5adcd077534" translate="yes" xml:space="preserve">
          <source>Editors which cannot open to a specific line with a command may ignore the &lt;code&gt;line&lt;/code&gt; argument. The &lt;code&gt;fn&lt;/code&gt; callback must return either an appropriate &lt;code&gt;Cmd&lt;/code&gt; object to open a file or &lt;code&gt;nothing&lt;/code&gt; to indicate that they cannot edit this file. Use &lt;code&gt;nothing&lt;/code&gt; to indicate that this editor is not appropriate for the current environment and another editor should be attempted. It is possible to add more general editing hooks that need not spawn external commands by pushing a callback directly to the vector &lt;code&gt;EDITOR_CALLBACKS&lt;/code&gt;.</source>
          <target state="translated">명령으로 특정 줄을 열 수없는 편집자는 &lt;code&gt;line&lt;/code&gt; 인수를 무시할 수 있습니다 . &lt;code&gt;fn&lt;/code&gt; 콜백 적절한 중 하나를 반환해야 &lt;code&gt;Cmd&lt;/code&gt; 를의 파일이나 열 개체 &lt;code&gt;nothing&lt;/code&gt; 가이 파일을 편집 할 수없는 것을 나타 내기 위해서입니다. 이 편집기가 현재 환경에 적합하지 않으며 다른 편집기를 시도해야 함을 나타내려면 &lt;code&gt;nothing&lt;/code&gt; 사용 하지 마십시오. 콜백을 벡터 &lt;code&gt;EDITOR_CALLBACKS&lt;/code&gt; 에 직접 푸시하여 외부 명령을 생성 할 필요가없는보다 일반적인 편집 후크를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c375fe45e00ed5d286a20e4c69197b11257ae1df" translate="yes" xml:space="preserve">
          <source>Efficient algorithms are implemented for &lt;code&gt;H \ b&lt;/code&gt;, &lt;code&gt;det(H)&lt;/code&gt;, and similar.</source>
          <target state="translated">&lt;code&gt;H \ b&lt;/code&gt; , &lt;code&gt;det(H)&lt;/code&gt; 등에 대해 효율적인 알고리즘이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="44dc07f2fcde6067bce262b5efc8feb032594384" translate="yes" xml:space="preserve">
          <source>Efficient support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, including but not limited to &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 을 포함하지만 이에 국한되지 않는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;유니 코드&lt;/a&gt; 에 대한 효율적인 지원</target>
        </trans-unit>
        <trans-unit id="86a35f1cb66a4b67fe0a08c54f9a06ca22ca2502" translate="yes" xml:space="preserve">
          <source>Eight Pointed Black Star</source>
          <target state="translated">여덟 뾰족한 검은 별</target>
        </trans-unit>
        <trans-unit id="b096e49c067864c8657cc77cb2489f9c7a46a60c" translate="yes" xml:space="preserve">
          <source>Eight Spoked Asterisk</source>
          <target state="translated">8 스포크 별표</target>
        </trans-unit>
        <trans-unit id="64b33bc5b072bf67cae39a4367e9262f072d0983" translate="yes" xml:space="preserve">
          <source>Eighth Note</source>
          <target state="translated">여덟째 주</target>
        </trans-unit>
        <trans-unit id="3e48f6a437e3973638b906ba62fc55ca1cbd9219" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;EltypeUnknown()&lt;/code&gt; or &lt;code&gt;HasEltype()&lt;/code&gt; as appropriate</source>
          <target state="translated">어느 &lt;code&gt;EltypeUnknown()&lt;/code&gt; 또는 &lt;code&gt;HasEltype()&lt;/code&gt; 적절한</target>
        </trans-unit>
        <trans-unit id="a0e204f765f5ad928475881aca7c13ef5c65e351" translate="yes" xml:space="preserve">
          <source>Electric Light Bulb</source>
          <target state="translated">전구</target>
        </trans-unit>
        <trans-unit id="b15c5b6da40c647c02530732f2c154f67995f39b" translate="yes" xml:space="preserve">
          <source>Electric Plug</source>
          <target state="translated">전기 플러그</target>
        </trans-unit>
        <trans-unit id="3f114e1bd5e42dad4fb0e15a6f2fe2cdbffd8d5c" translate="yes" xml:space="preserve">
          <source>Electric Torch</source>
          <target state="translated">전기 토치</target>
        </trans-unit>
        <trans-unit id="8bc90f041dc25b644c48594037e5678f3120b766" translate="yes" xml:space="preserve">
          <source>Electrical Intersection</source>
          <target state="translated">전기 교차점</target>
        </trans-unit>
        <trans-unit id="94a626de4e05a050364a69d3ed8b52928fa721f2" translate="yes" xml:space="preserve">
          <source>Elegant and extensible conversions and promotions for numeric and other types</source>
          <target state="translated">숫자 및 기타 유형에 대한 우아하고 확장 가능한 변환 및 프로모션</target>
        </trans-unit>
        <trans-unit id="b145388f2a6c1f663c46cc3fef6df0278b0d0e7b" translate="yes" xml:space="preserve">
          <source>Element Of</source>
          <target state="translated">요소</target>
        </trans-unit>
        <trans-unit id="c7e75d5c58d3d99fb0549bbb6eebd8b77418f140" translate="yes" xml:space="preserve">
          <source>Element Of Opening Downwards</source>
          <target state="translated">아래쪽으로 여는 요소</target>
        </trans-unit>
        <trans-unit id="ec9d5e51a88871a1e6bce9e1d8f55eddb1be4d6d" translate="yes" xml:space="preserve">
          <source>Element Of Opening Upwards</source>
          <target state="translated">개방의 요소</target>
        </trans-unit>
        <trans-unit id="eabe348be570b5c3a81b5a78a24f6bc500a5b337" translate="yes" xml:space="preserve">
          <source>Element Of With Dot Above</source>
          <target state="translated">위의 점이있는 요소</target>
        </trans-unit>
        <trans-unit id="17bfb5ca72c4a27f20d3d15f5185aabec39f3a3b" translate="yes" xml:space="preserve">
          <source>Element Of With Long Horizontal Stroke</source>
          <target state="translated">긴 수평 스트로크의 요소</target>
        </trans-unit>
        <trans-unit id="f3443f2657692062978d73b4527d8f3f59f40708" translate="yes" xml:space="preserve">
          <source>Element Of With Overbar</source>
          <target state="translated">오버 바와의 요소</target>
        </trans-unit>
        <trans-unit id="0335789ad2498b26e35d6c835f82cac2d005c318" translate="yes" xml:space="preserve">
          <source>Element Of With Two Horizontal Strokes</source>
          <target state="translated">두 개의 수평 획의 요소</target>
        </trans-unit>
        <trans-unit id="71f5f71f9939ea54d51a735c864b74e3967c3ba7" translate="yes" xml:space="preserve">
          <source>Element Of With Underbar</source>
          <target state="translated">밑줄의 요소</target>
        </trans-unit>
        <trans-unit id="256f897f2234cedafe188f182b0344400f8e1c28" translate="yes" xml:space="preserve">
          <source>Element Of With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">수평 스트로크 끝에 수직 막대가있는 요소</target>
        </trans-unit>
        <trans-unit id="86ab7fa25cb358d66e37e0c0a1c13bec1b3787f5" translate="yes" xml:space="preserve">
          <source>Elementary Functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="97b701a83c60171055869225a728b6d2098cfc55" translate="yes" xml:space="preserve">
          <source>Elementary operations</source>
          <target state="translated">초등 작업</target>
        </trans-unit>
        <trans-unit id="1c6f116ce35bbe8b5c5b3a26cfa9e63c4b7cff24" translate="yes" xml:space="preserve">
          <source>Elephant</source>
          <target state="translated">Elephant</target>
        </trans-unit>
        <trans-unit id="628aee648dc7795c701c3ac4168565c49ba7d8a8" translate="yes" xml:space="preserve">
          <source>Eliminates array bounds checking within expressions.</source>
          <target state="translated">식 내에서 배열 범위 검사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="436e5580dafe4837fafc385b6832e44770757da8" translate="yes" xml:space="preserve">
          <source>Em Dash</source>
          <target state="translated">엠 대쉬</target>
        </trans-unit>
        <trans-unit id="54edea64256fec1b9afd042056c683a5e954b05d" translate="yes" xml:space="preserve">
          <source>Em Space</source>
          <target state="translated">엠 스페이스</target>
        </trans-unit>
        <trans-unit id="fd5fa6acc8725853ec64793d0347faa7182d2f81" translate="yes" xml:space="preserve">
          <source>Embedding Julia</source>
          <target state="translated">줄리아 임베딩</target>
        </trans-unit>
        <trans-unit id="8638f2d27f26ab330e90a52d10d3ba6e903a995b" translate="yes" xml:space="preserve">
          <source>Emit bounds checks always or never (ignoring declarations)</source>
          <target state="translated">경계 검사를 항상 또는 전혀 방출하지 않음 (선언 무시)</target>
        </trans-unit>
        <trans-unit id="6822793744c195c06628e13a8e25bb8ee807d832" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-1-2</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-1-2</target>
        </trans-unit>
        <trans-unit id="e7d0e508f11f735e99c8bf9621166a5b98508edb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-3</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-3</target>
        </trans-unit>
        <trans-unit id="27052bd6bf6386f71c6cd2f5155906907462e4eb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-4</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-4</target>
        </trans-unit>
        <trans-unit id="1a1f8c73826ca18825ae5fad787b1128670acb3c" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-5</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-5</target>
        </trans-unit>
        <trans-unit id="ddf70184418afb46c24a9ba734226beae8038ce5" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-6</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-6</target>
        </trans-unit>
        <trans-unit id="92732205e250b4761981020982f3419de88cf7db" translate="yes" xml:space="preserve">
          <source>Empty Set</source>
          <target state="translated">빈 세트</target>
        </trans-unit>
        <trans-unit id="8ec062085bcc2b801f216fc4c40783b689f973cf" translate="yes" xml:space="preserve">
          <source>Empty Set With Left Arrow Above</source>
          <target state="translated">위 왼쪽 화살표와 함께 빈 세트</target>
        </trans-unit>
        <trans-unit id="d91ae9a03edea62c7bd20d9ba629d7162aa63219" translate="yes" xml:space="preserve">
          <source>Empty Set With Overbar</source>
          <target state="translated">오버 바로 빈 세트</target>
        </trans-unit>
        <trans-unit id="6d8f951440669eb13bd78e4eb7585eb670aa5993" translate="yes" xml:space="preserve">
          <source>Empty Set With Right Arrow Above</source>
          <target state="translated">위의 오른쪽 화살표가있는 빈 세트</target>
        </trans-unit>
        <trans-unit id="43f45b3c27e994f1786fe11853d88094ff3f0d3a" translate="yes" xml:space="preserve">
          <source>Empty Set With Small Circle Above</source>
          <target state="translated">위의 작은 동그라미와 빈 세트</target>
        </trans-unit>
        <trans-unit id="5ebfd6f75b259f38d9a9191637cf54107c71d5e2" translate="yes" xml:space="preserve">
          <source>Empty arrays like &lt;code&gt;[]&lt;/code&gt;, which select no elements</source>
          <target state="translated">요소를 선택하지 않는 &lt;code&gt;[]&lt;/code&gt; 와 같은 빈 배열</target>
        </trans-unit>
        <trans-unit id="d1b6081c62b3668f73437e7ef55230193e6e2dec" translate="yes" xml:space="preserve">
          <source>Empty generic functions</source>
          <target state="translated">빈 일반 함수</target>
        </trans-unit>
        <trans-unit id="74006a3cefa65eb24a50f14a080a0a283848825f" translate="yes" xml:space="preserve">
          <source>En Dash</source>
          <target state="translated">엔 대쉬</target>
        </trans-unit>
        <trans-unit id="1628cc600d641d86574721f4cba6f82ac4859ad1" translate="yes" xml:space="preserve">
          <source>En Space</source>
          <target state="translated">엔 스페이스</target>
        </trans-unit>
        <trans-unit id="c26082fba43142d1c87a99220a9c21dffcbbcbfe" translate="yes" xml:space="preserve">
          <source>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</source>
          <target state="translated">디버그 정보 생성 수준 활성화 / 설정 (기본 수준은 지정되지 않은 경우 1, 수준없이 사용 된 경우 2)</target>
        </trans-unit>
        <trans-unit id="cdf7726a55289566143a4b529102535c5730b7a5" translate="yes" xml:space="preserve">
          <source>Enable N threads; &lt;code&gt;auto&lt;/code&gt; currently sets N to the number of local CPU threads but this might change in the future</source>
          <target state="translated">N 스레드를 활성화합니다. &lt;code&gt;auto&lt;/code&gt; 는 현재 N을 로컬 CPU 스레드 수로 설정하지만 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f89b819c104d36c25c43b4b3679d57166fd8a76d" translate="yes" xml:space="preserve">
          <source>Enable debug logging for a file or module, see &lt;a href=&quot;../../stdlib/logging/index#Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">파일 또는 모듈에 대한 디버그 로깅을 활성화 합니다. 자세한 내용 은 &lt;a href=&quot;../../stdlib/logging/index#Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99d7732e401f3ac5abd96dcf18eb471bc62eedcf" translate="yes" xml:space="preserve">
          <source>Enable or disable Julia's default signal handlers</source>
          <target state="translated">Julia의 기본 신호 처리기 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="868de4fff11fc1378b5bf090b18d305dd45bc334" translate="yes" xml:space="preserve">
          <source>Enable or disable color text</source>
          <target state="translated">컬러 텍스트 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="5c9a249a64cc4fd650a34fa825cad6ef21b766ee" translate="yes" xml:space="preserve">
          <source>Enable or disable incremental precompilation of modules</source>
          <target state="translated">모듈의 증분 프리 컴파일 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="a51c0e3a6688b962a589c4b3871584f7a8a45cd2" translate="yes" xml:space="preserve">
          <source>Enable or disable method overwrite warnings</source>
          <target state="translated">메소드 덮어 쓰기 경고 사용 또는 사용 안함</target>
        </trans-unit>
        <trans-unit id="aca528646e6712e710558c2a4eb1f14f7c2f63c3" translate="yes" xml:space="preserve">
          <source>Enable or disable startup banner</source>
          <target state="translated">시작 배너 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="2ca0be31a9b9b42744412a3827771e952db1ba08" translate="yes" xml:space="preserve">
          <source>Enable or disable syntax and method deprecation warnings (&lt;code&gt;error&lt;/code&gt; turns warnings into errors)</source>
          <target state="translated">구문 및 메소드 지원 중단 경고를 사용하거나 사용하지 않습니다 ( &lt;code&gt;error&lt;/code&gt; 는 경고를 오류로 바꿉니다)</target>
        </trans-unit>
        <trans-unit id="dd61ab9cf22b749efe0c17fd33d2e5ed63c746f4" translate="yes" xml:space="preserve">
          <source>Enable the GC, return previous state as int</source>
          <target state="translated">GC를 활성화하고 이전 상태를 int로 반환</target>
        </trans-unit>
        <trans-unit id="8e8469c75c7e1c37ce55e37721cd77e479242109" translate="yes" xml:space="preserve">
          <source>Enables or disables Nagle's algorithm on a given TCP server or socket.</source>
          <target state="translated">주어진 TCP 서버 또는 소켓에서 Nagle의 알고리즘을 활성화하거나 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="bab95ff490fda9c25eacf7c86628805a78ecd8fa" translate="yes" xml:space="preserve">
          <source>End Of Proof</source>
          <target state="translated">증명의 끝</target>
        </trans-unit>
        <trans-unit id="ad9d937f40f9885915fd0bc9430bfd7d6e63f0d4" translate="yes" xml:space="preserve">
          <source>End With Leftwards Arrow Above</source>
          <target state="translated">위의 왼쪽 화살표로 끝남</target>
        </trans-unit>
        <trans-unit id="348ce364668910edabfd008dfd0d3a94254a6fef" translate="yes" xml:space="preserve">
          <source>End, &lt;code&gt;^E&lt;/code&gt;</source>
          <target state="translated">끝, &lt;code&gt;^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0891cb9306e1015f2471b30de2c6d9cc3c5bab0c" translate="yes" xml:space="preserve">
          <source>Ensuring that all arguments support broadcast</source>
          <target state="translated">모든 주장이 방송을 지원하도록 보장</target>
        </trans-unit>
        <trans-unit id="a74398c918fa81c3c891469eb00e56ab1bce6a94" translate="yes" xml:space="preserve">
          <source>Enter help or shell mode (when at start of a line)</source>
          <target state="translated">도움말 또는 쉘 모드를 입력하십시오 (행 시작시)</target>
        </trans-unit>
        <trans-unit id="e641b987ac9e8ea3ec201a6a67556391d2e16178" translate="yes" xml:space="preserve">
          <source>Enum constant for &lt;a href=&quot;#Libdl.dlopen&quot;&gt;&lt;code&gt;dlopen&lt;/code&gt;&lt;/a&gt;. See your platform man page for details, if applicable.</source>
          <target state="translated">&lt;a href=&quot;#Libdl.dlopen&quot;&gt; &lt;code&gt;dlopen&lt;/code&gt; 의&lt;/a&gt; 열거 형 정수입니다 . 해당되는 경우 자세한 내용은 플랫폼 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3d4759b02e49d42abcfd8c6da270947288cfdfb3" translate="yes" xml:space="preserve">
          <source>Enums.@enum</source>
          <target state="translated">Enums.@enum</target>
        </trans-unit>
        <trans-unit id="9848c4523e6e3aa918b1c25741d4c5549ef8d0ad" translate="yes" xml:space="preserve">
          <source>Enums.Enum</source>
          <target state="translated">Enums.Enum</target>
        </trans-unit>
        <trans-unit id="cc756bbce5c6a1daad1db7d15c8a2dcefb92b0e6" translate="yes" xml:space="preserve">
          <source>EnvDict</source>
          <target state="translated">EnvDict</target>
        </trans-unit>
        <trans-unit id="7f4a2c89d81b1eddb2e5160fabf3758acbd3a82d" translate="yes" xml:space="preserve">
          <source>Envelope</source>
          <target state="translated">Envelope</target>
        </trans-unit>
        <trans-unit id="6762c5bdd1e043549bb3b44e75155fdf9be1b7a5" translate="yes" xml:space="preserve">
          <source>Envelope With Downwards Arrow Above</source>
          <target state="translated">아래쪽 화살표가있는 봉투</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="941617a2c1b6b1aec2faae0db722ab34dd080e87" translate="yes" xml:space="preserve">
          <source>Environment stacks</source>
          <target state="translated">환경 스택</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="89641f9fa6e1bc519a9a2c77cb0174bd0af98e58" translate="yes" xml:space="preserve">
          <source>Environment variables :</source>
          <target state="translated">환경 변수 :</target>
        </trans-unit>
        <trans-unit id="19f829a38150f040480818f9393c99b2f11589f5" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="translated">터미널에서 REPL 출력 형식을 지정하는 방법을 결정하는 환경 변수입니다. 일반적으로 이러한 변수는 &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI 터미널 이스케이프 시퀀스&lt;/a&gt; 로 설정해야합니다 . Julia는 거의 동일한 기능을 가진 고급 인터페이스를 제공합니다. &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;Julia REPL&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50ee4c027fd890e4de416f6f3ab9a71f9c9e72e8" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="translated">터미널에서 REPL 출력을 형식화하는 방법을 결정하는 환경 변수. 일반적으로 이러한 변수는 &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI 터미널 이스케이프 시퀀스&lt;/a&gt; 로 설정해야합니다 . Julia는 동일한 기능을 가진 고급 인터페이스를 제공합니다. &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="3adc5cf208fce048a876da30f12ee121f6e24ef5" translate="yes" xml:space="preserve">
          <source>Equal And Parallel To</source>
          <target state="translated">동일하고 평행</target>
        </trans-unit>
        <trans-unit id="9014b90f8a5c287f9f7cca7cf1a09f7419d2e0a4" translate="yes" xml:space="preserve">
          <source>Equal To By Definition</source>
          <target state="translated">정의 별</target>
        </trans-unit>
        <trans-unit id="527d2270efb77ab589aa3d2bc8b1899c1c160dcc" translate="yes" xml:space="preserve">
          <source>Equal To Or Greater-Than / Equal To Or Greater Than</source>
          <target state="translated">같거나보다 크거나 같거나보다 큼</target>
        </trans-unit>
        <trans-unit id="6043f4fef98b74458e43463764bf902e73e8ff02" translate="yes" xml:space="preserve">
          <source>Equal To Or Less-Than / Equal To Or Less Than</source>
          <target state="translated">같거나보다 작거나 같거나보다 작음</target>
        </trans-unit>
        <trans-unit id="f6b115d144ac2f3557f089ae7d83d11f870e6ef8" translate="yes" xml:space="preserve">
          <source>Equal To Or Precedes</source>
          <target state="translated">같거나 선행</target>
        </trans-unit>
        <trans-unit id="3e050032f44766762506ff80de8be9a1911a3683" translate="yes" xml:space="preserve">
          <source>Equal To Or Succeeds</source>
          <target state="translated">같거나 성공</target>
        </trans-unit>
        <trans-unit id="15cfd415b36fe06b7025888786ae38085fcb3dbe" translate="yes" xml:space="preserve">
          <source>Equality and Comparison Operators</source>
          <target state="translated">평등 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="d8dae2f241fe4b5c985e7ee897c6b9676b9479ac" translate="yes" xml:space="preserve">
          <source>Equals Colon / Equal Colon</source>
          <target state="translated">동등한 콜론 / 동등한 콜론</target>
        </trans-unit>
        <trans-unit id="f93dc9419a85602368082c386c9a828a21bf6a6a" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Leftwards Arrow</source>
          <target state="translated">왼쪽 화살표 위의 기호</target>
        </trans-unit>
        <trans-unit id="ec3132ed55f4f598ba853ce4e35988f1d955c3eb" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Plus Sign</source>
          <target state="translated">더하기 기호 위의 기호</target>
        </trans-unit>
        <trans-unit id="77fb2dbe6663a45556f7650f2f6c1c73a590ed1c" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Tilde Operator</source>
          <target state="translated">물결표 연산자 위의 기호</target>
        </trans-unit>
        <trans-unit id="62609b0cf8c4d06d3037a7bf8e6a793f1d27492d" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel</source>
          <target state="translated">부호가 같고 기울어 진 평행</target>
        </trans-unit>
        <trans-unit id="23b4d26cbdac9571083cacc41611600ec79ff967" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel With Tilde Above</source>
          <target state="translated">위의 물결표와 동일하고 평행하게 기울어 짐</target>
        </trans-unit>
        <trans-unit id="392e4a8368a67b37c46109802dbf3b2bbe627e02" translate="yes" xml:space="preserve">
          <source>Equals Sign With Bumpy Above</source>
          <target state="translated">울퉁불퉁 한 위와 같은 표시</target>
        </trans-unit>
        <trans-unit id="f2b106f710b9bbc7d6d2a380faea7b8fd23ed23a" translate="yes" xml:space="preserve">
          <source>Equals Sign With Dot Below</source>
          <target state="translated">아래의 점이있는 기호</target>
        </trans-unit>
        <trans-unit id="292a343448e994eeed1ffd3fdb4c2c8eb86b5555" translate="yes" xml:space="preserve">
          <source>Equals Sign With Two Dots Above And Two Dots Below</source>
          <target state="translated">위의 두 개의 점과 아래의 두 개의 점이있는 기호</target>
        </trans-unit>
        <trans-unit id="5e945a1cf2921ae612b33494ebe19cfd549e10ac" translate="yes" xml:space="preserve">
          <source>Equals With Asterisk</source>
          <target state="translated">별표와 동일</target>
        </trans-unit>
        <trans-unit id="f3f7928443c385bebfa509e6448cd7d63a9cc4a2" translate="yes" xml:space="preserve">
          <source>Equiangular To</source>
          <target state="translated">등변</target>
        </trans-unit>
        <trans-unit id="0dae504b4d888ad200cb544ee05069b242235880" translate="yes" xml:space="preserve">
          <source>Equivalent To</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="209bb1206181d9c196e80f6965debb3ab3399f46" translate="yes" xml:space="preserve">
          <source>Equivalent With Four Dots Above</source>
          <target state="translated">위의 4 개의 점과 동일</target>
        </trans-unit>
        <trans-unit id="bdeb0fcd2d5eaaa85eb93b2bbb4eae42f75d7875" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</source>
          <target state="translated">상당 &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a444cba5b25b06d85c75d2cdc5490f28108cce13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawn expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fetch(@spawn expr)&lt;/code&gt; 와 같습니다 . &lt;code&gt;fetch&lt;/code&gt; 및 &lt;a href=&quot;#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04a15056af777844fc12e01881e2375b1a9bb29c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat :any expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fetch(@spawnat :any expr)&lt;/code&gt; 와 동일합니다 . &lt;code&gt;fetch&lt;/code&gt; 및 &lt;a href=&quot;#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb3145567457b210ea2803bee24b9156158b97cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt; 와 같습니다 . &lt;code&gt;fetch&lt;/code&gt; 및 &lt;a href=&quot;#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ce9a67772da7b41e7c54b6a2b9da8ba6fbcc2a7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git branch&lt;/code&gt;. Create a new branch from the current HEAD.</source>
          <target state="translated">&lt;code&gt;git branch&lt;/code&gt; 와 같습니다 . 현재 HEAD에서 새 분기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ad57947a691137150d754570a8ec38ac67d31bf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d743c43b1f86bc4c8cac6b46919f9f746db86863" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt;. Checkout the git commit &lt;code&gt;commit&lt;/code&gt; (a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) in &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, force the checkout and discard any current changes. Note that this detaches the current HEAD.</source>
          <target state="translated">동등 &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt; . &lt;code&gt;repo&lt;/code&gt; 에서 git commit &lt;code&gt;commit&lt;/code&gt; ( 문자열 형태 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; )&lt;/a&gt; 을 체크 아웃하십시오 . 경우 &lt;code&gt;force&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 체크 아웃을 강제로 현재의 모든 변경 사항을 취소. 이렇게하면 현재 HEAD가 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="901e29752c2ee8a70b5ed5fe68c348abc419a1fa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad74bb24ad9c1d3be87108ffc378bb2da2cc9f9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d427754f80d9c8df017cbc0092318835b0e696" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8f3cd0f685b341a1ae14b9341b4e36c903d172" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332ee7d1accb14409369b51e9d27080d4e0d14ed" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0083711cca7b02373661eae132e8a9c8507549ec" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eabda327026b4f99bb6d32a8fbcdc496382a0b31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6790132b2a9497e212bac7d4cf8fd0dd3edd5e55" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652b9155620394c1b1868072030e6b42f726640f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a71f2870da7113263fbb72943176e45aaa35d2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git update-index&lt;/code&gt;. Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;repo&lt;/code&gt; needs updating.</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 와 같습니다 . &lt;code&gt;repo&lt;/code&gt; 를 업데이트해야하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6ae3107848d44951e6909ca431ab304a4e9d539" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).ctime&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;stat(file).ctime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a4ce7135ab64a453fd910fc4aa56e36ba1ee2e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat(file).mode&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a1382d7c1945d0f98e93198d22d79e261cf0056" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mtime&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;stat(file).mtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe4fd466e331817e41386a75031f2b796ddfe458" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat(file).size&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0e823580a07913d38604c722d16a5560458f01a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; 여기서, &lt;code&gt;i&lt;/code&gt; 가 위치 인 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f31ba230aca25c1b698d1cc7150cef0b7b302c5" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9eaa630d94bb27275e18bb3b960a961c0a1f0f4b" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;char&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;char&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="118bc4f07f9064de09c7d27e3dc69b842c07d3cb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;double&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;double&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdf6e4eb22892b98b092275da9c573a01025062d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;float&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;float&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="699b0aa6e72445454df17960d3daa3c9e6cc0497" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;intmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;intmax_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ) 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fb40c99637fa47e326a9d7aab30c227079ce80bd" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type (&lt;code&gt;Int&lt;/code&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type ( &lt;code&gt;Int&lt;/code&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="864b89ace5975f766b1aac60a330727b39bce821" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;signed int&lt;/code&gt; c- 형 ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42f2a96aef8ef6b3b801a9ca2e3e8f2afcb4b1e9" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;signed long long&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5cd170ceee5df72650f75fb3558c1e0d584a0dc" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;signed long&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc320fb0e8a7512a786d769855e2e089a153ce2" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;signed short&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e69f65df3ca222b477f6e9993f20448b4bdae0f" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;size_t&lt;/code&gt; c-type (&lt;code&gt;UInt&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;size_t&lt;/code&gt; c- 타입 ( &lt;code&gt;UInt&lt;/code&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="264d1040fe211b837b556b11ff091efb6a3f53bb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ssize_t&lt;/code&gt; c-type.</source>
          <target state="translated">기본 &lt;code&gt;ssize_t&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbd9e2c996a261d76f3ff53391f8e38719fe9e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;uintmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;uintmax_t&lt;/code&gt; c 유형 ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c8ce8fa159766da046ddd33786548e72dee4d9d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned char&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned char&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="344ab3cdb03d54ba12a0e16e58a7476236a61e4d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned int&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55d9ab0846117166f39d8e403505f1471a82f976" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned long long&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b3c06e09eab11aa3d1730ea23df9a5045171b15" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned long&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="016e279d1d48e1d87938958891ce84c0cfdfcbbb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned short&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c9bbcb68fcb17f0cce9547b0872debb3c579553" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;wchar_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;wchar_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="698b31ff8b5d1a102369509499209b09eacc9225" translate="yes" xml:space="preserve">
          <source>Errors can also be handled by retrying failed computations. Keyword arguments &lt;code&gt;retry_delays&lt;/code&gt; and &lt;code&gt;retry_check&lt;/code&gt; are passed through to &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt; as keyword arguments &lt;code&gt;delays&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</source>
          <target state="translated">실패한 계산을 재 시도하여 오류를 처리 할 수도 있습니다. 키워드 인수 &lt;code&gt;retry_delays&lt;/code&gt; 및 &lt;code&gt;retry_check&lt;/code&gt; 는 키워드 인수 &lt;code&gt;delays&lt;/code&gt; 및 &lt;code&gt;check&lt;/code&gt; 각각 &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt; &lt;code&gt;retry&lt;/code&gt; &lt;/a&gt; 하기 위해 전달 됩니다. 배치가 지정되고 전체 배치가 실패하면 배치의 모든 항목이 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d7a4876d3316d08fbc2b13153db110692b9665" translate="yes" xml:space="preserve">
          <source>Escaped backslash (&lt;code&gt;\\&lt;/code&gt;)</source>
          <target state="translated">이스케이프 된 백 슬래시 ( &lt;code&gt;\\&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cc1c125b60f307138cb9e72beb52b2e7792689de" translate="yes" xml:space="preserve">
          <source>Escaped double-quote (&lt;code&gt;\&quot;&lt;/code&gt;)</source>
          <target state="translated">이스케이프 된 큰 따옴표 ( &lt;code&gt;\&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="06580f39a051b4e6ef99253897a370dadc16359c" translate="yes" xml:space="preserve">
          <source>Essentials</source>
          <target state="translated">Essentials</target>
        </trans-unit>
        <trans-unit id="e8510e15707f994fff8e2c28fa38378116dc350d" translate="yes" xml:space="preserve">
          <source>Estimates</source>
          <target state="translated">Estimates</target>
        </trans-unit>
        <trans-unit id="b9ba339b04699a110d3fe7f5b9f39b67a033e6ff" translate="yes" xml:space="preserve">
          <source>Estimates the error in the solution to &lt;code&gt;A * X = B&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt;, or the equivalent equations a right-handed &lt;code&gt;side = R&lt;/code&gt;&lt;code&gt;X * A&lt;/code&gt; after computing &lt;code&gt;X&lt;/code&gt; using &lt;code&gt;trtrs!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is lower triangular. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;Ferr&lt;/code&gt; and &lt;code&gt;Berr&lt;/code&gt; are optional inputs. &lt;code&gt;Ferr&lt;/code&gt; is the forward error and &lt;code&gt;Berr&lt;/code&gt; is the backward error, each component-wise.</source>
          <target state="translated">추정치 용액의 오차 &lt;code&gt;A * X = B&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; , 또는 &lt;code&gt;trtrs!&lt;/code&gt; 사용하여 &lt;code&gt;X&lt;/code&gt; 를 계산 &lt;code&gt;X * A&lt;/code&gt; 후 등가 방정식 오른손 &lt;code&gt;side = R&lt;/code&gt; X * A ! . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 위 삼각형이다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 낮은 삼각형이다. 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. 경우 &lt;code&gt;diag = U&lt;/code&gt; 의 모든 대각선 요소를 &lt;code&gt;A&lt;/code&gt; 는 하나입니다. &lt;code&gt;Ferr&lt;/code&gt; 및 &lt;code&gt;Berr&lt;/code&gt; 은 선택적 입력입니다. &lt;code&gt;Ferr&lt;/code&gt; 은 정방향 오류이고 &lt;code&gt;Berr&lt;/code&gt; 은 정방향 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f36e35f5e8b00caa694f59163398facd608ea93b" translate="yes" xml:space="preserve">
          <source>Euler Constant / Eulers</source>
          <target state="translated">오일러 상수 / 오일러</target>
        </trans-unit>
        <trans-unit id="2e207df50d2607a1fe4fc27fe314291135737c83" translate="yes" xml:space="preserve">
          <source>Euler's constant.</source>
          <target state="translated">오일러의 상수.</target>
        </trans-unit>
        <trans-unit id="44623d7804a9c26efcde5e7649c3cb20b91a39c3" translate="yes" xml:space="preserve">
          <source>Euro Sign</source>
          <target state="translated">유로 기호</target>
        </trans-unit>
        <trans-unit id="57a3202bd3e441520bd7d609cab598bcb00faf56" translate="yes" xml:space="preserve">
          <source>European Castle</source>
          <target state="translated">유럽 ​​성</target>
        </trans-unit>
        <trans-unit id="c85713b44c54b59d5e3730564793b844ff3a2225" translate="yes" xml:space="preserve">
          <source>European Post Office</source>
          <target state="translated">유럽 ​​우체국</target>
        </trans-unit>
        <trans-unit id="70431e2cf67367675e48b7000db056935aff96a4" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 평가</target>
        </trans-unit>
        <trans-unit id="07ce5a176f4ebcfe9263b70e6399c95e665e2889" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; and display the result</source>
          <target state="translated">&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 을 평가 하고 결과를 표시하십시오</target>
        </trans-unit>
        <trans-unit id="25162b98d6071e304907ff82a3a467fb9271d77e" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the given module and return the result.</source>
          <target state="translated">주어진 모듈에서 표현식을 평가하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f829ca8274917256304e4a58cd74009eea2d9d8" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the global scope of the containing module. Every &lt;code&gt;Module&lt;/code&gt; (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;eval&lt;/code&gt;, which evaluates expressions in that module.</source>
          <target state="translated">포함 모듈의 전체 범위에서 표현식을 평가하십시오. &lt;code&gt;baremodule&lt;/code&gt; 으로 정의 된 &lt;code&gt;Module&lt;/code&gt; 제외한 모든 모듈 에는 &lt;code&gt;eval&lt;/code&gt; 의 자체 1- 인수 정의가 있으며 해당 모듈의 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="2601dc536c9d898fbb26df788d4c9e5325bd9791" translate="yes" xml:space="preserve">
          <source>Evaluate an expression with values interpolated into it using &lt;code&gt;eval&lt;/code&gt;. If two arguments are provided, the first is the module to evaluate in.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 을 사용하여 보간 된 값으로 표현식을 평가하십시오 . 두 개의 인수가 제공되면 첫 번째 인수는 평가할 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="0e1822550830e88855261b7ab222f92611690733" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt; 의 전역 범위에서 입력 소스 파일의 내용을 평가하십시오 . &lt;a href=&quot;#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; 로&lt;/a&gt; 정의 된 모듈을 제외한 모든 모듈 &lt;code&gt;include&lt;/code&gt; 의 고유 한 1- 인수 정의가 있으며 해당 모듈의 파일을 평가합니다. 입력 파일의 마지막으로 평가 된 표현식의 결과를 리턴합니다. 포함하는 동안 태스크 로컬 포함 경로는 파일을 포함하는 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 호출 은 해당 경로를 기준으로 검색합니다. 이 기능은 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분리 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b612928c09f072c08e5798d5159ed31466947d90" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt; omitting the &lt;code&gt;m&lt;/code&gt; argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt; 의 전역 범위에서 입력 소스 파일의 내용을 평가합니다 . 모든 모듈 ( &lt;a href=&quot;#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; 로&lt;/a&gt; 정의 된 모듈 제외 )에는 해당 모듈의 파일을 평가하는 &lt;code&gt;m&lt;/code&gt; 인수를 생략하는 자체 정의가 &lt;code&gt;include&lt;/code&gt; . 입력 파일의 마지막으로 평가 된 표현식의 결과를 반환합니다. 포함하는 동안 작업 로컬 포함 경로는 파일이 포함 된 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 된 호출 은 해당 경로를 기준으로 검색합니다. 이 함수는 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분할 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31d4172b689085063db7676aaaf218e8295b9200" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">포함 모듈의 전체 범위에서 입력 소스 파일의 내용을 평가하십시오. &lt;code&gt;baremodule&lt;/code&gt; 로 정의 된 모듈을 제외한 모든 모듈 &lt;code&gt;include&lt;/code&gt; 의 고유 한 1- 인수 정의가 있으며이 모듈에서 파일을 평가합니다. 입력 파일의 마지막으로 평가 된 표현식의 결과를 리턴합니다. 포함하는 동안 태스크 로컬 포함 경로는 파일을 포함하는 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 호출 은 해당 경로를 기준으로 검색합니다. 이 기능은 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분리 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f1c29d4ad5838bc52b4059149cf23bc056eedf" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">포함하는 모듈의 전역 범위에서 입력 소스 파일의 내용을 평가합니다. 모든 모듈 ( &lt;code&gt;baremodule&lt;/code&gt; 로 정의 된 모듈 제외 )에는 해당 모듈의 파일을 평가하는 자체 정의 &lt;code&gt;include&lt;/code&gt; 가 있습니다 . 입력 파일의 마지막으로 평가 된 표현식의 결과를 반환합니다. 포함하는 동안 작업 로컬 포함 경로는 파일이 포함 된 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 된 호출 은 해당 경로를 기준으로 검색합니다. 이 함수는 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분할 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf5bd09edaddcf11f7e48b14ce64a359652894a" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k c[k] z^{k-1}$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="translated">계수 &lt;code&gt;c[1]&lt;/code&gt; , &lt;code&gt;c[2]&lt;/code&gt; , ...에 대한 다항식 $ \ sum_k c [k] z ^ {k-1} $를 평가합니다 . 즉, 계수는 &lt;code&gt;z&lt;/code&gt; 의 거듭 제곱에 따라 오름차순으로 제공됩니다 . 이 매크로는 Horner의 방법을 사용하거나 복잡한 &lt;code&gt;z&lt;/code&gt; 의 경우보다 효율적인 Goertzel과 유사한 알고리즘 을 사용하는 효율적인 인라인 코드로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="17bdebb1637db1ca1fe9844da888b02d8d7bfdc0" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k x^{k-1} p[k]$ for the coefficients &lt;code&gt;p[1]&lt;/code&gt;, &lt;code&gt;p[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;x&lt;/code&gt;. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;. This function generates efficient code using Horner's method if &lt;code&gt;x&lt;/code&gt; is real, or using a Goertzel-like &lt;sup&gt;&lt;a href=&quot;#footnote-DK62&quot; id=&quot;citeref-DK62&quot;&gt;[DK62]&lt;/a&gt;&lt;/sup&gt; algorithm if &lt;code&gt;x&lt;/code&gt; is complex.</source>
          <target state="translated">계수 &lt;code&gt;p[1]&lt;/code&gt; , &lt;code&gt;p[2]&lt;/code&gt; , ...;에 대한 다항식 $ \ sum_k x ^ {k-1} p [k] $를 계산합니다 . 즉, 계수는 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱에 의해 오름차순으로 제공됩니다 . 계수 수가 정적으로 알려진 경우, 즉 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;Tuple&lt;/code&gt; 인 경우 컴파일 타임에 루프가 언 롤링됩니다 . 이 함수는 &lt;code&gt;x&lt;/code&gt; 가 실수 이면 Horner의 방법을 사용하고 &lt;code&gt;x&lt;/code&gt; 가 복소수 이면 Goertzel과 유사한 &lt;sup&gt;&lt;a href=&quot;#footnote-DK62&quot; id=&quot;citeref-DK62&quot;&gt;[DK62]&lt;/a&gt;&lt;/sup&gt; 알고리즘을 사용하여 효율적인 코드를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c2c283394a3475c9f10b4259ae3690af8f5faa1d" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k z^{k-1} c[k]$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="translated">계수 &lt;code&gt;c[1]&lt;/code&gt; , &lt;code&gt;c[2]&lt;/code&gt; , ...;에 대한 다항식 $ \ sum_k z ^ {k-1} c [k] $를 계산합니다 . 즉, 계수는 &lt;code&gt;z&lt;/code&gt; 의 거듭 제곱에 의해 오름차순으로 제공됩니다 . 이 매크로는 Horner의 방법 또는 복잡한 &lt;code&gt;z&lt;/code&gt; 의 경우 더 효율적인 Goertzel 유사 알고리즘 을 사용하는 효율적인 인라인 코드로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bf82123eb8f03dbfcdf15d386b828c44539c7f3" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt;&lt;code&gt;code_llvm&lt;/code&gt;&lt;/a&gt; on the resulting expression. Set the optional keyword arguments &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;dump_module&lt;/code&gt;, &lt;code&gt;debuginfo&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt; by putting them and their value before the function call, like this:</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt; &lt;code&gt;code_llvm&lt;/code&gt; &lt;/a&gt; 을 호출 합니다. 옵션 키워드 인자 설정 &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;dump_module&lt;/code&gt; , &lt;code&gt;debuginfo&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 다음과 같이 함수를 호출하기 전에 그들과 그들의 값을 넣어 :</target>
        </trans-unit>
        <trans-unit id="0574281a0958da4e1fedb99a3969efb400d9fd77" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="088bbc9cbb660de44f799b6c6a191524f6690255" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="86161509c0da7e0e06a0044e2d468e8408652cab" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하고 결과 표현식에서 &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d170313f77b7bcf562ce6e89794d222a66dc883d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt;&lt;code&gt;code_typed&lt;/code&gt;&lt;/a&gt; on the resulting expression. Use the optional argument &lt;code&gt;optimize&lt;/code&gt; with</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하고 결과 표현식에서 &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt; &lt;code&gt;code_typed&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 선택적 인수 &lt;code&gt;optimize&lt;/code&gt; with를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="84c0397d7e38cfd74be0824e7f63562d46240019" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;edit&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식 에서 &lt;code&gt;edit&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fca23945bcd8a8eb5e9f3ee416d4703a5d82433d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;less&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하며 결과 표현식 에서 &lt;code&gt;less&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2278317a19c030d07ee978a6edb3e56c37e01040" translate="yes" xml:space="preserve">
          <source>Evaluating expressions</source>
          <target state="translated">식 평가</target>
        </trans-unit>
        <trans-unit id="dbabc83f5b048a0e83e97e9b394f27da706b3e88" translate="yes" xml:space="preserve">
          <source>Evaluation Scope of Default Values</source>
          <target state="translated">기본값의 평가 범위</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="01624c7776323f5a2680a97bd186745ab3cf1f28" translate="yes" xml:space="preserve">
          <source>Event processing is controlled by overriding functions associated with &lt;code&gt;AbstractLogger&lt;/code&gt;:</source>
          <target state="translated">이벤트 처리는 &lt;code&gt;AbstractLogger&lt;/code&gt; 와 관련된 함수를 재정 의하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="e8a98dc3ac17ae3d77b1ddc48b9496c80b2623e7" translate="yes" xml:space="preserve">
          <source>Evergreen Tree</source>
          <target state="translated">상록수</target>
        </trans-unit>
        <trans-unit id="5d19898d878c5e7ae6a6206e54d456e97f3d4151" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="translated">모든 &lt;a href=&quot;../modules/index#modules&quot;&gt;모듈&lt;/a&gt; 에는 전역 범위에서 식을 평가 하는 자체 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 에&lt;/a&gt; 전달 된 표현식은 값을 반환하는 데 국한되지 않고 주변 모듈 환경의 상태를 변경하는 부작용도있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d21058e9a447b8fa599cb386e31bf0f68fa38e3" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules-1&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="translated">모든 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;모듈&lt;/a&gt; 에는 전체 범위에서 표현식을 평가 하는 자체 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 로 전달 된 표현식은 값을 반환하는 것으로 제한되지 않으며 둘러싸는 모듈 환경의 상태를 변경하는 부작용이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9db205866ccce1546fa3a3f0dcf16499413e68" translate="yes" xml:space="preserve">
          <source>Every Julia program starts life as a string:</source>
          <target state="translated">모든 Julia 프로그램은 삶을 문자열로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="554f49a29b61819b844be413863c737b1ffe0f6b" translate="yes" xml:space="preserve">
          <source>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a &lt;code&gt;=&lt;/code&gt; immediately after the operator. For example, writing &lt;code&gt;x += 3&lt;/code&gt; is equivalent to writing &lt;code&gt;x = x + 3&lt;/code&gt;:</source>
          <target state="translated">모든 이진 산술 및 비트 연산자에는 연산 결과를 다시 왼쪽 피연산자로 할당하는 업데이트 버전이 있습니다. 이항 연산자의 업데이트 버전은 연산자 바로 뒤에 a &lt;code&gt;=&lt;/code&gt; 를 배치하여 구성됩니다 . 예를 들어 &lt;code&gt;x += 3&lt;/code&gt; 을 쓰는 것은 &lt;code&gt;x = x + 3&lt;/code&gt; 을 쓰는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="74d163370c2dd6c3a91981ad81aefa6f4ddbb3ff" translate="yes" xml:space="preserve">
          <source>Every concrete value in the system is an instance of some &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">시스템의 모든 구체적인 값은 일부 &lt;code&gt;DataType&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="8f6ede3443e8f7e99e3d1681b81b7bd2c9c393a0" translate="yes" xml:space="preserve">
          <source>Every worker is also notified of other workers in the cluster.</source>
          <target state="translated">모든 작업자에게 클러스터의 다른 작업자에 대한 알림도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3da573171e36ece7f0a3ae53192e2857a7114b29" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex double&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*16&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;complex double&lt;/code&gt; 타입 (또는 포트란의 &lt;code&gt;COMPLEX*16&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="12b877c370c66bac293ce599efbe5b9cfed8d671" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex float&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;complex float&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;COMPLEX*8&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9f324ad0c495e9b10cd207dd5c4138beb2a008e4" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;double&lt;/code&gt; type in C (or &lt;code&gt;REAL*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;double&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;REAL*8&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6752421aa22fb1eeb8d2fd5badfc564def668c" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;float&lt;/code&gt; type in C (or &lt;code&gt;REAL*4&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;float&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;REAL*4&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6cffeb7c4b2c762c65b636222df4fb94787880c0" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;signed&lt;/code&gt; type annotation in C (or any &lt;code&gt;INTEGER&lt;/code&gt; type in Fortran). Any Julia type that is not a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; is assumed to be unsigned.</source>
          <target state="translated">C 의 &lt;code&gt;signed&lt;/code&gt; 유형 주석 (또는 Fortran의 &lt;code&gt;INTEGER&lt;/code&gt; 유형)과 정확히 일치합니다 . &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; 의 하위 유형이 아닌 Julia 유형은 서명 되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0d1330aca84c1389777df28581b8c82cd98c2394" translate="yes" xml:space="preserve">
          <source>Examining &lt;code&gt;hello.txt&lt;/code&gt; again will show its contents have been changed.</source>
          <target state="translated">&lt;code&gt;hello.txt&lt;/code&gt; 를 다시 검사 하면 내용이 변경되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1e20cb09b4bf0570e117bfae2c451577f63f7028" translate="yes" xml:space="preserve">
          <source>Example using an external library:</source>
          <target state="translated">외부 라이브러리를 사용한 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="373a52dcd1b4d765302f9139879ce9f9a0fb8c90" translate="yes" xml:space="preserve">
          <source>Example: On errors, retry &lt;code&gt;f&lt;/code&gt; on an element a maximum of 3 times without any delay between retries.</source>
          <target state="translated">예 : 오류가 발생하면 재시 도 사이에 지연없이 요소에서 최대 3 번 &lt;code&gt;f&lt;/code&gt; 를 재 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="e833cacc44d10e154db82262037462cf8beef7f2" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="translated">예 : 예외가 &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; 유형이 아닌 경우에만 &lt;code&gt;f&lt;/code&gt; 를 재 시도 하고 최대 3 배까지 지연이 기하 급수적으로 증가합니다. 모든 &lt;code&gt;InexactError&lt;/code&gt; 발생에 대해 &lt;code&gt;NaN&lt;/code&gt; 을 제자리에 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6a35fb66c95d0cf88768455058261ed6959091e5" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;code&gt;InexactError&lt;/code&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="translated">예 : 예외가 &lt;code&gt;InexactError&lt;/code&gt; 유형이 아닌 경우에만 &lt;code&gt;f&lt;/code&gt; 를 3 회까지 지연시켜 지수를 재 시도 하십시오 . 모든 &lt;code&gt;InexactError&lt;/code&gt; 발생에 대해 &lt;code&gt;NaN&lt;/code&gt; 을 제자리에 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b9efd4419a008bc5f5f67da74017e3ce7f66e0fb" translate="yes" xml:space="preserve">
          <source>Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.</source>
          <target state="translated">I / O 관련 작업의 예로는 파일 읽기 / 쓰기, 웹 서비스 액세스, 외부 프로그램 실행 등이 있습니다. 이러한 모든 경우에 파일을 읽는 동안 또는 파일을 읽는 동안 다른 작업을 실행할 수 있으면 전체 실행 시간이 향상 될 수 있습니다. 외부 서비스 / 프로그램이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="9f82b594b309c2e2430648d834395134902abf67" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="translated">가능한 경우 예제는 &lt;em&gt;doctests&lt;/em&gt; 로 작성해야합니다 . &lt;em&gt;doctest가가&lt;/em&gt; (참조 울타리 코드 블록 &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks&quot;&gt;코드 블록&lt;/a&gt; 으로 시작하는) &lt;code&gt;```jldoctest&lt;/code&gt; 및 임의의 개수가 포함 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 함께 입력 및 출력이 예상 모방하는 줄리아 REPL와 안내.</target>
        </trans-unit>
        <trans-unit id="8ca7a5cb7aef9e6990554e02b239447ff53ee134" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="translated">가능할 때마다 예제는 &lt;em&gt;doctests&lt;/em&gt; 로 작성해야합니다 . &lt;em&gt;doctest가가&lt;/em&gt; (참조 울타리 코드 블록 &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;코드 블록&lt;/a&gt; 으로 시작하는) &lt;code&gt;```jldoctest&lt;/code&gt; 및 임의의 개수가 포함 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 함께 입력 및 출력이 예상 모방하는 줄리아 REPL와 안내.</target>
        </trans-unit>
        <trans-unit id="2056efb231cce98ac0668dedf4d2bf625aba4a55" translate="yes" xml:space="preserve">
          <source>Examples that are untestable should be written within fenced code blocks starting with &lt;code&gt;```julia&lt;/code&gt; so that they are highlighted correctly in the generated documentation.</source>
          <target state="translated">테스트 할 수없는 예제는 &lt;code&gt;```julia&lt;/code&gt; 로 시작하는 분리 된 코드 블록 내에 작성되어 생성 된 문서에서 올바르게 강조 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="bf77702e21f59d94d4eb46c5b52d82853eea421c" translate="yes" xml:space="preserve">
          <source>Exception handling in Julia is done using &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;, instead of &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;except&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia due to performance reasons.</source>
          <target state="translated">Julia에서 예외 처리 는 &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;except&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt; 대신 &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt; 를 사용하여 수행됩니다 . Python과 달리 성능상의 이유로 Julia에서 일반적인 워크 플로의 일부로 예외 처리를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b93cbc45254a123c56a8eaff87f67380fa6af7a8" translate="yes" xml:space="preserve">
          <source>Exception stacks and &lt;code&gt;catch_stack&lt;/code&gt;</source>
          <target state="translated">예외 스택 및 &lt;code&gt;catch_stack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d404b3b66335698d08bc7e83b3b1da3bf0caaf78" translate="yes" xml:space="preserve">
          <source>Exception stacks requires at least Julia 1.1.</source>
          <target state="translated">예외 스택에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a7f19469182a37332b5dea18474c06d9a6cffcd0" translate="yes" xml:space="preserve">
          <source>Exception thrown when a &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; value is encountered in a situation where it is not supported. The error message, in the &lt;code&gt;msg&lt;/code&gt; field may provide more specific details.</source>
          <target state="translated">지원되지 않는 상황에서 &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값이 발생 하면 예외 가 발생합니다. &lt;code&gt;msg&lt;/code&gt; 필드 의 오류 메시지 는보다 구체적인 내용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2886bf315699a79be72431b11e875ca8880a85db" translate="yes" xml:space="preserve">
          <source>Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed. This may &lt;em&gt;not&lt;/em&gt; mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the zero pivot(s).</source>
          <target state="translated">행렬 분해 / 해결이 피벗 (대각선) 위치에서 0을 만나 진행할 수없는 경우 예외가 발생합니다. 이것은 행렬이 특이하다는 것을 의미 &lt;em&gt;하지 않을&lt;/em&gt; 수 있습니다. 거짓 제로 피벗을 제거하기 위해 변수를 재정렬 할 수있는 피벗 된 LU와 같은 다른 인수 분해로 전환하는 것이 유익 할 수 있습니다. &lt;code&gt;info&lt;/code&gt; 필드는 (하나의) 제로 피봇 (S)의 위치를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="1a497fe30a5347da8aff63c8337366f7a84f4058" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the singular value(s).</source>
          <target state="translated">입력 행렬에 하나 이상의 0 값의 고유 값이 있고 되돌릴 수없는 경우 예외가 발생합니다. 이러한 매트릭스와 관련된 선형 해석은 계산할 수 없습니다. &lt;code&gt;info&lt;/code&gt; 필드는 위치 (하나의) 특이 값 (들)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="2023c26839abcfb0ae82bfd1150e32fbc284d2ca" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix was not &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;positive definite&lt;/a&gt;. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</source>
          <target state="translated">입력 행렬이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;정의 양수&lt;/a&gt; 가 아닌 경우 예외가 발생합니다 . 일부 선형 대수 함수와 인수 분해는 양의 한정 행렬에만 적용 할 수 있습니다. &lt;code&gt;info&lt;/code&gt; 필드는 위치 (하나) 미만 / 0 인 (임) 인 고유 값 (들)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="82857d1e87d55237f9f3e372603e440bfa06f318" translate="yes" xml:space="preserve">
          <source>Exceptions can be created explicitly with &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt;. For example, a function defined only for nonnegative numbers could be written to &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if the argument is negative:</source>
          <target state="translated">예외는 &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; 로&lt;/a&gt; 명시 적으로 만들 수 있습니다 . 예를 들어, 함수는에 기록 될 수있는 음이 아닌 숫자에 대해 정의 &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 을&lt;/a&gt; 인수가 음수 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e4ba2f79f23d1d745b18049a3459429b5707c9cf" translate="yes" xml:space="preserve">
          <source>Exceptions on remote computations are captured and rethrown locally. A &lt;code&gt;RemoteException&lt;/code&gt; wraps the &lt;code&gt;pid&lt;/code&gt; of the worker and a captured exception. A &lt;code&gt;CapturedException&lt;/code&gt; captures the remote exception and a serializable form of the call stack when the exception was raised.</source>
          <target state="translated">원격 계산에 대한 예외는 로컬에서 캡처되고 다시 발생합니다. &lt;code&gt;RemoteException&lt;/code&gt; 감쌈 &lt;code&gt;pid&lt;/code&gt; 작업자 및 캡처 예외입니다. &lt;code&gt;CapturedException&lt;/code&gt; 은 예외가 발생 될 때를 제외하고 원격 호출 스택의 직렬화 형태를 캡처한다.</target>
        </trans-unit>
        <trans-unit id="47a6e6d3c2e9b02e1dbab62db882a7f9616c024c" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로그 이벤트를 생성하는 동안 발생하는 예외는 기본적으로 캡처 및 기록됩니다. 이렇게하면 개별 중단 된 이벤트가 응용 프로그램을 중단하지 못하게되어 프로덕션 시스템에서 거의 사용되지 않는 디버그 이벤트를 활성화 할 때 도움이됩니다. 이 동작은 &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt; &lt;code&gt;Logging.catch_exceptions&lt;/code&gt; &lt;/a&gt; 를 확장하여 로거 유형별로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20d32bee5048387540915f82b1cf8f99bd32d983" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Logging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로그 이벤트를 생성하는 동안 발생하는 예외는 기본적으로 캡처 및 기록됩니다. 이렇게하면 개별 중단 된 이벤트가 응용 프로그램을 중단하는 것을 방지하므로 프로덕션 시스템에서 거의 사용되지 않는 디버그 이벤트를 활성화 할 때 유용합니다. 이 동작은 &lt;a href=&quot;#Logging.catch_exceptions&quot;&gt; &lt;code&gt;Logging.catch_exceptions&lt;/code&gt; &lt;/a&gt; 를 확장하여 로거 유형별로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249bab0d837de1c736ed6cf322c1023e34887589" translate="yes" xml:space="preserve">
          <source>Excessive use will likely lead to poor performance.</source>
          <target state="translated">과도하게 사용하면 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f389ff868b8af6a6f2f6d30e8b679e098d301b92" translate="yes" xml:space="preserve">
          <source>Exchange the current position with the mark</source>
          <target state="translated">현재 위치를 표시와 교환</target>
        </trans-unit>
        <trans-unit id="c80276d7c0f717bb4d551e808f6db2511c2186fe" translate="yes" xml:space="preserve">
          <source>Exclamation Question Mark</source>
          <target state="translated">느낌표 물음표</target>
        </trans-unit>
        <trans-unit id="dac1fed7304cfae795fbd37d78d8443ee698fee8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f&lt;/code&gt; in an environment that is temporarily modified (not replaced as in &lt;code&gt;setenv&lt;/code&gt;) by zero or more &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; arguments &lt;code&gt;kv&lt;/code&gt;. &lt;code&gt;withenv&lt;/code&gt; is generally used via the &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; syntax. A value of &lt;code&gt;nothing&lt;/code&gt; can be used to temporarily unset an environment variable (if it is set). When &lt;code&gt;withenv&lt;/code&gt; returns, the original environment has been restored.</source>
          <target state="translated">0 이상으로 &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; 인수 &lt;code&gt;kv&lt;/code&gt; 로 일시적으로 수정 된 ( &lt;code&gt;setenv&lt;/code&gt; 에서 대체되지 않은) 환경에서 &lt;code&gt;f&lt;/code&gt; 를 실행하십시오 . &lt;code&gt;withenv&lt;/code&gt; 는 일반적으로 &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; 구문을 통해 사용됩니다 . 값 &lt;code&gt;nothing&lt;/code&gt; (이 설정되어있는 경우) 임시 환경 변수 설정을 해제 할 수있다. 때 &lt;code&gt;withenv&lt;/code&gt; 반환, 원래의 환경이 복원되었습니다.</target>
        </trans-unit>
        <trans-unit id="303c63e1f5cb3dac07df60b3ba1c0270b3b39672" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;function&lt;/code&gt;, directing all log messages to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">모든 로그 메시지를 &lt;code&gt;logger&lt;/code&gt; 보내는 &lt;code&gt;function&lt;/code&gt; 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="bad793892b867876bd2fc3271d9d2236468940a7" translate="yes" xml:space="preserve">
          <source>Execute Permission</source>
          <target state="translated">실행 권한</target>
        </trans-unit>
        <trans-unit id="ccf93fd6554ca73378cd7ef4e9dc68bcbb434afc" translate="yes" xml:space="preserve">
          <source>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined &amp;ndash; be careful when doing this, as it may change numerical results.</source>
          <target state="translated">엄격한 IEEE 의미를 위반할 수있는 함수를 호출하는 변환 된 버전의 표현식을 실행하십시오. 이를 통해 가능한 가장 빠른 작업이 가능하지만 결과는 정의되지 않습니다. 수치 결과가 변경 될 수 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="5e27a1a745ad8902705c2e6ab83a0903098f9f06" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;a href=&quot;../../base/base/index#Base.CompositeException&quot;&gt;&lt;code&gt;CompositeException&lt;/code&gt;&lt;/a&gt; and thrown. For example:</source>
          <target state="translated">모든 &lt;code&gt;procs&lt;/code&gt; 의 &lt;code&gt;Main&lt;/code&gt; 아래에서 표현식을 실행합니다 . 모든 프로세스에 대한 오류는 &lt;a href=&quot;../../base/base/index#Base.CompositeException&quot;&gt; &lt;code&gt;CompositeException&lt;/code&gt; &lt;/a&gt; 으로 수집되어 발생합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0c9df83ba80f7ea05232757e37fd45c85f102a7b" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;code&gt;CompositeException&lt;/code&gt; and thrown. For example:</source>
          <target state="translated">모든 &lt;code&gt;procs&lt;/code&gt; 에서 &lt;code&gt;Main&lt;/code&gt; 아래 표현식을 실행하십시오 . 모든 프로세스의 오류는 &lt;code&gt;CompositeException&lt;/code&gt; 으로 수집되어 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef0298149bb24a28fd471679846d07a4d0087cc3" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;f&lt;/code&gt; on worker &lt;code&gt;id&lt;/code&gt; asynchronously. Unlike &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall&lt;/code&gt;&lt;/a&gt;, it does not store the result of computation, nor is there a way to wait for its completion.</source>
          <target state="translated">작업자 &lt;code&gt;id&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 를 비동기 적으로 실행합니다 . &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall&lt;/code&gt; &lt;/a&gt; 과 달리 계산 결과를 저장하지 않으며 완료를 기다리는 방법도 없습니다.</target>
        </trans-unit>
        <trans-unit id="acb80322579157531d28a7bec37d10ea4056bc6f" translate="yes" xml:space="preserve">
          <source>Executing the above snippet results in &lt;code&gt;Main.A&lt;/code&gt; on worker 2 having a different value from &lt;code&gt;Main.A&lt;/code&gt; on worker 3, while the value of &lt;code&gt;Main.A&lt;/code&gt; on node 1 is set to &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서 결과를 실행 &lt;code&gt;Main.A&lt;/code&gt; 에서 다른 값을 갖는 작업자 2 &lt;code&gt;Main.A&lt;/code&gt; 값하면서 작업자 3을 &lt;code&gt;Main.A&lt;/code&gt; 노드 1로 설정 &lt;code&gt;nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="911180ac9cebe24cefdcdd1680b9c49387acd612" translate="yes" xml:space="preserve">
          <source>Exit (when buffer is empty)</source>
          <target state="translated">종료 (버퍼가 비었을 때)</target>
        </trans-unit>
        <trans-unit id="d477eb857db4070fa5362225484e2e2cc1160414" translate="yes" xml:space="preserve">
          <source>Exit hooks are allowed to call &lt;code&gt;exit(n)&lt;/code&gt;, in which case Julia will exit with exit code &lt;code&gt;n&lt;/code&gt; (instead of the original exit code). If more than one exit hook calls &lt;code&gt;exit(n)&lt;/code&gt;, then Julia will exit with the exit code corresponding to the last called exit hook that calls &lt;code&gt;exit(n)&lt;/code&gt;. (Because exit hooks are called in LIFO order, &quot;last called&quot; is equivalent to &quot;first registered&quot;.)</source>
          <target state="translated">종료 후크는 &lt;code&gt;exit(n)&lt;/code&gt; 을 호출 할 수 있습니다 .이 경우 Julia는 원래 종료 코드 대신 종료 코드 &lt;code&gt;n&lt;/code&gt; 으로 종료 됩니다. 둘 이상의 종료 후크가 &lt;code&gt;exit(n)&lt;/code&gt; 호출 하면 Julia는 &lt;code&gt;exit(n)&lt;/code&gt; 을 호출하는 마지막 호출 된 종료 후크에 해당하는 종료 코드와 함께 종료됩니다 . (종료 후크는 LIFO 순서로 호출되기 때문에 &quot;마지막 호출&quot;은 &quot;처음 등록&quot;과 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="67fb80361f00a1ef919b8a402eb0fa8767e88aa3" translate="yes" xml:space="preserve">
          <source>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">매크로 호출을 포함하는 파일 디렉토리의 절대 경로가있는 문자열로 확장하십시오. REPL에서 실행되거나 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 에 의해 평가되는 경우 현재 작업 디렉토리를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="43f7e4fd43efc93c7c61b01d066abbb6ecd0ad58" translate="yes" xml:space="preserve">
          <source>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;. Return &lt;code&gt;nothing&lt;/code&gt; if the macro was missing parser source information. Alternatively see &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt;&lt;code&gt;PROGRAM_FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매크로 호출을 포함하는 파일 경로가있는 문자열로 확장하거나 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 에 의해 평가되는 경우 빈 문자열로 확장하십시오 . 매크로에 파서 소스 정보가 없으면 &lt;code&gt;nothing&lt;/code&gt; 반환 하지 않습니다 . 또는 &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt; &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f8c8a91207271c3979e8b044e269e773310cb43" translate="yes" xml:space="preserve">
          <source>Expand to the line number of the location of the macrocall. Return &lt;code&gt;0&lt;/code&gt; if the line number could not be determined.</source>
          <target state="translated">매크로 호출 위치의 행 번호로 확장하십시오. 행 번호를 확인할 수 없으면 &lt;code&gt;0&lt;/code&gt; 을 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="c980fcdbd3756987bdd9be9bd2691a2d11e6223d" translate="yes" xml:space="preserve">
          <source>Expecting the filesystem to be unchanged between compile-time and runtime e.g. &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;source_path()&lt;/code&gt; to find resources at runtime, or the BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</source>
          <target state="translated">컴파일시와 런타임 사이에 파일 시스템이 변경되지 않을 것으로 예상합니다 (예 : &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;source_path()&lt;/code&gt; 런타임시 리소스 찾기 또는 BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; 매크로). 때때로 이것은 피할 수없는 일입니다. 그러나 가능하면 컴파일 타임에 모듈에 리소스를 복사하여 런타임에 찾을 필요가없는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef01e9964e65833fa4da94fa27761fbd0428c0b5" translate="yes" xml:space="preserve">
          <source>Experimental multithreading support.</source>
          <target state="translated">실험적인 멀티 스레딩 지원.</target>
        </trans-unit>
        <trans-unit id="d1e10c5f2ecca7a990bcf252a20b9966c63ad49c" translate="yes" xml:space="preserve">
          <source>Explicitly finds &lt;code&gt;Q&lt;/code&gt;, the orthogonal/unitary matrix from &lt;code&gt;gehrd!&lt;/code&gt;. &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;tau&lt;/code&gt; must correspond to the input/output to &lt;code&gt;gehrd!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gehrd!&lt;/code&gt; 에서 직교 / 단위 행렬 인 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 ! . &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;tau&lt;/code&gt; 는 &lt;code&gt;gehrd!&lt;/code&gt; 의 입력 / 출력에 해당해야합니다 ! .</target>
        </trans-unit>
        <trans-unit id="d89ba743e7b20b3225440e90c3ccf3bf8748afa9" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;LQ&lt;/code&gt; factorization after calling &lt;code&gt;gelqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gelqf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;LQ&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;gelqf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842467dd8285c3ac06d28f0f33b4e3294049f962" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QL&lt;/code&gt; factorization after calling &lt;code&gt;geqlf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;geqlf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;QL&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;geqlf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ece9405b82e399d70d34379e646461b54cd5e7c" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QR&lt;/code&gt; factorization after calling &lt;code&gt;geqrf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;geqrf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;QR&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 ! 에 . &lt;code&gt;geqrf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b7a9812258e65fe016e3ff6743203ffc052ea2" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;RQ&lt;/code&gt; factorization after calling &lt;code&gt;gerqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gerqf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;gerqf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50220615494147fbec7eb0d31ca7ba3a82c81db3" translate="yes" xml:space="preserve">
          <source>Explicitly passing &lt;code&gt;task&lt;/code&gt; will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</source>
          <target state="translated">명시 적으로 &lt;code&gt;task&lt;/code&gt; 을 전달 하면 임의의 작업에서 현재 예외 스택이 반환됩니다. 포착되지 않은 예외로 인해 실패한 작업을 검사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="90b58b7713ee5ebddd55f78493a86426624ddf35" translate="yes" xml:space="preserve">
          <source>ExponentialBackOff</source>
          <target state="translated">ExponentialBackOff</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="23bf8b64f7777c5abac718af8c1d4675c08d1bd7" translate="yes" xml:space="preserve">
          <source>Exponentiation operator. If &lt;code&gt;x&lt;/code&gt; is a matrix, computes matrix exponentiation.</source>
          <target state="translated">지수 연산자. 경우 &lt;code&gt;x&lt;/code&gt; 행렬 계산하며 행렬 지수이다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="2ffaab085f397ec888c88af14ff5370679b8c9cd" translate="yes" xml:space="preserve">
          <source>Expressionless Face</source>
          <target state="translated">표정없는 얼굴</target>
        </trans-unit>
        <trans-unit id="88cbc8428bc0cead64822d528b5aeb2ed594f6d0" translate="yes" xml:space="preserve">
          <source>Expressions and evaluation</source>
          <target state="translated">표현과 평가</target>
        </trans-unit>
        <trans-unit id="395de5a745d120d755d181c48640612c62257526" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawn&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="translated">&lt;code&gt;@spawn&lt;/code&gt; 을 통해 원격으로 실행되는 표현식 또는 &lt;code&gt;remotecall&lt;/code&gt; 을 사용하여 원격 실행을 위해 지정된 클로저 는 전역 변수를 참조 할 수 있습니다. &lt;code&gt;Main&lt;/code&gt; 모듈의 전역 바인딩은 다른 모듈의 전역 바인딩에 비해 약간 다르게 처리됩니다. 다음 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c021e85f0971c261cc893329ddbecca6139c6c2b" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawnat&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="translated">&lt;code&gt;@spawnat&lt;/code&gt; 을 통해 원격으로 실행되는 표현식 또는 &lt;code&gt;remotecall&lt;/code&gt; 을 사용하여 원격 실행을 위해 지정된 클로저 는 전역 변수를 참조 할 수 있습니다. &lt;code&gt;Main&lt;/code&gt; 모듈 아래의 전역 바인딩은 다른 모듈의 전역 바인딩과 약간 다르게 처리됩니다. 다음 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6bdaffe5a439039b7bf8f6bd820ea137bfdd1da7" translate="yes" xml:space="preserve">
          <source>Expressions may also be constructed directly in &lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;prefix notation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;접두사 표기법으로&lt;/a&gt; 직접 표현식을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="499636f8c38809ad543e77eff829b775812e07ab" translate="yes" xml:space="preserve">
          <source>Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are symbols, &lt;code&gt;*(b,c)&lt;/code&gt; is a subexpression, and &lt;code&gt;1&lt;/code&gt; is a literal 64-bit signed integer.</source>
          <target state="translated">파서가 제공하는 표현식은 일반적으로 기호, 다른 표현식 및 리터럴 값을 인수로만 사용하는 반면 Julia 코드로 생성 된 표현식은 리터럴 형식이없는 임의의 런타임 값을 인수로 사용할 수 있습니다. 이 특정 예에서 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 는 기호이고 &lt;code&gt;*(b,c)&lt;/code&gt; 는 하위 표현식이고 &lt;code&gt;1&lt;/code&gt; 은 리터럴 64 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7f0edd94f804e2ef96353f1dd584892a96db61b3" translate="yes" xml:space="preserve">
          <source>Expressions starting with &lt;code&gt;0x&lt;/code&gt; are always hexadecimal literals.</source>
          <target state="translated">&lt;code&gt;0x&lt;/code&gt; 로 시작하는 표현식 은 항상 16 진 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="14b0df907ddf13aab95716adce355b18503f9692" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; are always floating-point literals.</source>
          <target state="translated">숫자 리터럴로 시작하고 그 뒤에 &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 가 있는 표현식 은 항상 부동 소수점 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="168d5e3cbe916c23713fe630f1348b13aac9d055" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;f&lt;/code&gt; are always 32-bit floating-point literals.</source>
          <target state="translated">숫자 리터럴로 시작하고 뒤에 &lt;code&gt;f&lt;/code&gt; 가 오는 표현식 은 항상 32 비트 부동 소수점 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="3716e13409c4d9335f64fad9810901c98f3f9853" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">수학 기호 및 함수에 대한 확장 된 문서는 &lt;a href=&quot;../math/index#math-ops&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94855ece22db4469edf3ed1b0b895b74c83b0b49" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">수학 기호 및 함수에 대한 확장 설명서가 &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9923a9977a4965d0e75c0d0897087a1b8aae8273" translate="yes" xml:space="preserve">
          <source>Extending broadcast with custom implementations</source>
          <target state="translated">맞춤형 구현으로 방송 확장</target>
        </trans-unit>
        <trans-unit id="e37b3da56d0eb7ab09f9dced1733e35bd0cf8f0a" translate="yes" xml:space="preserve">
          <source>Extending in-place broadcasting</source>
          <target state="translated">인플레 이스 방송 확장</target>
        </trans-unit>
        <trans-unit id="dda79d09f22a8d0b6a55357e8dd3c1f09491aeff" translate="yes" xml:space="preserve">
          <source>External Profiling</source>
          <target state="translated">외부 프로파일 링</target>
        </trans-unit>
        <trans-unit id="dcc209bf958342fc6704aa1a6650f41110ebb0ea" translate="yes" xml:space="preserve">
          <source>External applications</source>
          <target state="translated">외부 응용</target>
        </trans-unit>
        <trans-unit id="ddfa24e5756c773c710e95d9df553e39fcc67e85" translate="yes" xml:space="preserve">
          <source>External libraries, such as those called via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, pose a problem for Julia's task-based I/O mechanism. If a C library performs a blocking operation, that prevents the Julia scheduler from executing any other tasks until the call returns. (Exceptions are calls into custom C code that call back into Julia, which may then yield, or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt;, the C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 을&lt;/a&gt; 통해 호출되는 것과 같은 외부 라이브러리 는 Julia의 작업 기반 I / O 메커니즘에 문제를 제기합니다. C 라이브러리가 차단 작업을 수행하는 경우 Julia 스케줄러는 호출이 반환 될 때까지 다른 작업을 실행하지 못합니다. (예외는 커스텀 코드 C에 호출이 있는지 다음 생성됨 줄리아, 또는 통화가 C 코드로 콜 백 &lt;code&gt;jl_yield()&lt;/code&gt; 의 C 당량 &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="72388f5a580b9a206f5fadf477e9c6409b4ba887" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments can be collected using &lt;code&gt;...&lt;/code&gt;, as in varargs functions:</source>
          <target state="translated">varargs 함수에서와 같이 &lt;code&gt;...&lt;/code&gt; 을 사용하여 추가 키워드 인수를 수집 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4546f951699a79deff827a563b0a9a224961ffb" translate="yes" xml:space="preserve">
          <source>Extract a field from a composite &lt;code&gt;value&lt;/code&gt; by name or position. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 또는 위치별로 복합 &lt;code&gt;value&lt;/code&gt; 에서 필드를 추출합니다 . &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c542a0937e5c368280ab873c2a76a31ca26a4f2" translate="yes" xml:space="preserve">
          <source>Extract a named field from a &lt;code&gt;value&lt;/code&gt; of composite type. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 유형 의 &lt;code&gt;value&lt;/code&gt; 에서 명명 된 필드를 추출하십시오 . &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c60b2d6e5ed4bb81c4f042b61a85bf3046814ef9" translate="yes" xml:space="preserve">
          <source>Extract the &lt;code&gt;significand(s)&lt;/code&gt; (a.k.a. mantissa), in binary representation, of a floating-point number. If &lt;code&gt;x&lt;/code&gt; is a non-zero finite number, then the result will be a number of the same type on the interval $[1,2)$. Otherwise &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">추출 &lt;code&gt;significand(s)&lt;/code&gt; 부동 소수점 숫자의 이진 표현 (일명 가수). 경우 &lt;code&gt;x&lt;/code&gt; 영이 아닌 유한 한 수이며, 그 결과는 $ 구간 [1,2) $ 동일한 유형의 수가 될 것이다. 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd9a47407646b7eb349264a1847a577117c4b4b" translate="yes" xml:space="preserve">
          <source>Extracting the type parameter from a super-type</source>
          <target state="translated">수퍼 유형에서 유형 매개 변수 추출</target>
        </trans-unit>
        <trans-unit id="1fbfe5e749872a05dc1c33c2c7e3ca998b7be846" translate="yes" xml:space="preserve">
          <source>Extracting useful information</source>
          <target state="translated">유용한 정보 추출</target>
        </trans-unit>
        <trans-unit id="a98fa15cfef5c8e370cf565d569aef6f02c37e94" translate="yes" xml:space="preserve">
          <source>Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:</source>
          <target state="translated">범위 인덱싱을 사용하여 하위 문자열을 추출하면 유효한 바이트 인덱스가 필요하거나 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="479ced4730cae81bdb549a4c55a6c538ce811e6e" translate="yes" xml:space="preserve">
          <source>Extraterrestrial Alien</source>
          <target state="translated">외계인 외계인</target>
        </trans-unit>
        <trans-unit id="794b03ba50df5bea4d6fe059ce926e6abf4b67b1" translate="yes" xml:space="preserve">
          <source>Eyeglasses</source>
          <target state="translated">Eyeglasses</target>
        </trans-unit>
        <trans-unit id="62be7f51429e4e104e01fe3131805c3195ede1d0" translate="yes" xml:space="preserve">
          <source>Eyes</source>
          <target state="translated">Eyes</target>
        </trans-unit>
        <trans-unit id="935b5308312476832a58c20321b71ffe59146c81" translate="yes" xml:space="preserve">
          <source>Face Massage</source>
          <target state="translated">얼굴 마사지</target>
        </trans-unit>
        <trans-unit id="6d9f49198cfb94a88e7e31f25250998eb9d2d1e4" translate="yes" xml:space="preserve">
          <source>Face Savouring Delicious Food</source>
          <target state="translated">맛있는 음식을 맛보는 얼굴</target>
        </trans-unit>
        <trans-unit id="28d752ff1cbe0e0d9da042fc2eb4d864b23a6a83" translate="yes" xml:space="preserve">
          <source>Face Screaming In Fear</source>
          <target state="translated">두려움에 비명을 지르는 얼굴</target>
        </trans-unit>
        <trans-unit id="b9e9beed389ea0d867f47293f82e2186403a9ed4" translate="yes" xml:space="preserve">
          <source>Face Throwing A Kiss</source>
          <target state="translated">키스를 던지는 얼굴</target>
        </trans-unit>
        <trans-unit id="bbcbf04ff477b2051e7e4f303a290165f6e17c1c" translate="yes" xml:space="preserve">
          <source>Face With Cold Sweat</source>
          <target state="translated">식은 땀이있는 얼굴</target>
        </trans-unit>
        <trans-unit id="31e3b7279424674f21abf98db495235d209a6f78" translate="yes" xml:space="preserve">
          <source>Face With Look Of Triumph</source>
          <target state="translated">승리의 표정으로 얼굴</target>
        </trans-unit>
        <trans-unit id="d977220829cb5c54e44951e580b7af5a8be682f2" translate="yes" xml:space="preserve">
          <source>Face With Medical Mask</source>
          <target state="translated">의료 마스크 얼굴</target>
        </trans-unit>
        <trans-unit id="ed92f3d2a6422f2069bba1ed8548d4fce7291c38" translate="yes" xml:space="preserve">
          <source>Face With No Good Gesture</source>
          <target state="translated">좋은 제스처가없는 얼굴</target>
        </trans-unit>
        <trans-unit id="506a6677d48e694c03b7beb019db5a830b3143a9" translate="yes" xml:space="preserve">
          <source>Face With Ok Gesture</source>
          <target state="translated">확인 제스처와 얼굴</target>
        </trans-unit>
        <trans-unit id="28e351cf809c3e1056a0ccbe38a572fea7f91813" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth</source>
          <target state="translated">열린 입으로 얼굴</target>
        </trans-unit>
        <trans-unit id="ede5660328e307c9c221b7e2a4cda4e1f338198d" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth And Cold Sweat</source>
          <target state="translated">입을 벌리고 식은 땀이 나는 얼굴</target>
        </trans-unit>
        <trans-unit id="2ba0e50eb9d9ecd8226c1f88f65005c12090219b" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue</source>
          <target state="translated">붙어 혀로 얼굴</target>
        </trans-unit>
        <trans-unit id="0ac1bde49f3cb47f6fb14b275d6c4062eb336a94" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Tightly-Closed Eyes</source>
          <target state="translated">혀를 내밀고 눈을 감은 얼굴</target>
        </trans-unit>
        <trans-unit id="f4cf7e61567246c7cc07e1da723a4bb7e03afad8" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Winking Eye</source>
          <target state="translated">붙어 혀와 윙크하는 눈을 가진 얼굴</target>
        </trans-unit>
        <trans-unit id="a06e070daf131855d1c38e6f755e23cf18f7fde6" translate="yes" xml:space="preserve">
          <source>Face With Tears Of Joy</source>
          <target state="translated">기쁨의 눈물로 얼굴</target>
        </trans-unit>
        <trans-unit id="712efae47f8a280e2a18330da009234488ca3fe5" translate="yes" xml:space="preserve">
          <source>Face Without Mouth</source>
          <target state="translated">입없는 얼굴</target>
        </trans-unit>
        <trans-unit id="afc193c2d83a82dc7805b7f571fe51bc57700902" translate="yes" xml:space="preserve">
          <source>Factorial of &lt;code&gt;n&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if &lt;code&gt;n&lt;/code&gt; is not small, but you can use &lt;code&gt;factorial(big(n))&lt;/code&gt; to compute the result exactly in arbitrary precision.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 계승 . 경우 &lt;code&gt;n&lt;/code&gt; 은 인 &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , 팩토리얼 정수로서 산출된다 (적어도 64 비트 촉진). &lt;code&gt;n&lt;/code&gt; 이 작지 않으면 오버플로가 발생할 수 있지만 &lt;code&gt;factorial(big(n))&lt;/code&gt; 을 사용하여 결과를 임의의 정밀도로 정확하게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="63654e405afb574cef72ea67524c3b8dfe3ad9f8" translate="yes" xml:space="preserve">
          <source>Fallen Leaf</source>
          <target state="translated">타락한 잎</target>
        </trans-unit>
        <trans-unit id="b9484d668f5b5826c667e198c17cfe45233a7bb4" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing North East Arrow</source>
          <target state="translated">떨어지는 대각선 교차점 북동쪽 화살표</target>
        </trans-unit>
        <trans-unit id="393d595d0d4e1a1bb3815008194b595d879c69cb" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing Rising Diagonal</source>
          <target state="translated">떨어지는 대각선 횡단 상승 대각선</target>
        </trans-unit>
        <trans-unit id="4efb6cb7c018f0c686d4e9d68b615950223b4dd1" translate="yes" xml:space="preserve">
          <source>Family</source>
          <target state="translated">Family</target>
        </trans-unit>
        <trans-unit id="f4b462a59695a129404bc83da0ca619fa6bc84c1" translate="yes" xml:space="preserve">
          <source>FastMath.@fastmath</source>
          <target state="translated">FastMath.@fastmath</target>
        </trans-unit>
        <trans-unit id="5e56c9df8931a964370d4185aaacd5e1646ab9bf" translate="yes" xml:space="preserve">
          <source>Fastforward merge changes into current HEAD. This is only possible if the commit referred to by &lt;code&gt;ann&lt;/code&gt; is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).</source>
          <target state="translated">현재 HEAD 로의 빠른 병합 변경. &lt;code&gt;ann&lt;/code&gt; 에 의해 참조 된 커밋 이 현재 HEAD에서 내려진 경우에만 가능합니다 (예 : 로컬 브랜치 팁보다 앞서있는 원격 브랜치에서 변경 사항을 가져 오는 경우).</target>
        </trans-unit>
        <trans-unit id="2cb40f791e4167e1561e4d7cf136b54833a93f9c" translate="yes" xml:space="preserve">
          <source>Father Christmas</source>
          <target state="translated">아버지 크리스마스</target>
        </trans-unit>
        <trans-unit id="9f64754b8681b16b5355b0c86ea9df6b53108695" translate="yes" xml:space="preserve">
          <source>Fax Machine</source>
          <target state="translated">팩스</target>
        </trans-unit>
        <trans-unit id="2e7c6c500cc9c35c302564a53fea2d0265ede623" translate="yes" xml:space="preserve">
          <source>Fearful Face</source>
          <target state="translated">두려운 얼굴</target>
        </trans-unit>
        <trans-unit id="e8205fe2da2e8213474f5eefce3af1eb9e900095" translate="yes" xml:space="preserve">
          <source>Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; will add to the appropriate project and manifest files, selected via &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt;, so that a future call to &lt;code&gt;import X&lt;/code&gt; will load &lt;code&gt;X&lt;/code&gt; without further thought.</source>
          <target state="translated">연합 패키지 관리 및 정확한 소프트웨어 재현성은 패키지 시스템에서 어렵지만 가치있는 목표입니다. 이러한 목표를 조합하면 대부분의 동적 언어보다 패키지로드 메커니즘이 더 복잡해 지지만 정적 언어와 더 일반적으로 연관된 확장 성과 재현성을 제공합니다. 일반적으로 Julia 사용자는 내장 된 패키지 관리자를 사용하여 이러한 상호 작용에 대한 정확한 이해없이 프로젝트를 관리 할 수 ​​있어야합니다. 를 호출 &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; 는 를 통해 선택 적절한 프로젝트와 매니페스트 파일에 추가합니다 &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt; 에 대한 미래의 호출 그래서, &lt;code&gt;import X&lt;/code&gt; 로드 &lt;code&gt;X&lt;/code&gt; 를 더 생각없이.</target>
        </trans-unit>
        <trans-unit id="47786ddc55ac4be098cd5e14320506e7fb87ccf0" translate="yes" xml:space="preserve">
          <source>Federation of packages</source>
          <target state="translated">패키지 연합</target>
        </trans-unit>
        <trans-unit id="39d4db59ebfbfc4ac31928560a37f5b11dfbe6ef" translate="yes" xml:space="preserve">
          <source>Female Sign</source>
          <target state="translated">여성 부호</target>
        </trans-unit>
        <trans-unit id="5ade35b896f1964ffd73b5188c1b0487a813086e" translate="yes" xml:space="preserve">
          <source>Feminine Ordinal Indicator</source>
          <target state="translated">여성 서수 지표</target>
        </trans-unit>
        <trans-unit id="d710ff00c62629aec846cd362ec81d6ef45db696" translate="yes" xml:space="preserve">
          <source>Ferris Wheel</source>
          <target state="translated">관람차</target>
        </trans-unit>
        <trans-unit id="df0dbf9f1e3f08dc6fd97eee350731fe6d045e40" translate="yes" xml:space="preserve">
          <source>Fetch from the specified &lt;code&gt;rmt&lt;/code&gt; remote git repository, using &lt;code&gt;refspecs&lt;/code&gt; to determine which remote branch(es) to fetch. The keyword arguments are:</source>
          <target state="translated">가져올 원격 브랜치를 결정하기 위해 &lt;code&gt;refspecs&lt;/code&gt; 을 사용하여 지정된 &lt;code&gt;rmt&lt;/code&gt; 원격 git 저장소에서 가져옵니다. 키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb2823e177eb0088e61a0c4192de87c90606b3f2" translate="yes" xml:space="preserve">
          <source>Fetch value(s) from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;rr&lt;/code&gt;, removing the value(s) in the process.</source>
          <target state="translated">프로세스에서 값을 제거하여 &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;rr&lt;/code&gt; 에서 값을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="f75758f2a5b3122c0452e7b217407d3ca4c90027" translate="yes" xml:space="preserve">
          <source>Fetches updates from an upstream of the repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">저장소의 상류에서 업데이트를 가져옵니다 &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab81972fb7d8656b3c745c5f3e56930d139a6985" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="translated">필드 &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; 는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 클러스터 관리자가 설정할 수 있습니다 . 이 필드의 값은 모든 &lt;code&gt;connect&lt;/code&gt; 콜백 에서 전달됩니다 . 일반적으로 작업자 &lt;em&gt;와 연결하는 방법&lt;/em&gt; 에 &lt;em&gt;대한&lt;/em&gt; 정보를 전달합니다 . 예를 들어, TCP / IP 소켓 전송은이 필드를 사용하여 작업자에 연결할 &lt;code&gt;(host, port)&lt;/code&gt; 튜플 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="33e0dc3617ed6df7db01aef23ac96c5f906e0e79" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="translated">연결 관리자 필드 &lt;code&gt;connect_at::Any&lt;/code&gt; &lt;code&gt;WorkerConfig&lt;/code&gt; 의모든 항목 은 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 클러스터 관리자가 설정할 수 있습니다 . 이 필드의 값은 모든 &lt;code&gt;connect&lt;/code&gt; 콜백 에서 전달됩니다 . 일반적으로 작업자 &lt;em&gt;연결 방법&lt;/em&gt; 에 &lt;em&gt;대한&lt;/em&gt; 정보를 제공 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, TCP / IP 소켓 전송은이 필드를 사용하여 작업자에 연결할 &lt;code&gt;(host, port)&lt;/code&gt; 튜플 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a021a8bc64f3d535386a42159616c145f16e2e9f" translate="yes" xml:space="preserve">
          <source>Fields can have type restrictions, which may be parameterized:</source>
          <target state="translated">필드에는 유형 제한이있을 수 있으며 매개 변수화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e54bf45d80186bc0d6353b5c2465d78bd8c6a3" translate="yes" xml:space="preserve">
          <source>Fields for output from functions can also be completed:</source>
          <target state="translated">기능 출력을위한 필드도 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c69000bd588bc2ad85aa2ab7ce5f54b4fa4c471" translate="yes" xml:space="preserve">
          <source>Fields with no type annotation default to &lt;code&gt;Any&lt;/code&gt;, and can accordingly hold any type of value.</source>
          <target state="translated">유형 주석이없는 필드는 기본적으로 &lt;code&gt;Any&lt;/code&gt; 로 설정 되므로 모든 유형의 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="844953f92852d1b54e7d635339a7d17db22cf318" translate="yes" xml:space="preserve">
          <source>File Events</source>
          <target state="translated">파일 이벤트</target>
        </trans-unit>
        <trans-unit id="f78e390524cd3565f0dc8b46bd2ea361def72e8d" translate="yes" xml:space="preserve">
          <source>File Folder</source>
          <target state="translated">파일 폴더</target>
        </trans-unit>
        <trans-unit id="1b8c4bf7746a674619789c0353c0a64bca75a908" translate="yes" xml:space="preserve">
          <source>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</source>
          <target state="translated">현재 플랫폼에서 동적 라이브러리 (예 : dll, dylib 등)의 파일 확장자</target>
        </trans-unit>
        <trans-unit id="2a5ce0551b3bc16a4d13e2e3a13e5586cafae52b" translate="yes" xml:space="preserve">
          <source>File locations</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="2c420d28b90db2dee25055b2d7bd4981ad9a1524" translate="yes" xml:space="preserve">
          <source>File/function names are sometimes truncated (with &lt;code&gt;...&lt;/code&gt;), and indentation is truncated with a &lt;code&gt;+n&lt;/code&gt; at the beginning, where &lt;code&gt;n&lt;/code&gt; is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide &lt;code&gt;displaysize&lt;/code&gt; in an &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">파일 / 함수 이름이 간혹 잘려지고 ( &lt;code&gt;...&lt;/code&gt; 포함 ) 들여 쓰기는 처음에 &lt;code&gt;+n&lt;/code&gt; 으로 잘립니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 여유 공간이있을 경우 삽입 된 추가 공간의 수입니다. 깊이 중첩 된 코드의 전체 프로파일을 원할 경우 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 에서 넓은 &lt;code&gt;displaysize&lt;/code&gt; 크기를 사용하여 파일에 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f8d8d763bd5d522952215bd9a9fc1f2faf928be9" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_fd()</source>
          <target state="translated">FileWatching.poll_fd()</target>
        </trans-unit>
        <trans-unit id="9a0031862648613baa256a2b1e25c479a5254826" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_file()</source>
          <target state="translated">FileWatching.poll_file()</target>
        </trans-unit>
        <trans-unit id="747de65fe94e8175642ef8c7cef685465b1b4bb5" translate="yes" xml:space="preserve">
          <source>FileWatching.unwatch_folder()</source>
          <target state="translated">FileWatching.unwatch_folder()</target>
        </trans-unit>
        <trans-unit id="d92f14cfa1ec3fdb1aad5fa8235becab8031e345" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_file()</source>
          <target state="translated">FileWatching.watch_file()</target>
        </trans-unit>
        <trans-unit id="c0d5eb4225c04b069f17ff8146680ce4c975f229" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_folder()</source>
          <target state="translated">FileWatching.watch_folder()</target>
        </trans-unit>
        <trans-unit id="0b5acc23bb7f272c55693528aa9ca461dacf6e0b" translate="yes" xml:space="preserve">
          <source>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:</source>
          <target state="translated">파일과 파일 이름은 대부분 모듈과 관련이 없습니다. 모듈은 모듈 표현식과 만 연관됩니다. 하나는 모듈 당 여러 파일을 가질 수 있고 파일 당 여러 모듈을 가질 수 있습니다</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="66d37ac694679d2aaba78e1325d8da6c3e6b2dc1" translate="yes" xml:space="preserve">
          <source>Filesystem.cd()</source>
          <target state="translated">Filesystem.cd()</target>
        </trans-unit>
        <trans-unit id="4b83b49056e1fe9e1c6931b13ab708ea3d3dc5b1" translate="yes" xml:space="preserve">
          <source>Filesystem.cp()</source>
          <target state="translated">Filesystem.cp()</target>
        </trans-unit>
        <trans-unit id="a4dead2a6ad53fe70d8e528eef3724fac180b679" translate="yes" xml:space="preserve">
          <source>Filesystem.mv()</source>
          <target state="translated">Filesystem.mv()</target>
        </trans-unit>
        <trans-unit id="cf83f1b98e2416e6a59699657d24bd33d10365f7" translate="yes" xml:space="preserve">
          <source>Filesystem.rm()</source>
          <target state="translated">Filesystem.rm()</target>
        </trans-unit>
        <trans-unit id="e8602ecc6cdda92120a80db2b2896945fc2bc02d" translate="yes" xml:space="preserve">
          <source>Fill array &lt;code&gt;A&lt;/code&gt; with the value &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; will return &lt;code&gt;A&lt;/code&gt; filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 를 값 &lt;code&gt;x&lt;/code&gt; 로 채 웁니다 . 경우 &lt;code&gt;x&lt;/code&gt; 개체 참조하고, 모든 요소가 동일한 객체를 참조한다. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; 는 &lt;code&gt;Foo()&lt;/code&gt; 한 번 평가 한 결과로 채워진 &lt;code&gt;A&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="15f90b730a9bb3cbbb4e0be4003f4356fc9b9036" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 를 정규 분포 (평균 0, 표준 편차 1) 난수로 채 웁니다. &lt;a href=&quot;#Base.rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 기능 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ae93e848c3d30d15d2b5012ea3af3f0ab55b5ca" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with random numbers following the exponential distribution (with scale 1).</source>
          <target state="translated">지수 분포 (스케일 1)에 따라 난수로 배열 &lt;code&gt;A&lt;/code&gt; 를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0e5d88ef3637a2479a8b258a074f4fa06d769918" translate="yes" xml:space="preserve">
          <source>Fills an array of the digits of &lt;code&gt;n&lt;/code&gt; in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</source>
          <target state="translated">주어진 밑에서 &lt;code&gt;n&lt;/code&gt; 의 자릿수 배열을 채 웁니다 . 더 큰 숫자는 더 높은 지수에 있습니다. 배열 길이가 충분하지 않은 경우 최하위 자릿수가 배열 길이까지 채워집니다. 배열 길이가 너무 길면 초과 부분이 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="6631e6cc1655ad1b4e5dff0d7262c17fe69da03f" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="translated">마지막으로, &lt;code&gt;where&lt;/code&gt; 파라 방법 및 타입 정의를 기록하기위한 중위 연산자로 해석된다. 또한 &lt;code&gt;in&lt;/code&gt; 및 &lt;code&gt;isa&lt;/code&gt; 는 중위 연산자로 구문 분석됩니다. 그러나 &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;isa&lt;/code&gt; 라는 이름의 변수 생성 은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="396759f79c6ca8385ec1d2296022926c7edb5dd8" translate="yes" xml:space="preserve">
          <source>Finally, distributed computing runs multiple processes with separate memory spaces, potentially on different machines. This functionality is provided by the &lt;code&gt;Distributed&lt;/code&gt; standard library as well as external packages like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">마지막으로 분산 컴퓨팅은 잠재적으로 다른 시스템에서 별도의 메모리 공간을 사용하여 여러 프로세스를 실행합니다. 이 기능은 &lt;code&gt;Distributed&lt;/code&gt; 표준 라이브러리와 &lt;code&gt;MPI.jl&lt;/code&gt; 및 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 과 같은 외부 패키지에서 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="22655b3e2d52ed1fe3abbc273a301c575c9c7fae" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;DummyModule.jl&lt;/code&gt; is not a standalone file but a package, then &lt;code&gt;using DummyModule&lt;/code&gt; will &lt;em&gt;load&lt;/em&gt;&lt;code&gt;DummyModule.jl&lt;/code&gt; on all processes, but only bring it into scope on the process where &lt;code&gt;using&lt;/code&gt; was called.</source>
          <target state="translated">마지막으로, 만약 &lt;code&gt;DummyModule.jl&lt;/code&gt; 는 독립형 파일 만 패키지되어 있지 않은 경우, &lt;code&gt;using DummyModule&lt;/code&gt; 것입니다 &lt;em&gt;로드 &lt;/em&gt; &lt;code&gt;DummyModule.jl&lt;/code&gt; 을 모든 프로세스에 있지만, 경우에만 과정에 범위에 그것을 가지고 &lt;code&gt;using&lt;/code&gt; 불렸다.</target>
        </trans-unit>
        <trans-unit id="f1c7a00722ed8c5c04db876017518449fd3a13b0" translate="yes" xml:space="preserve">
          <source>Finally, let's take a look at some more complex examples where this rule comes into play. Define a function &lt;code&gt;f(x)&lt;/code&gt;, which initially has one method:</source>
          <target state="translated">마지막으로이 규칙이 적용되는 좀 더 복잡한 예를 살펴 보겠습니다. &lt;code&gt;f(x)&lt;/code&gt; 함수를 정의하십시오. 처음에는 하나의 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ab1a15d94e7105e3fcab5c9d28790890e0a56b" translate="yes" xml:space="preserve">
          <source>Finally, the &quot;exclusive or&quot; logical operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; always propagates &lt;code&gt;missing&lt;/code&gt; values, since both operands always have an effect on the result. Also note that the negation operator &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;missing&lt;/code&gt; when the operand is &lt;code&gt;missing&lt;/code&gt; just like other unary operators.</source>
          <target state="translated">마지막으로, &quot;독점 또는&quot;논리 연산자 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; 는&lt;/a&gt; 항상 결 &lt;code&gt;missing&lt;/code&gt; 전파 합니다. 두 피연산자가 항상 결과에 영향을 미치기 때문입니다. 또한 부정 연산자 &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;missing&lt;/code&gt; 피연산자가 될 때 &lt;code&gt;missing&lt;/code&gt; 단지 다른 단항 연산자처럼.</target>
        </trans-unit>
        <trans-unit id="f1606584dd02e5f78a49dbb79dadabcf6a1374a4" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[begin+1:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="translated">마지막으로, 벡터화 된 연산의 출력 배열이 &lt;em&gt;사전 할당&lt;/em&gt; 될 때 일반적으로 최대 효율성이 달성 되므로 반복 호출이 결과에 대해 새 배열을 반복해서 할당하지 않습니다 ( &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs&quot;&gt;출력 사전 할당&lt;/a&gt; 참조 ). 이것에 대한 편리한 구문은 &lt;code&gt;X .= ...&lt;/code&gt; 이며, 위와 같이 &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; 동일합니다 &lt;code&gt;broadcast!&lt;/code&gt; 루프는 중첩 된 &quot;점&quot;호출과 융합됩니다. 예를 들어, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; 는 &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt; 와 동일하며 &lt;code&gt;X&lt;/code&gt; 를 &lt;code&gt;sin.(Y)&lt;/code&gt; in-place로 덮어 씁니다 . 왼쪽이 배열 인덱싱 표현식 인 경우, 예 : &lt;code&gt;X[begin+1:end] .= sin.(Y)&lt;/code&gt; , 그러면 &lt;code&gt;broadcast!&lt;/code&gt; 번역됩니다 ! A의 &lt;code&gt;view&lt;/code&gt; , 예를 들면 &lt;code&gt;broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)&lt;/code&gt; , 왼쪽이 자리에서 업데이트됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="767751161f0cdd1157de7a8f8d7964c9db4474ed" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="translated">마지막으로 최대 효율은 일반적으로 벡터화 된 연산의 출력 배열이 &lt;em&gt;사전 할당&lt;/em&gt; 될 때 달성 되므로 반복 된 호출이 결과에 대해 새로운 배열을 반복해서 할당하지 않습니다 ( &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;사전 할당 출력&lt;/a&gt; 참조 ). 이에 대한 편리한 구문은 &lt;code&gt;X .= ...&lt;/code&gt; 이며, 위와 같이 &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; 동일합니다 &lt;code&gt;broadcast!&lt;/code&gt; 루프는 중첩 된 &quot;도트&quot;호출과 융합됩니다. 예를 들어 &lt;code&gt;X .= sin.(Y)&lt;/code&gt; 는 &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt; 와 동일하며 &lt;code&gt;X&lt;/code&gt; 를 &lt;code&gt;sin.(Y)&lt;/code&gt; 로 덮어 씁니다 . 왼쪽이 배열 인덱싱 표현식 인 경우 (예 : &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt; 그러면 &lt;code&gt;broadcast!&lt;/code&gt; 변환됩니다 ! A의 &lt;code&gt;view&lt;/code&gt; , 즉 &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt; , 그래서 왼쪽 제자리에서 업데이트된다.</target>
        </trans-unit>
        <trans-unit id="c12ff37c90964a19ee534ead21bebd3e9eed8809" translate="yes" xml:space="preserve">
          <source>Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</source>
          <target state="translated">마지막으로, Julia의 합리적인 숫자 유형에 대한 진행중인 사례 연구를 마치고 다음과 같은 프로모션 규칙을 사용하여 프로모션 메커니즘을 비교적 정교하게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="30b68f7e7af1c04cf4dd6e837e4591351c43581a" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. Arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 을 사용 하여 실제로 라이브러리 함수에 대한 호출을 생성 할 수 있습니다 . &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 대한 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7d84c29ce4854abb76c4c28bbdd03fd9c5aa451" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. The arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 을 사용 하여 실제로 라이브러리 함수에 대한 호출을 생성 할 수 있습니다 . &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 대한 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feefe85d510994646d16a16714a8d3ae19ac8a26" translate="yes" xml:space="preserve">
          <source>Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;guidelines for contributing&lt;/a&gt;.</source>
          <target state="translated">마지막으로, 소스를 기반으로 Julia를 빌드하는 것도 고려할 수 있습니다. 이 옵션은 주로 명령 줄에 익숙하거나 학습에 관심이있는 사람들을위한 것입니다. 이 내용이 귀하를 설명하는 경우, &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;기여 가이드 라인을&lt;/a&gt; 읽고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3fe342dc0e6c8372fd117cdbcdeaa485ff1b80" translate="yes" xml:space="preserve">
          <source>Finally,&lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="translated">마지막으로 &lt;code&gt;where&lt;/code&gt; 는 파라 메트릭 메소드 및 유형 정의를 작성하기위한 삽입 연산자로 구문 분석됩니다. 또한 &lt;code&gt;in&lt;/code&gt; 및 &lt;code&gt;isa&lt;/code&gt; 는 중위 연산자로 구문 분석됩니다. &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;isa&lt;/code&gt; 라는 이름의 변수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b51ec67d633a0669dda1015ca213cfa3baaf80" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y::T&lt;/code&gt; such that &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n), where n is the number of integers representable in &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; is an integer in &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; can represent any integer (e.g. &lt;code&gt;T == BigInt&lt;/code&gt;), then this operation corresponds to a conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n) 와 같이 &lt;code&gt;y::T&lt;/code&gt; 찾으십시오 . 여기서 n은 &lt;code&gt;T&lt;/code&gt; 로 표현할 수있는 정수의 수 이고 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt; 의 정수입니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 임의의 정수 (예를 나타낼 수 &lt;code&gt;T == BigInt&lt;/code&gt; )로 전환 된 다음에이 동작에 대응 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="c6150b2996e7de5708d81911408a8ec428d36e07" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y&lt;/code&gt; in the range &lt;code&gt;r&lt;/code&gt; such that $x &amp;equiv; y (mod n)$, where &lt;code&gt;n = length(r)&lt;/code&gt;, i.e. &lt;code&gt;y = mod(x - first(r), n) + first(r)&lt;/code&gt;.</source>
          <target state="translated">$ x &amp;equiv; y (mod n) $, 여기서 &lt;code&gt;n = length(r)&lt;/code&gt; , 즉 &lt;code&gt;y = mod(x - first(r), n) + first(r)&lt;/code&gt; 가되도록 범위 &lt;code&gt;r&lt;/code&gt; 에서 &lt;code&gt;y&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="f647c9d8a07df297d4680ab0a11627650c460ccd" translate="yes" xml:space="preserve">
          <source>Find a merge base (a common ancestor) between the commits &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt;. &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; may both be in string form. Return the &lt;code&gt;GitHash&lt;/code&gt; of the merge base.</source>
          <target state="translated">커밋 &lt;code&gt;one&lt;/code&gt; 과 &lt;code&gt;two&lt;/code&gt; 사이의 병합 기반 (공통 조상)을 찾으십시오 . &lt;code&gt;one&lt;/code&gt; 와 &lt;code&gt;two&lt;/code&gt; 은 모두 문자열 형식 일 수 있습니다. 머지베이스 의 &lt;code&gt;GitHash&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1825fce8a92f2ce1845fd36082521f2d3a4e162f" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 처음 나타나는 &lt;code&gt;pattern&lt;/code&gt; 을 찾으십시오 . 상당 &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80ded0d1fb8ec161dcae3181a5658542cce2200b" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 첫 번째 &lt;code&gt;pattern&lt;/code&gt; 을 찾습니다 . 상당 &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b21d600b94cf0b778ba467005900538f19345af8" translate="yes" xml:space="preserve">
          <source>Find the index of the element of &lt;code&gt;dx&lt;/code&gt; with the maximum absolute value. &lt;code&gt;n&lt;/code&gt; is the length of &lt;code&gt;dx&lt;/code&gt;, and &lt;code&gt;incx&lt;/code&gt; is the stride. If &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;incx&lt;/code&gt; are not provided, they assume default values of &lt;code&gt;n=length(dx)&lt;/code&gt; and &lt;code&gt;incx=stride1(dx)&lt;/code&gt;.</source>
          <target state="translated">최대 절대 값을 가진 &lt;code&gt;dx&lt;/code&gt; 요소의 색인을 찾으십시오 . &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;dx&lt;/code&gt; 의 길이 이고 &lt;code&gt;incx&lt;/code&gt; 는 보폭입니다. 경우 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;incx&lt;/code&gt; 이 제공되지 않습니다, 그들은의 기본 값 가정 &lt;code&gt;n=length(dx)&lt;/code&gt; 및 &lt;code&gt;incx=stride1(dx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eaf75b6910de284edca0478751e60e1ad92a9d8" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 마지막 &lt;code&gt;pattern&lt;/code&gt; 발생을 찾으십시오 . 상당 &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e62ddbda9380872652837135cdba3485044ca2" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 &lt;code&gt;pattern&lt;/code&gt; 의 마지막 항목을 찾습니다 . 상당 &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80338a6fd8042cc9a4548c075df3fb6d4dd0cdc" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 문자 &lt;code&gt;ch&lt;/code&gt; 의 마지막 발생을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="552c8ae53a2283ce454807a34e7013b314ceea60" translate="yes" xml:space="preserve">
          <source>Find the maximum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">최대 찾기 그리고 단일 차원을 따라 선형 대응 인덱스 &lt;code&gt;rval&lt;/code&gt; 에 와 &lt;code&gt;rind&lt;/code&gt; 한 결과의 저장 &lt;code&gt;rval&lt;/code&gt; 에 및 &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9aa328c598b9330ac1b7a72be0fe532e46cd4d55" translate="yes" xml:space="preserve">
          <source>Find the minimum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">최소 찾기 그리고 단일 차원을 따라 선형 대응 인덱스 &lt;code&gt;rval&lt;/code&gt; 에 와 &lt;code&gt;rind&lt;/code&gt; 한 결과의 저장 &lt;code&gt;rval&lt;/code&gt; 에 및 &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d865db872da82af36f837e5f310f73145bef3112" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함 후에 다음 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; (A)의 &lt;code&gt;true&lt;/code&gt; 의 요소 , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bed36c27812d4cd102ecb3fe1568c0bed863342" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함 후에 다음 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; 의 요소의 하는 &lt;code&gt;predicate&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a1d8f46d937916c8787067db2b2714283d812a5" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;. &lt;code&gt;pattern&lt;/code&gt; can be either a string, or a regular expression, in which case &lt;code&gt;string&lt;/code&gt; must be of type &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 위치에서 시작 하여 &lt;code&gt;string&lt;/code&gt; 에서 다음 &lt;code&gt;pattern&lt;/code&gt; 을 찾습니다 . &lt;code&gt;pattern&lt;/code&gt; 은 문자열이거나 정규식 일 수 있으며,이 경우 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;String&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ea577e1df683b2cdf0866079e5dca95cc8a70df" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 위치에서 시작하는 &lt;code&gt;string&lt;/code&gt; 에서 다음 문자 &lt;code&gt;ch&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="5acd53075bd7738ba5874f9d2945af016adac780" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함하기 전에 이전 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; (A)의 &lt;code&gt;true&lt;/code&gt; 의 요소 , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac4b726fe8ef16af102227f0592ab9d5019209eb" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함하기 전에 이전 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; 의 요소의 하는 &lt;code&gt;predicate&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7099f261e64c52f512558cba2d47b4f0bc49c077" translate="yes" xml:space="preserve">
          <source>Find the previous occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">위치 &lt;code&gt;start&lt;/code&gt; 에서 시작 하는 &lt;code&gt;string&lt;/code&gt; 에서 이전에 나타난 &lt;code&gt;pattern&lt;/code&gt; 을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="0eee018a6003d420d94f270f4deb2bf0aff001cc" translate="yes" xml:space="preserve">
          <source>Find the root module of a given module. This is the first module in the chain of parent modules of &lt;code&gt;m&lt;/code&gt; which is either a registered root module or which is its own parent module.</source>
          <target state="translated">주어진 모듈의 루트 모듈을 찾으십시오. 이것은 등록 된 루트 모듈이거나 자체 상위 모듈 인 &lt;code&gt;m&lt;/code&gt; 의 상위 모듈 체인에서 첫 번째 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="48db6f6163bbca28ad1cb048ef296ccaadb4bcda" translate="yes" xml:space="preserve">
          <source>Finding the length of time between two &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is straightforward given their underlying representation as &lt;code&gt;UTInstant{Day}&lt;/code&gt; and &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt;, respectively. The difference between &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is returned in the number of &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt;&lt;code&gt;Day&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in the number of &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt;&lt;code&gt;Millisecond&lt;/code&gt;&lt;/a&gt;. Similarly, comparing &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; is a simple matter of comparing the underlying machine instants (which in turn compares the internal &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values).</source>
          <target state="translated">두 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 사이의 시간을 찾는 것은 기본적으로 각각 &lt;code&gt;UTInstant{Day}&lt;/code&gt; 및 &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt; 로 표시되므로 간단 합니다. &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 의 차이 는 &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt; &lt;code&gt;Day&lt;/code&gt; &lt;/a&gt; 수로 , &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt; &lt;code&gt;Millisecond&lt;/code&gt; &lt;/a&gt; 수로 반환됩니다 . 마찬가지로 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 을 비교하는 것은 기본 컴퓨터 순간을 비교하는 간단한 문제입니다 (이는 내부 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 값을 비교 합니다).</target>
        </trans-unit>
        <trans-unit id="2069d729b3672a99ea2f38ff359c481d7de66468" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;LU&lt;/code&gt; factorization of a tridiagonal matrix with &lt;code&gt;dl&lt;/code&gt; on the subdiagonal, &lt;code&gt;d&lt;/code&gt; on the diagonal, and &lt;code&gt;du&lt;/code&gt; on the superdiagonal.</source>
          <target state="translated">찾아 &lt;code&gt;LU&lt;/code&gt; 의 삼중 대각 매트릭스 분해의 &lt;code&gt;dl&lt;/code&gt; subdiagonal에 &lt;code&gt;d&lt;/code&gt; 대각선을 한 &lt;code&gt;du&lt;/code&gt; 에 superdiagonal.</target>
        </trans-unit>
        <trans-unit id="f84cbc64cd18b52fd324e199af11a5fabde58655" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt; with matrix balancing. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. If &lt;code&gt;balanc = N&lt;/code&gt;, no balancing is performed. If &lt;code&gt;balanc = P&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted but not scaled. If &lt;code&gt;balanc = S&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is scaled but not permuted. If &lt;code&gt;balanc = B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted and scaled. If &lt;code&gt;sense = N&lt;/code&gt;, no reciprocal condition numbers are computed. If &lt;code&gt;sense = E&lt;/code&gt;, reciprocal condition numbers are computed for the eigenvalues only. If &lt;code&gt;sense = V&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors only. If &lt;code&gt;sense = B&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If &lt;code&gt;sense = E,B&lt;/code&gt;, the right and left eigenvectors must be computed.</source>
          <target state="translated">행렬 균형 조정을 사용 하여 &lt;code&gt;A&lt;/code&gt; 의 고유 시스템을 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; , 우측 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다. 경우 &lt;code&gt;balanc = N&lt;/code&gt; 어떠한 균형이 수행되지 않는다. 경우 &lt;code&gt;balanc = P&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 순열하지만 크기는 조절되지 않습니다. 경우 &lt;code&gt;balanc = S&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 축소되지만 순열되지 않습니다. 경우 &lt;code&gt;balanc = B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 순열 및 스케일링된다. &lt;code&gt;sense = N&lt;/code&gt; 경우상호 조건 번호는 계산되지 않습니다. 경우 &lt;code&gt;sense = E&lt;/code&gt; , 상호 조건 번호는 고유 값에 대해 계산된다. &lt;code&gt;sense = V&lt;/code&gt; 인 경우 , 올바른 고유 벡터에 대해서만 상호 조건 번호가 계산됩니다. 경우 &lt;code&gt;sense = B&lt;/code&gt; , 상호 조건 번호는 고유 벡터 및 우측 고유 벡터에 대해 계산된다. 만약 &lt;code&gt;sense = E,B&lt;/code&gt; 오른쪽과 왼쪽 고유 벡터 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0023ab74a3d6a6fa55c15cb99a0305228d939c9" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. Returns the eigenvalues in &lt;code&gt;W&lt;/code&gt;, the right eigenvectors in &lt;code&gt;VR&lt;/code&gt;, and the left eigenvectors in &lt;code&gt;VL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 고유 시스템을 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; , 우측 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다. &lt;code&gt;W&lt;/code&gt; 의 고유 값 , &lt;code&gt;VR&lt;/code&gt; 의 오른쪽 고유 벡터, &lt;code&gt;VL&lt;/code&gt; 의 왼쪽 고유 벡터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c756f96984dbd050044ac948d5f71380b56742" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of an upper triangular matrix &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;side = R&lt;/code&gt;, the right eigenvectors are computed. If &lt;code&gt;side = L&lt;/code&gt;, the left eigenvectors are computed. If &lt;code&gt;side = B&lt;/code&gt;, both sets are computed. If &lt;code&gt;howmny = A&lt;/code&gt;, all eigenvectors are found. If &lt;code&gt;howmny = B&lt;/code&gt;, all eigenvectors are found and backtransformed using &lt;code&gt;VL&lt;/code&gt; and &lt;code&gt;VR&lt;/code&gt;. If &lt;code&gt;howmny = S&lt;/code&gt;, only the eigenvectors corresponding to the values in &lt;code&gt;select&lt;/code&gt; are computed.</source>
          <target state="translated">상부 삼각 행렬 &lt;code&gt;T&lt;/code&gt; 의 고유 시스템을 찾습니다 . 하면 &lt;code&gt;side = R&lt;/code&gt; , 우측 고유 벡터가 계산된다. 하면 &lt;code&gt;side = L&lt;/code&gt; , 왼쪽의 고유 벡터가 계산된다. 하면 &lt;code&gt;side = B&lt;/code&gt; , 두 세트가 계산된다. 경우 &lt;code&gt;howmny = A&lt;/code&gt; 모든 고유 벡터가 발견된다. 경우 &lt;code&gt;howmny = B&lt;/code&gt; 모든 고유 벡터 발견하고 사용 backtransformed하는 &lt;code&gt;VL&lt;/code&gt; 및 &lt;code&gt;VR&lt;/code&gt; 을 . 경우 &lt;code&gt;howmny = S&lt;/code&gt; ,의 값에 대응하는 고유 벡터만을 &lt;code&gt;select&lt;/code&gt; 계산된다.</target>
        </trans-unit>
        <trans-unit id="0322800c8fc7bfd25f123e3f433827d776d8a68b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상단 삼각형 &lt;code&gt;A&lt;/code&gt; 는 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4975ecab6a2216e2ae41b865699cde79f331c8b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상단 삼각형 &lt;code&gt;A&lt;/code&gt; 는 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다. 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 만약 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 경우. 발견 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. &lt;code&gt;abstol&lt;/code&gt; 는 융합 공차로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="61beb0a5e34ea39a8997c5ca322120812554427f" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigendecomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 분해를 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터를 계산하지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; 우측 고유 벡터가 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다.</target>
        </trans-unit>
        <trans-unit id="c264a1b0e814f3cbf1d8360c3568e4b5d9e1b127" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt; and symmetric positive-definite matrix &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;itype = 1&lt;/code&gt;, the problem to solve is &lt;code&gt;A * x = lambda * B * x&lt;/code&gt;. If &lt;code&gt;itype = 2&lt;/code&gt;, the problem to solve is &lt;code&gt;A * B * x = lambda * x&lt;/code&gt;. If &lt;code&gt;itype = 3&lt;/code&gt;, the problem to solve is &lt;code&gt;B * A * x = lambda * x&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 와 대칭 양의 유한 행렬 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 상단 삼각형 이 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다. 경우 &lt;code&gt;itype = 1&lt;/code&gt; 해결하는 문제는 &lt;code&gt;A * x = lambda * B * x&lt;/code&gt; . 경우 &lt;code&gt;itype = 2&lt;/code&gt; , 해결하는 문제는 &lt;code&gt;A * B * x = lambda * x&lt;/code&gt; . 경우 &lt;code&gt;itype = 3&lt;/code&gt; , 해결하는 문제는 &lt;code&gt;B * A * x = lambda * x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32def567c6d9738ac90487f8efbe1b9b389479aa" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt; or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 특이 값 분해 , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 및 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 찾습니다 . &lt;code&gt;D1&lt;/code&gt; 은 대각선에 &lt;code&gt;alpha&lt;/code&gt; 가 있고 &lt;code&gt;D2&lt;/code&gt; 는 대각선에 &lt;code&gt;beta&lt;/code&gt; 가 있습니다. 경우 &lt;code&gt;jobu = U&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;U&lt;/code&gt; 를 계산한다. 경우 &lt;code&gt;jobv = V&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;V&lt;/code&gt; 는 계산된다. 경우 &lt;code&gt;jobq = Q&lt;/code&gt; 직교 / 단위 행렬 &lt;code&gt;Q&lt;/code&gt; 가 계산된다. 만약 &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; 또는 &lt;code&gt;jobq&lt;/code&gt; 가 있다 &lt;code&gt;N&lt;/code&gt; 해당 행렬은 계산되지 않습니다. 이 기능은 3.6.0 이전의 LAPACK 버전에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="210e81d5d1ad1ff32c30a0939ad6da82758f3395" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt;, or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function requires LAPACK 3.6.0.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 특이 값 분해 , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 및 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 찾습니다 . &lt;code&gt;D1&lt;/code&gt; 은 대각선에 &lt;code&gt;alpha&lt;/code&gt; 가 있고 &lt;code&gt;D2&lt;/code&gt; 는 대각선에 &lt;code&gt;beta&lt;/code&gt; 가 있습니다. 경우 &lt;code&gt;jobu = U&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;U&lt;/code&gt; 를 계산한다. 경우 &lt;code&gt;jobv = V&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;V&lt;/code&gt; 는 계산된다. 경우 &lt;code&gt;jobq = Q&lt;/code&gt; 직교 / 단위 행렬 &lt;code&gt;Q&lt;/code&gt; 가 계산된다. 만약 &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; , 또는 &lt;code&gt;jobq&lt;/code&gt; 가 있다 &lt;code&gt;N&lt;/code&gt; 해당 행렬은 계산되지 않습니다. 이 기능에는 LAPACK 3.6.0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a39c044a480fd441ceb8f283f49fa1d53cc5f0a7" translate="yes" xml:space="preserve">
          <source>Finds the inverse of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">삼각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역수를 &lt;code&gt;uplo = U&lt;/code&gt; ( uplo = U 이면 위 , &lt;code&gt;uplo = L&lt;/code&gt; 이면 아래 ) . 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. &lt;code&gt;diag = U&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 모든 대각선 요소 는 1입니다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="6a5d68361868fdd15faef2d4f1871095495175a9" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. If &lt;code&gt;norm = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;norm = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm.</source>
          <target state="translated">삼각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역수 조건 수를 찾습니다 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 상위 , &lt;code&gt;uplo = L&lt;/code&gt; 경우 하위 ) . 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. &lt;code&gt;diag = U&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 모든 대각선 요소 는 1입니다. 경우 &lt;code&gt;norm = I&lt;/code&gt; , 조건 수는 무한대의 규범에서 발견된다. 경우 &lt;code&gt;norm = O&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 의 조건 수는 하나 개의 표준에서 발견된다.</target>
        </trans-unit>
        <trans-unit id="c78886357b0729c06906090f44a5cf8b7b256de8" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;normtype = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;normtype = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm. &lt;code&gt;A&lt;/code&gt; must be the result of &lt;code&gt;getrf!&lt;/code&gt; and &lt;code&gt;anorm&lt;/code&gt; is the norm of &lt;code&gt;A&lt;/code&gt; in the relevant norm.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 역수를 구합니다 . 경우 &lt;code&gt;normtype = I&lt;/code&gt; , 조건 수는 무한대의 규범에서 발견된다. 경우 &lt;code&gt;normtype = O&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 의 조건 수는 하나 개의 표준에서 발견된다. &lt;code&gt;A&lt;/code&gt; 는 의 결과이어야합니다 &lt;code&gt;getrf!&lt;/code&gt; 및 &lt;code&gt;anorm&lt;/code&gt; 은 의 규범 관련 규범이다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c19c48ac3ae5442f994d8fe0a9d01dd34ef53de" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;, using a divide and conquer approach. If &lt;code&gt;job = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; and the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; or rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;job = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately.</source>
          <target state="translated">나누기 및 정복 방법을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = U * S * V'&lt;/code&gt; 의 특이 값 분해를 찾습니다 . &lt;code&gt;job = A&lt;/code&gt; 인 경우 &lt;code&gt;U&lt;/code&gt; 의 모든 열과 &lt;code&gt;V'&lt;/code&gt; 의 행 이 계산됩니다. &lt;code&gt;job = N&lt;/code&gt; 인 경우 &lt;code&gt;U&lt;/code&gt; 열 또는 &lt;code&gt;V'&lt;/code&gt; 행 이 계산되지 않습니다. 경우 &lt;code&gt;job = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (얇은)의 열이 덮어 &lt;code&gt;U&lt;/code&gt; 와 (얇은)의 행 &lt;code&gt;V'&lt;/code&gt; . 경우 &lt;code&gt;job = S&lt;/code&gt; (박막)의 열 &lt;code&gt;U&lt;/code&gt; 및 (박막)의 행 &lt;code&gt;V'&lt;/code&gt; 계산 따로 반환된다.</target>
        </trans-unit>
        <trans-unit id="a0b3e8d21586ca0fb1724dcb3c78acc9787461cc" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;. If &lt;code&gt;jobu = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = A&lt;/code&gt; all the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = N&lt;/code&gt; no rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt;. If &lt;code&gt;jobvt = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;jobu = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; are computed and returned separately. If &lt;code&gt;jobvt = S&lt;/code&gt; the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately. &lt;code&gt;jobu&lt;/code&gt; and &lt;code&gt;jobvt&lt;/code&gt; can't both be &lt;code&gt;O&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = U * S * V'&lt;/code&gt; 의 특이 값 분해를 찾습니다 . &lt;code&gt;jobu = A&lt;/code&gt; 인 경우 &lt;code&gt;U&lt;/code&gt; 의 모든 열 이 계산됩니다. &lt;code&gt;jobvt = A&lt;/code&gt; 경우 &lt;code&gt;V'&lt;/code&gt; 의 모든 행 이 계산됩니다. 경우 &lt;code&gt;jobu = N&lt;/code&gt; 의 더 열 &lt;code&gt;U&lt;/code&gt; 는 계산되지 않습니다. &lt;code&gt;jobvt = N&lt;/code&gt; 이면 &lt;code&gt;V'&lt;/code&gt; 행 이 계산 되지 않습니다 . 경우 &lt;code&gt;jobu = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (박막)의 열이 덮어 &lt;code&gt;U&lt;/code&gt; . 경우 &lt;code&gt;jobvt = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (박막)의 로우로 덮어 &lt;code&gt;V'&lt;/code&gt; . 경우 &lt;code&gt;jobu = S&lt;/code&gt; 의 열 (얇은) &lt;code&gt;U&lt;/code&gt; 는 별도로 계산되고 반환됩니다. 경우 &lt;code&gt;jobvt = S&lt;/code&gt; (박막)의 행 &lt;code&gt;V'&lt;/code&gt; 계산 따로 반환된다. &lt;code&gt;jobu&lt;/code&gt; 및 &lt;code&gt;jobvt&lt;/code&gt; 는 모두 &lt;code&gt;O&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbc35df929a38fee1ee63d2aef508a3752ae6f0" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">용액을 찾아 &lt;code&gt;A * X = B&lt;/code&gt; 에르 미트 행렬에 대한 &lt;code&gt;A&lt;/code&gt; . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. 솔루션 &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 . Bunch-Kaufman 인수 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;ipiv&lt;/code&gt; 에는 인수 분해에 대한 피벗 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1c2e1c20cfe582666286913369ada94f51d8cf" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 에 대한 &lt;code&gt;A * X = B&lt;/code&gt; 대한 해를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. 솔루션 &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 . Bunch-Kaufman 인수 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;ipiv&lt;/code&gt; 에는 인수 분해에 대한 피벗 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c0a676aeb2122358cb2d2b62a8dc34d0ff96bb" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by &lt;code&gt;potrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">찾아에 용액 &lt;code&gt;A * X = B&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 촐레 스키 분해에 의해 계산 된 대칭 또는 에르 미트 정부 호 행렬이다 &lt;code&gt;potrf!&lt;/code&gt; . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 상단 콜레 분해 &lt;code&gt;A&lt;/code&gt; 는 계산했다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; 하부 촐레 스키 분해 &lt;code&gt;A&lt;/code&gt; 를 산출 하였다. 솔루션 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e99b5edae4a2dc1678284239ea67a37fe1921376" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A * X = B&lt;/code&gt; 대한 해를 구합니다. 여기서 &lt;code&gt;A&lt;/code&gt; 는 대칭형 또는 은자 양수 한정 행렬입니다. &lt;code&gt;uplo = U&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 의 C 레 스키 상층 분해 가 계산됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; 하부 촐레 스키 분해 &lt;code&gt;A&lt;/code&gt; 를 산출한다. Cholesky 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. 솔루션 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8e7e713430f9bcb8fd60110d1ddaba473fe37beb" translate="yes" xml:space="preserve">
          <source>Finished with an uncaught exception</source>
          <target state="translated">잡히지 않은 예외로 마무리</target>
        </trans-unit>
        <trans-unit id="d4f94f922955d9b99f89834068cd98fd1aba023b" translate="yes" xml:space="preserve">
          <source>Finite Part Integral</source>
          <target state="translated">유한 부분 적분</target>
        </trans-unit>
        <trans-unit id="e5b076c42526fba51c6923d8682dc75c64aa4bcd" translate="yes" xml:space="preserve">
          <source>Finite difference operator on a vector or a multidimensional array &lt;code&gt;A&lt;/code&gt;. In the latter case the dimension to operate on needs to be specified with the &lt;code&gt;dims&lt;/code&gt; keyword argument.</source>
          <target state="translated">벡터 또는 다차원 어레이에 대한 유한 차분 연산자 . 후자의 경우 작동 할 차원은 &lt;code&gt;dims&lt;/code&gt; 키워드 인수 로 지정해야합니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a4557ec58940c5eada2fe857ddb8888c78004d3" translate="yes" xml:space="preserve">
          <source>Finite numbers are ordered in the usual manner.</source>
          <target state="translated">유한 번호는 일반적인 방식으로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="78baebfcb4b52665d7e8a9c7826c47b0fa2439f6" translate="yes" xml:space="preserve">
          <source>Fire</source>
          <target state="translated">Fire</target>
        </trans-unit>
        <trans-unit id="ccb3bd276e9391502d5858c0ee82ed61db7ec7a7" translate="yes" xml:space="preserve">
          <source>Fire Engine</source>
          <target state="translated">소방차</target>
        </trans-unit>
        <trans-unit id="c38b663a951f35db127c178e977a734a5f954d31" translate="yes" xml:space="preserve">
          <source>Firework Sparkler</source>
          <target state="translated">불꽃 향</target>
        </trans-unit>
        <trans-unit id="4f8ff80cb6112a8df5a0ae17110f841b4709fc4a" translate="yes" xml:space="preserve">
          <source>Fireworks</source>
          <target state="translated">Fireworks</target>
        </trans-unit>
        <trans-unit id="0b7bdf63087ea834463f7869ee05ee0f78b2039d" translate="yes" xml:space="preserve">
          <source>First Quarter Moon</source>
          <target state="translated">1 분기 문</target>
        </trans-unit>
        <trans-unit id="8d23a610d2c1a9be816138d8135fd6968e488141" translate="yes" xml:space="preserve">
          <source>First Quarter Moon Symbol</source>
          <target state="translated">1 분기 문 기호</target>
        </trans-unit>
        <trans-unit id="74fa6c1e17a3a3252deb8af7194e87d8d33fbc11" translate="yes" xml:space="preserve">
          <source>First Quarter Moon With Face</source>
          <target state="translated">얼굴이있는 1 분기 문</target>
        </trans-unit>
        <trans-unit id="f1738c1a48a67517ee40f4407fe85d205603ee0a" translate="yes" xml:space="preserve">
          <source>First, a review of some relevant Julia type terminology:</source>
          <target state="translated">먼저 관련된 Julia 유형 용어를 검토합니다.</target>
        </trans-unit>
        <trans-unit id="429810985fd6146395c751081851ef1372d21c2f" translate="yes" xml:space="preserve">
          <source>First, let's review some relevant Julia type terminology:</source>
          <target state="translated">먼저 관련 Julia 유형 용어를 검토해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7cea893d2a53ebb1e9b3f78ee61f550c12f76b89" translate="yes" xml:space="preserve">
          <source>First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</source>
          <target state="translated">먼저, 삼중 따옴표로 묶인 문자열도 가장 들여 쓰기가 적은 줄 수준으로 표시됩니다. 들여 쓰기 된 코드 내에서 문자열을 정의 할 때 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0d11adabc82edc0523feb5883cbbd9e9d59c1cd" translate="yes" xml:space="preserve">
          <source>First, with &lt;code&gt;ntasks&lt;/code&gt; undefined, each element is processed in a different task.</source>
          <target state="translated">먼저, &lt;code&gt;ntasks&lt;/code&gt; 가 정의되어 있지 않으면 각 요소가 다른 작업에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3030e8ec7633ec1a524bb246aee7dbda6fb3e4bc" translate="yes" xml:space="preserve">
          <source>Fish</source>
          <target state="translated">Fish</target>
        </trans-unit>
        <trans-unit id="08ef4d73924ae1ff99ef9760dad3a8b35cdbc717" translate="yes" xml:space="preserve">
          <source>Fish Cake With Swirl Design</source>
          <target state="translated">소용돌이 모양의 생선 케이크</target>
        </trans-unit>
        <trans-unit id="6af9685850189240cc327402ef6a117b0925f447" translate="yes" xml:space="preserve">
          <source>Fisheye</source>
          <target state="translated">Fisheye</target>
        </trans-unit>
        <trans-unit id="217458563b479c9b5e1aa24b33b36b9c5286dff5" translate="yes" xml:space="preserve">
          <source>Fishing Pole And Fish</source>
          <target state="translated">낚싯대와 물고기</target>
        </trans-unit>
        <trans-unit id="ec1091759eb5098c1ce15fb7122c53128cb7e317" translate="yes" xml:space="preserve">
          <source>Fisted Hand Sign</source>
          <target state="translated">주먹 손 기호</target>
        </trans-unit>
        <trans-unit id="46a9bd02c1e56f8667dcc006e6e80c33bdfb6b09" translate="yes" xml:space="preserve">
          <source>Five-argument &lt;code&gt;mul!&lt;/code&gt; requires at least Julia 1.3.</source>
          <target state="translated">5 인수 &lt;code&gt;mul!&lt;/code&gt; 최소한 Julia 1.3이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ee4d04bcaeb407d6978ec547023834d74dc08028" translate="yes" xml:space="preserve">
          <source>Fix deprecation warnings</source>
          <target state="translated">지원 중단 경고 수정</target>
        </trans-unit>
        <trans-unit id="f057e4dd9329dfaa6b558f5251558c8bd7042ccf" translate="yes" xml:space="preserve">
          <source>Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; would correspond to a date string like &lt;code&gt;&quot;20140716&quot;&lt;/code&gt;. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; from one period character to the next.</source>
          <target state="translated">고정 폭 슬롯은 문자 사이에 구분자가없는 폭에 해당하는 횟수만큼 마침표 문자를 반복하여 지정됩니다. 따라서 &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;20140716&quot;&lt;/code&gt; 과 같은 날짜 문자열에 해당합니다 . 파서는 구분 문자가 없어 고정 너비 슬롯을 구분 하여 한 마침표 문자에서 다음 마침표 문자로의 &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; 전환 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5695ea14bfec9e6b7d86faa5e86d6e6aa911f902" translate="yes" xml:space="preserve">
          <source>Flag In Hole</source>
          <target state="translated">구멍에 깃발</target>
        </trans-unit>
        <trans-unit id="58270b038657eb33ab9c272d4b0b663caf6f505b" translate="yes" xml:space="preserve">
          <source>Flatness</source>
          <target state="translated">Flatness</target>
        </trans-unit>
        <trans-unit id="157a69122ac7ee154e0f87d80f294a117ce27465" translate="yes" xml:space="preserve">
          <source>Flexed Biceps</source>
          <target state="translated">굽은 이두근</target>
        </trans-unit>
        <trans-unit id="ee9ce77c4431cac02ee809f2bf8b3362c097e451" translate="yes" xml:space="preserve">
          <source>Flip the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt;, so that if a bit is &lt;code&gt;0&lt;/code&gt; it will be &lt;code&gt;1&lt;/code&gt; after the toggle, and vice-versa.</source>
          <target state="translated">비트 플립의 &lt;code&gt;val&lt;/code&gt; 에 의해 인덱싱 &lt;code&gt;flag&lt;/code&gt; 비트 인 경우 그래서, &lt;code&gt;0&lt;/code&gt; 이 될 것 &lt;code&gt;1&lt;/code&gt; , 토글 후에, 그 반대.</target>
        </trans-unit>
        <trans-unit id="444518fe06999c30d999423013ab4f1c5d158646" translate="yes" xml:space="preserve">
          <source>Floating-Point Numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="50eee28c25d79612d8553be7d7bd2846378f99a9" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</source>
          <target state="translated">부동 소수점 산술에는 낮은 수준의 구현 세부 사항에 익숙하지 않은 사용자에게는 놀라 울 수있는 많은 미묘함이 수반됩니다. 그러나 이러한 미묘한 점은 과학 계산에 관한 대부분의 책과 다음 참고 자료에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa83ec82b434276bb3bfc0811f157d35a5e75cfc" translate="yes" xml:space="preserve">
          <source>Floating-point numbers have &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;two zeros&lt;/a&gt;, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt;&lt;code&gt;bitstring&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">부동 소수점 숫자에는 양수 0과 음수 0의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;두 개의 0&lt;/a&gt; 이 있습니다. &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt; &lt;code&gt;bitstring&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 볼 수 있듯이 서로 같지만 이진 표현이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3fba63653b996ccaa92264b381e4cee8797797a5" translate="yes" xml:space="preserve">
          <source>Floating-point operations on reduction variables can be reordered, possibly causing different results than without &lt;code&gt;@simd&lt;/code&gt;.</source>
          <target state="translated">감소 변수에 대한 부동 소수점 연산은 재정렬되어 &lt;code&gt;@simd&lt;/code&gt; 없이 다른 결과가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5043ab32eb0ec94e147a66ceca999e1ecfae56b6" translate="yes" xml:space="preserve">
          <source>Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</source>
          <target state="translated">부동 소수점 값은 가장 큰 부동 소수점 인수 유형으로 승격됩니다. 정수 값은 기본 기계어 크기 또는 가장 큰 정수 인수 유형 중 하나로 크게 승격됩니다. 정수와 부동 소수점 값의 혼합은 모든 값을 보유하기에 충분히 큰 부동 소수점 유형으로 승격됩니다. 유리수와 혼합 된 정수는 유리수로 승격됩니다. 부유물과 혼합 된 합리성은 부유물로 승격됩니다. 실수 값과 혼합 된 복소수 값은 적절한 종류의 복소수 값으로 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">부동 소수점 제로</target>
        </trans-unit>
        <trans-unit id="d43047ffbb02b9960d1076b1d1bb9cdef48764e1" translate="yes" xml:space="preserve">
          <source>Flooring division, returning a value consistent with &lt;code&gt;mod1(x,y)&lt;/code&gt;</source>
          <target state="translated">바닥 분할, &lt;code&gt;mod1(x,y)&lt;/code&gt; 와 일치하는 값 반환</target>
        </trans-unit>
        <trans-unit id="0cb23ae2c189b13f5f90d739cf453c252387dc2d" translate="yes" xml:space="preserve">
          <source>Floppy Disk</source>
          <target state="translated">플로피 디스크</target>
        </trans-unit>
        <trans-unit id="00d43012b0d3d0a7fff1c3e0edf1cbd87e191788" translate="yes" xml:space="preserve">
          <source>Flower Playing Cards</source>
          <target state="translated">꽃 놀이 카드</target>
        </trans-unit>
        <trans-unit id="3b70164ceac5ab45d8a49385e479599c3b2028ee" translate="yes" xml:space="preserve">
          <source>Flushed Face</source>
          <target state="translated">플러시 얼굴</target>
        </trans-unit>
        <trans-unit id="c095ff38e8ffaf6ceac6c9df64aa62e9da573536" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams (which may have been written to by external C code).</source>
          <target state="translated">C &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 스트림을 플러시합니다 (외부 C 코드로 작성되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="88957d8137dbc8ecadcade0adeacd0f2a5ab4356" translate="yes" xml:space="preserve">
          <source>Foggy</source>
          <target state="translated">Foggy</target>
        </trans-unit>
        <trans-unit id="6e5da7739741403346eb36590ee15c92d6501bc4" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="translated">외부 생성자 정의에 따라 &lt;code&gt;⊘&lt;/code&gt; 연산자에 대한 여러 메소드를 정의했으며 , 이는 합리적 작성을위한 구문을 제공합니다 (예 : &lt;code&gt;1 ⊘ 2&lt;/code&gt; ). Julia의 &lt;code&gt;Rational&lt;/code&gt; 유형은 이를 위해 &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; 연산자를 사용합니다 . 이러한 정의 이전에 &lt;code&gt;⊘&lt;/code&gt; 은 구문 만 있고 의미가없는 완전히 정의되지 않은 연산자입니다. 이후에는 &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers&quot;&gt;Rational Numbers에&lt;/a&gt; 설명 된대로 동작합니다. 전체 동작은이 몇 줄에 정의되어 있습니다. 제 가장 기본적인 정의가 단지 수 &lt;code&gt;a ⊘ b&lt;/code&gt; 구조체 &lt;code&gt;OurRational&lt;/code&gt; 을 인가하여 &lt;code&gt;OurRational&lt;/code&gt; 로 생성자 및 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 정수일 때. &lt;code&gt;⊘&lt;/code&gt; 의 피연산자 중 하나 가 이미 유리수이면 결과 비율에 대한 새로운 유리수를 약간 다르게 구성합니다. 이 동작은 실제로 유리수를 정수로 나누는 것과 동일합니다. 마지막으로 &lt;code&gt;⊘&lt;/code&gt; 를 복잡한 정수 값에 적용 하면 실수와 허수 부분이 합리적인 복소수 인 &lt;code&gt;Complex{OurRational}&lt;/code&gt; 의 인스턴스가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c789741f990351befd624144e4fbf31c533b3a78" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="translated">외부 생성자 정의에 따라, 우리는 &lt;code&gt;⊘&lt;/code&gt; 연산자에 대한 여러 가지 방법을 정의했으며 ,이 연산자는 유리수를 작성하기위한 구문을 제공합니다 (예 : &lt;code&gt;1 ⊘ 2&lt;/code&gt; ). Julia의 &lt;code&gt;Rational&lt;/code&gt; 유형은 이 목적으로 &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; 연산자를 사용합니다 . 이러한 정의 이전에 &lt;code&gt;⊘&lt;/code&gt; 는 구문 만 있고 의미가없는 완전히 정의되지 않은 연산자입니다. 그 후에는 &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers에&lt;/a&gt; 설명 된대로 작동 합니다. 전체 동작은이 몇 줄에 정의되어 있습니다. 제 가장 기본적인 정의가 단지 수 &lt;code&gt;a ⊘ b&lt;/code&gt; 구조체 &lt;code&gt;OurRational&lt;/code&gt; 을 인가하여 &lt;code&gt;OurRational&lt;/code&gt; 로 생성자 및 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 그들이 정수일 때. &lt;code&gt;⊘&lt;/code&gt; 의 피연산자 중 하나 가 이미 합리적인 수인 경우 결과 비율에 대한 새로운 합리성을 약간 다르게 구성합니다. 이 동작은 실제로 유리수를 정수로 나누는 것과 동일합니다. 마지막으로,인가 &lt;code&gt;⊘&lt;/code&gt; 복소 적분 값은 인스턴스 생성 &lt;code&gt;Complex{OurRational}&lt;/code&gt; - 그 실수 부 및 허수 부 유리수되는 복소수 :</target>
        </trans-unit>
        <trans-unit id="1e77a8685e1b18b030132d7235106a58bff9d77d" translate="yes" xml:space="preserve">
          <source>Footnote references</source>
          <target state="translated">각주 참조</target>
        </trans-unit>
        <trans-unit id="9d738544b84d3e6ca69948f1d45fc336d259c385" translate="yes" xml:space="preserve">
          <source>Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the &lt;code&gt;:&lt;/code&gt; character that is appended to the footnote label.</source>
          <target state="translated">각주 텍스트는 각주 레이블에 추가 된 &lt;code&gt;:&lt;/code&gt; 문자를 제외하고 각주 참조 구문과 유사한 다음 구문을 사용하여 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="6f17ee469db4ec0c0c7e81b41c2cbcf9f902b3cc" translate="yes" xml:space="preserve">
          <source>Footprints</source>
          <target state="translated">Footprints</target>
        </trans-unit>
        <trans-unit id="ae9f4e9dfa0443b0ceae859867c4f509f5a9474e" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects this can be done either directly or by use of a convenience macro:</source>
          <target state="translated">들어 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이 직접 중 하나를 수행하거나 편의 매크로를 사용하여 할 수있는 개체 :</target>
        </trans-unit>
        <trans-unit id="b1492f65d2da61bde614e2df1030321603972a60" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; 정수 유형이 동일하다 &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; . 들면 &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; 유형 정수이 동등 &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a40737843ce84d120d446cac7c60f6d3a180523" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types that support arbitrary dimensionality, &lt;code&gt;N&lt;/code&gt; can be set to &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">들어 &lt;code&gt;AbstractArray&lt;/code&gt; 의 임의의 차원을 지원하는 유형, &lt;code&gt;N&lt;/code&gt; 은 설정할 수 있습니다 &lt;code&gt;Any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78cc0c00798ab494e86cd193ffb9a72a0848fb41" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types, defining a &lt;code&gt;BroadcastStyle&lt;/code&gt; supersedes the fallback choice, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt;&lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;DefaultArrayStyle&lt;/code&gt; and the abstract supertype, &lt;code&gt;AbstractArrayStyle&lt;/code&gt;, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</source>
          <target state="translated">들어 &lt;code&gt;AbstractArray&lt;/code&gt; 의 종류, 결정적인 &lt;code&gt;BroadcastStyle&lt;/code&gt; 것은 , 대체 선택을 대체 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt; &lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt; 을&lt;/a&gt; . &lt;code&gt;DefaultArrayStyle&lt;/code&gt; 및 추상 수퍼 타입 ​​인 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 은 차원 요구 사항이 고정 된 특수 배열 유형을 지원하기 위해 차원을 유형 매개 변수로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0c614db39e8f0ca718810e31731f59d181271482" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArrays&lt;/code&gt; that only support a certain dimensionality, create a subtype of &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (see below).</source>
          <target state="translated">들면 &lt;code&gt;AbstractArrays&lt;/code&gt; 만 소정 차원을 지원하는 아형 생성 &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (아래 참조).</target>
        </trans-unit>
        <trans-unit id="36e4edbd82274075aaa50a1a6642d0776aa14705" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MySimpleContainer&lt;/code&gt;, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</source>
          <target state="translated">들어 &lt;code&gt;MySimpleContainer&lt;/code&gt; 컴파일러가 최적화 된 기능을 생성 할 수 있도록 객체는 그 유형과 매개 변수에 의해 완전히 지정됩니다. 대부분의 경우이 정도면 충분할 것입니다.</target>
        </trans-unit>
        <trans-unit id="08c5ae2629f26fdb821a26a0f5b3306f51f209f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SymTridiagonal&lt;/code&gt; block matrices, the elements of &lt;code&gt;dv&lt;/code&gt; are symmetrized. The argument &lt;code&gt;ev&lt;/code&gt; is interpreted as the superdiagonal. Blocks from the subdiagonal are (materialized) transpose of the corresponding superdiagonal blocks.</source>
          <target state="translated">들면 &lt;code&gt;SymTridiagonal&lt;/code&gt; 블록 행렬의 요소 &lt;code&gt;dv&lt;/code&gt; 대칭된다. 인수 &lt;code&gt;ev&lt;/code&gt; 는 superdiagonal로 해석됩니다. subdiagonal 블록은 해당 superdiagonal 블록의 전치 (구체화)됩니다.</target>
        </trans-unit>
        <trans-unit id="066f4790c89fa96385b602165d512d492e66ecc6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string) or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="translated">들어 &lt;code&gt;wchar_t*&lt;/code&gt; 인수, 줄리아 유형은해야 &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; 합니다 (C 루틴이 NUL 종료 문자열을 기대 경우) &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; 이 없습니다. Julia의 UTF-8 문자열 데이터는 내부적으로 NUL로 끝나므로 복사하지 않고 NUL로 끝나는 데이터를 기대하는 C 함수에 전달할 수 있습니다 (그러나 &lt;code&gt;Cwstring&lt;/code&gt; 유형을 사용 하면 문자열 자체가 있으면 오류가 발생합니다) NUL 문자를 포함합니다).</target>
        </trans-unit>
        <trans-unit id="757bf33c899d624608fa2ee3a0b47130199f6860" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string), or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="translated">들어 &lt;code&gt;wchar_t*&lt;/code&gt; 인수, 줄리아 유형은해야 &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; 합니다 (C 루틴이 NUL 종료 문자열을 기대하는 경우), 또는 &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; 그렇지. Julia의 UTF-8 문자열 데이터는 내부적으로 NUL로 종료되므로 복사하지 않고 NUL로 종료되는 데이터를 예상하는 C 함수에 전달할 수 있습니다 (하지만 &lt;code&gt;Cwstring&lt;/code&gt; 유형을 사용 하면 문자열 자체가 NUL 문자 포함).</target>
        </trans-unit>
        <trans-unit id="b8d4350a3633a902604161c6b5b29254014e76bb" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;every&lt;/em&gt; binary operation like &lt;code&gt;^&lt;/code&gt;, there is a corresponding &quot;dot&quot; operation &lt;code&gt;.^&lt;/code&gt; that is &lt;em&gt;automatically&lt;/em&gt; defined to perform &lt;code&gt;^&lt;/code&gt; element-by-element on arrays. For example, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; is not defined, since there is no standard mathematical meaning to &quot;cubing&quot; a (non-square) array, but &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; is defined as computing the elementwise (or &quot;vectorized&quot;) result &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt;. Similarly for unary operators like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&amp;radic;&lt;/code&gt;, there is a corresponding &lt;code&gt;.&amp;radic;&lt;/code&gt; that applies the operator elementwise.</source>
          <target state="translated">내용 &lt;em&gt;마다&lt;/em&gt; 같은 이진 연산 &lt;code&gt;^&lt;/code&gt; , 대응하는 동작을 &quot;실&quot;이있다 &lt;code&gt;.^&lt;/code&gt; 되는 &lt;em&gt;자동&lt;/em&gt; 수행 정의 &lt;code&gt;^&lt;/code&gt; 원소 별 어레이에. 예를 들어, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; 이 &quot;큐빙의&quot;(비 사각형) 배열 표준 수학적 의미는 없지만, 이후 정의되지 &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; 연산으로 정의된다 요소 별 (또는 &quot;벡터화 된&quot;) 결과 &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt; . &lt;code&gt;!&lt;/code&gt; 와 같은 단항 연산자의 경우와 유사합니다 . 또는 &lt;code&gt;&amp;radic;&lt;/code&gt; , 연산자를 요소별로 적용 하는 해당 &lt;code&gt;.&amp;radic;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33b12b0497bd71670a617ce62626d84d142b3953" translate="yes" xml:space="preserve">
          <source>For Adjoint/Transpose-wrapped vectors, return the operator $q$-norm of &lt;code&gt;A&lt;/code&gt;, which is equivalent to the &lt;code&gt;p&lt;/code&gt;-norm with value &lt;code&gt;p = q/(q-1)&lt;/code&gt;. They coincide at &lt;code&gt;p = q = 2&lt;/code&gt;. Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the &lt;code&gt;p&lt;/code&gt; norm of &lt;code&gt;A&lt;/code&gt; as a vector.</source>
          <target state="translated">Adjoint / Transpose-wrapped 벡터의 경우 &lt;code&gt;A&lt;/code&gt; 의 $ q $ -norm 연산자를 반환합니다. 이 값은 &lt;code&gt;p = q/(q-1)&lt;/code&gt; 값을 가진 &lt;code&gt;p&lt;/code&gt; - norm과 같습니다 . &lt;code&gt;p = q = 2&lt;/code&gt; 에서 일치 합니다. 사용 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 컴퓨팅하는 &lt;code&gt;p&lt;/code&gt; 의 규범 &lt;code&gt;A&lt;/code&gt; 벡터로.</target>
        </trans-unit>
        <trans-unit id="7cce7fbd5f6d7a391c27939f48d9689b1cad7e94" translate="yes" xml:space="preserve">
          <source>For All</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="34ab36290f41b0fe509819193b0860af6e374811" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form</source>
          <target state="translated">&lt;code&gt;character(len=*)&lt;/code&gt; 유형의 가변 길이 문자열을 사용하는 Fortran 함수의 경우 문자열 길이가 &lt;em&gt;숨겨진 인수&lt;/em&gt; 로 제공됩니다 . 목록에서 이러한 인수의 유형과 위치는 컴파일러에 따라 &lt;code&gt;Csize_t&lt;/code&gt; , 컴파일러 공급 업체는 일반적으로 Csize_t 를 유형 으로 사용 하고 인수 목록 끝에 숨겨진 인수를 추가합니다. 이 동작은 일부 컴파일러 (GNU)에서 수정되지만 다른 컴파일러는 &lt;em&gt;선택적으로&lt;/em&gt; 문자 인수 (Intel, PGI) 바로 뒤에 숨겨진 인수를 배치 할 수 있습니다. 예를 들어, Fortran 서브 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc4c87ed1d5890c7a24dd4de829654130f87033e" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</source>
          <target state="translated">&lt;code&gt;character(len=*)&lt;/code&gt; 유형의 가변 길이 문자열을 사용하는 포트란 함수의 경우 문자열 길이는 &lt;em&gt;숨겨진 인수&lt;/em&gt; 로 제공됩니다 . 목록에서 이러한 인수의 유형과 위치는 컴파일러마다 다릅니다. 컴파일러 공급 업체는 기본적으로 &lt;code&gt;Csize_t&lt;/code&gt; 를 유형 으로 사용 하고 인수 목록 끝에 숨겨진 인수를 추가합니다. 이 동작은 일부 컴파일러 (GNU)에 대해 고정되어 있지만 다른 인수는 &lt;em&gt;선택적으로&lt;/em&gt; 문자 인수 (Intel, PGI) 바로 뒤에 숨겨진 인수를 배치 할 수 있습니다. 예를 들어, 형식의 포트란 서브 루틴</target>
        </trans-unit>
        <trans-unit id="d553b36129c90b85dcd46c9add276340b10d3409" translate="yes" xml:space="preserve">
          <source>For Loops and Comprehensions</source>
          <target state="translated">루프와 이해를 위해</target>
        </trans-unit>
        <trans-unit id="717c84af107ffef8e4706cbbe50e715cf976c386" translate="yes" xml:space="preserve">
          <source>For Windows users, Julia's shell mode does not expose windows shell commands. Hence, this will fail:</source>
          <target state="translated">Windows 사용자의 경우 Julia의 셸 모드는 Windows 셸 명령을 노출하지 않습니다. 따라서 이것은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="16f78eccb3fe706727ad782465619222ec9fd8a5" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;String&lt;/code&gt;, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an &lt;code&gt;a::Array&lt;/code&gt; of some other bitstype, you can do &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt;, but note that the result may be endian-dependent.</source>
          <target state="translated">A에 대한 &lt;code&gt;String&lt;/code&gt; 결과는 UTF-8 인코딩에 특정 참고 (다른 체크섬 다른 유니 인코딩에 의한 것이다). 다른 비트 유형 의 &lt;code&gt;a::Array&lt;/code&gt; 를 체크섬하려면 &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt; 수행 할 수 있지만 결과는 엔디안 종속적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbd68155fa3d6b046d9d04578affc99d85e662a" translate="yes" xml:space="preserve">
          <source>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;article&lt;/a&gt; on the subject as well as his &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;introduction&lt;/a&gt; to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</source>
          <target state="translated">부동 소수점 숫자를 표현하는 방법에 대한 간단하지만 자명 한 설명 은 주제에 대한 John D. Cook의 &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;기사&lt;/a&gt; 와이 표현이 동작에서 이상적인 실제 숫자 추상화와 어떻게 다른지에 따라 발생하는 일부 문제에 대한 &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;소개&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d026061b818471461b6e11cb1c3175bde48284" translate="yes" xml:space="preserve">
          <source>For a complete example, let's say you have created a type, &lt;code&gt;ArrayAndChar&lt;/code&gt;, that stores an array and a single character:</source>
          <target state="translated">완전한 예를 들어, 배열과 단일 문자를 저장하는 &lt;code&gt;ArrayAndChar&lt;/code&gt; 유형을 작성했다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="125644f126fbc4277c5149f11a90f626bb48ac54" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;em&gt;every&lt;/em&gt; Julia operator's precedence, see the top of this file: &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt;&lt;code&gt;src/julia-parser.scm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; Julia 운영자의 우선 순위에 대한 전체 목록은 이 파일의 상단을 참조하십시오. &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt; &lt;code&gt;src/julia-parser.scm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f4d0c1cef2d73378f1ab6ea21dcd2e3aa81e9b0" translate="yes" xml:space="preserve">
          <source>For a given period, return the value associated with that period. For example, &lt;code&gt;value(Millisecond(10))&lt;/code&gt; returns 10 as an integer.</source>
          <target state="translated">주어진 기간 동안 해당 기간과 관련된 값을 반환합니다. 예를 들어 &lt;code&gt;value(Millisecond(10))&lt;/code&gt; 는 10을 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1ded20e8e0575e0300cc2adc5a53b33da3694f1" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="translated">이러한 모든 통화가 현명하게 작동하도록하는보다 일반적인 방법은 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;변환 및 승격을&lt;/a&gt; 참조하십시오 . 서스펜스를 망칠 위험이 있으므로 여기서는 일반적인 &lt;code&gt;Point&lt;/code&gt; 생성자 에 대한 모든 호출 이 예상대로 작동 하도록하기 위해 다음과 같은 외부 메서드 정의 만 있으면된다는 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88ab5fbb77be1d46e4a2df54b426186afb121ac6" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="translated">이러한 모든 통화를 현명하게 작동시키는보다 일반적인 방법은 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;전환 및 프로모션을&lt;/a&gt; 참조하십시오 . 서스펜스를 망칠 위험이 있으므로 여기서는 일반적인 &lt;code&gt;Point&lt;/code&gt; 생성자 에 대한 모든 호출을 예상대로 수행 하기 위해 다음과 같은 외부 메소드 정의 만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ed852a3125d50800bb13a676272e7f42d0c371f3" translate="yes" xml:space="preserve">
          <source>For a more specific example, a generic square-matrix multiply pseudo-code might look like:</source>
          <target state="translated">보다 구체적인 예를 들어, 일반적인 제곱 행렬 곱셈 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b96550022e1c9fcddbfb08ee86d23ebf98de982" translate="yes" xml:space="preserve">
          <source>For a scalar input, &lt;code&gt;eigvals&lt;/code&gt; will return a scalar.</source>
          <target state="translated">스칼라 입력의 경우 &lt;code&gt;eigvals&lt;/code&gt; 는 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e10df5562967eabafd887233bdf313820cd17e4" translate="yes" xml:space="preserve">
          <source>For addition details see the LibGit2 guide on &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;authenticating against a server&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;서버 인증에 대한&lt;/a&gt; LibGit2 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f08193acb8e4821221019bdf43b59fe564f1010" translate="yes" xml:space="preserve">
          <source>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; and &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt;.</source>
          <target state="translated">추가 (알고리즘) 정보 및 인수 확인을 포기하는 이러한 메소드의 버전에 대해서는 unexported_noalias_permute &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; 그리고 &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42ec6c27994a098a5b5c8be91c0dfca1418b0092" translate="yes" xml:space="preserve">
          <source>For additional documentation and an expert driver, see &lt;code&gt;SparseArrays.sparse!&lt;/code&gt;.</source>
          <target state="translated">추가 설명서 및 전문가 드라이버는 &lt;code&gt;SparseArrays.sparse!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="2966c479e2a97d05120d634abb3c3b4fa57bcb14" translate="yes" xml:space="preserve">
          <source>For all practical purposes, such objects behave identically to those of &lt;code&gt;MyStillAmbiguousType&lt;/code&gt;.</source>
          <target state="translated">모든 실제적인 목적으로 이러한 객체는 &lt;code&gt;MyStillAmbiguousType&lt;/code&gt; 의 객체와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="2586b120b44665025a1f73d79469ce79bd89f3e9" translate="yes" xml:space="preserve">
          <source>For allowed arguments, see &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">허용되는 인수는 &lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1cb1d8b0a6fd3f459dd21aee4330db5fb020cbc" translate="yes" xml:space="preserve">
          <source>For an M-by-N matrix &lt;code&gt;A&lt;/code&gt; and P-by-N matrix &lt;code&gt;B&lt;/code&gt;,</source>
          <target state="translated">MxN 행렬 &lt;code&gt;A&lt;/code&gt; 및 PxN 행렬 &lt;code&gt;B&lt;/code&gt; 의 경우</target>
        </trans-unit>
        <trans-unit id="c4a55d03c0f3c7fb4fb277a66cb30932f6ca5fde" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the maximum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">배열 입력의 경우 주어진 차원에 대한 최대 요소의 인덱스를 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f86a7fc66f2b2ba3bac55fe34c24f68f4fabc8c5" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the minimum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">배열 입력의 경우 지정된 차원에서 최소 요소의 인덱스를 반환하십시오. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="29ced7bd7c80c9a4577211e81fdcb7b16c085cf0" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the maximum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">배열 입력의 경우 지정된 차원에 대한 최대 값과 색인을 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="049c1d61ced18d9f201600808d1def1f22e2bc2b" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the minimum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">배열 입력의 경우 지정된 차원에서 최소값과 인덱스를 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="af04ee9a31664b38b875e97d7dedcb572df90336" translate="yes" xml:space="preserve">
          <source>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg's paper &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 숫자와 함께 계산할 때 발생하는 수치 정확도 문제에 대한 심도 있고 깊이있는 토론은 David Goldberg의 논문 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;모든 컴퓨터 과학자가 부동 소수점 산술에 대해 알아야 할 내용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b2edf4da8334ec709f88df3d9c11c7bf6cf6a32" translate="yes" xml:space="preserve">
          <source>For an in-place version and algorithmic information, see &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 버전 및 알고리즘 정보는 &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="231340498dbc5d7093c855f539374b7859ea6f87" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</source>
          <target state="translated">키와 값 (예 : 배열 및 사전)이있는 반복자 또는 컬렉션의 경우 키 위에 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">키와 값이있는 반복자 또는 컬렉션의 경우 값 위에 반복자를 반환합니다. 일반 반복자의 요소는 일반적으로 &quot;값&quot;으로 간주되므로이 함수는 기본적으로 인수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f5a23131be87d6b23ab4381b2afccc7a7294e103" translate="yes" xml:space="preserve">
          <source>For an ordered container &lt;code&gt;collection&lt;/code&gt;, add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of it.</source>
          <target state="translated">정렬 된 컨테이너 &lt;code&gt;collection&lt;/code&gt; 의 경우 &lt;code&gt;collection2&lt;/code&gt; 의 요소를 끝에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">외부 버전은 &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 알고리즘 정보는 &lt;code&gt;fkeep!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 와 같은 기능 이 필요하고 유용한 이유에 대한 개요 는 주제에 대한 John D. Cook의 탁월한 블로그 게시물 쌍인 &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt; 및 &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot를 참조하십시오.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">반복 가능한 컨테이너 &lt;code&gt;A&lt;/code&gt; (모든 차원의 배열 포함)의 숫자 (또는 &lt;code&gt;norm&lt;/code&gt; 이 정의 된 요소 유형 )의 경우, &lt;code&gt;A&lt;/code&gt; 가 해당 길이의 벡터 인 것처럼 &lt;code&gt;p&lt;/code&gt; -norm (기본값은 &lt;code&gt;p=2&lt;/code&gt; ) 을 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">반복 가능한 컨테이너 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; (모든 차원의 배열 포함)의 숫자 (또는 &lt;code&gt;dot&lt;/code&gt; 정의 된 모든 요소 유형 )의 경우 내적 (또는 내적 또는 스칼라 곱), 즉 &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; , 마치 벡터 인 것처럼.</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">지정되지 않은 키워드의 경우 &lt;code&gt;cmd&lt;/code&gt; 의 현재 설정 이 사용됩니다. 일반적으로 &lt;code&gt;Cmd&lt;/code&gt; 객체를 처음에 만들려면 백틱을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">일반적인 색인 (1부터 시작) 또는 다차원 배열을 갖는 배열의 경우 선형 인덱스의 범위는 1에서 &lt;code&gt;length(A)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;AbstractVector&lt;/code&gt; 의 선형 인덱스는 &lt;code&gt;axes(A, 1)&lt;/code&gt; 이므로 비 전통적인 색인이있는 벡터의 경우 1부터 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">배열의 경우 크기 및 유형 정보의 문자열 (예 : &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">배열의 경우이 함수에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">비트 유형의 경우 이는 한 번 설정된 값의 비트 패턴이 변경되지 않으며 해당 값은 비트 유형의 ID라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데카르트를 선형 인덱스로 변환하려면 &lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">&lt;code&gt;\u80&lt;/code&gt; 보다 작은 코드 포인트의 경우, 각 코드 포인트의 UTF-8 인코딩은 해당 &lt;code&gt;\x&lt;/code&gt; 이스케이프에 의해 생성 된 단일 바이트 이므로 구별을 안전하게 무시할 수 있습니다. 내용은 탈출 &lt;code&gt;\x80&lt;/code&gt; 을 통해 &lt;code&gt;\xff&lt;/code&gt; 에 비해 &lt;code&gt;\u80&lt;/code&gt; 을 통해 &lt;code&gt;\uff&lt;/code&gt; 그러나 중요한 차이가 있습니다 : 전 탈출 모든 인코딩 단일 바이트 - 매우 구체적인 계속 이어 않는 바이트 - 유효한 UTF-8 형성하지 않습니다 후자 이스케이프는 모두 2 바이트 인코딩의 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">복합 유형의 경우 이는 해당 필드 값의 ID가 변경되지 않음을 의미합니다. 필드가 비트 유형 인 경우 값이 배열과 같이 변경 가능한 유형 인 필드의 경우 비트가 절대 변경되지 않음을 의미합니다. 즉, 변경 가능한 값의 내용 자체가 수정 될 수 있지만 필드는 항상 동일한 변경 가능한 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">Julia에서 일관성을 유지하려면 호출 사이트는 항상 &lt;em&gt;type을&lt;/em&gt; 사용하는 대신 &lt;code&gt;Val&lt;/code&gt; &lt;em&gt;인스턴스를&lt;/em&gt; 전달해야 &lt;em&gt;합니다&lt;/em&gt; . 즉, &lt;code&gt;foo(Val{:bar})&lt;/code&gt; 대신 &lt;code&gt;foo(Val(:bar))&lt;/code&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형이 될 수 있습니다. &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="f72febf4d9dbc862197cbb1a8b226080ce81a9b0" translate="yes" xml:space="preserve">
          <source>For custom matrix and vector types, it is recommended to implement 5-argument &lt;code&gt;mul!&lt;/code&gt; rather than implementing 3-argument &lt;code&gt;mul!&lt;/code&gt; directly if possible.</source>
          <target state="translated">사용자 지정 행렬 및 벡터 유형의 경우 5-argument &lt;code&gt;mul!&lt;/code&gt; 3-argument &lt;code&gt;mul!&lt;/code&gt; 가능하면 직접.</target>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">직접적인 C ++ 인터페이스에 대해서는 &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; 패키지를 참조하십시오 . C ++ 바인딩을 작성하는 도구는 &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; 패키지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 쌍의 경우 &lt;code&gt;old=&amp;gt;new&lt;/code&gt; 에 &lt;code&gt;old_new&lt;/code&gt; , 모든 항목 교체 &lt;code&gt;old&lt;/code&gt; 수집에 &lt;code&gt;A&lt;/code&gt; 하여 &lt;code&gt;new&lt;/code&gt; . 평등은 &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; 을&lt;/a&gt; 사용하여 결정됩니다 . 경우 &lt;code&gt;count&lt;/code&gt; 지정하면 대부분에서 대체 &lt;code&gt;count&lt;/code&gt; 총 발생. &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">이해를 돕기 위해이 장의 예제는 근, 그래프 및 경로에 대한 전체 데이터 구조를 보여줍니다. 그러나 Julia의 패키지 로딩 코드는이를 명시 적으로 생성하지 않습니다. 대신, 주어진 패키지를로드하는 데 필요한만큼의 각 구조 만 느리게 계산합니다.</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">빈 컬렉션을 위해 제공 &lt;code&gt;init&lt;/code&gt; 특별한 경우를 제외하고, 필요하다 (예를 들면 때 &lt;code&gt;op&lt;/code&gt; 중 하나입니다 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) 줄리아의 중립 요소를 확인할 수 있습니다 때 &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">더욱 광범위의 역사 문서에 대한 근거 및 문제 부동 소수점 숫자뿐만 아니라, 수치 계산의 많은 다른 주제의 토론 내용은 참조 &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;수집 된 글&lt;/a&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;윌리엄 카한을&lt;/a&gt; 일반적으로 부동의 &quot;아버지로 알려진, 포인트&quot;. 특히 흥미로운 &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;것은 부동 소수점 노인과의 인터뷰입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">작업자와 들어오는 모든 논리적 연결에 대해 &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; 를 호출해야합니다. 그러면 &lt;code&gt;IO&lt;/code&gt; 객체로 표시되는 작업자와의 메시지 읽기 및 쓰기를 처리하는 새 작업이 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">모든 노동자가 출시를 들어, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 추가해야합니다 방법 &lt;code&gt;WorkerConfig&lt;/code&gt; 의 에 객체를 (해당 필드로 초기화) &lt;code&gt;launched&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">예를 들어 위의 &lt;code&gt;findfirst&lt;/code&gt; 예제 를 수정 하려면 각 스레드마다 별도의 &lt;code&gt;rx&lt;/code&gt; 변수 사본이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">예를 들어 다음 docstring에서 변수 &lt;code&gt;a&lt;/code&gt; 가 정의되고 Julia REPL에 인쇄 된 예상 결과가 나중에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">예를 들어, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; 는 &lt;code&gt;Sys.iswindows()&lt;/code&gt; 를 평가 하고 &lt;code&gt;foo&lt;/code&gt; 또는 &lt;code&gt;bar&lt;/code&gt; 를 표현식에 삽입합니다 . 존재하지 않는 함수에 대한 &lt;code&gt;ccall&lt;/code&gt; 과 같은 다른 플랫폼에서 구문이 유효하지 않은 경우에 유용 합니다. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; 및 &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; 도 유효한 구문 인 경우 @static .</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 은 &lt;code&gt;pid&lt;/code&gt; 에서 크기가 &lt;code&gt;Int&lt;/code&gt; 이고 크기가 10 인 채널에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 은 &lt;code&gt;Int&lt;/code&gt; 유형 및 크기 10의 채널에 대한 참조를 반환합니다 .이 채널은 작업자 &lt;code&gt;pid&lt;/code&gt; 에 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">예를 들어, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; 는 범위를 변경할 수없고 2 차원을 지원하지 않기 때문에 초기화되지 않은 &lt;code&gt;Array{Int,2}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Beowulf 클러스터는 &lt;code&gt;ClusterManagers.jl&lt;/code&gt; 패키지에 구현 된 사용자 정의 클러스터 관리자를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">예를 들어 NFKC는 &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; 옵션에 해당 합니다 .</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">예를 들어, 줄리아와 리눅스 설치를 실행에 위치 &lt;code&gt;/bin/julia&lt;/code&gt; 하는 &lt;code&gt;DATAROOTDIR&lt;/code&gt; 의 &lt;code&gt;../share&lt;/code&gt; 및 &lt;code&gt;SYSCONFDIR&lt;/code&gt; 의 &lt;code&gt;../etc&lt;/code&gt; 는 것 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 의 에 설정을 &lt;code&gt;/bin&lt;/code&gt; 의 소스 파일 검색 경로</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">예를 들어, 재귀 요인 루틴은 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">예를 들어, 선을 &lt;code&gt;plot&lt;/code&gt; 함수 그림 을 생각해보십시오 . 이 기능에는 선 스타일, 너비, 색상 등을 제어하기위한 많은 옵션이있을 수 있습니다. 키워드 인수를 허용하는 경우 가능한 호출은 &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; 와 같을 수 있으며 여기서 선 너비 만 지정하도록 선택했습니다. 이것은 두 가지 목적으로 사용됩니다. 우리는 인자를 의미로 라벨링 할 수 있기 때문에 호출이 더 읽기 쉽다. 또한 많은 수의 인수 중 일부를 순서에 상관없이 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">예를 들어, 인수와 함께 1을 더한 함수 &lt;code&gt;addone&lt;/code&gt; 의 다음 정의를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">예를 들어, 열린 파일이 닫히도록 보장하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4559e10e5bdf85aaaa91ac7c4619e47af5636653" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;x&lt;/code&gt; is an array and &lt;code&gt;v = @view x[1:10]&lt;/code&gt;, then &lt;code&gt;v&lt;/code&gt; acts like a 10-element array, but its data is actually accessing the first 10 elements of &lt;code&gt;x&lt;/code&gt;. Writing to a view, e.g. &lt;code&gt;v[3] = 2&lt;/code&gt;, writes directly to the underlying array &lt;code&gt;x&lt;/code&gt; (in this case modifying &lt;code&gt;x[3]&lt;/code&gt;).</source>
          <target state="translated">예를 들어, &lt;code&gt;x&lt;/code&gt; 가 배열이고 &lt;code&gt;v = @view x[1:10]&lt;/code&gt; 이면 &lt;code&gt;v&lt;/code&gt; 는 10 개 요소 배열처럼 작동하지만 데이터는 실제로 &lt;code&gt;x&lt;/code&gt; 의 처음 10 개 요소에 액세스합니다 . 뷰에 쓰기 (예 : &lt;code&gt;v[3] = 2&lt;/code&gt; )는 기본 배열 &lt;code&gt;x&lt;/code&gt; 에 직접 씁니다 (이 경우 &lt;code&gt;x[3]&lt;/code&gt; 수정 ).</target>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;MyImage&lt;/code&gt; 유형 을 정의하고 PNG 파일에 작성하는 방법을 알고 있다면 &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; 함수를 정의 할 수 있습니다. PNG 가능 &lt;code&gt;AbstractDisplay&lt;/code&gt; (예 : IJulia) 에 표시 할 이미지 평소와 같이 내장 Julia 함수 &lt;code&gt;show&lt;/code&gt; 에 새 메소드를 추가하려면 &lt;code&gt;import Base.show&lt;/code&gt; 를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">예를 들어 벡터를 합산의 정확한 표현과 함께 저장하는 유형을 정의한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">예를 들어, 첫 번째 숫자가 두 번째 숫자보다 크지 않다는 제약 조건에 따라 한 쌍의 실수를 보유하는 유형을 선언하려고한다고 가정하십시오. 다음과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">예를 들어, 새로운 함수 &lt;code&gt;foo(x)&lt;/code&gt; 가 예상대로 작동하는지 확인한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;sqrt&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 함수는 다음과 같이 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">예를 들어, &lt;code&gt;sqrt&lt;/code&gt; 함수는 음의 실수 값에 적용된 경우 &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">예를 들어, 다음 코드</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">예를 들어 다음 코드는 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">예를 들어 다음 정의는 범위 부정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">예를 들어, 다음 정규식에는 세 개의 플래그가 모두 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">예를 들어, 다음은 &lt;code&gt;for&lt;/code&gt; 루프가 더 많은 데이터를 기다리는 원인이 됩니다.</target>
        </trans-unit>
        <trans-unit id="eecf63c1cc24adb010e598c33c14402e51c960fb" translate="yes" xml:space="preserve">
          <source>For example, the tuple &lt;code&gt;(a=3.1, b=&quot;hello&quot;)&lt;/code&gt; has a type &lt;code&gt;NamedTuple{(:a, :b),Tuple{Float64,String}}&lt;/code&gt;, which can also be declared via &lt;code&gt;@NamedTuple&lt;/code&gt; as:</source>
          <target state="translated">예를 들어, 튜플 &lt;code&gt;(a=3.1, b=&quot;hello&quot;)&lt;/code&gt; 의 유형은 &lt;code&gt;NamedTuple{(:a, :b),Tuple{Float64,String}}&lt;/code&gt; 이며 &lt;code&gt;@NamedTuple&lt;/code&gt; 을 통해 다음 과 같이 선언 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">예를 들어 간단한 바이트 배열을 읽으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">예를 들어, 배열의 요소 유형을 디스패치하려고하면 종종 모호한 상황이 발생합니다. 대신 일반적으로 코드는 컨테이너 유형을 먼저 전달한 다음 eltype을 기반으로 한 더 구체적인 방법으로 재귀 적입니다. 대부분의 경우 알고리즘은 이러한 계층 적 접근 방식에 편리하게 적합하지만 다른 경우에는 이러한 엄격 성을 수동으로 해결해야합니다. 이 디스패치 브랜치는 예를 들어 두 매트릭스를 합산하는 로직에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 같은 길이의 두 벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; 또는 &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; 의해 탭으로 구분 된 텍스트의 두 열로 &lt;code&gt;f&lt;/code&gt; 에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">예를 들어, 명령에서 모든 출력을 &lt;code&gt;read(out, String)&lt;/code&gt; &lt;code&gt;wait(process)&lt;/code&gt; 아닌 read (out, String)을 호출 하십시오. 전자는 프로세스에 의해 작성된 모든 데이터를 적극적으로 소비하지만 후자는 리더의 연결을 기다리는 동안 커널 버퍼의 데이터.</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">예를 들어 다항식의 계수를 저장하지만 다항식을 평가하는 함수처럼 동작하는 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">예를 들어, &lt;code&gt;dlsym&lt;/code&gt; 을 통해 함수를 찾은 다음 해당 세션에 대한 공유 참조로 캐시 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">전문 드라이버 및 추가 정보는 &lt;code&gt;permute!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">파일 종속성의 경우 &lt;code&gt;include_dependency&lt;/code&gt; 에 의해 명시 적으로 추가되거나 &lt;code&gt;include&lt;/code&gt; 되어로드 되거나 로드 된 각 파일의 수정 시간 (mtime) 이 변경되지 않았 는지 또는 가장 근접한 초 단위로 잘린 수정 시간과 같은지 검사하여 변경 사항을 판별합니다 ( 초 미만의 정확도로 mtime 복사). 또한 고려 여부의 검색 로직에 의해 선택된 파일의 경로 &lt;code&gt;require&lt;/code&gt; 일치 프리 D 파일을 생성 한 경로를. 또한 실행중인 시스템과 프리 컴파일 캐시간에 비 호환성을 피하기 위해 현재 프로세스에 이미로드 된 종속성 세트를 고려하고 파일이 변경되거나 사라져도 해당 모듈을 다시 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">128 비트 미만의 고정 크기 정수 유형의 경우 &lt;code&gt;widen&lt;/code&gt; 하면 비트 수가 두 배인 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ff71b16e3ea299f0633e174809e0487289b907" translate="yes" xml:space="preserve">
          <source>For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">재미를 위해 &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 줄을 &lt;code&gt;mycompare&lt;/code&gt; 에 삽입 하면 &lt;code&gt;qsort&lt;/code&gt; 가 수행 하는 비교를 볼 수 있고 전달한 Julia 함수를 실제로 호출하는지 확인할 수 있습니다. 그것에).</target>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">함수의 &lt;code&gt;f(x)&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; 새로운 함수를 정의 정수 &lt;code&gt;f&lt;/code&gt; 하거나하는 새로운 방법이 추가 &lt;code&gt;f&lt;/code&gt; 경우 &lt;code&gt;f&lt;/code&gt; 는 이미 정의되고; 이 사용법은 &lt;code&gt;function f(x); x; end&lt;/code&gt; 와 같습니다 . 엑스; 끝 .</target>
        </trans-unit>
        <trans-unit id="225c4a50cda420749e1622d47819d81476ffb811" translate="yes" xml:space="preserve">
          <source>For functions that do not need to return a value (functions used only for some side effects), the Julia convention is to return the value &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">값을 반환 할 필요가없는 함수 (일부 부작용에만 사용되는 함수)의 경우 Julia 규칙은 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 값을 반환하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw add&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw and&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw max&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw min&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw nand&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw or&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw sub&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw xchg&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw xor&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;cmpxchg&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;fence&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25a5b4ba8ce7a92e22ffc818fd949e445709bd1e" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">이러한 비유 한 부동 소수점 값이 서로 및 다른 부동 소수점에 대해 정렬되는 방법에 대한 자세한 내용은 &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;숫자 비교를&lt;/a&gt; 참조하십시오 . 에 의해 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 이 부동 소수점 값은 어떤 연산의 결과이다 :</target>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">이러한 비유동 부동 소수점 값이 서로 다른 부동 소수점에 대해 어떻게 정렬되는지에 대한 자세한 내용은 &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;숫자 비교를&lt;/a&gt; 참조하십시오 . 에 의해 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 이 부동 소수점 값은 어떤 연산의 결과이다 :</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 비대칭 행렬의 경우 고유 값 계산 전에 행렬의 균형을 조정하는 방법을 지정할 수 있습니다. &lt;code&gt;permute&lt;/code&gt; , &lt;code&gt;scale&lt;/code&gt; 및 &lt;code&gt;sortby&lt;/code&gt; 의 키워드와 동일 &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">일반적인 비대칭 행렬의 경우 고유 벡터 계산 전에 행렬의 균형을 조정하는 방법을 지정할 수 있습니다. &lt;code&gt;permute=true&lt;/code&gt; 옵션 은 행렬을 상 삼각형에 가깝게 치환하고, &lt;code&gt;scale=true&lt;/code&gt; 는 행렬을 대각선 요소로 스케일링하여 행과 열을보다 평등하게 만듭니다. 두 옵션 모두 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">일반적인 정방 행렬의 경우 &lt;code&gt;A = A*B&lt;/code&gt; 는 임시 저장없이 구현할 수 없습니다. &lt;code&gt;A[1,1]&lt;/code&gt; 은 오른쪽에서 사용하기 전에 왼쪽에서 계산되고 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">글로벌 변수의 경우 바인딩 만이 데이터가 아닌 클로저에서 캡처됩니다. &lt;code&gt;let&lt;/code&gt; 블록은 글로벌 데이터를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">덧셈과 같은 기본 연산을 구현하기 위해 &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 원하는 출력 유형을 계산합니다. (이전과 같이, 우리는 &lt;code&gt;+&lt;/code&gt; 에 대한 호출에서 &lt;code&gt;promote&lt;/code&gt; 호출 에서 작동하는 것을 보았습니다 ).</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">예를 들어, AVX 내장 함수를 사용하는이 C 루틴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">최소 제곱의 의미로 조밀하고 조건이 잘못된 행렬을 반전 &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; 가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="034287249fc47e9292b9e290930968170dd861cb" translate="yes" xml:space="preserve">
          <source>For long docstrings, consider splitting the documentation with an &lt;code&gt;# Extended help&lt;/code&gt; header. The typical help-mode will show only the material above the header; you can access the full help by adding a '?' at the beginning of the expression (i.e., &quot;??foo&quot; rather than &quot;?foo&quot;).</source>
          <target state="translated">긴 독 스트링의 경우 &lt;code&gt;# Extended help&lt;/code&gt; 헤더를 사용 하여 문서를 분할하는 것을 고려하십시오 . 일반적인 도움말 모드는 헤더 위의 자료 만 표시합니다. '?'를 추가하여 전체 도움말에 액세스 할 수 있습니다. 식의 시작 부분 (즉, &quot;? foo&quot;가 아닌 &quot;?? foo&quot;).</target>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">많은 문제의 경우 작업에 대해 직접 생각할 필요가 없습니다. 그러나 동시에 여러 이벤트를 기다리는 데 사용할 수 있으므로 &lt;em&gt;동적 스케줄링이 가능&lt;/em&gt; 합니다. 동적 스케줄링에서 프로그램은 다른 작업이 완료되는 시점에 따라 계산 대상 또는 계산 위치를 결정합니다. 예측 불가능하거나 불균형 한 워크로드에 필요합니다. 여기서 현재 작업이 완료된 경우에만 프로세스에 더 많은 작업을 할당하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">많은 유형의 경우 필드 값을 함께 바인딩하여 새 객체를 만드는 것이 인스턴스를 만드는 데 필요한 모든 것입니다. 그러나 경우에 따라 복합 객체를 만들 때 더 많은 기능이 필요합니다. 때때로 불변은 인수를 확인하거나 변환하여 시행해야합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;재귀 적 데이터 구조&lt;/a&gt; , 특히 자기 참조 적 구조 는 불완전한 상태에서 먼저 생성 된 후 완전히 생성되지 않은 상태에서 객체를 생성하는 별도의 단계로 프로그래밍 방식으로 변경하지 않는 경우가 많습니다. 때로는 필드보다 적은 수 또는 다른 유형의 매개 변수로 객체를 구성하는 것이 편리 할 때가 있습니다. Julia의 객체 구성 시스템은 이러한 모든 경우와 그 이상을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 요소가있는 행렬 &lt;code&gt;M&lt;/code&gt; 의 경우 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 보다 큰 특이 값 만 반전하여 의사 역수 를 계산하는 것이 편리합니다. 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 가장 큰 특이 값입니다 .</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">행렬에 대한 더 복잡한 함수의 경우 더 복잡한 연산 순서에 대한 예상 반환 유형을 계산해야 할 수도 있습니다. 이것은 종종 다음 단계에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">콜백을 C 라이브러리에 전달하는 방법에 대한 자세한 내용은이 &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;블로그 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40c80b687e747654f0a96421e3edca10bc4facd7" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">코드 로딩에 대한 자세한 내용은 &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;모듈&lt;/a&gt; 및 &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;병렬 컴퓨팅&lt;/a&gt; 에 대한 매뉴얼 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">코드 로딩에 대한 자세한 내용은 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;모듈&lt;/a&gt; 및 &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;병렬 컴퓨팅&lt;/a&gt; 에 대한 매뉴얼 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b74d22bb6d8c3dae54e22351d507e76018a8637" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">스타일 규칙에 대한 자세한 정보는 &lt;a href=&quot;../style-guide/index#Style-Guide&quot;&gt;스타일 안내서를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">스타일 규칙에 대한 자세한 정보는 &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;스타일 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM 언어 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt; , &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt; , &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt; , &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1043bbca3d9cff9872a90536395e252c63759842" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;sup&gt;&lt;a href=&quot;#footnote-issue8859&quot; id=&quot;citeref-issue8859&quot;&gt;[issue8859]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-B96&quot; id=&quot;citeref-B96&quot;&gt;[B96]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-S84&quot; id=&quot;citeref-S84&quot;&gt;[S84]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-KY88&quot; id=&quot;citeref-KY88&quot;&gt;[KY88]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">자세한 내용은 &lt;sup&gt;&lt;a href=&quot;#footnote-issue8859&quot; id=&quot;citeref-issue8859&quot;&gt;[issue8859]&lt;/a&gt;&lt;/sup&gt; , &lt;sup&gt;&lt;a href=&quot;#footnote-B96&quot; id=&quot;citeref-B96&quot;&gt;[B96]&lt;/a&gt;&lt;/sup&gt; , &lt;sup&gt;&lt;a href=&quot;#footnote-S84&quot; id=&quot;citeref-S84&quot;&gt;[S84]&lt;/a&gt;&lt;/sup&gt; , &lt;sup&gt;&lt;a href=&quot;#footnote-KY88&quot; id=&quot;citeref-KY88&quot;&gt;[KY88]을 참조하세요&lt;/a&gt;&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">보다 심각한 벤치마킹 을 위해서는 무엇보다도 노이즈를 줄이기 위해 기능을 여러 번 평가하는 &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; 패키지를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fb3b51ac0a69c0826f2ccf53c628c34678a1b75" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;code&gt;@btime&lt;/code&gt; macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">보다 심각한 벤치마킹 을 위해 BenchmarkTools.jl 패키지 의 &lt;code&gt;@btime&lt;/code&gt; 매크로를 고려하십시오 .이 매크로는 특히 노이즈를 줄이기 위해 함수를 여러 번 평가합니다.</target>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">대부분의 사용자 정의 형식의 경우 프로그래머가 예상 형식을 생성자 함수에 명시 적으로 제공하도록 요구하는 것이 더 좋지만, 특히 숫자 문제의 경우 자동으로 승격하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">여러 콜렉션 인수의 경우 요소 단위로 &lt;code&gt;f&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">멀티 스레딩 및 병렬 컴퓨팅을 처음 사용하는 사람에게는 Julia가 제공하는 여러 수준의 병렬 처리를 먼저 이해하는 것이 유용 할 수 있습니다. 우리는 세 가지 주요 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">숫자가 아닌 값과 둘 이상의 인수에 대해 함수 &lt;code&gt;f&lt;/code&gt; 는 정의되지 않은 상태로 유지하며이를 적용하면 여전히 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c60cf4f6c963a7be1f2993b69f713f92f6b5f1c8" translate="yes" xml:space="preserve">
          <source>For number types, &lt;code&gt;adjoint&lt;/code&gt; returns the complex conjugate, and therefore it is equivalent to the identity function for real numbers.</source>
          <target state="translated">숫자 유형의 경우 &lt;code&gt;adjoint&lt;/code&gt; 는 켤레 복소수를 반환하므로 실수에 대한 항등 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">숫자의 경우 $ \ left (| x | ^ p \ right) ^ {1 / p} $를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 경우 $ \ left (| x | ^ p \ right) ^ {1 / p} $를 반환하십시오. 이것은 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">한 인수의 경우, 이것은 양의 &lt;em&gt;x&lt;/em&gt; 축과 점 (1, &lt;em&gt;y&lt;/em&gt; ) 사이의 라디안 각도이며 $ [-\ pi / 2, \ pi / 2] $ 간격의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 경우 &lt;code&gt;isequal&lt;/code&gt; 의 기본값은 &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 를 호출 하므로 고유 한 유형에 대해 동등성을 정의하려면 &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 메소드 만 추가하면됩니다 . 당신이 당신의 자신의 평등 함수를 정의하는 경우, 당신은 아마 해당 정의해야 &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; 을 보장하기 위하여 방법을 &lt;code&gt;isequal(x,y)&lt;/code&gt; 을 의미한다 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b291b40e0be0bd452d639b38ca79aedde9913f1" translate="yes" xml:space="preserve">
          <source>For outputting hours with 12-hour clock</source>
          <target state="translated">12 시간 제로 시간을 출력하는 경우</target>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">실수 또는 복잡한 부동 소수점 값의 경우, &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; 지정하지 않으면 &lt;code&gt;rtol&lt;/code&gt; 의 기본값 은 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 유형의 &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 의 제곱근 중 큰 값 (가장 작은 값)입니다. 이는 유효 숫자의 절반 정도의 동등성을 요구하는 것에 해당합니다. 그렇지 않으면, 예를 들어 정수 인수 또는 &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; 이 제공되면 &lt;code&gt;rtol&lt;/code&gt; 의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9a1f18a5fd677ec7a031d2172a281c2590c59640" translate="yes" xml:space="preserve">
          <source>For real vectors &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt;, the Kronecker product is related to the outer product by &lt;code&gt;kron(v,w) == vec(w * transpose(v))&lt;/code&gt; or &lt;code&gt;w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))&lt;/code&gt;. Note how the ordering of &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; differs on the left and right of these expressions (due to column-major storage). For complex vectors, the outer product &lt;code&gt;w * v'&lt;/code&gt; also differs by conjugation of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">실수 벡터 &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;w&lt;/code&gt; 의 경우 Kronecker 곱은 &lt;code&gt;kron(v,w) == vec(w * transpose(v))&lt;/code&gt; 또는 &lt;code&gt;w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))&lt;/code&gt; )에 의해 외적과 관련됩니다. ), (길이 (w), 길이 (v))) . &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;w&lt;/code&gt; 의 순서가 이러한 표현식의 왼쪽과 오른쪽에서 어떻게 다른지 확인하십시오 (열 주 저장으로 인해). 복소 벡터를 들어, 외적 &lt;code&gt;w * v'&lt;/code&gt; 또한 접합의 차이에 의해 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">길이가 길면 여기에 결과가 표시되지 않지만 직접 시도해 볼 수도 있습니다. 첫 번째 경우 형식이 완전히 지정되었으므로 컴파일러는 런타임에 형식을 확인하기 위해 코드를 생성 할 필요가 없습니다. 이로 인해 코드가 짧아지고 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">직사각형 들어 결과의 피봇 QR 인수 분해에 의해 계산 된 최소 표준 최소 제곱 솔루션 및 랭크 예측 는 R 팩터에 기초. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96f59651f15b7587bcada98bfc3f714cf7b14bc2" translate="yes" xml:space="preserve">
          <source>For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.</source>
          <target state="translated">비슷한 이유로 Julia 로의 자동 번역은 일반적으로 다른 언어의 기본 Julia 포트에 대한 좋은 시작점이되지 않는 읽을 수없고 느리고 비 관상적인 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">간단한 함수의 경우 함수의 목적을 설명 할 때 인수의 역할을 직접 언급하는 것이 더 분명합니다. 인수 목록은 다른 곳에 이미 제공된 정보 만 반복합니다. 그러나 인수 목록을 제공하는 것은 많은 인수 (특히 키워드 인수)가있는 복잡한 함수에 유용 할 수 있습니다. 그 경우에, 아래의 함수의 일반적인 설명 후에 삽입 &lt;code&gt;# Arguments&lt;/code&gt; 하나 헤더 &lt;code&gt;-&lt;/code&gt; 각각의 인자에 대한 탄환. 이 목록에는 인수의 유형과 기본값 (있는 경우)이 언급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">간단한 인덱스 유형의 경우, 익스포트되지 &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; 를 지연시켜 각 인덱스 &lt;code&gt;i&lt;/code&gt; 를 처리합니다 . 이 내부 함수를 직접 호출 할 수는 없지만 사용자 정의 색인 동작을 제공하기 위해 사용자 정의 배열 또는 색인 유형으로 &lt;code&gt;Base.to_index&lt;/code&gt; 를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 &lt;code&gt;x&lt;/code&gt; 값 이 가끔 존재하는 경우 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 유형은 함수 인수, 객체 필드 및 배열 요소 유형에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Option&lt;/code&gt; 또는 &lt;code&gt;Maybe&lt;/code&gt; 와 다른 언어 로 사용될 수 있습니다 . 값 자체가 &lt;code&gt;nothing&lt;/code&gt; 될 수 없는 경우 (특히 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Any&lt;/code&gt; 일 때 ) &lt;code&gt;x == nothing&lt;/code&gt; 이기 때문에 &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 유형이 더 적합 하며 &lt;code&gt;x == Some(nothing)&lt;/code&gt; 값의 존재를 나타내는 동일한 &lt;code&gt;nothing&lt;/code&gt; . &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;함수를 풀기 수 있습니다 &lt;code&gt;Some&lt;/code&gt; 개체를하고 대신 기본값을 사용하여 &lt;code&gt;nothing&lt;/code&gt; 인수. 컴파일러는 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 인수 또는 필드로 작업 할 때 효율적인 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">다른 값을 &quot;랩핑&quot;하는 일부 유형의 경우 생성자는 이미 요청 된 유형 인 경우에도 인수를 새 객체로 래핑 할 수 있습니다. 예를 들어 &lt;code&gt;Some(x)&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 가 래핑 되어 값이 있음을 나타냅니다 (결과가 &lt;code&gt;Some&lt;/code&gt; 또는 &lt;code&gt;nothing&lt;/code&gt; 일 수있는 컨텍스트에서 ). 그러나 &lt;code&gt;x&lt;/code&gt; 자체는 &lt;code&gt;Some(y)&lt;/code&gt; 객체 일 수 있으며, 이 경우 결과는 &lt;code&gt;Some(Some(y))&lt;/code&gt; 이며 두 가지 수준으로 줄 바꿈됩니다. 반면 &lt;code&gt;convert(Some, x)&lt;/code&gt; 는 이미 &lt;code&gt;Some&lt;/code&gt; 이므로 &lt;code&gt;x&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">일부 유형의 경우 중첩 된 수준의 브로드 캐스트에서 &quot;퓨즈&quot;작업을 수행하는 기계를 사용할 수 없거나 점진적으로 더 효율적으로 수행 할 수 있습니다. 이러한 경우 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; 으로 작성된 것처럼 x. * (x. + 1) 을 평가해야 할 수도 있습니다 . 여기서 내부 작업은 태클 전에 평가됩니다. 외부 작업. 이런 종류의 간절한 작업은 약간의 간접적 인 지원으로 직접 지원됩니다. Julia는 &lt;code&gt;Broadcasted&lt;/code&gt; 객체 를 직접 구성하는 대신 융합 식 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; 을 &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; 낮 춥니 다 . 이제 기본적으로 &lt;code&gt;broadcasted&lt;/code&gt; 는 &lt;code&gt;Broadcasted&lt;/code&gt; 캐스트 만 호출합니다. 융합 표현식 트리의 지연 표현을 작성하기위한 생성자이지만 함수와 인수의 특정 조합에 대해이를 겹쳐 쓰도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">사용자 정의 유형의 브로드 캐스트를 전문화하려면</target>
        </trans-unit>
        <trans-unit id="1b18cc26dc44ec9e519a2a7660046d4495db6e20" translate="yes" xml:space="preserve">
          <source>For specific exception types, &lt;code&gt;handler&lt;/code&gt; is required to accept additional arguments:</source>
          <target state="translated">특정 예외 유형의 경우 추가 인수를 허용하려면 &lt;code&gt;handler&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">문자열 인수 ( &lt;code&gt;char*&lt;/code&gt; )의 경우 Julia 유형은 &lt;code&gt;Cstring&lt;/code&gt; (NUL 종료 데이터가 예상되는 경우)이거나 &lt;code&gt;Ptr{Cchar}&lt;/code&gt; 또는 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 어야합니다. &lt;code&gt;String&lt;/code&gt; . 마찬가지로 배열 인수 ( &lt;code&gt;T[]&lt;/code&gt; 또는 &lt;code&gt;T*&lt;/code&gt; )의 경우 Julia 유형은 &lt;code&gt;Vector{T}&lt;/code&gt; 아니라 &lt;code&gt;Ptr{T}&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae9d821284a94b5ce78c69057ff544650721831" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected), or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">문자열 인수 ( &lt;code&gt;char*&lt;/code&gt; )의 경우 Julia 유형은 &lt;code&gt;Cstring&lt;/code&gt; (NUL 종료 데이터가 예상되는 경우)이거나 &lt;code&gt;Ptr{Cchar}&lt;/code&gt; 또는 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 그렇지 않은 경우 (이 두 포인터 유형은 동일한 효과를 가짐), &lt;code&gt;String&lt;/code&gt; 이 아닙니다 . 마찬가지로 배열 인수 ( &lt;code&gt;T[]&lt;/code&gt; 또는 &lt;code&gt;T*&lt;/code&gt; )의 경우 Julia 유형은 다시 &lt;code&gt;Vector{T}&lt;/code&gt; 아니라 &lt;code&gt;Ptr{T}&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">대칭 또는 은자 &lt;code&gt;A&lt;/code&gt; 의 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 사용되며, 그렇지 않으면 스케일링 및 제곱 알고리즘 ( &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt; 참조 )이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="9203451fb420c19124d347a28e5e21e46e2168a9" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;sup&gt;&lt;a href=&quot;#footnote-H05&quot; id=&quot;citeref-H05&quot;&gt;[H05]&lt;/a&gt;&lt;/sup&gt;) is chosen.</source>
          <target state="translated">대칭 또는 Hermitian &lt;code&gt;A&lt;/code&gt; 의 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 사용됩니다. 그렇지 않으면 스케일링 및 제곱 알고리즘 ( &lt;sup&gt;&lt;a href=&quot;#footnote-H05&quot; id=&quot;citeref-H05&quot;&gt;[H05]&lt;/a&gt;&lt;/sup&gt; 참조 )이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">텍스트 I / O의 경우 필요에 따라 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;show&lt;/code&gt; 방법을 사용하십시오 (두 방법의 차이점에 대한 자세한 내용은이 두 방법에 대한 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위에서 반복 가능한 &lt;code&gt;Squares&lt;/code&gt; 경우, 제곱 하여 시퀀스 의 &lt;code&gt;i&lt;/code&gt; 번째 요소를 쉽게 계산할 수 있습니다 . 이것을 인덱싱 표현식 &lt;code&gt;S[i]&lt;/code&gt; 로 노출시킬 수 있습니다 . 이 동작을 선택하려면 &lt;code&gt;Squares&lt;/code&gt; 에서&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 를 정의 하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">의 요일을 위해 &lt;code&gt;dt&lt;/code&gt; 에주의 그 날의 총 수를 반환 &lt;code&gt;dt&lt;/code&gt; 의 달. 4 또는 5를 리턴 합니다. adjuster 함수에 &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; 를 포함시켜 한 달의 마지막 요일을 지정하기위한 임시 표현식에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">의 요일에 대한 &lt;code&gt;dt&lt;/code&gt; 는에 번호, 반환 &lt;code&gt;dt&lt;/code&gt; 의 달. 따라서 &lt;code&gt;dt&lt;/code&gt; 의 요일 이 월요일이면 &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; 입니다. 1 : 5 범위입니다.</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">기본 생성자의 경우 각 필드마다 정확히 하나의 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 키워드 인수에 대해서는 &lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">같은 이유로 위에서 제시 한 논리 연산자와 달리 단락 부울 연산자 &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;||&lt;/code&gt; 피연산자의 값이 다음 피연산자의 평가 여부를 결정하는 상황에서 결 &lt;code&gt;missing&lt;/code&gt; 허용 하지 마십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">매우 일반적인 패턴 사용 패턴</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">이러한 이유로 대안을 고려하기 전에 내장 샘플링 프로파일 러를 사용해 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">C 인수 목록을 Julia로 변환하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">C 리턴 유형을 Julia로 변환하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">두 개의 인수의 경우, 이것은 양의 &lt;em&gt;x&lt;/em&gt; 축과 점 ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ) 사이의 라디안 각도이며 $ [-\ pi, \ pi] $ 간격의 값을 반환합니다. 이것은 표준 &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; 기능에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt; 기다리는 작업이 있으면 &lt;code&gt;true&lt;/code&gt; 반환 합니다 ! .</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt; 까지 차단합니다 ! 다른 작업으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt; 나올 때까지 차단합니다 ! 다른 작업으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a1f4f3e026d72a7731be56290972632b9296433b" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;code&gt;take!&lt;/code&gt; is performed by a different task.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;code&gt;take!&lt;/code&gt; 까지 차단합니다 ! 다른 작업에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">변수 및 식 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a = b&lt;/code&gt; 하게 &lt;code&gt;a&lt;/code&gt; 의 값을 참조 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">캡처 대신 문자열의 일치하지 않는 경우를 들어, &lt;code&gt;m.captures&lt;/code&gt; 는 포함되어 있지 않습니다 &lt;code&gt;nothing&lt;/code&gt; 그 위치에서, 그리고 &lt;code&gt;m.offsets&lt;/code&gt; 는 문자열 인에 제로 오프셋 있도록 줄리아의 인덱스는 1-를 기반으로하는 제로 오프셋 (리콜을 가지고 유효하지 않습니다). 다음은 다소 고안된 예입니다.</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">GC 실행 강제</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">메모리 매핑 된 &lt;code&gt;Array&lt;/code&gt; 또는 &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 의 메모리 내 버전 과 디스크 내 버전을 동기화 합니다.</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">포크와 나이프</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;tok&lt;/code&gt; 에서 토큰 &lt;code&gt;dt&lt;/code&gt; 하고에 기록 &lt;code&gt;io&lt;/code&gt; . 서식은 &lt;code&gt;locale&lt;/code&gt; 기반으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b95515ff3376dd3ae2f977e999ab2880dd7abaa5" translate="yes" xml:space="preserve">
          <source>Fortran Wrapper Example</source>
          <target state="translated">Fortran 래퍼 예</target>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">포트란 컴파일러는 &lt;em&gt;할 수있다&lt;/em&gt; (또한 포인터에 대한 다른 숨겨진 인수를 추가, 모양 가정 &lt;code&gt;:&lt;/code&gt; ) 및 가정 크기 ( &lt;code&gt;*&lt;/code&gt; ) 배열을. 이러한 동작은 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 을 사용 하고 서브 루틴 정의에 &lt;code&gt;bind(c)&lt;/code&gt; 를 포함 하여 피할 수 있으며 , 상호 운용 가능한 코드에 강력히 권장됩니다. 이 경우 일부 언어 기능을 사용하여 숨겨진 인수가 없습니다 (예 : &lt;code&gt;character(len=1)&lt;/code&gt; 만 문자열을 전달할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">포트란 이름</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">다행히도 많은 유용한 병렬 계산에는 데이터 이동이 필요하지 않습니다. 일반적인 예는 여러 프로세스가 독립적 인 시뮬레이션 시험을 동시에 처리 할 수있는 Monte Carlo 시뮬레이션입니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 을 사용 하여 두 프로세스에서 동전을 뒤집을 수 있습니다 . 먼저 &lt;code&gt;count_heads.jl&lt;/code&gt; 에 다음 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="c88633f59ce30b4843943132dd5c7b1eb583498a" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">다행히도 많은 유용한 병렬 계산에는 데이터 이동이 필요하지 않습니다. 일반적인 예는 여러 프로세스가 독립적 인 시뮬레이션 시도를 동시에 처리 할 수있는 Monte Carlo 시뮬레이션입니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 을 사용 하여 두 프로세스에서 동전을 뒤집을 수 있습니다 . 먼저 &lt;code&gt;count_heads.jl&lt;/code&gt; 에 다음 함수를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">한 문자 앞으로 삭제 (버퍼에 텍스트가있는 경우)</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">다음 단어를 앞으로 삭제</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">네 잎 클로버</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">4 개 공간</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">넷째 루트</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">분수 분자 하나</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">무료 및 오픈 소스 ( &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT 라이선스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">감자 튀김</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">새우 튀김</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">개구리 얼굴</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">호출자의 관점에서 이것은 일반 함수와 동일합니다. 사실, 정규 함수 또는 생성 된 함수를 호출하는지 여부를 알 필요가 없습니다. &lt;code&gt;foo&lt;/code&gt; 가 어떻게 동작 하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">이러한 정의에서 다음과 같은 동작을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">정면 아기 병아리</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">입을 벌리고 얼굴을 찡그림</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">연료 펌프</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">풀 블록</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">보름달 기호</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">얼굴 보름달</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">완전 외부 조인</target>
        </trans-unit>
        <trans-unit id="f1096aa4780f9ea80d71f2a7366569059e04d8fc" translate="yes" xml:space="preserve">
          <source>Full day of week name</source>
          <target state="translated">요일 이름</target>
        </trans-unit>
        <trans-unit id="91bc6576bb78484d08a918ba3eadfec40cb28a6b" translate="yes" xml:space="preserve">
          <source>Full month name according to the &lt;code&gt;locale&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;locale&lt;/code&gt; 키워드 에 따른 전체 월 이름</target>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">다음에 의해 완전히 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">함수 &lt;code&gt;abmult&lt;/code&gt; 는 인수 &lt;code&gt;r&lt;/code&gt; 에 절대 값 r 을 곱하는 함수 &lt;code&gt;f&lt;/code&gt; 를 반환합니다 . &lt;code&gt;f&lt;/code&gt; 에 지정된 내부 기능을 &quot;클로저&quot;라고합니다. 내부 함수는 언어에서 &lt;code&gt;do&lt;/code&gt; - blocks 및 생성기 표현에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="902d94a2b6ad89fe3137e81fa9679244c8f73579" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;exit_on_sigint&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="translated">&lt;code&gt;exit_on_sigint&lt;/code&gt; 함수 에는 최소한 Julia 1.5가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt; 시작하는 함수 본문</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">함수 체인 (때때로 &quot;파이핑&quot;또는 &quot;파이프를 사용하여&quot;을 사용하여 후속 함수로 데이터 전송)은 이전 함수의 출력에 함수를 적용 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="de91ebb3667f8cc24a066c6edb9a49fb5801d827" translate="yes" xml:space="preserve">
          <source>Function composition also works in prefix form: &lt;code&gt;∘(f, g)&lt;/code&gt; is the same as &lt;code&gt;f ∘ g&lt;/code&gt;. The prefix form supports composition of multiple functions: &lt;code&gt;∘(f, g, h) = f ∘ g ∘ h&lt;/code&gt; and splatting &lt;code&gt;∘(fs...)&lt;/code&gt; for composing an iterable collection of functions.</source>
          <target state="translated">함수 구성은 접두사 형식으로도 작동합니다 : &lt;code&gt;∘(f, g)&lt;/code&gt; 는 &lt;code&gt;f ∘ g&lt;/code&gt; 와 동일 합니다. 접두사 형식은 여러 함수의 구성을 지원합니다 : &lt;code&gt;∘(f, g, h) = f ∘ g ∘ h&lt;/code&gt; 및 반복 가능한 함수 모음을 구성하기위한 splatting &lt;code&gt;∘(fs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">기능 구성 및 배관</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">함수 구성은 함수를 함께 결합하고 결과 구성을 인수에 적용하는 것입니다. 함수 구성 연산자 ( &lt;code&gt;∘&lt;/code&gt; )를 사용하여 함수 를 구성하므로 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 는 &lt;code&gt;f(g(args...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2060410180dd6737f9e6d318390fd5317d7bae" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">함수 매개 변수를 사용하여 &quot;varargs&quot;함수 ( &lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt; )에 제공 할 수있는 인수의 수를 제한 할 수도 있습니다 . 이러한 제약을 나타 내기 위해 표기법 &lt;code&gt;Vararg{T,N}&lt;/code&gt; 이 사용됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">함수 매개 변수를 사용하여 &quot;varargs&quot;함수 ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; )에 제공 될 수있는 인수의 수를 제한 할 수도 있습니다 . &lt;code&gt;Vararg{T,N}&lt;/code&gt; 표기법 은 이러한 제한 조건을 나타내는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">기능은 원격 참조를 위해 &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs 및 &lt;code&gt;mirror&lt;/code&gt; 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">함수형 객체</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">base-64로 인코딩 된 문자열 및 IO를위한 기능.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">기능 및 방법</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt; 및 기타 함수 는 클러스터에서 프로세스를 추가, 제거 및 쿼리하는 프로그래밍 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">기능은 &lt;code&gt;any&lt;/code&gt; 및 &lt;code&gt;all&lt;/code&gt; 또한, 복귀 3 치 논리의 규칙을 따라야 &lt;code&gt;missing&lt;/code&gt; 결과를 확인할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">기능과 방법</target>
        </trans-unit>
        <trans-unit id="547df569a8b37a13ed96cad6ad095bccba6ee3ff" translate="yes" xml:space="preserve">
          <source>Functions and variables share the same namespace (&amp;ldquo;Lisp-1&amp;rdquo;).</source>
          <target state="translated">함수와 변수는 동일한 네임 스페이스 ( &quot;Lisp-1&quot;)를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">함수는 &lt;code&gt;function&lt;/code&gt; 키워드 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Julia의 함수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;일류 객체입니다&lt;/a&gt; . 변수에 할당 할 수 있으며, 지정된 변수에서 표준 함수 호출 구문을 사용하여 호출 할 수 있습니다. 인수로 사용될 수 있으며 값으로 리턴 될 수 있습니다. 다음 구문 중 하나를 사용하여 이름을 지정하지 않고 익명으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">Julia의 기능은 함께 구성하거나 파이핑 (체인)하여 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Julia의 함수에는 메소드라는 여러 구현이있을 수 있습니다. 일반 함수는 단일 목적을 갖는 것이 좋지만 Julia는 필요한 경우 메소드를 개별적으로 문서화 할 수 있습니다. 일반적으로 가장 일반적인 방법 또는 기능 자체 만 문서화해야합니다 (예 : &lt;code&gt;function bar end&lt;/code&gt; 메서드없이 생성 된 객체 ). 구체적인 방법은 일반적인 방법과 다른 경우에만 문서화해야합니다. 어쨌든 그들은 다른 곳에서 제공된 정보를 반복해서는 안됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0369fd43ccf1e9549a7a746fe6b93020919f4a10" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Julia 의 함수는 함수 정의에서 반환 할 변수 이름을 나열하는 대신 마지막 표현식 또는 &lt;code&gt;return&lt;/code&gt; 키워드에서 값을 반환합니다 (자세한 내용 &lt;a href=&quot;../functions/index#The-return-Keyword&quot;&gt;은 return 키워드&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Julia 의 함수는 함수 정의에 리턴 할 변수 이름을 나열하는 대신 마지막 표현식 또는 &lt;code&gt;return&lt;/code&gt; 키워드에서 값을 리턴합니다 (자세한 내용 &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;은 return 키워드&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Julia의 함수는 마지막 표현식 또는 &lt;code&gt;return&lt;/code&gt; 키워드 에서 값을 반환 합니다. 함수에서 여러 값을 반환하고 튜플로 할당 할 수 있습니다 &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; 예 : C / C ++에서와 같이 포인터를 값에 전달하는 대신 (a, b) = myfunction () 또는 &lt;code&gt;a, b = myfunction()&lt;/code&gt; 즉 &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">&lt;code&gt;strange_twos&lt;/code&gt; 와 같은 함수 는 불확실한 유형의 데이터 (예 : 정수, 부동 소수점, 문자열 또는 다른 것을 포함 할 수있는 입력 파일에서로드 된 데이터)를 처리 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">에 기능 &lt;code&gt;Expr&lt;/code&gt; essions</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">확률 분포와 관련된 함수는 &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;분포 패키지에&lt;/a&gt; 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="f329adf9adf1ecc64a0f0d4d6a3d48dd49e69578" translate="yes" xml:space="preserve">
          <source>Functions that do not propagate &lt;code&gt;missing&lt;/code&gt; values can be made to do so by wrapping them in the &lt;code&gt;passmissing&lt;/code&gt; function provided by the &lt;a href=&quot;https://github.com/JuliaData/Missings.jl&quot;&gt;Missings.jl&lt;/a&gt; package. For example, &lt;code&gt;f(x)&lt;/code&gt; becomes &lt;code&gt;passmissing(f)(x)&lt;/code&gt;.</source>
          <target state="translated">전파되지 않는 기능 &lt;code&gt;missing&lt;/code&gt; 값은에 그들을 배치하여 그렇게 할 수 &lt;code&gt;passmissing&lt;/code&gt; 에 의해 제공되는 기능 &lt;a href=&quot;https://github.com/JuliaData/Missings.jl&quot;&gt;Missings.jl의&lt;/a&gt; 패키지로 제공된다. 예를 들어, &lt;code&gt;f(x)&lt;/code&gt; 는 &lt;code&gt;passmissing(f)(x)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">인수에 쓰는 함수의 이름은 &lt;code&gt;!&lt;/code&gt; . 함수를 호출 한 후 값을 반환하는 것이 아니라 인수를 변경하기 위해 &quot;mutating&quot;또는 &quot;in-place&quot;함수라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">키워드 인수가있는 함수는 서명에 세미콜론을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="d740b078ded802ba0e2eac07618b79e4bfdcbb51" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;code&gt;a .+= b&lt;/code&gt; (또는 &lt;code&gt;@. a += b&lt;/code&gt; ) 와 같은 &quot;점선&quot;업데이트 연산자 &lt;code&gt;a .= a .+ b&lt;/code&gt; 로 구문 분석됩니다 . 여기서 &lt;code&gt;.=&lt;/code&gt; 는 통합 된 &lt;em&gt;내부&lt;/em&gt; 할당 작업입니다 ( &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;점 구문 문서&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;code&gt;a .+= b&lt;/code&gt; (또는 &lt;code&gt;@. a += b&lt;/code&gt; ) 와 같은 &quot;점&quot;업데이트 연산자는 a. = a. + b 로 구문 분석됩니다 &lt;code&gt;a .= a .+ b&lt;/code&gt; 여기서 &lt;code&gt;.=&lt;/code&gt; 는 통합 된 &lt;em&gt;내부&lt;/em&gt; 할당 조작입니다 ( &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;점 구문 문서&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">또한 함수 호출로 스플릿 된 반복 가능한 객체는 튜플 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart, &quot;순위 변성&quot;, 과학 통계 통계에 관한 SIAM 저널, 5 (2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;도 : 10.1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">게임 다이</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">쓰레기 수거 안전</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">첫 번째 인수에 '$'로 주석을 달 때 &lt;code&gt;@cfunction&lt;/code&gt; 의 리턴 값에 대한 가비지 콜렉션 핸들 . 모든처럼 &lt;code&gt;cfunction&lt;/code&gt; 의 핸들, 그것을 전달해야 &lt;code&gt;ccall&lt;/code&gt; A와 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , 적절한 유형으로 호출 사이트에서 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">보석 스톤</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">일반 컬렉션</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">일반 I / O</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">일반 숫자 함수 및 상수</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">전통적인 C 및 유니 코드 이스케이프 시퀀스의 일반적인 탈출. 첫 번째 형식은 이스케이프 된 문자열을 반환하고 두 번째 형식은 결과를 &lt;code&gt;io&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">다음과 같은 기능을 사용하여 일반적인 예외를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">비 정사각형</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">일반 광장</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">전통적인 C 및 유니 코드 이스케이프 시퀀스의 일반적인 탈출. 첫 번째 형식은 이스케이프 된 문자열을 반환하고 두 번째 형식은 결과를 &lt;code&gt;io&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d4a5e7b244f7677a49086fc90992db4311d8da" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;. The argument &lt;code&gt;keep&lt;/code&gt; specifies a collection of characters which (along with backlashes) are to be kept as they are.</source>
          <target state="translated">전통적인 C 및 유니 코드 이스케이프 시퀀스의 일반적인 이스케이프 해제. 첫 번째 형식은 이스케이프 된 문자열을 반환하고 두 번째 형식은 결과를 &lt;code&gt;io&lt;/code&gt; 에 인쇄합니다 . &lt;code&gt;keep&lt;/code&gt; 인수 는 (백래시와 함께) 그대로 유지 될 문자 모음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">일반화 된 SVD</target>
        </trans-unit>
        <trans-unit id="57f4b7233f83ddd1853b6b2d05e4bb762f7fd0b4" translate="yes" xml:space="preserve">
          <source>Generalized Schur decomposition</source>
          <target state="translated">일반화 된 Schur 분해</target>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">일반화 된 선형 모델은 &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM 패키지에&lt;/a&gt; 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="74e66c6cbf540d5ae8fbca755495f0306efa1594" translate="yes" xml:space="preserve">
          <source>Generalized spectral decomposition</source>
          <target state="translated">일반화 된 스펙트럼 분해</target>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">일반적으로 새 유형은 이 함수 대신 &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt; 를 구현 하고 대체 정의 &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">임의의 부울 값으로 구성된 &lt;code&gt;BitArray&lt;/code&gt; 를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">주어진 유형 서명에 대해 &lt;code&gt;callable&lt;/code&gt; Julia 함수에서 C 호출 가능 함수 포인터를 생성하십시오 . 리턴 값을 &lt;code&gt;ccall&lt;/code&gt; 에 전달하려면 서명에서 인수 유형 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="464b58935d4b4855a4eca20151ebbc5055b2f194" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution of variance 1 (corresponding to real and imaginary part having independent normal distribution with mean zero and variance &lt;code&gt;1/2&lt;/code&gt;).</source>
          <target state="translated">평균이 0이고 표준 편차가 1 인 &lt;code&gt;T&lt;/code&gt; 유형 의 정규 분포 난수를 생성합니다. 선택적으로 정규 분포 난수 배열을 생성합니다. &lt;code&gt;Base&lt;/code&gt; 모듈은 현재 유형의 구현을 제공 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (기본값)과 &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 대응을. 유형 인수가 복소수 인 경우 값은 분산 1의 원형 대칭 복소 정규 분포에서 가져옵니다 (평균 0 및 분산 &lt;code&gt;1/2&lt;/code&gt; 을 갖는 독립 정규 분포를 갖는 실수 및 허수 부분에 해당 ).</target>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">평균이 0이고 표준 편차가 1 인 정규 분포 &lt;code&gt;T&lt;/code&gt; 유형의 난수를 생성합니다. 선택적으로 정규 분포 난수의 배열을 생성합니다. &lt;code&gt;Base&lt;/code&gt; 모듈은 현재 유형의 구현을 제공 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (기본값)과 &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 대응을. 유형 인수가 복소수이면 값은 원형 대칭 복소 정규 분포에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">척도 1의 지수 분포에 따라 유형 &lt;code&gt;T&lt;/code&gt; 의 난수를 생성합니다 . 선택적으로 이러한 난수의 배열을 생성합니다. &lt;code&gt;Base&lt;/code&gt; 모듈은 현재 유형의 구현을 제공 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; 을&lt;/a&gt; (기본값).</target>
        </trans-unit>
        <trans-unit id="a537f03cb21656031e0fd8ad6fc35f3473173ca5" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to &lt;code&gt;tempname&lt;/code&gt; generating the same file name. The name is guaranteed to differ from all files already existing at the time of the call to &lt;code&gt;tempname&lt;/code&gt;.</source>
          <target state="translated">임시 파일 경로를 생성합니다. 이 함수는 경로 만 반환합니다. 파일이 생성되지 않습니다. 경로는 고유 할 수 있지만 동일한 파일 이름을 생성하는 &lt;code&gt;tempname&lt;/code&gt; 에 대한 두 개의 동시 호출이 매우 원격으로 가능하기 때문에 보장 할 수 없습니다 . 이름은 &lt;code&gt;tempname&lt;/code&gt; 을 호출 할 때 이미 존재하는 모든 파일과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">임시 파일 경로를 생성하십시오. 이 함수는 경로 만 반환합니다. 파일이 작성되지 않습니다. 경로는 고유 할 수 있지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">생성 된 함수</target>
        </trans-unit>
        <trans-unit id="cba590af8f8ae8e32e66535964125d2756a08bf3" translate="yes" xml:space="preserve">
          <source>Generated functions are only permitted to call functions that were defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function. (Failure to follow this may result in getting &lt;code&gt;MethodErrors&lt;/code&gt; referring to functions from a future world-age.)</source>
          <target state="translated">생성 된 함수는 생성 된 함수의 정의 &lt;em&gt;이전&lt;/em&gt; 에 정의 된 함수 만 호출 할 수 있습니다. (이를 따르지 않으면 미래 세계 시대의 함수를 참조하는 &lt;code&gt;MethodErrors&lt;/code&gt; 가 발생할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">생성 된 함수는 런타임시 높은 효율성을 달성 할 수 있지만 컴파일 시간 비용이 발생합니다. 구체적인 인수 유형의 모든 조합에 대해 새 함수 본문을 생성해야합니다. 일반적으로 Julia는 인수에 사용할 수있는 &quot;일반&quot;버전의 함수를 컴파일 할 수 있지만 생성 된 함수로는 불가능합니다. 이는 생성 된 함수를 많이 사용하는 프로그램을 정적으로 컴파일하는 것이 불가능할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">생성 된 함수는 일정하지 않은 전역 상태 (예 : IO, 잠금, 로컬이 아닌 사전 포함 또는 &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; &lt;/a&gt; 사용)를 &lt;em&gt;변경&lt;/em&gt; 하거나 &lt;em&gt;관찰&lt;/em&gt; 해서는 안됩니다. )를 . 즉, 전역 상수 만 읽을 수 있으며 부작용이 없습니다. 다시 말해, 그것들은 완전히 순수해야합니다. 구현 제한으로 인해 현재 클로저 또는 생성기를 정의 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 키워드를 사용하여 생성 된 값을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 사본을 생성하고 해당 사본에서 저장된 숫자 0을 제거하여 선택적으로 &lt;code&gt;trim&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 일 때 결과의 &lt;code&gt;rowval&lt;/code&gt; 및 &lt;code&gt;nzval&lt;/code&gt; 배열 에서 초과 공간을 트리밍 합니다 .</target>
        </trans-unit>
        <trans-unit id="eae6d1575ffa43a8d9796f9233f972a39752f20b" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 복사본을 생성하고 해당 복사본에서 저장된 숫자 0을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복사본을 생성하고 해당 복사본에서 숫자 0을 제거하고 선택적으로 &lt;code&gt;trim&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 때 결과의 &lt;code&gt;nzind&lt;/code&gt; 및 &lt;code&gt;nzval&lt;/code&gt; 배열 에서 여분의 공간을 잘라 냅니다. .</target>
        </trans-unit>
        <trans-unit id="45dac0453bb6ba7f95de954c9e7abbe105892f30" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복사본을 생성하고 해당 복사본에서 숫자 0을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">변수에 대한 기호를 생성합니다. 예를 들어, &lt;code&gt;@gensym x y&lt;/code&gt; 는 &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; 로 변환됩니다 . y = gensym ( &quot;y&quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">다른 변수 이름과 충돌하지 않는 기호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 1 (시간 기반) UUID (Universally Unique Identifier)를 생성합니다. RFC의 섹션 4.5에 따라 노드 ID가 임의로 생성됩니다 (호스트를 식별하지 않음).</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 4 (랜덤 또는 의사 랜덤) UUID (Universally Unique Identifier)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 5 (네임 스페이스 및 도메인 기반) UUID (Universally Unique Identifier)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="070600dec2910fb2959b8379d05bbc160f7ec7de" translate="yes" xml:space="preserve">
          <source>Generating random values for some distributions may involve various trade-offs. &lt;em&gt;Pre-computed&lt;/em&gt; values, such as an &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;alias table&lt;/a&gt; for discrete distributions, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rejection_sampling&quot;&gt;&amp;ldquo;squeezing&amp;rdquo; functions&lt;/a&gt; for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.</source>
          <target state="translated">일부 분포에 대한 임의 값 생성에는 다양한 절충이 포함될 수 있습니다. 이산 분포에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;별칭 테이블&lt;/a&gt; 또는 일 변량 분포에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rejection_sampling&quot;&gt;&quot;압축&quot;함수&lt;/a&gt; 와 같이 &lt;em&gt;미리 계산 된&lt;/em&gt; 값 은 샘플링 속도를 상당히 높일 수 있습니다. 미리 계산해야하는 정보의 양은 분포에서 도출하려는 값의 수에 따라 달라질 수 있습니다. 또한 일부 난수 생성기는 다양한 알고리즘이 악용 할 수있는 특정 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">사용자 정의 유형의 임의 값 생성</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;AbstractFloat&lt;/code&gt; 유형의 값 생성</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">컬렉션에서 값 생성</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">유형에서 값 생성</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">생성기 표현식</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">발전기 (창조 및 파종)</target>
        </trans-unit>
        <trans-unit id="23abb36aa0bc1408666d7f17a0f4dc7b6c92131a" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">생성기는 내부 함수를 통해 구현됩니다. 언어의 다른 곳에서 사용되는 내부 함수와 마찬가지로 둘러싸는 범위의 변수는 내부 함수에서 &quot;캡처&quot;될 수 있습니다. 예를 들어 &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; 은 둘러싸는 범위에서 세 개의 변수 &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 을 캡처합니다 . 캡처 된 변수는 성능 문제를 일으킬 수 있습니다. &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;성능 팁을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">발전기는 내부 기능을 통해 구현됩니다. 언어의 다른 곳에서 사용되는 내부 함수와 마찬가지로 둘러싸는 범위의 변수는 내부 함수에서 &quot;캡처&quot;될 수 있습니다. 예를 들어, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; 경우 sum (p [i]-q [i] 는 둘러싸는 범위에서 세 개의 변수 &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 을 캡처합니다 . 캡처 된 변수는 성능 문제를 일으킬 수 있습니다. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">일반 항등 연산자 &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 로 폴백 합니다. 인스턴스가 나타내는 추상적 인 값을 기반으로 동일한 개념으로 모든 유형에 대해 구현해야합니다. 예를 들어, 모든 숫자 유형은 유형을 무시하고 숫자 값으로 비교됩니다. 문자열은 인코딩을 무시하고 일련의 문자로 비교됩니다. 컬렉션의 경우 &lt;code&gt;==&lt;/code&gt; 는 일반적으로 모든 내용에서 재귀 적으로 호출되지만 다른 속성 (배열 모양과 같은)도 고려 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">일반 오류 유형 &lt;code&gt;.msg&lt;/code&gt; 필드 의 오류 메시지 는보다 구체적인 내용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 크기 조정 균일 스케일링 연산자는 ID 연산자 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; 의 스칼라 시간으로 정의됩니다 . &lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">기하 비율</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">기하학적으로 동일</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">기하학적으로</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">긴 Solidus 오버레이 / 비 간격 Long 슬래시 오버레이 결합과 기하학적으로 동일</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">Julia의 프로세스 ID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">현재 프로그램 포인트의 역 추적 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">객체 식별 정보를 기반으로 &lt;code&gt;x&lt;/code&gt; 의 해시 값을 가져 옵니다. &lt;code&gt;x === y&lt;/code&gt; 경우 &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; 저장소 의 모든 참조 이름 목록을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; 의 모든 태그 목록을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">모듈의 둘러싸 가져 오기 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Main&lt;/code&gt; 은 자신의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 처음 &lt;code&gt;n&lt;/code&gt; 자로 구성된 문자열을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 마지막 &lt;code&gt;n&lt;/code&gt; 자로 구성된 문자열을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">객체 &lt;code&gt;x&lt;/code&gt; 의 속성 ( &lt;code&gt;x.property&lt;/code&gt; )으로 구성된 튜플 또는 벡터를 가져옵니다 . 이는 일반적으로 동일하다 &lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; &lt;/a&gt; 하지만, 그 종류 과부하 &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; 일반적한다 과부하 &lt;code&gt;propertynames&lt;/code&gt; 유형의 인스턴스의 특성을 얻을뿐만 아니라이.</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 필드의 이름으로 튜플을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">지정된 유형의 로컬 머신의 IP 주소를 가져옵니다. 지정된 유형의 주소를 사용할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">IPv6보다 IPv4를 선호하는 로컬 컴퓨터의 IP 주소를 얻습니다. 사용 가능한 주소가없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">더 이상 사용되지 않는 이름을 제외 하고 &lt;code&gt;Module&lt;/code&gt; 에서 내 보낸 이름의 배열을 가져옵니다 . &lt;code&gt;all&lt;/code&gt; 참인 경우 목록에는 모듈에 정의 된 내보내기되지 않은 이름, 더 이상 사용되지 않는 이름 및 컴파일러 생성 이름도 포함됩니다. 경우 &lt;code&gt;imported&lt;/code&gt; 사실이다, 다음 명시 적으로 다른 모듈에서 가져온 이름도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">가져 오기 &lt;code&gt;Module&lt;/code&gt; 은 IS 최상위 평가의 &lt;code&gt;Module&lt;/code&gt; 현재에서 읽고있는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">(가) 가져 오기 &lt;em&gt;가져 오기&lt;/em&gt; 지정된 대한 refspecs를 &lt;code&gt;rmt&lt;/code&gt; . 이 참조 스펙에는 가져올 브랜치에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">가져 오기 &lt;em&gt;푸시&lt;/em&gt; 지정된 대한 refspecs &lt;code&gt;rmt&lt;/code&gt; . 이 참조 스펙에는 푸시 할 브랜치에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">현재 실행 스레드의 ID 번호를 가져옵니다. 마스터 스레드는 ID &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">주어진 소켓이 연결된 원격 엔드 포인트의 IP 주소와 포트를 가져옵니다. 연결된 TCP 소켓에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">주어진 소켓이 바인딩 된 IP 주소와 포트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">지정된 유형의 로컬 시스템의 IP 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5f0191f319b101f536ac6e663f42d85f39f5dc3e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine.</source>
          <target state="translated">로컬 컴퓨터의 IP 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">로컬 컴퓨터의 IPv4 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 유형의 가산 성 요소를 가져옵니다 ( &lt;code&gt;x&lt;/code&gt; 는 유형 자체도 지정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 블록 내에서 사용하기 위해 현재 예외의 역 추적을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">자식 프로세스 ID가 여전히 존재하는 경우 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">구체적인 &lt;code&gt;x&lt;/code&gt; 유형을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">기본 산술 함수 ( &lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; ) 의 반올림 및 유형 변환을 제어하여 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 현재 부동 소수점 반올림 모드를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">스트림의 현재 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 실행중인 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 를 가져&lt;/a&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">경로의 디렉토리 부분을 가져옵니다. 경로의 후행 문자 ( '/'또는 '\')는 경로의 일부로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">정규화 된 부동 소수점 숫자의 지수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">원격 자식 저장소의 가져 오기 URL을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">경로의 파일 이름 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">반복 가능한 컬렉션의 첫 번째 요소를 가져옵니다. 비어있는 경우에도 &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; 의&lt;/a&gt; 시작점을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e2a67c4001b5073d3effff6ee96ac8c41fc3f469" translate="yes" xml:space="preserve">
          <source>Get the full path of the library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libname&lt;/code&gt; 라이브러리의 전체 경로를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">모듈의 정규화 된 이름을 튜플 심볼로 가져옵니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">처 자식 개체를 가져옵니다 &lt;code&gt;te&lt;/code&gt; 의미와 실제 유형 (유형으로 반환 &lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt; 인스턴스 A을 입증 할) &lt;code&gt;GitBlob&lt;/code&gt; 또는 &lt;code&gt;GitTag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">현재 프로세스의 ID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사전 유형의 키 유형을 가져옵니다. &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 과 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">O (1) 시간으로 계산할 수있는 경우 정렬 된 컬렉션의 마지막 요소를 가져옵니다. 마지막 색인을 얻기 위해 &lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; 를 호출 하면 됩니다. 비어있는 경우에도 &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; 의 끝점을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">로컬 컴퓨터의 호스트 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">Julia 객체의 메모리 주소를 &lt;code&gt;Ptr&lt;/code&gt; 로 가져 옵니다 . 결과 &lt;code&gt;Ptr&lt;/code&gt; 이 존재하더라도 가비지 콜렉션으로부터 오브젝트를 보호하지 않으므로 &lt;code&gt;Ptr&lt;/code&gt; 이 사용될 전체 시간 동안 오브젝트가 참조 된 상태로 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">(부모 모듈없이 ) (잠재적으로 &lt;code&gt;UnionAll&lt;/code&gt; - wrapped) &lt;code&gt;DataType&lt;/code&gt; 의 이름을 심볼로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이름을 &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">일반 &lt;code&gt;Function&lt;/code&gt; 의 이름을 기호 또는 &lt;code&gt;:anonymous&lt;/code&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="64e061910a8b5067e4b872f11bbe2bcd37fe4b98" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of &lt;code&gt;Function&lt;/code&gt;, it is the name of the function's type.</source>
          <target state="translated">일반 &lt;code&gt;Function&lt;/code&gt; 의 이름을 기호로 가져 옵니다 . 익명 함수의 경우 컴파일러 생성 이름입니다. &lt;code&gt;Function&lt;/code&gt; 의 명시 적으로 선언 된 하위 유형의 경우 함수 유형의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">원격 저장소의 이름을 가져 오십시오 (예 : &lt;code&gt;&quot;origin&quot;&lt;/code&gt; ) . 원격이 익명 인 경우 ( &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; &lt;/a&gt; 참조 ) 이름은 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 필드 &lt;code&gt;i&lt;/code&gt; 의 이름을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">선택적으로 주어진 위치 &lt;code&gt;index&lt;/code&gt; 에서 배열 또는 문자열의 기본 주소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">사용 가능한 프로세스 수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 작업자 프로세스 수를 얻습니다. 이것은 &lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; &lt;/a&gt; 보다 작은 것 입니다. 동일 &lt;code&gt;nprocs()&lt;/code&gt; 경우 &lt;code&gt;nprocs() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">주어진 객체의 필드 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">주어진 유형의 인스턴스가 가질 필드 수를 가져옵니다. 유형이 너무 추상적이면이를 판별 할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8783ebd0cc15f38c2e971a316cd9c7666dbba9ce" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;a href=&quot;#Base.Threads.threadid&quot;&gt;&lt;code&gt;threadid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia 프로세스에 사용할 수있는 스레드 수를 가져옵니다. 이것은 &lt;a href=&quot;#Base.Threads.threadid&quot;&gt; &lt;code&gt;threadid()&lt;/code&gt; &lt;/a&gt; 에 대한 포괄적 인 상한 입니다.</target>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">Julia 프로세스에 사용 가능한 스레드 수를 가져옵니다. &lt;code&gt;threadid()&lt;/code&gt; 에 포함되는 상한 입니다.</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">파일 소유자의 권한을 비트 필드로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 산술에 현재 사용되는 정밀도 (비트)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">가수의 유효 비트 수로 정의 된 부동 소수점 수의 정밀도를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c82750d28bc29a3941ba9c542817da0f2854ea45" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the significand.</source>
          <target state="translated">유효 비트 수로 정의 된 부동 소수점 숫자의 정밀도를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">프로세스 제목을 가져옵니다. 일부 시스템에서는 항상 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">현재 처리중인 예외 스택을 가져옵니다. 중첩 된 catch 블록의 경우 현재 예외가 두 개 이상있을 수 있습니다.이 경우 가장 최근에 발생한 예외는 스택에서 마지막입니다. 스택은 &lt;code&gt;(exception,backtrace)&lt;/code&gt; 쌍의 Vector 또는 &lt;code&gt;include_bt&lt;/code&gt; 가 false 인 경우 예외의 Vector로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">&lt;code&gt;ie&lt;/code&gt; 의 스테이지 번호를 가져옵니다 . 스테이지 번호 &lt;code&gt;0&lt;/code&gt; 은 작업 트리의 현재 상태를 나타내지 만 병합 충돌의 경우 다른 번호를 사용할 수 있습니다. 이러한 경우, &lt;code&gt;IndexEntry&lt;/code&gt; 의 다양한 스테이지 번호 는 파일의 현재 상태가 속하는 충돌의 어느 쪽 (들)을 설명합니다. 단계 &lt;code&gt;0&lt;/code&gt; 은 병합을 시도하기 전의 상태이고, 단계 &lt;code&gt;1&lt;/code&gt; 은 로컬에서 수행 된 변경이며, 단계 &lt;code&gt;2&lt;/code&gt; 이상은 다른 브랜치 (예 : 다중 분기 &quot;문어&quot;병합의 경우 단계)의 변경을위한 것입니다. &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 및 &lt;code&gt;4&lt;/code&gt; 가 사용될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; 객체 의 단계 크기를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">에포크 (epoch) 이후 시스템 시간 (초)을 상당히 높은 (일반적으로 마이크로 초) 해상도로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">나노초로 시간을 가져옵니다. 0에 해당하는 시간은 정의되어 있지 않으며 5.8 년마다 줄 바꿈됩니다.</target>
        </trans-unit>
        <trans-unit id="860a244a52c686caf400b1420fb67fb1c70889f7" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in bytes.</source>
          <target state="translated">RAM의 총 여유 메모리를 바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">RAM에서 사용 가능한 총 메모리를 킬로바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2891099c5c8dc8b6402c7d53caeef5e0b9cc1707" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in bytes.</source>
          <target state="translated">RAM의 총 메모리 (현재 사용중인 메모리 포함)를 바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">RAM의 총 메모리 (현재 사용 된 메모리 포함)를 킬로바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">C 라이브러리의 &lt;code&gt;errno&lt;/code&gt; 값을 가져옵니다 . 인수가 지정되면 &lt;code&gt;errno&lt;/code&gt; 값을 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사전 유형의 값 유형을 가져옵니다. &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 과 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">공유 배열을 매핑하는 프로세스 벡터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 의 모든 IP 주소를 가져옵니다 . 운영 체제의 기본 &lt;code&gt;getaddrinfo&lt;/code&gt; 구현을 사용하여 DNS 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">지정된 &lt;code&gt;IPAddr&lt;/code&gt; &lt;code&gt;host&lt;/code&gt; 의 첫 번째 IP 주소를 가져 옵니다. 유형 . 운영 체제의 기본 getaddrinfo 구현을 사용하여 DNS 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846899bbba33d15c0dd1bf73665c2578909867ff" translate="yes" xml:space="preserve">
          <source>Gets the path of the temporary directory. On Windows, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, &lt;code&gt;USERPROFILE&lt;/code&gt;. On all other operating systems, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, and &lt;code&gt;TEMPDIR&lt;/code&gt;. If none of these are found, the path &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; is used.</source>
          <target state="translated">임시 디렉터리의 경로를 가져옵니다. Windows에서 &lt;code&gt;tempdir()&lt;/code&gt; 은 정렬 된 목록 &lt;code&gt;TMP&lt;/code&gt; , &lt;code&gt;TEMP&lt;/code&gt; , &lt;code&gt;USERPROFILE&lt;/code&gt; 에 있는 첫 번째 환경 변수를 사용합니다 . 다른 모든 운영 체제에서 &lt;code&gt;tempdir()&lt;/code&gt; 은 정렬 된 목록 &lt;code&gt;TMPDIR&lt;/code&gt; , &lt;code&gt;TMP&lt;/code&gt; , &lt;code&gt;TEMP&lt;/code&gt; 및 &lt;code&gt;TEMPDIR&lt;/code&gt; 에 있는 첫 번째 환경 변수를 사용합니다 . 이러한 항목이 없으면 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 경로 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">둘러보기</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">위생 규칙을 올바르게 작성하는 것은 큰 도전이 될 수 있습니다. 매크로를 사용하기 전에 함수 클로저가 충분한 지 고려할 수 있습니다. 또 다른 유용한 전략은 가능한 많은 작업을 런타임에 연기하는 것입니다. 예를 들어, 많은 매크로는 단순히 인수를 &lt;code&gt;QuoteNode&lt;/code&gt; 또는 다른 유사한 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; 로&lt;/a&gt; 랩핑합니다 . 이 중 일부 예는 &lt;code&gt;@task body&lt;/code&gt; 단순히 반환 &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; , 및 &lt;code&gt;@eval expr&lt;/code&gt; 단순히 반환, &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">기멜 상징 / 제 3의 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="d1acb2e33d2070c77075991c4c8d8d1a063d6fb4" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that it should not inline a function.</source>
          <target state="translated">함수를 인라인해서는 안된다는 힌트를 컴파일러에 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">컴파일러에게이 함수가 인라인 할 가치가 있다는 힌트를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">문자를 인쇄하는 데 필요한 열 수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">문자열을 인쇄하는 데 필요한 열 수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="a34ffde7989d779a84306150562bbcc334bb927c" translate="yes" xml:space="preserve">
          <source>Given a 2-argument function &lt;code&gt;f&lt;/code&gt; and an iterator &lt;code&gt;itr&lt;/code&gt;, return a new iterator that successively applies &lt;code&gt;f&lt;/code&gt; to the previous value and the next element of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">2 인수 함수 &lt;code&gt;f&lt;/code&gt; 와 반복기 &lt;code&gt;itr&lt;/code&gt; 가 주어지면, &lt;code&gt;f&lt;/code&gt; 를 이전 값과 &lt;code&gt;itr&lt;/code&gt; 의 다음 요소에 연속적으로 적용하는 새 반복기를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">I / O 스트림을 첫 번째 인수로 사용 하는 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 유사 함수 인 &lt;code&gt;writefunc&lt;/code&gt; 가 주어지면 base64encode &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; 는 &lt;code&gt;writefunc&lt;/code&gt; 를 호출 하여 &lt;code&gt;args...&lt;/code&gt; 를 base64로 인코딩 된 문자열 에 쓰고 문자열을 반환합니다. &lt;code&gt;base64encode(args...)&lt;/code&gt; 는 &lt;code&gt;base64encode(write, args...)&lt;/code&gt; 같습니다. 표준 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수를 바이트로 변환하고 base64로 인코딩 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">&lt;code&gt;Ptr{T}&lt;/code&gt; 주어지면, 일반적으로 &lt;code&gt;T&lt;/code&gt; 유형의 내용은 &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; 사용하여 참조 된 메모리에서 Julia 객체로 복사 될 수 있습니다 . index 인수는 선택 사항이며 (기본값은 1) 1 기반 색인의 Julia 컨벤션을 따릅니다. 이 함수는 의도적으로 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 의 동작과 유사합니다 ! (예 : &lt;code&gt;[]&lt;/code&gt; 액세스 구문).</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">컬렉션 유형 &lt;code&gt;S&lt;/code&gt; 가 주어지면 현재 &lt;code&gt;rand(::S)&lt;/code&gt; 가 정의되면 &lt;code&gt;eltype(S)&lt;/code&gt; 유형의 객체 가 생성 된다고 가정합니다 . &lt;code&gt;S&lt;/code&gt; 유형의 오브젝트에서 무작위 생성을 정의하기 위해 다음 메소드를 정의 할 수 있습니다. &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; . 여기서 &lt;code&gt;sp&lt;/code&gt; 는 단순히 &lt;code&gt;sp[]&lt;/code&gt; 를 통해 액세스 할 수있는 &lt;code&gt;S&lt;/code&gt; 유형의 객체를 래핑합니다 . &lt;code&gt;Die&lt;/code&gt; 예제를 계속 진행하면서 &lt;code&gt;rand(d::Die)&lt;/code&gt; 를 정의 하여 &lt;code&gt;d&lt;/code&gt; 의 측면 중 하나에 해당 하는 &lt;code&gt;Int&lt;/code&gt; 를 생성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="700a876db14031cb467cacd249ca9851d58258cb" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">컬렉션 유형 &lt;code&gt;S&lt;/code&gt; 가 주어지면 현재 &lt;code&gt;rand(::S)&lt;/code&gt; 가 정의되면 &lt;code&gt;eltype(S)&lt;/code&gt; 유형의 객체 가 생성 된다고 가정합니다 . 마지막 예에서는 &lt;code&gt;Vector{Any}&lt;/code&gt; 가 생성됩니다. 그 이유는 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; 입니다. 해결책은 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; 를 정의하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;D&lt;/code&gt; 가 주어지면 구문 &lt;code&gt;D[x]&lt;/code&gt; 는 키 &lt;code&gt;x&lt;/code&gt; 의 값을 반환 하거나 (있는 경우) 오류를 발생시키고, &lt;code&gt;D[x] = y&lt;/code&gt; 는 키-값 쌍 &lt;code&gt;x =&amp;gt; y&lt;/code&gt; 를 &lt;code&gt;D&lt;/code&gt; 에 저장합니다 (기존의 모든 것을 대체 함) 키 &lt;code&gt;x&lt;/code&gt; 값 ). &lt;code&gt;D[...]&lt;/code&gt; 대한 여러 인수 는 튜플로 변환됩니다. 예를 들어, 구문 &lt;code&gt;D[x,y]&lt;/code&gt; 는 &lt;code&gt;D[(x,y)]&lt;/code&gt; 와 같습니다. 즉, 튜플 &lt;code&gt;(x,y)&lt;/code&gt; 에 의해 키가 지정된 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c0b3c9a8cb5b6bf41774ca0094396ad324bf5391" translate="yes" xml:space="preserve">
          <source>Given a library &lt;code&gt;handle&lt;/code&gt; from &lt;code&gt;dlopen&lt;/code&gt;, return the full path.</source>
          <target state="translated">도서관을 감안할 때 &lt;code&gt;handle&lt;/code&gt; 에서 &lt;code&gt;dlopen&lt;/code&gt; , 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">실행 컨텍스트에 대한 포인터 (주로 &lt;code&gt;backtrace&lt;/code&gt; 호출에 의해 생성됨 )가 제공되면 스택 프레임 컨텍스트 정보를 찾습니다. 그 시점에서 가장 안쪽에있는 함수부터 인라인 된 모든 함수에 대한 프레임 정보 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">술어 함수 &lt;code&gt;flt&lt;/code&gt; 와 iterable 객체 &lt;code&gt;itr&lt;/code&gt; 이 주어지면 iterable 객체 를 리턴하십시오. iterable 객체는 itt의 반복 요소가 &lt;code&gt;flt(x)&lt;/code&gt; 를 만족시키는 &lt;code&gt;itr&lt;/code&gt; 의 요소 &lt;code&gt;x&lt;/code&gt; 를 산출합니다 . 원래 반복자의 순서는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">이전 프로파일 링 실행에서 특정 기능을 호출 한 사람을 결정하십시오. 파일 이름 (및 선택적으로 함수가 정의 된 행 번호 범위)을 제공하면 오버로드 된 메소드를 명확하게 할 수 있습니다. 반환 된 값은 발신자 수와 발신자에 대한 회선 정보를 포함하는 벡터입니다. &lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt; 에서 얻은 역 추적 &lt;code&gt;data&lt;/code&gt; 를 선택적으로 제공 할 수 있습니다 . 그렇지 않으면 현재 내부 프로파일 버퍼가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">반복 가능한 단일 인수 가 제공되면 인수에 의해 생성 된 2 개의 튜플 &lt;code&gt;(key,value)&lt;/code&gt; 에서 키-값 쌍을 가져 오는 &lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">시작 값이 주어지면 선택적으로 주어진 단계 (기본값은 1, &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; ) 로 길이 또는 &lt;code&gt;start&lt;/code&gt; 부터 &lt;code&gt;stop&lt;/code&gt; 까지 범위를 구성하십시오 . &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;stop&lt;/code&gt; 중 하나 가 필요합니다. 경우 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 모두 지정되어, 그들은 동의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">16 진 숫자의 시퀀스에 대해 ASCII 코드 &lt;code&gt;s&lt;/code&gt; 문자열 또는 배열이 주어지면 2 진 표현에 해당하는 바이트 의 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 바이트를 리턴합니다 . &lt;code&gt;s&lt;/code&gt; 의 16 진 숫자 쌍 각각 은 리턴 벡터에서 1 바이트의 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b539dd0aaced1e1e9c21b2db4d99090ee705b0d2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. &lt;code&gt;SamplerType&lt;/code&gt; is the &lt;em&gt;default sampler for types&lt;/em&gt;. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; method should be defined, and should return values what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형이 주어지면 현재 &lt;code&gt;rand(T)&lt;/code&gt; 가 정의되면 &lt;code&gt;T&lt;/code&gt; 유형의 객체 가 생성 된다고 가정합니다 . &lt;code&gt;SamplerType&lt;/code&gt; 은 &lt;em&gt;유형에&lt;/em&gt; 대한 &lt;em&gt;기본 샘플러입니다&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; 유형의 값의 임의 생성을 정의 하려면 &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; 메서드를 정의하고 &lt;code&gt;rand(rng, T)&lt;/code&gt; 가 반환 할 것으로 예상되는 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 주어지면 현재 &lt;code&gt;rand(T)&lt;/code&gt; 가 정의되면 유형 &lt;code&gt;T&lt;/code&gt; 의 객체 가 생성 된다고 가정합니다 . &lt;code&gt;T&lt;/code&gt; 유형의 임의 값 생성을 정의하기 위해 다음과 같은 방법을 정의 할 수 있습니다. &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; ( &lt;code&gt;rand(rng, T)&lt;/code&gt; 가 리턴 할 것으로 예상되는 것을 리턴해야합니다. ).</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">AbstractArray &lt;code&gt;A&lt;/code&gt; 가 주어지면 치수가 순열 된 것처럼 보이도록 뷰 &lt;code&gt;B&lt;/code&gt; 를 만듭니다 . 복사가 발생하지 않는다는 점을 제외하고 &lt;code&gt;permutedims&lt;/code&gt; 과 유사 합니다 ( &lt;code&gt;B&lt;/code&gt; 는 스토리지를 &lt;code&gt;A&lt;/code&gt; 와 공유 함 ).</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">표현 객체가 주어지면 Julia가 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 을&lt;/a&gt; 사용하여 전역 범위에서 그것을 평가 (실행)시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b05155f37fd5b5acf7427c2b96abcb47e059d8f8" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse(v)&lt;/code&gt;&lt;/a&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">&lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;reverse(v)&lt;/code&gt; &lt;/a&gt; 의 인덱스 &lt;code&gt;i&lt;/code&gt; 가 주어지면 &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; 되도록 &lt;code&gt;v&lt;/code&gt; 의 해당 인덱스를 반환합니다 . ( &lt;code&gt;v&lt;/code&gt; 에 ASCII가 아닌 문자가 포함되어 있는 경우에는 중요하지 않을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">&lt;code&gt;reverse(v)&lt;/code&gt; 의 인덱스 &lt;code&gt;i&lt;/code&gt; 가 주어지면 &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; 되도록 &lt;code&gt;v&lt;/code&gt; 의 해당 인덱스를 반환하십시오 . ( &lt;code&gt;v&lt;/code&gt; 에 ASCII가 아닌 문자가 포함 된 경우에는 쉽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">반복자 감안할 때 &lt;code&gt;itr&lt;/code&gt; 다음 &lt;code&gt;reverse(itr)&lt;/code&gt; 같은 콜렉션하지만 역순 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">반복자를 생성하는 반복자가 주어진 경우 해당 반복자의 요소를 생성하는 반복자를 리턴하십시오. 다르게 말하면, 인수 반복자의 요소는 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">그러한 선언이 주어지면 &lt;code&gt;T&lt;/code&gt; 의 각 선택에 대해 &lt;code&gt;Pointy{T}&lt;/code&gt; 의 하위 유형으로 &lt;code&gt;Point{T}&lt;/code&gt; 가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">git 구성 파일에 다음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">문을 감안할 때 &lt;code&gt;using Foo&lt;/code&gt; , 시스템은 이름 하나를 찾기 위해 최상위 모듈의 내부 테이블을 참조합니다 &lt;code&gt;Foo&lt;/code&gt; . 모듈이 존재하지 않는 경우 시스템은 &lt;code&gt;require(:Foo)&lt;/code&gt; 시도하여 일반적으로 설치된 패키지에서 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">반복자의 유형이 주어지면 다음 값 중 하나를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">이 종속성 &lt;code&gt;graph&lt;/code&gt; 주어지면 Julia가 &lt;code&gt;Pub&lt;/code&gt; 패키지에서 UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; 이 있는 &lt;code&gt;import Priv&lt;/code&gt; 를 볼 때 다음을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">이 뿌리에,지도 감안할 때 &lt;code&gt;App&lt;/code&gt; 의 코드 문 &lt;code&gt;import Priv&lt;/code&gt; 찾아 볼 줄리아의 원인이됩니다 &lt;code&gt;roots[:Priv]&lt;/code&gt; 산출, &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 을 의의 UUID &lt;code&gt;Priv&lt;/code&gt; 에서로드 될 패키지 그 맥락. 이 UUID 는 기본 애플리케이션이 &lt;code&gt;import Priv&lt;/code&gt; 평가할 때로드하고 사용할 &lt;code&gt;Priv&lt;/code&gt; 패키지를 식별 합니다.</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">글로벌 범위</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">전역 상수는 원격 노드에서도 상수로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">전역 카운터 (예 : 개체를 고유하게 식별하려는 경우) 다음 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">표준 오류 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">표준 입력 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">표준 출력 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">기본 라이브러리로 내 보낸 전역 변수는 &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이름으로 액세스 할 수 있습니다 . 의 인수 &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; 사용하는 것과 동일한 기호 사양이다 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , 변수에 저장된 값을 나타내는 유형 :</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">전역 통화는 원격 통화 컨텍스트에서만 대상 작업자에게 재전송되며 값이 변경된 경우에만 재전송됩니다. 또한 클러스터는 노드 간 전역 바인딩을 동기화하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 이외의 모듈 아래의 전역 은 값으로 원격 노드에 직렬화되지 않습니다. 참조 만 전송됩니다. 전역 바인딩을 만드는 함수 ( &lt;code&gt;Main&lt;/code&gt; 제외 )는 나중에 &lt;code&gt;UndefVarError&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">자오선을 가진 지구</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">빛나는 별</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="e10a82a4acb4738d8b41ab1910aa292204041524" translate="yes" xml:space="preserve">
          <source>Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler &lt;code&gt;SamplerDie&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Die&lt;/code&gt; 예제로 돌아가서 : &lt;code&gt;rand(::Die)&lt;/code&gt; 는 범위에서 임의 생성을 사용하므로이 최적화를위한 기회가 있습니다. 커스텀 샘플러 &lt;code&gt;SamplerDie&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">C와 같이 정적으로 컴파일 된 언어에 근접한 우수한 성능</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">졸업 캡</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">이중선보다 큰 선보다 작은 선보다 큼</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
