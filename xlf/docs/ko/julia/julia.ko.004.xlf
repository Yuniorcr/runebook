<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="4475ebb24c0e359de01708bc1d247a728f337715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt; should be set to the required command line arguments for new workers.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; 는 새로운 작업자에게 필요한 명령 줄 인수로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="05f09246b7fa073a7f1026d572e6e088740c6e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exeflags&lt;/code&gt;: additional flags passed to the worker processes.</source>
          <target state="translated">&lt;code&gt;exeflags&lt;/code&gt; : 작업자 프로세스에 전달 된 추가 플래그.</target>
        </trans-unit>
        <trans-unit id="3e8963f41f3051e232c8d5de842f5be607191c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; &amp;ndash; the path to the Julia executable on the host, defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; &amp;ndash; 호스트에서 Julia 실행 파일의 경로이며 기본값은 &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbecc18bae8e3704699c9ddb2d2f6ee8f7947be3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt; is the name of the &lt;code&gt;julia&lt;/code&gt; executable including the full path.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; 은 전체 경로를 포함한 &lt;code&gt;julia&lt;/code&gt; 실행 파일 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9e9777b51b1141d2eaeeb8767f03f02a288a8ebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exename&lt;/code&gt;: name of the &lt;code&gt;julia&lt;/code&gt; executable. Defaults to &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; or &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; as the case may be.</source>
          <target state="translated">&lt;code&gt;exename&lt;/code&gt; : &lt;code&gt;julia&lt;/code&gt; 실행 파일의 이름입니다 . 경우에 따라 기본값은 &lt;code&gt;&quot;$(Sys.BINDIR)/julia&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;$(Sys.BINDIR)/julia-debug&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6dc7570f94249d865b09eb2a692da386f794499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d0445c62c1b3939fafe7b40795814fcba18b16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; is used within modules to tell Julia which functions should be made available to the user. For example: &lt;code&gt;export foo&lt;/code&gt; makes the name &lt;code&gt;foo&lt;/code&gt; available when &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; the module. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 모듈 내에서 export 는 사용자에게 어떤 기능을 제공해야하는지 Julia에게 알려줍니다. 예를 들어 : &lt;code&gt;export foo&lt;/code&gt; 이름을 만드는 &lt;code&gt;foo&lt;/code&gt; 사용할 수 &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; 모듈을. 자세한 내용 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;은 모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6574aff1f598d8da6d01cfe7e24524b2c0a7bd1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a7471ee53c91775ff9ce42d242abe595bcfc7dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x)&lt;/code&gt; can be any call expression. Returns the result of &lt;code&gt;f(x)&lt;/code&gt; if the types match, and an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it finds different types.</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 는 모든 호출 표현식 일 수 있습니다. 형식이 일치하면 &lt;code&gt;f(x)&lt;/code&gt; 의 결과를 반환하고 다른 형식을 찾으면 &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0b49364119f011655f3a8d05e365aee509c9dd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; must not cause a task switch, which excludes most I/O operations such as &lt;code&gt;println&lt;/code&gt;. Using the &lt;code&gt;@async&lt;/code&gt; macro (to defer context switching to outside of the finalizer) or &lt;code&gt;ccall&lt;/code&gt; to directly invoke IO functions in C may be helpful for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497f30aa399e54f4d4675a55c3eafb38181ea62b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt; is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; 는 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="17c27552004d64395046d29795efee05dcc044c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;factors&lt;/code&gt;, as in the &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt; type, is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix.</source>
          <target state="translated">&lt;code&gt;factors&lt;/code&gt; &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; &lt;/a&gt; 유형 에서와 같이 factor 는 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="d807df0dedd6adab6f030655307f5490121a67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (0)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (0)</target>
        </trans-unit>
        <trans-unit id="7c323dd694e4baf6f9a2d099639446439f70e26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fastforward::Bool=false&lt;/code&gt;: If &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return &lt;code&gt;false&lt;/code&gt;. This is equivalent to the git CLI option &lt;code&gt;--ff-only&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fastforward::Bool=false&lt;/code&gt; : &lt;code&gt;fastforward&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 병합이 빨리 감기 인 경우에만 병합하고 (현재 분기 헤드는 병합 할 커밋의 조 상임) 그렇지 않으면 병합을 거부하고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 이것은 git CLI 옵션 &lt;code&gt;--ff-only&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="87c543b2d8b2065a2e5dc452819e6c3f937251e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 는 오브젝트를 로컬 머신으로 이동하도록 직접 요청하기 때문에 명시적인 데이터 이동 조작으로 간주 될 수 있습니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; (및 몇 가지 관련 구문)도 데이터를 이동하지만 이것은 분명하지 않으므로 암시 적 데이터 이동 작업이라고 할 수 있습니다. 랜덤 행렬을 구성하고 제곱하는 다음 두 가지 방법을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="441aed98e0f65cd26d43e6c836d252a8cc6789ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch&lt;/code&gt; can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f304481efd9961734ed02019c52b7f122e9caadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetch_opts&lt;/code&gt;: The options for performing the pre-checkout fetch of the remote as part of the clone.</source>
          <target state="translated">&lt;code&gt;fetch_opts&lt;/code&gt; : 클론의 일부로 원격의 사전 체크 아웃 페치를 수행하기위한 옵션.</target>
        </trans-unit>
        <trans-unit id="b6fd3b698a115341e458d38e2ec7ad39b99bd28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_favor&lt;/code&gt;: how to handle conflicting file contents for the &lt;code&gt;text&lt;/code&gt; driver.</source>
          <target state="translated">&lt;code&gt;file_favor&lt;/code&gt; : &lt;code&gt;text&lt;/code&gt; 드라이버 의 충돌하는 파일 내용을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="4de1b4ec1dbc92d77323db107114a2663e47b3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_flags&lt;/code&gt;: guidelines for merging files.</source>
          <target state="translated">&lt;code&gt;file_flags&lt;/code&gt; : 파일 병합을위한 지침.</target>
        </trans-unit>
        <trans-unit id="3fbf2559a3914fd50a580c62f1bf3a524a1b31f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_mode&lt;/code&gt;: read/write/access mode for any files involved in the checkout. Default is &lt;code&gt;0755&lt;/code&gt; or &lt;code&gt;0644&lt;/code&gt;, depending on the blob.</source>
          <target state="translated">&lt;code&gt;file_mode&lt;/code&gt; : 체크 아웃에 관련된 모든 파일에 대한 읽기 / 쓰기 / 액세스 모드 기본값은 &lt;code&gt;0755&lt;/code&gt; 또는 &lt;code&gt;0644&lt;/code&gt; 얼룩에 따라 0644 입니다.</target>
        </trans-unit>
        <trans-unit id="2c42aacc63e30d4330883c95cf718c8560278f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_open_flags&lt;/code&gt;: bitflags used to open any files during the checkout.</source>
          <target state="translated">&lt;code&gt;file_open_flags&lt;/code&gt; : 체크 아웃하는 동안 파일을 여는 데 사용되는 비트 플래그.</target>
        </trans-unit>
        <trans-unit id="5a0fc1d82d9beeb03810443c1cef5731061c18c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt;, and it sets options for the diff. The default is to show files added, modified, or deleted.</source>
          <target state="translated">&lt;code&gt;filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED]))&lt;/code&gt; ) 및 diff에 대한 옵션을 설정합니다. 기본값은 추가, 수정 또는 삭제 된 파일을 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1902a68a69fa5a2286af83a34ec192b45a3e6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="705dcca1f483b5f410a7d024bf9ea5567a98d882" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a246350d082e2ecf351fc1a6227a9daf36f33939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;i &amp;lt;= start&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findnext(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; 되도록 &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; 하고 &lt;code&gt;i &amp;lt;= start&lt;/code&gt; 하거나 &lt;code&gt;nothing&lt;/code&gt; 경우 .</target>
        </trans-unit>
        <trans-unit id="07de775ab3ffe3db837f89e66ab75d6248ad4f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; such that &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; and &lt;code&gt;stop &amp;lt;= i&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if unmatched.</source>
          <target state="translated">&lt;code&gt;findprev(&quot;substring&quot;, string, i)&lt;/code&gt; == &lt;code&gt;start:stop&lt;/code&gt; 되도록 &lt;code&gt;string[start:stop] == &quot;substring&quot;&lt;/code&gt; 및 &lt;code&gt;stop &amp;lt;= i&lt;/code&gt; 또는 &lt;code&gt;nothing&lt;/code&gt; 비교할 경우.</target>
        </trans-unit>
        <trans-unit id="6132598e6b7a6f7dbd326bd4b30b37bdb5c4535d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: Flags for the delta and the objects on each side. Determines whether to treat the file(s) as binary/text, whether they exist on each side of the diff, and whether the object ids are known to be correct.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 델타 및 각 측면의 객체에 대한 플래그입니다. 파일을 이진 / 텍스트로 취급할지, 파일이 diff의 양쪽에 있는지 여부 및 객체 ID가 올바른지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="08dfea97d21ddfc07bbc16a2205aa96d1c822a29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: a combination of the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt;&lt;code&gt;git_diff_flag_t&lt;/code&gt;&lt;/a&gt; flags. The &lt;code&gt;i&lt;/code&gt;th bit of this integer sets the &lt;code&gt;i&lt;/code&gt;th flag.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_flag_t&quot;&gt; &lt;code&gt;git_diff_flag_t&lt;/code&gt; &lt;/a&gt; 플래그 의 조합 . 이 정수 의 &lt;code&gt;i&lt;/code&gt; 번째 비트는 &lt;code&gt;i&lt;/code&gt; 를 설정합니다 번째 플래그를 .</target>
        </trans-unit>
        <trans-unit id="6a3f46c8ead4a96fd5e9f1735c77e01ac2e9df4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for flags describing merge behavior. Defined in &lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt;&lt;code&gt;git_merge_flag_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_MERGE&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 병합 동작을 설명하는 플래그에 대한 &lt;code&gt;enum&lt;/code&gt; 입니다. &lt;a href=&quot;https://github.com/libgit2/libgit2/blob/HEAD/include/git2/merge.h#L95&quot;&gt; &lt;code&gt;git_merge_flag_t&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 해당 Julia 열거 형은 &lt;code&gt;GIT_MERGE&lt;/code&gt; 입니다. 이며 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7ad69674a910f1a345e02b973a2e9f13be3f925" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags controlling which files will appear in the diff. Defaults to &lt;code&gt;DIFF_NORMAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : diff에 표시 될 파일을 제어하는 ​​플래그. 기본값은 &lt;code&gt;DIFF_NORMAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac96c3420fc47ecbae6d81e79e8646bf681816a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: flags for controlling any callbacks used in a status call.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 상태 호출에 사용되는 모든 콜백을 제어하기위한 플래그.</target>
        </trans-unit>
        <trans-unit id="0f514fc00776f1753b3aa88448a24342da8ef48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: one of &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; or &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; (the other blame flags are not yet implemented by libgit2).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : &lt;code&gt;Consts.BLAME_NORMAL&lt;/code&gt; 또는 &lt;code&gt;Consts.BLAME_FIRST_PARENT&lt;/code&gt; 중 하나입니다 (다른 비난 플래그는 아직 libgit2에 의해 구현되지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="e302baefdbfe650eed3e3989e00d95ff24420d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;floor(T, x)&lt;/code&gt; 입력 결과를 변환 &lt;code&gt;T&lt;/code&gt; 를 던지고 &lt;code&gt;InexactError&lt;/code&gt; 을 값을 표현할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="83862f9f9b336e858b86ef3cce875e4b50041164" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;floor(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; that is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;floor(x)&lt;/code&gt; 동일한 유형의 가장 가까운 정수 값을 반환하는 &lt;code&gt;x&lt;/code&gt; 와 동일하다보다 작거나 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="555deaa32601a989d7598bcb2f199e104d3181cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops repeatedly evaluate a block of statements while iterating over a sequence of values.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프는 일련의 값을 반복하면서 명령문 블록을 반복적으로 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ffc0eadc34c155040e86b2da693e68d65e15d861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops, and &lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;Comprehensions&lt;/a&gt; have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프, &lt;code&gt;while&lt;/code&gt; 루프 및 &lt;a href=&quot;../arrays/index#Comprehensions-1&quot;&gt;이해&lt;/a&gt; 에는 다음과 같은 동작이 있습니다. 본문 범위에 도입 된 새 변수는 루프 본문이 &lt;code&gt;let&lt;/code&gt; 블록 으로 둘러싸인 것처럼 각 루프 반복에 대해 새로 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bec35bbf9967b12c572f1318ed025dfeae186ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c53dd6aa8e8d475ff1ee618c1ee3d8f300a0e513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: determines if the push will be a force push, overwriting the remote branch.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : 푸시가 강제 푸시인지 여부를 결정하여 원격 분기를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="4ffee3fe6299fc5a6f0fbcb9a6544eb7b084a999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, branch creation will be forced.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 인 분기 작성이 강제 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="26c5127fe157928b2cdc7f2f08c633baf7c246a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, existing references will be overwritten.</source>
          <target state="translated">&lt;code&gt;force::Bool=false&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 인 기존 참조를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="d8ce10e1bd1c57308264cfa8a02820161529c9d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, a force-push will occur, disregarding conflicts.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 충돌을 무시하고 강제 푸시가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e46f672d0974765d0e4d253aed78bcd6e5d3db60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; &amp;ndash; 트리 구조를 나타내는 백 트레이스가 (default, &lt;code&gt;:tree&lt;/code&gt; ) 또는 들여 쓰기 ( &lt;code&gt;:flat&lt;/code&gt; ) 없이 인쇄되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="c5f38a1c899e88a0f23d1dfceaf7e3fd37e72169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; &amp;ndash; Introduced above, determines whether backtraces are printed with (default, &lt;code&gt;:tree&lt;/code&gt;) or without (&lt;code&gt;:flat&lt;/code&gt;) indentation indicating tree structure.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; &amp;ndash; 위에 소개되었으며, 백 트레이스가 트리 구조를 나타내는 (default, &lt;code&gt;:tree&lt;/code&gt; ) 또는 ( &lt;code&gt;:flat&lt;/code&gt; ) 들여 쓰기 없이 인쇄되는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="07b58cbb5868ed67a3999d68cce4a5e6d8243fe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward&lt;/code&gt; &amp;ndash; the forwarding option used for &lt;code&gt;-L&lt;/code&gt; option of ssh</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f61b7b48011ec894bf5fdc902e3b4b8a9fb28f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; must accept the bound channel as its only argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fcdc8d4522728ad257672e40067d5a19c4c857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="0109f2ca671c98fc793c2888fdfb44cb05b2f484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global const&lt;/code&gt; statements from local scope after &lt;code&gt;__init__()&lt;/code&gt; has been started (see issue #12010 for plans to add an error for this)</source>
          <target state="translated">&lt;code&gt;global const&lt;/code&gt; &lt;code&gt;__init__()&lt;/code&gt; 가 시작된 후 로컬 범위의 전역 const 문 (에 대한 오류 추가 계획은 문제 # 12010 참조)</target>
        </trans-unit>
        <trans-unit id="09097a47be30f38cda85035ead6ddf1a81219edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcb126bd8fbe56f4b5b16fa14c6c4a92e9cf8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global x&lt;/code&gt; makes &lt;code&gt;x&lt;/code&gt; in the current scope and its inner scopes refer to the global variable of that name. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; 하게 &lt;code&gt;x&lt;/code&gt; 현재의 범위 및 그 범위 내 그 이름의 전역 변수 참조. &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;변수 범위 지정에&lt;/a&gt; 대한 매뉴얼 섹션을 참조하십시오 대한 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c2e813901bd2d8f12c7e3878d31c8f733486073" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a90e71a2c6d30f99d8ba5b28c6c2a5bb0f3aff1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash&lt;/code&gt; is a full (&lt;code&gt;GitHash&lt;/code&gt;) or partial (&lt;code&gt;GitShortHash&lt;/code&gt;) hash.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 는 전체 ( &lt;code&gt;GitHash&lt;/code&gt; ) 또는 부분 ( &lt;code&gt;GitShortHash&lt;/code&gt; ) 해시입니다.</target>
        </trans-unit>
        <trans-unit id="6ab9710162b39252a4dfe60a21316f6a9dd04318" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;head_to_index&lt;/code&gt;: a pointer to a &lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt;&lt;code&gt;DiffDelta&lt;/code&gt;&lt;/a&gt; which encapsulates the difference(s) between the file as it exists in HEAD and in the index.</source>
          <target state="translated">&lt;code&gt;head_to_index&lt;/code&gt; : HEAD와 인덱스에 존재하는 파일 간의 차이를 캡슐화 하는 &lt;a href=&quot;#LibGit2.DiffDelta&quot;&gt; &lt;code&gt;DiffDelta&lt;/code&gt; 에&lt;/a&gt; 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="a8fb6255646b88973be5d589e3e2cd202888275d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hessenberg!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;hessenberg!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 사본을 작성하는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 겹쳐 써서 공간을 절약합니다 .</target>
        </trans-unit>
        <trans-unit id="443aaa2d8a08dbab9eefb3c00c406e4d50854023" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;homedir&lt;/code&gt; determines the home directory via &lt;code&gt;libuv&lt;/code&gt;'s &lt;code&gt;uv_os_homedir&lt;/code&gt;. For details (for example on how to specify the home directory via environment variables), see the &lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt;&lt;code&gt;uv_os_homedir&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;homedir&lt;/code&gt; 은 &lt;code&gt;libuv&lt;/code&gt; 의 &lt;code&gt;uv_os_homedir&lt;/code&gt; 을 통해 홈 디렉토리를 결정합니다 . 자세한 내용 (예 : 환경 변수를 통해 홈 디렉토리를 지정하는 방법)은 &lt;a href=&quot;http://docs.libuv.org/en/v1.x/misc.html#c.uv_os_homedir&quot;&gt; &lt;code&gt;uv_os_homedir&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="25471dd737a8db4cd226555668049cca23bf99f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt;: the hostname to use in the output. A hostname is required to be specified.</source>
          <target state="translated">&lt;code&gt;host::AbstractString=&quot;&quot;&lt;/code&gt; : 출력에 사용할 호스트 이름입니다. 호스트 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b6378d9ceebd483400cddb31fa9c2a3c49dd015" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; &amp;ndash; the host address (either an &lt;code&gt;AbstractString&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; &amp;ndash; 호스트 주소 ( &lt;code&gt;AbstractString&lt;/code&gt; 또는 &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98f2590aab388123acc554ec9786e12f2ed78dd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; enables case-insensitive matching</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 대소 문자를 구분 정합있게</target>
        </trans-unit>
        <trans-unit id="1ac86474612cc32f61718a325d8179094b3f029b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; is unique across all references created from the worker specified by &lt;code&gt;whence&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 는 &lt;code&gt;whence&lt;/code&gt; 에 의해 지정된 작업자로부터 생성 된 모든 참조에서 고유합니다 .</target>
        </trans-unit>
        <trans-unit id="77683aec1c525b2fa7ea4282b18b2bfd743591a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the commit being worked on during this rebase step.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 이 rebase 단계에서 수행되는 커밋 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4632953193a9be88e4db3f78db33ec9c0b3e5355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the item in the diff. If the item is empty on this side of the diff (for instance, if the diff is of the removal of a file), this will be &lt;code&gt;GitHash(0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : diff에있는 항목 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;diff의이면에 항목이 비어있는 경우 (예 : diff가 파일을 제거하는 경우) &lt;code&gt;GitHash(0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e890a5aeabd7d8ed2134402d7301e54269b9fea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: only present in LibGit2 versions newer than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. The length of the &lt;code&gt;id&lt;/code&gt; field when converted using &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Usually equal to &lt;code&gt;OID_HEXSZ&lt;/code&gt; (40).</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; : &lt;code&gt;0.25.0&lt;/code&gt; 이상의 LibGit2 버전에만 존재 합니다. &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; 을&lt;/a&gt; 사용하여 변환 할 때 &lt;code&gt;id&lt;/code&gt; 필드 의 길이입니다 . 일반적으로 &lt;code&gt;OID_HEXSZ&lt;/code&gt; (40)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d569a64dd1d8d5f907282660e533f0925b4121f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id_abbrev&lt;/code&gt;: sets the length of the abbreviated &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to print. Default is &lt;code&gt;7&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id_abbrev&lt;/code&gt; : 축약 된 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 의 길이 를 인쇄 로 설정합니다 . 기본값은 &lt;code&gt;7&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b126af9abc886e3ecfdde16a44fc1fd06cacab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ident&lt;/code&gt; &amp;ndash; worker as identified by the &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ident&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; 에&lt;/a&gt; 의해 식별 된 작업자</target>
        </trans-unit>
        <trans-unit id="63b00d5176640c38aab5edaa5b524b6e779cf1b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, so</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록이 값을 반환하면 다른 많은 언어를 사용하는 사용자에게는 직관적이지 않을 수 있습니다. 이 값은 단순히 선택된 브랜치에서 마지막으로 실행 된 명령문의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="fcb2f9043fb5a6e861c26de7d9fc3e06f6279b43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; blocks are &quot;leaky&quot;, i.e. they do not introduce a local scope. This means that new variables defined inside the &lt;code&gt;if&lt;/code&gt; clauses can be used after the &lt;code&gt;if&lt;/code&gt; block, even if they weren't defined before. So, we could have defined the &lt;code&gt;test&lt;/code&gt; function above as</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 블록 &quot;새는&quot;, 그들은이 지역의 범위를 도입하지 않는 즉. 새로운 변수는 내부 정의한 수단이 &lt;code&gt;if&lt;/code&gt; 조항이 후 사용할 수 &lt;code&gt;if&lt;/code&gt; 들이 이전에 정의되어 있지 않은 경우에도, 블록. 따라서 위 의 &lt;code&gt;test&lt;/code&gt; 기능을 다음과 같이 정의 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="4bf46a1a1630b72dba5a7f8db4ee562143b45f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 는 조건부 평가를 수행하여 부울 표현식의 값에 따라 코드의 일부를 평가하거나 평가하지 않을 수 있습니다. 여기의 해부학 인 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;elseif&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 조건 구문 :</target>
        </trans-unit>
        <trans-unit id="566ebce021ad66c3334658155da253a262017f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b5d807151cf5fb7a277f815a71877f8ac2493dd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore_submodules&lt;/code&gt;: whether to look at files in submodules or not. Defaults to &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt;, which means the submodule's configuration will control whether it appears in the diff or not.</source>
          <target state="translated">&lt;code&gt;ignore_submodules&lt;/code&gt; : 서브 모듈에서 파일을 볼지 여부. 기본값은 &lt;code&gt;SUBMODULE_IGNORE_UNSPECIFIED&lt;/code&gt; 입니다 . 이는 서브 모듈의 구성이 diff에 나타나는지 여부를 제어 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7ec9971812e6bb11003c306876aa97764469071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignorestatus::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then the &lt;code&gt;Cmd&lt;/code&gt; will not throw an error if the return code is nonzero.</source>
          <target state="translated">&lt;code&gt;ignorestatus::Bool&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; ) 이면 반환 코드가 0이 아닌 경우 &lt;code&gt;Cmd&lt;/code&gt; 에서 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b778f0523dec6fb0a23df4b4366a7735dc4e5360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d73230963993ccbecb868483fbaecb6157d6cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt;. Names from the imported &lt;code&gt;Foo&lt;/code&gt; module can be accessed with dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;). See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;import Foo&lt;/code&gt; 는 모듈 또는 패키지 &lt;code&gt;Foo&lt;/code&gt; 를 로드합니다 . 가져온에서 이름 &lt;code&gt;Foo&lt;/code&gt; 모듈 (예 : 도트 구문에 액세스 할 수 있습니다 &lt;code&gt;Foo.foo&lt;/code&gt; 이름에 액세스 할 수 &lt;code&gt;foo&lt;/code&gt; 는 ). 자세한 내용 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;은 모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a86299ce603a7643e3664ff35ca004b94ad86d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c35c5eb16c9e1c075a2a381e94cfe254e7dd0daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; the &lt;code&gt;tst.jl&lt;/code&gt; file in the Julia REPL with &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; &lt;code&gt;include(&quot;tst.jl&quot;)&lt;/code&gt; Julia REPL에 &lt;code&gt;tst.jl&lt;/code&gt; 파일을 포함 시키 십시오 .</target>
        </trans-unit>
        <trans-unit id="f768295f60d5987df59c14346dbea6137535cca3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_to_workdir&lt;/code&gt;: a pointer to a &lt;code&gt;DiffDelta&lt;/code&gt; which encapsulates the difference(s) between the file as it exists in the index and in the &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index_to_workdir&lt;/code&gt; : 인덱스와 &lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt; 에 존재하는 파일 간의 차이를 캡슐화 하는 &lt;code&gt;DiffDelta&lt;/code&gt; 에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="474f56e3f7f2db91f626ba947f94c8134a832be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inds&lt;/code&gt; can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;true&lt;/code&gt; indicating entries to delete.</source>
          <target state="translated">&lt;code&gt;inds&lt;/code&gt; 반복자 또는 정렬 및 고유 한 정수 인덱스의 집합, 또는 같은 길이의 부울 벡터가 될 수 와 &lt;code&gt;true&lt;/code&gt; 삭제 표시 항목. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4b74525a3214d8995b7de35723cd0e10aa9cc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; be called as part of worker process initialization.</source>
          <target state="translated">&lt;code&gt;init_worker(cookie, manager::FooManager)&lt;/code&gt; 작업자 프로세스 초기화의 일부로 init_worker (cookie, manager :: FooManager) &lt;em&gt;를&lt;/em&gt; 호출 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="062786138593a2c08d489ac7499ae90c9ac1b687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inmemory&lt;/code&gt;: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The &lt;a href=&quot;#LibGit2.workdir&quot;&gt;&lt;code&gt;workdir&lt;/code&gt;&lt;/a&gt; will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;inmemory&lt;/code&gt; : 인 메모리 리베이스를 시작합니다. rebase에서 작업하는 발신자는 해당 단계를 수행하고 변경 사항을 커밋 할 수 있지만 HEAD를 되감거나 리포지토리를 업데이트 할 수는 없습니다. &lt;a href=&quot;#LibGit2.workdir&quot;&gt; &lt;code&gt;workdir&lt;/code&gt; &lt;/a&gt; 수정되지 않습니다. 0.24.0 이상인 libgit2 버전에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="43f0e964371142a5bdcf673bc58ad413b60b5576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;BOOL&lt;/code&gt; (C, typical)</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; , &lt;code&gt;BOOL&lt;/code&gt; (C, 일반)</target>
        </trans-unit>
        <trans-unit id="8c6987d5f4b696d5dad48c78ec3bd108e4434880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interhunk_lines&lt;/code&gt;: the maximum number of &lt;em&gt;unchanged&lt;/em&gt; lines &lt;em&gt;between&lt;/em&gt; two separate hunks allowed before the hunks will be combined. Default is 0.</source>
          <target state="translated">&lt;code&gt;interhunk_lines&lt;/code&gt; : 덩어리가 결합되기 전에 허용되는 두 개의 분리 된 덩어리 &lt;em&gt;사이&lt;/em&gt; 의 &lt;em&gt;변경되지 않은&lt;/em&gt; 최대 라인 수. 기본값은 0입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ac758c6df49f7e88cbaf72ed20736709216e27a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv(::Missing)&lt;/code&gt; requires at least Julia 1.2.</source>
          <target state="translated">&lt;code&gt;inv(::Missing)&lt;/code&gt; 에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="defccb8166cf527d394e34aea3f1751d7f3bf94e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f1625223f3bccb84ba7248a9f8ae3e5a6efc8f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fd375f58223ce99e67fd522a69ff52eeb0090c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inv&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inv&lt;/code&gt; , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb423dd8ec10d55f3420319afa3f79a334d2182d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; Allows you to save the results to a buffer, e.g. a file, but the default is to print to &lt;code&gt;stdout&lt;/code&gt; (the console).</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; &amp;ndash; 결과를 파일과 같은 버퍼에 저장할 수 있지만 기본값은 &lt;code&gt;stdout&lt;/code&gt; (콘솔) 으로 인쇄하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5546bdb05f19d23dc367936cace4cab1b8200d3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io&lt;/code&gt; &amp;ndash; the connection used to access the worker (a subtype of &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; &amp;ndash; 작업자에 액세스하는 데 사용되는 연결 ( &lt;code&gt;IO&lt;/code&gt; 의 하위 유형 또는 &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b8a259654f78220bfceb0da4679453a56d4d9938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isbare::Bool=false&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, clone the remote as a bare repository, which will make &lt;code&gt;repo_path&lt;/code&gt; itself the git directory instead of &lt;code&gt;repo_path/.git&lt;/code&gt;. This means that a working tree cannot be checked out. Plays the role of the git CLI argument &lt;code&gt;--bare&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isbare::Bool=false&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 원격을 베어 저장소로 복제하여 &lt;code&gt;repo_path&lt;/code&gt; 자체를 &lt;code&gt;repo_path/.git&lt;/code&gt; 대신 git 디렉토리로 만듭니다 . 이는 작업 트리를 체크 아웃 할 수 없음을 의미합니다. git CLI 인수 &lt;code&gt;--bare&lt;/code&gt; 의 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="8f28ba244c2cc607da8b0fcf1f3367c037ee2322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; can also be used to distinguish signed zeros:</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 을 사용하여 부호있는 0을 구별 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6155f47b9568bd6b958ba232c62862f14186f428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isequal&lt;/code&gt; is the comparison function used by hash tables (&lt;code&gt;Dict&lt;/code&gt;). &lt;code&gt;isequal(x,y)&lt;/code&gt; must imply that &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 은 해시 테이블 ( &lt;code&gt;Dict&lt;/code&gt; )에서 사용하는 비교 함수 입니다. &lt;code&gt;isequal(x,y)&lt;/code&gt; 는 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; 암시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c588e795f436dd4d05aaac17fde984ce26c5d8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ismerge&lt;/code&gt;: Boolean flag indicating whether the changes at the remote have been merged into the local copy yet or not. If &lt;code&gt;true&lt;/code&gt;, the local copy is up to date with the remote fetch head.</source>
          <target state="translated">&lt;code&gt;ismerge&lt;/code&gt; : 원격의 변경 사항이 로컬 복사본에 아직 병합되었는지 여부를 나타내는 부울 플래그입니다. &lt;code&gt;true&lt;/code&gt; 인 경우 , 로컬 사본은 원격 페치 헤드로 최신 상태입니다.</target>
        </trans-unit>
        <trans-unit id="cf09e161cb1b30fd41fdc4159954ec544ced0840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; - return false if a &lt;code&gt;take!&lt;/code&gt; on the pool would block, else true</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; - &lt;code&gt;take!&lt;/code&gt; 가면 거짓을 반환 ! 수영장에서 차단, 그렇지 않으면 사실</target>
        </trans-unit>
        <trans-unit id="7ad6e3363b26358cf09c26c458c64943918beb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isready&lt;/code&gt; tests for the presence of any object in the channel, while &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; waits for an object to become available.</source>
          <target state="translated">&lt;code&gt;isready&lt;/code&gt; 는 채널에 객체가 있는지 테스트하는 동안 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 는 객체가 사용 가능할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="cf94b7544dc2a3713c698136abf41c0ffeb4bb19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_error&lt;/code&gt; takes a C string, and &lt;code&gt;jl_errorf&lt;/code&gt; is called like &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;jl_error&lt;/code&gt; 는 C 문자열을 취하며 &lt;code&gt;jl_errorf&lt;/code&gt; 는 &lt;code&gt;printf&lt;/code&gt; 와 같이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="41fc079cf4386f9010ec6a2a6dcc4d336dfd5990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t**&lt;/code&gt; (a reference to a Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t**&lt;/code&gt; (Julia 유형에 대한 참조)</target>
        </trans-unit>
        <trans-unit id="c496bfdad90f2fcfcf408b69f7b755c0534067bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jl_value_t*&lt;/code&gt; (any Julia Type)</source>
          <target state="translated">&lt;code&gt;jl_value_t*&lt;/code&gt; (모든 Julia 유형)</target>
        </trans-unit>
        <trans-unit id="a6119baf62a14c4942fa709be955c8698c7254e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jpvt&lt;/code&gt; is an integer vector of length &lt;code&gt;n&lt;/code&gt; corresponding to the permutation $P$.</source>
          <target state="translated">&lt;code&gt;jpvt&lt;/code&gt; 는 순열 $ P $에 해당하는 길이 &lt;code&gt;n&lt;/code&gt; 의 정수 벡터입니다 .</target>
        </trans-unit>
        <trans-unit id="5370bf4f79562ad85e01f701fe6974cf62dddd5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    pkg&amp;gt; generate MyPkg              # type ] to enter pkg mode    julia&amp;gt; push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode&lt;/code&gt; If you restart your Julia session you'll have to re-issue that command modifying &lt;code&gt;LOAD_PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;julia pkg&amp;gt; generate MyPkg # type ] to enter pkg mode julia&amp;gt; push!(LOAD_PATH, pwd()) # hit backspace to exit pkg mode&lt;/code&gt; 십시오 Julia 세션을 다시 시작하면 &lt;code&gt;LOAD_PATH&lt;/code&gt; 수정 명령을 다시 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdd73df7706c15ba69b8cb61854340ff6886bc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;julia    using PkgTemplates    t = Template()    generate(&quot;MyPkg&quot;, t)&lt;/code&gt; This will create a blank package, &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt;, in your &lt;code&gt;.julia/dev&lt;/code&gt; directory. Note that PkgTemplates allows you to control many different options through its &lt;code&gt;Template&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;julia using PkgTemplates t = Template() generate(&quot;MyPkg&quot;, t)&lt;/code&gt; 이 빈 패키지, 만들 것 &lt;code&gt;&quot;MyPkg&quot;&lt;/code&gt; 당신에, &lt;code&gt;.julia/dev&lt;/code&gt; 에 디렉토리. PkgTemplates를 사용하면 &lt;code&gt;Template&lt;/code&gt; 생성자를 통해 다양한 옵션을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="625af536bb88ddf9aa5a8b9ba26a788c563e9774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keepempty&lt;/code&gt;: whether empty fields should be kept in the result. Default is &lt;code&gt;false&lt;/code&gt; without a &lt;code&gt;dlm&lt;/code&gt; argument, &lt;code&gt;true&lt;/code&gt; with a &lt;code&gt;dlm&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;keepempty&lt;/code&gt; : 빈 필드를 결과에 유지 해야하는지 여부 기본값은 &lt;code&gt;false&lt;/code&gt; 없이 &lt;code&gt;dlm&lt;/code&gt; , 인수 &lt;code&gt;true&lt;/code&gt; A를 &lt;code&gt;dlm&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="9c6fd799a7cffc4157ed068f75896f2a6f68342b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; is called to remove a worker from the cluster. On the master process, the corresponding &lt;code&gt;IO&lt;/code&gt; objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an &lt;code&gt;exit()&lt;/code&gt; call on the specified remote worker.</source>
          <target state="translated">&lt;code&gt;kill(manager, pid, config)&lt;/code&gt; 클러스터에서 작업자를 제거하기 위해 kill (manager, pid, config) 이 호출됩니다. 마스터 프로세스에서 적절한 정리를 위해 구현 에서 해당 &lt;code&gt;IO&lt;/code&gt; 오브젝트를 닫아야합니다. 기본 구현은 단순히 지정된 원격 작업자에서 &lt;code&gt;exit()&lt;/code&gt; 호출을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="5bfba992423752658b61db87a6fc7a82071655e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;launched::Array&lt;/code&gt;: the array to append one or more &lt;code&gt;WorkerConfig&lt;/code&gt; objects to</source>
          <target state="translated">&lt;code&gt;launched::Array&lt;/code&gt; : 하나 이상의 &lt;code&gt;WorkerConfig&lt;/code&gt; 객체를 추가 할 배열</target>
        </trans-unit>
        <trans-unit id="6c4472e72e5805ee9aa798ea6065a631b9f8120d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazy&lt;/code&gt;: Applicable only with &lt;code&gt;topology=:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; : &lt;code&gt;topology=:all_to_all&lt;/code&gt; 에만 적용 가능합니다 . &lt;code&gt;true&lt;/code&gt; 인 경우 작업자-작업자 연결이 느리게 설정됩니다. 즉, 작업자 간 원격 통화의 첫 번째 인스턴스에서 설정됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="6ab3641b567d7550fa4574b7e9fcd59486edd69f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(iter)&lt;/code&gt; and &lt;code&gt;size(iter, [dim])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;length(iter)&lt;/code&gt; 및 &lt;code&gt;size(iter, [dim])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b82c15769674081bdc4b1e2732d829ab6f255a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str)&lt;/code&gt; the number of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str)&lt;/code&gt; 의 문자 수 &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520336ce4b0d7ffb4223a859ab46df75e628bf97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length(str, i, j)&lt;/code&gt; the number of valid character indices in &lt;code&gt;str&lt;/code&gt; from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length(str, i, j)&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;j&lt;/code&gt; 까지의 &lt;code&gt;str&lt;/code&gt; 에서 유효한 문자 인덱스 수입니다 .</target>
        </trans-unit>
        <trans-unit id="45f8144db4b1abe106783e820484be829d5e84bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, &lt;code&gt;let&lt;/code&gt; creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The &lt;code&gt;let&lt;/code&gt; syntax accepts a comma-separated series of assignments and variable names:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문이 새로운 변수 바인딩에게 그들이 실행할 때마다 할당합니다. 할당 수정 반면 기존 값 위치, &lt;code&gt;let&lt;/code&gt; 새 위치를 작성합니다. 이 차이는 클로저를 통해 해당 범위보다 오래 지속되는 변수의 경우에만 감지 할 수 있습니다. &lt;code&gt;let&lt;/code&gt; 구문은 할당 및 변수 이름의 쉼표로 구분 된 일련의 수용 :</target>
        </trans-unit>
        <trans-unit id="2857b88b57ff8e8634f1fd5411364f41533e5276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="6d34fd9ee3b3db157e9c05aba51e1a69d53562d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt;: the maximum size of the result. &lt;code&gt;limit=0&lt;/code&gt; implies no maximum (default)</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; : 결과의 최대 크기입니다. &lt;code&gt;limit=0&lt;/code&gt; 은 최대 값을 의미하지 않습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="4701fc63cc18d0bd4efa7e7a724aa45a91814bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the line number to open the editor at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee768c9c42d9eb36402e2084b6758909461265e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a949f1c99f2882cd291b76f59d11378f665e213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt; introduces a new local variable. See the &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;manual section on variable scoping&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 은 새로운 지역 변수를 소개합니다. 자세한 내용은 &lt;a href=&quot;../../manual/variables-and-scoping/index#scope-of-variables-1&quot;&gt;변수 범위 지정에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1237a0341e49a3e81f1f3559c045b64e25d095c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="b2ace899c61be5098940595710c0631ed9e0f98f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localclone&lt;/code&gt;: Flag whether to clone a local object database or do a fetch. The default is to let git decide. It will not use the git-aware transport for a local clone, but will use it for URLs which begin with &lt;code&gt;file://&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;localclone&lt;/code&gt; : 로컬 객체 데이터베이스를 복제할지 아니면 가져 오기를 수행할지 여부를 표시합니다. 디폴트는 git이 결정하게하는 것입니다. 로컬 클론에는 git-aware 전송을 사용하지 않지만 &lt;code&gt;file://&lt;/code&gt; 로 시작하는 URL에는 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="45419d31c5c3e877e8801855f33df8c42b91a13b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lu!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;lu!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 사본을 작성하는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 겹쳐 써서 공간을 절약합니다 . &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 의&lt;/a&gt; 인수 분해는 요소의 유형에 의해 표현할 수없는 다수 발생하는 경우 예외가 발생 정수 형식의 예를. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e7ecffd4874930679049a4efd39c31c359825a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt; treats the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; tokens as matching the start and end of individual lines, as opposed to the whole string.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 은 전체 문자열이 아니라 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 토큰을 개별 행의 시작 및 끝과 일치하는 것으로 취급 합니다.</target>
        </trans-unit>
        <trans-unit id="959d5f8f25ccf34278c7231d15d752b5420fe0a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; 항등 행렬</target>
        </trans-unit>
        <trans-unit id="f58713efbedd940089d6be8f8c2bd121e93d80c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. Requires &lt;code&gt;using LinearAlgebra&lt;/code&gt; for &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0804fc37d749faa6c59c487dd0fd30a88f27145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machine_spec&lt;/code&gt; is a string of the form &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. If &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; is specified, other workers will connect to this worker at the specified &lt;code&gt;bind_addr&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;machine_spec&lt;/code&gt; 은 &lt;code&gt;[user@]host[:port] [bind_addr[:port]]&lt;/code&gt; 형식의 문자열입니다 . &lt;code&gt;user&lt;/code&gt; 는 기본적으로 현재 사용자, &lt;code&gt;port&lt;/code&gt; 는 표준 ssh 포트입니다. 경우 &lt;code&gt;[bind_addr[:port]]&lt;/code&gt; 를 지정, 다른 근로자는 지정된에서이 노동자에 연결 &lt;code&gt;bind_addr&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae97bd7ed7d82dd19e12486744447e7aab4faa00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;machines&lt;/code&gt; is a vector of machine specifications. Workers are started for each specification.</source>
          <target state="translated">&lt;code&gt;machines&lt;/code&gt; 는 기계 사양의 벡터입니다. 각 사양마다 작업자가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0e0fb4129a24815ec030736714dbdf7a492aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols.</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt; 는 생성 된 코드를 프로그램에 삽입하는 방법을 정의합니다. 매크로는 일련의 인수 표현식을 리턴 된 표현식에 맵핑하고 결과 표현식은 매크로가 호출되는 지점에서 프로그램으로 직접 대체됩니다. 생성 된 코드가 단순히 주변 프로그램의 일부가되기 때문에 매크로는 &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/init/#Base.eval-1&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 호출하지 않고 생성 된 코드를 실행하는 방법 입니다. 매크로 인수에는 표현식, 리터럴 값 및 기호가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b776a97940ed8af56b4981f4f88255433cb44ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt; defines a method for inserting generated code into a program. A macro maps a sequence of argument expressions to a returned expression, and the resulting expression is substituted directly into the program at the point where the macro is invoked. Macros are a way to run generated code without calling &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/init/#Base.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, since the generated code instead simply becomes part of the surrounding program. Macro arguments may include expressions, literal values, and symbols. Macros can be defined for variable number of arguments (varargs), but do not accept keyword arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8484bf3ce18b73a3cab86759b8f006be25dfcef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;macro&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="84b9fe4b3edfa78bd622af9c76d19c51a2ae7a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; is called at different times during the worker's lifetime with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)&lt;/code&gt; 는 작업자의 수명 동안 적절한 &lt;code&gt;op&lt;/code&gt; 값으로 다른 시간에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3811884df527d3a7abba9f083f81c97faa84f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manager::ClusterManager&lt;/code&gt;: the cluster manager that &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; is called with</source>
          <target state="translated">&lt;code&gt;manager::ClusterManager&lt;/code&gt; : &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; 가 호출 되는 클러스터 관리자</target>
        </trans-unit>
        <trans-unit id="8fdaf74a3de08a38b1e7873c2d0c9cc29c15317c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(f, values(dict::AbstractDict))&lt;/code&gt; requires Julia 1.2 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f703846e4a33db719039e6bcacfcf60d0b7d137b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapreduce&lt;/code&gt; with multiple iterators requires Julia 1.2 or later.</source>
          <target state="translated">&lt;code&gt;mapreduce&lt;/code&gt; 여러 반복자가있는 mapreduce 에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="404b7144aa3a425a14deb38ee5cef8b003767781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_candidates_tags&lt;/code&gt;: consider this many most recent tags in &lt;code&gt;refs/tags&lt;/code&gt; to describe a commit. Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).</source>
          <target state="translated">&lt;code&gt;max_candidates_tags&lt;/code&gt; : 커밋을 설명하기 위해 &lt;code&gt;refs/tags&lt;/code&gt; 에서 가장 최근의 많은 태그를 고려하십시오 . 기본값은 10입니다 (최근 10 개의 태그가 커밋을 설명하는지 확인하기 위해 검사 됨).</target>
        </trans-unit>
        <trans-unit id="72981d27e1ab22dbc583a1145b1621a961f192c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_line&lt;/code&gt;: the last line of the file to which to blame. The default is &lt;code&gt;0&lt;/code&gt;, meaning the last line of the file.</source>
          <target state="translated">&lt;code&gt;max_line&lt;/code&gt; : 비난 할 파일의 마지막 줄. 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 파일의 마지막 줄을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15cedd55ecf1ad91d90724912d371f1e5caa41be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt; &amp;ndash; the maximum number of workers to connect to in parallel on the host</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; &amp;ndash; 호스트에서 병렬로 연결할 최대 작업자 수</target>
        </trans-unit>
        <trans-unit id="d995f39223c4bb9a999a43cfcca6c5681ab1ad1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_parallel&lt;/code&gt;: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.</source>
          <target state="translated">&lt;code&gt;max_parallel&lt;/code&gt; : 호스트에서 병렬로 연결된 최대 작업자 수를 지정합니다. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="1b1d9f37af536ccd58c278c3e506d8652b8ac208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_size&lt;/code&gt;: the maximum file size of a blob. Above this size, it will be treated as a binary blob. The default is 512 MB.</source>
          <target state="translated">&lt;code&gt;max_size&lt;/code&gt; : Blob의 최대 파일 크기입니다. 이 크기보다 크면 이진 얼룩으로 처리됩니다. 기본값은 512MB입니다.</target>
        </trans-unit>
        <trans-unit id="eaffe3704906f8467b046897a2780542aedcf5e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits frames at a depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; &lt;code&gt;:tree&lt;/code&gt; 형식 에서 &lt;code&gt;maxdepth&lt;/code&gt; 보다 높은 깊이로 프레임을 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="32491e760e7f18f6d8360a85f2a4709cc201ee79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; Limits the depth higher than &lt;code&gt;maxdepth&lt;/code&gt; in the &lt;code&gt;:tree&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; &amp;ndash; &lt;code&gt;:tree&lt;/code&gt; 형식 에서 &lt;code&gt;maxdepth&lt;/code&gt; 보다 높은 깊이를 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="5f20d7bbc515704268a8c41e4ee1011847047e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxlog=integer&lt;/code&gt; should be used as a hint to the backend that the message should be displayed no more than &lt;code&gt;maxlog&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;maxlog=integer&lt;/code&gt; 는 메시지가 &lt;code&gt;maxlog&lt;/code&gt; 시간 이하로 표시되어야한다는 백엔드의 힌트로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="234c5dd9163cc56272b3f54c2a5466c8b1f6eaee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxsize&lt;/code&gt;: specifies a size beyond which the buffer may not be grown.</source>
          <target state="translated">&lt;code&gt;maxsize&lt;/code&gt; : 버퍼가 커질 수없는 크기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="98f6f1cd7ea6f9bdc2332e5a901da5db582cd3aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mean&lt;/code&gt; for empty arrays requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; 빈 배열의 평균 은 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2f22ee8634e701a2f38532448ed1c500b069efd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt;: options for how to perform the merge, including whether fastforwarding is allowed. See &lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt;&lt;code&gt;MergeOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions = MergeOptions()&lt;/code&gt; : 빨리 감기 허용 여부를 포함하여 병합을 수행하는 방법에 대한 옵션입니다. 자세한 내용은 &lt;a href=&quot;#LibGit2.MergeOptions&quot;&gt; &lt;code&gt;MergeOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71cc2e70735d9fd74fff0caeb5b8d510b36cbd2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt;: &lt;code&gt;merge_opts&lt;/code&gt; specifies options for the merge, such as merge strategy in case of conflicts.</source>
          <target state="translated">&lt;code&gt;merge_opts::MergeOptions=MergeOptions()&lt;/code&gt; : &lt;code&gt;merge_opts&lt;/code&gt; 는 충돌시 병합 전략과 같은 병합 옵션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="125e60bc501dba72f09f0b4976efe2ce6d4483cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_opts&lt;/code&gt;: merge options controlling how the trees will be merged at each rebase step. Only present on libgit2 versions newer than or equal to 0.24.0.</source>
          <target state="translated">&lt;code&gt;merge_opts&lt;/code&gt; : 각 rebase 단계에서 트리를 병합하는 방법을 제어하는 ​​병합 옵션. 0.24.0 이상인 libgit2 버전에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a5c88c45c2e1535dc547029bf00d88024b7ab716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith!&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d6df524e25091e18c8beea5b75a95d3f719841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergewith&lt;/code&gt; requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b67314512e49ee15c92e5c7e9f6dbd1931dab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; should be an expression which evaluates to a string which is a human readable description of the log event. By convention, this string will be formatted as markdown when presented.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 는 사람이 읽을 수있는 로그 이벤트 설명 인 문자열로 평가되는 표현식이어야합니다. 일반적으로이 문자열은 표시 될 때 마크 다운으로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="b90e0c119e4dfcc2e9dd089d139594390c4da90a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta_formatter&lt;/code&gt; is a function which takes the log event metadata &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; and returns a color (as would be passed to printstyled), prefix and suffix for the log message. The default is to prefix with the log level and a suffix containing the module, file and line location.</source>
          <target state="translated">&lt;code&gt;meta_formatter&lt;/code&gt; 는 로그 이벤트 메타 데이터 &lt;code&gt;(level, _module, group, id, file, line)&lt;/code&gt; 를 가져 와서 로그 메시지의 색상 (인쇄 스타일로 전달됨), 접두사 및 접미사를 반환하는 함수입니다. 기본값은 로그 레벨과 모듈, 파일 및 행 위치를 포함하는 접미사를 접두어로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="793b666b763adfb5cbc980bd4657fe28ca8ebfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metric&lt;/code&gt;: optional custom function to use to determine the similarity between two files for rename detection.</source>
          <target state="translated">&lt;code&gt;metric&lt;/code&gt; : 이름 바꾸기 감지를 위해 두 파일 간의 유사성을 판별하는 데 사용할 선택적 사용자 정의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ee731c731c0b59328238d9d827bb96b9a9284c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_line&lt;/code&gt;: the first line of the file from which to starting blaming. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min_line&lt;/code&gt; : 비난을 시작할 파일의 첫 번째 줄입니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b3253f765bb04e11f5c63333adab3ac5b42e254" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_match_characters&lt;/code&gt;: the minimum number of &lt;em&gt;alphanumeric&lt;/em&gt; characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; flags are used, which libgit2 does not implement yet.</source>
          <target state="translated">&lt;code&gt;min_match_characters&lt;/code&gt; : 변경 사항이 해당 커밋과 연결되도록 커밋이 많이 변경되는 &lt;em&gt;영숫자&lt;/em&gt; 문자 의 최소 ​​수입니다 . 기본값은 20입니다. libst2가 아직 구현하지 않은 &lt;code&gt;Consts.BLAME_*_COPIES&lt;/code&gt; 플래그 중 하나가 사용 된 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5db057df9be404f6e7c104b6feff23b69ad90b59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits frames with less than &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; &lt;code&gt;mincount&lt;/code&gt; 횟수 보다 적은 수의 프레임을 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="1560ab3a1270d2ec7101ba0ebabaa0d8741ee114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; Limits the printout to only those lines with at least &lt;code&gt;mincount&lt;/code&gt; occurrences.</source>
          <target state="translated">&lt;code&gt;mincount&lt;/code&gt; &amp;ndash; 인쇄물이 최소한 &lt;code&gt;mincount&lt;/code&gt; 이상 발생 하는 행으로 만 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fc9303555177cabe6ff1fd33c9914d821e64acb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard mathematical operators and functions. For these functions, uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means a math operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fbe82d06f465bb8d2948bd22cf8237ee9a59c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod&lt;/code&gt; with offset 1; returns &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; for &lt;code&gt;y&amp;gt;0&lt;/code&gt; or &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; for &lt;code&gt;y&amp;lt;0&lt;/code&gt;, where &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 오프셋 1을 갖는 모드 ; 반환 &lt;code&gt;r&amp;isin;(0,y]&lt;/code&gt; 에 대한 &lt;code&gt;y&amp;gt;0&lt;/code&gt; 또는 &lt;code&gt;r&amp;isin;[y,0)&lt;/code&gt; 에 대한 &lt;code&gt;y&amp;lt;0&lt;/code&gt; , &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d4ee2c86fd7250e19c9601f24f28fca8d9bdc9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; must be one of &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;r+&quot;&lt;/code&gt;, &lt;code&gt;&quot;w+&quot;&lt;/code&gt;, or &lt;code&gt;&quot;a+&quot;&lt;/code&gt;, and defaults to &lt;code&gt;&quot;r+&quot;&lt;/code&gt; if the file specified by &lt;code&gt;filename&lt;/code&gt; already exists, or &lt;code&gt;&quot;w+&quot;&lt;/code&gt; if not. If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers. You cannot specify an &lt;code&gt;init&lt;/code&gt; function if the file is not writable.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;r+&quot;&lt;/code&gt; , &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;a+&quot;&lt;/code&gt; 중 하나 여야하며 &lt;code&gt;filename&lt;/code&gt; 으로 지정된 파일이 이미 존재 하는 경우 기본값은 &lt;code&gt;&quot;r+&quot;&lt;/code&gt; , 그렇지 않은 경우 &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 입니다. &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 유형 의 &lt;code&gt;init&lt;/code&gt; 함수 가 지정되면 모든 참여 작업자에서 호출됩니다. 파일이 쓰기 가능하지 않으면 &lt;code&gt;init&lt;/code&gt; 함수를 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9a097698641d5469c04e6f0f998cce8e958f0b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt;: the &lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode for the item.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; : 아이템 의 &lt;a href=&quot;../../base/file/index#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모드.</target>
        </trans-unit>
        <trans-unit id="2698588e3b9b4ad6d810639c1a90db1327c88c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5158bf646d4d27259805df6c3a41ba7e37637e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; declares a &lt;a href=&quot;#Core.Module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else&amp;rsquo;s. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 은 별도의 전역 변수 작업 공간 인 &lt;a href=&quot;#Core.Module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; 을&lt;/a&gt; 선언합니다 . 모듈 내에서 다른 모듈에서 어떤 이름을 볼 수 있는지 (가져 오기를 통해) 제어하고 공개 할 이름을 지정할 수 있습니다 (내보내기를 통해). 모듈을 사용하면 코드를 다른 사람과 함께 사용할 때 이름 충돌에 대한 걱정없이 최상위 수준의 정의를 만들 수 있습니다. 자세한 내용 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;은 모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d6b46915fd1e85bc90eb5d56fd7bd927a43d2f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="c95192ba3e3940cd0188a72ebb62589a75aa7d1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt;: the message for the tag.</source>
          <target state="translated">&lt;code&gt;msg::AbstractString=&quot;&quot;&lt;/code&gt; : 태그의 메시지.</target>
        </trans-unit>
        <trans-unit id="f4d691c48a28d2ce55d8a4698e4a2c1aee668e25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt;: a message to insert into the reflogs.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; : 참조 로그에 삽입 할 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="487395b1bdfc7e61d7447898d434b73b3a4f1f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_loop&lt;/code&gt;: loopback for multicast packets (default: &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_loop&lt;/code&gt; : 멀티 캐스트 패킷에 대한 루프백 (기본값 : &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e99e21c3690f3dcdfa4d6c0fe75cee3eea8fe44c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast_ttl&lt;/code&gt;: TTL for multicast packets (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multicast_ttl&lt;/code&gt; : 멀티 캐스트 패킷의 TTL (기본값 : &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="187344f44af903c3b6f0efb3f7498faa785d7c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use SSH multiplexing for tunneling) or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44fe996e6d08709a8c10b3979d511d5e4323b6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplex&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH multiplexing is used for SSH tunneling. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56a3d584155f39e37a0ccc363839ae179552328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f441746093557e9ec7fe5f7c0d91f2ae4fdd6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt; is similar to &lt;a href=&quot;#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;, but additionally allows the fields of the type to be set after construction. See the manual section on &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; 비슷 &lt;a href=&quot;#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 이지만 별도로 유형의 필드 구성 다음에 설정 될 수있다. 자세한 내용은 &lt;a href=&quot;../../manual/types/index#Composite-Types-1&quot;&gt;복합 유형에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="112c939f3f1e9b5e8b278904ec6b0b49257b0632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;mutable struct&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="320c0e13d8c7b9ff51bc77d61fd9070c11bc1ebc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is the total number of instruction pointers you can store, with a default value of &lt;code&gt;10^6&lt;/code&gt;. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most applications.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 저장할 수있는 총 명령어 포인터 수이며 기본값은 &lt;code&gt;10^6&lt;/code&gt; 입니다. 일반적인 역 추적이 20 개의 명령 포인터 인 경우 50000 역 추적을 수집 할 수 있으며 이는 1 % 미만의 통계적 불확실성을 나타냅니다. 대부분의 응용 프로그램에 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e658555bc40ad43ec211978ec0729a0b02c58be6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The full name of the committer or author of the commit.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 커미터 또는 커밋 작성자의 전체 이름.</target>
        </trans-unit>
        <trans-unit id="552e03fffa49ac0ec7ab0ea1aaa5c130fedf4f05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: The name in the local reference database of the fetch head, for example, &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 인출 헤드의 로컬 참조 데이터베이스에서 이름, 예를 들면, &lt;code&gt;&quot;refs/heads/master&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d29f5a5c3f202febb2a81757e5b837859f3823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ncodeunits(str)&lt;/code&gt; number of &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;code units&lt;/a&gt; in a string.</source>
          <target state="translated">&lt;code&gt;ncodeunits(str)&lt;/code&gt; 문자열 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding#Terminology&quot;&gt;코드 단위&lt;/a&gt; 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f909eb780ec20a645e7ec717e2b09ab499055360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="735cb1802f16a2c6f76996e3fbd8153f32d4f6fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) after the changes.</source>
          <target state="translated">&lt;code&gt;new_file&lt;/code&gt; : 변경 후 파일에 대한 정보가 들어 있는 &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7be2c96b12a02f7083c9d25ea7528ad8667d09e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_prefix&lt;/code&gt;: the virtual file directory in which to place new files on one side of the diff. Default is &lt;code&gt;&quot;b&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_prefix&lt;/code&gt; : diff의 한쪽에 새 파일을 배치 할 가상 파일 디렉토리. 기본값은 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8c2e95eb3130b139d44d439028bbbfabf438e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the newest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;newest_commit&lt;/code&gt; : 변경 사항을 살펴볼 최신 커밋 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f40f498efe7ceacbe5a57c6f819e21dd76050f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline2lf=true&lt;/code&gt;, &lt;code&gt;newline2ls=true&lt;/code&gt;, or &lt;code&gt;newline2ps=true&lt;/code&gt;: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively</source>
          <target state="translated">&lt;code&gt;newline2lf=true&lt;/code&gt; , &lt;code&gt;newline2ls=true&lt;/code&gt; 또는 &lt;code&gt;newline2ps=true&lt;/code&gt; : 다양한 개행 문자 시퀀스 (LF, CRLF, CR, NEL)를 각각 줄 바꿈 (LF), 줄 구분 (LS) 또는 단락 구분 (PS) 문자로 변환</target>
        </trans-unit>
        <trans-unit id="4ec45f42c32c00b527d28e030133b724dbf610e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nfiles&lt;/code&gt;: The number of files in the delta (for instance, if the delta was run on a submodule commit id, it may contain more than one file).</source>
          <target state="translated">&lt;code&gt;nfiles&lt;/code&gt; : 델타의 파일 수입니다 (예를 들어, 델타가 서브 모듈 커밋 ID에서 실행 된 경우 둘 이상의 파일을 포함 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="13583c0cdd9e082972c1e68b453244539921d780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that are below the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; 샘플의 휴리스틱 노이즈 플로어 아래에있는 프레임을 제한합니다 (형식 &lt;code&gt;:tree&lt;/code&gt; 에만 적용 ). 이를 위해 권장되는 값은 2.0입니다 (기본값은 0). 이 매개 변수는 &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; 인 샘플을 숨 깁니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은이 행 의 샘플 수 이고 &lt;code&gt;N&lt;/code&gt; 은 수신자의 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="f539796532455743d77bf293cbd17e25f2f2dad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; Limits frames that exceed the heuristic noise floor of the sample (only applies to format &lt;code&gt;:tree&lt;/code&gt;). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of samples on this line, and &lt;code&gt;N&lt;/code&gt; is the number of samples for the callee.</source>
          <target state="translated">&lt;code&gt;noisefloor&lt;/code&gt; &amp;ndash; 샘플의 휴리스틱 노이즈 플로어를 초과하는 프레임을 제한합니다 (형식 &lt;code&gt;:tree&lt;/code&gt; 에만 적용 ). 이를 위해 권장되는 값은 2.0입니다 (기본값은 0). 이 매개 변수는 &lt;code&gt;n &amp;lt;= noisefloor * &amp;radic;N&lt;/code&gt; 인 샘플을 숨 깁니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은이 행 의 샘플 수 이고 &lt;code&gt;N&lt;/code&gt; 은 수신자의 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="7cccdf2a98a9aae590bd349512e62d461403b275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: An optional callback function to notify the user if a checkout conflict occurs. If this function returns a non-zero value, the checkout will be cancelled.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; : 체크 아웃 충돌이 발생하면 사용자에게 알리는 선택적 콜백 함수입니다. 이 함수가 0이 아닌 값을 반환하면 체크 아웃이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="30392c812d865b5c68f24732d969c588932dc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_cb&lt;/code&gt;: optional callback which will notify the user of changes to the diff as file deltas are added to it.</source>
          <target state="translated">&lt;code&gt;notify_cb&lt;/code&gt; : 파일 델타가 추가되면 diff에 대한 변경 사항을 사용자에게 알리는 선택적 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="5d44c57c1841b302e1e4a4864a4e16016feedd35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_flags&lt;/code&gt;: Flags for what sort of conflicts the user should be notified about.</source>
          <target state="translated">&lt;code&gt;notify_flags&lt;/code&gt; : 사용자에게 알려야 할 충돌의 종류를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="c444029454795fde1134c2d469857e669b1440c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_payload&lt;/code&gt;: Payload for the notify callback function.</source>
          <target state="translated">&lt;code&gt;notify_payload&lt;/code&gt; : 알림 콜백 기능을위한 페이로드.</target>
        </trans-unit>
        <trans-unit id="f8a72ff21213c5747c87230deb5736ece00049c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of &lt;code&gt;ntasks_func&lt;/code&gt; is less than the current number of tasks.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; 는 0 인수 기능으로 지정할 수도 있습니다. 이 경우, 병렬로 실행할 태스크 수는 모든 요소를 ​​처리하기 전에 점검되며 &lt;code&gt;ntasks_func&lt;/code&gt; 값이 현재 태스크 수보다 작 으면 새 태스크가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="28a2d799c4775665ec0492395458a2421920f94b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntasks&lt;/code&gt; specifies the number of tasks to run concurrently. Depending on the length of the collections, if &lt;code&gt;ntasks&lt;/code&gt; is unspecified, up to 100 tasks will be used for concurrent mapping.</source>
          <target state="translated">&lt;code&gt;ntasks&lt;/code&gt; 는 동시에 실행할 작업 수를 지정합니다. 컬렉션의 길이에 따라 &lt;code&gt;ntasks&lt;/code&gt; 를 지정하지 않으면 동시 매핑에 최대 100 개의 작업이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="649eb66db0ac1d45f589aa8e9473637c03ceaed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; allows you to skip the specified number of bytes at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 사용하면 파일 시작 부분에서 지정된 바이트 수를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f497a87199a32512c97994d5a18e9f772067d770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oid&lt;/code&gt;: The &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the tip of the fetch head.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; : 페치 헤드 팁의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1944d05e865a7be7c70b13dc44ad49d6eef824c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_file&lt;/code&gt;: A &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt;&lt;code&gt;DiffFile&lt;/code&gt;&lt;/a&gt; containing information about the file(s) before the changes.</source>
          <target state="translated">&lt;code&gt;old_file&lt;/code&gt; 하십시오 &lt;a href=&quot;#LibGit2.DiffFile&quot;&gt; &lt;code&gt;DiffFile&lt;/code&gt; &lt;/a&gt; 변경하기 전에 파일 (들)에 대한 정보를 포함.</target>
        </trans-unit>
        <trans-unit id="0c4e9a36bc861c7981c727529931615c5c12cf7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_prefix&lt;/code&gt;: the virtual file directory in which to place old files on one side of the diff. Default is &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_prefix&lt;/code&gt; : diff의 한쪽에 오래된 파일을 배치 할 가상 파일 디렉토리. 기본값은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5c31e5cf28678d5c969358670eb5133dd3159a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oldest_commit&lt;/code&gt;: the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the oldest commit from which to look at changes.</source>
          <target state="translated">&lt;code&gt;oldest_commit&lt;/code&gt; : 변경 사항을 살펴볼 가장 오래된 커밋 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ab08f6dbafd16b32ce5160a5db1168198264195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;only_follow_first_parent&lt;/code&gt;: when finding the distance from a matching reference to the described object, only consider the distance from the first parent.</source>
          <target state="translated">&lt;code&gt;only_follow_first_parent&lt;/code&gt; : 일치하는 참조에서 설명 된 객체까지의 거리를 찾을 때 첫 번째 상위까지의 거리 만 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cf7b1529623e34aaf3b56dcbaf1430c042e15e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimize&lt;/code&gt; controls whether additional optimizations, such as inlining, are also applied. &lt;code&gt;raw&lt;/code&gt; makes all metadata and dbg.* calls visible. &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; (default) or &lt;code&gt;:none&lt;/code&gt;, to specify the verbosity of code comments. &lt;code&gt;dump_module&lt;/code&gt; prints the entire module that encapsulates the function.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 는 인라인과 같은 추가 최적화가 적용되는지 여부를 제어합니다. &lt;code&gt;raw&lt;/code&gt; 는 모든 메타 데이터 및 dbg. * 호출을 표시합니다. &lt;code&gt;debuginfo&lt;/code&gt; 는 자세한 코드 설명을 지정하기 위해 &lt;code&gt;:source&lt;/code&gt; (기본값) 또는 &lt;code&gt;:none&lt;/code&gt; 중 하나 일 수 있습니다 . &lt;code&gt;dump_module&lt;/code&gt; 은 함수를 캡슐화하는 전체 모듈을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5c0c73b16f432720504516e2f958debb7c0a4f9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the fetch, e.g. whether to prune afterwards. See &lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt;&lt;code&gt;FetchOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; : 가져 오기 옵션을 결정합니다 (예 : 이후 제거 (prune) 여부). 자세한 정보는 &lt;a href=&quot;#LibGit2.FetchOptions&quot;&gt; &lt;code&gt;FetchOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a9ddb6ecff4eeaf4d380bca97b4dd6f7fde407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: determines the options for the push, e.g. which proxy headers to use. See &lt;a href=&quot;#LibGit2.PushOptions&quot;&gt;&lt;code&gt;PushOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; : 푸시에 대한 옵션 (예 : 사용할 프록시 헤더)을 결정합니다. 자세한 내용은 &lt;a href=&quot;#LibGit2.PushOptions&quot;&gt; &lt;code&gt;PushOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f25b0d9ee03294770f82dddd1bc7bcef0fb64c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optype&lt;/code&gt;: the type of rebase operation currently being performed. The options are:</source>
          <target state="translated">&lt;code&gt;optype&lt;/code&gt; : 현재 수행중인 rebase 작업의 유형입니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e3a0e908208f76b5ccd84be51a34bb39927cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ospid&lt;/code&gt; &amp;ndash; the process ID according to the host OS, used to interrupt worker processes</source>
          <target state="translated">&lt;code&gt;ospid&lt;/code&gt; &amp;ndash; 작업자 프로세스를 중단시키는 데 사용되는 호스트 OS에 따른 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="697de2c67496b1d84f2571e138792286e7da4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;our_label&lt;/code&gt;: In case of conflicts, the name of &quot;our&quot; side.</source>
          <target state="translated">&lt;code&gt;our_label&lt;/code&gt; : 충돌이있을 경우 &quot;우리&quot;측의 이름.</target>
        </trans-unit>
        <trans-unit id="6830be65e4ac77ca9e62be6dc5c7e0620fc0523a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, &lt;code&gt;norm(A, Inf)&lt;/code&gt; returns the largest value in &lt;code&gt;abs.(A)&lt;/code&gt;, whereas &lt;code&gt;norm(A, -Inf)&lt;/code&gt; returns the smallest. If &lt;code&gt;A&lt;/code&gt; is a matrix and &lt;code&gt;p=2&lt;/code&gt;, then this is equivalent to the Frobenius norm.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 는 모든 숫자 값을 가정 할 수 있습니다 (모든 값이 수학적으로 유효한 벡터 표준을 생성하지는 않지만). 특히 &lt;code&gt;norm(A, Inf)&lt;/code&gt; 는 &lt;code&gt;abs.(A)&lt;/code&gt; 에서 가장 큰 값을 반환하는 반면 &lt;code&gt;norm(A, -Inf)&lt;/code&gt; 는 가장 작은 값을 반환합니다. 경우 &lt;code&gt;A&lt;/code&gt; 는 행렬이고 &lt;code&gt;p=2&lt;/code&gt; , 그때 이것은 Frobenius의 규범 동일하다.</target>
        </trans-unit>
        <trans-unit id="c1263f31af18883ad798ffeb9ebfc0a698a746ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallelism&lt;/code&gt;: if a pack file must be created, this variable sets the number of worker threads which will be spawned by the packbuilder. If &lt;code&gt;0&lt;/code&gt;, the packbuilder will auto-set the number of threads to use. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parallelism&lt;/code&gt; : 팩 파일을 작성해야하는 경우이 변수는 packbuilder에 의해 생성되는 작업자 스레드 수를 설정합니다. 경우 &lt;code&gt;0&lt;/code&gt; 의 packbuilder 사용에 스레드의 수를-자동으로 설정합니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="062dd574e97337bbf0642f566cbd632bf4e6858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params::Dict&lt;/code&gt;: all the keyword arguments passed to &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;params::Dict&lt;/code&gt; : &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; 에&lt;/a&gt; 전달 된 모든 키워드 인수</target>
        </trans-unit>
        <trans-unit id="2c7beec041180be0f67a5413cf19dc80f87f5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; is a list of commits by &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.</source>
          <target state="translated">&lt;code&gt;parent_ids::Vector{GitHash}=GitHash[]&lt;/code&gt; 는 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 가 새 커밋의 부모 커밋으로 사용하기위한 커밋 목록이며 비어있을 수 있습니다. 예를 들어, 커밋은 병합 커밋 인 경우 여러 부모를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aeba9857371fd4afaedeaa23fe9e52591dc0285" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parse(Bool, str)&lt;/code&gt; requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;parse(Bool, str)&lt;/code&gt; 에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="985febc2923b1ba06875dac2b326b7c44efb7b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt;: the password to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;password::AbstractString=&quot;&quot;&lt;/code&gt; : 제공된 경우 출력에 사용할 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="7b2d565e6b56d3e37cd4a4c107b73f4f88a4add0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt;: the path to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;path::AbstractString=&quot;&quot;&lt;/code&gt; : 제공된 경우 출력에 사용할 경로입니다.</target>
        </trans-unit>
        <trans-unit id="6bbb797e9183ff39fe99d21ff1e7ff0b15d193b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the path to the source file to open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a1cfd3ac44390db0e2939f5bb09d810d9dc716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt;: a &lt;code&gt;NULL&lt;/code&gt; terminated path to the item relative to the working directory of the repository.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; : 저장소의 작업 디렉토리에 상대적인 항목에 대한 &lt;code&gt;NULL&lt;/code&gt; 종료 경로.</target>
        </trans-unit>
        <trans-unit id="df78851e58e7c0164b5edaedb4aae38730252715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;: If not empty, describes which paths to search during the checkout. If empty, the checkout will occur over all files in the repository.</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt; : 비어 있지 않은 경우 체크 아웃 중에 검색 할 경로를 설명합니다. 비어있는 경우, 저장소의 모든 파일에 대해 체크 아웃이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aaac9c176103fbec24dd83078cf0783db26c54ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of &lt;code&gt;show&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; : 경로 일치에 사용할 경로 배열입니다. 경로 일치 동작은 &lt;code&gt;show&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ff5de9b2330e81c1ec09cc2a025ec36b4958e8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathspec&lt;/code&gt;: path to files to include in the diff. Default is to use all files in the repository.</source>
          <target state="translated">&lt;code&gt;pathspec&lt;/code&gt; : diff에 포함 할 파일의 경로입니다. 기본값은 저장소의 모든 파일을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d5c79832426fbf09095f04929a254af7d30d839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt;: only consider tags which match &lt;code&gt;pattern&lt;/code&gt;. Supports glob expansion.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; : 만 일치 태그 고려 &lt;code&gt;pattern&lt;/code&gt; . 글로브 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="faa8387984da43a7639fa49609355dfec1758934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to be provided to the two callback functions.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; : 두 콜백 함수에 제공되는 페이로드.</target>
        </trans-unit>
        <trans-unit id="66e76aa49d7a614c921c6cec0e182e1bd4a6645c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt;: the payload to pass to &lt;code&gt;notify_cb&lt;/code&gt; and &lt;code&gt;progress_cb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; : &lt;code&gt;notify_cb&lt;/code&gt; 및 &lt;code&gt;progress_cb&lt;/code&gt; 에 전달할 페이로드 .</target>
        </trans-unit>
        <trans-unit id="2913a1a2626baab62573ae3ba9c2e917e2edec43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peakflops&lt;/code&gt; computes the peak flop rate of the computer by using double precision &lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt;&lt;code&gt;gemm!&lt;/code&gt;&lt;/a&gt;. By default, if no arguments are specified, it multiplies a matrix of size &lt;code&gt;n x n&lt;/code&gt;, where &lt;code&gt;n = 2000&lt;/code&gt;. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with &lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt;&lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;peakflops&lt;/code&gt; 는 배정 밀도 &lt;a href=&quot;#LinearAlgebra.BLAS.gemm!&quot;&gt; &lt;code&gt;gemm!&lt;/code&gt; &lt;/a&gt; 을 사용하여 컴퓨터의 최대 플롭 속도를 계산합니다 ! . 기본적으로 인수를 지정하지 않으면 &lt;code&gt;n x n&lt;/code&gt; 크기의 행렬을 곱합니다 ( 여기서 &lt;code&gt;n = 2000&lt;/code&gt; . 기본 BLAS가 여러 스레드를 사용하는 경우 더 높은 플롭 속도가 실현됩니다. BLAS 스레드 수는 &lt;a href=&quot;#LinearAlgebra.BLAS.set_num_threads&quot;&gt; &lt;code&gt;BLAS.set_num_threads(n)&lt;/code&gt; &lt;/a&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87b91990e60f0a690dd7da2850cc5ea9cee3bec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_cb&lt;/code&gt;: An optional callback function to display performance data.</source>
          <target state="translated">&lt;code&gt;perfdata_cb&lt;/code&gt; : 성능 데이터를 표시하는 선택적 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e9d2d97fa30fe0159febc55e5a72c5956e0c05f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perfdata_payload&lt;/code&gt;: Payload for the performance callback.</source>
          <target state="translated">&lt;code&gt;perfdata_payload&lt;/code&gt; : 성능 콜백을위한 페이로드.</target>
        </trans-unit>
        <trans-unit id="c5c86680e44cfade629b4ed2ebc1670d3a11ff31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pmap&lt;/code&gt; can also use a mix of processes and tasks via the &lt;code&gt;batch_size&lt;/code&gt; argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length &lt;code&gt;batch_size&lt;/code&gt; or less. A batch is sent as a single request to a free worker, where a local &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt; processes elements from the batch using multiple concurrent tasks.</source>
          <target state="translated">&lt;code&gt;pmap&lt;/code&gt; 은 &lt;code&gt;batch_size&lt;/code&gt; 인수 를 통해 다양한 프로세스와 작업을 사용할 수도 있습니다 . 1보다 큰 배치 크기의 경우 컬렉션은 길이가 &lt;code&gt;batch_size&lt;/code&gt; 이하인 여러 배치로 처리됩니다 . 배치는 단일 요청으로 자유 작업자에게 전송되는데, 로컬 &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; 은 여러 동시 작업을 사용하여 배치의 요소를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a6062089bc8ea7356a1c0e294144b992c9b0d190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt;: the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;port::Union{AbstractString,Integer}=&quot;&quot;&lt;/code&gt; : 제공된 경우 출력에 사용할 포트 번호입니다. scp와 같은 구문을 사용할 때는 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3926b6e41c21bebec38e3305ee3aef86c0f67cdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; the port on the host used to connect to the worker (either an &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; &amp;ndash; 작업자에 연결하는 데 사용되는 호스트의 포트 ( &lt;code&gt;Int&lt;/code&gt; 또는 &lt;code&gt;Nothing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d7ae02e4311ab0f64e68f548cb0826d87786e864" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;power_method&lt;/code&gt; repeatedly creates a new vector and normalizes it. We have not specified any type signature in function declaration, let's see if it works with the aforementioned datatypes:</source>
          <target state="translated">&lt;code&gt;power_method&lt;/code&gt; 는 반복적으로 새로운 벡터를 생성하고 정규화합니다. 함수 선언에 형식 서명을 지정하지 않았습니다. 위에서 언급 한 데이터 형식과 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9113fbab087ead22351138a5675e71d4cc277d28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision&lt;/code&gt; as a keyword argument requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;precision&lt;/code&gt; is the second positional argument (&lt;code&gt;BigFloat(x, precision)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;precision&lt;/code&gt; 키워드 인수로서의 정밀도 에는 Julia 1.1 이상이 필요합니다. Julia 1.0에서 &lt;code&gt;precision&lt;/code&gt; 는 두 번째 위치 인수입니다 ( &lt;code&gt;BigFloat(x, precision)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af54082b04f05e356fa41312f4ae5ca97f259a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt; declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; 은 데이터가 일련의 비트로 만 구성되는 구체적 유형을 선언합니다. 기본 유형의 고전적인 예는 정수 및 부동 소수점 값입니다. 내장 기본 유형 선언의 예 :</target>
        </trans-unit>
        <trans-unit id="d408d986573283a26cbda182d85b826b49383c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;primitive type&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;primitive type&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="ce0cc2b360368626a735bd2ae5d7c2a083fbb6e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; &quot;lock&quot; the stream during a call. Consequently changing &lt;code&gt;write&lt;/code&gt; to &lt;code&gt;println&lt;/code&gt; in the above example results in:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 및 &lt;code&gt;println&lt;/code&gt; 호출 중에 스트림을 &quot;잠금&quot;합니다. 결과적으로 위 예제에서 &lt;code&gt;println&lt;/code&gt; 으로 &lt;code&gt;write&lt;/code&gt; 를 변경 하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1959b9f7871b156edd3a2de5e77463b33177e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; falls back to calling &lt;code&gt;show&lt;/code&gt;, so most types should just define &lt;code&gt;show&lt;/code&gt;. Define &lt;code&gt;print&lt;/code&gt; if your type has a separate &quot;plain&quot; representation. For example, &lt;code&gt;show&lt;/code&gt; displays strings with quotes, and &lt;code&gt;print&lt;/code&gt; displays strings without quotes.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 는 &lt;code&gt;show&lt;/code&gt; 호출로 돌아가 므로 대부분의 유형은 &lt;code&gt;show&lt;/code&gt; 를 정의해야합니다 . 유형에 별도의 &quot;일반&quot;표현이있는 경우 &lt;code&gt;print&lt;/code&gt; 정의하십시오 . 예를 들어, &lt;code&gt;show&lt;/code&gt; 는 문자열을 따옴표로 표시 하고 &lt;code&gt;print&lt;/code&gt; 는 문자열을 따옴표없이 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d0178c5df89eb967f462cc2e8445f025988bec10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;process&lt;/code&gt; &amp;ndash; the process which will be connected (usually the manager will assign this during &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; &amp;ndash; 연결될 프로세스 (일반적으로 관리자는 &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; 중에 이를 지정합니다 )</target>
        </trans-unit>
        <trans-unit id="c63a4f1761d5adacd1e7460b66b481bd63cdd398" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: An optional callback function to display checkout progress.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; : 체크 아웃 진행률을 표시하는 선택적 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7cb6a0f147459271d2a7a2a1bcb82b298199436d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_cb&lt;/code&gt;: optional callback which will display diff progress. Only relevant on libgit2 versions at least as new as 0.24.0.</source>
          <target state="translated">&lt;code&gt;progress_cb&lt;/code&gt; : diff progress를 표시하는 선택적 콜백입니다. 최소 0.24.0 이상의 libgit2 버전에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="a974da56e773f57fa11edfba525b0d17e70b3e1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;progress_payload&lt;/code&gt;: Payload for the progress callback.</source>
          <target state="translated">&lt;code&gt;progress_payload&lt;/code&gt; : 진행 콜백에 대한 페이로드.</target>
        </trans-unit>
        <trans-unit id="9656c555e40a59798ca04ab2a0fd64ef8fcd145d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propertynames(x)&lt;/code&gt; may return only &quot;public&quot; property names that are part of the documented interface of &lt;code&gt;x&lt;/code&gt;. If you want it to also return &quot;private&quot; fieldnames intended for internal use, pass &lt;code&gt;true&lt;/code&gt; for the optional second argument. REPL tab completion on &lt;code&gt;x.&lt;/code&gt; shows only the &lt;code&gt;private=false&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;propertynames(x)&lt;/code&gt; 의 문서화 된 인터페이스의 일부에만 &quot;공개&quot;속성의 이름을 반환 할 수 있습니다 &lt;code&gt;x&lt;/code&gt; . 내부 용으로 &quot;비공개&quot;필드 이름도 반환 하려면 선택적 두 번째 인수에 &lt;code&gt;true&lt;/code&gt; 를 전달하십시오. &lt;code&gt;x.&lt;/code&gt; 에서 REPL 탭 완성 . &lt;code&gt;private=false&lt;/code&gt; 속성 만 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="29d345329a2391a60fb2ebd4642c5f13f15f3a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: only relevant if the LibGit2 version is greater than or equal to &lt;code&gt;0.25.0&lt;/code&gt;. Sets options for using a proxy to communicate with a remote. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; : LibGit2 버전이 &lt;code&gt;0.25.0&lt;/code&gt; 이상인 경우에만 해당됩니다 . 프록시를 사용하여 원격과 통신하기위한 옵션을 설정합니다. 자세한 내용은 &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a1c2878a9100523ed8ddcdc2ca50b8e3e3accca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy_opts&lt;/code&gt;: options for connecting to the remote through a proxy. See &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt;&lt;code&gt;ProxyOptions&lt;/code&gt;&lt;/a&gt;. Only present on libgit2 versions newer than or equal to 0.25.0.</source>
          <target state="translated">&lt;code&gt;proxy_opts&lt;/code&gt; : 프록시를 통해 원격에 연결하기위한 옵션. &lt;a href=&quot;#LibGit2.ProxyOptions&quot;&gt; &lt;code&gt;ProxyOptions&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 0.25.0 이상인 libgit2 버전에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2d1cca20f02fc7ef7b42d7136de423456f81b239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxytype&lt;/code&gt;: an &lt;code&gt;enum&lt;/code&gt; for the type of proxy to use. Defined in &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt;&lt;code&gt;git_proxy_t&lt;/code&gt;&lt;/a&gt;. The corresponding Julia enum is &lt;code&gt;GIT_PROXY&lt;/code&gt; and has values:</source>
          <target state="translated">&lt;code&gt;proxytype&lt;/code&gt; : 사용할 프록시 유형의 &lt;code&gt;enum&lt;/code&gt; 입니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_proxy_t&quot;&gt; &lt;code&gt;git_proxy_t&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 해당 Julia 열거 형은 &lt;code&gt;GIT_PROXY&lt;/code&gt; 이며 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c30e484bc5a233582234aa0eaf5f9ff4b81c5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prune&lt;/code&gt;: whether to perform a prune after the fetch or not. The default is to use the setting from the &lt;code&gt;GitConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; : 페치 후 제거를 수행할지 여부. 기본값은 &lt;code&gt;GitConfig&lt;/code&gt; 의 설정을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="80d39971bfff573dc1ff9e1372624b262b5a7768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put!&lt;/code&gt; - put back a worker to the available pool</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; -사용 가능한 수영장에 노동자를 다시 넣어</target>
        </trans-unit>
        <trans-unit id="a29ba5aea9b5cc34e1af996fefeb1a63d0872750" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d064f8a98d481de062cba01c97539bfc2f0871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;StridedMatrix&lt;/code&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;code&gt;qr!&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;StridedMatrix&lt;/code&gt; 의 하위 유형 인 경우 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 복사본을 만드는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 덮어 써서 공간을 절약합니다 . &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 의&lt;/a&gt; 인수 분해는 요소의 유형에 의해 표현할 수없는 다수 발생하는 경우 예외가 발생 정수 형식의 예를. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9e4bad0fd4a4794a48064d48581af7033259a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr&lt;/code&gt; returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; matrices can be stored compactly rather as two separate dense matrices.</source>
          <target state="translated">&lt;code&gt;qr&lt;/code&gt; 반환 여러 유형 LAPACK은 그래서, 세대주 초등학교 반사경의 제품의 메모리 스토리지 요구 사항을 최소화 몇 가지 표현을 사용하기 때문에 &lt;code&gt;Q&lt;/code&gt; 와 &lt;code&gt;R&lt;/code&gt; 의 행렬이 아닌 두 개의 밀도 행렬로 컴팩트하게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe298f4b4614717693aba0cf7548649332f44a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qsort&lt;/code&gt; expects a comparison function that return a C &lt;code&gt;int&lt;/code&gt;, so we annotate the return type to be &lt;code&gt;Cint&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b9466c550831a8245833d9e56b4ae895f63c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quiet&lt;/code&gt;: inform other git clients helping with/working on the rebase that the rebase should be done &quot;quietly&quot;. Used for interoperability. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; : rebase 작업을 도와주는 다른 자식 클라이언트에게 rebase가 &quot;조용히&quot;이루어져야한다고 알립니다. 상호 운용성에 사용됩니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89148ab980d30701194964666d016c3558cde6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt; creates multiple expression objects in a block without using the explicit &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. For example:</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt; 는 명시 적 &lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 생성자를 사용하지 않고 블록에 여러 표현식 오브젝트를 작성합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f3b9755167388bcf3471ba197b6c40b6008de5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;quote&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9096a143fba87878f860ce663f000649f6400ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; produces a regular expression object rather than a string</source>
          <target state="translated">&lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 는 문자열이 아닌 정규식 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6ec672446bd53c264182855affbe5a78b442fb6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;: restricts operations to the buffer; see &lt;code&gt;open&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;append&lt;/code&gt; : 버퍼로 작업을 제한합니다. 자세한 내용은 &lt;code&gt;open&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecf721b9c658fe1430c1a0d12d81daeb2549a2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recur&lt;/code&gt; &amp;ndash; Controls the recursion handling in &lt;code&gt;:tree&lt;/code&gt; format. &lt;code&gt;:off&lt;/code&gt; (default) prints the tree as normal. &lt;code&gt;:flat&lt;/code&gt; instead compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator. &lt;code&gt;:flatc&lt;/code&gt; does the same but also includes collapsing of C frames (may do odd things around &lt;code&gt;jl_apply&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fbd8f3deb831b9f5ec8b1264c745debaec29b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursion_limit&lt;/code&gt;: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; : 병합을위한 새 가상 병합 기반을 구축하기 위해 수행 할 공통 조상의 병합 수에 대한 상한입니다. 기본값은 제한이 없습니다. 이 필드는 0.24.0 이전의 libgit2 버전에만 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3223e9226e352a329b29a7eace6c1d31eb0a618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt;: if not NULL, the name of the reference to update to point to the new commit. For example, &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; will update the HEAD of the current branch. If the reference does not yet exist, it will be created.</source>
          <target state="translated">&lt;code&gt;refname::AbstractString=Consts.HEAD_FILE&lt;/code&gt; : NULL이 아닌 경우, 새로운 커밋을 가리 키도록 업데이트 할 참조 이름. 예를 들어 &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; 는 현재 분기의 HEAD를 업데이트합니다. 참조가 아직 없으면 참조가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7e2623afd5bf4ea28699952aaf1e41bf326a1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the fetch.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; : 페치의 속성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cad51a938d649503c2ef46d1225a6fc56968236e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt;: determines properties of the push.</source>
          <target state="translated">&lt;code&gt;refspecs=AbstractString[]&lt;/code&gt; : 푸시의 속성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="789e0d7504799b3b38c290db69c2914eaa79a006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rejectna=true&lt;/code&gt;: throw an error if unassigned code points are found</source>
          <target state="translated">&lt;code&gt;rejectna=true&lt;/code&gt; : 할당되지 않은 코드 포인트가 발견되면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="47c34491f7ee239ad33defe253fb1defd64e8594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: the name of the upstream remote to push to.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; : 푸시 할 업스트림 원격의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4b26ba19c7207aa3b208454b432a26db97e4da0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt;: which remote, specified by name, of &lt;code&gt;repo&lt;/code&gt; to fetch from. If this is empty, the URL will be used to construct an anonymous remote.</source>
          <target state="translated">&lt;code&gt;remote::AbstractString=&quot;origin&quot;&lt;/code&gt; : 가져올 원격 &lt;code&gt;repo&lt;/code&gt; 이름으로 지정된 원격 . 비어있는 경우 URL을 사용하여 익명 원격을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ffdcacc6e1483f4d462c34f2bea9360ca75d4db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt;: a callback which will be used to create the remote before it is cloned. If &lt;code&gt;C_NULL&lt;/code&gt; (the default), no attempt will be made to create the remote - it will be assumed to already exist.</source>
          <target state="translated">&lt;code&gt;remote_cb::Ptr{Cvoid}=C_NULL&lt;/code&gt; : 콜백하기 전에 원격을 만드는 데 사용되는 콜백입니다. 경우 &lt;code&gt;C_NULL&lt;/code&gt; (기본값), 시도는 원격를 만들려고되지 않습니다 - 그것은 가정 할 것이다 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; : 콜백을 만들기 전에 &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용되는 선택적 콜백 입니다.</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; : 원격 콜백의 페이로드.</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; 는 원격 참조의 &lt;code&gt;whence&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 값 을 래핑 하는 &lt;code&gt;RRID&lt;/code&gt; 객체 를 반환하는 저수준 API입니다 .</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : &lt;code&gt;remote&lt;/code&gt; 의 URL입니다 .</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : &lt;code&gt;remote&lt;/code&gt; 의 URL입니다 . 지정하지 않으면 지정된 &lt;code&gt;remote&lt;/code&gt; 이름을 기준으로 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; : 하나의 파일 이름이 다른 파일 이름으로 바뀌어야 하는 유사성 백분율 유사성을 설정하는 정수입니다. 기본값은 50입니다.</target>
        </trans-unit>
        <trans-unit id="a1f245ca6c95e5deef1b0ce6ee0330ae1e9c18b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repetition&lt;/code&gt; can be &lt;code&gt;Val(1)&lt;/code&gt; or &lt;code&gt;Val(Inf)&lt;/code&gt;, and should be used as a suggestion for deciding the amount of precomputation, if applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; : 클론이 생성 될 &lt;em&gt;새&lt;/em&gt; 리포지토리 를 만드는 데 사용되는 선택적 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; : 리포지토리 콜백의 페이로드</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 은 &lt;code&gt;show&lt;/code&gt; 의 출력을 문자열로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; 는 주어진 값 &lt;code&gt;x&lt;/code&gt; 를 다시 호출자 에게 전달하여 엔 클로징 함수를 일찍 종료시킵니다 . &lt;code&gt;return&lt;/code&gt; 값없이 자체는 동등 &lt;code&gt;return nothing&lt;/code&gt; (볼 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; : 리베이스가 완료 될 때 커밋 노트를 다시 쓰는 데 사용할 노트에 대한 참조 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; 는 로그 메타 데이터가 정당화되는 정수 열입니다. 기본값은 0입니다 (메타 데이터는 자체 행에 있음).</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 허용합니다 &lt;code&gt;.&lt;/code&gt; 개행과 일치하는 수정 자.</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; 는 (실제) 대칭 인 행렬로 태그가 지정되었으므로 고유 계수 또는 행렬-벡터 제품 계산과 같은 나중에 수행 할 수있는 작업의 경우 절반 만 참조하면 효율성을 찾을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; : 사용할 프로토콜을 식별하는 URL 체계입니다. HTTP는 &quot;http&quot;, SSH는 &quot;ssh&quot;등을 사용합니다. &lt;code&gt;scheme&lt;/code&gt; 이 제공되지 않으면 출력 형식은 &quot;ssh&quot;이지만 scp와 같은 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; 경우 : &lt;code&gt;:wrap&lt;/code&gt; 다음 상단과 하단 커서를 포장, 경우에하는 것은 : &lt;code&gt;nowrap&lt;/code&gt; 커서를 포장하지 않는다</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 이면 브랜치 생성이 완료된 후 브랜치 헤드가 &lt;code&gt;repo&lt;/code&gt; 의 HEAD로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; 는 일부 하드웨어에서 일부 계산 속도를 높일 수 있습니다. 그러나 &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; 와 같은 ID를 손상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; 얻어 &lt;code&gt;AbstractString&lt;/code&gt; 물체 배열 형 ( &lt;code&gt;NTuple&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 형태의 요소) &lt;code&gt;UInt8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; : 검사 할 파일과 순서를 나타내는 플래그입니다. 기본값은 &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; : 커밋을 설명하는 일치하는 참조를 찾을 수 없으면 오류를 발생 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 대신 커밋의 GitHash 를 표시합니다 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; 는 포맷하는 동안 &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; 키를 설정하여 큰 데이터 구조의 인쇄를 화면에 맞출 수있는 것으로 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; : 태그의 서명입니다.</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; : 파일 이름이 바뀌 었는지 또는 복사되었는지를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7997da896750d945cfa8c2d3cb4698bd3a261b9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; : 아이템의 크기 (바이트).</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; : 버퍼 용량을 제안합니다 ( &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;sizehint!(data, size)&lt;/code&gt; 구현해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="b8c3ba1857a9b0055e1e04c56e79b38b776b38ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples, and &lt;code&gt;:overhead&lt;/code&gt; sorts by the number of samples incurred by each function by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; 순서를 &lt;code&gt;:flat&lt;/code&gt; 형식으로 제어 합니다. &lt;code&gt;:filefuncline&lt;/code&gt; (기본값)은 소스 행을 기준으로 정렬하지만 &lt;code&gt;:count&lt;/code&gt; 는 수집 된 샘플 수를 기준으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; 는 자연스럽게 더 높은 차원으로 확장됩니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 2x2x2 배열 인 경우 &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; 는 3 차원 내에서 슬라이스를 정렬하여 2x2 슬라이스 &lt;code&gt;A[:, :, 1]&lt;/code&gt; 및 &lt;code&gt;A[:, :, 2]&lt;/code&gt; 를 비교 함수에 전달합니다. . 고차원 슬라이스에는 기본 순서가 없지만 &lt;code&gt;by&lt;/code&gt; 또는 &lt;code&gt;lt&lt;/code&gt; 키워드 인수를 사용하여 이러한 순서를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 은 텍스트 사양입니다. 전체 목록 &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;은 git 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; , &lt;code&gt;&amp;radic;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; SSH 연결 설정에 사용할 플래그</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; : 지정 추가 SSH 옵션, 예를 들어 &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; : 유니 코드 버전 안정성 강화</target>
        </trans-unit>
        <trans-unit id="c3f34cc201b5d8b2b94a13ec51d0f5a9bea4d457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode versioning stability (never introduce characters missing from earlier Unicode versions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; 는 TCP / IP를 통해 연결하는 작업자 프로세스의 기본 진입 점 인 내부 함수입니다. 프로세스를 Julia 클러스터 작업자로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; 는 앵커를 정규식으로 컴파일하지 않고 대신 앵커를 &lt;code&gt;match_option&lt;/code&gt; 으로 PCRE에 전달합니다 . 컴파일 시간이 상각되면 ( &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; 가 &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : 파일이 추가 / 수정 / 삭제되었는지 여부를 나타내는 &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : 파일의 상태 플래그를 포함하여 파일이 현재인지 또는 색인 또는 작업 트리에서 어떤 방식으로 변경되었는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 위치 인수로 멈추려면 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 은 위치 또는 키워드 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 은 &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;Pipe&lt;/code&gt; 또는 소켓 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 일반적으로 직접 정의해서는 안됩니다. 대신 &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; 메소드를 정의하십시오 . 경우 &lt;code&gt;string(x)&lt;/code&gt; 특정 유형의 요구에 매우 효율적으로, 다음은하는 방법을 추가하는 의미가 있습니다 &lt;code&gt;string&lt;/code&gt; 과 정의 &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; 기능이 일관되게합니다.</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; 은 &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; 를 통해 문자열로 변환 할 수있는 요소 &lt;code&gt;x&lt;/code&gt; 에 대해 반복 가능할 수 있습니다 . &lt;code&gt;strings&lt;/code&gt; 은 &lt;code&gt;io&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; : 스트립 제어 문자; 가로 탭과 용지 공급은 공백으로 변환됩니다. 개행 변환 플래그를 지정하지 않으면 개행도 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; : 유니 코드의 &quot;기본 무시할 수있는&quot;문자를 제거합니다 (예 : 소프트 하이픈 또는 왼쪽에서 오른쪽으로 마커)</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; : 발음 구별 부호 (예 : 악센트)</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; ( struct에 typedef 포함)</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 는 기본적으로 불변입니다. 이러한 유형 중 하나의 인스턴스는 구성 후에 수정할 수 없습니다. 인스턴스를 수정할 수있는 유형을 선언 하려면 &lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; (하위 타입 연산자의 반대)</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; : 테스트 용. true 인 경우 메뉴가 콘솔에 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 , 복사하는 대신 인수 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 를 제자리에서 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="5ac943a1020666f7a7da5c2717895ed9dd7a951a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 사본을 작성하는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 겹쳐 써서 공간을 절약합니다 .</target>
        </trans-unit>
        <trans-unit id="2f443b46f49f7a0ffb67743e11d80b3fef2023d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. See documentation of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; for details. ```</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; -사용 가능한 풀에서 작업자를 가져옵니다 (원격 기능 실행에 사용).</target>
        </trans-unit>
        <trans-unit id="fbcd6c4d67df75ccaec5596e95f9f2b241b36c9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;a href=&quot;#Base.fetch-Tuple%7BTask%7D&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt; on an empty, closed channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; (이 취득을하지만 값을 제거하지 않음)가 비워 질 때까지 성공적으로 기존의 값을 반환 닫힌 채널. 위의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; : 비어 있지 않으면 &lt;code&gt;workdir&lt;/code&gt; 대신이 디렉토리를 체크 아웃하십시오 .</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; : 이름을 찾기 위해 비교할 최대 파일 수입니다. 기본값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; 는 현재 작업과 관련된 키-값 저장소를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; : 충돌이있을 경우 &quot;그들&quot;의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; : 작업자가 서로 연결하는 방법을 지정합니다. 연결되지 않은 작업자간에 메시지를 보내면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; : 모든 프로세스가 서로 연결되었습니다. 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; 다음 &lt;code&gt;launch&lt;/code&gt; 클러스터 관리자의 방법은 필드를 통해 연결 토폴로지 지정 &lt;code&gt;ident&lt;/code&gt; 와 &lt;code&gt;connect_idents&lt;/code&gt; 에 &lt;code&gt;WorkerConfig&lt;/code&gt; 을 . 클러스터 관리자 신분 인 작업자 &lt;code&gt;ident&lt;/code&gt; 에 지정된 모든 근로자에 연결됩니다 &lt;code&gt;connect_idents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; : 드라이버 프로세스, 즉 &lt;code&gt;pid&lt;/code&gt; 1 만 작업자에 연결됩니다. 노동자들은 서로 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; : 새 분기가 추적해야하는 원격 분기의 이름입니다 (있는 경우). 비어 있으면 (기본값) 원격 지점이 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; 는 커밋을 생성하는 데 사용되는 자식 트리로, 조상과 다른 기록과의 관계를 보여줍니다. &lt;code&gt;tree&lt;/code&gt; 는 &lt;code&gt;repo&lt;/code&gt; 에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; (1)</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; 입력 결과를 변환 &lt;code&gt;T&lt;/code&gt; 를 던지고 &lt;code&gt;InexactError&lt;/code&gt; 을 값을 표현할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; 동일한 유형의 가장 가까운 정수 값을 반환 &lt;code&gt;x&lt;/code&gt; 이하일 또는보다 절대 값을 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; : 버퍼 크기를 0 길이로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; 문을 사용하면 &lt;code&gt;Exception&lt;/code&gt; 를 변수에 저장할 수도 있습니다. 다음 인위적인 예제의 두 번째 요소의 제곱근 계산 &lt;code&gt;x&lt;/code&gt; 경우 &lt;code&gt;x&lt;/code&gt; 는 달리 가정, 색인입니다 &lt;code&gt;x&lt;/code&gt; 는 실수이고 그것의 제곱근을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; : 소켓에 전송 된 패킷의 수명 (기본값 : &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (터널링 사용), &lt;code&gt;false&lt;/code&gt; (터널링 사용 안 함) 또는 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; (관리자에 기본값 사용)</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; , &lt;code&gt;bind_addr&lt;/code&gt; , &lt;code&gt;sshflags&lt;/code&gt; 및 &lt;code&gt;max_parallel&lt;/code&gt; 은 ssh 터널이 마스터 프로세스에서 작업자에게 연결해야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 SSH 터널링을 사용하여 마스터 프로세스에서 작업자에 연결합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; : 선택하지 않은 문자열</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; : 위쪽 화살표에 사용할 문자</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; : 페치 후 &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; 를 업데이트할지 여부 . 기본값은 업데이트를 수행하는 것이며 이는 정상적인 git 동작입니다.</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : 가져 오기 헤드의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : 프록시의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 정의 클러스터 관리자가 고유 한 작업자 별 정보를 저장하기 위해 userdata 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; : 제공된 경우 출력에 사용할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7d104208af9cf68b573f7feb14b42536431e64fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; 를 사용하면 모듈 또는 패키지 &lt;code&gt;Foo&lt;/code&gt; 가로드 되고 &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; 이름을 직접 사용할 수있게됩니다. 이름 은 &lt;code&gt;export&lt;/code&gt; 여부에 관계없이 도트 구문 (예 : &lt;code&gt;Foo.foo&lt;/code&gt; 으로 이름 &lt;code&gt;foo&lt;/code&gt; 에 액세스)을 통해 사용할 수도 있습니다 . 자세한 내용 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;은 모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 는 이제 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;put!&lt;/code&gt; 채널의 타입으로 변환 됩니다 ! 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="49167f4be17e10d892b6cbc7f3c57602c873f166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;var&quot;name&quot;&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; : 모든 추가 정보를 인쇄</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; : 나중에 변경되는 경우 사용중인 구조체의 버전입니다. 지금은 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; 은 검색 할 고유 값 창의 하한이고 &lt;code&gt;vu&lt;/code&gt; 는 상한입니다.</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 및 &lt;code&gt;[[noreturn]]&lt;/code&gt; 또는 &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; : 커밋이 언제 리포지토리에 작성 / 커밋 &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; &lt;/a&gt; 나타내는 TimeStruct .</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; - 원격 참조가 작성된 노드를 나타냅니다. 이것은 참조 된 기본 개체가 실제로 존재하는 노드와 다릅니다. 예를 들어 마스터 프로세스에서 &lt;code&gt;RemoteChannel(2)&lt;/code&gt; 을 호출 하면 &lt;code&gt;where&lt;/code&gt; 값이 2이고 &lt;code&gt;whence&lt;/code&gt; 값이 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; -참조가 참조하는 기본 오브젝트 / 스토리지가 실제로 존재하는 노드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 반복적으로 조건식을 평가하고 표현식이 true로 유지되는 동안 while 루프의 본문을 계속 평가합니다. while 루프에 처음 도달 할 때 조건 표현식이 false이면 본문이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )이면 Windows에서 &lt;code&gt;Cmd&lt;/code&gt; 가 실행될 때 새 콘솔 창이 표시되지 않습니다 . 콘솔이 이미 열려 있거나 Windows 이외의 시스템에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )이면 Windows에서 &lt;code&gt;Cmd&lt;/code&gt; 는 공백을 포함하는 인수를 포함하여 인수를 인용하거나 이스케이프하지 않고 프로세스에 명령 행 문자열을 보냅니다. (Windows에서 인수는 단일 &quot;명령 줄&quot;문자열로 프로그램에 전송되며 프로그램은 인수로 구문 분석해야합니다. 기본적으로 공백 또는 탭이있는 빈 인수 및 인수 는 명령에서 큰 따옴표로 묶습니다 &lt;code&gt;&quot;&lt;/code&gt; 라인 및 &lt;code&gt;\&lt;/code&gt; 또는 &lt;code&gt;&quot;&lt;/code&gt; 백 슬래시로 시작된다. &lt;code&gt;windows_verbatim=true&lt;/code&gt; ). 비표준 방식으로 자신의 명령 줄을 구문 분석 프로그램을 실행하는 데 유용합니다 비 Windows 시스템에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; , 대조에 따라 부호화 방출 할 수있다 &lt;code&gt;typeof(c)&lt;/code&gt; , 그리고 &lt;code&gt;read(io, typeof(c))&lt;/code&gt; 와 같은 인코딩 읽어야 &lt;code&gt;write&lt;/code&gt; . 새로운 &lt;code&gt;AbstractChar&lt;/code&gt; 타입은 자체적 인 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;read&lt;/code&gt; 구현을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; 는 정수 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt; 적합한 정수 타입 &lt;code&gt;T&lt;/code&gt; 의 값으로 변환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 의 비트 수입니다 . 즉, 이진 표현이 적합하도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (여기서 &lt;code&gt;&amp;sdot;&lt;/code&gt; 는 REPL에서 탭 완성 &lt;code&gt;\cdot&lt;/code&gt; 로 입력 할 수 있음 )은 &lt;code&gt;dot(x, y)&lt;/code&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; 정수 값에 대해 효율적으로 계산되는 x * 2 ^ &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 동일</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 숫자의 배열 일 수도 있습니다.이 경우 &lt;code&gt;norm&lt;/code&gt; 은 LinearAlgebra 의 일반적인 &lt;code&gt;norm&lt;/code&gt; 함수로 기본 설정되지만 &lt;code&gt;norm::Function&lt;/code&gt; 키워드 인수를 전달하여 변경 될 수 있습니다 . (숫자의 경우 &lt;code&gt;norm&lt;/code&gt; 은 &lt;code&gt;abs&lt;/code&gt; 와 같습니다 .) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 배열 일 때 &lt;code&gt;norm(x-y)&lt;/code&gt; 이 유한하지 않으면 (즉, &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; ) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 모든 요소 가 컴포넌트와 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &quot;주석 모드&quot;를 활성화합니다. &lt;code&gt;\&lt;/code&gt; 로 이스케이프 된 경우를 제외하고 공백이 활성화 되며 &lt;code&gt;#&lt;/code&gt; 은 주석 시작으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 유한 수입니다</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 무한하다</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 숫자가 아니다</target>
        </trans-unit>
        <trans-unit id="bcdade3b450aacebe7ce055923202bb9a54acb72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; 여기서 &lt;code&gt;~&lt;/code&gt; 는 시스템에서 적절한 사용자 홈입니다.</target>
        </trans-unit>
        <trans-unit id="e0376dc9fd7a8a47da8cd6fcc825a0caa36450a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;All&lt;/em&gt; functions are generic and use multiple dispatch. Argument lists don't have to follow the same template, which leads to a powerful idiom (see &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt;). Optional and keyword arguments are handled differently. Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition of a more specific method for the intersection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;코드를로드 &lt;em&gt;하기 전에&lt;/em&gt; Revise를 실행 중인지 확인하십시오. &lt;code&gt;using Revise&lt;/code&gt; 하거나 자동으로 실행되도록 구성하는 설명서를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;로그 이벤트 &lt;em&gt;작성&lt;/em&gt; 은 이벤트 발생 위치 및 포함 할 정보를 결정해야하는 모듈 작성자의 관심사입니다.</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 예제들을 복사하지 마십시오!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1da7110d00e265f94760324ffd9a23c2410b52b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implicit use&lt;/em&gt; of &lt;code&gt;x&lt;/code&gt; covers any indirect use of resources logically owned by &lt;code&gt;x&lt;/code&gt; which the compiler cannot see. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;로그 이벤트 &lt;em&gt;처리 (&lt;/em&gt; 즉, 디스플레이, 필터링, 집계 및 기록)는 여러 모듈을 협력 애플리케이션으로 통합해야하는 애플리케이션 작성자의 관심사입니다.</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;분할 및 정복&lt;/em&gt; 정렬 전략.</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;분할 및 정복&lt;/em&gt; : &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; &lt;/a&gt; 와 유사한 정렬 전략 .</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;대규모 컬렉션에 &lt;em&gt;적합한 성능&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;독립적이고 동일하게 분포 된 &lt;em&gt;iid&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;제자리&lt;/em&gt; 에 메모리.</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;메모리에 &lt;em&gt;제자리&lt;/em&gt; 에 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;안정적이지 않음&lt;/em&gt; : 동일하게 비교되는 요소의 순서를 유지하지 않습니다 (예 : 대소 문자를 무시하는 문자로 &quot;a&quot;및 &quot;A&quot;).</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;정렬 할 요소 수의 &lt;em&gt;2 차 성능&lt;/em&gt; : 작은 모음에는 적합하지만 큰 모음에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;안정&lt;/em&gt; : 동일하게 비교되는 요소의 순서를 유지합니다 (예 : 대소 문자를 무시하는 일종의 문자로 &quot;a&quot;및 &quot;A&quot;).</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;패키지 디렉토리&lt;/strong&gt; 는 서브 디렉토리로서 패키지 세트의 소스 트리를 포함하는 디렉토리이며 &lt;em&gt;내재적 환경을&lt;/em&gt; 형성 &lt;em&gt;합니다&lt;/em&gt; . 경우 &lt;code&gt;X&lt;/code&gt; 는 패키지 디렉토리의 서브 디렉토리이며, &lt;code&gt;X/src/X.jl&lt;/code&gt; 존재하고 패키지 &lt;code&gt;X&lt;/code&gt; 는 패키지 디렉토리 환경에서 사용할 수 있으며 &lt;code&gt;X/src/X.jl&lt;/code&gt; 그것을로드하는 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;프로젝트 환경&lt;/strong&gt; 은 프로젝트 파일과 선택적 매니페스트 파일이있는 디렉토리이며 &lt;em&gt;명시적인 환경을&lt;/em&gt; 형성합니다 . 프로젝트 파일은 프로젝트 직접 종속성의 이름과 ID가 무엇인지 결정합니다. 매니페스트 파일이있는 경우 모든 직접 및 간접 종속성, 각 버전의 정확한 버전 및 정확한 버전을 찾아서로드하기에 충분한 정보를 포함하여 완전한 종속성 그래프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71e41c9cbdf8ac89f9996aae247a324d7f18b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environment&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;내장 된 산술 유형 및 연산자에 대한 자동 승격&lt;/strong&gt; 대부분의 언어에서 내장 숫자 유형은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 와 같은 접두어 구문이있는 산술 연산자에 대한 피연산자로 사용되는 경우 예상 결과를 자동으로 일반 유형으로 승격합니다. C는, 자바, 펄, 및 Python, 몇 가지 이름을 모두 정확하게 계산 합 &lt;code&gt;1 + 1.5&lt;/code&gt; 부동 소수점 값 &lt;code&gt;2.5&lt;/code&gt; 에 피연산자이더라도 &lt;code&gt;+&lt;/code&gt; 를정수입니다. 이 시스템은 일반적으로 프로그래머에게 보이지는 않지만 충분히 편리하고 신중하게 설계되었습니다. 이러한 표현을 작성할 때이 승격을 의식적으로 생각하는 사람은 거의 없지만, 컴파일러와 인터프리터는 정수와 부동 소수점 이후에 더하기 전에 변환을 수행해야합니다. 포인트 값은 그대로 추가 할 수 없습니다. 이러한 자동 변환에 대한 복잡한 규칙은 필연적으로 이러한 언어에 대한 사양 및 구현의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 설명&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 기계 우회&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;코드 포함 :&lt;/strong&gt; 예 : &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; . 포함을 사용하면 단일 소스 프로그램을 여러 소스 파일로 분할 할 수 있습니다. 표현은 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 파일의 내용을 발생 &lt;code&gt;source.jl&lt;/code&gt; 이 (가) 여기서 모듈의 전역에서 평가되는 &lt;code&gt;include&lt;/code&gt; 통화가 발생한다. 경우 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; , 여러 번 호출 &lt;code&gt;source.jl&lt;/code&gt; 여러 번 평가된다. 포함 된 경로 &lt;code&gt;source.jl&lt;/code&gt; 은 &lt;code&gt;include&lt;/code&gt; 호출이 발생한 파일을 기준으로 해석 됩니다. 소스 파일의 하위 트리를 쉽게 재배치 할 수 있습니다. REPL에서 포함 된 경로는 현재 작업 디렉토리를 기준으로 해석됩니다.&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선형 인덱스와 데카르트 인덱스 간의 변환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;커서 이동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 정의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;다른 모든 것&lt;/strong&gt; . 다른 주장들.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="19683dd3d8903f638a6b291d6c9f28ca79e6c660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Existing local:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;already a local variable&lt;/em&gt;, then the existing local &lt;code&gt;x&lt;/code&gt; is assigned;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;외부 링크&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부동 소수점 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;함수 인수&lt;/strong&gt; . 함수 인수를 먼저 넣으면 여러 줄 익명 함수를 전달하기 위해 &lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt; 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec40a2f0a30b472e6c7208cfd9385764834e554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named &lt;code&gt;x&lt;/code&gt; is created in the scope of the assignment;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 높은 차원의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 큰 치수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;I / O를 스트림&lt;/strong&gt; . 시방 &lt;code&gt;IO&lt;/code&gt; 의 첫번째 목적은 다음과 같은 기능을 할 수있는 기능을 전달 가능하게 &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; &lt;/a&gt; 예 &lt;code&gt;sprint(show, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중요한 선택적 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력이 변경되고&lt;/strong&gt; 있습니다. 예를 위해, &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; 변이되는 목적 및 값에 삽입하기 전에이 표시 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력이 변경되지 않았습니다&lt;/strong&gt; . 에서 &lt;code&gt;fill!(x, v)&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 변이되고 그것은 뒤에 오는 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정수 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;키&lt;/strong&gt; . 연관 컬렉션의 경우 키-값 쌍의 키입니다. 다른 인덱스 컬렉션의 경우 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키워드 인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;키워드 인수&lt;/strong&gt; . Julia에서 키워드 인수는 함수 정의에서 마지막에 와야합니다. 완전성을 위해 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;비누 거품. 헹구기. 반복. &lt;/strong&gt; &lt;code&gt;julia&lt;/code&gt; 명령 프롬프트 에서 아이디어를 탐색하십시오 . &lt;code&gt;tst.jl&lt;/code&gt; 에 좋은 아이디어를 저장하십시오 . &lt;code&gt;tst.jl&lt;/code&gt; 이 변경된 후에 실행하려면 다시 &lt;code&gt;include&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;자동 프로모션이 없습니다. &lt;/strong&gt;이 캠프에는 Ada 및 ML이 포함됩니다. 매우 &quot;엄격한&quot;정적 유형 언어입니다. 이러한 언어에서는 프로그래머가 모든 변환을 명시 적으로 지정해야합니다. 따라서 식 &lt;code&gt;1 + 1.5&lt;/code&gt; 의 예 는 Ada와 ML 모두에서 컴파일 오류입니다. 대신 &lt;code&gt;real(1) + 1.5&lt;/code&gt; 추가하기 전에 정수 &lt;code&gt;1&lt;/code&gt; 을 부동 소수점 값 으로 명시 적으로 변환하여 real (1) + 1.5를 작성해야합니다 . 그러나 모든 곳에서 명시 적 변환은 매우 불편하므로 Ada조차도 어느 정도의 자동 변환이 가능합니다. 정수 리터럴은 예상되는 정수 유형으로 자동 승격되고 부동 소수점 리터럴은 적절한 부동 소수점 유형으로 유사하게 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비 전통적인 지수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;libgit2&lt;/code&gt; 인증 절차 의 특성상 인증이 실패하면 인증 성공 여부를 알리지 않고이 함수가 다시 호출됩니다. 무한 루프가 동일한 잘못된 자격 증명을 반복적으로 사용하는 것을 방지하기 위해 페이로드를 사용하여 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 섹션에서는 Unix와 유사한 운영 체제에서 C로 Julia 코드를 임베드하는 방법에 대해 설명합니다. Windows에서이 작업을 수행하려면 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선택적 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;패키지 로딩 :&lt;/strong&gt; 예 &lt;strong&gt;: &lt;/strong&gt; &lt;code&gt;import X&lt;/code&gt; 또는 &lt;code&gt;using X&lt;/code&gt; . 가져 오기 메커니즘을 사용하면 패키지 (즉, 모듈에 싸여있는 독립적이고 재사용 가능한 Julia 코드 모음)를로드 하고 가져 오기 모듈 내부 에서 이름 &lt;code&gt;X&lt;/code&gt; 로 결과 모듈을 사용할 수 있습니다 . 동일한 Julia 세션에서 동일한 &lt;code&gt;X&lt;/code&gt; 패키지를 여러 번 가져 오는 경우, 처음 가져올 때만로드됩니다. 후속 가져 오기에서 가져 오기 모듈은 동일한 모듈에 대한 참조를 가져옵니다. 하는 것으로, 비록 &lt;code&gt;import X&lt;/code&gt; 서로 다른 상황에서 다른 패키지를로드 할 수 있습니다 : &lt;code&gt;X&lt;/code&gt; 는 이름이 하나 개의 패키지를 참조 할 수 있습니다 &lt;code&gt;X&lt;/code&gt; 를 명명 된 다른 패키지에 잠재적으로 주요 프로젝트에 있지만 &lt;code&gt;X&lt;/code&gt; 각 의존성에서. 이에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로그램 제어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;임시 모듈에 개발중인 코드를 넣습니다. &lt;/strong&gt; &lt;code&gt;Tmp.jl&lt;/code&gt; 이라는 파일을 만들고 그 안에 포함하십시오</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;테스트 코드를 다른 파일에 넣으십시오. &lt;/strong&gt; &lt;code&gt;tst.jl&lt;/code&gt; 과 같은 다른 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="762b0b987efcf101541560526e8d90e402907514" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;References&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;References&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한보십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36121b3eefd78b60d0003f60318af0689a90639e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Soft scope:&lt;/strong&gt; If &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;not already a local variable&lt;/em&gt; and all of the scope constructs containing the assignment are soft scopes (loops, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; blocks, or &lt;code&gt;struct&lt;/code&gt; blocks), the behavior depends on whether the global variable &lt;code&gt;x&lt;/code&gt; is defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3021827c46a7ed515f5246c6017d78d244ed6bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Dependent Types&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608f32cb9eef948fcb1ef6e535b6635c88420101" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent Types&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시스템 독립적 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 디렉토리 &lt;strong&gt;의 종속성 그래프&lt;/strong&gt; 는 각 패키지의 하위 디렉토리에있는 프로젝트 파일의 존재 여부와 내용에 따라 결정됩니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 환경 &lt;strong&gt;의 종속성 그래프&lt;/strong&gt; 는 존재하는 경우 매니페스트 파일의 내용에 따라 결정됩니다. 매니페스트 파일이 없으면 그래프가 비어 있습니다. 매니페스트 파일에는 각 프로젝트의 직접 또는 간접 종속성에 대한 스탠자가 포함되어 있습니다. 각 종속성에 대해 파일은 패키지의 UUID와 소스 트리 해시 또는 소스 코드의 명시 적 경로를 나열합니다. &lt;code&gt;App&lt;/code&gt; 에 대한 다음 매니페스트 파일 예제를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여기서 핵심은 Julia 코드는 내부적으로 언어 자체에서 액세스 할 수있는 데이터 구조로 표현된다는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;패키지 디렉토리 &lt;strong&gt;의 경로 맵&lt;/strong&gt; 은 간단합니다. 하위 디렉토리 이름을 해당 진입 점 경로에 맵핑합니다. 즉, 예제 프로젝트 디렉토리의 경로가 &lt;code&gt;/home/me/animals&lt;/code&gt; 인 경우 &lt;code&gt;paths&lt;/code&gt; 맵은이 사전으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 환경 &lt;strong&gt;의 경로 맵&lt;/strong&gt; 은 매니페스트 파일에서 추출됩니다. &lt;code&gt;X&lt;/code&gt; 라는 패키지 &lt;code&gt;uuid&lt;/code&gt; 의 경로는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;루트 맵&lt;/strong&gt; 은 존재하는 모든 패키지 목록을 생성하기 위해 패키지 디렉토리의 내용을 검사하여 결정됩니다. 또한 UUID는 다음과 같이 각 항목에 할당됩니다. &lt;code&gt;X&lt;/code&gt; 폴더 안에있는 지정된 패키지의 경우 ...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;환경 &lt;strong&gt;의 루트 맵&lt;/strong&gt; 은 프로젝트 파일의 내용, 특히 최상위 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;uuid&lt;/code&gt; 항목 및 &lt;code&gt;[deps]&lt;/code&gt; 섹션 (모두 선택 사항)에 따라 결정됩니다. 앞에서 설명한 가상 응용 프로그램 &lt;code&gt;App&lt;/code&gt; 에 대한 다음 예제 프로젝트 파일을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;을 입력하십시오&lt;/strong&gt; . 유형을 전달하면 일반적으로 출력에 지정된 유형이 있음을 의미합니다. 에서 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt; 문자열을 구문 분석하기 전에, 유형 온다. 유형이 먼저 나타나는 많은 예제가 있지만 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;IO&lt;/code&gt; 인수가 유형 앞에 나타나고 여기에 설명 된 순서에 따라 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="b586fc911b064b4cf7b9cf3a61a4f379ea0edfb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use in broadcasting&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eab55c50210340cd0c0df6a7519baa6abc6fcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;가치&lt;/strong&gt; . 연관 콜렉션의 경우 이는 키-값 쌍의 값입니다. &lt;code&gt;fill!(x, v)&lt;/code&gt; 와 같은 경우 이것은 &lt;code&gt;v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Varargs&lt;/strong&gt; . 이것은 함수 호출 끝에 무기한으로 나열 될 수있는 인수를 나타냅니다. 예를 들어, &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; 에서 차원은 &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; , 예를 들어 &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; 또는 &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; 로 제공 될 수 있습니다 ( 예 : &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떤 코드가 생성됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다음은 어떻게됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;그래프 : &lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; uu &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;경로 : &lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;뿌리 : &lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;전&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">@threadcall (실험)</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">지원되는 &lt;code&gt;isbits&lt;/code&gt; 요소 유형을 가진 인스턴스 가이 메모리 레이아웃을 예상하는 외부 C 및 Fortran 함수에 전달 될 수 있도록 &quot;분할 된&quot;배열은 규칙적인 오프셋에 배치 된 요소와 함께 메모리에 저장됩니다 . 스트라이드 된 배열은 각 차원에 대해 &quot;스트라이드&quot;의 튜플을 반환 하는 &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt; 메서드를 정의해야 합니다. 제공된 &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; 메소드는 이 튜플 내의 &lt;code&gt;k&lt;/code&gt; 번째 요소에 액세스합니다 . 차원의 인덱스 증가 &lt;code&gt;k&lt;/code&gt; 하여 &lt;code&gt;1&lt;/code&gt; 은 인덱스를 증가시켜야 &lt;code&gt;i&lt;/code&gt; 들 &lt;code&gt;getindex(A,i)&lt;/code&gt; 에서 &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; . 포인터 변환 방법 &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;메모리 레이아웃은 이러한 보폭과 동일한 방식으로 일치해야합니다. &lt;code&gt;DenseArray&lt;/code&gt; 는 요소가 연속적으로 배열되는 스트라이드 배열의 매우 구체적인 예이므로 하위 유형에 적절한 &lt;code&gt;strides&lt;/code&gt; 정의를 제공합니다 . 더 구체적인 예제는 &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided arrays 인터페이스 안내서&lt;/a&gt; 에서 찾을 수 있습니다 . &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt; 는 스트라이드 배열로 간주되는 많은 내장 배열 유형의 편리한 별칭으로 포인터와 보폭 만 사용하여 고도로 조정되고 최적화 된 BLAS 및 LAPACK 함수를 호출하는 특수한 구현을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b06ef311fe65245308768dcdeb585be5facb485c" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;view&amp;rdquo; is a data structure that acts like an array (it is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;), but the underlying data is actually part of another array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">A (모두)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; 는&lt;/a&gt; A를 벗겨됩니다 &lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; 의&lt;/a&gt; 연산자는 스칼라 배 정체성 연산자 나타내는 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . ID 연산자 &lt;code&gt;I&lt;/code&gt; 는 상수로 정의되며 &lt;code&gt;UniformScaling&lt;/code&gt; 의 인스턴스입니다 . 이 연산자의 크기는 일반적이며 이진 연산 &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 의 다른 행렬과 일치합니다 . 들어 &lt;code&gt;A+I&lt;/code&gt; 와 &lt;code&gt;A-I&lt;/code&gt; 이 의미하는 &lt;code&gt;A&lt;/code&gt; 는 사각형이어야합니다. 아이덴티티 연산자 &lt;code&gt;I&lt;/code&gt; 과의 곱셈 은 스눕 (스케일링 팩터가 1인지 확인하는 것을 제외)이므로 오버 헤드가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">&lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; 값을 설정 하는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 입니다 (기본값 : &lt;code&gt;60.0&lt;/code&gt; ). 이 기능은 작업자 프로세스가 종료되기 전에 마스터 프로세스가 연결을 설정하기를 기다리는 시간 (초)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 처음 열린 상태입니다. 즉, &lt;code&gt;take!&lt;/code&gt; 를 통해 자유롭게 읽고 쓸 수 있습니다! 그리고 &lt;code&gt;put!&lt;/code&gt; 전화. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;닫 습니다 . 닫힌 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;put!&lt;/code&gt; 실패합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 과정에 지역이다. 작업자 2는 작업자 3 의 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 을 직접 참조 할 수 없으며 그 반대도 마찬가지입니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 는&lt;/a&gt; 그러나 넣고 근로자에 걸쳐 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 는&lt;/a&gt; A와 생각 될 수 &lt;em&gt;핸들&lt;/em&gt; A와 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">간격 &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ) 의 비율로 요소가 지수 적으로 증가하는 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 반복자입니다 . 첫 번째 요소는 &lt;code&gt;first_delay&lt;/code&gt; 이고 모든 요소는 &lt;code&gt;max_delay&lt;/code&gt; 로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eff87e10245c4721bd18e0368a4c02ba6a49f3c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair (most common),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">&lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; 리터럴 상수로 기록되어야 쌍,</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;(name, library)&lt;/code&gt; 기능 사양은 상수 표현식이어야합니다. 그러나 다음과 같이 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 통해 스테이징하여 계산 된 값을 함수 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 열의 헤더 분리기의 양쪽 끝에있는 문자 (포함 된 행 &lt;code&gt;-&lt;/code&gt; 자) 행이 우측 정렬 또는 좌측 정렬되어 있는지 여부를 지정 (시 &lt;code&gt;:&lt;/code&gt; 양단에 나타나는) 가운데 맞춤. no &lt;code&gt;:&lt;/code&gt; 문자를 제공 하면 기본적으로 열이 오른쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">&lt;code&gt;BufferStream&lt;/code&gt; 는 메모리 내이다 &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 처럼 동작 &lt;code&gt;IO&lt;/code&gt; - 그것은 비동기 적으로 처리 될 수있는 스트림이다.</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CartesianIndex&lt;/code&gt; 는 때때로에 의해 생성된다 &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; , 항상 명시 적으로 반복 할 때 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">&lt;code&gt;Channel&lt;/code&gt; A의 반복 가능 객체로 사용될 수 &lt;code&gt;for&lt;/code&gt; 루프만큼으로 실행되는 경우에 루프 &lt;code&gt;Channel&lt;/code&gt; 데이터를 갖거나 열려있다. 루프 변수는 &lt;code&gt;Channel&lt;/code&gt; 추가 된 모든 값을받습니다 . &lt;code&gt;for&lt;/code&gt; 한 번 루프는 종료 &lt;code&gt;Channel&lt;/code&gt; 폐쇄 비워집니다.</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 이 특수 문자 표시와 해당 연산 동작과 단지 32 비트의 프리미티브 타입이고, 이는이 표현하는 숫자 값으로 변환 될 수있다 : 값은 단일의 문자를 나타내는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; . (Julia 패키지는 다른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;텍스트 인코딩에&lt;/a&gt; 대한 작업을 최적화하기 위해 &lt;code&gt;AbstractChar&lt;/code&gt; 의 다른 하위 유형을 정의 할 수 있습니다 .) 다음은 &lt;code&gt;Char&lt;/code&gt; 값이 입력되고 표시되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;CompoundPeriod&lt;/code&gt; 이 작은 기간의 고정 된 다중하지 않은 기간을 표현하는 데 유용하다. 예를 들어, &quot;일과 일&quot;은 고정 된 일수가 아니라 &lt;code&gt;CompoundPeriod&lt;/code&gt; 를 사용하여 표현할 수 있습니다 . 실제로 &lt;code&gt;CompoundPeriod&lt;/code&gt; 는 다른 기간 유형을 추가하여 자동으로 생성됩니다. 예를 들어 &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; 는 &lt;code&gt;CompoundPeriod&lt;/code&gt; 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 추상적 또는 구체적으로 할 수있다. 콘크리트 인 경우 지정된 크기, 스토리지 레이아웃 및 (선택적) 필드 이름이 있습니다. 따라서 기본 유형은 크기가 0이지만 필드 이름이없는 &lt;code&gt;DataType&lt;/code&gt; 입니다. 복합 유형은 필드 이름이 있거나 비어있는 (0 크기) &lt;code&gt;DataType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8254718d7cf35196b57a0c256656d29ca6967f68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Future&lt;/code&gt; is a placeholder for a single computation of unknown termination status and time. For multiple potential computations, see &lt;code&gt;RemoteChannel&lt;/code&gt;. See &lt;code&gt;remoteref_id&lt;/code&gt; for identifying an &lt;code&gt;AbstractRemoteRef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitCommit&lt;/code&gt; 는 A를 벗겨됩니다 &lt;code&gt;GitTree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">&lt;code&gt;GitRevWalker&lt;/code&gt; 는&lt;em&gt;산책&lt;/em&gt; 관통 &lt;em&gt;개정&lt;/em&gt; 자식 저장소 (즉, 커밋) &lt;code&gt;repo&lt;/code&gt; . 리포지토리의 커밋 모음이며 반복 및 &lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 호출을 지원합니다 (예를 들어, &lt;code&gt;count&lt;/code&gt; 는 리포지토리의 커밋 비율을 특정 작성자가 결정한 비율을 결정하는 데 사용될 수 있음).</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">&lt;code&gt;GitTag&lt;/code&gt; 가 참조하는 객체에 벗겨됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecaf0ba8d28df22c60ef1b5589bb9e3a4cbe6da" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Hessenberg&lt;/code&gt; object represents the Hessenberg factorization &lt;code&gt;QHQ'&lt;/code&gt; of a square matrix, or a shift &lt;code&gt;Q(H+&amp;mu;I)Q'&lt;/code&gt; thereof, which is produced by the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">&lt;code&gt;MIME&lt;/code&gt; 의 목적은 두 번째 인수로서 전달 될 수있는 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; 하는 포맷 요청 출력한다.</target>
        </trans-unit>
        <trans-unit id="bd67479c52c92dddc64ec714d9c7069f1b10867a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; 또는 &lt;code&gt;RandomDevice&lt;/code&gt; : RNG는 다음과 같은 종류의 균일 한 난수를 발생시킬 수 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; (또는 복소수 그 유형의). 임의의 부동 소수점 숫자는 $ [0, 1) $에 균일하게 생성됩니다. 로 &lt;code&gt;BigInt&lt;/code&gt; 제한없는 정수를 나타내려면 간격을 지정해야합니다 (예 : &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="93e7981a3162e9783d86dcf2247127a2e48a689e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 별도의 전역 변수 작업 공간입니다. 자세한 내용은 &lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7ec3daecca2c04b2bae1c27f0094a5422da6aa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;N&lt;/code&gt;-dimensional custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexCartesian&lt;/code&gt; needs to implement indexing (and indexed assignment) with exactly &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices; all other indexing expressions &amp;mdash; including linear indexing &amp;mdash; will be recomputed to the equivalent Cartesian location. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with cartesian indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt;, this would be recomputed to the equivalent Cartesian index and call &lt;code&gt;A[1, 3]&lt;/code&gt; since &lt;code&gt;5 = 2*1 + 3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; 의 유형은 하나의 튜플 인수를 받아들이는 생성자로 사용할 수 있습니다. 생성 된 &lt;code&gt;NamedTuple&lt;/code&gt; 유형은 두 매개 변수가 모두 지정된 구체적 유형이거나 필드 이름 만 지정하는 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">&lt;code&gt;Polar&lt;/code&gt; 객체는 지원의 HTML 표시하는 환경에서 HTML을 사용하여 자동으로 표시됩니다,하지만 당신은 호출 할 수 있습니다 &lt;code&gt;show&lt;/code&gt; 원하는 경우 GET HTML 출력에 수동 :</target>
        </trans-unit>
        <trans-unit id="3992f5106e091bf1a1db28341609bec19be4cafd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VersionNumber&lt;/code&gt; 줄리아의 버전을 나타내는 개체가 사용된다. 자세한 내용은 &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;버전 번호 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b5d6ebeedad778839a920e823243163f3ccd68a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">A는 &lt;code&gt;do&lt;/code&gt; 포위 범위에서 수 &quot;캡처&quot;변수 다른 내부 기능처럼, 블록. 예를 들어, 위의 &lt;code&gt;open...do&lt;/code&gt; 예제의 변수 &lt;code&gt;data&lt;/code&gt; 는 외부 범위에서 캡처됩니다. 캡처 된 변수는 &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 에서 설명한대로 성능 문제를 일으킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 또는 이해의 반복 변수는 항상 새로운 변수입니다 :</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 확장하지 않고, 기본적으로 파일의 기본 이름으로 설정되는 이벤트에 대한. 이는 메시지를 로그 레벨보다 세밀하게 범주 (예 : 모든 폐기 경고에 group &lt;code&gt;:depwarn&lt;/code&gt; 이 있음 ) 또는 모듈 전체 또는 모듈 내에서 논리적 그룹으로 그룹화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 문에 의해 발생 오류 (예외) 차단 할 수 있습니다 &lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; 그 프로그램의 실행을 계속할 수 있도록합니다. 예를 들어 다음 코드는 파일을 쓰려고 시도하지만 파일을 쓸 수없는 경우 실행을 종료하는 대신 사용자에게 경고하고 진행합니다.</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">&lt;em&gt;패키지는&lt;/em&gt; 다른 줄리아 프로젝트에 재사용 할 수있는 표준 레이아웃을 제공하는 기능을 가진 소스 트리입니다. 패키지는 &lt;code&gt;import X&lt;/code&gt; 또는 &lt;code&gt;using X&lt;/code&gt; 문을 사용하여 로드됩니다 . 이 명령문은 또한 패키지 이름 을로드 한 결과 &lt;code&gt;X&lt;/code&gt; 라는 모듈을 import 문이 발생하는 모듈 내에서 사용할 수있게합니다. &lt;code&gt;import X&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 에서 X 의 의미 는 상황에 따라 다릅니다. 어떤 &lt;code&gt;X&lt;/code&gt; 패키지가로드되는지는 명령문이 어떤 코드에 따라 달라집니다. 따라서 &lt;code&gt;import X&lt;/code&gt; 처리는 두 단계로 이루어집니다. 먼저, &lt;code&gt;X&lt;/code&gt; 로 정의 된 패키지를 결정 &lt;strong&gt;합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;이 맥락에서; 둘째, 특정 &lt;code&gt;X&lt;/code&gt; 패키지가 &lt;strong&gt;있는 위치&lt;/strong&gt; 를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">&lt;code&gt;Cvoid&lt;/code&gt; 를 반환하도록 선언 된 AC 함수는 Julia에서 &lt;code&gt;nothing&lt;/code&gt; 값 도 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="390614814aa5adb2a2fccf6c0c90c7149f4d96ba" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">기본 문자 유형 &lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt; 로 구성된 C 스타일 문자열 입니다. &lt;code&gt;Cstring&lt;/code&gt; 은 NUL로 종료됩니다. 기본 와이드 문자 유형으로 구성된 C 스타일 문자열은 &lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . C와의 문자열 상호 운용성에 대한 자세한 내용은 &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18521ba47ad36cc4f8c112bae48ca35ecb2ee122" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">기본 와이드 문자 유형 &lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; 로 구성된 C 스타일 문자열 입니다. &lt;code&gt;Cwstring&lt;/code&gt; 은 NUL로 종료됩니다. 기본 문자 유형으로 구성된 C 스타일 문자열은 &lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . C와의 문자열 상호 운용성에 대한 자세한 내용은 &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c197fd05f688124d54264f0b58fc3c22d93ec77c" translate="yes" xml:space="preserve">
          <source>A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexCartesian&lt;/code&gt; will return a range of &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">A 회전 선형 연산자를 제공합니다. 필드 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;s&lt;/code&gt; 는 각각 회전 각도의 코사인과 사인을 나타냅니다. &lt;code&gt;Givens&lt;/code&gt; 형 지지체 승산 왼쪽 &lt;code&gt;G*A&lt;/code&gt; 과 승산 공액 전치 오른쪽 &lt;code&gt;A*G'&lt;/code&gt; . 형식은없는 &lt;code&gt;size&lt;/code&gt; 때문에 긴만큼 임의의 크기의 행렬과 곱해질 수 &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; 에 대한 &lt;code&gt;G*A&lt;/code&gt; 또는 &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; 에 대한 &lt;code&gt;A*G'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">줄리아 함수</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">Julia 클러스터에는 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46f55d05b4cea9eeb2d26c893736aefe4db768d" translate="yes" xml:space="preserve">
          <source>A Julia function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">Julia 스크립트는 여러 함수를 포함 할 수 있으며 파일이로드 될 때 모든 정의를 외부에서 볼 수 있습니다. 기능 정의는 현재 작업 디렉토리 외부의 파일에서로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">연결 프로토콜을 통해 다른 자격 증명 획득 기능을 제공하는 LibGit2 자격 증명 콜백 기능. &lt;code&gt;payload_ptr&lt;/code&gt; 는 포함 할 필요가 &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; 의 상태 및 설정을 추적 할 개체를.</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">문자열 배열의 LibGit2 표현입니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">컴팩트 블록 형식으로 저장된 QR 매트릭스 인수 분해는 일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻습니다 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">팩 형식으로 저장된 QR 매트릭스 인수 분해는 일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻습니다 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻은 압축 형식의 열 피벗을 사용한 QR 행렬 인수 분해 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">기본 편집기 / REPL 워크 플로우</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OS 파일 디스크립터를 랩핑하는 버퍼 된 IO 스트림. 대부분 &lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; 에서&lt;/a&gt; 반환 한 파일을 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 호출하면 &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; 의 벡터가 반환되며 , 번역을 위해 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 추적 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데카르트 인덱싱 스타일은 배열에서 위치를 설명하기 위해 여러 정수 / 인디 케이트를 사용합니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 직교 인덱스 를 사용하는 &lt;code&gt;(2, 3, 4)&lt;/code&gt; 커스텀 행렬 유형 인 경우 &lt;code&gt;A[2, 1, 3]&lt;/code&gt; 참조 할 수 있으며 Julia는이를 기본 메모리의 올바른 위치로 자동 변환합니다. &lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">채널은 파이프로 시각화 할 수 있습니다. 즉, 쓰기 끝과 읽기 끝이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">전형적인 예는 다음 과 같이 선언 된 표준 C 라이브러리 &lt;code&gt;qsort&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">&lt;code&gt;--machine-file&lt;/code&gt; 옵션을 사용하는 클러스터 스패닝 머신 . 비밀번호없는 &lt;code&gt;ssh&lt;/code&gt; 로그인을 사용 하여 지정된 시스템에서 Julia 작업자 프로세스 (현재 호스트와 동일한 경로에서)를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">쉘을 통해 외부 프로그램을 실행할 때의 일반적인 함정은 파일 이름에 쉘에 특수 문자가 포함되어 있으면 원하지 않는 동작이 발생할 수 있다는 것입니다. 예를 들어 &lt;code&gt;/etc/passwd&lt;/code&gt; 가 아니라 &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; 파일의 내용을 정렬하려고 한다고 가정 합니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">변수의 일반적인 사용은 변경되지 않은 특정 값에 이름을 지정하는 것입니다. 이러한 변수는 한 번만 할당됩니다. 이 의도는 &lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 컴파일러에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">모든 문서화 가능한 Julia 구문에 대한 포괄적 인 개요.</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; 을 구현 하려면 &lt;code&gt;AbstractChannel&lt;/code&gt; ( &lt;code&gt;Channel&lt;/code&gt; 과 같은 )을 구체적으로 구현 해야합니다 . , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; 및 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 참조하는 원격 객체 는 &lt;code&gt;Channel{Any}(1)&lt;/code&gt; , 즉 &lt;code&gt;Any&lt;/code&gt; 유형의 객체를 보유 할 수있는 크기 1 의 &lt;code&gt;Channel&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">생성자는 전체 동작이 메소드의 결합 된 동작에 의해 정의된다는 점에서 Julia의 다른 함수와 같습니다. 따라서 단순히 새로운 메소드를 정의하여 생성자에 기능을 추가 할 수 있습니다. 예를 들어, 하나의 인수 만 사용하고 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 필드 모두에 대해 주어진 값을 사용하는 &lt;code&gt;Foo&lt;/code&gt; 오브젝트에 대한 생성자 메소드를 추가하려고한다고 가정하십시오 . 이것은 간단하다 :</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt; 유형 을 작성하기위한 편리한 매크로로 , 일반적으로 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; 할 메소드를 추가 할 때 사용됩니다 . 예를 들어 구문 &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; 을 사용하여 &lt;code&gt;MyType&lt;/code&gt; 의 HTML 표현을 작성하는 방법을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70c4d119efcef0d9d58b6c1b731caa5e0cea492c" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;Point{T}&lt;/code&gt; 유형의 모든 인수를 허용하는 메소드를 정의하는 올바른 방법 : 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">새로운 사용자를 시작하는 데 도움이되는 유용한 학습 자료의 목록은 기본 Julia 웹 사이트 의 &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;학습&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="195192cf6a65111d3220eb69daad42095c4bb54b" translate="yes" xml:space="preserve">
          <source>A custom array that reports its &lt;code&gt;IndexStyle&lt;/code&gt; as &lt;code&gt;IndexLinear&lt;/code&gt; only needs to implement indexing (and indexed assignment) with a single &lt;code&gt;Int&lt;/code&gt; index; all other indexing expressions &amp;mdash; including multidimensional accesses &amp;mdash; will be recomputed to the linear index. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;2&amp;times;3&lt;/code&gt; custom matrix with linear indexing, and we referenced &lt;code&gt;A[1, 3]&lt;/code&gt;, this would be recomputed to the equivalent linear index and call &lt;code&gt;A[5]&lt;/code&gt; since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eda7036e705b5b4e6080ae4d063390e3d333bd8" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. For that standard types (&lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;... etc_, if no title text is specified after the admonition type, then the type title used will be the type of the block. E.g. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">상자에 대한 사용자 정의 제목은 훈계 유형 뒤에 문자열 (큰 따옴표)로 제공 될 수 있습니다. 훈계 유형 뒤에 제목 텍스트가 지정되지 않은 경우, 사용 된 제목은 블록의 유형이됩니다 (예 를 들어, 훈계 &lt;code&gt;note&lt;/code&gt; 의 경우 &lt;code&gt;&quot;Note&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">libgit2에서 데이터를 내보내기위한 데이터 버퍼 &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">더 이상 사용되지 않는 함수는 내부적으로 관련 경고를 한 번만 인쇄하기 위해 조회를 수행합니다. 이 추가 조회는 상당한 속도 저하를 일으킬 수 있으므로 사용되지 않는 기능의 모든 사용은 경고에서 제안한대로 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="30d96d8ddfc84bb803bea097ec17d062d6889473" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">초기 활성 프로젝트 여야하는 프로젝트를 나타내는 디렉토리 경로. 이 환경 변수를 설정하면 &lt;code&gt;--project&lt;/code&gt; 시작 옵션 을 지정하는 것과 동일한 효과 가 있지만 &lt;code&gt;--project&lt;/code&gt; 가 우선 순위가 높습니다. 변수가 &lt;code&gt;@.&lt;/code&gt; 로 설정된 경우 그런 다음 Julia는 현재 디렉토리와 상위 디렉토리에서 &lt;code&gt;Project.toml&lt;/code&gt; 또는 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 파일 이 포함 된 프로젝트 디렉토리를 찾으려고 합니다. &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;코드 로딩&lt;/a&gt; 에 관한 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">다음과 같은 형식의 루프 용 병렬 분산 메모리 :</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">헤더를 사용하여 문서를 다른 섹션으로 나눌 수 있습니다. 헤더는 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">스케줄의 빠른 불공정 스케줄 버전 &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; 스케줄러를 호출하기 전에 즉시 &lt;code&gt;t&lt;/code&gt; 를 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">참고할 몇 가지 일반적인 규칙 :</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">알아야 할 몇 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">하스켈, 스칼라, 루비를 포함한 몇몇 인기있는 언어는 싱글 톤 타입을 가지고 있습니다. 일반적으로 &quot;단일 유형&quot;이라는 용어는 인스턴스가 단일 값인 유형을 나타냅니다. 이 의미는 Julia의 싱글 톤 유형에 적용되지만 유형 객체에만 싱글 톤 유형이 있다는주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">명확하지 않은 이름을 가진 함수에 대한 호출에 해당하는 몇 가지 특수 표현식이 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">시작시 &lt;code&gt;-L&lt;/code&gt; 플래그를 사용하여 여러 프로세스에 파일을 사전로드 할 수 있으며 드라이버 스크립트를 사용하여 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a01e3bc84b099bc13fd4194e7a227e1495a2f3" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">탭 완성의 전체 목록은 설명서 의 &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;유니 코드 입력&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석 및 형식화 테스트 및 예제의 전체 세트는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">Julia 객체 &lt;code&gt;x&lt;/code&gt; 의 가장 풍부한 멀티미디어 디스플레이를 요청 하는 함수 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; (일반 텍스트 폴백 포함).</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">전통적인 괄호 구문을 사용하여 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">함수 이름은 튜플 대신 단독으로 사용될 수 있습니다 (단지 &lt;code&gt;:function&lt;/code&gt; 또는 &lt;code&gt;&quot;function&quot;&lt;/code&gt; ). 이 경우 이름은 현재 프로세스 내에서 확인됩니다. 이 양식은 C 라이브러리 함수, Julia 런타임의 함수 또는 Julia에 링크 된 애플리케이션의 함수를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">함수 서명 :</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">반환 유형이 선언 된 함수는 반환 값을 해당 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fff933fe03507e0a69f0bb2eb791a7b5f8b176b4" translate="yes" xml:space="preserve">
          <source>A functional programming style is fully supported by the language, including closures, but isn't always the idiomatic solution for Julia. Some &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;workarounds&lt;/a&gt; may be necessary for performance when modifying captured variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">sha-1 해시에 기반한 자식 객체 식별자. 리포지토리에서 &lt;code&gt;GitObject&lt;/code&gt; 를 식별하는 데 사용되는 20 바이트 문자열 (40 개의 16 진수) 입니다.</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">지정된 &lt;code&gt;AbstractChar&lt;/code&gt; 하위 유형은 유니 코드의 하위 집합 만 나타낼 수 있으며,이 경우 지원되지 않는 &lt;code&gt;UInt32&lt;/code&gt; 값 에서 변환 하면 오류가 발생할 수 있습니다. 반대로 내장 &lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; 유형은 유니 코드 의 &lt;em&gt;수퍼 세트&lt;/em&gt; (유효하지 않은 바이트 스트림을 손실없이 인코딩하기 위해)를 나타내며,이 경우 비 유니 코드 값 &lt;em&gt;을 &lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; 로 변환 하면 오류가 발생합니다. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt; 함수는 주어진에서 표현할 수있는 코드 포인트를 확인하는 데 사용될 수 &lt;code&gt;AbstractChar&lt;/code&gt; 의 유형.</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">전역 변수는 값을 가질 수 있으므로 유형은 언제든지 변경 될 수 있습니다. 이로 인해 컴파일러가 전역 변수를 사용하여 코드를 최적화하기가 어렵습니다. 변수는 로컬이거나 가능할 때마다 함수의 인수로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Julia의 가장 큰 장점은 I / O가 실제로 비동기 적으로 발생하더라도 API가 동 기적으로 노출되므로 콜백에 대해 걱정하거나 서버가 실행되도록 보장 할 필요가 없다는 것입니다. 우리가 &lt;code&gt;connect&lt;/code&gt; 를 호출 하면 현재 작업은 연결이 설정되기를 기다렸다가 그 후에 만 ​​실행을 계속했습니다. 이 일시 정지에서, 서버 태스크는 실행을 재개하고 (연결 요청이 사용 가능하므로) 연결을 승인하고 메시지를 인쇄 한 후 다음 클라이언트를 기다렸습니다. 읽기와 쓰기는 같은 방식으로 작동합니다. 이것을 보려면 다음의 간단한 에코 서버를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="31c1ae4c7c3a38a0afd976393219aa6a44dd785b" translate="yes" xml:space="preserve">
          <source>A hard-coded &lt;a href=&quot;../base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; of common array types that follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays&quot;&gt;strided array interface&lt;/a&gt;, with elements of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">헤더 행은 단락과 동일한 방식으로 인라인 구문을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 하위 유형 을 정의하는 데있어 핵심적인 부분 은 &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; 입니다. 인덱싱은 배열의 중요한 부분이며 종종 핫 루프에서 발생하기 때문에 인덱싱 및 인덱싱 된 할당을 최대한 효율적으로 만드는 것이 중요합니다. 배열 데이터 구조는 일반적으로 두 가지 방법 중 하나로 정의됩니다. 하나의 인덱스를 사용하여 해당 요소에 가장 효율적으로 액세스하거나 (선형 인덱싱) 모든 차원에 지정된 인덱스를 사용하여 본질적으로 요소에 액세스합니다. 이 두 가지 양식은 Julia에 의해 &lt;code&gt;IndexLinear()&lt;/code&gt; 및 &lt;code&gt;IndexCartesian()&lt;/code&gt; 으로 식별됩니다 . 선형 인덱스를 여러 인덱스 첨자로 변환하는 것은 일반적으로 비용이 많이 들기 때문에 모든 배열 유형에 대해 효율적인 일반 코드를 가능하게하는 특성 기반 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">배열로 선형 인덱스 &lt;code&gt;A&lt;/code&gt; A를 변환 할 수 &lt;code&gt;CartesianIndex&lt;/code&gt; 과 직교 인덱싱 &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (참고 &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; 을&lt;/a&gt; ), 및 일련의 &lt;code&gt;N&lt;/code&gt; 직교 지수를 갖는 선형 인덱스로 변환 할 수 &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; ( &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2c3eb1f6f74eb080998f31c2d0aa44b3b54b4558" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer index to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; from an array that is &lt;code&gt;IndexLinear&lt;/code&gt; will return a simple one-dimensional range, even if it is multidimensional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선형 인덱싱 스타일은 배열의 위치를 ​​설명하기 위해 하나의 정수를 사용하며 (다차원 배열 인 경우에도) 열 주요 순서는 요소에 액세스하는 데 사용됩니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 선형 인덱싱 을 사용하는 &lt;code&gt;(2, 3)&lt;/code&gt; 사용자 정의 행렬 유형이고 &lt;code&gt;A[5]&lt;/code&gt; (선형 스타일 사용)를 참조한 경우 &lt;code&gt;A[1, 3]&lt;/code&gt; 을 참조 하는 것과 같습니다 ( &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; 이후 + 3 = 5 ). &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">입력 유형의 리터럴 튜플</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">조금 더 아래로 보면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">위에 표시된대로 &lt;code&gt;-p&lt;/code&gt; 옵션으로 지정된 로컬 클러스터</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">로거는 로그 레코드가 필터링 및 발송되는 방법을 제어합니다. 로그 레코드가 생성되면 로거는 사용자가 구성 할 수있는 첫 번째 코드로 레코드를 검사하고 레코드와 함께 수행 할 작업을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Julia의 많은 기능과 확장 성은 비공식 인터페이스 모음에서 비롯됩니다. 사용자 지정 형식에 사용할 수있는 몇 가지 특정 방법을 확장하면 해당 형식의 개체가 해당 기능을 수신 할뿐만 아니라 이러한 동작을 일반적으로 구축하기 위해 작성된 다른 방법에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; 가&lt;/a&gt; 반환 한 &lt;code&gt;id&lt;/code&gt; 대한 지원 &lt;code&gt;AbstractChannel&lt;/code&gt; 을 반환하는 저수준 API입니다 . 호출은 지원 채널이 존재하는 노드에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 연결 또는 &lt;code&gt;Worker&lt;/code&gt; 가 제공된 하위 수준 API 는 연결된 작업자 의 &lt;code&gt;pid&lt;/code&gt; 를 반환합니다 . 이는 수신 프로세스 ID에 따라 기록 된 데이터를 최적화하는 유형에 대한 사용자 정의 &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt; 메소드를 작성할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">기계 스펙은 문자열 &lt;code&gt;machine_spec&lt;/code&gt; 또는 tuple- &lt;code&gt;(machine_spec, count)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">표현식을 평가하는 매크로로 결과 값을 버리고 대신 부동 소수점 숫자로 실행하는 데 걸리는 시간 (초)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25d6ce8e35c816ac4036b6028811a1a2075b37da" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">식을 평가하고 결과 값을 버리는 대신 식을 평가하는 동안 할당 된 총 바이트 수를 반환하는 매크로입니다. 참고 : 표현식은 컴파일의 영향을 제거하기 위해 현재 컨텍스트 대신 로컬 함수 내에서 평가되지만 JIT 컴파일으로 인해 일부 할당이 여전히있을 수 있습니다. 또한 결과가 &lt;code&gt;@time&lt;/code&gt; 매크로 와 일치 하지 않으므로 컴파일 효과를 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">식을 실행하고 식의 값, 경과 시간, 할당 된 총 바이트 수, 가비지 수집 시간 및 다양한 메모리 할당 카운터가있는 개체를 반환하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">식의 값을 반환하기 전에 식을 실행하는 매크로, 실행 시간, 할당 수 및 실행이 할당 된 총 바이트 수를 인쇄하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="e612ee47dedcebb8c33ec68affacf4a81104cb7f" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a &lt;code&gt;for&lt;/code&gt; loop to run with multiple threads. Splits the iteration space among multiple tasks and runs those tasks on threads according to a scheduling policy. A barrier is placed at the end of the loop which waits for all tasks to finish execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">여러 스레드로 실행하기 위해 for 루프를 병렬화하는 매크로입니다. 이것은 &lt;code&gt;nthreads()&lt;/code&gt; 수의 스레드를 생성 하고 반복 공간을 분할하고 병렬로 반복합니다. 모든 스레드의 실행이 완료 될 때까지 대기하는 루프의 끝에 장벽이 배치되고 루프가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 데이터를 참조하는 메모리 주소 입니다. 그러나 메모리가 실제로 유효한지 또는 실제로 지정된 유형의 데이터를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">로깅 매크로가 나타나는 &lt;em&gt;소스 코드 문의&lt;/em&gt; 고유 한 고정 식별자 인 메시지 &lt;code&gt;id&lt;/code&gt; 입니다 . 이 식별자는 로깅 명령문 자체가 동일하게 유지되는 한 파일의 소스 코드가 변경 되더라도 상당히 안정적으로 설계되었습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">지정된 형식 함수에 필수 형식 서명이있는 메소드가 없습니다. 또는 가장 고유 한 고유 한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">보다 이식성있는 파일은 32 비트 또는 64 비트라는 단어 크기와 엔디안 정보를 헤더에 인코딩해야합니다. 실제로 HDF5 (메모리 매핑과 함께 사용할 수있는)와 같은 표준 형식을 사용하여 이진 데이터를 인코딩하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">위의 반복 디스패치에 대한 자연스러운 확장은 유형 계층에 의해 정의 된 세트와 독립적 인 유형 세트를 디스패치 할 수있는 메소드 선택에 계층을 추가하는 것입니다. 우리 는 해당 유형 의 &lt;code&gt;Union&lt;/code&gt; 을 작성하여 이러한 세트를 구성 할 수 있지만 생성 후에 &lt;code&gt;Union&lt;/code&gt; 유형을 변경할 수 없으므로이 세트를 확장 할 수 없습니다. 그러나 이러한 확장 가능한 세트는 종종 &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;신성한 특성&quot;&lt;/a&gt; 이라고하는 디자인 패턴으로 프로그래밍 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에서 음수 값을 반환 하면 트리 보행이 중지됩니다. 양수 값은 &lt;code&gt;post&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 항목을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="62d79b805fd70e21e9dc784de34e11e7bbeb08de" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table&quot;&gt;table&lt;/a&gt; for a complete list). Some programming languages require explicitly declaring new variables before using them. Explicit declaration works in Julia too: in any local scope, writing &lt;code&gt;local x&lt;/code&gt; declares a new local variable in that scope, regardless of whether there is already a variable named &lt;code&gt;x&lt;/code&gt; in an outer scope or not. Declaring each new local like this is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a new variable in a local scope to implicitly declare that variable as a new local. Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than one might na&amp;iuml;vely imagine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">새로운 로컬 범위는 대부분의 코드 블록에 의해 도입되었습니다 ( 전체 목록 은 위의 &lt;a href=&quot;#man-scope-table-1&quot;&gt;표&lt;/a&gt; 참조 ). 로컬 범위는 읽기 및 쓰기를 위해 부모 로컬 범위의 모든 변수를 상속합니다. 전역 범위와 달리 로컬 범위는 네임 스페이스가 아니므로 일종의 정규화 된 액세스를 통해 내부 범위의 변수를 상위 범위에서 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="91d3c0787a3293d9e014f25bc097c52cd39aa358" translate="yes" xml:space="preserve">
          <source>A numeric literal placed directly before an identifier or parentheses, e.g. &lt;code&gt;2x&lt;/code&gt; or &lt;code&gt;2(x+y)&lt;/code&gt;, is treated as a multiplication, except with higher precedence than other binary operations. See &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;Numeric Literal Coefficients&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1 차원 &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">Julia 세션 당 패키지는 한 번만로드 할 수 있습니다. 현재 Julia 세션에서 &lt;code&gt;import Example&lt;/code&gt; 을 실행 한 경우 Pkg REPL에서 Julia를 다시 시작하고 &lt;code&gt;activate tutorial&lt;/code&gt; 을 다시 실행해야합니다 . &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; 로이 프로세스를 훨씬 더 즐겁게 만들 수 있지만 설정은이 안내서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">프로젝트 파일이 있지만 명시 적 UUID가없는 패키지는 프로젝트 파일이없는 패키지에만 의존 할 수 있습니다. 이러한 패키지에 할당 된 더미 UUID는 엄격하게 내부이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">프로젝트 파일과 패키지 만의 패키지를로드 할 수 있기 때문에 프로젝트 파일과 패키지는 프로젝트 파일없이 하나에 의존 할 수 &lt;code&gt;graph&lt;/code&gt; 에 표시되지 않습니다 프로젝트 파일없이 패키지를 &lt;code&gt;graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">프로젝트 파일이없는 패키지는 모든 최상위 종속성에 의존 할 수 있으며 패키지 디렉토리의 모든 패키지는 최상위 레벨에서 사용 가능하므로 환경의 모든 패키지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5392bfe5103ecd0e6030986407ee36c2237b3b31" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">단락은 일반 텍스트 블록으로, 위 및 아래에 하나 이상의 빈 줄이있는 위 의 &lt;a href=&quot;#Inline-elements-1&quot;&gt;인라인 요소&lt;/a&gt; 섹션에 정의 된 여러 개의 인라인 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6007e06cc6ef0228d827b11a1334d34e7c3bc855" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 유형 의 특히 유용한 경우 는 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; . 여기서 &lt;code&gt;T&lt;/code&gt; 는 모든 유형일 수 있으며 &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 은 인스턴스가 객체 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 단일 유형입니다 . 이 패턴은 다른 언어 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; 또는 &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; 유형 과 같은 Julia 입니다. 함수 인수 또는 필드 선언 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 타입의 값 중 하나를 설정할 수 있습니다 &lt;code&gt;T&lt;/code&gt; , 또는에 &lt;code&gt;nothing&lt;/code&gt; 값이 없음을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;이 FAQ 항목&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">데이터 블록에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">패키지 종속성 해결 프로그램 의 max-sum 서브 루틴 &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; 이 포기하기 전에 만족스러운 제한 조건을 시도하는 데 얼마나 많은 시간이 걸리는지 를 결정하는 양의 &lt;code&gt;Int&lt;/code&gt; :이 값은 기본적으로 &lt;code&gt;1&lt;/code&gt; 이며 더 큰 값은 더 많은 시간에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">미리 계산 된 &lt;code&gt;mean&lt;/code&gt; 이 제공 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d945dad8bbc2c247c2aec246f6c166ddc81c4918" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided. When &lt;code&gt;dims&lt;/code&gt; is specified, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">접두사 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 의 인수에 사용되어 스칼라 값 대신 스칼라 인수에 대한 포인터가 전달되어야 함을 나타냅니다 (위에서 언급 한대로 모든 포트란 함수 인수에 필요함). 다음 예제는 BLAS 함수를 사용하여 내적을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">프리미티브 유형은 데이터가 평범한 오래된 비트로 구성된 콘크리트 유형입니다. 기본 유형의 고전적인 예는 정수 및 부동 소수점 값입니다. 대부분의 언어와 달리 Julia를 사용하면 고정 된 내장 유형 만 제공하는 대신 고유 한 기본 유형을 선언 할 수 있습니다. 실제로 표준 프리미티브 유형은 모두 언어 자체로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">프로젝트 환경은 &lt;code&gt;Project.toml&lt;/code&gt; 이라는 프로젝트 파일 과 &lt;code&gt;Manifest.toml&lt;/code&gt; 이라는 매니페스트 파일이 포함 된 디렉토리에 의해 결정됩니다 . 이러한 파일은 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 및 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; 이라고도 하며,이 경우 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 은 무시됩니다. 따라서 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 이라는 파일을 중요하게 고려할 수있는 다른 도구와 공존 할 수 있습니다 . 그러나 순수 Julia 프로젝트의 경우 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">순수한 기능은 불변 정보에만 의존 할 수 있습니다. 또한 &lt;code&gt;@pure&lt;/code&gt; 함수는 일반 함수를 포함하여 전역 변경 가능 상태를 사용할 수 없습니다. 일반 함수에 대한 호출은 변경 가능한 전역 상태 인 메소드 테이블에 따라 다릅니다. 주의해서 사용 하면 함수의 잘못된 &lt;code&gt;@pure&lt;/code&gt; 주석이 버그를 식별하기 어려울 수 있습니다. 일반 함수 호출을 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a38ae91b9307c68d0e967bb52415d492ca7b2c6c" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceda790c7683875242632789b7229b6b3328dc5d" translate="yes" xml:space="preserve">
          <source>A quoted piece of code, that does not support interpolation. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-quote-node&quot;&gt;manual section about QuoteNodes&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">범위 &lt;code&gt;r&lt;/code&gt; &lt;code&gt;r[i]&lt;/code&gt; 타입의 값 생성 &lt;code&gt;T&lt;/code&gt; 를 (두 번째 형태는, &lt;code&gt;T&lt;/code&gt; 는 a로 파라미터 자동으로 도출된다) &lt;code&gt;ref&lt;/code&gt; ERENCE 값, &lt;code&gt;step&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; GTH. 기본적으로 &lt;code&gt;ref&lt;/code&gt; 는 시작 값 &lt;code&gt;r[1]&lt;/code&gt; 이지만 다른 인덱스 &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; 대해 &lt;code&gt;r[offset]&lt;/code&gt; 값으로 제공 할 수도 있습니다 . &lt;code&gt;TwicePrecision&lt;/code&gt; 과 함께 이것은 반올림 오류가없는 범위를 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">a로 파라미터 범위 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 형 &lt;code&gt;T&lt;/code&gt; 요소 가득은만큼 이격 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;start&lt;/code&gt; 될 때까지 &lt;code&gt;stop&lt;/code&gt; 초과된다. 구문 &lt;code&gt;a:b&lt;/code&gt; 와 및 &lt;code&gt;b&lt;/code&gt; 모두 &lt;code&gt;Integer&lt;/code&gt; s는 생성 &lt;code&gt;UnitRange&lt;/code&gt; 를 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;stop&lt;/code&gt; 사이에 &lt;code&gt;len&lt;/code&gt; 이 간격을 둔 요소를 갖는 범위입니다 . 간격의 크기는 &lt;code&gt;len&lt;/code&gt; 에 의해 제어되며 , &lt;code&gt;Int&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">이와 관련된 전략 악용 &lt;code&gt;promote&lt;/code&gt; 가지고에 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 일반적인 유형 :</target>
        </trans-unit>
        <trans-unit id="d7c0e6452fd18c0732cb625754236d5f55a408f6" translate="yes" xml:space="preserve">
          <source>A related third strategy is to use a yield-free queue. We don't currently have a lock-free queue implemented in Base, but &lt;code&gt;Base.InvasiveLinkedListSynchronized{T}&lt;/code&gt; is suitable. This can frequently be a good strategy to use for code with event loops. For example, this strategy is employed by &lt;code&gt;Gtk.jl&lt;/code&gt; to manage lifetime ref-counting. In this approach, we don't do any explicit work inside the &lt;code&gt;finalizer&lt;/code&gt;, and instead add it to a queue to run at a safer time. In fact, Julia's task scheduler already uses this, so defining the finalizer as &lt;code&gt;x -&amp;gt; @spawn do_cleanup(x)&lt;/code&gt; is one example of this approach. Note however that this doesn't control which thread &lt;code&gt;do_cleanup&lt;/code&gt; runs on, so &lt;code&gt;do_cleanup&lt;/code&gt; would still need to acquire a lock. That doesn't need to be true if you implement your own queue, as you can explicitly only drain that queue from your thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">원격 통화는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 결과로 반환합니다 . 원격 전화는 즉시 응답합니다. 원격 호출이 다른 곳에서 발생하는 동안 호출 한 프로세스는 다음 작업으로 진행됩니다. 반환 된 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 원격 호출이 완료 될 때까지 기다릴 수 있으며 &lt;code&gt;fetch&lt;/code&gt; 를 사용하여 결과의 ​​전체 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 연산자를 사용하여 함수 선언에 반환 유형을 지정할 수도 있습니다 . 리턴 값을 지정된 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f794450cdef21a1d306e7fb59ec235acfc19011a" translate="yes" xml:space="preserve">
          <source>A return type can be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; 의 리턴 유형은 함수가 C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; 또는 C11 &lt;code&gt;_Noreturn&lt;/code&gt; (예 : &lt;code&gt;jl_throw&lt;/code&gt; 또는 &lt;code&gt;longjmp&lt;/code&gt; )을 리턴하지 않음을 의미합니다 . 값을 반환하지 않고 ( &lt;code&gt;void&lt;/code&gt; ) 반환하는 함수에는 이것을 사용하지 말고 대신 &lt;code&gt;Cvoid&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0df8658c1a2663d5b4b16580728c11544340a3ac" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return, i.e., C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">선택적으로 타입 선언을하는 데 사용될 수있는 객체를 구성하고 설명하기위한 풍부한 유형의 언어</target>
        </trans-unit>
        <trans-unit id="3b35eab36ca2f92e10ca8fc1b981602576d246ef" translate="yes" xml:space="preserve">
          <source>A sampler for types, containing no other information. The default fallback for &lt;code&gt;Sampler&lt;/code&gt; when called with types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">역 추적이 간격으로 발생하기 때문에 샘플링 프로파일 러는 완전한 라인 단위 범위를 제공하지 않습니다 (실제 스케줄링은 운영 체제로드의 영향을 받더라도 기본적으로 1 밀리 초 시스템, Windows에서는 10 밀리 초). 더욱이, 아래에서 더 논의되는 바와 같이, 샘플은 모든 실행 포인트의 스파 스 서브 세트에서 수집되기 때문에, 샘플링 프로파일 러에 의해 수집 된 데이터는 통계적 노이즈의 영향을 받는다.</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">스칼라 인덱스 기본적으로 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e149e1fe6cf738b9500f7f73419a47eddcaa861" translate="yes" xml:space="preserve">
          <source>A second strategy, employed by Base in a couple places, is to explicitly delay a finalizer until it may be able to acquire its lock non-recursively. The following example demonstrates how this strategy could be applied to &lt;code&gt;Distributed.finalize_ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">이 초기 이루어진 고유 때 자식 객체를 식별하는 데 사용될 수있는 단축 자식 객체 식별자, &lt;code&gt;len&lt;/code&gt; 의 16 진수 &lt;code&gt;hash&lt;/code&gt; (나머지 숫자는 무시된다).</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">간단한 TCP 예제</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">간단한 예는 정의 된 길이를 가진 반복 가능한 제곱 숫자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="74210b965c13b3f0a92488bc76d8ed6610e194df" translate="yes" xml:space="preserve">
          <source>A simple sampler without pre-computed data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">이 스크립트는 명령 줄에서 간단하게 사용합니다. &lt;code&gt;julia-config.jl&lt;/code&gt; 이 &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; 에 있다고 가정하면 명령 행에서 직접 호출 할 수 있으며 3 개의 플래그를 조합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">이 유형의 싱글 톤은 환경 변수에 대한 해시 테이블 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">방송을위한 특별한 구문이 존재합니다 : &lt;code&gt;f.(args...)&lt;/code&gt; 는 &lt;code&gt;broadcast(f, args...)&lt;/code&gt; 와 동일하며 중첩 된 &lt;code&gt;f.(g.(args...))&lt;/code&gt; 호출은 단일 브로드 캐스트 루프에 통합됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">Julia의 코드 로딩 메커니즘뿐만 아니라 패키지 관리자도 패키지 레지스트리, 설치된 패키지, 명명 된 환경, 저장소 복제본, 캐시 된 컴파일 된 패키지 이미지 및 구성 파일을 찾는 &quot;저장소&quot;위치의 스택입니다. 기본적으로 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">strided array는 엔트리가 고정 된 stride를 가진 메모리에 저장되는 &lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형입니다 . 배열의 요소 유형이 BLAS와 호환되는 경우 스 트레이드 배열은 BLAS 및 LAPACK 루틴을 사용하여보다 효율적인 선형 대수 루틴을 수행 할 수 있습니다. 사용자 정의 스트라이드 배열의 전형적인 예는 표준 &lt;code&gt;Array&lt;/code&gt; 을 추가 구조로 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">빌드 트리플을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">&lt;code&gt;julia&lt;/code&gt; 실행 파일이 포함 된 디렉토리의 전체 경로가 포함 된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명령 행에서 Julia에게 전달 된 스크립트 이름이 포함 된 문자열. 스크립트 이름은 포함 된 파일 내에서 변경되지 않은 상태로 유지됩니다. 또는 &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">숫자의 리터럴 비트 표현을 제공하는 문자열.</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">구조체는 &lt;code&gt;&amp;lt;:&lt;/code&gt; 문법을 통해 추상 슈퍼 타입을 선언 할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">호출이 성공하면 요청이 원격 노드에서 실행되도록 승인되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">현재 범위의 기호가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">빌드 구성의 아키텍처를 나타내는 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">빌드 구성이 &lt;code&gt;uname&lt;/code&gt; 않으면 서 리턴되는 운영 체제 이름을 나타내는 기호 입니다.</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">내장 함수 &lt;code&gt;Base.operator_associativity&lt;/code&gt; 를 호출하여 연산자 연관성을 나타내는 기호를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">오류 코드 ( &lt;code&gt;errno&lt;/code&gt; 전역 변수)로 시스템 호출에 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="e7383f155bc43b22861eb93ff761378a3dfd82ac" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">태스크를 호출하여 명시 적으로 작성된 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 는 처음에 스케줄러에 알려지지 않았습니다. 원하는 경우 &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; 를&lt;/a&gt; 사용하여 수동으로 작업을 관리 할 수 ​​있습니다 . 그러나 이러한 작업이 이벤트를 기다리는 경우 이벤트가 발생할 때 예상대로 여전히 자동으로 다시 시작됩니다. 스케줄러가 이벤트를 기다리지 않고 가능할 때마다 태스크를 실행하도록 할 수도 있습니다. 이것은 &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 수행됩니다 ( 자세한 내용 은 &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;병렬 컴퓨팅&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드 안전 버전의 &lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edef5e7571427a5f91f025df54f077af0dd3024e" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;../parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b58805de54debccfbd0e801ac822dbec053b647" translate="yes" xml:space="preserve">
          <source>A tuple of input types, corresponding to the function signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">입력 유형의 튜플. 입력 유형은 튜플 값 변수 나 표현식이 아닌 리터럴 튜플로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2 차원 &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">형식 어설 션 실패 또는 잘못된 인수 형식의 고유 함수 호출</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">표준 인터넷 데이터 형식을 나타내는 유형입니다. &quot;MIME&quot;은 &quot;Multipurpose Internet Mail Extensions&quot;의 약자입니다. 표준은 원래 전자 메일 메시지에 대한 첨부 파일을 설명하는 데 사용 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 줄리아 코드 (AST)의 복합 표현식을 나타내는 유형입니다. 각 표현식은 어떤 종류의 표현식 (예 : 호출, for 루프, 조건문 등)을 식별 하는 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; 과 하위 표현식 (예 : 호출의 인수)으로 구성됩니다. 하위 표현식은 &lt;code&gt;args&lt;/code&gt; 라는 &lt;code&gt;Vector{Any}&lt;/code&gt; 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">타입 유니언은 특별한 &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 생성 된 인자 타입의 모든 인스턴스를 객체로 포함하는 특별한 추상 타입입니다 :</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">타입 유니언은 인수 타입의 모든 인스턴스를 포함하는 추상 타입입니다. 빈 연합 &lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt; 은 Julia의 최하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d4feddb63143773f90aec3aa6e9e79164c040b57" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;a href=&quot;#Base.round-Tuple%7BType,Any%7D&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">A (통해 부동 소수점 연산의 라운딩 모드를 제어하기 위해 사용되는 타입 &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; 기능) 또는 (비아 가장 가까운 정수로 반올림 선택적 인수로 &lt;code&gt;round&lt;/code&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 유형의 필드가없는 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">누락 된 값을 나타내는 데 단일 인스턴스 &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 이있는 필드가없는 유형 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">그러나 이러한 한 쌍의 반환 값을 일반적으로 사용하면 각 값을 변수로 추출합니다. Julia는이를 용이하게하는 간단한 튜플 &quot;파괴&quot;를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">형식 매개 변수의 모든 값에 대한 형식의 합집합 &lt;code&gt;UnionAll&lt;/code&gt; 은 일부 매개 변수의 값을 알 수없는 매개 변수 유형을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; 매크로 는 성능 측정에 유용한 도구입니다 . 위의 전역 변수를 사용하여 예제를 반복하지만 이번에는 유형 주석이 제거 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; 로 선언하여 변수 이름을 지정하지 않고 변수 이름을 &quot;예약&quot;할 수 있습니다 . 로드 시간 이후에 초기화 된 전역에 대한 이름 충돌을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">대화식 프롬프트에서 자동으로 설정되는 마지막 계산 된 값을 참조하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">Julia의 변수는 값과 연관된 이름입니다. 나중에 사용하기 위해 값 (예 : 수학 후에 얻은 값)을 저장하려는 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">유형 불안정성의 모양을 피하는이 접근 방식의 변형은 &lt;code&gt;Int&lt;/code&gt; 및 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 유형을 단일 하이브리드 정수 유형으로 병합하여 결과가 더 이상 기계 정수의 크기에 맞지 않을 때 내부적으로 표시를 변경하는 것입니다. 이것은 Julia 코드 수준에서 유형 불안정성을 피할 수는 있지만이 하이브리드 정수 유형을 구현하는 C 코드에 동일한 어려움을 모두가함으로써 양탄자 문제를 해결할 수 있습니다. 이 방법 &lt;em&gt;은&lt;/em&gt;많은 경우에 빠르게 작동 할 수 있지만 몇 가지 단점이 있습니다. 한 가지 문제점은 정수 및 정수 배열의 메모리 내 표현이 더 이상 C, Fortran 및 기타 언어에서 기본 기계 정수로 사용하는 자연 표현과 일치하지 않는다는 것입니다. 따라서 이러한 언어와 상호 작용하려면 궁극적으로 기본 정수 유형을 도입해야합니다. 무제한의 정수 표현은 고정 된 수의 비트를 가질 수 없으므로 고정 크기 슬롯이있는 배열에 인라인으로 저장할 수 없습니다. 정수 값이 클수록 항상 별도의 힙 할당 스토리지가 필요합니다. 물론 하이브리드 정수 구현이 아무리 영리하게 사용하더라도 성능이 예기치 않게 저하되는 상황 인 성능 트랩이 항상 있습니다. 복잡한 표현, C 및 Fortran과의 상호 운용성 부족추가 힙 스토리지없이 정수 배열을 표현할 수없고 예측할 수없는 성능 특성으로 인해 가장 영리한 하이브리드 정수 구현도 고성능 수치 작업에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">매우 특수한 매크로는 &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; 로&lt;/a&gt; , 소위 &lt;em&gt;생성 된 함수&lt;/em&gt; 를 정의 할 수 있습니다 . 이들은 여러 디스패치로 달성 할 수있는 것보다 더 유연하고 코드가 적은 인수 유형에 따라 특수 코드를 생성 할 수 있습니다. 매크로는 구문 분석시 표현식에 대해 작업하고 입력 유형에 액세스 할 수 없지만 인수 유형이 알려진 시점에 생성 된 함수가 확장되지만 함수는 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 에서 값이없는 것 ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; )과 값 이 &lt;code&gt;nothing&lt;/code&gt; (즉, &lt;code&gt;Some(nothing)&lt;/code&gt; ) 을 구분하기 위해 사용되는 래퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="80d305c58f97edfae92a3627f5a66d9bef4d8d46" translate="yes" xml:space="preserve">
          <source>AM</source>
          <target state="translated">AM</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII 문자와 ASCII 이스케이프는 단일 바이트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="125c32f24e67f8006c45d7fdea568e01f28fd48b" translate="yes" xml:space="preserve">
          <source>Abbreviated days of the week</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">위와 같이 모호성을 해결할 수 있다고 지적되었습니다.</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">추상 배열</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">추상 유형</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">추상 컨테이너 및 요소 유형</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">추상 숫자 유형</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">: 동기화 프리미티브를 구현하는 유형 설명하는 추상 슈퍼 &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">IP 주소의 추상 수퍼 타입. &lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 은이 유형의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">모든 부동 소수점 숫자에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">모든 숫자 유형에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">모든 실수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">부호있는 모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">부호없는 모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">풍부한 디스플레이 출력 장치를위한 추상 수퍼 타입. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt; 는 이것의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5e9597d58105eaf8a30d20d99c956a69b4d700ba" translate="yes" xml:space="preserve">
          <source>Abstract type for &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix factorizations&lt;/a&gt; a.k.a. matrix decompositions. See &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;online documentation&lt;/a&gt; for a list of available matrix factorizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">모든 기능의 추상적 유형.</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">추상 유형은 &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 선언됩니다 . 추상 형식을 선언하는 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">추상 유형은 인스턴스화 할 수 없으며 유형 그래프에서 노드의 역할 만하므로 관련 콘크리트 유형 세트 (자손 인 콘크리트 유형)를 설명합니다. 추상 유형은 유형 시스템의 중추이기 때문에 인스턴스화가 없지만 추상 유형으로 시작합니다. 이들은 개념적 계층 구조를 형성하여 Julia의 유형 시스템을 단순한 객체 구현 모음 이상으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; 는 디스플레이 스택에서 최상위로 적용 가능한 디스플레이를 사용하며 일반적으로 &lt;code&gt;x&lt;/code&gt; 에 대해 가장 풍부한 지원되는 멀티미디어 출력을 사용하며 일반 텍스트 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 출력을 폴백으로 사용합니다. &lt;code&gt;display(d, x)&lt;/code&gt; 표시하는 변형 시도 &lt;code&gt;x&lt;/code&gt; 주어진 디스플레이에 &lt;code&gt;d&lt;/code&gt; 투구 만 &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 이&lt;/a&gt; 경우 &lt;code&gt;d&lt;/code&gt; 이 유형의 오브젝트를 표시 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">이를 사용하지 않으면 런타임 시스템이 손상되고 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">교류 전류</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">주어진 서버에서 연결을 수락하고 클라이언트에 대한 연결을 반환합니다. 초기화되지 않은 클라이언트 스트림이 제공 될 수 있으며,이 경우 새 스트림을 생성하는 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">열을 따라 메모리 순서로 배열에 액세스</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">액세스는 보폭 패턴을 가져야하며 &quot;수집&quot;(임의 색인 읽기) 또는 &quot;산란&quot;(임의 색인 쓰기)이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">포인터를 통해 데이터에 액세스</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">문서에 액세스</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">글로벌 변수에 액세스</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">반환 된 배열에 액세스</target>
        </trans-unit>
        <trans-unit id="06321d9fadb0d72695135f33706dc1e00ad6f5c5" translate="yes" xml:space="preserve">
          <source>Accessing memory of an object directly via a &lt;code&gt;Ptr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명명 된 튜플에서 이름과 연관된 값에 액세스하는 것은 필드 액세스 구문 (예 : &lt;code&gt;x.a&lt;/code&gt; ) 또는 &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; (예 : &lt;code&gt;x[:a]&lt;/code&gt; 사용하여 수행 할 수 있습니다 . &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 를 사용하여 이름 의 튜플을 얻을 수 있고 &lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 사용하여 값 의 튜플을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">접근 자 기능</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">축적 및 청소</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">&lt;code&gt;1+x&lt;/code&gt; 의 정확한 자연 로그 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 는&lt;/a&gt; 대한 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; -1보다 작은 인수.</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">$ e ^ x-1 $를 정확하게 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 가 사용 가능 해지면 확보하십시오 . 다른 작업 / 스레드에 의해 잠금이 이미 잠긴 경우 사용 가능할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="1b62ab8ac8364cef9cfdb46dc16347ea263ed957" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt;, execute &lt;code&gt;f&lt;/code&gt; with the &lt;code&gt;lock&lt;/code&gt; held, and release the &lt;code&gt;lock&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; returns. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 잠금을 획득하고 성공하면 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 . 잠금이 이미 다른 작업 / 스레드에 의해 잠겨 있으면 &lt;code&gt;false&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">예각</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스케줄러 대기열에 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 추가하십시오 . 이로 인해 시스템이 유휴 상태 일 때 작업이 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 등의 차단 작업을 수행하지 않는 한 작업이 계속 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">지정된 &lt;code&gt;rmt&lt;/code&gt; 에 대한 &lt;em&gt;페치 참조&lt;/em&gt; 스펙을 추가하십시오 . 이 참조 스펙에는 가져올 브랜치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">지정된 &lt;code&gt;rmt&lt;/code&gt; 에 대한 &lt;em&gt;푸시 참조 사양을&lt;/em&gt; 추가하십시오 . 이 참조 스펙에는 푸시 할 브랜치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">stream &lt;code&gt;s&lt;/code&gt; 현재 위치에 마크를 추가하십시오 . 표시된 위치를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; 에 의해 지정된 경로를 가진 모든 파일 을 색인 &lt;code&gt;idx&lt;/code&gt; (또는 &lt;code&gt;repo&lt;/code&gt; 의 색인 )에 추가하십시오. 파일이 이미 존재하면 색인 항목이 업데이트됩니다. 파일이 없으면 색인에 새로 추가됩니다. &lt;code&gt;files&lt;/code&gt; 확장 될 것이고 일치하는 파일 (않는 추가 될 글롭 패턴을 포함 할 수있다 &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; 가 설정되어, 아래 참조). 파일이 (무시 된 경우 &lt;code&gt;.gitignore&lt;/code&gt; 또는 설정에), 그것은 &lt;em&gt;하지 않습니다&lt;/em&gt; , 추가 될 &lt;em&gt;하지 않는 한&lt;/em&gt; 이미이있는 경우에는 인덱스에서 추적하는 &lt;em&gt;것입니다&lt;/em&gt; 업데이트. 키워드 인수 &lt;code&gt;flags&lt;/code&gt; 무시 된 파일에 대한 동작을 제어하는 ​​비트 플래그 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">SSH를 통해 원격 시스템에 프로세스를 추가하십시오. 필요 &lt;code&gt;julia&lt;/code&gt; 각 노드에서 같은 위치에 설치하거나 공유 파일 시스템을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">의 요소를 추가 &lt;code&gt;collection2&lt;/code&gt; 을 끝으로 &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">추가 연산자. &lt;code&gt;x+y+z+...&lt;/code&gt; 는 모든 인수, 즉 &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; 와 함께이 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 예제 및 테스트는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">또한 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 는 배열로 제한되지 않으며 (함수 설명서 참조) 또한 튜플을 처리하고 배열, 튜플 또는 &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; 제외 ) 가 아닌 모든 인수를 &quot;스칼라&quot;로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="945097f233edb04921a995b222a7aba704c8bec8" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation); it also handles scalars, tuples and other collections. By default, only some argument types are considered scalars, including (but not limited to) &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;code&gt;missing&lt;/code&gt; and &lt;code&gt;nothing&lt;/code&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">또한 &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt; 는 각각 &lt;code&gt;sin(pi*x)&lt;/code&gt; 및 &lt;code&gt;cos(pi*x)&lt;/code&gt; 보다 정확한 계산을 위해 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="6351bb5c94d5c92615addcb5b2795472a480f027" translate="yes" xml:space="preserve">
          <source>Additionally, Julia is not memory safe in the presence of a data race. Be very careful about reading a global variable (or closure variable) if another thread might write to it! Instead, always use the lock pattern above when changing any data (such as assigning to a global) visible to multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">또한 코드 블록을 강조 표시하는 방법을 지정하기 위해 선택적 &quot;언어&quot;와 함께 삼중 백틱을 사용하여 코드 블록을 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4cc224a45b05b5c73175d158a7eca11aff2c5e" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">또한 이러한 기본 숫자 유형 위에 &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex 및 Rational Numbers&lt;/a&gt; 를 완벽하게 지원합니다 . 유연하고 사용자가 확장 할 수있는 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;유형 승격 시스템&lt;/a&gt; 덕분에 모든 숫자 유형이 명시 적 캐스트없이 자연스럽게 상호 운용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">또한, 일부 &lt;code&gt;AbstractFloat&lt;/code&gt; 및 &lt;code&gt;Complex&lt;/code&gt; 유형에 대해 정규 및 지수 분포가 구현됩니다 . 자세한 내용 은 &lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">또한 괄호로 묶은 표현식을 변수에 대한 계수로 사용할 수 있으므로 표현식에 변수가 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">또한 일부 예외 유형은 오류보고에 사용되는 하나 이상의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7c53242e98f029fd9fd99fe8ac859128c91d92ea" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[begin]&lt;/code&gt; and &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the first and last valid indices, respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">또한 &lt;code&gt;S[end]&lt;/code&gt; 구문을 지원하려면 &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; 를 정의 하여 마지막 유효한 인덱스를 지정 해야합니다 . 첫 번째 유효한 인덱스를 지정하려면 &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; &lt;/a&gt; 를 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">문서화 가능한 표현식이어야 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 이 구문은</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">&lt;code&gt;@m expression&lt;/code&gt; 을 확장하여 생성 된 표현식에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 이를 통해 &lt;code&gt;@inline&lt;/code&gt; , &lt;code&gt;@noinline&lt;/code&gt; , &lt;code&gt;@generated&lt;/code&gt; 또는 기타 매크로로 장식 된 표현식을 장식되지 않은 표현식과 동일한 방식으로 문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 &lt;code&gt;@m(::Any)&lt;/code&gt; 매크로 정의에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">를 추가의 문서화 문자열 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 받는 사람 &lt;code&gt;Binding&lt;/code&gt; 의 , &lt;code&gt;b&lt;/code&gt; , 그리고 &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; 에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . &lt;code&gt;Module&lt;/code&gt; 위에 docstring을 추가하는 것이 선호되는 구문이지만 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="82e1da815004f8c82f5b3b4ddf196b362c9b6b8a" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 함수 &lt;code&gt;f&lt;/code&gt; 에 추가합니다 . 첫 번째 버전이 선호하는 구문이지만 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@m&lt;/code&gt; 이라는 매크로에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f(::Any)&lt;/code&gt; 메소드에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b443c2f582d2d534bd4dd25c05fdf4fba408aed1" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. However, it is preferred that &lt;code&gt;sym&lt;/code&gt; is documented where it is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">&lt;code&gt;sym&lt;/code&gt; 과 연관된 값에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 사용자 문서화 선호한다 &lt;code&gt;sym&lt;/code&gt; 그 정의에.</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">를 추가의 문서화 문자열 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 2 &lt;code&gt;Method&lt;/code&gt; 들, 즉 &lt;code&gt;f(::Any)&lt;/code&gt; 와 &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 &lt;code&gt;T&lt;/code&gt; 유형에 , &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 &lt;code&gt;T.x&lt;/code&gt; 필드에 , &lt;code&gt;&quot;y&quot;&lt;/code&gt; 를 &lt;code&gt;T.y&lt;/code&gt; 필드에 추가합니다 . &lt;code&gt;mutable struct&lt;/code&gt; 유형 에도 적용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 유형 &lt;code&gt;T1&lt;/code&gt; , &lt;code&gt;T2&lt;/code&gt; 및 &lt;code&gt;T3&lt;/code&gt; 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">조절기 기능</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 &lt;code&gt;limit&lt;/code&gt; 증분 반복을 &lt;code&gt;step&lt;/code&gt; 단위로 반복하여 &lt;code&gt;dt&lt;/code&gt; 를 조정 합니다 . &lt;code&gt;func&lt;/code&gt; 은 단일 &lt;code&gt;TimeType&lt;/code&gt; 인수를 가져 와서 &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; 을&lt;/a&gt; 반환 해야합니다 . &lt;code&gt;same&lt;/code&gt; 있게 &lt;code&gt;dt&lt;/code&gt; 만족 고려하여야 &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 월요일로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 주 일요일로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월 의 첫 번째 &lt;code&gt;dow&lt;/code&gt; 로 조정합니다 . 또는 &lt;code&gt;of=Year&lt;/code&gt; 는 해당 연도 의 첫 번째 &lt;code&gt;dow&lt;/code&gt; 에 맞게 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월의 첫 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 분기의 첫날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 연도의 첫날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 그 달 의 마지막 &lt;code&gt;dow&lt;/code&gt; 로 조정합니다 . 또는 &lt;code&gt;of=Year&lt;/code&gt; 는 연도 의 마지막 &lt;code&gt;dow&lt;/code&gt; 에 맞게 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 분기의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 연도의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">를 조정은 &lt;code&gt;dt&lt;/code&gt; 에 해당하는주의 다음날 &lt;code&gt;dow&lt;/code&gt; 와 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . &lt;code&gt;same=true&lt;/code&gt; 로 설정 하면 현재 &lt;code&gt;dt&lt;/code&gt; 가 다음 &lt;code&gt;dow&lt;/code&gt; 로 간주되어 조정이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">를 조정은 &lt;code&gt;dt&lt;/code&gt; 에 해당하는 주 전날에 &lt;code&gt;dow&lt;/code&gt; 와 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . &lt;code&gt;same=true&lt;/code&gt; 로 설정 하면 현재 &lt;code&gt;dt&lt;/code&gt; 가 이전 &lt;code&gt;dow&lt;/code&gt; 로 간주되어 조정이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">다른 최상위 요소와 마찬가지로 훈계에는 다른 최상위 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">다음 요소를 얻기 위해 반복자를 진행시킵니다. 요소가 남아 있지 않으면 &lt;code&gt;nothing&lt;/code&gt; 반환 되지 않아야합니다. 그렇지 않으면 다음 요소의 2 튜플과 새로운 반복 상태가 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">다음 읽기 문자가 &lt;code&gt;predicate&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 첫 번째 나머지 문자가되도록 스트림 &lt;code&gt;io&lt;/code&gt; 를 진행시킵니다 . 키워드 인수 &lt;code&gt;linecomment&lt;/code&gt; 가 지정되면 해당 문자에서 다음 행이 시작될 때까지의 모든 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">공중 전차</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">&lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; 와 같은 호출 후 ; y = power_by_squaring (x, 4) 이면 예상 결과가 나타납니다. &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; . 그러나 이제 행렬과 함께 사용될 때 &lt;code&gt;*=&lt;/code&gt; 대신 왼쪽을 변경 했다고 가정합니다 . 두 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5164f2f115375c06ec8f88153f96f0d31b808d" translate="yes" xml:space="preserve">
          <source>After a task starts running on a certain thread (e.g. via &lt;code&gt;@spawn&lt;/code&gt;), it will always be restarted on the same thread after blocking. In the future this limitation will be removed, and tasks will migrate between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">알람 시계</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">알레프 기호 / 최초의 영구 추기경</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">단일 생성자 유형 &lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 생성하는 &lt;code&gt;UndefInitializer()&lt;/code&gt; 대한 별명 은 배열 초기화에 사용되어 배열 생성자 호출자가 초기화되지 않은 배열을 원함 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">외계인 몬스터</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;export&lt;/code&gt; ed 이름 ( &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; ), &lt;code&gt;MyModule.x&lt;/code&gt; , &lt;code&gt;MyModule.y&lt;/code&gt; 및 &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">모두 같음</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">모든 I / O 작업, 타이머, REPL 명령 등은 이벤트 루프를 통해 단일 OS 스레드로 다중화됩니다. 패치 된 libuv 버전 ( &lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt; )이이 기능을 제공합니다. 항복 지점은 여러 작업을 동일한 OS 스레드에 협력 적으로 예약 할 수 있도록합니다. I / O 작업 및 타이머는 이벤트 발생을 기다리는 동안 암시 적으로 생성됩니다. 호출 &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; 다른 작업을 예약 할 수 있도록 명시 적으로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">모든 Julia 스트림 은 스트림을 첫 번째 인수로 사용하여 최소한 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 메소드를 노출합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">모든 객체</target>
        </trans-unit>
        <trans-unit id="dd1ab7575b34c95371319e3c78f1e648aa0611b0" translate="yes" xml:space="preserve">
          <source>All Unicode code points (&lt;code&gt;\U&lt;/code&gt; with 1-8 trailing hex digits; max value = 0010ffff)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">REPL의 모든 코드는 전역 범위에서 평가되므로 최상위 수준에서 정의되고 지정된 변수 는 &lt;strong&gt;전역&lt;/strong&gt; 변수가됩니다. 모듈 내부의 최상위 수준에서 정의 된 변수도 전역 적입니다.</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 이후의 모든 쉼표로 구분 된 표현식 은 범위로 해석됩니다. 괄호를 추가하면 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 에&lt;/a&gt; 세 번째 인수를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">마스터가 시작한 작업자 만 서로 연결할 수 있도록 모든 연결이 양쪽에서 인증됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">선언 된 모든 유형 ( &lt;code&gt;DataType&lt;/code&gt; 종류)은 각 경우에 동일한 구문으로 매개 변수화 할 수 있습니다. 먼저 파라 메트릭 합성 타입, 파라 메트릭 추상 타입, 파라 메트릭 프리미티브 타입의 순서로 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">일부 추상 유형의 모든 인스턴스는 기본적 으로 Julia Base에서 범용 &lt;code&gt;convert&lt;/code&gt; 정의가 제공되는 &quot;충분히 유사&quot;한 것으로 간주됩니다 . 예를 들어,이 정의 는 1 인수 생성자를 호출하여 임의의 &lt;code&gt;Number&lt;/code&gt; 유형을 다른 숫자 유형으로 &lt;code&gt;convert&lt;/code&gt; 하는 것이 유효 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">모든 인터페이스 사용자 정의는 키워드 전용 &lt;code&gt;TerminalMenus.config()&lt;/code&gt; 함수를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">대각선의 비 실제 부분은 모두 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 로깅 매크로 &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; 및 &lt;code&gt;@error&lt;/code&gt; 는 일반적인 매크로 &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 자세히 설명되어있는 공통 기능을 공유 합니다.</target>
        </trans-unit>
        <trans-unit id="ec4e52b5ca9f88c6fa22f8c3f3902856d9403989" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Logging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">희소 행렬에 대한 모든 작업은 CSC 데이터 구조를 활용하여 성능을 높이고 값 비싼 작업을 피하기 위해 신중하게 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">다른 모든 인수 조합은 기본적으로 &lt;code&gt;Array&lt;/code&gt; 를 반환 하지만 사용자 정의 컨테이너 유형은 자체 구현 및 승격과 같은 규칙을 정의하여 인수로 표시 될 때 결과를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">모든 프로세스는 서로 직접 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">클러스터의 모든 프로세스는 기본적으로 마스터 프로세스에서 임의로 생성 된 문자열 인 동일한 쿠키를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">모든 문자열 유형은 추상 유형 &lt;code&gt;AbstractString&lt;/code&gt; 의 하위 유형 이며 외부 패키지는 추가 &lt;code&gt;AbstractString&lt;/code&gt; 하위 유형 (예 : 다른 인코딩의 경우)을 정의합니다. 문자열 인수가 필요한 함수를 정의하는 경우 문자열 형식을 허용하려면 형식을 &lt;code&gt;AbstractString&lt;/code&gt; 으로 선언해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">해당 토큰을 포함 하는 &lt;code&gt;DateFormat&lt;/code&gt; 에 따라 Date / DateTime 객체를 인쇄하려면 &lt;code&gt;AbstractDateToken&lt;/code&gt; 의 모든 하위 유형 이이 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">모든 정렬 및 순서 관련 기능은 조작 할 값의 총 순서를 정의하는 &quot;보다 작음&quot;관계에 의존합니다. &lt;code&gt;isless&lt;/code&gt; 의 기능은 기본적으로 호출하지만 관계는 통해 지정할 수 있습니다 &lt;code&gt;lt&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">모든 표준 삼각 함수 및 쌍곡선 함수도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="47776a059f25c3e9e75665d89b25759946e151d9" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">클러스터의 모든 작업자 는 마스터 와 동일한 &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;쿠키&lt;/a&gt; 를 공유합니다 . 쿠키가 지정되지 않은 경우 (예 : &lt;code&gt;--worker&lt;/code&gt; 옵션) 작업자는 표준 입력에서 쿠키 를 읽으려고합니다. &lt;code&gt;LocalManager&lt;/code&gt; 및 &lt;code&gt;SSHManager&lt;/code&gt; 는 모두 표준 입력을 통해 쿠키를 새로 시작된 작업자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">출력 컨테이너 할당</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">허용되는 변수 이름</target>
        </trans-unit>
        <trans-unit id="91b9aa574b0fcbb72864d68cfe9f2b306633c73a" translate="yes" xml:space="preserve">
          <source>Allowed within</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">거의 같거나 같음</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">거의 동일</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">곡절 악센트와 거의 동일</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">자, 생성 된 함수의 작동 방식을 더 잘 이해 했으므로 이제이를 사용하여보다 고급 (고 유효한) 기능을 구축해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">또한 차이 통지 &lt;code&gt;max.(a,b)&lt;/code&gt; , &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 위에 elementwise 와 &lt;code&gt;b&lt;/code&gt; , 그리고 &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt; 가장 큰 값을 찾아 내, &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;min.(a,b)&lt;/code&gt; 및 &lt;code&gt;minimum(a)&lt;/code&gt; 대해서도 동일한 관계가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">또한 &lt;code&gt;\xff&lt;/code&gt; 와 &lt;code&gt;\uff&lt;/code&gt; . 전자 이스케이프 시퀀스는 &lt;em&gt;바이트 255를&lt;/em&gt; 인코딩 하지만 후자의 이스케이프 시퀀스는 &lt;em&gt;코드 포인트 255를&lt;/em&gt; 나타냅니다.&lt;em&gt;&lt;/em&gt; 를 나타내며 UTF-8에서 2 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;부동 소수점 숫자에 대한&lt;/a&gt; Bruce Dawson의 블로그 게시물 시리즈를 권장 합니다 .</target>
        </trans-unit>
        <trans-unit id="3be1a8ba3f90adcceb5c1de0a45416e04c2e2aa6" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;em&gt;모든&lt;/em&gt; 이진 연산자는 다음 과 같은 배열 (및 배열과 스칼라의 조합)에 적용 할 수 있는 &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;도트 버전&lt;/a&gt; 을 지원합니다.&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt; 융합 된 브로드 캐스트 작업&lt;/a&gt; (예 : &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">또한 인수가 튀어 나오는 함수는 varargs 함수일 필요는 없습니다 (자주 사용하는 경우도 있음).</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">5 개의 부울 대신 문자열 기반 모드 지정자가 사용되는 open의 대체 구문입니다. &lt;code&gt;mode&lt;/code&gt; 의 값은 &lt;code&gt;fopen(3)&lt;/code&gt; 의 값에 해당합니다. 또는 Perl &lt;code&gt;open&lt;/code&gt; 하며 다음 부울 그룹을 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">또는 &lt;code&gt;using Module&lt;/code&gt; 을 사용 하면 내 보낸 모든 항목을 가져옵니다. &lt;code&gt;Module&lt;/code&gt; 함수를 현재 네임 스페이스로 .</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">대안 적으로, 일련의 쌍 인수가 전달 될 수있다.</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">또는 &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; 를 호출하여보다 세밀한 제어 및 추가 변환을 얻을 수 있습니다 . 여기서 다음과 같은 부울 키워드 옵션 ( &lt;code&gt;compose&lt;/code&gt; 제외하고 모두 기본값은 &lt;code&gt;false&lt;/code&gt; 임)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="afdfa160e58c5d1c29ca9c36c54e36dba734b5d6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">또는 하나를 제외한 모든 방법에 대해 튜플에 하나 이상의 요소가 있다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">또는 이미 배열을 할당 한 경우 해당 데이터 주위에 씬 래퍼를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;test/embedding/&lt;/code&gt; 폴더 의 Julia 소스 트리에서 &lt;code&gt;embedding.c&lt;/code&gt; 프로그램을 보십시오 . 파일 &lt;code&gt;ui/repl.c&lt;/code&gt; 프로그램 설정 방법은 또 다른 간단한 예입니다 &lt;code&gt;jl_options&lt;/code&gt; 의 에 연결하는 동안 옵션 &lt;code&gt;libjulia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0651e957590c9ae374820826fa54266e498875fb" translate="yes" xml:space="preserve">
          <source>Alternatively, one of the four &quot;normal forms&quot; of the Unicode standard can be specified: &lt;code&gt;normalform&lt;/code&gt; can be &lt;code&gt;:NFC&lt;/code&gt;, &lt;code&gt;:NFD&lt;/code&gt;, &lt;code&gt;:NFKC&lt;/code&gt;, or &lt;code&gt;:NFKD&lt;/code&gt;. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">MATLAB 사용자는 Julia의 구문을 잘 알고 있지만 Julia는 MATLAB 복제본이 아닙니다. 주요 구문과 기능상의 차이점이 있습니다. 다음은 MATLAB에 익숙한 Julia 사용자를 놀라게 할 수있는 몇 가지 주목할만한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">내부 생성자에서 완전히 초기화 된 객체를 반환하는 것이 일반적으로 좋지만 불완전하게 초기화 된 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">단순한 개념으로 보이지만 가치 유형에 대한 다중 디스패치는 아마도 Julia 언어의 가장 강력하고 중심적인 기능 일 것입니다. 핵심 작업에는 일반적으로 수십 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">원칙적으로 &lt;code&gt;promote&lt;/code&gt; 함수에 대한 메소드를 직접 정의 할 수 있지만 인수 유형의 가능한 모든 순열에 대해 많은 중복 정의가 필요합니다. 대신 &lt;code&gt;promote&lt;/code&gt; 동작은 &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt; 이라는 보조 함수 측면에서 정의되며 ,이를 통해 메소드를 제공 할 수 있습니다. &lt;code&gt;promote_rule&lt;/code&gt; 함수는 인수 유형의 인스턴스를 반환 유형으로 승격 될 것 같은 것을 입력 개체의 쌍을 받아 다른 유형의 객체를 반환합니다. 따라서 규칙을 정의하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">동적 언어를 &quot;유형이 없다&quot;고 말하는 경우도 있지만, 기본 객체이든 사용자 정의이든 모든 객체에 유형이있는 것은 아닙니다. 그러나 대부분의 동적 언어에서 유형 선언이 없으면 컴파일러가 값 유형에 대해 지시 할 수 없으며 종종 유형에 대해 명시 적으로 말할 수 없습니다. 반면 정적 언어에서는 컴파일러의 형식에 주석을 달 수 있지만 일반적으로 필수는하지만 형식은 컴파일 타임에만 존재하며 런타임에는 조작하거나 표현할 수 없습니다. Julia에서는 유형 자체가 런타임 객체이며 정보를 컴파일러에 전달하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">이것은 충분히 순진한 것처럼 보이지만 문제는 &lt;code&gt;0&lt;/code&gt; 은 정수 ( &lt;code&gt;Int&lt;/code&gt; 유형 )이고 &lt;code&gt;x&lt;/code&gt; 는 모든 유형 일 수 있습니다. 따라서 &lt;code&gt;x&lt;/code&gt; 값에 따라이 함수는 두 가지 유형 중 하나의 값을 반환 할 수 있습니다. 이 동작은 허용되며 경우에 따라 바람직 할 수도 있습니다. 그러나 다음과 같이 쉽게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">항상 정답은 &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">줄리아 코드로 인쇄 될 수 있도록 4 개의 공백으로 들여 쓰기를하여 문서 상단에 함수의 서명을 항상 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">합병 또는 공동 제품</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">미식 축구</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">8 바이트 식별 헤더가 먼저 스트림에 기록됩니다. 헤더를 작성하지 않으려면 &lt;code&gt;Serializer&lt;/code&gt; 를 구성하고 대신 &lt;code&gt;serialize&lt;/code&gt; 할 첫 번째 인수로 사용하십시오. &lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt; 도 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">추가하여 읽고 쓸 수 있는 &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 입니다. 찾기 및 자르기는 지원되지 않습니다. 사용 가능한 생성자에 대해서는 &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;code&gt;data&lt;/code&gt; 가 제공되는 경우 선택적으로 기본 &lt;code&gt;Array&lt;/code&gt; 가 커질 수없는 크기를 지정하여 데이터 벡터에서 작동 할 &lt;code&gt;PipeBuffer&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; 은&lt;/a&gt; 모든 근로자가 요청하기 전에 종료 할 수없는 경우 발생 &lt;code&gt;waitfor&lt;/code&gt; 초.</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;M&lt;/code&gt; 의 &lt;code&gt;k&lt;/code&gt; 번째 대각선의 인덱스를 제공 하는 &lt;code&gt;AbstractRange&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; 경우 발생합니다 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 의 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을. 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 Quantile을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; 경우 발생합니다 &lt;code&gt;v&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 의 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="273b5060458d33a00226d8a4b324524243edaee5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 요소가 있는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;em&gt;스트라이드&lt;/em&gt; 배열입니다 . 이 배열은 &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array 인터페이스를&lt;/a&gt; 따릅니다 . 경우 &lt;code&gt;A&lt;/code&gt; 는 A는 &lt;code&gt;StridedArray&lt;/code&gt; 다음 요소는 크기에 따라 다를뿐만 차원 내의 일정 수의 오프셋과 함께 메모리에 저장된다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 는 차원 1에서 보폭 2를, 차원 2에서 보폭 3을 가질 수 있습니다. 차원 &lt;code&gt;d&lt;/code&gt; 를 따라 &lt;code&gt;A&lt;/code&gt; 를 증가 &lt;code&gt;strides(A, d)&lt;/code&gt; 메모리에서 [ 보폭 (A, d) ] 슬롯 만큼 점프 합니다. Strided 배열은 BLAS와 같은 외국어 라이브러리에 대한 포인터로 직접 전달 될 수 있기 때문에 특히 중요하고 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NTuple&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 의의 치수를 나타내는 데 사용할 &lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">&lt;em&gt;환경&lt;/em&gt; 을 결정 &lt;code&gt;import X&lt;/code&gt; 및 &lt;code&gt;using X&lt;/code&gt; 로드 할 평균에서 다양한 코드 상황을 어떤 파일이 문을 유발한다. Julia는 두 가지 환경을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">HTML 렌더러는 이것을 &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number : 3.0으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">액션 서명 (예 : 커미터, 태거 등) &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">고급 예</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 의 별칭이 제공됩니다. &lt;code&gt;stacktrace&lt;/code&gt; 호출로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">대안은 배열의 &quot;보기&quot;를 만드는 것인데,이 배열 은 복사본을 만들지 않고 원래 배열의 데이터를 실제로 참조 하는 배열 객체 ( &lt;code&gt;SubArray&lt;/code&gt; )입니다. 뷰에 쓰면 원래 배열의 데이터도 수정됩니다. &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt; 를 호출하여 개별 슬라이스에 대해 수행 할 수 있고 , 또는 해당 표현식 앞에 &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; 를 넣어 전체 표현식 또는 코드 블록에 대해 더 간단하게 수행 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">하이브리드 정수를 사용하거나 BigInts로 승격시키는 대안은 포화 정수 산술을 사용하는 것입니다. 최대 정수 값을 더하면 가장 작은 정수 값에서 빼기 위해 변경되지 않고 그대로 둡니다. 이것이 바로 Matlab &amp;trade;이하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">배열 리터럴 (또는 이해)을 통해 매크로를 호출하는 다른 방법은 괄호를 사용하지 않고 둘 다를 병렬 처리하는 것입니다. 이 경우 배열은 매크로에 공급되는 유일한식이됩니다. 다음 구문은 동일하며 &lt;code&gt;@name [a b] * v&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">함수 내에서 반복적으로 사용되는 변수에 대해 유사한 &quot;유형 안정성&quot;문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">주석이 달린 git commit에는 조회 방법 및 이유에 대한 정보가 포함되어 rebase 또는 merge 작업이 commit 컨텍스트에 대한 자세한 정보를 갖습니다. 충돌 파일에는 병합의 소스 / 대상 분기에 대한 정보가 포함되어 있습니다 (예 : 충돌). 어노테이션이있는 커밋은 원격 브랜치의 팁 (예 : &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; 가 전달 될 때 ) 또는 &lt;code&gt;GitReference&lt;/code&gt; 를 사용하여 설명 된 브랜치 헤드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">여러 인수를 허용하는 익명 함수는 &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; 구문을 사용하여 작성할 수 있습니다 . 인수가 0 인 익명 함수는 &lt;code&gt;()-&amp;gt;3&lt;/code&gt; 으로 작성됩니다 . 인수가없는 함수에 대한 아이디어는 이상하게 보일 수 있지만 계산을 &quot;지연&quot;하는 데 유용합니다. 이 사용법에서 코드 블록은 인수가없는 함수로 래핑되며 나중에 &lt;code&gt;f&lt;/code&gt; 로 호출하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">결 &lt;code&gt;missing&lt;/code&gt; 허용 하지만 그러한 값을 포함하지 않는 배열은 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 를&lt;/a&gt; 사용하여 결 측값을 허용하지 않는 배열로 다시 변환 될 수 있습니다 . 배열 에 &lt;code&gt;MethodError&lt;/code&gt; 이 포함 &lt;code&gt;missing&lt;/code&gt; 경우 변환 중에 MethodError 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1aa345a94617c2935e2b045aa7c4690942cd7adb" translate="yes" xml:space="preserve">
          <source>An array is &quot;strided&quot; if it is stored in memory with well-defined spacings (strides) between its elements. A strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or LAPACK by simply passing its &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt; and the stride for each dimension. The &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A, d)&lt;/code&gt;&lt;/a&gt; is the distance between elements along dimension &lt;code&gt;d&lt;/code&gt;. For example, the builtin &lt;code&gt;Array&lt;/code&gt; returned by &lt;code&gt;rand(5,7,2)&lt;/code&gt; has its elements arranged contiguously in column major order. This means that the stride of the first dimension &amp;mdash; the spacing between elements in the same column &amp;mdash; is &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열은 다차원 그리드에 저장된 개체의 모음입니다. 가장 일반적인 경우 배열에는 &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 유형의 객체가 포함될 수 있습니다 . 대부분의 계산 목적으로 배열에는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 와 같이보다 구체적인 유형의 객체가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca0d5271db66618f81cc70b668cef389e0b4f2d" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">코드를로드 할 때 프로젝트 환경 또는 패키지 디렉토리로 간주 할 명령문을 &lt;code&gt;using&lt;/code&gt; 하고 &lt;code&gt;import&lt;/code&gt; 위한 경로 배열입니다 . 설정된 경우 &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt; 환경 변수를 기반으로 채워집니다 . 그렇지 않으면 기본값은 &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; 입니다. &lt;code&gt;@&lt;/code&gt; 로 시작하는 항목 에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">스칼라 인덱스의 배열입니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">줄에 줄로 전달 된 명령 행 인수의 배열.</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">구문 &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; 구문을 사용하여 특정 요소 유형의 배열을 구성 할 수 있습니다 . 이렇게하면 요소 유형 &lt;code&gt;T&lt;/code&gt; 로 1-d 배열을 구성 하고 요소 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 등 을 포함하도록 초기화됩니다 . 예를 들어 &lt;code&gt;Any[x, y, z]&lt;/code&gt; 는 모든 값을 포함 할 수있는 이기종 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">다양한 최적화 수준에서 어설 션이 비활성화 될 수 있습니다. 따라서 Assert는 디버깅 도구로만 사용해야하며 인증 확인 (예 : 암호 확인)에 사용해서는 안되며, 기능이 제대로 작동하는 데 필요한 부작용을 Assert 내부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">함수, 유형 또는 매크로 정의에 사용 된 변수를 소개하는 할당은 내부 사용 전에 오지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">쉽게 찾을 수있는 방법은 신체를 다른 (일반) 기능으로 추출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b60a8e096bfa335613b61303e86087f18cd47ed" translate="yes" xml:space="preserve">
          <source>An entirely independent approach to profile visualization is &lt;a href=&quot;https://github.com/vchuravy/PProf.jl&quot;&gt;PProf.jl&lt;/a&gt;, which uses the external &lt;code&gt;pprof&lt;/code&gt; tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">환경 그래프는 각 &lt;code&gt;context&lt;/code&gt; UUID에 대해 루트 맵과 유사하지만 해당 &lt;code&gt;context&lt;/code&gt; 고유 한 이름에서 UUID로 맵을 할당하는 다중 레벨 맵입니다 . 줄리아 볼 때 &lt;code&gt;import X&lt;/code&gt; UUID입니다 패키지의 코드에서 &lt;code&gt;context&lt;/code&gt; , 그것은의 신원 조회 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;graph[context][:X]&lt;/code&gt; . 특히 이것은 &lt;code&gt;import X&lt;/code&gt; 가 &lt;code&gt;context&lt;/code&gt; 에 따라 다른 패키지를 참조 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">환경의 루트 맵은 환경이 주 프로젝트에 사용할 수있는 모든 최상위 종속성 (예 : &lt;code&gt;Main&lt;/code&gt; 에 로드 할 수있는 것)에 대해 패키지 이름을 UUID에 지정합니다 . 줄리아가 발생하면 &lt;code&gt;import X&lt;/code&gt; 주요 프로젝트, 그것의 신원 조회 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;roots[:X]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">모듈의 &lt;code&gt;__init__&lt;/code&gt; 함수를 실행할 때 오류가 발생했습니다 . 발생한 실제 오류는 &lt;code&gt;.error&lt;/code&gt; 필드 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">인덱스 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;str&lt;/code&gt; 에 액세스 하는 중에 유효하지 않은 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">파일 &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; 중에 오류가 발생했습니다 . 오류 세부 사항은 &lt;code&gt;.error&lt;/code&gt; 필드 에서 사용 가능해야 합니다.</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 을 올바르게 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25c5e7a2c4027183bf26e4e9c2615052f9de37e7" translate="yes" xml:space="preserve">
          <source>An example of overflow behavior and how to potentially resolve it is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">전역 상수를 지우도록 요청하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">전역 변수에 할당하려면 명시 적 &lt;code&gt;global&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">이러한 방식으로 래핑 된 표현식은 매크로 확장기에 의해 단독으로 남겨져 단순히 출력 그대로 그대로 붙여 넣어집니다. 따라서 매크로 호출 환경에서 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">불변 객체에는 배열과 같은 가변 객체가 필드로 포함될 수 있습니다. 포함 된 객체는 변경 가능합니다. 불변 객체 자체의 필드 만 다른 객체를 가리 키도록 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">&lt;code&gt;AbstractWorkerPool&lt;/code&gt; 의 구현입니다 . &lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; (및 원격으로 함수를 실행하는 다른 원격 호출)은 작업자 노드에서 직렬화 / 직렬화되지 않은 함수, 특히 클로저 (대량의 데이터를 캡처 할 수 있음)를 캐싱하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">분산 메모리 병렬 컴퓨팅의 구현은 Julia와 함께 제공되는 표준 라이브러리의 일부로 &lt;code&gt;Distributed&lt;/code&gt; 모듈에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Julia 유형 시스템의 중요하고 강력한 기능은 매개 변수라는 점입니다. 유형은 매개 변수를 사용할 수 있으므로 유형 선언은 실제로 가능한 모든 매개 변수 값 조합마다 하나씩 새로운 유형의 전체 계열을 도입합니다. 일부 &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;일반 프로그래밍&lt;/a&gt; 버전을 지원하는 많은 언어가 있습니다.여기서,이를 조작하기위한 데이터 구조 및 알고리즘은 관련된 정확한 유형을 지정하지 않고 특정 될 수있다. 예를 들어 ML, Haskell, Ada, Eiffel, C ++, Java, C #, F # 및 Scala에는 일반적인 프로그래밍 형태가 있습니다. 이러한 언어 중 일부는 진정한 파라 메트릭 다형성 (예 : ML, Haskell, Scala)을 지원하는 반면 다른 언어는 임시 템플릿 기반의 일반 프로그래밍 스타일 (예 : C ++, Java)을 지원합니다. 다양한 언어로 된 다양한 종류의 제네릭 프로그래밍 및 파라 메트릭 유형으로 인해 Julia의 파라 메트릭 유형을 다른 언어와 비교하려고 시도하지 않고 대신 Julia의 시스템 자체를 설명하는 데 중점을 둘 것입니다. 그러나 Julia는 동적으로 유형이 지정된 언어이므로 컴파일 타임에 모든 유형을 결정할 필요가 없으므로,정적 파라 메트릭 유형 시스템에서 발생하는 많은 전통적인 어려움은 비교적 쉽게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe22d7af0ef7feda8cfd84ded555dd181a687db" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-abstract-container&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">주목해야 할 중요한 점은 프로그래머가 인수가 추상 유형 인 함수에 의존하는 경우 성능이 손실되지 않는다는 것입니다. 호출되는 인수 콘크리트 유형의 각 튜플에 대해 다시 컴파일되기 때문입니다. 그러나 추상 유형의 컨테이너 인 함수 인수의 경우 성능 문제가있을 수 있습니다 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a9c84445e53230deb0eebf338b52d84f7d83ccf2" translate="yes" xml:space="preserve">
          <source>An important property of this design is that any code that executes in a file without a warning will behave the same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves differently than it did in the REPL, then you will get a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">기억해야 할 중요한 점은 일단 가져온 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 는 해당 값을 로컬로 캐시 한다는 것입니다. 추가 &lt;code&gt;fetch&lt;/code&gt; 호출에는 네트워크 홉이 필요하지 않습니다. 모든 참조 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 페치되면 원격 저장된 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">추상 유형의 중요한 사용은 구체적 유형에 대한 기본 구현을 제공하는 것입니다. 간단한 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">&lt;code&gt;AbstractDict&lt;/code&gt; ( &lt;code&gt;Dict&lt;/code&gt; ) 또는 &lt;code&gt;Set&lt;/code&gt; like 객체에 대한 인덱싱 작업 이 존재하지 않는 요소에 액세스하거나 삭제하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 에 대한 인덱싱 작업이 인덱스 &lt;code&gt;i&lt;/code&gt; 의 범위를 벗어난 요소에 액세스하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; 의 인스턴스는 64 비트 값의 즉각적인 쌍으로 작고 효율적으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">의 인스턴스 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스 쌍 보유 할 수 있어야 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Real&lt;/code&gt; 의 인스턴스 인 객체 는 임의의 크기와 구조를 가질 수 있으므로 실제로 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스는 개별적으로 할당 된 &lt;code&gt;Real&lt;/code&gt; 객체 에 대한 포인터 쌍으로 표시되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="12aa0088bc6a62b5d720f6445639bc7feea0dfd4" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">보다 복잡한 매크로에서 발생하는 문제는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;위생 문제&lt;/a&gt; 입니다. 간단히 말해서, 매크로는 반환 된 표현식에 도입 된 변수가 확장 된 주변 코드의 기존 변수와 실수로 충돌하지 않도록해야합니다. 반대로, 매크로로 인수로 전달되는 표현식은 종종 &lt;em&gt;예상됩니다.&lt;/em&gt;주변 코드의 맥락에서 평가하고 기존 변수와 상호 작용하고 수정합니다. 매크로가 정의 된 것과 다른 모듈에서 매크로가 호출 될 수 있다는 사실에서 또 다른 우려가 발생합니다. 이 경우 모든 전역 변수가 올바른 모듈로 해석되도록해야합니다. Julia는 이미 텍스트 매크로 확장 (예 : C)이있는 언어에 비해 반환 된 표현식 만 고려하면되기 때문에 큰 이점을 가지고 있습니다. (같은 모든 다른 변수 &lt;code&gt;msg&lt;/code&gt; 에 &lt;code&gt;@assert&lt;/code&gt; 위)를 따라 &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;정상적인 범위 지정 블록 동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소에 액세스하여 &lt;code&gt;i =&amp;gt; x&lt;/code&gt; 반환 하는 반복자입니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 요소의 인덱스이고 &lt;code&gt;x = A[i]&lt;/code&gt; 입니다. 동일한 &lt;code&gt;pairs(A)&lt;/code&gt; , 인덱스의 스타일이 선택 될 수 있다는 점을 제외. 또한 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 의 유효한 색인이 된다는 점을 제외하고 &lt;code&gt;enumerate(A)&lt;/code&gt; 와 유사 하지만 &lt;code&gt;enumerate&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 인덱스에 관계없이 항상 1부터 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">반복자 그 계산 영원히부터 &lt;code&gt;start&lt;/code&gt; 에 의해 증가 &lt;code&gt;step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">를 통해 반복자는 사이클 &lt;code&gt;iter&lt;/code&gt; 영원히. &lt;code&gt;iter&lt;/code&gt; 가 비어 있으면 &lt;code&gt;cycle(iter)&lt;/code&gt; 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="99ec5bfacc5e607a59f3f0e21acc0539e9b04968" translate="yes" xml:space="preserve">
          <source>An iterator that drops element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, returns every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 첫 &lt;code&gt;n&lt;/code&gt; 개 요소를 제외한 모든 요소 를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 첫 &lt;code&gt;n&lt;/code&gt; 개 이하 요소 를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="d764aa048a3e74537873dd366c614add03dee409" translate="yes" xml:space="preserve">
          <source>An iterator that generates element from &lt;code&gt;iter&lt;/code&gt; as long as predicate &lt;code&gt;pred&lt;/code&gt; is true, afterwards, drops every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값을 영원히 생성하는 반복자입니다 . 경우 &lt;code&gt;n&lt;/code&gt; 을 지정 생성 &lt;code&gt;x&lt;/code&gt; (상응하는 횟수를 그 &lt;code&gt;take(repeated(x), n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">&lt;code&gt;(i, x)&lt;/code&gt; 를 산출하는 반복자. 여기서 &lt;code&gt;i&lt;/code&gt; 는 1에서 시작하는 카운터이고, &lt;code&gt;x&lt;/code&gt; 는 주어진 반복자 의 &lt;code&gt;i&lt;/code&gt; 번째 값입니다. 반복 하는 값 &lt;code&gt;x&lt;/code&gt; 뿐만 아니라 지금까지 반복 횟수 가 필요할 때 유용합니다 . 참고 &lt;code&gt;i&lt;/code&gt; 색인에 대한 유효하지 않을 수 있습니다 &lt;code&gt;iter&lt;/code&gt; ; 그것은 수도 있습니다 그 &lt;code&gt;x != iter[i]&lt;/code&gt; , 경우 &lt;code&gt;iter&lt;/code&gt; 1 참조에서 시작하지 않는 인덱스가 &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; 이 있는지 확인하려면 방법 &lt;code&gt;i&lt;/code&gt; 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 와 동일한 요소를 가져 오지만 주어진 &lt;code&gt;state&lt;/code&gt; 에서 시작 하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">모든 크기의 단위 행렬을 나타내는 &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">스칼라 인덱스 배열을 나타내는 객체이며 &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; 에&lt;/a&gt; 의해 그러한 객체로 변환 될 수 있습니다 . 기본적으로 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 데이터를 안전하게 참조하는 객체입니다 . 이 유형은 올바른 유형의 Julia 할당 메모리를 가리 킵니다. &lt;code&gt;Ref&lt;/code&gt; 자체가 참조 되는 한 기본 데이터는 가비지 수집기에서 해제되지 않도록 보호됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">불변 유형의 객체는 불변성으로 인해 프로그래밍 방식으로 원본 객체와 사본을 구분할 수 없으므로 컴파일러가 자유롭게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">조작이 시스템 또는 가비지 콜렉터가 올바르게 처리하기에 너무 많은 메모리를 할당했습니다.</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">작업이 읽기 전용 인 메모리에 쓰려고했습니다.</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">매트릭스 매트릭스 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">행렬 스칼라 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">행렬-벡터 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">모든 특성 값 및 / 또는 벡터를 찾는 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">최적화 된 방법은 찾아 &lt;code&gt;il&lt;/code&gt; 관통 번째 &lt;code&gt;ih&lt;/code&gt; 특성치가 가능한 토륨</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">구간 [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vh&lt;/code&gt; ] 에서 특성 값을 찾는 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">특성 값 &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; 해당하는 특성 벡터를 찾는 최적화 된 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f744563fd636d437613d62cd83f1a88cf9af7cbd" translate="yes" xml:space="preserve">
          <source>An optimized sampler with pre-computed data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">정렬 된 목록은 위의 예의 두 번째 목록에서와 같이 1이 아닌 다른 숫자에서 시작하여 5부터 번호가 매겨 질 수 있습니다. 정렬되지 않은 목록과 마찬가지로 정렬 된 목록에는 중첩 된 최상위 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Julia가 사용할 수있는 최대 스레드 수를 설정 하는 부호없는 64 비트 정수 ( &lt;code&gt;uint64_t&lt;/code&gt; )입니다. 경우 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 가능한 물리적 CPU 코어의 수를 초과 한 후 스레드의 수는 코어 수로 설정됩니다. 경우 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 긍정적 없거나 설정되지 않았거나 CPU 코어의 수는 시스템 호출을 통해 판단 할 수없는 경우, 다음 스레드 수로 설정됩니다 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">업데이트 연산자는 변수를 왼쪽에 리 바인드합니다. 결과적으로 변수 유형이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
