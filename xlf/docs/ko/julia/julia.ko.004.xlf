<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="81f2145109807b12c478f9428b7d01692494e503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb&lt;/code&gt;: An optional callback used to create the &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt;&lt;code&gt;GitRemote&lt;/code&gt;&lt;/a&gt; before making the clone from it.</source>
          <target state="translated">&lt;code&gt;remote_cb&lt;/code&gt; : 콜백을 만들기 전에 &lt;a href=&quot;#LibGit2.GitRemote&quot;&gt; &lt;code&gt;GitRemote&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용되는 선택적 콜백 입니다.</target>
        </trans-unit>
        <trans-unit id="08210342f9819d0a52928951c3cf701a468f0a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_cb_payload&lt;/code&gt;: The payload for the remote callback.</source>
          <target state="translated">&lt;code&gt;remote_cb_payload&lt;/code&gt; : 원격 콜백의 페이로드.</target>
        </trans-unit>
        <trans-unit id="0b84ddfb974082fe30d2fdbc1437b3f617f6a788" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteref_id&lt;/code&gt; is a low-level API which returns a &lt;code&gt;RRID&lt;/code&gt; object that wraps &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; values of a remote reference.</source>
          <target state="translated">&lt;code&gt;remoteref_id&lt;/code&gt; 는 원격 참조의 &lt;code&gt;whence&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 값 을 래핑 하는 &lt;code&gt;RRID&lt;/code&gt; 객체 를 반환하는 저수준 API입니다 .</target>
        </trans-unit>
        <trans-unit id="8507e85a94a6cd1cb8268156f73c57a12952c455" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : &lt;code&gt;remote&lt;/code&gt; 의 URL입니다 .</target>
        </trans-unit>
        <trans-unit id="af1618648ef5cfe8bc793d28a4d2646feb098771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt;: the URL of &lt;code&gt;remote&lt;/code&gt;. If not specified, will be assumed based on the given name of &lt;code&gt;remote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remoteurl::AbstractString=&quot;&quot;&lt;/code&gt; : &lt;code&gt;remote&lt;/code&gt; 의 URL입니다 . 지정하지 않으면 지정된 &lt;code&gt;remote&lt;/code&gt; 이름을 기준으로 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="609e8e82126a8aeb5967ff81fbb3ef2aa24bd998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename_threshold&lt;/code&gt;: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.</source>
          <target state="translated">&lt;code&gt;rename_threshold&lt;/code&gt; : 하나의 파일 이름이 다른 파일 이름으로 바뀌어야 하는 유사성 백분율 유사성을 설정하는 정수입니다. 기본값은 50입니다.</target>
        </trans-unit>
        <trans-unit id="e2a99cf9dace7b445312c1ed6b449e6eaff870cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb&lt;/code&gt;: An optional callback which will be used to create the &lt;em&gt;new&lt;/em&gt; repository into which the clone is made.</source>
          <target state="translated">&lt;code&gt;repository_cb&lt;/code&gt; : 클론이 생성 될 &lt;em&gt;새&lt;/em&gt; 리포지토리 를 만드는 데 사용되는 선택적 콜백입니다 .</target>
        </trans-unit>
        <trans-unit id="69b143fd85b9454789782c1eb3c8d602eb3b9b29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repository_cb_payload&lt;/code&gt;: The payload for the repository callback.</source>
          <target state="translated">&lt;code&gt;repository_cb_payload&lt;/code&gt; : 리포지토리 콜백의 페이로드</target>
        </trans-unit>
        <trans-unit id="5023aea211818a0760fb42fd29ef6a5a0289aa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repr&lt;/code&gt; returns the output of &lt;code&gt;show&lt;/code&gt; as a string.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 은 &lt;code&gt;show&lt;/code&gt; 의 출력을 문자열로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff0db60e6e9b0f8032c3c60e6fb8dfbe0818b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return x&lt;/code&gt; causes the enclosing function to exit early, passing the given value &lt;code&gt;x&lt;/code&gt; back to its caller. &lt;code&gt;return&lt;/code&gt; by itself with no value is equivalent to &lt;code&gt;return nothing&lt;/code&gt; (see &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return x&lt;/code&gt; 는 주어진 값 &lt;code&gt;x&lt;/code&gt; 를 다시 호출자 에게 전달하여 엔 클로징 함수를 일찍 종료시킵니다 . &lt;code&gt;return&lt;/code&gt; 값없이 자체는 동등 &lt;code&gt;return nothing&lt;/code&gt; (볼 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="502272392029d8c1210ca8442ce973a51a80b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="45cec38c32f578811af123b4529c8927598f6954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewrite_notes_ref&lt;/code&gt;: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.</source>
          <target state="translated">&lt;code&gt;rewrite_notes_ref&lt;/code&gt; : 리베이스가 완료 될 때 커밋 노트를 다시 쓰는 데 사용할 노트에 대한 참조 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ee12f97ff2f79dfd78b89cda4ab0e281561a61af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;right_justify&lt;/code&gt; is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).</source>
          <target state="translated">&lt;code&gt;right_justify&lt;/code&gt; 는 로그 메타 데이터가 정당화되는 정수 열입니다. 기본값은 0입니다 (메타 데이터는 자체 행에 있음).</target>
        </trans-unit>
        <trans-unit id="b331dc2677ed78e2b46e6f7e4f15579bf2430629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.ceil&quot;&gt;&lt;code&gt;ceil&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.ceil&quot;&gt; &lt;code&gt;ceil&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b82694560cc17d932ed74b0e5a76969bf6a0851b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.floor&quot;&gt;&lt;code&gt;floor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.floor&quot;&gt; &lt;code&gt;floor&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6064aeb0303df233165e5be4f2a31b0e19b1991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; using this rounding mode is an alias for &lt;a href=&quot;#Base.trunc&quot;&gt;&lt;code&gt;trunc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 이 반올림 모드를 사용하는 별칭입니다 &lt;a href=&quot;#Base.trunc&quot;&gt; &lt;code&gt;trunc&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f32289fec3fa365e6110d93226bbad2f67917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; allows the &lt;code&gt;.&lt;/code&gt; modifier to match newlines.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 허용합니다 &lt;code&gt;.&lt;/code&gt; 개행과 일치하는 수정 자.</target>
        </trans-unit>
        <trans-unit id="f9a850a68210f1321a24f7f9f7751b659bc2b984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sB&lt;/code&gt; has been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:</source>
          <target state="translated">&lt;code&gt;sB&lt;/code&gt; 는 (실제) 대칭 인 행렬로 태그가 지정되었으므로 고유 계수 또는 행렬-벡터 제품 계산과 같은 나중에 수행 할 수있는 작업의 경우 절반 만 참조하면 효율성을 찾을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccc484e194571496ce1eda5190c7d8120eefadd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt;: the URL scheme which identifies the protocol to be used. For HTTP use &quot;http&quot;, SSH use &quot;ssh&quot;, etc. When &lt;code&gt;scheme&lt;/code&gt; is not provided the output format will be &quot;ssh&quot; but using the scp-like syntax.</source>
          <target state="translated">&lt;code&gt;scheme::AbstractString=&quot;&quot;&lt;/code&gt; : 사용할 프로토콜을 식별하는 URL 체계입니다. HTTP는 &quot;http&quot;, SSH는 &quot;ssh&quot;등을 사용합니다. &lt;code&gt;scheme&lt;/code&gt; 이 제공되지 않으면 출력 형식은 &quot;ssh&quot;이지만 scp와 같은 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93b2806e781d6fca17b7143cb112498a0b664a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scroll::Symbol=:na&lt;/code&gt;: If &lt;code&gt;:wrap&lt;/code&gt; then wrap the cursor around top and bottom, if :&lt;code&gt;nowrap&lt;/code&gt; do not wrap cursor</source>
          <target state="translated">&lt;code&gt;scroll::Symbol=:na&lt;/code&gt; 경우 : &lt;code&gt;:wrap&lt;/code&gt; 다음 상단과 하단 커서를 포장, 경우에하는 것은 : &lt;code&gt;nowrap&lt;/code&gt; 커서를 포장하지 않는다</target>
        </trans-unit>
        <trans-unit id="4b280689ba075d50a8bf44f6918ee06bdd7f1ee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_head::Bool=true&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt;, after the branch creation finishes the branch head will be set as the HEAD of &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_head::Bool=true&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 이면 브랜치 생성이 완료된 후 브랜치 헤드가 &lt;code&gt;repo&lt;/code&gt; 의 HEAD로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cc61ed461b5dbaa13fd1fd838ddca4a2542572c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; can speed up some computations on some hardware. However, it can break identities such as &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_zero_subnormals(true)&lt;/code&gt; 는 일부 하드웨어에서 일부 계산 속도를 높일 수 있습니다. 그러나 &lt;code&gt;(x-y==0) == (x==y)&lt;/code&gt; 와 같은 ID를 손상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c2e75ceadb77395d5345eca4bc8bc47dec72358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shaxxx()&lt;/code&gt; takes &lt;code&gt;AbstractString&lt;/code&gt; and array-like objects (&lt;code&gt;NTuple&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;) with elements of type &lt;code&gt;UInt8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shaxxx()&lt;/code&gt; 얻어 &lt;code&gt;AbstractString&lt;/code&gt; 물체 배열 형 ( &lt;code&gt;NTuple&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 형태의 요소) &lt;code&gt;UInt8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ec3df759f8c80bc7761d61c8e5aa7aa26b8f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show&lt;/code&gt;: a flag for which files to examine and in which order. The default is &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; : 검사 할 파일과 순서를 나타내는 플래그입니다. 기본값은 &lt;code&gt;Consts.STATUS_SHOW_INDEX_AND_WORKDIR&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a32266a7567a6361fd0030ea46dc886158ce573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt;: if no matching reference can be found which describes a commit, show the commit's &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; instead of throwing an error (the default behavior).</source>
          <target state="translated">&lt;code&gt;show_commit_oid_as_fallback&lt;/code&gt; : 커밋을 설명하는 일치하는 참조를 찾을 수 없으면 오류를 발생 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 대신 커밋의 GitHash 를 표시합니다 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="321d9936b85b091cfbe32e4ed333aa1019f70153" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;show_limited&lt;/code&gt; limits the printing of large data structures to something which can fit on the screen by setting the &lt;code&gt;:limit&lt;/code&gt;&lt;code&gt;IOContext&lt;/code&gt; key during formatting.</source>
          <target state="translated">&lt;code&gt;show_limited&lt;/code&gt; 는 포맷하는 동안 &lt;code&gt;:limit&lt;/code&gt; &lt;code&gt;IOContext&lt;/code&gt; 키를 설정하여 큰 데이터 구조의 인쇄를 화면에 맞출 수있는 것으로 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="eb77d8781dd9b346f7972d289b6b8d6656b27a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt;: the tagger's signature.</source>
          <target state="translated">&lt;code&gt;sig::Signature=Signature(repo)&lt;/code&gt; : 태그의 서명입니다.</target>
        </trans-unit>
        <trans-unit id="d753c86afdec45711bc5c02d99a4e474cd4a4e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;similarity&lt;/code&gt;: Used to indicate if a file has been renamed or copied.</source>
          <target state="translated">&lt;code&gt;similarity&lt;/code&gt; : 파일 이름이 바뀌 었는지 또는 복사되었는지를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff10e5c77568c1b5f3ae641f11c70c8c65f4ba74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d10f869613b60c50f32f40c9033fbe46c6290e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: the size of the item in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; : 아이템의 크기 (바이트).</target>
        </trans-unit>
        <trans-unit id="5477a94f16fd95259abdf4ec79e87fa8ddde3d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizehint&lt;/code&gt;: suggests a capacity of the buffer (&lt;code&gt;data&lt;/code&gt; must implement &lt;code&gt;sizehint!(data, size)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sizehint&lt;/code&gt; : 버퍼 용량을 제안합니다 ( &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;sizehint!(data, size)&lt;/code&gt; 구현해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="e3b3de6bcf724e5eb7a7cd993fb64be110536dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; Controls the order in &lt;code&gt;:flat&lt;/code&gt; format. &lt;code&gt;:filefuncline&lt;/code&gt; (default) sorts by the source line, whereas &lt;code&gt;:count&lt;/code&gt; sorts in order of number of collected samples.</source>
          <target state="translated">&lt;code&gt;sortedby&lt;/code&gt; &amp;ndash; 순서를 &lt;code&gt;:flat&lt;/code&gt; 형식으로 제어 합니다. &lt;code&gt;:filefuncline&lt;/code&gt; (기본값)은 소스 행을 기준으로 정렬하지만 &lt;code&gt;:count&lt;/code&gt; 는 수집 된 샘플 수를 기준으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="9ab7b3a3ab6403e446642819fa1d378711eeccfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortslices&lt;/code&gt; extends naturally to higher dimensions. E.g., if &lt;code&gt;A&lt;/code&gt; is a a 2x2x2 array, &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; will sort slices within the 3rd dimension, passing the 2x2 slices &lt;code&gt;A[:, :, 1]&lt;/code&gt; and &lt;code&gt;A[:, :, 2]&lt;/code&gt; to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the &lt;code&gt;by&lt;/code&gt; or &lt;code&gt;lt&lt;/code&gt; keyword argument to specify such an order.</source>
          <target state="translated">&lt;code&gt;sortslices&lt;/code&gt; 는 자연스럽게 더 높은 차원으로 확장됩니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 2x2x2 배열 인 경우 &lt;code&gt;sortslices(A, dims=3)&lt;/code&gt; 는 3 차원 내에서 슬라이스를 정렬하여 2x2 슬라이스 &lt;code&gt;A[:, :, 1]&lt;/code&gt; 및 &lt;code&gt;A[:, :, 2]&lt;/code&gt; 를 비교 함수에 전달합니다. . 고차원 슬라이스에는 기본 순서가 없지만 &lt;code&gt;by&lt;/code&gt; 또는 &lt;code&gt;lt&lt;/code&gt; 키워드 인수를 사용하여 이러한 순서를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4951048c7ac40b21df3d0f006898cdcb02270fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spec&lt;/code&gt; is a textual specification: see &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;the git docs&lt;/a&gt; for a full list.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 은 텍스트 사양입니다. 전체 목록 &lt;a href=&quot;https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions&quot;&gt;은 git 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f04859a49c065ca19fcdcec7b6d599fc9662e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt;, &lt;code&gt;&amp;radic;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; , &lt;code&gt;&amp;radic;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1844a8d2cb0ff3056c35be76a61b67e6353a981b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; flags to use in establishing the SSH connection</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; &amp;ndash; SSH 연결 설정에 사용할 플래그</target>
        </trans-unit>
        <trans-unit id="7a4e3e2ec23bd08e30d9fd3aad5785bb62849893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sshflags&lt;/code&gt;: specifies additional ssh options, e.g. &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt;`</source>
          <target state="translated">&lt;code&gt;sshflags&lt;/code&gt; : 지정 추가 SSH 옵션, 예를 들어 &lt;code&gt;sshflags=`-i /home/foo/bar.pem&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="482b777392d5aea02672e566aeba40602b1e6b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stable=true&lt;/code&gt;: enforce Unicode Versioning Stability</source>
          <target state="translated">&lt;code&gt;stable=true&lt;/code&gt; : 유니 코드 버전 안정성 강화</target>
        </trans-unit>
        <trans-unit id="a1d673d269bddb99403b4804cd814dccb535526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_worker&lt;/code&gt; is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.</source>
          <target state="translated">&lt;code&gt;start_worker&lt;/code&gt; 는 TCP / IP를 통해 연결하는 작업자 프로세스의 기본 진입 점 인 내부 함수입니다. 프로세스를 Julia 클러스터 작업자로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0d39313a7b53c31deacd642a6f563eef785766ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startswith&lt;/code&gt; does not compile the anchoring into the regular expression, but instead passes the anchoring as &lt;code&gt;match_option&lt;/code&gt; to PCRE. If compile time is amortized, &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; is faster than &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startswith&lt;/code&gt; 는 앵커를 정규식으로 컴파일하지 않고 대신 앵커를 &lt;code&gt;match_option&lt;/code&gt; 으로 PCRE에 전달합니다 . 컴파일 시간이 상각되면 ( &lt;code&gt;occursin(r&quot;^...&quot;, s)&lt;/code&gt; 가 &lt;code&gt;startswith(s, r&quot;...&quot;)&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="15339811e6d33db9e7897efcdd503d8c3b49eea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: One of &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt;, indicating whether the file has been added/modified/deleted.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : 파일이 추가 / 수정 / 삭제되었는지 여부를 나타내는 &lt;code&gt;Consts.DELTA_STATUS&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="593409fff5972acd2d5fc66532b51e6073c0482a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; : 파일의 상태 플래그를 포함하여 파일이 현재인지 또는 색인 또는 작업 트리에서 어떤 방식으로 변경되었는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7130447a57fb8968eccd9497b959129d184d5ebe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; as a positional argument requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 위치 인수로 멈추려면 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d0f59bf23005820bb215225956bc86d1eabe9e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop&lt;/code&gt; may be specified as either a positional or keyword argument.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 은 위치 또는 키워드 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12b59a2409adf775bb3ba9ebdfd0542b9cb0251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream&lt;/code&gt; must be a &lt;code&gt;TTY&lt;/code&gt;, a &lt;code&gt;Pipe&lt;/code&gt;, or a socket.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 은 &lt;code&gt;TTY&lt;/code&gt; , &lt;code&gt;Pipe&lt;/code&gt; 또는 소켓 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="92d2aefd112ecb4c0e212056a16040530a1c9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; should usually not be defined directly. Instead, define a method &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt;. If &lt;code&gt;string(x)&lt;/code&gt; for a certain type needs to be highly efficient, then it may make sense to add a method to &lt;code&gt;string&lt;/code&gt; and define &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; to ensure the functions are consistent.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 일반적으로 직접 정의해서는 안됩니다. 대신 &lt;code&gt;print(io::IO, x::MyType)&lt;/code&gt; 메소드를 정의하십시오 . 경우 &lt;code&gt;string(x)&lt;/code&gt; 특정 유형의 요구에 매우 효율적으로, 다음은하는 방법을 추가하는 의미가 있습니다 &lt;code&gt;string&lt;/code&gt; 과 정의 &lt;code&gt;print(io::IO, x::MyType) = print(io, string(x))&lt;/code&gt; 기능이 일관되게합니다.</target>
        </trans-unit>
        <trans-unit id="3a0a1bd4f366a04445c7d0b5b5d4912e1e3e7619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strings&lt;/code&gt; can be any iterable over elements &lt;code&gt;x&lt;/code&gt; which are convertible to strings via &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt;. &lt;code&gt;strings&lt;/code&gt; will be printed to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; 은 &lt;code&gt;print(io::IOBuffer, x)&lt;/code&gt; 를 통해 문자열로 변환 할 수있는 요소 &lt;code&gt;x&lt;/code&gt; 에 대해 반복 가능할 수 있습니다 . &lt;code&gt;strings&lt;/code&gt; 은 &lt;code&gt;io&lt;/code&gt; 로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="03d10d2948fe43796bacbfe30f1e399090a85dee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripcc=true&lt;/code&gt;: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified</source>
          <target state="translated">&lt;code&gt;stripcc=true&lt;/code&gt; : 스트립 제어 문자; 가로 탭과 용지 공급은 공백으로 변환됩니다. 개행 변환 플래그를 지정하지 않으면 개행도 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="348e9291c5b543afc5d72a87490213ecd8d4eb07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripignore=true&lt;/code&gt;: strip Unicode's &quot;default ignorable&quot; characters (e.g. the soft hyphen or the left-to-right marker)</source>
          <target state="translated">&lt;code&gt;stripignore=true&lt;/code&gt; : 유니 코드의 &quot;기본 무시할 수있는&quot;문자를 제거합니다 (예 : 소프트 하이픈 또는 왼쪽에서 오른쪽으로 마커)</target>
        </trans-unit>
        <trans-unit id="ea8af5006099bc8365d7c8c2016e824fc2c530ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stripmark=true&lt;/code&gt;: strip diacritical marks (e.g. accents)</source>
          <target state="translated">&lt;code&gt;stripmark=true&lt;/code&gt; : 발음 구별 부호 (예 : 악센트)</target>
        </trans-unit>
        <trans-unit id="152fe4fc303b0a193c1b742fe9f4ede9b98c674b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct T&lt;/code&gt; (including typedef to a struct)</source>
          <target state="translated">&lt;code&gt;struct T&lt;/code&gt; ( struct에 typedef 포함)</target>
        </trans-unit>
        <trans-unit id="c56e50a4a868cc2df17e58d4812fe396996de54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="ba2cc4e0e66a121d0318b71f9b1e31d8945e78e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;s are immutable by default; an instance of one of these types cannot be modified after construction. Use &lt;a href=&quot;#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt; instead to declare a type whose instances can be modified.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 는 기본적으로 불변입니다. 이러한 유형 중 하나의 인스턴스는 구성 후에 수정할 수 없습니다. 인스턴스를 수정할 수있는 유형을 선언 하려면 &lt;a href=&quot;#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="13e850a37abc68848cc3b254dc2d22440b355863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supertype operator&lt;/code&gt; (reverse of subtype operator)</source>
          <target state="translated">&lt;code&gt;supertype operator&lt;/code&gt; (하위 타입 연산자의 반대)</target>
        </trans-unit>
        <trans-unit id="cc1fbbda24d7f513ea72de9ed041f7b7a1294c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;supress_output::Bool=false&lt;/code&gt;: For testing. If true, menu will not be printed to console.</source>
          <target state="translated">&lt;code&gt;supress_output::Bool=false&lt;/code&gt; : 테스트 용. true 인 경우 메뉴가 콘솔에 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="865fee67603befce1b0155fd32588cd0eea3727b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but modifies the arguments &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in-place, instead of making copies.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 , 복사하는 대신 인수 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 를 제자리에서 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="23f1a2a22493ae52966dc56d654ec748102e1aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;svd!&lt;/code&gt; is the same as &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy.</source>
          <target state="translated">&lt;code&gt;svd!&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 사본을 작성하는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 겹쳐 써서 공간을 절약합니다 .</target>
        </trans-unit>
        <trans-unit id="26f8b179c1cd1baf106b501d9f23e6788334be4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; - take a worker from the available pool (to be used for remote function execution)</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; -사용 가능한 풀에서 작업자를 가져옵니다 (원격 기능 실행에 사용).</target>
        </trans-unit>
        <trans-unit id="a385216e2414d1ff7d0e710e07a4b2820a4c3d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; (이 취득을하지만 값을 제거하지 않음)가 비워 질 때까지 성공적으로 기존의 값을 반환 닫힌 채널. 위의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="f655219d63910b18e55d1c7b6d809270664f739b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_directory&lt;/code&gt;: If not empty, checkout to this directory instead of the &lt;code&gt;workdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target_directory&lt;/code&gt; : 비어 있지 않으면 &lt;code&gt;workdir&lt;/code&gt; 대신이 디렉토리를 체크 아웃하십시오 .</target>
        </trans-unit>
        <trans-unit id="73fa24ada0f915b08e5eb705950254ddb5149ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target_limit&lt;/code&gt;: the maximum number of files to compare with to look for renames. The default is 200.</source>
          <target state="translated">&lt;code&gt;target_limit&lt;/code&gt; : 이름을 찾기 위해 비교할 최대 파일 수입니다. 기본값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="8aa9f0c43ae05a2ce21f07a765041be8eb22e9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_local_storage&lt;/code&gt; manipulates a key-value store specific to the current task.</source>
          <target state="translated">&lt;code&gt;task_local_storage&lt;/code&gt; 는 현재 작업과 관련된 키-값 저장소를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="918476307e3ca43e70bc1905ec5bcef98a16e9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;their_label&lt;/code&gt;: In case of conflicts, the name of &quot;their&quot; side.</source>
          <target state="translated">&lt;code&gt;their_label&lt;/code&gt; : 충돌이있을 경우 &quot;그들&quot;의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6030193bdbe78c187e1658db0e709e4fa8490cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology&lt;/code&gt;: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; : 작업자가 서로 연결하는 방법을 지정합니다. 연결되지 않은 작업자간에 메시지를 보내면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afb214098cd0d7a7d60c3cf6760db696f2f4fcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:all_to_all&lt;/code&gt;: All processes are connected to each other. The default.</source>
          <target state="translated">&lt;code&gt;topology=:all_to_all&lt;/code&gt; : 모든 프로세스가 서로 연결되었습니다. 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="88dec064b9bfcaf6a26453d2e661939ebc23d230" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:custom&lt;/code&gt;: The &lt;code&gt;launch&lt;/code&gt; method of the cluster manager specifies the connection topology via fields &lt;code&gt;ident&lt;/code&gt; and &lt;code&gt;connect_idents&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt;. A worker with a cluster manager identity &lt;code&gt;ident&lt;/code&gt; will connect to all workers specified in &lt;code&gt;connect_idents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topology=:custom&lt;/code&gt; 다음 &lt;code&gt;launch&lt;/code&gt; 클러스터 관리자의 방법은 필드를 통해 연결 토폴로지 지정 &lt;code&gt;ident&lt;/code&gt; 와 &lt;code&gt;connect_idents&lt;/code&gt; 에 &lt;code&gt;WorkerConfig&lt;/code&gt; 을 . 클러스터 관리자 신분 인 작업자 &lt;code&gt;ident&lt;/code&gt; 에 지정된 모든 근로자에 연결됩니다 &lt;code&gt;connect_idents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b734d8bcd640fb2c65bc20498e0e55564a7cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topology=:master_worker&lt;/code&gt;: Only the driver process, i.e. &lt;code&gt;pid&lt;/code&gt; 1 connects to the workers. The workers do not connect to each other.</source>
          <target state="translated">&lt;code&gt;topology=:master_worker&lt;/code&gt; : 드라이버 프로세스, 즉 &lt;code&gt;pid&lt;/code&gt; 1 만 작업자에 연결됩니다. 노동자들은 서로 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d9f7d8f681c6583e7676e7d6edc9308af158917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt;: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.</source>
          <target state="translated">&lt;code&gt;track::AbstractString=&quot;&quot;&lt;/code&gt; : 새 분기가 추적해야하는 원격 분기의 이름입니다 (있는 경우). 비어 있으면 (기본값) 원격 지점이 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e2130c7a7a9a101281bd18d3a385769f9600d03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trans&lt;/code&gt;/&lt;code&gt;tX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14ddcb95a156c7bb55a2265603cd736316fe9393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; is a git tree to use to create the commit, showing its ancestry and relationship with any other history. &lt;code&gt;tree&lt;/code&gt; must belong to &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree_id::GitHash = GitHash()&lt;/code&gt; 는 커밋을 생성하는 데 사용되는 자식 트리로, 조상과 다른 기록과의 관계를 보여줍니다. &lt;code&gt;tree&lt;/code&gt; 는 &lt;code&gt;repo&lt;/code&gt; 에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c5eb7dc6b4355a5d1f4c868ec0c32021d4596579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; (1)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; (1)</target>
        </trans-unit>
        <trans-unit id="0936c575e4a9bce1faa418b1592ef449dfc0490a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(T, x)&lt;/code&gt; converts the result to type &lt;code&gt;T&lt;/code&gt;, throwing an &lt;code&gt;InexactError&lt;/code&gt; if the value is not representable.</source>
          <target state="translated">&lt;code&gt;trunc(T, x)&lt;/code&gt; 입력 결과를 변환 &lt;code&gt;T&lt;/code&gt; 를 던지고 &lt;code&gt;InexactError&lt;/code&gt; 을 값을 표현할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="7b21c9a0f1d3cee2b1f4d67453d1344f204a37a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc(x)&lt;/code&gt; returns the nearest integral value of the same type as &lt;code&gt;x&lt;/code&gt; whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x)&lt;/code&gt; 동일한 유형의 가장 가까운 정수 값을 반환 &lt;code&gt;x&lt;/code&gt; 이하일 또는보다 절대 값을 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbee0eec9b2e55430d527d6582dd8877f12bb7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&lt;/code&gt;: truncates the buffer size to zero length.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; : 버퍼 크기를 0 길이로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="41b6e3b3fb48f326fbad1eec1eadf0a833f25b9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try/catch&lt;/code&gt; statements also allow the &lt;code&gt;Exception&lt;/code&gt; to be saved in a variable. The following contrived example calculates the square root of the second element of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is indexable, otherwise assumes &lt;code&gt;x&lt;/code&gt; is a real number and returns its square root:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; 문을 사용하면 &lt;code&gt;Exception&lt;/code&gt; 를 변수에 저장할 수도 있습니다. 다음 인위적인 예제의 두 번째 요소의 제곱근 계산 &lt;code&gt;x&lt;/code&gt; 경우 &lt;code&gt;x&lt;/code&gt; 는 달리 가정, 색인입니다 &lt;code&gt;x&lt;/code&gt; 는 실수이고 그것의 제곱근을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="c33b1b48f85121178c6189a83f36ae5a4de3a504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="abd7dd9b12720a69f43edb81b0af4bb55b4e9603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ttl&lt;/code&gt;: Time-to-live of packets sent on the socket (default: &lt;code&gt;nothing&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; : 소켓에 전송 된 패킷의 수명 (기본값 : &lt;code&gt;nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbe2f11d5812292598ef7400b637ef93f999bc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (use tunneling), &lt;code&gt;false&lt;/code&gt; (do not use tunneling), or &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; (use default for the manager)</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; &amp;ndash; &lt;code&gt;true&lt;/code&gt; (터널링 사용), &lt;code&gt;false&lt;/code&gt; (터널링 사용 안 함) 또는 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; (관리자에 기본값 사용)</target>
        </trans-unit>
        <trans-unit id="402b0271ddb14ba3adb678d7b893e14da34abca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;, &lt;code&gt;bind_addr&lt;/code&gt;, &lt;code&gt;sshflags&lt;/code&gt; and &lt;code&gt;max_parallel&lt;/code&gt; are used when a ssh tunnel is required to connect to the workers from the master process.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; , &lt;code&gt;bind_addr&lt;/code&gt; , &lt;code&gt;sshflags&lt;/code&gt; 및 &lt;code&gt;max_parallel&lt;/code&gt; 은 ssh 터널이 마스터 프로세스에서 작업자에게 연결해야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae98d30d6b9f87be7214d21f7b1f1658026f596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tunnel&lt;/code&gt;: if &lt;code&gt;true&lt;/code&gt; then SSH tunneling will be used to connect to the worker from the master process. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tunnel&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; 인 경우 SSH 터널링을 사용하여 마스터 프로세스에서 작업자에 연결합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fdfbb92ea4996a990fc0aedc71b8b96f842b098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt;: string to use for unchecked</source>
          <target state="translated">&lt;code&gt;unchecked::String=&quot;[ ]&quot;|&quot;⬚&quot;)&lt;/code&gt; : 선택하지 않은 문자열</target>
        </trans-unit>
        <trans-unit id="ae5641baee7f560f12b53646e74002ae2a7b0bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt;: character to use for up arrow</source>
          <target state="translated">&lt;code&gt;up_arrow::Char='^'|'&amp;uarr;'&lt;/code&gt; : 위쪽 화살표에 사용할 문자</target>
        </trans-unit>
        <trans-unit id="1286bd62882b2197d9326752a14abf249e35dcf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_fetchhead&lt;/code&gt;: whether to update the &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; after the fetch. The default is to perform the update, which is the normal git behavior.</source>
          <target state="translated">&lt;code&gt;update_fetchhead&lt;/code&gt; : 페치 후 &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; 를 업데이트할지 여부 . 기본값은 업데이트를 수행하는 것이며 이는 정상적인 git 동작입니다.</target>
        </trans-unit>
        <trans-unit id="689158119264263de422838a5b03a631131c1362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;uplo&lt;/code&gt;/&lt;code&gt;ul&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab24710e9825de064a163f5ce94d79be47ade840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: The URL of the fetch head.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : 가져 오기 헤드의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="f442181197e49f968f2471275a5f012e278f3859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt;: the URL of the proxy.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; : 프록시의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="19c4e769ed90cfd681ef1b310a2d6f9ad4296082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;userdata&lt;/code&gt; is provided for custom cluster managers to store their own worker-specific information.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 정의 클러스터 관리자가 고유 한 작업자 별 정보를 저장하기 위해 userdata 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d3b8331fceffede2316a7974124bb49b8eeb18b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt;: the username to use in the output if provided.</source>
          <target state="translated">&lt;code&gt;username::AbstractString=&quot;&quot;&lt;/code&gt; : 제공된 경우 출력에 사용할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6c27371ad1b21bb51acb86107c58f827061ba3f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using Foo&lt;/code&gt; will load the module or package &lt;code&gt;Foo&lt;/code&gt; and make its &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt;ed names available for direct use. Names can also be used via dot syntax (e.g. &lt;code&gt;Foo.foo&lt;/code&gt; to access the name &lt;code&gt;foo&lt;/code&gt;), whether they are &lt;code&gt;export&lt;/code&gt;ed or not. See the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;using Foo&lt;/code&gt; 를 사용하면 모듈 또는 패키지 &lt;code&gt;Foo&lt;/code&gt; 가로드 되고 &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; 이름을 직접 사용할 수있게됩니다. 이름 은 &lt;code&gt;export&lt;/code&gt; 여부에 관계없이 도트 구문 (예 : &lt;code&gt;Foo.foo&lt;/code&gt; 으로 이름 &lt;code&gt;foo&lt;/code&gt; 에 액세스)을 통해 사용할 수도 있습니다 . 자세한 내용 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;은 모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="838b54a9eab8767958b3b80fdcf1e81d2fcffe22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="3e6a732011c1dc2660c4dbf3be189b6cbac8e5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v&lt;/code&gt; now gets converted to the channel's type with &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;put!&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 는 이제 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;put!&lt;/code&gt; 채널의 타입으로 변환 됩니다 ! 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a66a7e6c62d3aec6a461aa958f979b8da4631830" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: print all additional information</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; : 모든 추가 정보를 인쇄</target>
        </trans-unit>
        <trans-unit id="38771c8d2e3b58102e803157f1021fdc77359ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;: version of the struct in use, in case this changes later. For now, always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; : 나중에 변경되는 경우 사용중인 구조체의 버전입니다. 지금은 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1609ac09d4613eb0a602a783024f2b37f908873d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vl&lt;/code&gt; is the lower bound of the window of eigenvalues to search for, and &lt;code&gt;vu&lt;/code&gt; is the upper bound.</source>
          <target state="translated">&lt;code&gt;vl&lt;/code&gt; 은 검색 할 고유 값 창의 하한이고 &lt;code&gt;vu&lt;/code&gt; 는 상한입니다.</target>
        </trans-unit>
        <trans-unit id="39634ab88344e26a6c4f7e1a95904a898f43f0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; and &lt;code&gt;[[noreturn]]&lt;/code&gt; or &lt;code&gt;_Noreturn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 및 &lt;code&gt;[[noreturn]]&lt;/code&gt; 또는 &lt;code&gt;_Noreturn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f798cc6e3986d2379a7244ce2f55decce5179fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;: a &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt;&lt;code&gt;TimeStruct&lt;/code&gt;&lt;/a&gt; indicating when the commit was authored/committed into the repository.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; : 커밋이 언제 리포지토리에 작성 / 커밋 &lt;a href=&quot;#LibGit2.TimeStruct&quot;&gt; &lt;code&gt;TimeStruct&lt;/code&gt; &lt;/a&gt; 나타내는 TimeStruct .</target>
        </trans-unit>
        <trans-unit id="3719daed583548857eb7718a7ea0092ff6bffe3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;whence&lt;/code&gt; - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling &lt;code&gt;RemoteChannel(2)&lt;/code&gt; from the master process would result in a &lt;code&gt;where&lt;/code&gt; value of 2 and a &lt;code&gt;whence&lt;/code&gt; value of 1.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; - 원격 참조가 작성된 노드를 나타냅니다. 이것은 참조 된 기본 개체가 실제로 존재하는 노드와 다릅니다. 예를 들어 마스터 프로세스에서 &lt;code&gt;RemoteChannel(2)&lt;/code&gt; 을 호출 하면 &lt;code&gt;where&lt;/code&gt; 값이 2이고 &lt;code&gt;whence&lt;/code&gt; 값이 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="4feca933c79656bb4a1cc14d4c9d2c920ea65480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - refers to the node where the underlying object/storage referred to by the reference actually exists.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; -참조가 참조하는 기본 오브젝트 / 스토리지가 실제로 존재하는 노드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be931cf43d24dd627ab40ea349a9901fcb931b4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="551426be1e371b3925c0f4c041a102931aa878ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; loops repeatedly evaluate a conditional expression, and continue evaluating the body of the while loop as long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 반복적으로 조건식을 평가하고 표현식이 true로 유지되는 동안 while 루프의 본문을 계속 평가합니다. while 루프에 처음 도달 할 때 조건 표현식이 false이면 본문이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f18b5d8d4e26142e2aee4c1c2ade071ef4896235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="9e0e55014bc39303400ae1fa6e711c88709191dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_hide::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows no new console window is displayed when the &lt;code&gt;Cmd&lt;/code&gt; is executed. This has no effect if a console is already open or on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_hide::Bool&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )이면 Windows에서 &lt;code&gt;Cmd&lt;/code&gt; 가 실행될 때 새 콘솔 창이 표시되지 않습니다 . 콘솔이 이미 열려 있거나 Windows 이외의 시스템에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dfac6550a56cdb5e20498842d2ca74d4884878f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windows_verbatim::Bool&lt;/code&gt;: If &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;), then on Windows the &lt;code&gt;Cmd&lt;/code&gt; will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes &lt;code&gt;&quot;&lt;/code&gt; in the command line, and &lt;code&gt;\&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt; are preceded by backslashes. &lt;code&gt;windows_verbatim=true&lt;/code&gt; is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</source>
          <target state="translated">&lt;code&gt;windows_verbatim::Bool&lt;/code&gt; : &lt;code&gt;true&lt;/code&gt; (기본값은 &lt;code&gt;false&lt;/code&gt; )이면 Windows에서 &lt;code&gt;Cmd&lt;/code&gt; 는 공백을 포함하는 인수를 포함하여 인수를 인용하거나 이스케이프하지 않고 프로세스에 명령 행 문자열을 보냅니다. (Windows에서 인수는 단일 &quot;명령 줄&quot;문자열로 프로그램에 전송되며 프로그램은 인수로 구문 분석해야합니다. 기본적으로 공백 또는 탭이있는 빈 인수 및 인수 는 명령에서 큰 따옴표로 묶습니다 &lt;code&gt;&quot;&lt;/code&gt; 라인 및 &lt;code&gt;\&lt;/code&gt; 또는 &lt;code&gt;&quot;&lt;/code&gt; 백 슬래시로 시작된다. &lt;code&gt;windows_verbatim=true&lt;/code&gt; ). 비표준 방식으로 자신의 명령 줄을 구문 분석 프로그램을 실행하는 데 유용합니다 비 Windows 시스템에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b8aee3aafac635044e497c27a0514876ff35397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write(io, c)&lt;/code&gt;, in contrast, may emit an encoding depending on &lt;code&gt;typeof(c)&lt;/code&gt;, and &lt;code&gt;read(io, typeof(c))&lt;/code&gt; should read the same encoding as &lt;code&gt;write&lt;/code&gt;. New &lt;code&gt;AbstractChar&lt;/code&gt; types must provide their own implementations of &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write(io, c)&lt;/code&gt; , 대조에 따라 부호화 방출 할 수있다 &lt;code&gt;typeof(c)&lt;/code&gt; , 그리고 &lt;code&gt;read(io, typeof(c))&lt;/code&gt; 와 같은 인코딩 읽어야 &lt;code&gt;write&lt;/code&gt; . 새로운 &lt;code&gt;AbstractChar&lt;/code&gt; 타입은 자체적 인 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;read&lt;/code&gt; 구현을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fadd3731757e74adbe714a9fc3cde1b0f50d386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x % T&lt;/code&gt; converts an integer &lt;code&gt;x&lt;/code&gt; to a value of integer type &lt;code&gt;T&lt;/code&gt; congruent to &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of bits in &lt;code&gt;T&lt;/code&gt;. In other words, the binary representation is truncated to fit.</source>
          <target state="translated">&lt;code&gt;x % T&lt;/code&gt; 는 정수 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;2^n&lt;/code&gt; 적합한 정수 타입 &lt;code&gt;T&lt;/code&gt; 의 값으로 변환합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 의 비트 수입니다 . 즉, 이진 표현이 적합하도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="90c41f1363237dda010ffbdcb1e50483f239fe01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (where &lt;code&gt;&amp;sdot;&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\cdot&lt;/code&gt; in the REPL) is a synonym for &lt;code&gt;dot(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;sdot; y&lt;/code&gt; (여기서 &lt;code&gt;&amp;sdot;&lt;/code&gt; 는 REPL에서 탭 완성 &lt;code&gt;\cdot&lt;/code&gt; 로 입력 할 수 있음 )은 &lt;code&gt;dot(x, y)&lt;/code&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="1a73d00c797f625743ed5be89aa6859e0e140e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x*2^n&lt;/code&gt; computed efficiently for integer values of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x*2^n&lt;/code&gt; 정수 값에 대해 효율적으로 계산되는 x * 2 ^ &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1940ccb42a82ee4f57a9ef424ce506f2b4432f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a950a8c9e0c5cf38b19bf4e5268bb9ee46dfc69c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 동일</target>
        </trans-unit>
        <trans-unit id="ab3ac69532931e0ece805a61f4c297980ed1e736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; may also be arrays of numbers, in which case &lt;code&gt;norm&lt;/code&gt; defaults to the usual &lt;code&gt;norm&lt;/code&gt; function in LinearAlgebra, but may be changed by passing a &lt;code&gt;norm::Function&lt;/code&gt; keyword argument. (For numbers, &lt;code&gt;norm&lt;/code&gt; is the same thing as &lt;code&gt;abs&lt;/code&gt;.) When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays, if &lt;code&gt;norm(x-y)&lt;/code&gt; is not finite (i.e. &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;), the comparison falls back to checking whether all elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are approximately equal component-wise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 숫자의 배열 일 수도 있습니다.이 경우 &lt;code&gt;norm&lt;/code&gt; 은 LinearAlgebra 의 일반적인 &lt;code&gt;norm&lt;/code&gt; 함수로 기본 설정되지만 &lt;code&gt;norm::Function&lt;/code&gt; 키워드 인수를 전달하여 변경 될 수 있습니다 . (숫자의 경우 &lt;code&gt;norm&lt;/code&gt; 은 &lt;code&gt;abs&lt;/code&gt; 와 같습니다 .) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 배열 일 때 &lt;code&gt;norm(x-y)&lt;/code&gt; 이 유한하지 않으면 (즉, &lt;code&gt;&amp;plusmn;Inf&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; ) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 모든 요소 가 컴포넌트와 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="a48f8b3cde36a8ddf02a94dfeb998cab82856e48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; enables &quot;comment mode&quot;: whitespace is enabled except when escaped with &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;#&lt;/code&gt; is treated as starting a comment.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &quot;주석 모드&quot;를 활성화합니다. &lt;code&gt;\&lt;/code&gt; 로 이스케이프 된 경우를 제외하고 공백이 활성화 되며 &lt;code&gt;#&lt;/code&gt; 은 주석 시작으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7e404002ef27b1a2197f45feec798673ffc690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a finite number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 유한 수입니다</target>
        </trans-unit>
        <trans-unit id="c0524cd745ecc91f2a8a799e342f5f682c7f1d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is infinite</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 무한하다</target>
        </trans-unit>
        <trans-unit id="47fb95081b3ce22a0b461fae81e21bbc77c62b2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a number</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 숫자가 아니다</target>
        </trans-unit>
        <trans-unit id="64a786472b355da8522bfc59ef4c0762b67c585b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;Keyword</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;Keyword</target>
        </trans-unit>
        <trans-unit id="54aac4fafe7a37588d94288478848558abaf1196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~/.julia&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; is the user home as appropriate on the system;</source>
          <target state="translated">&lt;code&gt;~/.julia&lt;/code&gt; 여기서 &lt;code&gt;~&lt;/code&gt; 는 시스템에서 적절한 사용자 홈입니다.</target>
        </trans-unit>
        <trans-unit id="2df118c2fbb6c1d7ba0ff4dd87b88d00cf764a55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Before&lt;/em&gt; loading any code, make sure you're running Revise: say &lt;code&gt;using Revise&lt;/code&gt; or follow its documentation on configuring it to run automatically.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;코드를로드 &lt;em&gt;하기 전에&lt;/em&gt; Revise를 실행 중인지 확인하십시오. &lt;code&gt;using Revise&lt;/code&gt; 하거나 자동으로 실행되도록 구성하는 설명서를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="743bea8b6e02264a01bcef3ea67aed3f0cad8650" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Creating&lt;/em&gt; log events is the concern of the module author who needs to decide where events are triggered and which information to include.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;로그 이벤트 &lt;em&gt;작성&lt;/em&gt; 은 이벤트 발생 위치 및 포함 할 정보를 결정해야하는 모듈 작성자의 관심사입니다.</target>
        </trans-unit>
        <trans-unit id="b124a7e86891727331d73882ce0c24f7eaafd8ac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don't copy these examples!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 예제들을 복사하지 마십시오!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71cf9402e58fc3879fb68f8afe68b31dae06eee0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Processing&lt;/em&gt; of log events &amp;mdash; that is, display, filtering, aggregation and recording &amp;mdash; is the concern of the application author who needs to bring multiple modules together into a cooperating application.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;로그 이벤트 &lt;em&gt;처리 (&lt;/em&gt; 즉, 디스플레이, 필터링, 집계 및 기록)는 여러 모듈을 협력 애플리케이션으로 통합해야하는 애플리케이션 작성자의 관심사입니다.</target>
        </trans-unit>
        <trans-unit id="7685c1fa95d4518c2af3eb032fd247fef3129095" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt; sort strategy.</source>
          <target state="translated">&lt;em&gt;분할 및 정복&lt;/em&gt; 정렬 전략.</target>
        </trans-unit>
        <trans-unit id="955d87cc46ecdddf5939b69f5d5e66211dd43025" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;divide-and-conquer&lt;/em&gt;: sort strategy similar to &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt;&lt;code&gt;MergeSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;분할 및 정복&lt;/em&gt; : &lt;a href=&quot;#Base.Sort.MergeSort&quot;&gt; &lt;code&gt;MergeSort&lt;/code&gt; &lt;/a&gt; 와 유사한 정렬 전략 .</target>
        </trans-unit>
        <trans-unit id="547c0f175b81af7715456826fa2ddb801ca75ea1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;good performance&lt;/em&gt; for large collections.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;대규모 컬렉션에 &lt;em&gt;적합한 성능&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76e3721332fa8c80267a6d025e92a7b31c647f77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iid&lt;/em&gt;, independently and identically distributed.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;독립적이고 동일하게 분포 된 &lt;em&gt;iid&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4eecbf6b8e99fcad79c0f04ad8ffa79c56d8a143" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;제자리&lt;/em&gt; 에 메모리.</target>
        </trans-unit>
        <trans-unit id="53b7f08036597cd9367e51ae64cec4b72d17fb7f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not in-place&lt;/em&gt; in memory.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;메모리에 &lt;em&gt;제자리&lt;/em&gt; 에 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69d8a8fdc356b8320c038747a06bcc5697c84ab8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;not stable&lt;/em&gt;: does not preserve the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;안정적이지 않음&lt;/em&gt; : 동일하게 비교되는 요소의 순서를 유지하지 않습니다 (예 : 대소 문자를 무시하는 문자로 &quot;a&quot;및 &quot;A&quot;).</target>
        </trans-unit>
        <trans-unit id="bc0febd17aa71743548f98f48c43c546e1abfb04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;quadratic performance&lt;/em&gt; in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;정렬 할 요소 수의 &lt;em&gt;2 차 성능&lt;/em&gt; : 작은 모음에는 적합하지만 큰 모음에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a1491802554c00bcc7d066e787c837a325301ece" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stable&lt;/em&gt;: preserves the ordering of elements which compare equal (e.g. &quot;a&quot; and &quot;A&quot; in a sort of letters which ignores case).</source>
          <target state="translated">&lt;em&gt;안정&lt;/em&gt; : 동일하게 비교되는 요소의 순서를 유지합니다 (예 : 대소 문자를 무시하는 일종의 문자로 &quot;a&quot;및 &quot;A&quot;).</target>
        </trans-unit>
        <trans-unit id="47450e33687d2bd35b73c1a40f6abb2479676524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A package directory&lt;/strong&gt; is a directory containing the source trees of a set of packages as subdirectories, and forms an &lt;em&gt;implicit environment&lt;/em&gt;. If &lt;code&gt;X&lt;/code&gt; is a subdirectory of a package directory and &lt;code&gt;X/src/X.jl&lt;/code&gt; exists, then the package &lt;code&gt;X&lt;/code&gt; is available in the package directory environment and &lt;code&gt;X/src/X.jl&lt;/code&gt; is the source file by which it is loaded.</source>
          <target state="translated">&lt;strong&gt;패키지 디렉토리&lt;/strong&gt; 는 서브 디렉토리로서 패키지 세트의 소스 트리를 포함하는 디렉토리이며 &lt;em&gt;내재적 환경을&lt;/em&gt; 형성 &lt;em&gt;합니다&lt;/em&gt; . 경우 &lt;code&gt;X&lt;/code&gt; 는 패키지 디렉토리의 서브 디렉토리이며, &lt;code&gt;X/src/X.jl&lt;/code&gt; 존재하고 패키지 &lt;code&gt;X&lt;/code&gt; 는 패키지 디렉토리 환경에서 사용할 수 있으며 &lt;code&gt;X/src/X.jl&lt;/code&gt; 그것을로드하는 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="ab6e1278144bfe85f8b9792c5068eed40f8bd5eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A project environment&lt;/strong&gt; is a directory with a project file and an optional manifest file, and forms an &lt;em&gt;explicit environement&lt;/em&gt;. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.</source>
          <target state="translated">&lt;strong&gt;프로젝트 환경&lt;/strong&gt; 은 프로젝트 파일과 선택적 매니페스트 파일이있는 디렉토리이며 &lt;em&gt;명시적인 환경을&lt;/em&gt; 형성합니다 . 프로젝트 파일은 프로젝트 직접 종속성의 이름과 ID가 무엇인지 결정합니다. 매니페스트 파일이있는 경우 모든 직접 및 간접 종속성, 각 버전의 정확한 버전 및 정확한 버전을 찾아서로드하기에 충분한 정보를 포함하여 완전한 종속성 그래프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5dcf2f7a4986e6945bd060c2a9f0b685ebc4a479" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Automatic promotion for built-in arithmetic types and operators.&lt;/strong&gt; In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum &lt;code&gt;1 + 1.5&lt;/code&gt; as the floating-point value &lt;code&gt;2.5&lt;/code&gt;, even though one of the operands to &lt;code&gt;+&lt;/code&gt; is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</source>
          <target state="translated">&lt;strong&gt;내장 된 산술 유형 및 연산자에 대한 자동 승격&lt;/strong&gt; 대부분의 언어에서 내장 숫자 유형은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 와 같은 접두어 구문이있는 산술 연산자에 대한 피연산자로 사용되는 경우 예상 결과를 자동으로 일반 유형으로 승격합니다. C는, 자바, 펄, 및 Python, 몇 가지 이름을 모두 정확하게 계산 합 &lt;code&gt;1 + 1.5&lt;/code&gt; 부동 소수점 값 &lt;code&gt;2.5&lt;/code&gt; 에 피연산자이더라도 &lt;code&gt;+&lt;/code&gt; 를정수입니다. 이 시스템은 일반적으로 프로그래머에게 보이지는 않지만 충분히 편리하고 신중하게 설계되었습니다. 이러한 표현을 작성할 때이 승격을 의식적으로 생각하는 사람은 거의 없지만, 컴파일러와 인터프리터는 정수와 부동 소수점 이후에 더하기 전에 변환을 수행해야합니다. 포인트 값은 그대로 추가 할 수 없습니다. 이러한 자동 변환에 대한 복잡한 규칙은 필연적으로 이러한 언어에 대한 사양 및 구현의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="40672dddf16a6430318b3eb0b9096db189222d38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brief description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 설명&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="540bb8e1a8c92de3d9695826131a325154196169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Broadcasting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Broadcasting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f7d8aeead87b3699dcf3142b1e6dee864b1f9e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bypassing default machinery&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 기계 우회&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c3f895628a42c1489009a0b0558d48806270adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code inclusion:&lt;/strong&gt; e.g. &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt;. Inclusion allows you to split a single program across multiple source files. The expression &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; causes the contents of the file &lt;code&gt;source.jl&lt;/code&gt; to be evaluated in the global scope of the module where the &lt;code&gt;include&lt;/code&gt; call occurs. If &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; is called multiple times, &lt;code&gt;source.jl&lt;/code&gt; is evaluated multiple times. The included path, &lt;code&gt;source.jl&lt;/code&gt;, is interpreted relative to the file where the &lt;code&gt;include&lt;/code&gt; call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, &lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt;&lt;code&gt;pwd()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;코드 포함 :&lt;/strong&gt; 예 : &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; . 포함을 사용하면 단일 소스 프로그램을 여러 소스 파일로 분할 할 수 있습니다. 표현은 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; 파일의 내용을 발생 &lt;code&gt;source.jl&lt;/code&gt; 이 (가) 여기서 모듈의 전역에서 평가되는 &lt;code&gt;include&lt;/code&gt; 통화가 발생한다. 경우 &lt;code&gt;include(&quot;source.jl&quot;)&lt;/code&gt; , 여러 번 호출 &lt;code&gt;source.jl&lt;/code&gt; 여러 번 평가된다. 포함 된 경로 &lt;code&gt;source.jl&lt;/code&gt; 은 &lt;code&gt;include&lt;/code&gt; 호출이 발생한 파일을 기준으로 해석 됩니다. 소스 파일의 하위 트리를 쉽게 재배치 할 수 있습니다. REPL에서 포함 된 경로는 현재 작업 디렉토리를 기준으로 해석됩니다.&lt;a href=&quot;../../base/file/index#Base.Filesystem.pwd&quot;&gt; &lt;code&gt;pwd()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b2956aa02b611eba1c44ae4666e386f9a69158" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion between linear and cartesian indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선형 인덱스와 데카르트 인덱스 간의 변환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8981b2e89255132713afc6ec39691c7bdea5024d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cursor movement&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;커서 이동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f5b988cb89cb4ede6b56c1271511dfc59d67ac0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 정의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1c863333a531bcda45cde640d9c35956bb33378" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Editing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c838c65ad1ba4b74d30de6df9d506f5e2b0ac9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Everything else&lt;/strong&gt;. Any other arguments.</source>
          <target state="translated">&lt;strong&gt;다른 모든 것&lt;/strong&gt; . 다른 주장들.</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aec29b6e22750bc511d0ca82430cb4a126753e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="3c9102cd5f3ec81f62379dfb14e7e329a015e35f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Extensions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d05122489d09030ff3668a78437ee26a3f82b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;External links&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;외부 링크&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83e0b267355d0c11ea2a53fe10c727c43451c8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Floating-point types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부동 소수점 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a16a8e8a484df94b3401f2c14b02422be6ca3e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function argument&lt;/strong&gt;. Putting a function argument first permits the use of &lt;a href=&quot;../../base/base/index#do&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; blocks for passing multiline anonymous functions.</source>
          <target state="translated">&lt;strong&gt;함수 인수&lt;/strong&gt; . 함수 인수를 먼저 넣으면 여러 줄 익명 함수를 전달하기 위해 &lt;a href=&quot;../../base/base/index#do&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt; 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca787ea86b26829b090b38d91fb7a76042f2799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensional examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 높은 차원의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6a830a0dff55184e4ece6c75f5be5491d3d9702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Higher dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 큰 치수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0fb2b5df39867dacb9671eb2a360e55518f879f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I/O stream&lt;/strong&gt;. Specifying the &lt;code&gt;IO&lt;/code&gt; object first permits passing the function to functions such as &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt;&lt;code&gt;sprint&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;sprint(show, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;I / O를 스트림&lt;/strong&gt; . 시방 &lt;code&gt;IO&lt;/code&gt; 의 첫번째 목적은 다음과 같은 기능을 할 수있는 기능을 전달 가능하게 &lt;a href=&quot;../../base/io-network/index#Base.sprint&quot;&gt; &lt;code&gt;sprint&lt;/code&gt; &lt;/a&gt; 예 &lt;code&gt;sprint(show, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45650bbd2deb4cc345f368e53f1b5e765a99a0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6981e39179d49e3bc1edb6f6043ddc4d3a9c17e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중요한 선택적 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feaf5b204440e5d7b91a26fca33465989ee60de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input being mutated&lt;/strong&gt;. For example, in &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!(x, v)&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt; is the object being mutated and it appears before the value to be inserted into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력이 변경되고&lt;/strong&gt; 있습니다. 예를 위해, &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!(x, v)&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;x&lt;/code&gt; 변이되는 목적 및 값에 삽입하기 전에이 표시 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35035aa4af72e7ec2407cb311a13aa4b3f4086e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input not being mutated&lt;/strong&gt;. In &lt;code&gt;fill!(x, v)&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; being mutated and it comes after &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력이 변경되지 않았습니다&lt;/strong&gt; . 에서 &lt;code&gt;fill!(x, v)&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 변이되고 그것은 뒤에 오는 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c1aac8a2ffe99a6f68662d283f199e4c7902db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Integer types:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정수 유형 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b0deb4e2e9417b81879cdc846953811ed3197f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key&lt;/strong&gt;. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.</source>
          <target state="translated">&lt;strong&gt;키&lt;/strong&gt; . 연관 컬렉션의 경우 키-값 쌍의 키입니다. 다른 인덱스 컬렉션의 경우 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="ff1552788ed9b7867471169f6f6e13e67ae56e49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키워드 인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6d1fbca2eaaca33fbedfae851b1718e81cb621c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keyword arguments&lt;/strong&gt;. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.</source>
          <target state="translated">&lt;strong&gt;키워드 인수&lt;/strong&gt; . Julia에서 키워드 인수는 함수 정의에서 마지막에 와야합니다. 완전성을 위해 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="940941ba13fb5db6a5ccc6b2d81447af0218c6f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keywords&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keywords&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="739565cef16139694d18e4e833e383d92f6229e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lather. Rinse. Repeat.&lt;/strong&gt; Explore ideas at the &lt;code&gt;julia&lt;/code&gt; command prompt. Save good ideas in &lt;code&gt;tst.jl&lt;/code&gt;. To execute &lt;code&gt;tst.jl&lt;/code&gt; after it has been changed, just &lt;code&gt;include&lt;/code&gt; it again.</source>
          <target state="translated">&lt;strong&gt;비누 거품. 헹구기. 반복. &lt;/strong&gt; &lt;code&gt;julia&lt;/code&gt; 명령 프롬프트 에서 아이디어를 탐색하십시오 . &lt;code&gt;tst.jl&lt;/code&gt; 에 좋은 아이디어를 저장하십시오 . &lt;code&gt;tst.jl&lt;/code&gt; 이 변경된 후에 실행하려면 다시 &lt;code&gt;include&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="062ff7c1f91aac8affdefeef654af299368b137e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No automatic promotion.&lt;/strong&gt; This camp includes Ada and ML &amp;ndash; very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression &lt;code&gt;1 + 1.5&lt;/code&gt; would be a compilation error in both Ada and ML. Instead one must write &lt;code&gt;real(1) + 1.5&lt;/code&gt;, explicitly converting the integer &lt;code&gt;1&lt;/code&gt; to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</source>
          <target state="translated">&lt;strong&gt;자동 프로모션이 없습니다. &lt;/strong&gt;이 캠프에는 Ada 및 ML이 포함됩니다. 매우 &quot;엄격한&quot;정적 유형 언어입니다. 이러한 언어에서는 프로그래머가 모든 변환을 명시 적으로 지정해야합니다. 따라서 식 &lt;code&gt;1 + 1.5&lt;/code&gt; 의 예 는 Ada와 ML 모두에서 컴파일 오류입니다. 대신 &lt;code&gt;real(1) + 1.5&lt;/code&gt; 추가하기 전에 정수 &lt;code&gt;1&lt;/code&gt; 을 부동 소수점 값 으로 명시 적으로 변환하여 real (1) + 1.5를 작성해야합니다 . 그러나 모든 곳에서 명시 적 변환은 매우 불편하므로 Ada조차도 어느 정도의 자동 변환이 가능합니다. 정수 리터럴은 예상되는 정수 유형으로 자동 승격되고 부동 소수점 리터럴은 적절한 부동 소수점 유형으로 유사하게 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="19f000a09892ceb4a24beccfa194f3fb0e83a418" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-traditional indices&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비 전통적인 지수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3411b52319b78e51339257b20de47be2deece6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Due to the specifics of the &lt;code&gt;libgit2&lt;/code&gt; authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;libgit2&lt;/code&gt; 인증 절차 의 특성상 인증이 실패하면 인증 성공 여부를 알리지 않고이 함수가 다시 호출됩니다. 무한 루프가 동일한 잘못된 자격 증명을 반복적으로 사용하는 것을 방지하기 위해 페이로드를 사용하여 상태를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="9305d29fbc35afa9e63a3c399be778dee6ddefff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 섹션에서는 Unix와 유사한 운영 체제에서 C로 Julia 코드를 임베드하는 방법에 대해 설명합니다. Windows에서이 작업을 수행하려면 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbff1879231e49a20a9f4f3abc431b43d8a6387c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선택적 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fb86f3d0dc24e6e4655476741634ef5c5d50df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package loading:&lt;/strong&gt; e.g. &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;. The import mechanism allows you to load a package&amp;mdash;i.e. an independent, reusable collection of Julia code, wrapped in a module&amp;mdash;and makes the resulting module available by the name &lt;code&gt;X&lt;/code&gt; inside of the importing module. If the same &lt;code&gt;X&lt;/code&gt; package is imported multiple times in the same Julia session, it is only loaded the first time&amp;mdash;on subsequent imports, the importing module gets a reference to the same module. Note though, that &lt;code&gt;import X&lt;/code&gt; can load different packages in different contexts: &lt;code&gt;X&lt;/code&gt; can refer to one package named &lt;code&gt;X&lt;/code&gt; in the main project but potentially to different packages also named &lt;code&gt;X&lt;/code&gt; in each dependency. More on this below.</source>
          <target state="translated">&lt;strong&gt;패키지 로딩 :&lt;/strong&gt; 예 &lt;strong&gt;: &lt;/strong&gt; &lt;code&gt;import X&lt;/code&gt; 또는 &lt;code&gt;using X&lt;/code&gt; . 가져 오기 메커니즘을 사용하면 패키지 (즉, 모듈에 싸여있는 독립적이고 재사용 가능한 Julia 코드 모음)를로드 하고 가져 오기 모듈 내부 에서 이름 &lt;code&gt;X&lt;/code&gt; 로 결과 모듈을 사용할 수 있습니다 . 동일한 Julia 세션에서 동일한 &lt;code&gt;X&lt;/code&gt; 패키지를 여러 번 가져 오는 경우, 처음 가져올 때만로드됩니다. 후속 가져 오기에서 가져 오기 모듈은 동일한 모듈에 대한 참조를 가져옵니다. 하는 것으로, 비록 &lt;code&gt;import X&lt;/code&gt; 서로 다른 상황에서 다른 패키지를로드 할 수 있습니다 : &lt;code&gt;X&lt;/code&gt; 는 이름이 하나 개의 패키지를 참조 할 수 있습니다 &lt;code&gt;X&lt;/code&gt; 를 명명 된 다른 패키지에 잠재적으로 주요 프로젝트에 있지만 &lt;code&gt;X&lt;/code&gt; 각 의존성에서. 이에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd7c146c235ccd96ea634cfca88f3355f9e6c234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Program control&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로그램 제어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a191672dfe99327da9dff700b45c0a90a2ec39c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put code under development in a temporary module.&lt;/strong&gt; Create a file, say &lt;code&gt;Tmp.jl&lt;/code&gt;, and include within it</source>
          <target state="translated">&lt;strong&gt;임시 모듈에 개발중인 코드를 넣습니다. &lt;/strong&gt; &lt;code&gt;Tmp.jl&lt;/code&gt; 이라는 파일을 만들고 그 안에 포함하십시오</target>
        </trans-unit>
        <trans-unit id="4eebb852c621ba2a07cde7c387d74387c1073db2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Put your test code in another file.&lt;/strong&gt; Create another file, say &lt;code&gt;tst.jl&lt;/code&gt;, which looks like</source>
          <target state="translated">&lt;strong&gt;테스트 코드를 다른 파일에 넣으십시오. &lt;/strong&gt; &lt;code&gt;tst.jl&lt;/code&gt; 과 같은 다른 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="261a3928dc6c3e62bad4f4dc9c5ff983868f3948" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한보십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76a6a8a34ed60528197f028d9fedecb6c66b4c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System Independent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시스템 독립적 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212d71ac9a214ae43f2cb6533589aa526743d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;System-dependent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;System-dependent:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="62fabcca68af5e84228e26aadaf1eb51caedddfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 디렉토리 &lt;strong&gt;의 종속성 그래프&lt;/strong&gt; 는 각 패키지의 하위 디렉토리에있는 프로젝트 파일의 존재 여부와 내용에 따라 결정됩니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35fd5fb379b76233f79b688e018757619277e941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The dependency graph&lt;/strong&gt; of a project environment is determined by the contents of the manifest file, if present. If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for &lt;code&gt;App&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 환경 &lt;strong&gt;의 종속성 그래프&lt;/strong&gt; 는 존재하는 경우 매니페스트 파일의 내용에 따라 결정됩니다. 매니페스트 파일이 없으면 그래프가 비어 있습니다. 매니페스트 파일에는 각 프로젝트의 직접 또는 간접 종속성에 대한 스탠자가 포함되어 있습니다. 각 종속성에 대해 파일은 패키지의 UUID와 소스 트리 해시 또는 소스 코드의 명시 적 경로를 나열합니다. &lt;code&gt;App&lt;/code&gt; 에 대한 다음 매니페스트 파일 예제를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="99a933b1a5fc31f0c493bc7563a8e1ef2ab60637" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여기서 핵심은 Julia 코드는 내부적으로 언어 자체에서 액세스 할 수있는 데이터 구조로 표현된다는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ec20ee36876b86777c4834a05d78e1ed0df59a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is &lt;code&gt;/home/me/animals&lt;/code&gt; then the &lt;code&gt;paths&lt;/code&gt; map could be represented by this dictionary:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;패키지 디렉토리 &lt;strong&gt;의 경로 맵&lt;/strong&gt; 은 간단합니다. 하위 디렉토리 이름을 해당 진입 점 경로에 맵핑합니다. 즉, 예제 프로젝트 디렉토리의 경로가 &lt;code&gt;/home/me/animals&lt;/code&gt; 인 경우 &lt;code&gt;paths&lt;/code&gt; 맵은이 사전으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7176439c445de46708b9fc3e70d97730d2317fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The paths map&lt;/strong&gt; of a project environment is extracted from the manifest file. The path of a package &lt;code&gt;uuid&lt;/code&gt; named &lt;code&gt;X&lt;/code&gt; is determined by these rules (in order):</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;프로젝트 환경 &lt;strong&gt;의 경로 맵&lt;/strong&gt; 은 매니페스트 파일에서 추출됩니다. &lt;code&gt;X&lt;/code&gt; 라는 패키지 &lt;code&gt;uuid&lt;/code&gt; 의 경로는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d291e6a57a7e987da705641960c2e565ce87e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; is determined by examining the contents of the package directory to generate a list of all packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found inside the folder &lt;code&gt;X&lt;/code&gt;...</source>
          <target state="translated">&lt;strong&gt;루트 맵&lt;/strong&gt; 은 존재하는 모든 패키지 목록을 생성하기 위해 패키지 디렉토리의 내용을 검사하여 결정됩니다. 또한 UUID는 다음과 같이 각 항목에 할당됩니다. &lt;code&gt;X&lt;/code&gt; 폴더 안에있는 지정된 패키지의 경우 ...</target>
        </trans-unit>
        <trans-unit id="cd6e60a191a6ba1c08e90279b391c492d145ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The roots map&lt;/strong&gt; of the environment is determined by the contents of the project file, specifically, its top-level &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt; entries and its &lt;code&gt;[deps]&lt;/code&gt; section (all optional). Consider the following example project file for the hypothetical application, &lt;code&gt;App&lt;/code&gt;, as described earlier:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;환경 &lt;strong&gt;의 루트 맵&lt;/strong&gt; 은 프로젝트 파일의 내용, 특히 최상위 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;uuid&lt;/code&gt; 항목 및 &lt;code&gt;[deps]&lt;/code&gt; 섹션 (모두 선택 사항)에 따라 결정됩니다. 앞에서 설명한 가상 응용 프로그램 &lt;code&gt;App&lt;/code&gt; 에 대한 다음 예제 프로젝트 파일을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="fda932e2af71b43d983578e7c22d5ddfec83e11d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type&lt;/strong&gt;. Passing a type typically means that the output will have the given type. In &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt;&lt;/a&gt;, the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read(io, String)&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;IO&lt;/code&gt; argument appears before the type, which is in keeping with the order outlined here.</source>
          <target state="translated">&lt;strong&gt;을 입력하십시오&lt;/strong&gt; . 유형을 전달하면 일반적으로 출력에 지정된 유형이 있음을 의미합니다. 에서 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse(Int, &quot;1&quot;)&lt;/code&gt; &lt;/a&gt; 문자열을 구문 분석하기 전에, 유형 온다. 유형이 먼저 나타나는 많은 예제가 있지만 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read(io, String)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;IO&lt;/code&gt; 인수가 유형 앞에 나타나고 여기에 설명 된 순서에 따라 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="93eadc871861400a6078e0c61f3521be0b3a0f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;. For associative collections, this is the value of the key-value pair(s). In cases like &lt;code&gt;fill!(x, v)&lt;/code&gt;, this is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;가치&lt;/strong&gt; . 연관 콜렉션의 경우 이는 키-값 쌍의 값입니다. &lt;code&gt;fill!(x, v)&lt;/code&gt; 와 같은 경우 이것은 &lt;code&gt;v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e5d0e0a9d5ca3af4a899d7c1e28f16c0a7bba6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Varargs&lt;/strong&gt;. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt;, the dimensions can be given as a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt;, or as &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;s, e.g. &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Varargs&lt;/strong&gt; . 이것은 함수 호출 끝에 무기한으로 나열 될 수있는 인수를 나타냅니다. 예를 들어, &lt;code&gt;Matrix{T}(undef, dims)&lt;/code&gt; 에서 차원은 &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; , 예를 들어 &lt;code&gt;Matrix{T}(undef, (1,2))&lt;/code&gt; 또는 &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; 로 제공 될 수 있습니다 ( 예 : &lt;code&gt;Matrix{T}(undef, 1, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="545631b4b295bbbbaed02465401d0864d0ba7cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What code will this generate?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떤 코드가 생성됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3b9ef5ff046429380c724127c17394868104ef2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What happens next?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다음은 어떻게됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0ff7b4939bf14804a87f9610d1e80a40b4a40b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b12835c0c0b2c5b88b2a8e731d5eb2b1969e8e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a1a83d04dbd981bd8fe4ab619b42f958ca751fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH12]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH12]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b43d748a54903580e1f21b7242d8d7bb7c4a651a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_1]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_1]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a356e5ff840b60f1a7fd81a3055863d97b69c77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_2]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_2]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b68ee69a50f3609b2ad16980f29687180123ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_3]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_3]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a85a3aeb27ca57bd4a8e009398c96aa33508ed10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_4]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_4]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd2e496892d30147f2d48e88aa633252774dbf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_5]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_5]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ddc74cbd626ac29e02b601b534c540a40ab5c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AH16_6]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AH16_6]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e97166948a5a3dd11986acbec9fbe6e3cecc60a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[AHR13]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[AHR13]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65bccd8483458eb47f0cf100e59d18c925a72cfd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[B96]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[B96]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c87f94a30b3537fd21ece46a3be3dc64a62b55b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[BH83]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[BH83]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b1b49422b93ae8106416d25659e6c4a205faf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bischof1987]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27d14e168d4fa4ad2378bdf18be346c186cebb91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Bunch1977]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a39f9cf2c50ef187780e440b9a6f2239b055ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Clarke61]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Clarke61]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c9f7af37c9c1abf3d2cee7bcb7b4328414a23f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[H05]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[H05]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86010be2d69f415c30df7072124ec31548c70f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[KY88]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[KY88]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95c6fae5f939df06b7b59cc5c966b9329d025d70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[S84]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[S84]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6c947d8396f46ae50ccb15050b140acd93e682" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[Schreiber1989]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274fa9920703743f7af11b5a3280a2a8b5492b20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[issue8859]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[issue8859]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb59e9858773588134a730e8495054b325e35ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;graph:&lt;/strong&gt;&lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;그래프 : &lt;/strong&gt; &lt;code&gt;context::UUID&lt;/code&gt; ⟶ &lt;code&gt;name::Symbol&lt;/code&gt; uu &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da29c13a3741ca50b24df3f7e215f047cc6fe3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;malloc/free&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc/free&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc5e4770f37b853a29d3b06890d6a4abca810ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;paths:&lt;/strong&gt;&lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;경로 : &lt;/strong&gt; &lt;code&gt;uuid::UUID&lt;/code&gt; &amp;times; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;path::String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e060769be59aa948e668dd91db6570aedd04731c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;roots:&lt;/strong&gt;&lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;뿌리 : &lt;/strong&gt; &lt;code&gt;name::Symbol&lt;/code&gt; ⟶ &lt;code&gt;uuid::UUID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec6dd4d3b2fc9b4797a8648dcfb6a94dffc781ff" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;4.0 &lt;i&gt;전&lt;/i&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="4b5fcf2420327f83a4a6033c345a55bd47a95680" translate="yes" xml:space="preserve">
          <source>==()</source>
          <target state="translated">==()</target>
        </trans-unit>
        <trans-unit id="924d44730ffe4a504a8c5b50688254e4e4997e86" translate="yes" xml:space="preserve">
          <source>@__DIR__</source>
          <target state="translated">@__DIR__</target>
        </trans-unit>
        <trans-unit id="bd05d820a39cc57788c144db33dd9e5d64bc802d" translate="yes" xml:space="preserve">
          <source>@__FILE__</source>
          <target state="translated">@__FILE__</target>
        </trans-unit>
        <trans-unit id="0a7e2fb02c2ce1b02c47c60a07b07cab4fff90c0" translate="yes" xml:space="preserve">
          <source>@__LINE__</source>
          <target state="translated">@__LINE__</target>
        </trans-unit>
        <trans-unit id="cc0701eaddfdfad8a65ef41e959c8e4f27062811" translate="yes" xml:space="preserve">
          <source>@__MODULE__</source>
          <target state="translated">@__MODULE__</target>
        </trans-unit>
        <trans-unit id="0662c8864fe3f1ee3b1e0fb430b61c3e64455909" translate="yes" xml:space="preserve">
          <source>@allocated</source>
          <target state="translated">@allocated</target>
        </trans-unit>
        <trans-unit id="521dba9e02174468f68a0b805b470b64bd37b2ab" translate="yes" xml:space="preserve">
          <source>@assert</source>
          <target state="translated">@assert</target>
        </trans-unit>
        <trans-unit id="3b7c965e962f36eb0e6c472eea82392cdc514ade" translate="yes" xml:space="preserve">
          <source>@async</source>
          <target state="translated">@async</target>
        </trans-unit>
        <trans-unit id="e9bfca0d6780244df737a5f488a11f321a4e3e28" translate="yes" xml:space="preserve">
          <source>@b_str</source>
          <target state="translated">@b_str</target>
        </trans-unit>
        <trans-unit id="f0925e6a5b16433b144a470019c1c0dd5de55e2d" translate="yes" xml:space="preserve">
          <source>@boundscheck</source>
          <target state="translated">@boundscheck</target>
        </trans-unit>
        <trans-unit id="4c462c8f8efc0e427cbc1cf6bea236a9cc0c83e0" translate="yes" xml:space="preserve">
          <source>@cfunction</source>
          <target state="translated">@cfunction</target>
        </trans-unit>
        <trans-unit id="4edd1d89ba51e67e5cde36c993ecbd6d4257872d" translate="yes" xml:space="preserve">
          <source>@deprecate</source>
          <target state="translated">@deprecate</target>
        </trans-unit>
        <trans-unit id="c460a7d72a405ba1e96118402a7742091a82dc52" translate="yes" xml:space="preserve">
          <source>@elapsed</source>
          <target state="translated">@elapsed</target>
        </trans-unit>
        <trans-unit id="34bfbc0fb605f42aad89cbd346daff31c66f5b0e" translate="yes" xml:space="preserve">
          <source>@eval</source>
          <target state="translated">@eval</target>
        </trans-unit>
        <trans-unit id="0ce3f8c769d6a2e9b95a931f13c7916418581d1b" translate="yes" xml:space="preserve">
          <source>@generated</source>
          <target state="translated">@generated</target>
        </trans-unit>
        <trans-unit id="d7621df9275358d3c30a2cfd8844f4521261ee73" translate="yes" xml:space="preserve">
          <source>@gensym</source>
          <target state="translated">@gensym</target>
        </trans-unit>
        <trans-unit id="a443a35e19dcd1ec15e45404c7ffcdeb21fd2474" translate="yes" xml:space="preserve">
          <source>@goto</source>
          <target state="translated">@goto</target>
        </trans-unit>
        <trans-unit id="19d47413bcaa88444056e76c473085f6a1b72db9" translate="yes" xml:space="preserve">
          <source>@inbounds</source>
          <target state="translated">@inbounds</target>
        </trans-unit>
        <trans-unit id="b5cf25ca00c54f41be13cd9463b582cceefc51b6" translate="yes" xml:space="preserve">
          <source>@inline</source>
          <target state="translated">@inline</target>
        </trans-unit>
        <trans-unit id="8ca0acccfff73ec5f39bf9a76ceb21c3d72aa439" translate="yes" xml:space="preserve">
          <source>@isdefined</source>
          <target state="translated">@isdefined</target>
        </trans-unit>
        <trans-unit id="03c2e7fdb001cbf566801d52a83375cbdaa52bd5" translate="yes" xml:space="preserve">
          <source>@label</source>
          <target state="translated">@label</target>
        </trans-unit>
        <trans-unit id="4ea1201781ae986fc43d71514b609cb6e748d76c" translate="yes" xml:space="preserve">
          <source>@macroexpand</source>
          <target state="translated">@macroexpand</target>
        </trans-unit>
        <trans-unit id="1fd88e55d30c6edcea950811aea00f2ce4456bac" translate="yes" xml:space="preserve">
          <source>@macroexpand1</source>
          <target state="translated">@macroexpand1</target>
        </trans-unit>
        <trans-unit id="78b6dbe95bbae61a934cb6e904cb50533688efaf" translate="yes" xml:space="preserve">
          <source>@noinline</source>
          <target state="translated">@noinline</target>
        </trans-unit>
        <trans-unit id="a5325bbb0409334c7f59038d601431b5a3a33c33" translate="yes" xml:space="preserve">
          <source>@nospecialize</source>
          <target state="translated">@nospecialize</target>
        </trans-unit>
        <trans-unit id="cacd42ee4286c01451a0c3f4cbfa6028f915c0f9" translate="yes" xml:space="preserve">
          <source>@polly</source>
          <target state="translated">@polly</target>
        </trans-unit>
        <trans-unit id="4806d3609cdd2247d8453f645dee6710dc41ea0f" translate="yes" xml:space="preserve">
          <source>@propagate_inbounds</source>
          <target state="translated">@propagate_inbounds</target>
        </trans-unit>
        <trans-unit id="8d60f37515947a1cb20c28aea812b1fc5a9f5bf0" translate="yes" xml:space="preserve">
          <source>@pure</source>
          <target state="translated">@pure</target>
        </trans-unit>
        <trans-unit id="3a55093c30bbbe794bf8d402406d8fcf7a4d1310" translate="yes" xml:space="preserve">
          <source>@r_str</source>
          <target state="translated">@r_str</target>
        </trans-unit>
        <trans-unit id="5996760e14e5f71bfe6fa0d484bd050be2d81350" translate="yes" xml:space="preserve">
          <source>@raw_str</source>
          <target state="translated">@raw_str</target>
        </trans-unit>
        <trans-unit id="97cb7ca3c593693dc788600f2394549a69a72d68" translate="yes" xml:space="preserve">
          <source>@s_str</source>
          <target state="translated">@s_str</target>
        </trans-unit>
        <trans-unit id="0b2cd610c2ee6714f1bb72ef08e30cbecc00753b" translate="yes" xml:space="preserve">
          <source>@show</source>
          <target state="translated">@show</target>
        </trans-unit>
        <trans-unit id="74ed0e99c473ebedb95b8c861f075073cb57397f" translate="yes" xml:space="preserve">
          <source>@specialize</source>
          <target state="translated">@specialize</target>
        </trans-unit>
        <trans-unit id="151387036f429960867face2abcd91f32770c4e2" translate="yes" xml:space="preserve">
          <source>@static</source>
          <target state="translated">@static</target>
        </trans-unit>
        <trans-unit id="a68f475d88760f9b0feb2de9ebbfc91426a3b8f2" translate="yes" xml:space="preserve">
          <source>@sync</source>
          <target state="translated">@sync</target>
        </trans-unit>
        <trans-unit id="d38a8f83640ce0fff0b022161540cfdf0fb32550" translate="yes" xml:space="preserve">
          <source>@task</source>
          <target state="translated">@task</target>
        </trans-unit>
        <trans-unit id="aa18b4621d361b5a46f6036593dc03baa5cf1328" translate="yes" xml:space="preserve">
          <source>@threadcall</source>
          <target state="translated">@threadcall</target>
        </trans-unit>
        <trans-unit id="692eee2d0727b5f3f157c333231a8f4d656b6df0" translate="yes" xml:space="preserve">
          <source>@threadcall (Experimental)</source>
          <target state="translated">@threadcall (실험)</target>
        </trans-unit>
        <trans-unit id="cd087251781047bb579dc74d06a058b6ba3920e2" translate="yes" xml:space="preserve">
          <source>@time</source>
          <target state="translated">@time</target>
        </trans-unit>
        <trans-unit id="8568facb0a4570662a512fe404e622e193f338a6" translate="yes" xml:space="preserve">
          <source>@timed</source>
          <target state="translated">@timed</target>
        </trans-unit>
        <trans-unit id="27b687fc74e91aa623c8e1b6ee200080f7df4707" translate="yes" xml:space="preserve">
          <source>@timev</source>
          <target state="translated">@timev</target>
        </trans-unit>
        <trans-unit id="805c0ec7ef38a1e449165679942f376bf2b79ddf" translate="yes" xml:space="preserve">
          <source>@v_str</source>
          <target state="translated">@v_str</target>
        </trans-unit>
        <trans-unit id="30bb2b68176ace645967cfe93607300e8069c9f2" translate="yes" xml:space="preserve">
          <source>@view</source>
          <target state="translated">@view</target>
        </trans-unit>
        <trans-unit id="c0636d48f28866f15bfbc1ee9241d4414596eec3" translate="yes" xml:space="preserve">
          <source>@views</source>
          <target state="translated">@views</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="ae3a173d257f68d7b3200b2390513b03472ff42a" translate="yes" xml:space="preserve">
          <source>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported &lt;code&gt;isbits&lt;/code&gt; element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides(A)&lt;/code&gt;&lt;/a&gt; method that returns a tuple of &quot;strides&quot; for each dimension; a provided &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt; method accesses the &lt;code&gt;k&lt;/code&gt;th element within this tuple. Increasing the index of dimension &lt;code&gt;k&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; should increase the index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;getindex(A,i)&lt;/code&gt; by &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt;&lt;code&gt;stride(A,k)&lt;/code&gt;&lt;/a&gt;. If a pointer conversion method &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt;&lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt;&lt;/a&gt; is provided, the memory layout must correspond in the same way to these strides. &lt;code&gt;DenseArray&lt;/code&gt; is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the appropriate definition of &lt;code&gt;strides&lt;/code&gt;. More concrete examples can be found within the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;interface guide for strided arrays&lt;/a&gt;. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">지원되는 &lt;code&gt;isbits&lt;/code&gt; 요소 유형을 가진 인스턴스 가이 메모리 레이아웃을 예상하는 외부 C 및 Fortran 함수에 전달 될 수 있도록 &quot;분할 된&quot;배열은 규칙적인 오프셋에 배치 된 요소와 함께 메모리에 저장됩니다 . 스트라이드 된 배열은 각 차원에 대해 &quot;스트라이드&quot;의 튜플을 반환 하는 &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt; &lt;code&gt;strides(A)&lt;/code&gt; &lt;/a&gt; 메서드를 정의해야 합니다. 제공된 &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; 메소드는 이 튜플 내의 &lt;code&gt;k&lt;/code&gt; 번째 요소에 액세스합니다 . 차원의 인덱스 증가 &lt;code&gt;k&lt;/code&gt; 하여 &lt;code&gt;1&lt;/code&gt; 은 인덱스를 증가시켜야 &lt;code&gt;i&lt;/code&gt; 들 &lt;code&gt;getindex(A,i)&lt;/code&gt; 에서 &lt;a href=&quot;../../base/arrays/index#Base.stride&quot;&gt; &lt;code&gt;stride(A,k)&lt;/code&gt; &lt;/a&gt; . 포인터 변환 방법 &lt;a href=&quot;../../base/c/index#Base.unsafe_convert&quot;&gt; &lt;code&gt;Base.unsafe_convert(Ptr{T}, A)&lt;/code&gt; &lt;/a&gt;메모리 레이아웃은 이러한 보폭과 동일한 방식으로 일치해야합니다. &lt;code&gt;DenseArray&lt;/code&gt; 는 요소가 연속적으로 배열되는 스트라이드 배열의 매우 구체적인 예이므로 하위 유형에 적절한 &lt;code&gt;strides&lt;/code&gt; 정의를 제공합니다 . 더 구체적인 예제는 &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided arrays 인터페이스 안내서&lt;/a&gt; 에서 찾을 수 있습니다 . &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt; 는 스트라이드 배열로 간주되는 많은 내장 배열 유형의 편리한 별칭으로 포인터와 보폭 만 사용하여 고도로 조정되고 최적화 된 BLAS 및 LAPACK 함수를 호출하는 특수한 구현을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a6d45076b09098eb9df88807c997bb15e85369" translate="yes" xml:space="preserve">
          <source>A (all)</source>
          <target state="translated">A (모두)</target>
        </trans-unit>
        <trans-unit id="9e0270f067c0a720b45c4eb9f114b3b4f763ba05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LibGit2.GitCommit&quot;&gt;&lt;code&gt;GitCommit&lt;/code&gt;&lt;/a&gt; will be peeled to a &lt;a href=&quot;#LibGit2.GitTree&quot;&gt;&lt;code&gt;GitTree&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitCommit&quot;&gt; &lt;code&gt;GitCommit&lt;/code&gt; 는&lt;/a&gt; A를 벗겨됩니다 &lt;a href=&quot;#LibGit2.GitTree&quot;&gt; &lt;code&gt;GitTree&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba75f83e672a51cdb25eeef228f835e8a4e0af8a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; operator represents a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. The identity operator &lt;code&gt;I&lt;/code&gt; is defined as a constant and is an instance of &lt;code&gt;UniformScaling&lt;/code&gt;. The size of these operators are generic and match the other matrix in the binary operations &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt;. For &lt;code&gt;A+I&lt;/code&gt; and &lt;code&gt;A-I&lt;/code&gt; this means that &lt;code&gt;A&lt;/code&gt; must be square. Multiplication with the identity operator &lt;code&gt;I&lt;/code&gt; is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; 의&lt;/a&gt; 연산자는 스칼라 배 정체성 연산자 나타내는 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . ID 연산자 &lt;code&gt;I&lt;/code&gt; 는 상수로 정의되며 &lt;code&gt;UniformScaling&lt;/code&gt; 의 인스턴스입니다 . 이 연산자의 크기는 일반적이며 이진 연산 &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 의 다른 행렬과 일치합니다 . 들어 &lt;code&gt;A+I&lt;/code&gt; 와 &lt;code&gt;A-I&lt;/code&gt; 이 의미하는 &lt;code&gt;A&lt;/code&gt; 는 사각형이어야합니다. 아이덴티티 연산자 &lt;code&gt;I&lt;/code&gt; 과의 곱셈 은 스눕 (스케일링 팩터가 1인지 확인하는 것을 제외)이므로 오버 헤드가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c842dce0eb13d715db2132316b0c05a4d0e9a5e4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; that sets the value of &lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; (default: &lt;code&gt;60.0&lt;/code&gt;). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.</source>
          <target state="translated">&lt;code&gt;Distributed.worker_timeout()&lt;/code&gt; 값을 설정 하는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 입니다 (기본값 : &lt;code&gt;60.0&lt;/code&gt; ). 이 기능은 작업자 프로세스가 종료되기 전에 마스터 프로세스가 연결을 설정하기를 기다리는 시간 (초)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f904b64ee325fb09a13719884cf4994b4a67dc0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is in an open state initially. This means that it can be read from and written to freely via &lt;code&gt;take!&lt;/code&gt; and &lt;code&gt;put!&lt;/code&gt; calls. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; closes a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. On a closed &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;put!&lt;/code&gt; will fail. For example:</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 처음 열린 상태입니다. 즉, &lt;code&gt;take!&lt;/code&gt; 를 통해 자유롭게 읽고 쓸 수 있습니다! 그리고 &lt;code&gt;put!&lt;/code&gt; 전화. &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;닫 습니다 . 닫힌 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;put!&lt;/code&gt; 실패합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8375d9780c1ae8c1682f81b0f7a6ce2515b39852" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is local to a process. Worker 2 cannot directly refer to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; on worker 3 and vice-versa. A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, however, can put and take values across workers.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 과정에 지역이다. 작업자 2는 작업자 3 의 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 을 직접 참조 할 수 없으며 그 반대도 마찬가지입니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 는&lt;/a&gt; 그러나 넣고 근로자에 걸쳐 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8c6fb411b59b42a835d08f8b3cc960e82887e0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can be thought of as a &lt;em&gt;handle&lt;/em&gt; to a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 는&lt;/a&gt; A와 생각 될 수 &lt;em&gt;핸들&lt;/em&gt; A와 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17cfa5600f21f142fc6aae797119fcc13529b73c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; iterator of length &lt;code&gt;n&lt;/code&gt; whose elements exponentially increase at a rate in the interval &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt;). The first element is &lt;code&gt;first_delay&lt;/code&gt; and all elements are clamped to &lt;code&gt;max_delay&lt;/code&gt;.</source>
          <target state="translated">간격 &lt;code&gt;factor&lt;/code&gt; * (1 &amp;plusmn; &lt;code&gt;jitter&lt;/code&gt; ) 의 비율로 요소가 지수 적으로 증가하는 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 반복자입니다 . 첫 번째 요소는 &lt;code&gt;first_delay&lt;/code&gt; 이고 모든 요소는 &lt;code&gt;max_delay&lt;/code&gt; 로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c79d61fbf339539f4166e2a7bfbe466aba53081" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, which must be written as a literal constant,</source>
          <target state="translated">&lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; 리터럴 상수로 기록되어야 쌍,</target>
        </trans-unit>
        <trans-unit id="524fcaed9fa041013c206a6350ca0d844bfa68a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(name, library)&lt;/code&gt; function specification must be a constant expression. However, it is possible to use computed values as function names by staging through &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;(name, library)&lt;/code&gt; 기능 사양은 상수 표현식이어야합니다. 그러나 다음과 같이 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 통해 스테이징하여 계산 된 값을 함수 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15e6f0f33d377d6237a8e9e56d281edb772d043" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character on either end of a column's header separator (the row containing &lt;code&gt;-&lt;/code&gt; characters) specifies whether the row is left-aligned, right-aligned, or (when &lt;code&gt;:&lt;/code&gt; appears on both ends) center-aligned. Providing no &lt;code&gt;:&lt;/code&gt; characters will default to right-aligning the column.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 열의 헤더 분리기의 양쪽 끝에있는 문자 (포함 된 행 &lt;code&gt;-&lt;/code&gt; 자) 행이 우측 정렬 또는 좌측 정렬되어 있는지 여부를 지정 (시 &lt;code&gt;:&lt;/code&gt; 양단에 나타나는) 가운데 맞춤. no &lt;code&gt;:&lt;/code&gt; 문자를 제공 하면 기본적으로 열이 오른쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="d46ad2498166339bc8bbf3585924bc43d1e8d5c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufferStream&lt;/code&gt; is an in-memory &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; which behaves like an &lt;code&gt;IO&lt;/code&gt;&amp;ndash;it is a stream which can be handled asynchronously.</source>
          <target state="translated">&lt;code&gt;BufferStream&lt;/code&gt; 는 메모리 내이다 &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 처럼 동작 &lt;code&gt;IO&lt;/code&gt; - 그것은 비동기 적으로 처리 될 수있는 스트림이다.</target>
        </trans-unit>
        <trans-unit id="d1f408408afbccca18234c62817be522377e93f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CartesianIndex&lt;/code&gt; is sometimes produced by &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt;, and always when iterating with an explicit &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CartesianIndex&lt;/code&gt; 는 때때로에 의해 생성된다 &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; , 항상 명시 적으로 반복 할 때 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d375921fbca2bf53253dd9c9c9cb98fe33f687c8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Channel&lt;/code&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop runs as long as the &lt;code&gt;Channel&lt;/code&gt; has data or is open. The loop variable takes on all values added to the &lt;code&gt;Channel&lt;/code&gt;. The &lt;code&gt;for&lt;/code&gt; loop is terminated once the &lt;code&gt;Channel&lt;/code&gt; is closed and emptied.</source>
          <target state="translated">&lt;code&gt;Channel&lt;/code&gt; A의 반복 가능 객체로 사용될 수 &lt;code&gt;for&lt;/code&gt; 루프만큼으로 실행되는 경우에 루프 &lt;code&gt;Channel&lt;/code&gt; 데이터를 갖거나 열려있다. 루프 변수는 &lt;code&gt;Channel&lt;/code&gt; 추가 된 모든 값을받습니다 . &lt;code&gt;for&lt;/code&gt; 한 번 루프는 종료 &lt;code&gt;Channel&lt;/code&gt; 폐쇄 비워집니다.</target>
        </trans-unit>
        <trans-unit id="1464a151c99f208872dfcf6ce120c5e13267f23e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Char&lt;/code&gt; value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code point&lt;/a&gt;. (Julia packages may define other subtypes of &lt;code&gt;AbstractChar&lt;/code&gt;, e.g. to optimize operations for other &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;text encodings&lt;/a&gt;.) Here is how &lt;code&gt;Char&lt;/code&gt; values are input and shown:</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 이 특수 문자 표시와 해당 연산 동작과 단지 32 비트의 프리미티브 타입이고, 이는이 표현하는 숫자 값으로 변환 될 수있다 : 값은 단일의 문자를 나타내는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; . (Julia 패키지는 다른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;텍스트 인코딩에&lt;/a&gt; 대한 작업을 최적화하기 위해 &lt;code&gt;AbstractChar&lt;/code&gt; 의 다른 하위 유형을 정의 할 수 있습니다 .) 다음은 &lt;code&gt;Char&lt;/code&gt; 값이 입력되고 표시되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="29831ac830f246eb0b5dcfbe779b29bb30cb2979" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CompoundPeriod&lt;/code&gt; is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, &quot;a year and a day&quot; is not a fixed number of days, but can be expressed using a &lt;code&gt;CompoundPeriod&lt;/code&gt;. In fact, a &lt;code&gt;CompoundPeriod&lt;/code&gt; is automatically generated by addition of different period types, e.g. &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; produces a &lt;code&gt;CompoundPeriod&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;CompoundPeriod&lt;/code&gt; 이 작은 기간의 고정 된 다중하지 않은 기간을 표현하는 데 유용하다. 예를 들어, &quot;일과 일&quot;은 고정 된 일수가 아니라 &lt;code&gt;CompoundPeriod&lt;/code&gt; 를 사용하여 표현할 수 있습니다 . 실제로 &lt;code&gt;CompoundPeriod&lt;/code&gt; 는 다른 기간 유형을 추가하여 자동으로 생성됩니다. 예를 들어 &lt;code&gt;Year(1) + Day(1)&lt;/code&gt; 는 &lt;code&gt;CompoundPeriod&lt;/code&gt; 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="013639aa4c9e00f4e19703e4c05f20b5824ce3b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DataType&lt;/code&gt; may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a &lt;code&gt;DataType&lt;/code&gt; with nonzero size, but no field names. A composite type is a &lt;code&gt;DataType&lt;/code&gt; that has field names or is empty (zero size).</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 추상적 또는 구체적으로 할 수있다. 콘크리트 인 경우 지정된 크기, 스토리지 레이아웃 및 (선택적) 필드 이름이 있습니다. 따라서 기본 유형은 크기가 0이지만 필드 이름이없는 &lt;code&gt;DataType&lt;/code&gt; 입니다. 복합 유형은 필드 이름이 있거나 비어있는 (0 크기) &lt;code&gt;DataType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0a8047ce7922366b0e1686ff32c1d95d34209f7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitCommit&lt;/code&gt; will be peeled to a &lt;code&gt;GitTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitCommit&lt;/code&gt; 는 A를 벗겨됩니다 &lt;code&gt;GitTree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d18c2ea92257c3ec465776fe14e9a5ed1ec94622" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitRevWalker&lt;/code&gt;&lt;em&gt;walks&lt;/em&gt; through the &lt;em&gt;revisions&lt;/em&gt; (i.e. commits) of a git repository &lt;code&gt;repo&lt;/code&gt;. It is a collection of the commits in the repository, and supports iteration and calls to &lt;a href=&quot;#LibGit2.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LibGit2.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; (for instance, &lt;code&gt;count&lt;/code&gt; could be used to determine what percentage of commits in a repository were made by a certain author).</source>
          <target state="translated">&lt;code&gt;GitRevWalker&lt;/code&gt; 는&lt;em&gt;산책&lt;/em&gt; 관통 &lt;em&gt;개정&lt;/em&gt; 자식 저장소 (즉, 커밋) &lt;code&gt;repo&lt;/code&gt; . 리포지토리의 커밋 모음이며 반복 및 &lt;a href=&quot;#LibGit2.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LibGit2.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 호출을 지원합니다 (예를 들어, &lt;code&gt;count&lt;/code&gt; 는 리포지토리의 커밋 비율을 특정 작성자가 결정한 비율을 결정하는 데 사용될 수 있음).</target>
        </trans-unit>
        <trans-unit id="7218806e6e918d7a7efe224d0bbd25603b822749" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitTag&lt;/code&gt; will be peeled to the object it references.</source>
          <target state="translated">&lt;code&gt;GitTag&lt;/code&gt; 가 참조하는 객체에 벗겨됩니다.</target>
        </trans-unit>
        <trans-unit id="56db16f375b3ec2b4282d7f16a671aeb187ec450" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MIME&lt;/code&gt; object can be passed as the second argument to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; to request output in that format.</source>
          <target state="translated">&lt;code&gt;MIME&lt;/code&gt; 의 목적은 두 번째 인수로서 전달 될 수있는 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; 하는 포맷 요청 출력한다.</target>
        </trans-unit>
        <trans-unit id="64ab14f4b27b0ebae05bdd35cfc7b0f0829b66e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MersenneTwister&lt;/code&gt; or &lt;code&gt;RandomDevice&lt;/code&gt; RNG can generate uniformly random numbers of the following types: &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt;&lt;code&gt;UInt128&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; (or complex numbers of those types). Random floating point numbers are generated uniformly in $[0, 1)$. As &lt;code&gt;BigInt&lt;/code&gt; represents unbounded integers, the interval must be specified (e.g. &lt;code&gt;rand(big.(1:6))&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; 또는 &lt;code&gt;RandomDevice&lt;/code&gt; : RNG는 다음과 같은 종류의 균일 한 난수를 발생시킬 수 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt128&quot;&gt; &lt;code&gt;UInt128&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; (또는 복소수 그 유형의). 임의의 부동 소수점 숫자는 $ [0, 1) $에 균일하게 생성됩니다. 로 &lt;code&gt;BigInt&lt;/code&gt; 제한없는 정수를 나타내려면 간격을 지정해야합니다 (예 : &lt;code&gt;rand(big.(1:6))&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fcc156039502be223f5f3af68d44a563690ef471" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Module&lt;/code&gt; is a separate global variable workspace. See &lt;a href=&quot;#module&quot;&gt;&lt;code&gt;module&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;manual section about modules&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 별도의 전역 변수 작업 공간입니다. 자세한 내용은 &lt;a href=&quot;#module&quot;&gt; &lt;code&gt;module&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;모듈에&lt;/a&gt; 대한 매뉴얼 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fe27036120fb22dce22db3d877ea4b7e275e7b94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NamedTuple&lt;/code&gt; type can be used as a constructor, accepting a single tuple argument. The constructed &lt;code&gt;NamedTuple&lt;/code&gt; type can be either a concrete type, with both parameters specified, or a type that specifies only field names:</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; 의 유형은 하나의 튜플 인수를 받아들이는 생성자로 사용할 수 있습니다. 생성 된 &lt;code&gt;NamedTuple&lt;/code&gt; 유형은 두 매개 변수가 모두 지정된 구체적 유형이거나 필드 이름 만 지정하는 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea99f7079d8791c0343a7307d5e653f1f644267c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Polar&lt;/code&gt; object will then display automatically using HTML in an environment that supports HTML display, but you can call &lt;code&gt;show&lt;/code&gt; manually to get HTML output if you want:</source>
          <target state="translated">&lt;code&gt;Polar&lt;/code&gt; 객체는 지원의 HTML 표시하는 환경에서 HTML을 사용하여 자동으로 표시됩니다,하지만 당신은 호출 할 수 있습니다 &lt;code&gt;show&lt;/code&gt; 원하는 경우 GET HTML 출력에 수동 :</target>
        </trans-unit>
        <trans-unit id="c3372e99dcae94f7a8aba1e912fc8ad984983e16" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;VersionNumber&lt;/code&gt; object describing which version of Julia is in use. For details see &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;Version Number Literals&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VersionNumber&lt;/code&gt; 줄리아의 버전을 나타내는 개체가 사용된다. 자세한 내용은 &lt;a href=&quot;../../manual/strings/index#man-version-number-literals-1&quot;&gt;버전 번호 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac1b0b9643100f5709d747b0fa1193640db35af9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do&lt;/code&gt; block, like any other inner function, can &quot;capture&quot; variables from its enclosing scope. For example, the variable &lt;code&gt;data&lt;/code&gt; in the above example of &lt;code&gt;open...do&lt;/code&gt; is captured from the outer scope. Captured variables can create performance challenges as discussed in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">A는 &lt;code&gt;do&lt;/code&gt; 포위 범위에서 수 &quot;캡처&quot;변수 다른 내부 기능처럼, 블록. 예를 들어, 위의 &lt;code&gt;open...do&lt;/code&gt; 예제의 변수 &lt;code&gt;data&lt;/code&gt; 는 외부 범위에서 캡처됩니다. 캡처 된 변수는 &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 에서 설명한대로 성능 문제를 일으킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13afa4d8f5eaeee48f3a15d19e444c7dc58d320a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop or comprehension iteration variable is always a new variable:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 또는 이해의 반복 변수는 항상 새로운 변수입니다 :</target>
        </trans-unit>
        <trans-unit id="1cc87568b64210c7c32ecbee8a0599fd750c9777" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;group&lt;/code&gt; for the event, which is set to the base name of the file by default, without extension. This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group &lt;code&gt;:depwarn&lt;/code&gt;), or into logical groupings across or within modules.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 확장하지 않고, 기본적으로 파일의 기본 이름으로 설정되는 이벤트에 대한. 이는 메시지를 로그 레벨보다 세밀하게 범주 (예 : 모든 폐기 경고에 group &lt;code&gt;:depwarn&lt;/code&gt; 이 있음 ) 또는 모듈 전체 또는 모듈 내에서 논리적 그룹으로 그룹화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="236e91049303fa66d220cd5b5421a9050d83f949" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement allows intercepting errors (exceptions) thrown by &lt;a href=&quot;#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; so that program execution can continue. For example, the following code attempts to write a file, but warns the user and proceeds instead of terminating execution if the file cannot be written:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 문에 의해 발생 오류 (예외) 차단 할 수 있습니다 &lt;a href=&quot;#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; 그 프로그램의 실행을 계속할 수 있도록합니다. 예를 들어 다음 코드는 파일을 쓰려고 시도하지만 파일을 쓸 수없는 경우 실행을 종료하는 대신 사용자에게 경고하고 진행합니다.</target>
        </trans-unit>
        <trans-unit id="6f7e3d0cb44d68c0e786c74714c652c1e6239ca4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package&lt;/em&gt; is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt; statements. These statements also make the module named &lt;code&gt;X&lt;/code&gt;&amp;mdash;which results from loading the package code&amp;mdash;available within the module where the import statement occurs. The meaning of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; is context-dependent: which &lt;code&gt;X&lt;/code&gt; package is loaded depends on what code the statement occurs in. Thus, handling of &lt;code&gt;import X&lt;/code&gt; happens in two stages: first, it determines &lt;strong&gt;what&lt;/strong&gt; package is defined to be &lt;code&gt;X&lt;/code&gt; in this context; second, it determines &lt;strong&gt;where&lt;/strong&gt; that particular &lt;code&gt;X&lt;/code&gt; package is found.</source>
          <target state="translated">&lt;em&gt;패키지는&lt;/em&gt; 다른 줄리아 프로젝트에 재사용 할 수있는 표준 레이아웃을 제공하는 기능을 가진 소스 트리입니다. 패키지는 &lt;code&gt;import X&lt;/code&gt; 또는 &lt;code&gt;using X&lt;/code&gt; 문을 사용하여 로드됩니다 . 이 명령문은 또한 패키지 이름 을로드 한 결과 &lt;code&gt;X&lt;/code&gt; 라는 모듈을 import 문이 발생하는 모듈 내에서 사용할 수있게합니다. &lt;code&gt;import X&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 에서 X 의 의미 는 상황에 따라 다릅니다. 어떤 &lt;code&gt;X&lt;/code&gt; 패키지가로드되는지는 명령문이 어떤 코드에 따라 달라집니다. 따라서 &lt;code&gt;import X&lt;/code&gt; 처리는 두 단계로 이루어집니다. 먼저, &lt;code&gt;X&lt;/code&gt; 로 정의 된 패키지를 결정 &lt;strong&gt;합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;이 맥락에서; 둘째, 특정 &lt;code&gt;X&lt;/code&gt; 패키지가 &lt;strong&gt;있는 위치&lt;/strong&gt; 를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="0ea5ce3cb4556ddc297c6aeebda772ae9221423a" translate="yes" xml:space="preserve">
          <source>A C function declared to return &lt;code&gt;Cvoid&lt;/code&gt; will return the value &lt;code&gt;nothing&lt;/code&gt; in Julia.</source>
          <target state="translated">&lt;code&gt;Cvoid&lt;/code&gt; 를 반환하도록 선언 된 AC 함수는 Julia에서 &lt;code&gt;nothing&lt;/code&gt; 값 도 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="def83ea9fa11b0a4be5ef6b08c5ce4257e5755ca" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native character type &lt;a href=&quot;#Base.Cchar&quot;&gt;&lt;code&gt;Cchar&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native wide character type, see &lt;a href=&quot;#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">기본 문자 유형 &lt;a href=&quot;#Base.Cchar&quot;&gt; &lt;code&gt;Cchar&lt;/code&gt; &lt;/a&gt; 로 구성된 C 스타일 문자열 입니다. &lt;code&gt;Cstring&lt;/code&gt; 은 NUL로 종료됩니다. 기본 와이드 문자 유형으로 구성된 C 스타일 문자열은 &lt;a href=&quot;#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . C와의 문자열 상호 운용성에 대한 자세한 내용은 &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac0a9fe2ade0eb6e9c2e2cc4b61f726d6a965d9c" translate="yes" xml:space="preserve">
          <source>A C-style string composed of the native wide character type &lt;a href=&quot;#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;Cwstring&lt;/code&gt;s are NUL-terminated. For C-style strings composed of the native character type, see &lt;a href=&quot;#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt;. For more information about string interopability with C, see the &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">기본 와이드 문자 유형 &lt;a href=&quot;#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; 로 구성된 C 스타일 문자열 입니다. &lt;code&gt;Cwstring&lt;/code&gt; 은 NUL로 종료됩니다. 기본 문자 유형으로 구성된 C 스타일 문자열은 &lt;a href=&quot;#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . C와의 문자열 상호 운용성에 대한 자세한 내용은 &lt;a href=&quot;../../manual/calling-c-and-fortran-code/index#man-bits-types-1&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="023376b34dc0e6e575fb072d80744bfc1276423d" translate="yes" xml:space="preserve">
          <source>A Givens rotation linear operator. The fields &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; represent the cosine and sine of the rotation angle, respectively. The &lt;code&gt;Givens&lt;/code&gt; type supports left multiplication &lt;code&gt;G*A&lt;/code&gt; and conjugated transpose right multiplication &lt;code&gt;A*G'&lt;/code&gt;. The type doesn't have a &lt;code&gt;size&lt;/code&gt; and can therefore be multiplied with matrices of arbitrary size as long as &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; for &lt;code&gt;G*A&lt;/code&gt; or &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; for &lt;code&gt;A*G'&lt;/code&gt;.</source>
          <target state="translated">A 회전 선형 연산자를 제공합니다. 필드 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;s&lt;/code&gt; 는 각각 회전 각도의 코사인과 사인을 나타냅니다. &lt;code&gt;Givens&lt;/code&gt; 형 지지체 승산 왼쪽 &lt;code&gt;G*A&lt;/code&gt; 과 승산 공액 전치 오른쪽 &lt;code&gt;A*G'&lt;/code&gt; . 형식은없는 &lt;code&gt;size&lt;/code&gt; 때문에 긴만큼 임의의 크기의 행렬과 곱해질 수 &lt;code&gt;i2&amp;lt;=size(A,2)&lt;/code&gt; 에 대한 &lt;code&gt;G*A&lt;/code&gt; 또는 &lt;code&gt;i2&amp;lt;=size(A,1)&lt;/code&gt; 에 대한 &lt;code&gt;A*G'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f95cfdddef2f3b16bd0eaacf8c5ec7871a86e5" translate="yes" xml:space="preserve">
          <source>A Julia Function</source>
          <target state="translated">줄리아 함수</target>
        </trans-unit>
        <trans-unit id="338b907694ffa95225d1463f09b5454501424162" translate="yes" xml:space="preserve">
          <source>A Julia cluster has the following characteristics:</source>
          <target state="translated">Julia 클러스터에는 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbb147573dcd49250e15c543ce261c2ed456757" translate="yes" xml:space="preserve">
          <source>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</source>
          <target state="translated">Julia 스크립트는 여러 함수를 포함 할 수 있으며 파일이로드 될 때 모든 정의를 외부에서 볼 수 있습니다. 기능 정의는 현재 작업 디렉토리 외부의 파일에서로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec5c0a21b198e35d9011cfccf1720c04200ccca0" translate="yes" xml:space="preserve">
          <source>A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The &lt;code&gt;payload_ptr&lt;/code&gt; is required to contain a &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; object which will keep track of state and settings.</source>
          <target state="translated">연결 프로토콜을 통해 다른 자격 증명 획득 기능을 제공하는 LibGit2 자격 증명 콜백 기능. &lt;code&gt;payload_ptr&lt;/code&gt; 는 포함 할 필요가 &lt;code&gt;LibGit2.CredentialPayload&lt;/code&gt; 의 상태 및 설정을 추적 할 개체를.</target>
        </trans-unit>
        <trans-unit id="01a933ad46a5f5ec0c3c3e174d75cd08e0a9bf13" translate="yes" xml:space="preserve">
          <source>A LibGit2 representation of an array of strings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt;&lt;code&gt;git_strarray&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">문자열 배열의 LibGit2 표현입니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_strarray&quot;&gt; &lt;code&gt;git_strarray&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6b4f3bedfc4889701c09c75dc083d1c8d58006" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a compact blocked format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">컴팩트 블록 형식으로 저장된 QR 매트릭스 인수 분해는 일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻습니다 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="a2bfddaee8ff7a44aec0ab4b2b1e184a0f187d2e" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization stored in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">팩 형식으로 저장된 QR 매트릭스 인수 분해는 일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻습니다 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="c9925c571d2e1e694cc1d660f2d03ec4cf1ec057" translate="yes" xml:space="preserve">
          <source>A QR matrix factorization with column pivoting in a packed format, typically obtained from &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;. If $A$ is an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix, then</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#LinearAlgebra.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 에서 얻은 압축 형식의 열 피벗을 사용한 QR 행렬 인수 분해 . $ A $가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 행렬이면</target>
        </trans-unit>
        <trans-unit id="028b2fd647f67d6a5b3b18c1e2a4be06ea973f76" translate="yes" xml:space="preserve">
          <source>A basic editor/REPL workflow</source>
          <target state="translated">기본 편집기 / REPL 워크 플로우</target>
        </trans-unit>
        <trans-unit id="3e270c005ba798894763e8eb54b974bf29e5d476" translate="yes" xml:space="preserve">
          <source>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by &lt;a href=&quot;#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OS 파일 디스크립터를 랩핑하는 버퍼 된 IO 스트림. 대부분 &lt;a href=&quot;#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; 에서&lt;/a&gt; 반환 한 파일을 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6761a9dad52906730c7e2d2e824c87ab1ba9a0c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt;, which may then be passed into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; for translation:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 호출하면 &lt;code&gt;Union{Ptr{Nothing}, Base.InterpreterIP}&lt;/code&gt; 의 벡터가 반환되며 , 번역을 위해 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 추적 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783595edaa0cd8106f88e2687e628c9ad8922d54" translate="yes" xml:space="preserve">
          <source>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3, 4)&lt;/code&gt; custom matrix type with cartesian indexing, we could reference &lt;code&gt;A[2, 1, 3]&lt;/code&gt; and Julia would automatically convert this into the correct location in the underlying memory. See also &lt;a href=&quot;#Base.IndexLinear&quot;&gt;&lt;code&gt;IndexLinear&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데카르트 인덱싱 스타일은 배열에서 위치를 설명하기 위해 여러 정수 / 인디 케이트를 사용합니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 직교 인덱스 를 사용하는 &lt;code&gt;(2, 3, 4)&lt;/code&gt; 커스텀 행렬 유형 인 경우 &lt;code&gt;A[2, 1, 3]&lt;/code&gt; 참조 할 수 있으며 Julia는이를 기본 메모리의 올바른 위치로 자동 변환합니다. &lt;a href=&quot;#Base.IndexLinear&quot;&gt; &lt;code&gt;IndexLinear&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b670cf7ce6aa053516969f59beb26f75521a626" translate="yes" xml:space="preserve">
          <source>A channel can be visualized as a pipe, i.e., it has a write end and a read end :</source>
          <target state="translated">채널은 파이프로 시각화 할 수 있습니다. 즉, 쓰기 끝과 읽기 끝이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda0bd3645d716870c693b3b59018dd4924caf33" translate="yes" xml:space="preserve">
          <source>A classic example is the standard C library &lt;code&gt;qsort&lt;/code&gt; function, declared as:</source>
          <target state="translated">전형적인 예는 다음 과 같이 선언 된 표준 C 라이브러리 &lt;code&gt;qsort&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e90162b2f2534c5d2ad98ffd6060c363829dd8a7" translate="yes" xml:space="preserve">
          <source>A cluster spanning machines using the &lt;code&gt;--machine-file&lt;/code&gt; option. This uses a passwordless &lt;code&gt;ssh&lt;/code&gt; login to start Julia worker processes (from the same path as the current host) on the specified machines.</source>
          <target state="translated">&lt;code&gt;--machine-file&lt;/code&gt; 옵션을 사용하는 클러스터 스패닝 머신 . 비밀번호없는 &lt;code&gt;ssh&lt;/code&gt; 로그인을 사용 하여 지정된 시스템에서 Julia 작업자 프로세스 (현재 호스트와 동일한 경로에서)를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7d02127d252ebd3948a9767c4487385c4243c197" translate="yes" xml:space="preserve">
          <source>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than &lt;code&gt;/etc/passwd&lt;/code&gt;, we wanted to sort the contents of the file &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt;. Let's try it:</source>
          <target state="translated">쉘을 통해 외부 프로그램을 실행할 때의 일반적인 함정은 파일 이름에 쉘에 특수 문자가 포함되어 있으면 원하지 않는 동작이 발생할 수 있다는 것입니다. 예를 들어 &lt;code&gt;/etc/passwd&lt;/code&gt; 가 아니라 &lt;code&gt;/Volumes/External HD/data.csv&lt;/code&gt; 파일의 내용을 정렬하려고 한다고 가정 합니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="6454f39a38aef4a6a88d7b516cb03974038d7792" translate="yes" xml:space="preserve">
          <source>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the &lt;a href=&quot;../../base/base/index#const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">변수의 일반적인 사용은 변경되지 않은 특정 값에 이름을 지정하는 것입니다. 이러한 변수는 한 번만 할당됩니다. 이 의도는 &lt;a href=&quot;../../base/base/index#const&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 컴파일러에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3cb20f10d68d34ff29611ac3f50ba68dd4c4b99" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all documentable Julia syntax.</source>
          <target state="translated">모든 문서화 가능한 Julia 구문에 대한 포괄적 인 개요.</target>
        </trans-unit>
        <trans-unit id="0d6d37f3dca8ed9b04613226e4330c5ab758e3f1" translate="yes" xml:space="preserve">
          <source>A concrete implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt; (like &lt;code&gt;Channel&lt;/code&gt;), is required to implement &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. The remote object referred to by a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is stored in a &lt;code&gt;Channel{Any}(1)&lt;/code&gt;, i.e., a &lt;code&gt;Channel&lt;/code&gt; of size 1 capable of holding objects of &lt;code&gt;Any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; 을 구현 하려면 &lt;code&gt;AbstractChannel&lt;/code&gt; ( &lt;code&gt;Channel&lt;/code&gt; 과 같은 )을 구체적으로 구현 해야합니다 . , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; 및 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 참조하는 원격 객체 는 &lt;code&gt;Channel{Any}(1)&lt;/code&gt; , 즉 &lt;code&gt;Any&lt;/code&gt; 유형의 객체를 보유 할 수있는 크기 1 의 &lt;code&gt;Channel&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6d94519717188d6531df826c6d7c056c25b4e04" translate="yes" xml:space="preserve">
          <source>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let's say you want to add a constructor method for &lt;code&gt;Foo&lt;/code&gt; objects that takes only one argument and uses the given value for both the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields. This is simple:</source>
          <target state="translated">생성자는 전체 동작이 메소드의 결합 된 동작에 의해 정의된다는 점에서 Julia의 다른 함수와 같습니다. 따라서 단순히 새로운 메소드를 정의하여 생성자에 기능을 추가 할 수 있습니다. 예를 들어, 하나의 인수 만 사용하고 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 필드 모두에 대해 주어진 값을 사용하는 &lt;code&gt;Foo&lt;/code&gt; 오브젝트에 대한 생성자 메소드를 추가하려고한다고 가정하십시오 . 이것은 간단하다 :</target>
        </trans-unit>
        <trans-unit id="da756968deae2626766b76b59d785afc3e81b3a6" translate="yes" xml:space="preserve">
          <source>A convenience macro for writing &lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt;&lt;code&gt;MIME&lt;/code&gt;&lt;/a&gt; types, typically used when adding methods to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;. For example the syntax &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; could be used to define how to write an HTML representation of &lt;code&gt;MyType&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Multimedia.MIME&quot;&gt; &lt;code&gt;MIME&lt;/code&gt; &lt;/a&gt; 유형 을 작성하기위한 편리한 매크로로 , 일반적으로 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt; 할 메소드를 추가 할 때 사용됩니다 . 예를 들어 구문 &lt;code&gt;show(io::IO, ::MIME&quot;text/html&quot;, x::MyType) = ...&lt;/code&gt; 을 사용하여 &lt;code&gt;MyType&lt;/code&gt; 의 HTML 표현을 작성하는 방법을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce500fee8f2cf895c4ff2e81b81207ab74479894" translate="yes" xml:space="preserve">
          <source>A correct way to define a method that accepts all arguments of type &lt;code&gt;Point{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;Point{T}&lt;/code&gt; 유형의 모든 인수를 허용하는 메소드를 정의하는 올바른 방법 : 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3fdea15c071a796482bb0cbad61dbe066b8e91d1" translate="yes" xml:space="preserve">
          <source>A curated list of useful learning resources to help new users get started can be found on the &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;learning&lt;/a&gt; page of the main Julia web site.</source>
          <target state="translated">새로운 사용자를 시작하는 데 도움이되는 유용한 학습 자료의 목록은 기본 Julia 웹 사이트 의 &lt;a href=&quot;https://julialang.org/learning/&quot;&gt;학습&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f02f82182ef74a9efe3bec210a9632727895f0a5" translate="yes" xml:space="preserve">
          <source>A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. &lt;code&gt;&quot;Note&quot;&lt;/code&gt; in the case of the &lt;code&gt;note&lt;/code&gt; admonition.</source>
          <target state="translated">상자에 대한 사용자 정의 제목은 훈계 유형 뒤에 문자열 (큰 따옴표)로 제공 될 수 있습니다. 훈계 유형 뒤에 제목 텍스트가 지정되지 않은 경우, 사용 된 제목은 블록의 유형이됩니다 (예 를 들어, 훈계 &lt;code&gt;note&lt;/code&gt; 의 경우 &lt;code&gt;&quot;Note&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ad883b8ebd4cb13361ac5dca2bf64c895374f2" translate="yes" xml:space="preserve">
          <source>A data buffer for exporting data from libgit2. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt;&lt;code&gt;git_buf&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">libgit2에서 데이터를 내보내기위한 데이터 버퍼 &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_buf&quot;&gt; &lt;code&gt;git_buf&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="043f580a8a8cc9a9005c9d9892ccd32895f20dc0" translate="yes" xml:space="preserve">
          <source>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</source>
          <target state="translated">더 이상 사용되지 않는 함수는 내부적으로 관련 경고를 한 번만 인쇄하기 위해 조회를 수행합니다. 이 추가 조회는 상당한 속도 저하를 일으킬 수 있으므로 사용되지 않는 기능의 모든 사용은 경고에서 제안한대로 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8caa8da69c3b3cb75cd1d014abbbf0696fbf4493" translate="yes" xml:space="preserve">
          <source>A directory path that indicates which project should be the initial active project. Setting this environment variable has the same effect as specifying the &lt;code&gt;--project&lt;/code&gt; start-up option, but &lt;code&gt;--project&lt;/code&gt; has higher precedence. If the variable is set to &lt;code&gt;@.&lt;/code&gt; then Julia tries to find a project directory that contains &lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt; file from the current directory and its parents. See also the chapter on &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;.</source>
          <target state="translated">초기 활성 프로젝트 여야하는 프로젝트를 나타내는 디렉토리 경로. 이 환경 변수를 설정하면 &lt;code&gt;--project&lt;/code&gt; 시작 옵션 을 지정하는 것과 동일한 효과 가 있지만 &lt;code&gt;--project&lt;/code&gt; 가 우선 순위가 높습니다. 변수가 &lt;code&gt;@.&lt;/code&gt; 로 설정된 경우 그런 다음 Julia는 현재 디렉토리와 상위 디렉토리에서 &lt;code&gt;Project.toml&lt;/code&gt; 또는 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 파일 이 포함 된 프로젝트 디렉토리를 찾으려고 합니다. &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;코드 로딩&lt;/a&gt; 에 관한 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="214eedeee1125bd3c3f68e94a3d499c9e468ec4a" translate="yes" xml:space="preserve">
          <source>A distributed memory, parallel for loop of the form :</source>
          <target state="translated">다음과 같은 형식의 루프 용 병렬 분산 메모리 :</target>
        </trans-unit>
        <trans-unit id="19754b4c8d91fdeebb8f2031c8dcc27614b27813" translate="yes" xml:space="preserve">
          <source>A document can be split up into different sections using headers. Headers use the following syntax:</source>
          <target state="translated">헤더를 사용하여 문서를 다른 섹션으로 나눌 수 있습니다. 헤더는 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="906831c5f1833fe1c6cead11729270eaa1e64820" translate="yes" xml:space="preserve">
          <source>A fast, unfair-scheduling version of &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; which immediately yields to &lt;code&gt;t&lt;/code&gt; before calling the scheduler.</source>
          <target state="translated">스케줄의 빠른 불공정 스케줄 버전 &lt;code&gt;schedule(t, arg); yield()&lt;/code&gt; 스케줄러를 호출하기 전에 즉시 &lt;code&gt;t&lt;/code&gt; 를 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="5b34dfa04ee74a34a9d1a9cbb45d550b2f88b889" translate="yes" xml:space="preserve">
          <source>A few general rules to note:</source>
          <target state="translated">참고할 몇 가지 일반적인 규칙 :</target>
        </trans-unit>
        <trans-unit id="af07889865f77b7c4b96703878fe873de95ec344" translate="yes" xml:space="preserve">
          <source>A few other points to be aware of:</source>
          <target state="translated">알아야 할 몇 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="60a8d349acf8be941cbc934da15ee121f8a78126" translate="yes" xml:space="preserve">
          <source>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia's singleton types, but with that caveat that only type objects have singleton types.</source>
          <target state="translated">하스켈, 스칼라, 루비를 포함한 몇몇 인기있는 언어는 싱글 톤 타입을 가지고 있습니다. 일반적으로 &quot;단일 유형&quot;이라는 용어는 인스턴스가 단일 값인 유형을 나타냅니다. 이 의미는 Julia의 싱글 톤 유형에 적용되지만 유형 객체에만 싱글 톤 유형이 있다는주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00922cb6654b9fb1b8cc559d5766ed07010c9573" translate="yes" xml:space="preserve">
          <source>A few special expressions correspond to calls to functions with non-obvious names. These are:</source>
          <target state="translated">명확하지 않은 이름을 가진 함수에 대한 호출에 해당하는 몇 가지 특수 표현식이 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="df6e90fee529846cc6c25c991e16a7b9cfb908be" translate="yes" xml:space="preserve">
          <source>A file can also be preloaded on multiple processes at startup with the &lt;code&gt;-L&lt;/code&gt; flag, and a driver script can be used to drive the computation:</source>
          <target state="translated">시작시 &lt;code&gt;-L&lt;/code&gt; 플래그를 사용하여 여러 프로세스에 파일을 사전로드 할 수 있으며 드라이버 스크립트를 사용하여 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef6fc12def87705c0724012674763d06330988e" translate="yes" xml:space="preserve">
          <source>A full list of tab-completions can be found in the &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;Unicode Input&lt;/a&gt; section of the manual.</source>
          <target state="translated">탭 완성의 전체 목록은 설명서 의 &lt;a href=&quot;../../manual/unicode-input/index#Unicode-Input-1&quot;&gt;유니 코드 입력&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="776e65341479516956a84c86603101c98f11aaf1" translate="yes" xml:space="preserve">
          <source>A full suite of parsing and formatting tests and examples is available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문 분석 및 형식화 테스트 및 예제의 전체 세트는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/io.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/io.jl&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d1efd2d920b71c04b3aea5f88fea207dff694c1" translate="yes" xml:space="preserve">
          <source>A function &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; to request the richest available multimedia display of a Julia object &lt;code&gt;x&lt;/code&gt; (with a plain-text fallback).</source>
          <target state="translated">Julia 객체 &lt;code&gt;x&lt;/code&gt; 의 가장 풍부한 멀티미디어 디스플레이를 요청 하는 함수 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; (일반 텍스트 폴백 포함).</target>
        </trans-unit>
        <trans-unit id="96f1b83c87e5168541a9af06566b09eb353921f1" translate="yes" xml:space="preserve">
          <source>A function is called using the traditional parenthesis syntax:</source>
          <target state="translated">전통적인 괄호 구문을 사용하여 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d505a0f9d0a8bc085cb6ea8549229cd44ccf9a" translate="yes" xml:space="preserve">
          <source>A function name may be used alone in place of the tuple (just &lt;code&gt;:function&lt;/code&gt; or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</source>
          <target state="translated">함수 이름은 튜플 대신 단독으로 사용될 수 있습니다 (단지 &lt;code&gt;:function&lt;/code&gt; 또는 &lt;code&gt;&quot;function&quot;&lt;/code&gt; ). 이 경우 이름은 현재 프로세스 내에서 확인됩니다. 이 양식은 C 라이브러리 함수, Julia 런타임의 함수 또는 Julia에 링크 된 애플리케이션의 함수를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d50016e8809b20104597755ad0d300cddc21a6" translate="yes" xml:space="preserve">
          <source>A function signature:</source>
          <target state="translated">함수 서명 :</target>
        </trans-unit>
        <trans-unit id="fe743a5fafb686fdaff2fd3950e5909b38ec521c" translate="yes" xml:space="preserve">
          <source>A function with a declared return type converts its return value to that type.</source>
          <target state="translated">반환 유형이 선언 된 함수는 반환 값을 해당 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="25a045a60155304dcdc010c60b6dbf032ba437c0" translate="yes" xml:space="preserve">
          <source>A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a &lt;code&gt;GitObject&lt;/code&gt; in a repository.</source>
          <target state="translated">sha-1 해시에 기반한 자식 객체 식별자. 리포지토리에서 &lt;code&gt;GitObject&lt;/code&gt; 를 식별하는 데 사용되는 20 바이트 문자열 (40 개의 16 진수) 입니다.</target>
        </trans-unit>
        <trans-unit id="2b9dac9baaf8e5d26caf82470268456378e7b354" translate="yes" xml:space="preserve">
          <source>A given &lt;code&gt;AbstractChar&lt;/code&gt; subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported &lt;code&gt;UInt32&lt;/code&gt; value may throw an error. Conversely, the built-in &lt;a href=&quot;#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; type represents a &lt;em&gt;superset&lt;/em&gt; of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value &lt;em&gt;to&lt;/em&gt;&lt;code&gt;UInt32&lt;/code&gt; throws an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid&lt;/code&gt;&lt;/a&gt; function can be used to check which codepoints are representable in a given &lt;code&gt;AbstractChar&lt;/code&gt; type.</source>
          <target state="translated">지정된 &lt;code&gt;AbstractChar&lt;/code&gt; 하위 유형은 유니 코드의 하위 집합 만 나타낼 수 있으며,이 경우 지원되지 않는 &lt;code&gt;UInt32&lt;/code&gt; 값 에서 변환 하면 오류가 발생할 수 있습니다. 반대로 내장 &lt;a href=&quot;#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; 유형은 유니 코드 의 &lt;em&gt;수퍼 세트&lt;/em&gt; (유효하지 않은 바이트 스트림을 손실없이 인코딩하기 위해)를 나타내며,이 경우 비 유니 코드 값 &lt;em&gt;을 &lt;/em&gt; &lt;code&gt;UInt32&lt;/code&gt; 로 변환 하면 오류가 발생합니다. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid&lt;/code&gt; &lt;/a&gt; 함수는 주어진에서 표현할 수있는 코드 포인트를 확인하는 데 사용될 수 &lt;code&gt;AbstractChar&lt;/code&gt; 의 유형.</target>
        </trans-unit>
        <trans-unit id="04d95958adcacd4e7b4382e807134e41ec53c3fc" translate="yes" xml:space="preserve">
          <source>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</source>
          <target state="translated">전역 변수는 값을 가질 수 있으므로 유형은 언제든지 변경 될 수 있습니다. 이로 인해 컴파일러가 전역 변수를 사용하여 코드를 최적화하기가 어렵습니다. 변수는 로컬이거나 가능할 때마다 함수의 인수로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e11090dc004521cb3583f54e041c822a584bd2f5" translate="yes" xml:space="preserve">
          <source>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn't have to worry about callbacks or even making sure that the server gets to run. When we called &lt;code&gt;connect&lt;/code&gt; the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</source>
          <target state="translated">Julia의 가장 큰 장점은 I / O가 실제로 비동기 적으로 발생하더라도 API가 동 기적으로 노출되므로 콜백에 대해 걱정하거나 서버가 실행되도록 보장 할 필요가 없다는 것입니다. 우리가 &lt;code&gt;connect&lt;/code&gt; 를 호출 하면 현재 작업은 연결이 설정되기를 기다렸다가 그 후에 만 ​​실행을 계속했습니다. 이 일시 정지에서, 서버 태스크는 실행을 재개하고 (연결 요청이 사용 가능하므로) 연결을 승인하고 메시지를 인쇄 한 후 다음 클라이언트를 기다렸습니다. 읽기와 쓰기는 같은 방식으로 작동합니다. 이것을 보려면 다음의 간단한 에코 서버를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0a9e1db1edf203efc9535001b0c4d60d58c32400" translate="yes" xml:space="preserve">
          <source>A header line can contain any inline syntax in the same way as a paragraph can.</source>
          <target state="translated">헤더 행은 단락과 동일한 방식으로 인라인 구문을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5bee9cb41ed39aedfa6d81eeafb7305d47a4fcb" translate="yes" xml:space="preserve">
          <source>A key part in defining an &lt;code&gt;AbstractArray&lt;/code&gt; subtype is &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt;. Since indexing is such an important part of an array and often occurs in hot loops, it's important to make both indexing and indexed assignment as efficient as possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension. These two modalities are identified by Julia as &lt;code&gt;IndexLinear()&lt;/code&gt; and &lt;code&gt;IndexCartesian()&lt;/code&gt;. Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 하위 유형 을 정의하는 데있어 핵심적인 부분 은 &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; 입니다. 인덱싱은 배열의 중요한 부분이며 종종 핫 루프에서 발생하기 때문에 인덱싱 및 인덱싱 된 할당을 최대한 효율적으로 만드는 것이 중요합니다. 배열 데이터 구조는 일반적으로 두 가지 방법 중 하나로 정의됩니다. 하나의 인덱스를 사용하여 해당 요소에 가장 효율적으로 액세스하거나 (선형 인덱싱) 모든 차원에 지정된 인덱스를 사용하여 본질적으로 요소에 액세스합니다. 이 두 가지 양식은 Julia에 의해 &lt;code&gt;IndexLinear()&lt;/code&gt; 및 &lt;code&gt;IndexCartesian()&lt;/code&gt; 으로 식별됩니다 . 선형 인덱스를 여러 인덱스 첨자로 변환하는 것은 일반적으로 비용이 많이 들기 때문에 모든 배열 유형에 대해 효율적인 일반 코드를 가능하게하는 특성 기반 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a023b19be8aa0bdde697959a3cb353c50c4a7e6" translate="yes" xml:space="preserve">
          <source>A linear index into the array &lt;code&gt;A&lt;/code&gt; can be converted to a &lt;code&gt;CartesianIndex&lt;/code&gt; for cartesian indexing with &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;), and a set of &lt;code&gt;N&lt;/code&gt; cartesian indices can be converted to a linear index with &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; (see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">배열로 선형 인덱스 &lt;code&gt;A&lt;/code&gt; A를 변환 할 수 &lt;code&gt;CartesianIndex&lt;/code&gt; 과 직교 인덱싱 &lt;code&gt;CartesianIndices(A)[i]&lt;/code&gt; (참고 &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; 을&lt;/a&gt; ), 및 일련의 &lt;code&gt;N&lt;/code&gt; 직교 지수를 갖는 선형 인덱스로 변환 할 수 &lt;code&gt;LinearIndices(A)[i_1, i_2, ..., i_N]&lt;/code&gt; ( &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fba3600321961b41d61a445772a6a0bbc42feb66" translate="yes" xml:space="preserve">
          <source>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if &lt;code&gt;A&lt;/code&gt; were a &lt;code&gt;(2, 3)&lt;/code&gt; custom matrix type with linear indexing, and we referenced &lt;code&gt;A[5]&lt;/code&gt; (using linear style), this would be equivalent to referencing &lt;code&gt;A[1, 3]&lt;/code&gt; (since &lt;code&gt;2*1 + 3 = 5&lt;/code&gt;). See also &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선형 인덱싱 스타일은 배열의 위치를 ​​설명하기 위해 하나의 정수를 사용하며 (다차원 배열 인 경우에도) 열 주요 순서는 요소에 액세스하는 데 사용됩니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 선형 인덱싱 을 사용하는 &lt;code&gt;(2, 3)&lt;/code&gt; 사용자 정의 행렬 유형이고 &lt;code&gt;A[5]&lt;/code&gt; (선형 스타일 사용)를 참조한 경우 &lt;code&gt;A[1, 3]&lt;/code&gt; 을 참조 하는 것과 같습니다 ( &lt;code&gt;2*1 + 3 = 5&lt;/code&gt; 이후 + 3 = 5 ). &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60b78a78e322605d51a66eddac408816c2a8d70e" translate="yes" xml:space="preserve">
          <source>A literal tuple of input types</source>
          <target state="translated">입력 유형의 리터럴 튜플</target>
        </trans-unit>
        <trans-unit id="abd07e8344438c1637a18b8d088b307bacd1facc" translate="yes" xml:space="preserve">
          <source>A little further down, you see:</source>
          <target state="translated">조금 더 아래로 보면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b734fc221d82e75922a1b3bf7185abae1cf63084" translate="yes" xml:space="preserve">
          <source>A local cluster specified with the &lt;code&gt;-p&lt;/code&gt; option as shown above.</source>
          <target state="translated">위에 표시된대로 &lt;code&gt;-p&lt;/code&gt; 옵션으로 지정된 로컬 클러스터</target>
        </trans-unit>
        <trans-unit id="b83cf191c90b25b0d5f433557856a4746d3a9017" translate="yes" xml:space="preserve">
          <source>A logger controls how log records are filtered and dispatched. When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.</source>
          <target state="translated">로거는 로그 레코드가 필터링 및 발송되는 방법을 제어합니다. 로그 레코드가 생성되면 로거는 사용자가 구성 할 수있는 첫 번째 코드로 레코드를 검사하고 레코드와 함께 수행 할 작업을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="042546047eaee48205b79c0943331492c9d777d2" translate="yes" xml:space="preserve">
          <source>A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</source>
          <target state="translated">Julia의 많은 기능과 확장 성은 비공식 인터페이스 모음에서 비롯됩니다. 사용자 지정 형식에 사용할 수있는 몇 가지 특정 방법을 확장하면 해당 형식의 개체가 해당 기능을 수신 할뿐만 아니라 이러한 동작을 일반적으로 구축하기 위해 작성된 다른 방법에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdda590f5cebd6037d45dcdc70b7f61af7141059" translate="yes" xml:space="preserve">
          <source>A low-level API which returns the backing &lt;code&gt;AbstractChannel&lt;/code&gt; for an &lt;code&gt;id&lt;/code&gt; returned by &lt;a href=&quot;#Distributed.remoteref_id&quot;&gt;&lt;code&gt;remoteref_id&lt;/code&gt;&lt;/a&gt;. The call is valid only on the node where the backing channel exists.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.remoteref_id&quot;&gt; &lt;code&gt;remoteref_id&lt;/code&gt; 가&lt;/a&gt; 반환 한 &lt;code&gt;id&lt;/code&gt; 대한 지원 &lt;code&gt;AbstractChannel&lt;/code&gt; 을 반환하는 저수준 API입니다 . 호출은 지원 채널이 존재하는 노드에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="43d1ae4e08959da49eefb761652820ef46f3ee1d" translate="yes" xml:space="preserve">
          <source>A low-level API which, given a &lt;code&gt;IO&lt;/code&gt; connection or a &lt;code&gt;Worker&lt;/code&gt;, returns the &lt;code&gt;pid&lt;/code&gt; of the worker it is connected to. This is useful when writing custom &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt;&lt;code&gt;serialize&lt;/code&gt;&lt;/a&gt; methods for a type, which optimizes the data written out depending on the receiving process id.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 연결 또는 &lt;code&gt;Worker&lt;/code&gt; 가 제공된 하위 수준 API 는 연결된 작업자 의 &lt;code&gt;pid&lt;/code&gt; 를 반환합니다 . 이는 수신 프로세스 ID에 따라 기록 된 데이터를 최적화하는 유형에 대한 사용자 정의 &lt;a href=&quot;../serialization/index#Serialization.serialize&quot;&gt; &lt;code&gt;serialize&lt;/code&gt; &lt;/a&gt; 메소드를 작성할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="ba795db29049d0891e980ecd11cc60ac3e97da8e" translate="yes" xml:space="preserve">
          <source>A machine specification is either a string &lt;code&gt;machine_spec&lt;/code&gt; or a tuple - &lt;code&gt;(machine_spec, count)&lt;/code&gt;.</source>
          <target state="translated">기계 스펙은 문자열 &lt;code&gt;machine_spec&lt;/code&gt; 또는 tuple- &lt;code&gt;(machine_spec, count)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd1f8848b8ea19b616dae75f53fa9e5a2b6e59a0" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</source>
          <target state="translated">표현식을 평가하는 매크로로 결과 값을 버리고 대신 부동 소수점 숫자로 실행하는 데 걸리는 시간 (초)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb3b3a4181a161e900f67d35ae07d34f42540d5c" translate="yes" xml:space="preserve">
          <source>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the &lt;code&gt;@time&lt;/code&gt; macros, which do not try to adjust for the effects of compilation.</source>
          <target state="translated">식을 평가하고 결과 값을 버리는 대신 식을 평가하는 동안 할당 된 총 바이트 수를 반환하는 매크로입니다. 참고 : 표현식은 컴파일의 영향을 제거하기 위해 현재 컨텍스트 대신 로컬 함수 내에서 평가되지만 JIT 컴파일으로 인해 일부 할당이 여전히있을 수 있습니다. 또한 결과가 &lt;code&gt;@time&lt;/code&gt; 매크로 와 일치 하지 않으므로 컴파일 효과를 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8419a19f9c35dcf69afb6a224b11b1158512f81" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</source>
          <target state="translated">식을 실행하고 식의 값, 경과 시간, 할당 된 총 바이트 수, 가비지 수집 시간 및 다양한 메모리 할당 카운터가있는 개체를 반환하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="ec81ff86af0859e961659a65c9fded1ce9fa3695" translate="yes" xml:space="preserve">
          <source>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.</source>
          <target state="translated">식의 값을 반환하기 전에 식을 실행하는 매크로, 실행 시간, 할당 수 및 실행이 할당 된 총 바이트 수를 인쇄하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="f89e0c8d5e0780de8c8e7183eaddeb751b876c48" translate="yes" xml:space="preserve">
          <source>A macro to parallelize a for-loop to run with multiple threads. This spawns &lt;code&gt;nthreads()&lt;/code&gt; number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</source>
          <target state="translated">여러 스레드로 실행하기 위해 for 루프를 병렬화하는 매크로입니다. 이것은 &lt;code&gt;nthreads()&lt;/code&gt; 수의 스레드를 생성 하고 반복 공간을 분할하고 병렬로 반복합니다. 모든 스레드의 실행이 완료 될 때까지 대기하는 루프의 끝에 장벽이 배치되고 루프가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4056e98728a50b1503d6d58ab30b4f400279b462" translate="yes" xml:space="preserve">
          <source>A memory address referring to data of type &lt;code&gt;T&lt;/code&gt;. However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 데이터를 참조하는 메모리 주소 입니다. 그러나 메모리가 실제로 유효한지 또는 실제로 지정된 유형의 데이터를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="95d230cf10af62aec1cf82bb28af648076032cf6" translate="yes" xml:space="preserve">
          <source>A message &lt;code&gt;id&lt;/code&gt; that is a unique, fixed identifier for the &lt;em&gt;source code statement&lt;/em&gt; where the logging macro appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long as the logging statement itself remains the same.</source>
          <target state="translated">로깅 매크로가 나타나는 &lt;em&gt;소스 코드 문의&lt;/em&gt; 고유 한 고정 식별자 인 메시지 &lt;code&gt;id&lt;/code&gt; 입니다 . 이 식별자는 로깅 명령문 자체가 동일하게 유지되는 한 파일의 소스 코드가 변경 되더라도 상당히 안정적으로 설계되었습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2750f8d62ad398e67307a20fbfa3a8d50bdd8b0e" translate="yes" xml:space="preserve">
          <source>A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.</source>
          <target state="translated">지정된 형식 함수에 필수 형식 서명이있는 메소드가 없습니다. 또는 가장 고유 한 고유 한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb18ac1bbb6e9e8d32b3f5b781aaa128caf3d148" translate="yes" xml:space="preserve">
          <source>A more portable file would need to encode the word size &amp;ndash; 32 bit or 64 bit &amp;ndash; and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).</source>
          <target state="translated">보다 이식성있는 파일은 32 비트 또는 64 비트라는 단어 크기와 엔디안 정보를 헤더에 인코딩해야합니다. 실제로 HDF5 (메모리 매핑과 함께 사용할 수있는)와 같은 표준 형식을 사용하여 이진 데이터를 인코딩하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d12bebeb20e9c7a91d427b124d0d24b749dfc69d" translate="yes" xml:space="preserve">
          <source>A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a &lt;code&gt;Union&lt;/code&gt; of the types in question, but then this set would not be extensible as &lt;code&gt;Union&lt;/code&gt;-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;Holy-trait&quot;&lt;/a&gt;.</source>
          <target state="translated">위의 반복 디스패치에 대한 자연스러운 확장은 유형 계층에 의해 정의 된 세트와 독립적 인 유형 세트를 디스패치 할 수있는 메소드 선택에 계층을 추가하는 것입니다. 우리 는 해당 유형 의 &lt;code&gt;Union&lt;/code&gt; 을 작성하여 이러한 세트를 구성 할 수 있지만 생성 후에 &lt;code&gt;Union&lt;/code&gt; 유형을 변경할 수 없으므로이 세트를 확장 할 수 없습니다. 그러나 이러한 확장 가능한 세트는 종종 &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633&quot;&gt;&quot;신성한 특성&quot;&lt;/a&gt; 이라고하는 디자인 패턴으로 프로그래밍 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1df2e0e7411bff84daf33858b6c998ccc3af6df2" translate="yes" xml:space="preserve">
          <source>A negative value returned from &lt;code&gt;f&lt;/code&gt; stops the tree walk. A positive value means that the entry will be skipped if &lt;code&gt;post&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에서 음수 값을 반환 하면 트리 보행이 중지됩니다. 양수 값은 &lt;code&gt;post&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 항목을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="6eadc295d0ba924158738dd40574dc88fa55d3a0" translate="yes" xml:space="preserve">
          <source>A new local scope is introduced by most code blocks (see above &lt;a href=&quot;#man-scope-table-1&quot;&gt;table&lt;/a&gt; for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</source>
          <target state="translated">새로운 로컬 범위는 대부분의 코드 블록에 의해 도입되었습니다 ( 전체 목록 은 위의 &lt;a href=&quot;#man-scope-table-1&quot;&gt;표&lt;/a&gt; 참조 ). 로컬 범위는 읽기 및 쓰기를 위해 부모 로컬 범위의 모든 변수를 상속합니다. 전역 범위와 달리 로컬 범위는 네임 스페이스가 아니므로 일종의 정규화 된 액세스를 통해 내부 범위의 변수를 상위 범위에서 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d714251afe7092bca2f3b7a144d31cf965234924" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="2193a2ca1ad4d9733b4b0300e7ecba88f3943810" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="81968f8bb93ba2bc693aa91379d45e0967799536" translate="yes" xml:space="preserve">
          <source>A not-a-number value of type &lt;a href=&quot;#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 유형의 숫자가 아닌 값입니다 .</target>
        </trans-unit>
        <trans-unit id="bf0553a64a83d6adf63b024a57032beb1f6f23e7" translate="yes" xml:space="preserve">
          <source>A one-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1 차원 &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="763a944bd46fad5722e83f3b2781f484dab35fa0" translate="yes" xml:space="preserve">
          <source>A package can only be loaded once per Julia session. If you have run &lt;code&gt;import Example&lt;/code&gt; in the current Julia session, you will have to restart Julia and rerun &lt;code&gt;activate tutorial&lt;/code&gt; in the Pkg REPL. &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.</source>
          <target state="translated">Julia 세션 당 패키지는 한 번만로드 할 수 있습니다. 현재 Julia 세션에서 &lt;code&gt;import Example&lt;/code&gt; 을 실행 한 경우 Pkg REPL에서 Julia를 다시 시작하고 &lt;code&gt;activate tutorial&lt;/code&gt; 을 다시 실행해야합니다 . &lt;a href=&quot;https://github.com/timholy/Revise.jl/&quot;&gt;Revise.jl&lt;/a&gt; 로이 프로세스를 훨씬 더 즐겁게 만들 수 있지만 설정은이 안내서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="d8ea4ea99a9ccce09db2edcbcf21139124c0c674" translate="yes" xml:space="preserve">
          <source>A package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.</source>
          <target state="translated">프로젝트 파일이 있지만 명시 적 UUID가없는 패키지는 프로젝트 파일이없는 패키지에만 의존 할 수 있습니다. 이러한 패키지에 할당 된 더미 UUID는 엄격하게 내부이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="74b114825488547a02a0f9d88544ac2cd2767c9b" translate="yes" xml:space="preserve">
          <source>A package with a project file cannot depend on one without a project file since packages with project files can only load packages in &lt;code&gt;graph&lt;/code&gt; and packages without project files do not appear in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">프로젝트 파일과 패키지 만의 패키지를로드 할 수 있기 때문에 프로젝트 파일과 패키지는 프로젝트 파일없이 하나에 의존 할 수 &lt;code&gt;graph&lt;/code&gt; 에 표시되지 않습니다 프로젝트 파일없이 패키지를 &lt;code&gt;graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd75d89f707123dd68c78d210bdb2e047dca58d2" translate="yes" xml:space="preserve">
          <source>A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.</source>
          <target state="translated">프로젝트 파일이없는 패키지는 모든 최상위 종속성에 의존 할 수 있으며 패키지 디렉토리의 모든 패키지는 최상위 레벨에서 사용 가능하므로 환경의 모든 패키지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56c2cd76cad76c5809c4c87d958f6925a4c437f" translate="yes" xml:space="preserve">
          <source>A paragraph is a block of plain text, possibly containing any number of inline elements defined in the &lt;a href=&quot;#Inline-elements-1&quot;&gt;Inline elements&lt;/a&gt; section above, with one or more blank lines above and below it.</source>
          <target state="translated">단락은 일반 텍스트 블록으로, 위 및 아래에 하나 이상의 빈 줄이있는 위 의 &lt;a href=&quot;#Inline-elements-1&quot;&gt;인라인 요소&lt;/a&gt; 섹션에 정의 된 여러 개의 인라인 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f9c9755a3a3b90210c6624d61e0b0a1f59e0fa" translate="yes" xml:space="preserve">
          <source>A particularly useful case of a &lt;code&gt;Union&lt;/code&gt; type is &lt;code&gt;Union{T, Nothing}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; can be any type and &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is the singleton type whose only instance is the object &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. This pattern is the Julia equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; types in other languages. Declaring a function argument or a field as &lt;code&gt;Union{T, Nothing}&lt;/code&gt; allows setting it either to a value of type &lt;code&gt;T&lt;/code&gt;, or to &lt;code&gt;nothing&lt;/code&gt; to indicate that there is no value. See &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;this FAQ entry&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 유형 의 특히 유용한 경우 는 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; . 여기서 &lt;code&gt;T&lt;/code&gt; 는 모든 유형일 수 있으며 &lt;a href=&quot;../../base/base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 은 인스턴스가 객체 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 단일 유형입니다 . 이 패턴은 다른 언어 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; 또는 &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; 유형 과 같은 Julia 입니다. 함수 인수 또는 필드 선언 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 타입의 값 중 하나를 설정할 수 있습니다 &lt;code&gt;T&lt;/code&gt; , 또는에 &lt;code&gt;nothing&lt;/code&gt; 값이 없음을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../faq/index#faq-nothing-1&quot;&gt;이 FAQ 항목&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f8b8ac2cfde0d10f30bb94c874c9e1f1def48e" translate="yes" xml:space="preserve">
          <source>A pointer to the data block</source>
          <target state="translated">데이터 블록에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="6b9ee627484ba20558d37b2c66115f6d170670ea" translate="yes" xml:space="preserve">
          <source>A positive &lt;code&gt;Int&lt;/code&gt; that determines how much time the max-sum subroutine &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default &lt;code&gt;1&lt;/code&gt;, and larger values correspond to larger amounts of time.</source>
          <target state="translated">패키지 종속성 해결 프로그램 의 max-sum 서브 루틴 &lt;code&gt;MaxSum.maxsum()&lt;/code&gt; 이 포기하기 전에 만족스러운 제한 조건을 시도하는 데 얼마나 많은 시간이 걸리는지 를 결정하는 양의 &lt;code&gt;Int&lt;/code&gt; :이 값은 기본적으로 &lt;code&gt;1&lt;/code&gt; 이며 더 큰 값은 더 많은 시간에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="30e83519d088c9c533da7a48902b81020f8078b5" translate="yes" xml:space="preserve">
          <source>A pre-computed &lt;code&gt;mean&lt;/code&gt; may be provided.</source>
          <target state="translated">미리 계산 된 &lt;code&gt;mean&lt;/code&gt; 이 제공 될 수있다.</target>
        </trans-unit>
        <trans-unit id="e2cb212a617bce583ce37ac7b92063a39d21aed2" translate="yes" xml:space="preserve">
          <source>A prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is used on an argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</source>
          <target state="translated">접두사 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 의 인수에 사용되어 스칼라 값 대신 스칼라 인수에 대한 포인터가 전달되어야 함을 나타냅니다 (위에서 언급 한대로 모든 포트란 함수 인수에 필요함). 다음 예제는 BLAS 함수를 사용하여 내적을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1649f26efb9cb12037079805dd99e4da0fb754f9" translate="yes" xml:space="preserve">
          <source>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</source>
          <target state="translated">프리미티브 유형은 데이터가 평범한 오래된 비트로 구성된 콘크리트 유형입니다. 기본 유형의 고전적인 예는 정수 및 부동 소수점 값입니다. 대부분의 언어와 달리 Julia를 사용하면 고정 된 내장 유형 만 제공하는 대신 고유 한 기본 유형을 선언 할 수 있습니다. 실제로 표준 프리미티브 유형은 모두 언어 자체로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a9df194804c22a7662de8018248499081325a7" translate="yes" xml:space="preserve">
          <source>A project environment is determined by a directory containing a project file called &lt;code&gt;Project.toml&lt;/code&gt;, and optionally a manifest file called &lt;code&gt;Manifest.toml&lt;/code&gt;. These files may also be called &lt;code&gt;JuliaProject.toml&lt;/code&gt; and &lt;code&gt;JuliaManifest.toml&lt;/code&gt;, in which case &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are ignored. This allows for coexistence with other tools that might consider files called &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; significant. For pure Julia projects, however, the names &lt;code&gt;Project.toml&lt;/code&gt; and &lt;code&gt;Manifest.toml&lt;/code&gt; are preferred.</source>
          <target state="translated">프로젝트 환경은 &lt;code&gt;Project.toml&lt;/code&gt; 이라는 프로젝트 파일 과 &lt;code&gt;Manifest.toml&lt;/code&gt; 이라는 매니페스트 파일이 포함 된 디렉토리에 의해 결정됩니다 . 이러한 파일은 &lt;code&gt;JuliaProject.toml&lt;/code&gt; 및 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; 이라고도 하며,이 경우 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 은 무시됩니다. 따라서 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 이라는 파일을 중요하게 고려할 수있는 다른 도구와 공존 할 수 있습니다 . 그러나 순수 Julia 프로젝트의 경우 &lt;code&gt;Project.toml&lt;/code&gt; 및 &lt;code&gt;Manifest.toml&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="69645bb907ec77da55ad793cb959dcc26c6879c9" translate="yes" xml:space="preserve">
          <source>A pure function can only depend on immutable information. This also means a &lt;code&gt;@pure&lt;/code&gt; function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect &lt;code&gt;@pure&lt;/code&gt; annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.</source>
          <target state="translated">순수한 기능은 불변 정보에만 의존 할 수 있습니다. 또한 &lt;code&gt;@pure&lt;/code&gt; 함수는 일반 함수를 포함하여 전역 변경 가능 상태를 사용할 수 없습니다. 일반 함수에 대한 호출은 변경 가능한 전역 상태 인 메소드 테이블에 따라 다릅니다. 주의해서 사용 하면 함수의 잘못된 &lt;code&gt;@pure&lt;/code&gt; 주석이 버그를 식별하기 어려울 수 있습니다. 일반 함수 호출을 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f0f859ed475e8984520389a632de12d979f1bf" translate="yes" xml:space="preserve">
          <source>A range &lt;code&gt;r&lt;/code&gt; where &lt;code&gt;r[i]&lt;/code&gt; produces values of type &lt;code&gt;T&lt;/code&gt; (in the second form, &lt;code&gt;T&lt;/code&gt; is deduced automatically), parameterized by a &lt;code&gt;ref&lt;/code&gt;erence value, a &lt;code&gt;step&lt;/code&gt;, and the &lt;code&gt;len&lt;/code&gt;gth. By default &lt;code&gt;ref&lt;/code&gt; is the starting value &lt;code&gt;r[1]&lt;/code&gt;, but alternatively you can supply it as the value of &lt;code&gt;r[offset]&lt;/code&gt; for some other index &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt;. In conjunction with &lt;code&gt;TwicePrecision&lt;/code&gt; this can be used to implement ranges that are free of roundoff error.</source>
          <target state="translated">범위 &lt;code&gt;r&lt;/code&gt; &lt;code&gt;r[i]&lt;/code&gt; 타입의 값 생성 &lt;code&gt;T&lt;/code&gt; 를 (두 번째 형태는, &lt;code&gt;T&lt;/code&gt; 는 a로 파라미터 자동으로 도출된다) &lt;code&gt;ref&lt;/code&gt; ERENCE 값, &lt;code&gt;step&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; GTH. 기본적으로 &lt;code&gt;ref&lt;/code&gt; 는 시작 값 &lt;code&gt;r[1]&lt;/code&gt; 이지만 다른 인덱스 &lt;code&gt;1 &amp;lt;= offset &amp;lt;= len&lt;/code&gt; 대해 &lt;code&gt;r[offset]&lt;/code&gt; 값으로 제공 할 수도 있습니다 . &lt;code&gt;TwicePrecision&lt;/code&gt; 과 함께 이것은 반올림 오류가없는 범위를 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b444cdaa1ec0c32645903217d293c523a2b655" translate="yes" xml:space="preserve">
          <source>A range parameterized by a &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, filled with elements spaced by &lt;code&gt;1&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; until &lt;code&gt;stop&lt;/code&gt; is exceeded. The syntax &lt;code&gt;a:b&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; both &lt;code&gt;Integer&lt;/code&gt;s creates a &lt;code&gt;UnitRange&lt;/code&gt;.</source>
          <target state="translated">a로 파라미터 범위 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 형 &lt;code&gt;T&lt;/code&gt; 요소 가득은만큼 이격 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;start&lt;/code&gt; 될 때까지 &lt;code&gt;stop&lt;/code&gt; 초과된다. 구문 &lt;code&gt;a:b&lt;/code&gt; 와 및 &lt;code&gt;b&lt;/code&gt; 모두 &lt;code&gt;Integer&lt;/code&gt; s는 생성 &lt;code&gt;UnitRange&lt;/code&gt; 를 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6f1f96e933c37623ad62bee872115dc2545ea76" translate="yes" xml:space="preserve">
          <source>A range with &lt;code&gt;len&lt;/code&gt; linearly spaced elements between its &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The size of the spacing is controlled by &lt;code&gt;len&lt;/code&gt;, which must be an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;stop&lt;/code&gt; 사이에 &lt;code&gt;len&lt;/code&gt; 이 간격을 둔 요소를 갖는 범위입니다 . 간격의 크기는 &lt;code&gt;len&lt;/code&gt; 에 의해 제어되며 , &lt;code&gt;Int&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="706e2d69e0228bb191f57826b2fe6dee1a0d2fd7" translate="yes" xml:space="preserve">
          <source>A related strategy exploits &lt;code&gt;promote&lt;/code&gt; to bring &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to a common type:</source>
          <target state="translated">이와 관련된 전략 악용 &lt;code&gt;promote&lt;/code&gt; 가지고에 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 일반적인 유형 :</target>
        </trans-unit>
        <trans-unit id="1aacdb7c22de01fd91d580f3ce3c32f6aebf1795" translate="yes" xml:space="preserve">
          <source>A remote call returns a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, and you can obtain the full value of the result using &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">원격 통화는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 결과로 반환합니다 . 원격 전화는 즉시 응답합니다. 원격 호출이 다른 곳에서 발생하는 동안 호출 한 프로세스는 다음 작업으로 진행됩니다. 반환 된 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 원격 호출이 완료 될 때까지 기다릴 수 있으며 &lt;code&gt;fetch&lt;/code&gt; 를 사용하여 결과의 ​​전체 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c718be7a47524e3c8c121a2838b8196bfca32d81" translate="yes" xml:space="preserve">
          <source>A return type can also be specified in the function declaration using the &lt;code&gt;::&lt;/code&gt; operator. This converts the return value to the specified type.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 연산자를 사용하여 함수 선언에 반환 유형을 지정할 수도 있습니다 . 리턴 값을 지정된 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="487eaf5a6ef062e68fb2638581518230a5bbf1cb" translate="yes" xml:space="preserve">
          <source>A return type of &lt;code&gt;Union{}&lt;/code&gt; means the function will not return i.e. C++11 &lt;code&gt;[[noreturn]]&lt;/code&gt; or C11 &lt;code&gt;_Noreturn&lt;/code&gt; (e.g. &lt;code&gt;jl_throw&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;). Do not use this for functions that return no value (&lt;code&gt;void&lt;/code&gt;) but do return, use &lt;code&gt;Cvoid&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; 의 리턴 유형은 함수가 C ++ 11 &lt;code&gt;[[noreturn]]&lt;/code&gt; 또는 C11 &lt;code&gt;_Noreturn&lt;/code&gt; (예 : &lt;code&gt;jl_throw&lt;/code&gt; 또는 &lt;code&gt;longjmp&lt;/code&gt; )을 리턴하지 않음을 의미합니다 . 값을 반환하지 않고 ( &lt;code&gt;void&lt;/code&gt; ) 반환하는 함수에는 이것을 사용하지 말고 대신 &lt;code&gt;Cvoid&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d36c3c7861e0bdac1682c4b5f59e170ca861f5e" translate="yes" xml:space="preserve">
          <source>A rich language of types for constructing and describing objects, that can also optionally be used to make type declarations</source>
          <target state="translated">선택적으로 타입 선언을하는 데 사용될 수있는 객체를 구성하고 설명하기위한 풍부한 유형의 언어</target>
        </trans-unit>
        <trans-unit id="72264caef899e2b19ef0b87abaee4b3d2fbc99bb" translate="yes" xml:space="preserve">
          <source>A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.</source>
          <target state="translated">역 추적이 간격으로 발생하기 때문에 샘플링 프로파일 러는 완전한 라인 단위 범위를 제공하지 않습니다 (실제 스케줄링은 운영 체제로드의 영향을 받더라도 기본적으로 1 밀리 초 시스템, Windows에서는 10 밀리 초). 더욱이, 아래에서 더 논의되는 바와 같이, 샘플은 모든 실행 포인트의 스파 스 서브 세트에서 수집되기 때문에, 샘플링 프로파일 러에 의해 수집 된 데이터는 통계적 노이즈의 영향을 받는다.</target>
        </trans-unit>
        <trans-unit id="1c43fdae247597897ddce375dd4bc720d67a5129" translate="yes" xml:space="preserve">
          <source>A scalar index. By default this includes:</source>
          <target state="translated">스칼라 인덱스 기본적으로 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b55191124d22706cdd504c425bc25474c70cfe4b" translate="yes" xml:space="preserve">
          <source>A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial &lt;code&gt;len&lt;/code&gt; hexadecimal digits of &lt;code&gt;hash&lt;/code&gt; (the remaining digits are ignored).</source>
          <target state="translated">이 초기 이루어진 고유 때 자식 객체를 식별하는 데 사용될 수있는 단축 자식 객체 식별자, &lt;code&gt;len&lt;/code&gt; 의 16 진수 &lt;code&gt;hash&lt;/code&gt; (나머지 숫자는 무시된다).</target>
        </trans-unit>
        <trans-unit id="077f5f2c61a2286cb303f8e0203873661f4fb602" translate="yes" xml:space="preserve">
          <source>A simple TCP example</source>
          <target state="translated">간단한 TCP 예제</target>
        </trans-unit>
        <trans-unit id="a9e3389d4f0df30d0d029c511221cff89bde7e83" translate="yes" xml:space="preserve">
          <source>A simple example is an iterable sequence of square numbers with a defined length:</source>
          <target state="translated">간단한 예는 정의 된 길이를 가진 반복 가능한 제곱 숫자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="4f74541df487be036520d1a453fae53d9f7cabea" translate="yes" xml:space="preserve">
          <source>A simple use of this script is from the command line. Assuming that &lt;code&gt;julia-config.jl&lt;/code&gt; is located in &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt;, it can be invoked on the command line directly and takes any combination of 3 flags:</source>
          <target state="translated">이 스크립트는 명령 줄에서 간단하게 사용합니다. &lt;code&gt;julia-config.jl&lt;/code&gt; 이 &lt;code&gt;/usr/local/julia/share/julia&lt;/code&gt; 에 있다고 가정하면 명령 행에서 직접 호출 할 수 있으며 3 개의 플래그를 조합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa70eb6573e06a90b5cea95755e1d5d87242bd36" translate="yes" xml:space="preserve">
          <source>A singleton of this type provides a hash table interface to environment variables.</source>
          <target state="translated">이 유형의 싱글 톤은 환경 변수에 대한 해시 테이블 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="742dc31813ae03b1c856e52c5abe6409c9fab8c0" translate="yes" xml:space="preserve">
          <source>A special syntax exists for broadcasting: &lt;code&gt;f.(args...)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, and nested &lt;code&gt;f.(g.(args...))&lt;/code&gt; calls are fused into a single broadcast loop.</source>
          <target state="translated">방송을위한 특별한 구문이 존재합니다 : &lt;code&gt;f.(args...)&lt;/code&gt; 는 &lt;code&gt;broadcast(f, args...)&lt;/code&gt; 와 동일하며 중첩 된 &lt;code&gt;f.(g.(args...))&lt;/code&gt; 호출은 단일 브로드 캐스트 루프에 통합됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0fbd3b8f6db43e593e0be31ea0f379f85f1e4ca" translate="yes" xml:space="preserve">
          <source>A stack of &quot;depot&quot; locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</source>
          <target state="translated">Julia의 코드 로딩 메커니즘뿐만 아니라 패키지 관리자도 패키지 레지스트리, 설치된 패키지, 명명 된 환경, 저장소 복제본, 캐시 된 컴파일 된 패키지 이미지 및 구성 파일을 찾는 &quot;저장소&quot;위치의 스택입니다. 기본적으로 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83cbeda4e6c8af61ba213e9c4a7b5e87e7da5098" translate="yes" xml:space="preserve">
          <source>A strided array is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt; whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps a standard &lt;code&gt;Array&lt;/code&gt; with additional structure.</source>
          <target state="translated">strided array는 엔트리가 고정 된 stride를 가진 메모리에 저장되는 &lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형입니다 . 배열의 요소 유형이 BLAS와 호환되는 경우 스 트레이드 배열은 BLAS 및 LAPACK 루틴을 사용하여보다 효율적인 선형 대수 루틴을 수행 할 수 있습니다. 사용자 정의 스트라이드 배열의 전형적인 예는 표준 &lt;code&gt;Array&lt;/code&gt; 을 추가 구조로 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b1c35701525a8cf6b4348121d4ed856a675b22b" translate="yes" xml:space="preserve">
          <source>A string containing the build triple.</source>
          <target state="translated">빌드 트리플을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8f5d09501ae972f4c8432e623c2b5b34015798e0" translate="yes" xml:space="preserve">
          <source>A string containing the full path to the directory containing the &lt;code&gt;julia&lt;/code&gt; executable.</source>
          <target state="translated">&lt;code&gt;julia&lt;/code&gt; 실행 파일이 포함 된 디렉토리의 전체 경로가 포함 된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="bfd4ca3ee2c70681a147013214927fa8b03d2dc0" translate="yes" xml:space="preserve">
          <source>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명령 행에서 Julia에게 전달 된 스크립트 이름이 포함 된 문자열. 스크립트 이름은 포함 된 파일 내에서 변경되지 않은 상태로 유지됩니다. 또는 &lt;a href=&quot;../file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0797e0a3c7343edc1c5ee87f67440aa1e7a16452" translate="yes" xml:space="preserve">
          <source>A string giving the literal bit representation of a number.</source>
          <target state="translated">숫자의 리터럴 비트 표현을 제공하는 문자열.</target>
        </trans-unit>
        <trans-unit id="99fade2fd2012046282e2903a7ae0c96b265f5e9" translate="yes" xml:space="preserve">
          <source>A struct can also declare an abstract super type via &lt;code&gt;&amp;lt;:&lt;/code&gt; syntax:</source>
          <target state="translated">구조체는 &lt;code&gt;&amp;lt;:&lt;/code&gt; 문법을 통해 추상 슈퍼 타입을 선언 할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d8c381a5b7c7400aeadc10868e02841473506c28" translate="yes" xml:space="preserve">
          <source>A successful invocation indicates that the request has been accepted for execution on the remote node.</source>
          <target state="translated">호출이 성공하면 요청이 원격 노드에서 실행되도록 승인되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="62cc4725cdcde932b6f43e77c33829a7243aa044" translate="yes" xml:space="preserve">
          <source>A symbol in the current scope is not defined.</source>
          <target state="translated">현재 범위의 기호가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c20565dfe8ced2501d963ee2eb2804c69c838706" translate="yes" xml:space="preserve">
          <source>A symbol representing the architecture of the build configuration.</source>
          <target state="translated">빌드 구성의 아키텍처를 나타내는 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1630c742579320a925646310ce24a54343db4200" translate="yes" xml:space="preserve">
          <source>A symbol representing the name of the operating system, as returned by &lt;code&gt;uname&lt;/code&gt; of the build configuration.</source>
          <target state="translated">빌드 구성이 &lt;code&gt;uname&lt;/code&gt; 않으면 서 리턴되는 운영 체제 이름을 나타내는 기호 입니다.</target>
        </trans-unit>
        <trans-unit id="55d0851ad9930d2d2a1ce1a82a1321a9316a97a9" translate="yes" xml:space="preserve">
          <source>A symbol representing the operator associativity can also be found by calling the built-in function &lt;code&gt;Base.operator_associativity&lt;/code&gt;:</source>
          <target state="translated">내장 함수 &lt;code&gt;Base.operator_associativity&lt;/code&gt; 를 호출하여 연산자 연관성을 나타내는 기호를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31ca630f0d77e0cda110e0b86407ebc755d3a20f" translate="yes" xml:space="preserve">
          <source>A system call failed with an error code (in the &lt;code&gt;errno&lt;/code&gt; global variable).</source>
          <target state="translated">오류 코드 ( &lt;code&gt;errno&lt;/code&gt; 전역 변수)로 시스템 호출에 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="9449233a2f73e499e6bb945337a8062b4696d604" translate="yes" xml:space="preserve">
          <source>A task created explicitly by calling &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is initially not known to the scheduler. This allows you to manage tasks manually using &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;, or using the &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; macro (see &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; for more details).</source>
          <target state="translated">태스크를 호출하여 명시 적으로 작성된 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 는 처음에 스케줄러에 알려지지 않았습니다. 원하는 경우 &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; 를&lt;/a&gt; 사용하여 수동으로 작업을 관리 할 수 ​​있습니다 . 그러나 이러한 작업이 이벤트를 기다리는 경우 이벤트가 발생할 때 예상대로 여전히 자동으로 다시 시작됩니다. 스케줄러가 이벤트를 기다리지 않고 가능할 때마다 태스크를 실행하도록 할 수도 있습니다. 이것은 &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 수행됩니다 ( 자세한 내용 은 &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;병렬 컴퓨팅&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="98741cc98ee16d9ab3a998adf5789df91d6bd8b6" translate="yes" xml:space="preserve">
          <source>A thread-safe version of &lt;a href=&quot;#Base.Condition&quot;&gt;&lt;code&gt;Base.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스레드 안전 버전의 &lt;a href=&quot;#Base.Condition&quot;&gt; &lt;code&gt;Base.Condition&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="742c13a103d2480e968af031241292dc13ffa910" translate="yes" xml:space="preserve">
          <source>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</source>
          <target state="translated">입력 유형의 튜플. 입력 유형은 튜플 값 변수 나 표현식이 아닌 리터럴 튜플로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="02ac3688690ac8c45320416c8e40058c167fb818" translate="yes" xml:space="preserve">
          <source>A two-dimensional &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt;&lt;code&gt;SharedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2 차원 &lt;a href=&quot;#SharedArrays.SharedArray&quot;&gt; &lt;code&gt;SharedArray&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2cae43ab9952736150051924872c889307cc7b33" translate="yes" xml:space="preserve">
          <source>A type assertion failure, or calling an intrinsic function with an incorrect argument type.</source>
          <target state="translated">형식 어설 션 실패 또는 잘못된 인수 형식의 고유 함수 호출</target>
        </trans-unit>
        <trans-unit id="6c65420499bd2ab6c38a5269a2949906fd25fe5c" translate="yes" xml:space="preserve">
          <source>A type representing a standard internet data format. &quot;MIME&quot; stands for &quot;Multipurpose Internet Mail Extensions&quot;, since the standard was originally used to describe multimedia attachments to email messages.</source>
          <target state="translated">표준 인터넷 데이터 형식을 나타내는 유형입니다. &quot;MIME&quot;은 &quot;Multipurpose Internet Mail Extensions&quot;의 약자입니다. 표준은 원래 전자 메일 메시지에 대한 첨부 파일을 설명하는 데 사용 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fa12877ef329dc75c9fda25bdec3c035fe723779" translate="yes" xml:space="preserve">
          <source>A type representing compound expressions in parsed julia code (ASTs). Each expression consists of a &lt;code&gt;head&lt;/code&gt;&lt;code&gt;Symbol&lt;/code&gt; identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a &lt;code&gt;Vector{Any}&lt;/code&gt; field called &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 줄리아 코드 (AST)의 복합 표현식을 나타내는 유형입니다. 각 표현식은 어떤 종류의 표현식 (예 : 호출, for 루프, 조건문 등)을 식별 하는 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;Symbol&lt;/code&gt; 과 하위 표현식 (예 : 호출의 인수)으로 구성됩니다. 하위 표현식은 &lt;code&gt;args&lt;/code&gt; 라는 &lt;code&gt;Vector{Any}&lt;/code&gt; 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="12166025929849592cdb9b904ad437a429f4da9f" translate="yes" xml:space="preserve">
          <source>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">타입 유니언은 특별한 &lt;a href=&quot;../../base/base/index#Core.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 생성 된 인자 타입의 모든 인스턴스를 객체로 포함하는 특별한 추상 타입입니다 :</target>
        </trans-unit>
        <trans-unit id="c659722eaa7a1851dcf2b15fa8b1da6d2c52b7b1" translate="yes" xml:space="preserve">
          <source>A type union is an abstract type which includes all instances of any of its argument types. The empty union &lt;a href=&quot;#Union%7B%7D&quot;&gt;&lt;code&gt;Union{}&lt;/code&gt;&lt;/a&gt; is the bottom type of Julia.</source>
          <target state="translated">타입 유니언은 인수 타입의 모든 인스턴스를 포함하는 추상 타입입니다. 빈 연합 &lt;a href=&quot;#Union%7B%7D&quot;&gt; &lt;code&gt;Union{}&lt;/code&gt; &lt;/a&gt; 은 Julia의 최하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="78a19252283d099431e9543c48dcfeb2c0c70cdb" translate="yes" xml:space="preserve">
          <source>A type used for controlling the rounding mode of floating point operations (via &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;setrounding&lt;/code&gt; functions), or as optional arguments for rounding to the nearest integer (via the &lt;code&gt;round&lt;/code&gt; function).</source>
          <target state="translated">A (통해 부동 소수점 연산의 라운딩 모드를 제어하기 위해 사용되는 타입 &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;setrounding&lt;/code&gt; 기능) 또는 (비아 가장 가까운 정수로 반올림 선택적 인수로 &lt;code&gt;round&lt;/code&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="cce4e44b3212d47f6685805f453e4928d3ab1723" translate="yes" xml:space="preserve">
          <source>A type with no fields that is the type of &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 유형의 필드가없는 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2c8120bb7a13d8189f767168488ba78dd50f96b4" translate="yes" xml:space="preserve">
          <source>A type with no fields whose singleton instance &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; is used to represent missing values.</source>
          <target state="translated">누락 된 값을 나타내는 데 단일 인스턴스 &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 이있는 필드가없는 유형 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="306e436a1878b67ebef890bd34b67f5c57414a92" translate="yes" xml:space="preserve">
          <source>A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple &quot;destructuring&quot; that facilitates this:</source>
          <target state="translated">그러나 이러한 한 쌍의 반환 값을 일반적으로 사용하면 각 값을 변수로 추출합니다. Julia는이를 용이하게하는 간단한 튜플 &quot;파괴&quot;를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="913d40733121bbdbb40702c29375806cce6f85d2" translate="yes" xml:space="preserve">
          <source>A union of types over all values of a type parameter. &lt;code&gt;UnionAll&lt;/code&gt; is used to describe parametric types where the values of some parameters are not known.</source>
          <target state="translated">형식 매개 변수의 모든 값에 대한 형식의 합집합 &lt;code&gt;UnionAll&lt;/code&gt; 은 일부 매개 변수의 값을 알 수없는 매개 변수 유형을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a657ba8f21c293af12b12dfaacd8ec7d70ec5e5a" translate="yes" xml:space="preserve">
          <source>A useful tool for measuring performance is the &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; macro. We here repeat the example with the global variable above, but this time with the type annotation removed:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; 매크로 는 성능 측정에 유용한 도구입니다 . 위의 전역 변수를 사용하여 예제를 반복하지만 이번에는 유형 주석이 제거 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="c5253993e5fc44814c87723bb62dfda7d99d25d2" translate="yes" xml:space="preserve">
          <source>A variable name can be &quot;reserved&quot; without assigning to it by declaring it as &lt;code&gt;global x&lt;/code&gt;. This prevents name conflicts for globals initialized after load time.</source>
          <target state="translated">&lt;code&gt;global x&lt;/code&gt; 로 선언하여 변수 이름을 지정하지 않고 변수 이름을 &quot;예약&quot;할 수 있습니다 . 로드 시간 이후에 초기화 된 전역에 대한 이름 충돌을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="7fd534d23374f6545f94032e172165c5e2ffe3bb" translate="yes" xml:space="preserve">
          <source>A variable referring to the last computed value, automatically set at the interactive prompt.</source>
          <target state="translated">대화식 프롬프트에서 자동으로 설정되는 마지막 계산 된 값을 참조하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="9301af4052e23061aeab00f8629595c8531efad3" translate="yes" xml:space="preserve">
          <source>A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that you obtained after some math, for example) for later use. For example:</source>
          <target state="translated">Julia의 변수는 값과 연관된 이름입니다. 나중에 사용하기 위해 값 (예 : 수학 후에 얻은 값)을 저장하려는 경우에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="343ec2d984e66e00b3ae00539feb443a8166ee65" translate="yes" xml:space="preserve">
          <source>A variation on this approach, which avoids the appearance of type instability is to merge the &lt;code&gt;Int&lt;/code&gt; and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach &lt;em&gt;can&lt;/em&gt; be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots &amp;ndash; large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps &amp;ndash; situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.</source>
          <target state="translated">유형 불안정성의 모양을 피하는이 접근 방식의 변형은 &lt;code&gt;Int&lt;/code&gt; 및 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 유형을 단일 하이브리드 정수 유형으로 병합하여 결과가 더 이상 기계 정수의 크기에 맞지 않을 때 내부적으로 표시를 변경하는 것입니다. 이것은 Julia 코드 수준에서 유형 불안정성을 피할 수는 있지만이 하이브리드 정수 유형을 구현하는 C 코드에 동일한 어려움을 모두가함으로써 양탄자 문제를 해결할 수 있습니다. 이 방법 &lt;em&gt;은&lt;/em&gt;많은 경우에 빠르게 작동 할 수 있지만 몇 가지 단점이 있습니다. 한 가지 문제점은 정수 및 정수 배열의 메모리 내 표현이 더 이상 C, Fortran 및 기타 언어에서 기본 기계 정수로 사용하는 자연 표현과 일치하지 않는다는 것입니다. 따라서 이러한 언어와 상호 작용하려면 궁극적으로 기본 정수 유형을 도입해야합니다. 무제한의 정수 표현은 고정 된 수의 비트를 가질 수 없으므로 고정 크기 슬롯이있는 배열에 인라인으로 저장할 수 없습니다. 정수 값이 클수록 항상 별도의 힙 할당 스토리지가 필요합니다. 물론 하이브리드 정수 구현이 아무리 영리하게 사용하더라도 성능이 예기치 않게 저하되는 상황 인 성능 트랩이 항상 있습니다. 복잡한 표현, C 및 Fortran과의 상호 운용성 부족추가 힙 스토리지없이 정수 배열을 표현할 수없고 예측할 수없는 성능 특성으로 인해 가장 영리한 하이브리드 정수 구현도 고성능 수치 작업에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e58331c965191dacd80a8789c7e948a53ee2b04e" translate="yes" xml:space="preserve">
          <source>A very special macro is &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt;&lt;code&gt;@generated&lt;/code&gt;&lt;/a&gt;, which allows you to define so-called &lt;em&gt;generated functions&lt;/em&gt;. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.</source>
          <target state="translated">매우 특수한 매크로는 &lt;a href=&quot;../../base/base/index#Base.@generated&quot;&gt; &lt;code&gt;@generated&lt;/code&gt; 로&lt;/a&gt; , 소위 &lt;em&gt;생성 된 함수&lt;/em&gt; 를 정의 할 수 있습니다 . 이들은 여러 디스패치로 달성 할 수있는 것보다 더 유연하고 코드가 적은 인수 유형에 따라 특수 코드를 생성 할 수 있습니다. 매크로는 구문 분석시 표현식에 대해 작업하고 입력 유형에 액세스 할 수 없지만 인수 유형이 알려진 시점에 생성 된 함수가 확장되지만 함수는 아직 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="141d8c5657b1c8b0553ace4a61596a7c1734a9a6" translate="yes" xml:space="preserve">
          <source>A wrapper type used in &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; to distinguish between the absence of a value (&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;) and the presence of a &lt;code&gt;nothing&lt;/code&gt; value (i.e. &lt;code&gt;Some(nothing)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 에서 값이없는 것 ( &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; )과 값 이 &lt;code&gt;nothing&lt;/code&gt; (즉, &lt;code&gt;Some(nothing)&lt;/code&gt; ) 을 구분하기 위해 사용되는 래퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="a1df128dfacd3f460cbb61bb4087bb92287d3fcb" translate="yes" xml:space="preserve">
          <source>ARI</source>
          <target state="translated">ARI</target>
        </trans-unit>
        <trans-unit id="cade2543bf82eecb0447ba12066fcc5daa136208" translate="yes" xml:space="preserve">
          <source>ASCII characters and ASCII escapes produce a single byte.</source>
          <target state="translated">ASCII 문자와 ASCII 이스케이프는 단일 바이트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20ab2d9088d2ab458d63ed3bd729fda9297db5a4" translate="yes" xml:space="preserve">
          <source>AV</source>
          <target state="translated">AV</target>
        </trans-unit>
        <trans-unit id="33a783add30fb01fc6df3bfeb87611c9fd6e0247" translate="yes" xml:space="preserve">
          <source>Abbr.</source>
          <target state="translated">Abbr.</target>
        </trans-unit>
        <trans-unit id="d634b593f2d04c176e6178cce99b9871b914261f" translate="yes" xml:space="preserve">
          <source>Above, it was pointed out that one can resolve ambiguities like</source>
          <target state="translated">위와 같이 모호성을 해결할 수 있다고 지적되었습니다.</target>
        </trans-unit>
        <trans-unit id="444368fcd88ae8ee9706df79374d2260c8851efb" translate="yes" xml:space="preserve">
          <source>Abstract Arrays</source>
          <target state="translated">추상 배열</target>
        </trans-unit>
        <trans-unit id="afab87d7da169104e68739efdca076e3028a0b71" translate="yes" xml:space="preserve">
          <source>Abstract Types</source>
          <target state="translated">추상 유형</target>
        </trans-unit>
        <trans-unit id="3731303601cb9a5262dd9843918c4065a4b09ed2" translate="yes" xml:space="preserve">
          <source>Abstract containers and element types</source>
          <target state="translated">추상 컨테이너 및 요소 유형</target>
        </trans-unit>
        <trans-unit id="b81afa6e965e7c1908221b1c01f57fb3e1ed309d" translate="yes" xml:space="preserve">
          <source>Abstract number types</source>
          <target state="translated">추상 숫자 유형</target>
        </trans-unit>
        <trans-unit id="203bf0ca60eba0b4df86ca193ff6564bf1f08046" translate="yes" xml:space="preserve">
          <source>Abstract supertype describing types that implement the synchronization primitives: &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Base.islocked&quot;&gt;&lt;code&gt;islocked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">: 동기화 프리미티브를 구현하는 유형 설명하는 추상 슈퍼 &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;#Base.islocked&quot;&gt; &lt;code&gt;islocked&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="161cfe5f22c6ec0c5c1636e00ae6b86b4dfab7b0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for IP addresses. &lt;a href=&quot;#Sockets.IPv4&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Sockets.IPv6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; are subtypes of this.</source>
          <target state="translated">IP 주소의 추상 수퍼 타입. &lt;a href=&quot;#Sockets.IPv4&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Sockets.IPv6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 은이 유형의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7ec52c1e034eaa75fbf55c8ad047e12dee7c43d5" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all floating point numbers.</source>
          <target state="translated">모든 부동 소수점 숫자에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="d3c5cb7bbcaf4de0abc6af421aee06fd1805c5f7" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all integers.</source>
          <target state="translated">모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="c2307397eab7e7e325b924259a7acd689ce9202f" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all number types.</source>
          <target state="translated">모든 숫자 유형에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="8137ecd293ea0b9f148b79a2c5d9ef23135b11e0" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all real numbers.</source>
          <target state="translated">모든 실수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="5d4c24eb8dfef4792ccde0796267cae116c984c2" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all signed integers.</source>
          <target state="translated">부호있는 모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="98c1a75aa7f0d6a8990b451bf94db6a410025a03" translate="yes" xml:space="preserve">
          <source>Abstract supertype for all unsigned integers.</source>
          <target state="translated">부호없는 모든 정수에 대한 추상 수퍼 타입.</target>
        </trans-unit>
        <trans-unit id="93e4098f9689d748060c11ebe52324df10ec1351" translate="yes" xml:space="preserve">
          <source>Abstract supertype for rich display output devices. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt;&lt;code&gt;TextDisplay&lt;/code&gt;&lt;/a&gt; is a subtype of this.</source>
          <target state="translated">풍부한 디스플레이 출력 장치를위한 추상 수퍼 타입. &lt;a href=&quot;#Base.Multimedia.TextDisplay&quot;&gt; &lt;code&gt;TextDisplay&lt;/code&gt; &lt;/a&gt; 는 이것의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="76cd9a3f07be7d40989b1baf043119bf5df6066e" translate="yes" xml:space="preserve">
          <source>Abstract type of all functions.</source>
          <target state="translated">모든 기능의 추상적 유형.</target>
        </trans-unit>
        <trans-unit id="84e429cc9f28682f2f27e8d636ad9613a3b2da6d" translate="yes" xml:space="preserve">
          <source>Abstract types are declared using the &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt;&lt;code&gt;abstract type&lt;/code&gt;&lt;/a&gt; keyword. The general syntaxes for declaring an abstract type are:</source>
          <target state="translated">추상 유형은 &lt;a href=&quot;../../base/base/index#abstract%20type&quot;&gt; &lt;code&gt;abstract type&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 선언됩니다 . 추상 형식을 선언하는 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c58fec15e5232080566685f01231f0dc1e49a918" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.</source>
          <target state="translated">추상 유형은 인스턴스화 할 수 없으며 유형 그래프에서 노드의 역할 만하므로 관련 콘크리트 유형 세트 (자손 인 콘크리트 유형)를 설명합니다. 추상 유형은 유형 시스템의 중추이기 때문에 인스턴스화가 없지만 추상 유형으로 시작합니다. 이들은 개념적 계층 구조를 형성하여 Julia의 유형 시스템을 단순한 객체 구현 모음 이상으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99f8f0ef23e181287cd6d3022637085c03e3e6b8" translate="yes" xml:space="preserve">
          <source>AbstractDict</source>
          <target state="translated">AbstractDict</target>
        </trans-unit>
        <trans-unit id="c0458876d81208a95087a4de5e1caaa1d2000c99" translate="yes" xml:space="preserve">
          <source>AbstractDisplay &lt;code&gt;x&lt;/code&gt; using the topmost applicable display in the display stack, typically using the richest supported multimedia output for &lt;code&gt;x&lt;/code&gt;, with plain-text &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output as a fallback. The &lt;code&gt;display(d, x)&lt;/code&gt; variant attempts to display &lt;code&gt;x&lt;/code&gt; on the given display &lt;code&gt;d&lt;/code&gt; only, throwing a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;d&lt;/code&gt; cannot display objects of this type.</source>
          <target state="translated">AbstractDisplay &lt;code&gt;x&lt;/code&gt; 는 디스플레이 스택에서 최상위로 적용 가능한 디스플레이를 사용하며 일반적으로 &lt;code&gt;x&lt;/code&gt; 에 대해 가장 풍부한 지원되는 멀티미디어 출력을 사용하며 일반 텍스트 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 출력을 폴백으로 사용합니다. &lt;code&gt;display(d, x)&lt;/code&gt; 표시하는 변형 시도 &lt;code&gt;x&lt;/code&gt; 주어진 디스플레이에 &lt;code&gt;d&lt;/code&gt; 투구 만 &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 이&lt;/a&gt; 경우 &lt;code&gt;d&lt;/code&gt; 이 유형의 오브젝트를 표시 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="7eaed6a73d55c164395b7a1a21e441cbb954faed" translate="yes" xml:space="preserve">
          <source>AbstractIrrational</source>
          <target state="translated">AbstractIrrational</target>
        </trans-unit>
        <trans-unit id="bf18f60e42cfb0779a9b4f7ddad8d2d330b3942c" translate="yes" xml:space="preserve">
          <source>AbstractLock</source>
          <target state="translated">AbstractLock</target>
        </trans-unit>
        <trans-unit id="b088bdfb0583418c7216120363be65d53cfb24c4" translate="yes" xml:space="preserve">
          <source>AbstractMatrix</source>
          <target state="translated">AbstractMatrix</target>
        </trans-unit>
        <trans-unit id="1a85fd0dbacd4a4cf6bcd5291fb7d75e1f9be36d" translate="yes" xml:space="preserve">
          <source>AbstractRange</source>
          <target state="translated">AbstractRange</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="1d4be86b60074a8c81bb5c652c7352a1af4f56bd" translate="yes" xml:space="preserve">
          <source>AbstractUnitRange</source>
          <target state="translated">AbstractUnitRange</target>
        </trans-unit>
        <trans-unit id="69ac868610201e6a40f57ef6a33cac3933afa73e" translate="yes" xml:space="preserve">
          <source>AbstractVecOrMat</source>
          <target state="translated">AbstractVecOrMat</target>
        </trans-unit>
        <trans-unit id="6167adb4464ed99a679a24201ae93baff8fe87bb" translate="yes" xml:space="preserve">
          <source>AbstractVector</source>
          <target state="translated">AbstractVector</target>
        </trans-unit>
        <trans-unit id="ff33b5833701038044ed7a8bf95bb5da1639a716" translate="yes" xml:space="preserve">
          <source>Abusing this will corrupt the runtime system and cause undefined behavior:</source>
          <target state="translated">이를 사용하지 않으면 런타임 시스템이 손상되고 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1067d0a82d1d5a296a37f79af88170005dbcf1e6" translate="yes" xml:space="preserve">
          <source>Ac Current</source>
          <target state="translated">교류 전류</target>
        </trans-unit>
        <trans-unit id="d1e31fbd4f9f4072d2446b9b7e8c1f20663d7c76" translate="yes" xml:space="preserve">
          <source>Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.</source>
          <target state="translated">주어진 서버에서 연결을 수락하고 클라이언트에 대한 연결을 반환합니다. 초기화되지 않은 클라이언트 스트림이 제공 될 수 있으며,이 경우 새 스트림을 생성하는 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a231d65a330d9d9348434455d2fcc49d60050da" translate="yes" xml:space="preserve">
          <source>Access arrays in memory order, along columns</source>
          <target state="translated">열을 따라 메모리 순서로 배열에 액세스</target>
        </trans-unit>
        <trans-unit id="b34a6bc7b1bae42bda9d01ca1c470c5375ab7fb7" translate="yes" xml:space="preserve">
          <source>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</source>
          <target state="translated">액세스는 보폭 패턴을 가져야하며 &quot;수집&quot;(임의 색인 읽기) 또는 &quot;산란&quot;(임의 색인 쓰기)이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04dff1094ca04d8d22abd4cb907396dab9a3d50f" translate="yes" xml:space="preserve">
          <source>Accessing Data through a Pointer</source>
          <target state="translated">포인터를 통해 데이터에 액세스</target>
        </trans-unit>
        <trans-unit id="4e0aa606654432d6afe63016328a7456acbf5548" translate="yes" xml:space="preserve">
          <source>Accessing Documentation</source>
          <target state="translated">문서에 액세스</target>
        </trans-unit>
        <trans-unit id="5effc224ab155ff163fdf8204037715e80f5787f" translate="yes" xml:space="preserve">
          <source>Accessing Global Variables</source>
          <target state="translated">글로벌 변수에 액세스</target>
        </trans-unit>
        <trans-unit id="eece63f5b1a8127dcc472656346b5e65a1a16b4d" translate="yes" xml:space="preserve">
          <source>Accessing Returned Arrays</source>
          <target state="translated">반환 된 배열에 액세스</target>
        </trans-unit>
        <trans-unit id="94331919d037782e6104eb270ff9d9fb7da43903" translate="yes" xml:space="preserve">
          <source>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. &lt;code&gt;x.a&lt;/code&gt;, or using &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;x[:a]&lt;/code&gt;. A tuple of the names can be obtained using &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, and a tuple of the values can be obtained using &lt;a href=&quot;../collections/index#Base.values&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명명 된 튜플에서 이름과 연관된 값에 액세스하는 것은 필드 액세스 구문 (예 : &lt;code&gt;x.a&lt;/code&gt; ) 또는 &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; (예 : &lt;code&gt;x[:a]&lt;/code&gt; 사용하여 수행 할 수 있습니다 . &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 를 사용하여 이름 의 튜플을 얻을 수 있고 &lt;a href=&quot;../collections/index#Base.values&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 사용하여 값 의 튜플을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e66b7f3723702c43ff6e0aa8ffbcb4594a04f89" translate="yes" xml:space="preserve">
          <source>Accessor Functions</source>
          <target state="translated">접근 자 기능</target>
        </trans-unit>
        <trans-unit id="d2767f0a53b5589f58d10c2a600ba9c937b4860b" translate="yes" xml:space="preserve">
          <source>Accumulation and clearing</source>
          <target state="translated">축적 및 청소</target>
        </trans-unit>
        <trans-unit id="8d4bc1e3633428932020325ab9038391aedb805b" translate="yes" xml:space="preserve">
          <source>Accurate natural logarithm of &lt;code&gt;1+x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments less than -1.</source>
          <target state="translated">&lt;code&gt;1+x&lt;/code&gt; 의 정확한 자연 로그 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 는&lt;/a&gt; 대한 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; -1보다 작은 인수.</target>
        </trans-unit>
        <trans-unit id="daec25040f3792b222435be23467b3ab6876b7a5" translate="yes" xml:space="preserve">
          <source>Accurately compute $e^x-1$.</source>
          <target state="translated">$ e ^ x-1 $를 정확하게 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="11d200c26fa49e2ce4befb8e0cf46e14cd0db2d8" translate="yes" xml:space="preserve">
          <source>Acquire the &lt;code&gt;lock&lt;/code&gt; when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 가 사용 가능 해지면 확보하십시오 . 다른 작업 / 스레드에 의해 잠금이 이미 잠긴 경우 사용 가능할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="111fa83b00bb4738853e63e06a10c68a0195c86f" translate="yes" xml:space="preserve">
          <source>Acquire the lock if it is available, and return &lt;code&gt;true&lt;/code&gt; if successful. If the lock is already locked by a different task/thread, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 잠금을 획득하고 성공하면 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 . 잠금이 이미 다른 작업 / 스레드에 의해 잠겨 있으면 &lt;code&gt;false&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2342ed0f0b229a0d03ed8168b59f19edf073636" translate="yes" xml:space="preserve">
          <source>Acute Angle</source>
          <target state="translated">예각</target>
        </trans-unit>
        <trans-unit id="4e210cb6cb9deed65bd9b851c840063ddc24f3fc" translate="yes" xml:space="preserve">
          <source>Add a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스케줄러 대기열에 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 추가하십시오 . 이로 인해 시스템이 유휴 상태 일 때 작업이 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 등의 차단 작업을 수행하지 않는 한 작업이 계속 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba7029093da6b4c90c7e27d2113f54b848408051" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;fetch&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to fetch from.</source>
          <target state="translated">지정된 &lt;code&gt;rmt&lt;/code&gt; 에 대한 &lt;em&gt;페치 참조&lt;/em&gt; 스펙을 추가하십시오 . 이 참조 스펙에는 가져올 브랜치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bc32e59f77d37df698d49af8f9d944b43a7af79c" translate="yes" xml:space="preserve">
          <source>Add a &lt;em&gt;push&lt;/em&gt; refspec for the specified &lt;code&gt;rmt&lt;/code&gt;. This refspec will contain information about which branch(es) to push to.</source>
          <target state="translated">지정된 &lt;code&gt;rmt&lt;/code&gt; 에 대한 &lt;em&gt;푸시 참조 사양을&lt;/em&gt; 추가하십시오 . 이 참조 스펙에는 푸시 할 브랜치에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2e4a20c94af16618f42a95303b58afe01cacad" translate="yes" xml:space="preserve">
          <source>Add a mark at the current position of stream &lt;code&gt;s&lt;/code&gt;. Return the marked position.</source>
          <target state="translated">stream &lt;code&gt;s&lt;/code&gt; 현재 위치에 마크를 추가하십시오 . 표시된 위치를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="c81d1e9a4af83f24f843b4a0dd03ec8759d823af" translate="yes" xml:space="preserve">
          <source>Add all the files with paths specified by &lt;code&gt;files&lt;/code&gt; to the index &lt;code&gt;idx&lt;/code&gt; (or the index of the &lt;code&gt;repo&lt;/code&gt;). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. &lt;code&gt;files&lt;/code&gt; may contain glob patterns which will be expanded and any matching files will be added (unless &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; is set, see below). If a file has been ignored (in &lt;code&gt;.gitignore&lt;/code&gt; or in the config), it &lt;em&gt;will not&lt;/em&gt; be added, &lt;em&gt;unless&lt;/em&gt; it is already being tracked in the index, in which case it &lt;em&gt;will&lt;/em&gt; be updated. The keyword argument &lt;code&gt;flags&lt;/code&gt; is a set of bit-flags which control the behavior with respect to ignored files:</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; 에 의해 지정된 경로를 가진 모든 파일 을 색인 &lt;code&gt;idx&lt;/code&gt; (또는 &lt;code&gt;repo&lt;/code&gt; 의 색인 )에 추가하십시오. 파일이 이미 존재하면 색인 항목이 업데이트됩니다. 파일이 없으면 색인에 새로 추가됩니다. &lt;code&gt;files&lt;/code&gt; 확장 될 것이고 일치하는 파일 (않는 추가 될 글롭 패턴을 포함 할 수있다 &lt;code&gt;INDEX_ADD_DISABLE_PATHSPEC_MATCH&lt;/code&gt; 가 설정되어, 아래 참조). 파일이 (무시 된 경우 &lt;code&gt;.gitignore&lt;/code&gt; 또는 설정에), 그것은 &lt;em&gt;하지 않습니다&lt;/em&gt; , 추가 될 &lt;em&gt;하지 않는 한&lt;/em&gt; 이미이있는 경우에는 인덱스에서 추적하는 &lt;em&gt;것입니다&lt;/em&gt; 업데이트. 키워드 인수 &lt;code&gt;flags&lt;/code&gt; 무시 된 파일에 대한 동작을 제어하는 ​​비트 플래그 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f9859b5e151c0d4dccb9ba69eeb3e7174642b756" translate="yes" xml:space="preserve">
          <source>Add processes on remote machines via SSH. Requires &lt;code&gt;julia&lt;/code&gt; to be installed in the same location on each node, or to be available via a shared file system.</source>
          <target state="translated">SSH를 통해 원격 시스템에 프로세스를 추가하십시오. 필요 &lt;code&gt;julia&lt;/code&gt; 각 노드에서 같은 위치에 설치하거나 공유 파일 시스템을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93d7a95d43dad0a2e3566faa9380568c513bf49" translate="yes" xml:space="preserve">
          <source>Add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">의 요소를 추가 &lt;code&gt;collection2&lt;/code&gt; 을 끝으로 &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="8f60daef6009f4b56c282cccb45652345ff90737" translate="yes" xml:space="preserve">
          <source>Addition operator. &lt;code&gt;x+y+z+...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;+(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">추가 연산자. &lt;code&gt;x+y+z+...&lt;/code&gt; 는 모든 인수, 즉 &lt;code&gt;+(x, y, z, ...)&lt;/code&gt; 와 함께이 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="23397c083849f8b996730f9a8baa14e28dc8e903" translate="yes" xml:space="preserve">
          <source>Additional examples and tests are available in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt;&lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 예제 및 테스트는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl&quot;&gt; &lt;code&gt;stdlib/Dates/test/adjusters.jl&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="685ef1698c6666c2bd0d492d0ee46828879da80d" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt; (except for &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt;) as a &quot;scalar&quot;.</source>
          <target state="translated">또한 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 는 배열로 제한되지 않으며 (함수 설명서 참조) 또한 튜플을 처리하고 배열, 튜플 또는 &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; 제외 ) 가 아닌 모든 인수를 &quot;스칼라&quot;로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7f79534c24bf8f2a16bd71a1b6a3a39a544a8226" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt;&lt;code&gt;sinpi(x)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt;&lt;code&gt;cospi(x)&lt;/code&gt;&lt;/a&gt; are provided for more accurate computations of &lt;code&gt;sin(pi*x)&lt;/code&gt; and &lt;code&gt;cos(pi*x)&lt;/code&gt; respectively.</source>
          <target state="translated">또한 &lt;a href=&quot;../../base/math/index#Base.Math.sinpi&quot;&gt; &lt;code&gt;sinpi(x)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.Math.cospi&quot;&gt; &lt;code&gt;cospi(x)&lt;/code&gt; &lt;/a&gt; 는 각각 &lt;code&gt;sin(pi*x)&lt;/code&gt; 및 &lt;code&gt;cos(pi*x)&lt;/code&gt; 보다 정확한 계산을 위해 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf3a3f7bf5e98e1e5497ee4fe9676516a92be473" translate="yes" xml:space="preserve">
          <source>Additionally, code blocks can be enclosed using triple backticks with an optional &quot;language&quot; to specify how a block of code should be highlighted.</source>
          <target state="translated">또한 코드 블록을 강조 표시하는 방법을 지정하기 위해 선택적 &quot;언어&quot;와 함께 삼중 백틱을 사용하여 코드 블록을 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa6d0dd52c8f973d7d02448858d93589ccb8e270" translate="yes" xml:space="preserve">
          <source>Additionally, full support for &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex and Rational Numbers&lt;/a&gt; is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion system&lt;/a&gt;.</source>
          <target state="translated">또한 이러한 기본 숫자 유형 위에 &lt;a href=&quot;../complex-and-rational-numbers/index#Complex-and-Rational-Numbers-1&quot;&gt;Complex 및 Rational Numbers&lt;/a&gt; 를 완벽하게 지원합니다 . 유연하고 사용자가 확장 할 수있는 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;유형 승격 시스템&lt;/a&gt; 덕분에 모든 숫자 유형이 명시 적 캐스트없이 자연스럽게 상호 운용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccda9828ec19af11c51796660b5ccb16a7d0e952" translate="yes" xml:space="preserve">
          <source>Additionally, normal and exponential distributions are implemented for some &lt;code&gt;AbstractFloat&lt;/code&gt; and &lt;code&gt;Complex&lt;/code&gt; types, see &lt;a href=&quot;#Base.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Random.randexp&quot;&gt;&lt;code&gt;randexp&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">또한, 일부 &lt;code&gt;AbstractFloat&lt;/code&gt; 및 &lt;code&gt;Complex&lt;/code&gt; 유형에 대해 정규 및 지수 분포가 구현됩니다 . 자세한 내용 은 &lt;a href=&quot;#Base.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Random.randexp&quot;&gt; &lt;code&gt;randexp&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99173595dabed80445cea4531dee6a385768b591" translate="yes" xml:space="preserve">
          <source>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</source>
          <target state="translated">또한 괄호로 묶은 표현식을 변수에 대한 계수로 사용할 수 있으므로 표현식에 변수가 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="fc43d556aa5aff0175b36169557918148740e7bb" translate="yes" xml:space="preserve">
          <source>Additionally, some exception types take one or more arguments that are used for error reporting:</source>
          <target state="translated">또한 일부 예외 유형은 오류보고에 사용되는 하나 이상의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8af66c1813abced10595ff4db44c8598650f35a8" translate="yes" xml:space="preserve">
          <source>Additionally, to support the syntax &lt;code&gt;S[end]&lt;/code&gt;, we must define &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to specify the last valid index. It is recommended to also define &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt;&lt;code&gt;firstindex&lt;/code&gt;&lt;/a&gt; to specify the first valid index:</source>
          <target state="translated">또한 &lt;code&gt;S[end]&lt;/code&gt; 구문을 지원하려면 &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; 를 정의 하여 마지막 유효한 인덱스를 지정 해야합니다 . 첫 번째 유효한 인덱스를 지정하려면 &lt;a href=&quot;../../base/collections/index#Base.firstindex&quot;&gt; &lt;code&gt;firstindex&lt;/code&gt; &lt;/a&gt; 를 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0d6e9dda2992ae61bd194a5d6431ac6a6fc0e4af" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each of which should be a documentable expression. This syntax is equivalent to</source>
          <target state="translated">문서화 가능한 표현식이어야 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 이 구문은</target>
        </trans-unit>
        <trans-unit id="8943e54e348b67270f56f401533e4c55795efd88" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to expression generated by expanding &lt;code&gt;@m expression&lt;/code&gt;. This allows for expressions decorated with &lt;code&gt;@inline&lt;/code&gt;, &lt;code&gt;@noinline&lt;/code&gt;, &lt;code&gt;@generated&lt;/code&gt;, or any other macro to be documented in the same way as undecorated expressions.</source>
          <target state="translated">&lt;code&gt;@m expression&lt;/code&gt; 을 확장하여 생성 된 표현식에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 이를 통해 &lt;code&gt;@inline&lt;/code&gt; , &lt;code&gt;@noinline&lt;/code&gt; , &lt;code&gt;@generated&lt;/code&gt; 또는 기타 매크로로 장식 된 표현식을 장식되지 않은 표현식과 동일한 방식으로 문서화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5cf536102070d30975cbdc29561f68968871a8c" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;@m(::Any)&lt;/code&gt; macro definition.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 &lt;code&gt;@m(::Any)&lt;/code&gt; 매크로 정의에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="84e25857657b333b201a4364df19960589319dca" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Binding&lt;/code&gt;s &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">를 추가의 문서화 문자열 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 받는 사람 &lt;code&gt;Binding&lt;/code&gt; 의 , &lt;code&gt;b&lt;/code&gt; , 그리고 &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9a2f04c857c99469b4786ce6042e5c04d6c307" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the &lt;code&gt;Module&lt;/code&gt;&lt;code&gt;M&lt;/code&gt;. Adding the docstring above the &lt;code&gt;Module&lt;/code&gt; is the preferred syntax, however both are equivalent.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; &lt;code&gt;M&lt;/code&gt; 에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . &lt;code&gt;Module&lt;/code&gt; 위에 docstring을 추가하는 것이 선호되는 구문이지만 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d607a4ba66a2defbbbd671ccd4f1fc3f1e66348d" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the function &lt;code&gt;f&lt;/code&gt;. The first version is the preferred syntax, however both are equivalent.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 함수 &lt;code&gt;f&lt;/code&gt; 에 추가합니다 . 첫 번째 버전이 선호하는 구문이지만 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="015afea43fcf05b33dc7ee7ee68bca2953573884" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the macro named &lt;code&gt;@m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@m&lt;/code&gt; 이라는 매크로에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="827af43a45abefcd341e6f719f9f401e5c730792" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the method &lt;code&gt;f(::Any)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f(::Any)&lt;/code&gt; 메소드에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c8df7e7a7df772447527b2f26ed82b0a9c8b23e3" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to the value associated with &lt;code&gt;sym&lt;/code&gt;. Users should prefer documenting &lt;code&gt;sym&lt;/code&gt; at its definition.</source>
          <target state="translated">&lt;code&gt;sym&lt;/code&gt; 과 연관된 값에 docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 추가합니다 . 사용자 문서화 선호한다 &lt;code&gt;sym&lt;/code&gt; 그 정의에.</target>
        </trans-unit>
        <trans-unit id="7496f9703fbec9a9c078ee921645986d1520779f" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to two &lt;code&gt;Method&lt;/code&gt;s, namely &lt;code&gt;f(::Any)&lt;/code&gt; and &lt;code&gt;f(::Any, ::Any)&lt;/code&gt;.</source>
          <target state="translated">를 추가의 문서화 문자열 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 2 &lt;code&gt;Method&lt;/code&gt; 들, 즉 &lt;code&gt;f(::Any)&lt;/code&gt; 와 &lt;code&gt;f(::Any, ::Any)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c8aaa795c4bb3bd668d398ed223b6d5b98c3053" translate="yes" xml:space="preserve">
          <source>Adds docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt; to field &lt;code&gt;T.x&lt;/code&gt; and &lt;code&gt;&quot;y&quot;&lt;/code&gt; to field &lt;code&gt;T.y&lt;/code&gt;. Also applicable to &lt;code&gt;mutable struct&lt;/code&gt; types.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 &lt;code&gt;T&lt;/code&gt; 유형에 , &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 &lt;code&gt;T.x&lt;/code&gt; 필드에 , &lt;code&gt;&quot;y&quot;&lt;/code&gt; 를 &lt;code&gt;T.y&lt;/code&gt; 필드에 추가합니다 . &lt;code&gt;mutable struct&lt;/code&gt; 유형 에도 적용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="509ef7b304e0d5048959f5a1e066b6245d575e62" translate="yes" xml:space="preserve">
          <source>Adds the docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; to types &lt;code&gt;T1&lt;/code&gt;, &lt;code&gt;T2&lt;/code&gt;, and &lt;code&gt;T3&lt;/code&gt;.</source>
          <target state="translated">docstring &lt;code&gt;&quot;...&quot;&lt;/code&gt; 을 유형 &lt;code&gt;T1&lt;/code&gt; , &lt;code&gt;T2&lt;/code&gt; 및 &lt;code&gt;T3&lt;/code&gt; 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="e9a51c66a638e61a03f3ba3bc6a5ae7966f901a4" translate="yes" xml:space="preserve">
          <source>Adjuster Functions</source>
          <target state="translated">조절기 기능</target>
        </trans-unit>
        <trans-unit id="3ed15208c269239266d3575007709a349ee8dcb4" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; by iterating at most &lt;code&gt;limit&lt;/code&gt; iterations by &lt;code&gt;step&lt;/code&gt; increments until &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must take a single &lt;code&gt;TimeType&lt;/code&gt; argument and return a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;same&lt;/code&gt; allows &lt;code&gt;dt&lt;/code&gt; to be considered in satisfying &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 &lt;code&gt;limit&lt;/code&gt; 증분 반복을 &lt;code&gt;step&lt;/code&gt; 단위로 반복하여 &lt;code&gt;dt&lt;/code&gt; 를 조정 합니다 . &lt;code&gt;func&lt;/code&gt; 은 단일 &lt;code&gt;TimeType&lt;/code&gt; 인수를 가져 와서 &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; 을&lt;/a&gt; 반환 해야합니다 . &lt;code&gt;same&lt;/code&gt; 있게 &lt;code&gt;dt&lt;/code&gt; 만족 고려하여야 &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542b7e7c2fd74f8d271308bdddf4ad37b5294110" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Monday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 월요일로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="ba3476b1421df6e3edaa8e17f787d5952e83be65" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the Sunday of its week.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 주 일요일로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="3224cd68e5551ff4e3fc4fc6b2b947ffc7f24a64" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the first &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월 의 첫 번째 &lt;code&gt;dow&lt;/code&gt; 로 조정합니다 . 또는 &lt;code&gt;of=Year&lt;/code&gt; 는 해당 연도 의 첫 번째 &lt;code&gt;dow&lt;/code&gt; 에 맞게 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="85f046851c6e044a73b6195b73c28ea067eb7654" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월의 첫 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="f4430fe642c3e3cf011a04583f6d0f8ce92cdee6" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 분기의 첫날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="84bc65bd05f794b2297c4096e727f0dd2edbb9dd" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the first day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 연도의 첫날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0c9a334203505d658bff6209e3cc9cb72c986e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last &lt;code&gt;dow&lt;/code&gt; of its month. Alternatively, &lt;code&gt;of=Year&lt;/code&gt; will adjust to the last &lt;code&gt;dow&lt;/code&gt; of the year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 그 달 의 마지막 &lt;code&gt;dow&lt;/code&gt; 로 조정합니다 . 또는 &lt;code&gt;of=Year&lt;/code&gt; 는 연도 의 마지막 &lt;code&gt;dow&lt;/code&gt; 에 맞게 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="78d3c49adba39ac1f401e060e547fe0cc0d6d99c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its month.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 월의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="64612df263c1926bf9efeecdbaf1b82e9cd07b8e" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its quarter.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 분기의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="91489c37594baa78e3476045075dafd7e9ef8e93" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the last day of its year.</source>
          <target state="translated">&lt;code&gt;dt&lt;/code&gt; 를 해당 연도의 마지막 날로 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="f360011526f7451524f23fc8d46d352e948cc7d3" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the next day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the next &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">를 조정은 &lt;code&gt;dt&lt;/code&gt; 에 해당하는주의 다음날 &lt;code&gt;dow&lt;/code&gt; 와 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . &lt;code&gt;same=true&lt;/code&gt; 로 설정 하면 현재 &lt;code&gt;dt&lt;/code&gt; 가 다음 &lt;code&gt;dow&lt;/code&gt; 로 간주되어 조정이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="068372d2e011960d73021d80afa760372bcf985c" translate="yes" xml:space="preserve">
          <source>Adjusts &lt;code&gt;dt&lt;/code&gt; to the previous day of week corresponding to &lt;code&gt;dow&lt;/code&gt; with &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt;. Setting &lt;code&gt;same=true&lt;/code&gt; allows the current &lt;code&gt;dt&lt;/code&gt; to be considered as the previous &lt;code&gt;dow&lt;/code&gt;, allowing for no adjustment to occur.</source>
          <target state="translated">를 조정은 &lt;code&gt;dt&lt;/code&gt; 에 해당하는 주 전날에 &lt;code&gt;dow&lt;/code&gt; 와 &lt;code&gt;1 = Monday, 2 = Tuesday, etc&lt;/code&gt; . &lt;code&gt;same=true&lt;/code&gt; 로 설정 하면 현재 &lt;code&gt;dt&lt;/code&gt; 가 이전 &lt;code&gt;dow&lt;/code&gt; 로 간주되어 조정이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59c3f81e00ff6162254f4463064f47b013b2418f" translate="yes" xml:space="preserve">
          <source>Admonitions</source>
          <target state="translated">Admonitions</target>
        </trans-unit>
        <trans-unit id="836a223dfb6110b2db06c9c781ddc336919a8a06" translate="yes" xml:space="preserve">
          <source>Admonitions, like most other toplevel elements, can contain other toplevel elements.</source>
          <target state="translated">다른 최상위 요소와 마찬가지로 훈계에는 다른 최상위 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83b0b84935203a338ba6594cae9f540216d121e" translate="yes" xml:space="preserve">
          <source>Advance the iterator to obtain the next element. If no elements remain, &lt;code&gt;nothing&lt;/code&gt; should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</source>
          <target state="translated">다음 요소를 얻기 위해 반복자를 진행시킵니다. 요소가 남아 있지 않으면 &lt;code&gt;nothing&lt;/code&gt; 반환 되지 않아야합니다. 그렇지 않으면 다음 요소의 2 튜플과 새로운 반복 상태가 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b6a7abaa616c69342aad0f3bc06d227b49b3cf3" translate="yes" xml:space="preserve">
          <source>Advance the stream &lt;code&gt;io&lt;/code&gt; such that the next-read character will be the first remaining for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. If the keyword argument &lt;code&gt;linecomment&lt;/code&gt; is specified, all characters from that character until the start of the next line are ignored.</source>
          <target state="translated">다음 읽기 문자가 &lt;code&gt;predicate&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 첫 번째 나머지 문자가되도록 스트림 &lt;code&gt;io&lt;/code&gt; 를 진행시킵니다 . 키워드 인수 &lt;code&gt;linecomment&lt;/code&gt; 가 지정되면 해당 문자에서 다음 행이 시작될 때까지의 모든 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="ff26be938424cf2d67217e2575645ca68557c533" translate="yes" xml:space="preserve">
          <source>Aerial Tramway</source>
          <target state="translated">공중 전차</target>
        </trans-unit>
        <trans-unit id="c3753451b13262a44f9a5817e07e24e560603141" translate="yes" xml:space="preserve">
          <source>After a call like &lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt;, you would get the expected result: &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt;. However, now suppose that &lt;code&gt;*=&lt;/code&gt;, when used with matrices, instead mutated the left hand side. There would be two problems:</source>
          <target state="translated">&lt;code&gt;x = 5; y = power_by_squaring(x, 4)&lt;/code&gt; 와 같은 호출 후 ; y = power_by_squaring (x, 4) 이면 예상 결과가 나타납니다. &lt;code&gt;x == 5 &amp;amp;&amp;amp; y == 625&lt;/code&gt; . 그러나 이제 행렬과 함께 사용될 때 &lt;code&gt;*=&lt;/code&gt; 대신 왼쪽을 변경 했다고 가정합니다 . 두 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="db34be90d58adae735cb60ab04365869aa56065b" translate="yes" xml:space="preserve">
          <source>Airplane</source>
          <target state="translated">Airplane</target>
        </trans-unit>
        <trans-unit id="80135999396a20e42730a1c2e1dfae947e0952c1" translate="yes" xml:space="preserve">
          <source>Alarm Clock</source>
          <target state="translated">알람 시계</target>
        </trans-unit>
        <trans-unit id="4c76737983211c324879531ef47ac946ce297c2e" translate="yes" xml:space="preserve">
          <source>Alef Symbol / First Transfinite Cardinal</source>
          <target state="translated">알레프 기호 / 최초의 영구 추기경</target>
        </trans-unit>
        <trans-unit id="f2f34a33d9ae0109b50986f6079e5b5b8422fa27" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;UndefInitializer()&lt;/code&gt;, which constructs an instance of the singleton type &lt;a href=&quot;#Core.UndefInitializer&quot;&gt;&lt;code&gt;UndefInitializer&lt;/code&gt;&lt;/a&gt;, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</source>
          <target state="translated">단일 생성자 유형 &lt;a href=&quot;#Core.UndefInitializer&quot;&gt; &lt;code&gt;UndefInitializer&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 생성하는 &lt;code&gt;UndefInitializer()&lt;/code&gt; 대한 별명 은 배열 초기화에 사용되어 배열 생성자 호출자가 초기화되지 않은 배열을 원함 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="38d75bc82e2c72130349f85ee2dea5673d201a42" translate="yes" xml:space="preserve">
          <source>Alien Monster</source>
          <target state="translated">외계인 몬스터</target>
        </trans-unit>
        <trans-unit id="0c70d0069c9dc176b6060d55ab195149b38ec01a" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;export&lt;/code&gt;ed names (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;), &lt;code&gt;MyModule.x&lt;/code&gt;, &lt;code&gt;MyModule.y&lt;/code&gt; and &lt;code&gt;MyModule.p&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;export&lt;/code&gt; ed 이름 ( &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; ), &lt;code&gt;MyModule.x&lt;/code&gt; , &lt;code&gt;MyModule.y&lt;/code&gt; 및 &lt;code&gt;MyModule.p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91f95289d7bb9f459a113b14aa6caea6d6b0ee5b" translate="yes" xml:space="preserve">
          <source>All Equal To</source>
          <target state="translated">모두 같음</target>
        </trans-unit>
        <trans-unit id="59150af6415167841703220f4f97802416f10725" translate="yes" xml:space="preserve">
          <source>All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (&lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt;) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; explicitly allows for other tasks to be scheduled.</source>
          <target state="translated">모든 I / O 작업, 타이머, REPL 명령 등은 이벤트 루프를 통해 단일 OS 스레드로 다중화됩니다. 패치 된 libuv 버전 ( &lt;a href=&quot;http://docs.libuv.org/en/v1.x/&quot;&gt;http://docs.libuv.org/en/v1.x/&lt;/a&gt; )이이 기능을 제공합니다. 항복 지점은 여러 작업을 동일한 OS 스레드에 협력 적으로 예약 할 수 있도록합니다. I / O 작업 및 타이머는 이벤트 발생을 기다리는 동안 암시 적으로 생성됩니다. 호출 &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; 다른 작업을 예약 할 수 있도록 명시 적으로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e522896e2dfc730e2866839376a2a265314c5b2a" translate="yes" xml:space="preserve">
          <source>All Julia streams expose at least a &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method, taking the stream as their first argument, e.g.:</source>
          <target state="translated">모든 Julia 스트림 은 스트림을 첫 번째 인수로 사용하여 최소한 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 메소드를 노출합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="c6a6b81f53852c577455dd25f826592290abcb2e" translate="yes" xml:space="preserve">
          <source>All Objects</source>
          <target state="translated">모든 객체</target>
        </trans-unit>
        <trans-unit id="b272413234229118c2015aaa68ca35bdb9c75799" translate="yes" xml:space="preserve">
          <source>All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level will be a &lt;strong&gt;global&lt;/strong&gt; variable. Variables defined at top level scope inside modules are also global.</source>
          <target state="translated">REPL의 모든 코드는 전역 범위에서 평가되므로 최상위 수준에서 정의되고 지정된 변수 는 &lt;strong&gt;전역&lt;/strong&gt; 변수가됩니다. 모듈 내부의 최상위 수준에서 정의 된 변수도 전역 적입니다.</target>
        </trans-unit>
        <trans-unit id="d45486021b7cdd7677275ec32e5637b641c26f3c" translate="yes" xml:space="preserve">
          <source>All comma-separated expressions after &lt;code&gt;for&lt;/code&gt; are interpreted as ranges. Adding parentheses lets us add a third argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 이후의 모든 쉼표로 구분 된 표현식 은 범위로 해석됩니다. 괄호를 추가하면 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 에&lt;/a&gt; 세 번째 인수를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1833bbb77ee3eab574ef8615d776277ec2b68aa" translate="yes" xml:space="preserve">
          <source>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</source>
          <target state="translated">마스터가 시작한 작업자 만 서로 연결할 수 있도록 모든 연결이 양쪽에서 인증됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad5ec5b3a4aaf8bd9fb90db1fc3be44898322c8" translate="yes" xml:space="preserve">
          <source>All declared types (the &lt;code&gt;DataType&lt;/code&gt; variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.</source>
          <target state="translated">선언 된 모든 유형 ( &lt;code&gt;DataType&lt;/code&gt; 종류)은 각 경우에 동일한 구문으로 매개 변수화 할 수 있습니다. 먼저 파라 메트릭 합성 타입, 파라 메트릭 추상 타입, 파라 메트릭 프리미티브 타입의 순서로 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9c5dd854b32fb08dbc64da03bc88b2f5ca50052" translate="yes" xml:space="preserve">
          <source>All instances of some abstract types are by default considered &quot;sufficiently similar&quot; that a universal &lt;code&gt;convert&lt;/code&gt; definition is provided in Julia Base. For example, this definition states that it's valid to &lt;code&gt;convert&lt;/code&gt; any &lt;code&gt;Number&lt;/code&gt; type to any other by calling a 1-argument constructor:</source>
          <target state="translated">일부 추상 유형의 모든 인스턴스는 기본적 으로 Julia Base에서 범용 &lt;code&gt;convert&lt;/code&gt; 정의가 제공되는 &quot;충분히 유사&quot;한 것으로 간주됩니다 . 예를 들어,이 정의 는 1 인수 생성자를 호출하여 임의의 &lt;code&gt;Number&lt;/code&gt; 유형을 다른 숫자 유형으로 &lt;code&gt;convert&lt;/code&gt; 하는 것이 유효 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="40a2b8b6f65bf4cf79d2f004dafadcaa12f30e1e" translate="yes" xml:space="preserve">
          <source>All interface customization is done through the keyword only &lt;code&gt;TerminalMenus.config()&lt;/code&gt; function.</source>
          <target state="translated">모든 인터페이스 사용자 정의는 키워드 전용 &lt;code&gt;TerminalMenus.config()&lt;/code&gt; 함수를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e93c45e883f28df975e96b20e62c4d715867d52" translate="yes" xml:space="preserve">
          <source>All non-real parts of the diagonal will be ignored.</source>
          <target state="translated">대각선의 비 실제 부분은 모두 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f36c1fb18a59b1d9f547660c394427791f475ab" translate="yes" xml:space="preserve">
          <source>All of the logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; share common features that are described in detail in the documentation for the more general macro &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 로깅 매크로 &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; 및 &lt;code&gt;@error&lt;/code&gt; 는 일반적인 매크로 &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 자세히 설명되어있는 공통 기능을 공유 합니다.</target>
        </trans-unit>
        <trans-unit id="97250d85e46e2f0063062a4fe00d04b5c8c86241" translate="yes" xml:space="preserve">
          <source>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</source>
          <target state="translated">희소 행렬에 대한 모든 작업은 CSC 데이터 구조를 활용하여 성능을 높이고 값 비싼 작업을 피하기 위해 신중하게 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d92bd72fff847012d04881678e278a18d2126812" translate="yes" xml:space="preserve">
          <source>All other combinations of arguments default to returning an &lt;code&gt;Array&lt;/code&gt;, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</source>
          <target state="translated">다른 모든 인수 조합은 기본적으로 &lt;code&gt;Array&lt;/code&gt; 를 반환 하지만 사용자 정의 컨테이너 유형은 자체 구현 및 승격과 같은 규칙을 정의하여 인수로 표시 될 때 결과를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de25475b274a168126e2d504207af50116291e77" translate="yes" xml:space="preserve">
          <source>All processes can directly communicate with each other.</source>
          <target state="translated">모든 프로세스는 서로 직접 통신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7feddee30f64db86bbc24d86a29d550a804d3b31" translate="yes" xml:space="preserve">
          <source>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</source>
          <target state="translated">클러스터의 모든 프로세스는 기본적으로 마스터 프로세스에서 임의로 생성 된 문자열 인 동일한 쿠키를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="ad59be0f62242de6d2f5d39eccfa83593fd9484b" translate="yes" xml:space="preserve">
          <source>All string types are subtypes of the abstract type &lt;code&gt;AbstractString&lt;/code&gt;, and external packages define additional &lt;code&gt;AbstractString&lt;/code&gt; subtypes (e.g. for other encodings). If you define a function expecting a string argument, you should declare the type as &lt;code&gt;AbstractString&lt;/code&gt; in order to accept any string type.</source>
          <target state="translated">모든 문자열 유형은 추상 유형 &lt;code&gt;AbstractString&lt;/code&gt; 의 하위 유형 이며 외부 패키지는 추가 &lt;code&gt;AbstractString&lt;/code&gt; 하위 유형 (예 : 다른 인코딩의 경우)을 정의합니다. 문자열 인수가 필요한 함수를 정의하는 경우 문자열 형식을 허용하려면 형식을 &lt;code&gt;AbstractString&lt;/code&gt; 으로 선언해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b0dc699cc676b22c3459d4cf16d1eaa2e5774729" translate="yes" xml:space="preserve">
          <source>All subtypes of &lt;code&gt;AbstractDateToken&lt;/code&gt; must define this method in order to be able to print a Date / DateTime object according to a &lt;code&gt;DateFormat&lt;/code&gt; containing that token.</source>
          <target state="translated">해당 토큰을 포함 하는 &lt;code&gt;DateFormat&lt;/code&gt; 에 따라 Date / DateTime 객체를 인쇄하려면 &lt;code&gt;AbstractDateToken&lt;/code&gt; 의 모든 하위 유형 이이 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c882b6f017fe5d01060c9bf473577d13959404c" translate="yes" xml:space="preserve">
          <source>All the sorting and order related functions rely on a &quot;less than&quot; relation defining a total order on the values to be manipulated. The &lt;code&gt;isless&lt;/code&gt; function is invoked by default, but the relation can be specified via the &lt;code&gt;lt&lt;/code&gt; keyword.</source>
          <target state="translated">모든 정렬 및 순서 관련 기능은 조작 할 값의 총 순서를 정의하는 &quot;보다 작음&quot;관계에 의존합니다. &lt;code&gt;isless&lt;/code&gt; 의 기능은 기본적으로 호출하지만 관계는 통해 지정할 수 있습니다 &lt;code&gt;lt&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="3c82535675951a4a1fb997658084e8ecb7b3e47f" translate="yes" xml:space="preserve">
          <source>All the standard trigonometric and hyperbolic functions are also defined:</source>
          <target state="translated">모든 표준 삼각 함수 및 쌍곡선 함수도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6670e96208b5b1af061bdf66066d2386e48cd71d" translate="yes" xml:space="preserve">
          <source>All workers in a cluster share the same &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;cookie&lt;/a&gt; as the master. When the cookie is unspecified, i.e, with the &lt;code&gt;--worker&lt;/code&gt; option, the worker tries to read it from its standard input. &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt; both pass the cookie to newly launched workers via their standard inputs.</source>
          <target state="translated">클러스터의 모든 작업자 는 마스터 와 동일한 &lt;a href=&quot;#man-cluster-cookie-1&quot;&gt;쿠키&lt;/a&gt; 를 공유합니다 . 쿠키가 지정되지 않은 경우 (예 : &lt;code&gt;--worker&lt;/code&gt; 옵션) 작업자는 표준 입력에서 쿠키 를 읽으려고합니다. &lt;code&gt;LocalManager&lt;/code&gt; 및 &lt;code&gt;SSHManager&lt;/code&gt; 는 모두 표준 입력을 통해 쿠키를 새로 시작된 작업자에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cc1f71fefd88bfe7d7be3a2017ea32033d467364" translate="yes" xml:space="preserve">
          <source>Allocation of output container</source>
          <target state="translated">출력 컨테이너 할당</target>
        </trans-unit>
        <trans-unit id="dbd9853a9ad8ada702240986063881992112c9e5" translate="yes" xml:space="preserve">
          <source>Allowed Variable Names</source>
          <target state="translated">허용되는 변수 이름</target>
        </trans-unit>
        <trans-unit id="18ef6092b26e1508d93983ee74a79d58892de4c1" translate="yes" xml:space="preserve">
          <source>Almost Equal Or Equal To</source>
          <target state="translated">거의 같거나 같음</target>
        </trans-unit>
        <trans-unit id="1fbf3e4677335672b3087596163b48e552785b56" translate="yes" xml:space="preserve">
          <source>Almost Equal To</source>
          <target state="translated">거의 동일</target>
        </trans-unit>
        <trans-unit id="7475fcee6d3c9395bedceacb414c243d6b969b91" translate="yes" xml:space="preserve">
          <source>Almost Equal To With Circumflex Accent</source>
          <target state="translated">곡절 악센트와 거의 동일</target>
        </trans-unit>
        <trans-unit id="2c35923911b4ba37311dbb677458e2c0adca9382" translate="yes" xml:space="preserve">
          <source>Alright, now that we have a better understanding of how generated functions work, let's use them to build some more advanced (and valid) functionality...</source>
          <target state="translated">자, 생성 된 함수의 작동 방식을 더 잘 이해 했으므로 이제이를 사용하여보다 고급 (고 유효한) 기능을 구축해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c2ff920784db1defb83bee5378709d9aaacf2e45" translate="yes" xml:space="preserve">
          <source>Also notice the difference between &lt;code&gt;max.(a,b)&lt;/code&gt;, which &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; elementwise over &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum(a)&lt;/code&gt;&lt;/a&gt;, which finds the largest value within &lt;code&gt;a&lt;/code&gt;. The same relationship holds for &lt;code&gt;min.(a,b)&lt;/code&gt; and &lt;code&gt;minimum(a)&lt;/code&gt;.</source>
          <target state="translated">또한 차이 통지 &lt;code&gt;max.(a,b)&lt;/code&gt; , &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 위에 elementwise 와 &lt;code&gt;b&lt;/code&gt; , 그리고 &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum(a)&lt;/code&gt; &lt;/a&gt; 가장 큰 값을 찾아 내, &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;min.(a,b)&lt;/code&gt; 및 &lt;code&gt;minimum(a)&lt;/code&gt; 대해서도 동일한 관계가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c0081a46476345434d3719172fe53c135ada9e3" translate="yes" xml:space="preserve">
          <source>Also observe the significant distinction between &lt;code&gt;\xff&lt;/code&gt; and &lt;code&gt;\uff&lt;/code&gt;: the former escape sequence encodes the &lt;em&gt;byte 255&lt;/em&gt;, whereas the latter escape sequence represents the &lt;em&gt;code point 255&lt;/em&gt;, which is encoded as two bytes in UTF-8:</source>
          <target state="translated">또한 &lt;code&gt;\xff&lt;/code&gt; 와 &lt;code&gt;\uff&lt;/code&gt; . 전자 이스케이프 시퀀스는 &lt;em&gt;바이트 255를&lt;/em&gt; 인코딩 하지만 후자의 이스케이프 시퀀스는 &lt;em&gt;코드 포인트 255를&lt;/em&gt; 나타냅니다.&lt;em&gt;&lt;/em&gt; 를 나타내며 UTF-8에서 2 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc9da3cb0ed97f96102bee03dd8744d00eda6b1" translate="yes" xml:space="preserve">
          <source>Also recommended is Bruce Dawson's &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;series of blog posts on floating-point numbers&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/&quot;&gt;부동 소수점 숫자에 대한&lt;/a&gt; Bruce Dawson의 블로그 게시물 시리즈를 권장 합니다 .</target>
        </trans-unit>
        <trans-unit id="a4d960a868768098e1ba53fb3f2c0df8ab0a40a7" translate="yes" xml:space="preserve">
          <source>Also, &lt;em&gt;every&lt;/em&gt; binary operator supports a &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot version&lt;/a&gt; that can be applied to arrays (and combinations of arrays and scalars) in such &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;fused broadcasting operations&lt;/a&gt;, e.g. &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;em&gt;모든&lt;/em&gt; 이진 연산자는 다음 과 같은 배열 (및 배열과 스칼라의 조합)에 적용 할 수 있는 &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;도트 버전&lt;/a&gt; 을 지원합니다.&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt; 융합 된 브로드 캐스트 작업&lt;/a&gt; (예 : &lt;code&gt;z .== sin.(x .* y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef09b3cc10de506de44d97115e3fd6f71c9ee1fa" translate="yes" xml:space="preserve">
          <source>Also, the function that arguments are splatted into need not be a varargs function (although it often is):</source>
          <target state="translated">또한 인수가 튀어 나오는 함수는 varargs 함수일 필요는 없습니다 (자주 사용하는 경우도 있음).</target>
        </trans-unit>
        <trans-unit id="a36cb69e8042fa50a20647f8ee8afd7f80876eda" translate="yes" xml:space="preserve">
          <source>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of &lt;code&gt;mode&lt;/code&gt; correspond to those from &lt;code&gt;fopen(3)&lt;/code&gt; or Perl &lt;code&gt;open&lt;/code&gt;, and are equivalent to setting the following boolean groups:</source>
          <target state="translated">5 개의 부울 대신 문자열 기반 모드 지정자가 사용되는 open의 대체 구문입니다. &lt;code&gt;mode&lt;/code&gt; 의 값은 &lt;code&gt;fopen(3)&lt;/code&gt; 의 값에 해당합니다. 또는 Perl &lt;code&gt;open&lt;/code&gt; 하며 다음 부울 그룹을 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a084d20c27ad4b5e370e6e41af49a7a8b0bbbe9c" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;using Module&lt;/code&gt; will import all exported &lt;code&gt;Module&lt;/code&gt; functions into the current namespace.</source>
          <target state="translated">또는 &lt;code&gt;using Module&lt;/code&gt; 을 사용 하면 내 보낸 모든 항목을 가져옵니다. &lt;code&gt;Module&lt;/code&gt; 함수를 현재 네임 스페이스로 .</target>
        </trans-unit>
        <trans-unit id="cfd0514a347606051a7fccfba50cde275fcde17f" translate="yes" xml:space="preserve">
          <source>Alternatively, a sequence of pair arguments may be passed.</source>
          <target state="translated">대안 적으로, 일련의 쌍 인수가 전달 될 수있다.</target>
        </trans-unit>
        <trans-unit id="05c4eee40518a92290ba5caa4623a48a40f59cc6" translate="yes" xml:space="preserve">
          <source>Alternatively, finer control and additional transformations may be be obtained by calling &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt;, where any number of the following boolean keywords options (which all default to &lt;code&gt;false&lt;/code&gt; except for &lt;code&gt;compose&lt;/code&gt;) are specified:</source>
          <target state="translated">또는 &lt;code&gt;Unicode.normalize(s; keywords...)&lt;/code&gt; 를 호출하여보다 세밀한 제어 및 추가 변환을 얻을 수 있습니다 . 여기서 다음과 같은 부울 키워드 옵션 ( &lt;code&gt;compose&lt;/code&gt; 제외하고 모두 기본값은 &lt;code&gt;false&lt;/code&gt; 임)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="010a2642adb5dc50cd6b75461c8c6c62daaeaa3c" translate="yes" xml:space="preserve">
          <source>Alternatively, for all methods but one you can insist that there is at least one element in the tuple:</source>
          <target state="translated">또는 하나를 제외한 모든 방법에 대해 튜플에 하나 이상의 요소가 있다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658838e4feeee97296786aaec18103d8deb93854" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</source>
          <target state="translated">또는 이미 배열을 할당 한 경우 해당 데이터 주위에 씬 래퍼를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d124820084afee646f363e2b5b6737ae2fc063" translate="yes" xml:space="preserve">
          <source>Alternatively, look at the &lt;code&gt;embedding.c&lt;/code&gt; program in the Julia source tree in the &lt;code&gt;test/embedding/&lt;/code&gt; folder. The file &lt;code&gt;ui/repl.c&lt;/code&gt; program is another simple example of how to set &lt;code&gt;jl_options&lt;/code&gt; options while linking against &lt;code&gt;libjulia&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;test/embedding/&lt;/code&gt; 폴더 의 Julia 소스 트리에서 &lt;code&gt;embedding.c&lt;/code&gt; 프로그램을 보십시오 . 파일 &lt;code&gt;ui/repl.c&lt;/code&gt; 프로그램 설정 방법은 또 다른 간단한 예입니다 &lt;code&gt;jl_options&lt;/code&gt; 의 에 연결하는 동안 옵션 &lt;code&gt;libjulia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138af7c8699b17e1331dd202694df9508d5db6a5" translate="yes" xml:space="preserve">
          <source>Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</source>
          <target state="translated">MATLAB 사용자는 Julia의 구문을 잘 알고 있지만 Julia는 MATLAB 복제본이 아닙니다. 주요 구문과 기능상의 차이점이 있습니다. 다음은 MATLAB에 익숙한 Julia 사용자를 놀라게 할 수있는 몇 가지 주목할만한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="995141b8a0f9c91fdda45a6f5368f07495906a19" translate="yes" xml:space="preserve">
          <source>Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible to return incompletely initialized objects:</source>
          <target state="translated">내부 생성자에서 완전히 초기화 된 객체를 반환하는 것이 일반적으로 좋지만 불완전하게 초기화 된 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37777e78887373deee2eff18df3fa452fb79fe3f" translate="yes" xml:space="preserve">
          <source>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</source>
          <target state="translated">단순한 개념으로 보이지만 가치 유형에 대한 다중 디스패치는 아마도 Julia 언어의 가장 강력하고 중심적인 기능 일 것입니다. 핵심 작업에는 일반적으로 수십 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29da1b638100965fc90d2d714395923c89f62871" translate="yes" xml:space="preserve">
          <source>Although one could, in principle, define methods for the &lt;code&gt;promote&lt;/code&gt; function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of &lt;code&gt;promote&lt;/code&gt; is defined in terms of an auxiliary function called &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt;&lt;code&gt;promote_rule&lt;/code&gt;&lt;/a&gt;, which one can provide methods for. The &lt;code&gt;promote_rule&lt;/code&gt; function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</source>
          <target state="translated">원칙적으로 &lt;code&gt;promote&lt;/code&gt; 함수에 대한 메소드를 직접 정의 할 수 있지만 인수 유형의 가능한 모든 순열에 대해 많은 중복 정의가 필요합니다. 대신 &lt;code&gt;promote&lt;/code&gt; 동작은 &lt;a href=&quot;../../base/base/index#Base.promote_rule&quot;&gt; &lt;code&gt;promote_rule&lt;/code&gt; &lt;/a&gt; 이라는 보조 함수 측면에서 정의되며 ,이를 통해 메소드를 제공 할 수 있습니다. &lt;code&gt;promote_rule&lt;/code&gt; 함수는 인수 유형의 인스턴스를 반환 유형으로 승격 될 것 같은 것을 입력 개체의 쌍을 받아 다른 유형의 객체를 반환합니다. 따라서 규칙을 정의하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b980acb1a668eb7b397d3aa918a20ac9dccd65cc" translate="yes" xml:space="preserve">
          <source>Although one sometimes speaks of dynamic languages as being &quot;typeless&quot;, they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can &amp;ndash; and usually must &amp;ndash; annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.</source>
          <target state="translated">동적 언어를 &quot;유형이 없다&quot;고 말하는 경우도 있지만, 기본 객체이든 사용자 정의이든 모든 객체에 유형이있는 것은 아닙니다. 그러나 대부분의 동적 언어에서 유형 선언이 없으면 컴파일러가 값 유형에 대해 지시 할 수 없으며 종종 유형에 대해 명시 적으로 말할 수 없습니다. 반면 정적 언어에서는 컴파일러의 형식에 주석을 달 수 있지만 일반적으로 필수는하지만 형식은 컴파일 타임에만 존재하며 런타임에는 조작하거나 표현할 수 없습니다. Julia에서는 유형 자체가 런타임 객체이며 정보를 컴파일러에 전달하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="125f5076dabfcecbce55bdc53934ea25594cddd6" translate="yes" xml:space="preserve">
          <source>Although this seems innocent enough, the problem is that &lt;code&gt;0&lt;/code&gt; is an integer (of type &lt;code&gt;Int&lt;/code&gt;) and &lt;code&gt;x&lt;/code&gt; might be of any type. Thus, depending on the value of &lt;code&gt;x&lt;/code&gt;, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</source>
          <target state="translated">이것은 충분히 순진한 것처럼 보이지만 문제는 &lt;code&gt;0&lt;/code&gt; 은 정수 ( &lt;code&gt;Int&lt;/code&gt; 유형 )이고 &lt;code&gt;x&lt;/code&gt; 는 모든 유형 일 수 있습니다. 따라서 &lt;code&gt;x&lt;/code&gt; 값에 따라이 함수는 두 가지 유형 중 하나의 값을 반환 할 수 있습니다. 이 동작은 허용되며 경우에 따라 바람직 할 수도 있습니다. 그러나 다음과 같이 쉽게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec497a089c99ee5c6f04e61edfbbd31dd8344ae" translate="yes" xml:space="preserve">
          <source>Always gives the opposite answer as &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">항상 정답은 &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4fd498143f69490fe006adbf63236a973c15889" translate="yes" xml:space="preserve">
          <source>Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.</source>
          <target state="translated">줄리아 코드로 인쇄 될 수 있도록 4 개의 공백으로 들여 쓰기를하여 문서 상단에 함수의 서명을 항상 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="660916a9bd0a5e0c60196e069f980a7e1234e2f9" translate="yes" xml:space="preserve">
          <source>Amalgamation Or Coproduct</source>
          <target state="translated">합병 또는 공동 제품</target>
        </trans-unit>
        <trans-unit id="6ed272289e5ab5f2571a80ecd7c9ab3c53aaab06" translate="yes" xml:space="preserve">
          <source>Ambulance</source>
          <target state="translated">Ambulance</target>
        </trans-unit>
        <trans-unit id="6d1fa3121887df24f251a0892c85ff68056930fd" translate="yes" xml:space="preserve">
          <source>American Football</source>
          <target state="translated">미식 축구</target>
        </trans-unit>
        <trans-unit id="f035eead5c54745562ec49798968d1579aa5f09e" translate="yes" xml:space="preserve">
          <source>An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a &lt;code&gt;Serializer&lt;/code&gt; and use it as the first argument to &lt;code&gt;serialize&lt;/code&gt; instead. See also &lt;a href=&quot;#Serialization.writeheader&quot;&gt;&lt;code&gt;Serialization.writeheader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">8 바이트 식별 헤더가 먼저 스트림에 기록됩니다. 헤더를 작성하지 않으려면 &lt;code&gt;Serializer&lt;/code&gt; 를 구성하고 대신 &lt;code&gt;serialize&lt;/code&gt; 할 첫 번째 인수로 사용하십시오. &lt;a href=&quot;#Serialization.writeheader&quot;&gt; &lt;code&gt;Serialization.writeheader&lt;/code&gt; &lt;/a&gt; 도 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="9f8eb9358e7cc36217bd2b82eb7c1c39f3757d67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; that allows reading and performs writes by appending. Seeking and truncating are not supported. See &lt;a href=&quot;#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; for the available constructors. If &lt;code&gt;data&lt;/code&gt; is given, creates a &lt;code&gt;PipeBuffer&lt;/code&gt; to operate on a data vector, optionally specifying a size beyond which the underlying &lt;code&gt;Array&lt;/code&gt; may not be grown.</source>
          <target state="translated">추가하여 읽고 쓸 수 있는 &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 입니다. 찾기 및 자르기는 지원되지 않습니다. 사용 가능한 생성자에 대해서는 &lt;a href=&quot;#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;code&gt;data&lt;/code&gt; 가 제공되는 경우 선택적으로 기본 &lt;code&gt;Array&lt;/code&gt; 가 커질 수없는 크기를 지정하여 데이터 벡터에서 작동 할 &lt;code&gt;PipeBuffer&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="46a38d582619a610af47f792a125ea49f7521df6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; is raised if all workers cannot be terminated before the requested &lt;code&gt;waitfor&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; 은&lt;/a&gt; 모든 근로자가 요청하기 전에 종료 할 수없는 경우 발생 &lt;code&gt;waitfor&lt;/code&gt; 초.</target>
        </trans-unit>
        <trans-unit id="1bb56954c25d718243d7106afdb56cc9d480c633" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AbstractRange&lt;/code&gt; giving the indices of the &lt;code&gt;k&lt;/code&gt;th diagonal of the matrix &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;M&lt;/code&gt; 의 &lt;code&gt;k&lt;/code&gt; 번째 대각선의 인덱스를 제공 하는 &lt;code&gt;AbstractRange&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213f54bf4207eca3291be6421983a526dc7b3d7a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values. Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the quantiles of non-missing values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; 경우 발생합니다 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 의 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을. 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 Quantile을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="6168a5d96f0d40b398487557f6a06e26763f063a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ArgumentError&lt;/code&gt; is thrown if &lt;code&gt;v&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">&lt;code&gt;ArgumentError&lt;/code&gt; 경우 발생합니다 &lt;code&gt;v&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 의 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="de0265152d952d723c42ab1da85aac224914443f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;N&lt;/code&gt; dimensional &lt;em&gt;strided&lt;/em&gt; array with elements of type &lt;code&gt;T&lt;/code&gt;. These arrays follow the &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array interface&lt;/a&gt;. If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 요소가 있는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;em&gt;스트라이드&lt;/em&gt; 배열입니다 . 이 배열은 &lt;a href=&quot;../../manual/interfaces/index#man-interface-strided-arrays-1&quot;&gt;strided array 인터페이스를&lt;/a&gt; 따릅니다 . 경우 &lt;code&gt;A&lt;/code&gt; 는 A는 &lt;code&gt;StridedArray&lt;/code&gt; 다음 요소는 크기에 따라 다를뿐만 차원 내의 일정 수의 오프셋과 함께 메모리에 저장된다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 는 차원 1에서 보폭 2를, 차원 2에서 보폭 3을 가질 수 있습니다. 차원 &lt;code&gt;d&lt;/code&gt; 를 따라 &lt;code&gt;A&lt;/code&gt; 를 증가 &lt;code&gt;strides(A, d)&lt;/code&gt; 메모리에서 [ 보폭 (A, d) ] 슬롯 만큼 점프 합니다. Strided 배열은 BLAS와 같은 외국어 라이브러리에 대한 포인터로 직접 전달 될 수 있기 때문에 특히 중요하고 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aa4010002940515c72a60f1328742b5780fa5172" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;NTuple&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt;s used to represent the dimensions of an &lt;a href=&quot;#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NTuple&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 의의 치수를 나타내는 데 사용할 &lt;a href=&quot;#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ab7a7129a70bb02730939dd401c0c0cf3528b7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;environment&lt;/em&gt; determines what &lt;code&gt;import X&lt;/code&gt; and &lt;code&gt;using X&lt;/code&gt; mean in various code contexts and what files these statements cause to be loaded. Julia understands two kinds of environments:</source>
          <target state="translated">&lt;em&gt;환경&lt;/em&gt; 을 결정 &lt;code&gt;import X&lt;/code&gt; 및 &lt;code&gt;using X&lt;/code&gt; 로드 할 평균에서 다양한 코드 상황을 어떤 파일이 문을 유발한다. Julia는 두 가지 환경을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="d4692c48e17766970146c81604672bba8f6ba8a0" translate="yes" xml:space="preserve">
          <source>An HTML renderer would display this as: &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0</source>
          <target state="translated">HTML 렌더러는 이것을 &lt;code&gt;Polar{Float64}&lt;/code&gt; complex number : 3.0으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f5d640fb430f989eb8d86d4a923189e2c2ab6f36" translate="yes" xml:space="preserve">
          <source>An action signature (e.g. for committers, taggers, etc). Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">액션 서명 (예 : 커미터, 태거 등) &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="831ca4165fd1236bfdc4d70ab9d199abd7cc83b7" translate="yes" xml:space="preserve">
          <source>An advanced example</source>
          <target state="translated">고급 예</target>
        </trans-unit>
        <trans-unit id="d38eace5e9dd251808391417899bd07eb120ad72" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;Vector{StackFrame}&lt;/code&gt; provided for convenience; returned by calls to &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 의 별칭이 제공됩니다. &lt;code&gt;stacktrace&lt;/code&gt; 호출로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="90783e8e994e5b4a2ae87f94a62cbca8637e0361" translate="yes" xml:space="preserve">
          <source>An alternative is to create a &quot;view&quot; of the array, which is an array object (a &lt;code&gt;SubArray&lt;/code&gt;) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt;&lt;code&gt;view&lt;/code&gt;&lt;/a&gt;, or more simply for a whole expression or block of code by putting &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; in front of that expression. For example:</source>
          <target state="translated">대안은 배열의 &quot;보기&quot;를 만드는 것인데,이 배열 은 복사본을 만들지 않고 원래 배열의 데이터를 실제로 참조 하는 배열 객체 ( &lt;code&gt;SubArray&lt;/code&gt; )입니다. 뷰에 쓰면 원래 배열의 데이터도 수정됩니다. &lt;a href=&quot;../../base/arrays/index#Base.view&quot;&gt; &lt;code&gt;view&lt;/code&gt; &lt;/a&gt; 를 호출하여 개별 슬라이스에 대해 수행 할 수 있고 , 또는 해당 표현식 앞에 &lt;a href=&quot;../../base/arrays/index#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; 를 넣어 전체 표현식 또는 코드 블록에 대해 더 간단하게 수행 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="885d0eebcc9f4c68f23331045091c9a5f90ade43" translate="yes" xml:space="preserve">
          <source>An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab&amp;trade; does:</source>
          <target state="translated">하이브리드 정수를 사용하거나 BigInts로 승격시키는 대안은 포화 정수 산술을 사용하는 것입니다. 최대 정수 값을 더하면 가장 작은 정수 값에서 빼기 위해 변경되지 않고 그대로 둡니다. 이것이 바로 Matlab &amp;trade;이하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="91592a446374cc055177971cd79c3aca7e004b7f" translate="yes" xml:space="preserve">
          <source>An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from &lt;code&gt;@name [a b] * v&lt;/code&gt;):</source>
          <target state="translated">배열 리터럴 (또는 이해)을 통해 매크로를 호출하는 다른 방법은 괄호를 사용하지 않고 둘 다를 병렬 처리하는 것입니다. 이 경우 배열은 매크로에 공급되는 유일한식이됩니다. 다음 구문은 동일하며 &lt;code&gt;@name [a b] * v&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f03a7e8903dd9860d01fd9cd12eaf55e1fc8996a" translate="yes" xml:space="preserve">
          <source>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</source>
          <target state="translated">함수 내에서 반복적으로 사용되는 변수에 대해 유사한 &quot;유형 안정성&quot;문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="743741f9ed42719bff5265ccfe550c12e7459fce" translate="yes" xml:space="preserve">
          <source>An annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt;&lt;code&gt;FetchHead&lt;/code&gt;&lt;/a&gt; is passed, or to a branch head described using &lt;code&gt;GitReference&lt;/code&gt;.</source>
          <target state="translated">주석이 달린 git commit에는 조회 방법 및 이유에 대한 정보가 포함되어 rebase 또는 merge 작업이 commit 컨텍스트에 대한 자세한 정보를 갖습니다. 충돌 파일에는 병합의 소스 / 대상 분기에 대한 정보가 포함되어 있습니다 (예 : 충돌). 어노테이션이있는 커밋은 원격 브랜치의 팁 (예 : &lt;a href=&quot;#LibGit2.FetchHead&quot;&gt; &lt;code&gt;FetchHead&lt;/code&gt; &lt;/a&gt; 가 전달 될 때 ) 또는 &lt;code&gt;GitReference&lt;/code&gt; 를 사용하여 설명 된 브랜치 헤드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0977e50dcc26db8fee5c84903315951fecb439bb" translate="yes" xml:space="preserve">
          <source>An anonymous function accepting multiple arguments can be written using the syntax &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt;. A zero-argument anonymous function is written as &lt;code&gt;()-&amp;gt;3&lt;/code&gt;. The idea of a function with no arguments may seem strange, but is useful for &quot;delaying&quot; a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">여러 인수를 허용하는 익명 함수는 &lt;code&gt;(x,y,z)-&amp;gt;2x+y-z&lt;/code&gt; 구문을 사용하여 작성할 수 있습니다 . 인수가 0 인 익명 함수는 &lt;code&gt;()-&amp;gt;3&lt;/code&gt; 으로 작성됩니다 . 인수가없는 함수에 대한 아이디어는 이상하게 보일 수 있지만 계산을 &quot;지연&quot;하는 데 유용합니다. 이 사용법에서 코드 블록은 인수가없는 함수로 래핑되며 나중에 &lt;code&gt;f&lt;/code&gt; 로 호출하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="670132e18df0dbda4c7927cbfa1f5f772c1b879a" translate="yes" xml:space="preserve">
          <source>An array allowing for &lt;code&gt;missing&lt;/code&gt; values but which does not contain any such value can be converted back to an array which does not allow for missing values using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;. If the array contains &lt;code&gt;missing&lt;/code&gt; values, a &lt;code&gt;MethodError&lt;/code&gt; is thrown during conversion</source>
          <target state="translated">결 &lt;code&gt;missing&lt;/code&gt; 허용 하지만 그러한 값을 포함하지 않는 배열은 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 를&lt;/a&gt; 사용하여 결 측값을 허용하지 않는 배열로 다시 변환 될 수 있습니다 . 배열 에 &lt;code&gt;MethodError&lt;/code&gt; 이 포함 &lt;code&gt;missing&lt;/code&gt; 경우 변환 중에 MethodError 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41ac00a0bf9a5b610ef1696b9ce7b1bd86b26f82" translate="yes" xml:space="preserve">
          <source>An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;. For most computational purposes, arrays should contain objects of a more specific type, such as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열은 다차원 그리드에 저장된 개체의 모음입니다. 가장 일반적인 경우 배열에는 &lt;a href=&quot;../../base/base/index#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 유형의 객체가 포함될 수 있습니다 . 대부분의 계산 목적으로 배열에는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 와 같이보다 구체적인 유형의 객체가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fe522b01ac3a23b4adab253f39d747e24150892" translate="yes" xml:space="preserve">
          <source>An array of paths for &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements to consider as project environments or package directories when loading code. It is populated based on the &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt;&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt;&lt;/a&gt; environment variable if set; otherwise it defaults to &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. Entries starting with &lt;code&gt;@&lt;/code&gt; have special meanings:</source>
          <target state="translated">코드를로드 할 때 프로젝트 환경 또는 패키지 디렉토리로 간주 할 명령문을 &lt;code&gt;using&lt;/code&gt; 하고 &lt;code&gt;import&lt;/code&gt; 위한 경로 배열입니다 . 설정된 경우 &lt;a href=&quot;../../manual/environment-variables/index#JULIA_LOAD_PATH-1&quot;&gt; &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; &lt;/a&gt; 환경 변수를 기반으로 채워집니다 . 그렇지 않으면 기본값은 &lt;code&gt;[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; 입니다. &lt;code&gt;@&lt;/code&gt; 로 시작하는 항목 에는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcaca5094f1a9b10cd4725d7c73753c4f7c3e54" translate="yes" xml:space="preserve">
          <source>An array of scalar indices. This includes:</source>
          <target state="translated">스칼라 인덱스의 배열입니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81e3e729218c7a16f9993c281c977ad17183e8f6" translate="yes" xml:space="preserve">
          <source>An array of the command line arguments passed to Julia, as strings.</source>
          <target state="translated">줄에 줄로 전달 된 명령 행 인수의 배열.</target>
        </trans-unit>
        <trans-unit id="a0af30d315d1e58152feb3e6efd0b431012c6b41" translate="yes" xml:space="preserve">
          <source>An array with a specific element type can be constructed using the syntax &lt;code&gt;T[A, B, C, ...]&lt;/code&gt;. This will construct a 1-d array with element type &lt;code&gt;T&lt;/code&gt;, initialized to contain elements &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, etc. For example, &lt;code&gt;Any[x, y, z]&lt;/code&gt; constructs a heterogeneous array that can contain any values.</source>
          <target state="translated">구문 &lt;code&gt;T[A, B, C, ...]&lt;/code&gt; 구문을 사용하여 특정 요소 유형의 배열을 구성 할 수 있습니다 . 이렇게하면 요소 유형 &lt;code&gt;T&lt;/code&gt; 로 1-d 배열을 구성 하고 요소 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 등 을 포함하도록 초기화됩니다 . 예를 들어 &lt;code&gt;Any[x, y, z]&lt;/code&gt; 는 모든 값을 포함 할 수있는 이기종 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d49e95020e020a9b4ba7b0d2bd91635b96ade391" translate="yes" xml:space="preserve">
          <source>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</source>
          <target state="translated">다양한 최적화 수준에서 어설 션이 비활성화 될 수 있습니다. 따라서 Assert는 디버깅 도구로만 사용해야하며 인증 확인 (예 : 암호 확인)에 사용해서는 안되며, 기능이 제대로 작동하는 데 필요한 부작용을 Assert 내부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="71e89ce9e3702ca0f3496a7358d3f83d3e141bca" translate="yes" xml:space="preserve">
          <source>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</source>
          <target state="translated">함수, 유형 또는 매크로 정의에 사용 된 변수를 소개하는 할당은 내부 사용 전에 오지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d60802623cdaa53cdbcd142bd02b31e05d1a86f4" translate="yes" xml:space="preserve">
          <source>An easy way to find out is to extract the body into another (regular) function:</source>
          <target state="translated">쉽게 찾을 수있는 방법은 신체를 다른 (일반) 기능으로 추출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="75ba7cfd59f985e2f5eac9d9bfbe0747c5db6475" translate="yes" xml:space="preserve">
          <source>An environment's graph is a multilevel map which assigns, for each &lt;code&gt;context&lt;/code&gt; UUID, a map from names to UUIDs, similar to the roots map but specific to that &lt;code&gt;context&lt;/code&gt;. When Julia sees &lt;code&gt;import X&lt;/code&gt; in the code of the package whose UUID is &lt;code&gt;context&lt;/code&gt;, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;graph[context][:X]&lt;/code&gt;. In particular, this means that &lt;code&gt;import X&lt;/code&gt; can refer to different packages depending on &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">환경 그래프는 각 &lt;code&gt;context&lt;/code&gt; UUID에 대해 루트 맵과 유사하지만 해당 &lt;code&gt;context&lt;/code&gt; 고유 한 이름에서 UUID로 맵을 할당하는 다중 레벨 맵입니다 . 줄리아 볼 때 &lt;code&gt;import X&lt;/code&gt; UUID입니다 패키지의 코드에서 &lt;code&gt;context&lt;/code&gt; , 그것은의 신원 조회 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;graph[context][:X]&lt;/code&gt; . 특히 이것은 &lt;code&gt;import X&lt;/code&gt; 가 &lt;code&gt;context&lt;/code&gt; 에 따라 다른 패키지를 참조 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4e064b0051e803a86c003daf19461cf607e832da" translate="yes" xml:space="preserve">
          <source>An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in &lt;code&gt;Main&lt;/code&gt;). When Julia encounters &lt;code&gt;import X&lt;/code&gt; in the main project, it looks up the identity of &lt;code&gt;X&lt;/code&gt; as &lt;code&gt;roots[:X]&lt;/code&gt;.</source>
          <target state="translated">환경의 루트 맵은 환경이 주 프로젝트에 사용할 수있는 모든 최상위 종속성 (예 : &lt;code&gt;Main&lt;/code&gt; 에 로드 할 수있는 것)에 대해 패키지 이름을 UUID에 지정합니다 . 줄리아가 발생하면 &lt;code&gt;import X&lt;/code&gt; 주요 프로젝트, 그것의 신원 조회 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;roots[:X]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a6b075a0dfee676c2586ba796e8721ea7d846f5" translate="yes" xml:space="preserve">
          <source>An error occurred when running a module's &lt;code&gt;__init__&lt;/code&gt; function. The actual error thrown is available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">모듈의 &lt;code&gt;__init__&lt;/code&gt; 함수를 실행할 때 오류가 발생했습니다 . 발생한 실제 오류는 &lt;code&gt;.error&lt;/code&gt; 필드 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f872e576e1623149d829361d58e2cd908722e2d7" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to access &lt;code&gt;str&lt;/code&gt; at index &lt;code&gt;i&lt;/code&gt; that is not valid.</source>
          <target state="translated">인덱스 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;str&lt;/code&gt; 에 액세스 하는 중에 유효하지 않은 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="f33bd5b60514925c67cf1bcd27c0b818d1eaa51d" translate="yes" xml:space="preserve">
          <source>An error occurred while &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;ing, &lt;a href=&quot;#Base.require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;ing, or &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; a file. The error specifics should be available in the &lt;code&gt;.error&lt;/code&gt; field.</source>
          <target state="translated">파일 &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; 중에 오류가 발생했습니다 . 오류 세부 사항은 &lt;code&gt;.error&lt;/code&gt; 필드 에서 사용 가능해야 합니다.</target>
        </trans-unit>
        <trans-unit id="07364c5431123506298c1f1b97819a8211a7dee0" translate="yes" xml:space="preserve">
          <source>An example of correct usage of &lt;code&gt;Val&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 을 올바르게 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c493074be2f87d14f247d6f580604d1e79d5ee3a" translate="yes" xml:space="preserve">
          <source>An exception is raised if a global constant is requested to be cleared.</source>
          <target state="translated">전역 상수를 지우도록 요청하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74b831638ce2bece413802b1ce5999bdb817b935" translate="yes" xml:space="preserve">
          <source>An explicit &lt;code&gt;global&lt;/code&gt; is needed to assign to a global variable:</source>
          <target state="translated">전역 변수에 할당하려면 명시 적 &lt;code&gt;global&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fa929fb7568ac9e14759cbe89ba07ba8ca4d3c90" translate="yes" xml:space="preserve">
          <source>An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.</source>
          <target state="translated">이러한 방식으로 래핑 된 표현식은 매크로 확장기에 의해 단독으로 남겨져 단순히 출력 그대로 그대로 붙여 넣어집니다. 따라서 매크로 호출 환경에서 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8ce9f561ef25fa8ebcdf84d21250bf4af4d01b" translate="yes" xml:space="preserve">
          <source>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</source>
          <target state="translated">불변 객체에는 배열과 같은 가변 객체가 필드로 포함될 수 있습니다. 포함 된 객체는 변경 가능합니다. 불변 객체 자체의 필드 만 다른 객체를 가리 키도록 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6b2f30177c22471afdf680fdefbc947052099b3" translate="yes" xml:space="preserve">
          <source>An implementation of an &lt;code&gt;AbstractWorkerPool&lt;/code&gt;. &lt;a href=&quot;#Distributed.remote&quot;&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall_fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).</source>
          <target state="translated">&lt;code&gt;AbstractWorkerPool&lt;/code&gt; 의 구현입니다 . &lt;a href=&quot;#Distributed.remote&quot;&gt; &lt;code&gt;remote&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.remotecall_fetch-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall_fetch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; (및 원격으로 함수를 실행하는 다른 원격 호출)은 작업자 노드에서 직렬화 / 직렬화되지 않은 함수, 특히 클로저 (대량의 데이터를 캡처 할 수 있음)를 캐싱하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b306a470a7687a028d866f374bb4a4513c3bca" translate="yes" xml:space="preserve">
          <source>An implementation of distributed memory parallel computing is provided by module &lt;code&gt;Distributed&lt;/code&gt; as part of the standard library shipped with Julia.</source>
          <target state="translated">분산 메모리 병렬 컴퓨팅의 구현은 Julia와 함께 제공되는 표준 라이브러리의 일부로 &lt;code&gt;Distributed&lt;/code&gt; 모듈에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d783ac603cd4b08c0d7cd2a76549bc1da1d2e64a" translate="yes" xml:space="preserve">
          <source>An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types &amp;ndash; one for each possible combination of parameter values. There are many languages that support some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won't even attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</source>
          <target state="translated">Julia 유형 시스템의 중요하고 강력한 기능은 매개 변수라는 점입니다. 유형은 매개 변수를 사용할 수 있으므로 유형 선언은 실제로 가능한 모든 매개 변수 값 조합마다 하나씩 새로운 유형의 전체 계열을 도입합니다. 일부 &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;일반 프로그래밍&lt;/a&gt; 버전을 지원하는 많은 언어가 있습니다.여기서,이를 조작하기위한 데이터 구조 및 알고리즘은 관련된 정확한 유형을 지정하지 않고 특정 될 수있다. 예를 들어 ML, Haskell, Ada, Eiffel, C ++, Java, C #, F # 및 Scala에는 일반적인 프로그래밍 형태가 있습니다. 이러한 언어 중 일부는 진정한 파라 메트릭 다형성 (예 : ML, Haskell, Scala)을 지원하는 반면 다른 언어는 임시 템플릿 기반의 일반 프로그래밍 스타일 (예 : C ++, Java)을 지원합니다. 다양한 언어로 된 다양한 종류의 제네릭 프로그래밍 및 파라 메트릭 유형으로 인해 Julia의 파라 메트릭 유형을 다른 언어와 비교하려고 시도하지 않고 대신 Julia의 시스템 자체를 설명하는 데 중점을 둘 것입니다. 그러나 Julia는 동적으로 유형이 지정된 언어이므로 컴파일 타임에 모든 유형을 결정할 필요가 없으므로,정적 파라 메트릭 유형 시스템에서 발생하는 많은 전통적인 어려움은 비교적 쉽게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a620af1ece25f934c185b8ddc35721eeb3f3fac2" translate="yes" xml:space="preserve">
          <source>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;.)</source>
          <target state="translated">주목해야 할 중요한 점은 프로그래머가 인수가 추상 유형 인 함수에 의존하는 경우 성능이 손실되지 않는다는 것입니다. 호출되는 인수 콘크리트 유형의 각 튜플에 대해 다시 컴파일되기 때문입니다. 그러나 추상 유형의 컨테이너 인 함수 인수의 경우 성능 문제가있을 수 있습니다 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8a07f992d12e5a1cbc667f425042e464cb426b62" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that, once fetched, a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; will cache its value locally. Further &lt;code&gt;fetch&lt;/code&gt; calls do not entail a network hop. Once all referencing &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s have fetched, the remote stored value is deleted.</source>
          <target state="translated">기억해야 할 중요한 점은 일단 가져온 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 는 해당 값을 로컬로 캐시 한다는 것입니다. 추가 &lt;code&gt;fetch&lt;/code&gt; 호출에는 네트워크 홉이 필요하지 않습니다. 모든 참조 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 페치되면 원격 저장된 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9125cf95c1847e0bf4f4e8c480c3ff78274eac" translate="yes" xml:space="preserve">
          <source>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</source>
          <target state="translated">추상 유형의 중요한 사용은 구체적 유형에 대한 기본 구현을 제공하는 것입니다. 간단한 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="46c08a285690627fd53df02bea8440f31cc7ca2d" translate="yes" xml:space="preserve">
          <source>An indexing operation into an &lt;code&gt;AbstractDict&lt;/code&gt; (&lt;code&gt;Dict&lt;/code&gt;) or &lt;code&gt;Set&lt;/code&gt; like object tried to access or delete a non-existent element.</source>
          <target state="translated">&lt;code&gt;AbstractDict&lt;/code&gt; ( &lt;code&gt;Dict&lt;/code&gt; ) 또는 &lt;code&gt;Set&lt;/code&gt; like 객체에 대한 인덱싱 작업 이 존재하지 않는 요소에 액세스하거나 삭제하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="c0ef57c4e27de9e0e08cd005dba316af8fe9863a" translate="yes" xml:space="preserve">
          <source>An indexing operation into an array, &lt;code&gt;a&lt;/code&gt;, tried to access an out-of-bounds element at index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 에 대한 인덱싱 작업이 인덱스 &lt;code&gt;i&lt;/code&gt; 의 범위를 벗어난 요소에 액세스하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba7dc87158f89283a983f53bb3f993c869462761" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Float64}&lt;/code&gt; can be represented compactly and efficiently as an immediate pair of 64-bit values;</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; 의 인스턴스는 64 비트 값의 즉각적인 쌍으로 작고 효율적으로 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81188cb690cdf51aa857fee109d4a9ecc33db0cb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be able to hold any pair of instances of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;. Since objects that are instances of &lt;code&gt;Real&lt;/code&gt; can be of arbitrary size and structure, in practice an instance of &lt;code&gt;Point{Real}&lt;/code&gt; must be represented as a pair of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects.</source>
          <target state="translated">의 인스턴스 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스 쌍 보유 할 수 있어야 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Real&lt;/code&gt; 의 인스턴스 인 객체 는 임의의 크기와 구조를 가질 수 있으므로 실제로 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스는 개별적으로 할당 된 &lt;code&gt;Real&lt;/code&gt; 객체 에 대한 포인터 쌍으로 표시되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d49ef831f7376a07158e43b82f759fbd73bc08a0" translate="yes" xml:space="preserve">
          <source>An issue that arises in more complex macros is that of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;hygiene&lt;/a&gt;. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often &lt;em&gt;expected&lt;/em&gt; to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as &lt;code&gt;msg&lt;/code&gt; in &lt;code&gt;@assert&lt;/code&gt; above) follow the &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;normal scoping block behavior&lt;/a&gt;.</source>
          <target state="translated">보다 복잡한 매크로에서 발생하는 문제는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hygienic_macro&quot;&gt;위생 문제&lt;/a&gt; 입니다. 간단히 말해서, 매크로는 반환 된 표현식에 도입 된 변수가 확장 된 주변 코드의 기존 변수와 실수로 충돌하지 않도록해야합니다. 반대로, 매크로로 인수로 전달되는 표현식은 종종 &lt;em&gt;예상됩니다.&lt;/em&gt;주변 코드의 맥락에서 평가하고 기존 변수와 상호 작용하고 수정합니다. 매크로가 정의 된 것과 다른 모듈에서 매크로가 호출 될 수 있다는 사실에서 또 다른 우려가 발생합니다. 이 경우 모든 전역 변수가 올바른 모듈로 해석되도록해야합니다. Julia는 이미 텍스트 매크로 확장 (예 : C)이있는 언어에 비해 반환 된 표현식 만 고려하면되기 때문에 큰 이점을 가지고 있습니다. (같은 모든 다른 변수 &lt;code&gt;msg&lt;/code&gt; 에 &lt;code&gt;@assert&lt;/code&gt; 위)를 따라 &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;정상적인 범위 지정 블록 동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5758b288cd7216deea6832521aad4c2142aa23b0" translate="yes" xml:space="preserve">
          <source>An iterator that accesses each element of the array &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;i =&amp;gt; x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index for the element and &lt;code&gt;x = A[i]&lt;/code&gt;. Identical to &lt;code&gt;pairs(A)&lt;/code&gt;, except that the style of index can be selected. Also similar to &lt;code&gt;enumerate(A)&lt;/code&gt;, except &lt;code&gt;i&lt;/code&gt; will be a valid index for &lt;code&gt;A&lt;/code&gt;, while &lt;code&gt;enumerate&lt;/code&gt; always counts from 1 regardless of the indices of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소에 액세스하여 &lt;code&gt;i =&amp;gt; x&lt;/code&gt; 반환 하는 반복자입니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 요소의 인덱스이고 &lt;code&gt;x = A[i]&lt;/code&gt; 입니다. 동일한 &lt;code&gt;pairs(A)&lt;/code&gt; , 인덱스의 스타일이 선택 될 수 있다는 점을 제외. 또한 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 의 유효한 색인이 된다는 점을 제외하고 &lt;code&gt;enumerate(A)&lt;/code&gt; 와 유사 하지만 &lt;code&gt;enumerate&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 인덱스에 관계없이 항상 1부터 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7a506ba2a82dcb065490fadb0cc0de3162d7501" translate="yes" xml:space="preserve">
          <source>An iterator that counts forever, starting at &lt;code&gt;start&lt;/code&gt; and incrementing by &lt;code&gt;step&lt;/code&gt;.</source>
          <target state="translated">반복자 그 계산 영원히부터 &lt;code&gt;start&lt;/code&gt; 에 의해 증가 &lt;code&gt;step&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48922b72538924c877a99f16d2a1501116dd1387" translate="yes" xml:space="preserve">
          <source>An iterator that cycles through &lt;code&gt;iter&lt;/code&gt; forever. If &lt;code&gt;iter&lt;/code&gt; is empty, so is &lt;code&gt;cycle(iter)&lt;/code&gt;.</source>
          <target state="translated">를 통해 반복자는 사이클 &lt;code&gt;iter&lt;/code&gt; 영원히. &lt;code&gt;iter&lt;/code&gt; 가 비어 있으면 &lt;code&gt;cycle(iter)&lt;/code&gt; 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="2529486fdd6052d642060ef494ef6207d50e0319" translate="yes" xml:space="preserve">
          <source>An iterator that generates all but the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 첫 &lt;code&gt;n&lt;/code&gt; 개 요소를 제외한 모든 요소 를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="225cd1fc20e6b5e9157d6660f2d5a16cf5eaa208" translate="yes" xml:space="preserve">
          <source>An iterator that generates at most the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 첫 &lt;code&gt;n&lt;/code&gt; 개 이하 요소 를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="0e73058facca13f8b20620aa03238c21f3f77bff" translate="yes" xml:space="preserve">
          <source>An iterator that generates the value &lt;code&gt;x&lt;/code&gt; forever. If &lt;code&gt;n&lt;/code&gt; is specified, generates &lt;code&gt;x&lt;/code&gt; that many times (equivalent to &lt;code&gt;take(repeated(x), n)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값을 영원히 생성하는 반복자입니다 . 경우 &lt;code&gt;n&lt;/code&gt; 을 지정 생성 &lt;code&gt;x&lt;/code&gt; (상응하는 횟수를 그 &lt;code&gt;take(repeated(x), n)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e9bbba550395bdb9417724cabe5c648e9c151a" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;(i, x)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is a counter starting at 1, and &lt;code&gt;x&lt;/code&gt; is the &lt;code&gt;i&lt;/code&gt;th value from the given iterator. It's useful when you need not only the values &lt;code&gt;x&lt;/code&gt; over which you are iterating, but also the number of iterations so far. Note that &lt;code&gt;i&lt;/code&gt; may not be valid for indexing &lt;code&gt;iter&lt;/code&gt;; it's also possible that &lt;code&gt;x != iter[i]&lt;/code&gt;, if &lt;code&gt;iter&lt;/code&gt; has indices that do not start at 1. See the &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; method if you want to ensure that &lt;code&gt;i&lt;/code&gt; is an index.</source>
          <target state="translated">&lt;code&gt;(i, x)&lt;/code&gt; 를 산출하는 반복자. 여기서 &lt;code&gt;i&lt;/code&gt; 는 1에서 시작하는 카운터이고, &lt;code&gt;x&lt;/code&gt; 는 주어진 반복자 의 &lt;code&gt;i&lt;/code&gt; 번째 값입니다. 반복 하는 값 &lt;code&gt;x&lt;/code&gt; 뿐만 아니라 지금까지 반복 횟수 가 필요할 때 유용합니다 . 참고 &lt;code&gt;i&lt;/code&gt; 색인에 대한 유효하지 않을 수 있습니다 &lt;code&gt;iter&lt;/code&gt; ; 그것은 수도 있습니다 그 &lt;code&gt;x != iter[i]&lt;/code&gt; , 경우 &lt;code&gt;iter&lt;/code&gt; 1 참조에서 시작하지 않는 인덱스가 &lt;code&gt;pairs(IndexLinear(), iter)&lt;/code&gt; 이 있는지 확인하려면 방법 &lt;code&gt;i&lt;/code&gt; 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="266c36edd3f7797ff58b1ca95649bcf6b5c4372b" translate="yes" xml:space="preserve">
          <source>An iterator that yields the same elements as &lt;code&gt;iter&lt;/code&gt;, but starting at the given &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 와 동일한 요소를 가져 오지만 주어진 &lt;code&gt;state&lt;/code&gt; 에서 시작 하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="5702ee8b32ef9343efe014a1fb61b5e64e3eeb50" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt;, representing an identity matrix of any size.</source>
          <target state="translated">모든 크기의 단위 행렬을 나타내는 &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="71c4c33f82250491a99ad21209540c93bfa32676" translate="yes" xml:space="preserve">
          <source>An object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;. By default this includes:</source>
          <target state="translated">스칼라 인덱스 배열을 나타내는 객체이며 &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; 에&lt;/a&gt; 의해 그러한 객체로 변환 될 수 있습니다 . 기본적으로 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b6750cc125525c2ec2f6b1301138ae1f12a25d" translate="yes" xml:space="preserve">
          <source>An object that safely references data of type &lt;code&gt;T&lt;/code&gt;. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the &lt;code&gt;Ref&lt;/code&gt; itself is referenced.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 데이터를 안전하게 참조하는 객체입니다 . 이 유형은 올바른 유형의 Julia 할당 메모리를 가리 킵니다. &lt;code&gt;Ref&lt;/code&gt; 자체가 참조 되는 한 기본 데이터는 가비지 수집기에서 해제되지 않도록 보호됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e56b05f03b0a54be4311a52e3844ad08220010" translate="yes" xml:space="preserve">
          <source>An object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.</source>
          <target state="translated">불변 유형의 객체는 불변성으로 인해 프로그래밍 방식으로 원본 객체와 사본을 구분할 수 없으므로 컴파일러가 자유롭게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85eb57c0af1152d6c55f74e29c04701d2792e006" translate="yes" xml:space="preserve">
          <source>An operation allocated too much memory for either the system or the garbage collector to handle properly.</source>
          <target state="translated">조작이 시스템 또는 가비지 콜렉터가 올바르게 처리하기에 너무 많은 메모리를 할당했습니다.</target>
        </trans-unit>
        <trans-unit id="51b16b4dd3a608065010ab050f1c044d587e4984" translate="yes" xml:space="preserve">
          <source>An operation tried to write to memory that is read-only.</source>
          <target state="translated">작업이 읽기 전용 인 메모리에 쓰려고했습니다.</target>
        </trans-unit>
        <trans-unit id="0cdeff47b1133140cdc39aa6281a4193e4a3fd25" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-matrix operations is available</source>
          <target state="translated">매트릭스 매트릭스 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f3dca7e150e49f15f11e7561b432ec79e089bf1" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-scalar operations is available</source>
          <target state="translated">행렬 스칼라 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="061f7a534d622ec7d7b76381cb35a581642e8473" translate="yes" xml:space="preserve">
          <source>An optimized method for matrix-vector operations is available</source>
          <target state="translated">행렬-벡터 연산에 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1459d918f4690c46e6b424c4fc07b16a81bb1321" translate="yes" xml:space="preserve">
          <source>An optimized method to find all the characteristic values and/or vectors is available</source>
          <target state="translated">모든 특성 값 및 / 또는 벡터를 찾는 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cf356b7797f09dd430255cabba22e6b669b5778d" translate="yes" xml:space="preserve">
          <source>An optimized method to find the &lt;code&gt;il&lt;/code&gt;th through the &lt;code&gt;ih&lt;/code&gt;th characteristic values are available</source>
          <target state="translated">최적화 된 방법은 찾아 &lt;code&gt;il&lt;/code&gt; 관통 번째 &lt;code&gt;ih&lt;/code&gt; 특성치가 가능한 토륨</target>
        </trans-unit>
        <trans-unit id="55662dcd806465abd15ea9ee92465cc49d4f4bb3" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic values in the interval [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vh&lt;/code&gt;] is available</source>
          <target state="translated">구간 [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vh&lt;/code&gt; ] 에서 특성 값을 찾는 최적화 된 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="06771105d28cfe0fe650b94de200ff6d276e071c" translate="yes" xml:space="preserve">
          <source>An optimized method to find the characteristic vectors corresponding to the characteristic values &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; is available</source>
          <target state="translated">특성 값 &lt;code&gt;x=[x1, x2,...]&lt;/code&gt; 해당하는 특성 벡터를 찾는 최적화 된 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a93e7d7160ec681ea6d7e4c04a7926b5ad27e7" translate="yes" xml:space="preserve">
          <source>An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.</source>
          <target state="translated">정렬 된 목록은 위의 예의 두 번째 목록에서와 같이 1이 아닌 다른 숫자에서 시작하여 5부터 번호가 매겨 질 수 있습니다. 정렬되지 않은 목록과 마찬가지로 정렬 된 목록에는 중첩 된 최상위 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ca662d4f2c4b45816c66be6d31e3cf1480577f" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) that sets the maximum number of threads available to Julia. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Julia가 사용할 수있는 최대 스레드 수를 설정 하는 부호없는 64 비트 정수 ( &lt;code&gt;uint64_t&lt;/code&gt; )입니다. 경우 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 가능한 물리적 CPU 코어의 수를 초과 한 후 스레드의 수는 코어 수로 설정됩니다. 경우 &lt;code&gt;$JULIA_NUM_THREADS&lt;/code&gt; 긍정적 없거나 설정되지 않았거나 CPU 코어의 수는 시스템 호출을 통해 판단 할 수없는 경우, 다음 스레드 수로 설정됩니다 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d32b092601fd9ebd2ac1ea5cb15d47455e3d9c4d" translate="yes" xml:space="preserve">
          <source>An updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.</source>
          <target state="translated">업데이트 연산자는 변수를 왼쪽에 리 바인드합니다. 결과적으로 변수 유형이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8c77e7404ca30dcccf92c73c985f04a86420e7" translate="yes" xml:space="preserve">
          <source>Anchor</source>
          <target state="translated">Anchor</target>
        </trans-unit>
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">그리고 도트</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">그리고 그 테스트 세트를 사용하는 것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">분노 기호</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">안쪽으로 S를 가진 각</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">언더 바 각도</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">화난 얼굴</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">옹스트롬 부호 / 옹스트롬 단위</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">고뇌 된 얼굴</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프에 주석을 달아서 컴파일러가 루프를 다시 정렬 할 수 있도록 추가 자유를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">형식화되지 않은 위치에서 가져온 값에 주석 달기</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;blk&lt;/code&gt; 표현식을 경계 검사 블록으로 주석 처리하여 &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; 에&lt;/a&gt; 의해 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">또 다른 일반적인 솔루션은 파이프 라인의 리더와 라이터를 별도의 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 으로 분리하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">다른 경우에는 다른 도우미 유형 인 &lt;code&gt;Random.SamplerTag&lt;/code&gt; 가 현재 사용 가능 하지만 내부 API로 간주되며 적절한 지원 중단없이 언제든지 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">또 다른 비 - 표준 버전 사양을 확장 한 뒤에를 사용할 수 있습니다 &lt;code&gt;+&lt;/code&gt; 빌드 버전에 대한 상한을 표현하기 위해, 예를 들어 &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; 위의 모든 버전을 의미 할 수 있습니다 &lt;code&gt;0.2-rc1&lt;/code&gt; 과 그 중 하나를 빌드 : 그것은 반환 &lt;code&gt;false&lt;/code&gt; 버전에 대한 &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; 와 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">어떤 유형에 적용하는 또 다른 작업은 &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; 타입의 슈퍼 타입을 보여준다. 선언 된 유형 ( &lt;code&gt;DataType&lt;/code&gt; ) 에만 명확한 수퍼 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">또 다른 가능성은 다음과 같으며, 이는 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 보다 좁게 일치시켜야하는 경우에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">또 다른 유용한 비표준 문자열 리터럴은 바이트 배열 문자열 리터럴입니다 ( &lt;code&gt;b&quot;...&quot;&lt;/code&gt; . 이 형식을 사용하면 문자열 표기법을 사용하여 읽기 전용 리터럴 바이트 배열, 즉 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 값의 배열을 표현할 수 있습니다. 해당 오브젝트의 유형은 &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; 입니다. 바이트 배열 리터럴의 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">희소 배열을 만드는 또 다른 방법은 &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 밀도가 높은 배열을 희소 배열로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">뷰 표현하는 또 다른 방법은 함께 &lt;code&gt;Meta.show_sexpr&lt;/code&gt; 디스플레이, &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-표현&lt;/a&gt; 주어진 형태 &lt;code&gt;Expr&lt;/code&gt; 리스프의 사용자에게 매우 친숙한 보일 수 있습니다. 다음은 중첩 된 &lt;code&gt;Expr&lt;/code&gt; 의 표시를 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">Julia v0.6에서 삼각형 디스패치가 출현하기 전에 유일하게 올바른 방법이었던 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">바 안테나</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">반 시계 방향 컨투어 일체형</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">반 시계 방향 및 위쪽으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">반 시계 방향 통합</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">반 시계 방향으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">반 시계 방향 반원형 화살표</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">배열 값을 변경하면 (예 : &lt;code&gt;A[3] = 0&lt;/code&gt; ) 디스크의 값도 변경됩니다</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">성능이 중요하거나 벤치마킹되는 모든 코드는 함수 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형 인 스칼라 인덱스의 사용자 정의 배열</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">모든 사용자 정의 테스트 세트 유형 ( &lt;code&gt;AbstractTestSet&lt;/code&gt; 의 하위 유형 )을 제공 할 수 있으며 중첩 된 &lt;code&gt;@testset&lt;/code&gt; 호출 에도 사용 됩니다. 주어진 옵션은 테스트 세트에만 적용됩니다. 기본 테스트 세트 유형에는 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">모든 오류는 &lt;code&gt;pmap&lt;/code&gt; 이 나머지 콜렉션을 처리하지 못하게합니다. 이 동작을 무시하려면 단일 인수 (예 : 예외)를 &lt;code&gt;on_error&lt;/code&gt; 인수를 통해 오류 처리 기능을 지정할 수 있습니다 . 이 함수는 오류를 다시 발생시켜 처리를 중지하거나 계속하려면 결과와 함께 호출자에게 반환되는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에 의해 발생 된 예외 는 원격 작업자의 &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;eigen&lt;/code&gt; 에 전달 된 모든 키워드 인수 는 하위 수준 &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt; 전달됩니다 ! 함수.</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">이런 식으로 많은 표현이 함께 문서화됩니다. 이 구문은 비 변형 버전과 변이 버전 &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;f!&lt;/code&gt; 와 같은 두 가지 기능이 관련된 경우에 유용합니다 ! .</target>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">이 함수를 정의하는 모든 객체는 반복 가능 &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;하며 반복에 의존&lt;/a&gt; 하는 많은 함수 에서 사용될 수 있습니다 . 구문 때문에 &lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프 에서 직접 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">유형이 아닌 모든 객체는 &lt;code&gt;Type&lt;/code&gt; 인스턴스가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">오류를 발생시키는 모든 작업은 현재 구현되지 않았으며 해결 될 수 있도록 버그로 게시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 을&lt;/a&gt; 참조하는 모든 프로세스 는 채널에서 항목을 넣고 가져올 수 있습니다. 데이터는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 과 연관된 프로세스로 자동 전송되거나 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Apl 기능 기호 백 슬래시 바</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl 기능성 심볼 서클 스타일</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Apl 기능성 기호 I- 빔</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Apl 기능 기호 쿼드 질문</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl 기능 기호 쿼드 업 캐럿</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl 기능 기호 슬래시 바</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">추가 &lt;code&gt;!&lt;/code&gt; 인수를 수정하는 함수 이름</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">채널 &lt;code&gt;c&lt;/code&gt; 에 항목 &lt;code&gt;v&lt;/code&gt; 를 추가하십시오 . 채널이 가득 찬 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">함수 인수 이름에 적용되면 메소드가 해당 인수의 다른 유형에 특화된 것이 아니라 각 인수에 대해 선언 된 유형을 정확하게 사용해야한다는 것을 컴파일러에 알립니다. 이것은 과도한 코드 생성을 피하기위한 힌트 일뿐입니다. 형식 인수 목록 또는 함수 본문의 인수에 적용 할 수 있습니다. 인수에 적용될 때 매크로는 전체 인수 표현식을 랩핑해야합니다. 함수 본문에서 사용될 때 매크로는 명령문 위치에서 코드 앞에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">함수 또는 매크로 호출에 적용되면 지정된 호출에 대한 인수를 평가하고 해당 인수에 대해 호출 될 메소드의 위치를 ​​제공 하는 튜플 &lt;code&gt;(filename,line)&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;functionloc&lt;/code&gt; 함수 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">함수 또는 매크로 호출에 적용되면 지정된 호출에 대한 인수를 평가하고 해당 인수에 대해 호출 될 메소드 의 &lt;code&gt;Method&lt;/code&gt; 오브젝트를 리턴합니다 . 변수에 적용되면 변수가 바인딩 된 모듈을 반환합니다. &lt;code&gt;which&lt;/code&gt; 함수 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">앞의 인수에 함수를 적용합니다. 이는 쉬운 기능 체인을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; 의 각 요소에 함수 &lt;code&gt;f&lt;/code&gt; 를 적용한 다음 이진 함수 &lt;code&gt;op&lt;/code&gt; 를 사용하여 결과를 줄 입니다. 제공된 경우 &lt;code&gt;init&lt;/code&gt; 는 빈 컬렉션에 대해 반환 될 &lt;code&gt;op&lt;/code&gt; 의 중립 요소 여야합니다 . 비어 있지 않은 컬렉션에 &lt;code&gt;init&lt;/code&gt; 를 사용 할지 여부는 지정되지 않았습니다 . 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 git 저장소 &lt;code&gt;repo&lt;/code&gt; 에 적용하고 &lt;code&gt;f&lt;/code&gt; 를 적용하기 전에 &lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt; 을 작성하십시오 . &lt;code&gt;f&lt;/code&gt; 내에서 오류가 발생하면 , &lt;code&gt;repo&lt;/code&gt; 는 &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; 를&lt;/a&gt; 사용하여 스냅 샷 상태로 돌아갑니다 . 발생한 오류는 다시 발생하지만 &lt;code&gt;repo&lt;/code&gt; 상태는 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">함수 적용 &lt;code&gt;f&lt;/code&gt; 집합의 각 요소에 &lt;code&gt;itr&lt;/code&gt; , 평균 걸릴.</target>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; &lt;/a&gt; 결과에 적용하고 완료시 임시 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt; 결과에 적용하고 완료시 임시 디렉토리의 모든 내용을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; 의 결과에 적용하고 완료되면 결과 파일 디스크립터를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다른 유형의 인수에 적용하면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">한계에 접근</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">주어진 정수 유형의 구성 요소를 갖는 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 로서의 대략적인 부동 소수점 수 &lt;code&gt;x&lt;/code&gt; 결과는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;tol&lt;/code&gt; 만큼 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">대략 동일하지는 않지만</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">대략 같거나 같음</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">대략 동일</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">대략 같거나 이미지</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">임의 정밀 산술</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">임의의 정밀도 부동 소수점 숫자 유형.</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">임의 정밀도 정수 유형.</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">인수 &lt;code&gt;waitfor&lt;/code&gt; 노동자가 종료 때까지 기다려야하는 시간을 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">인수 전달 동작</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">인수 파괴</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">LLVM 백엔드로 전달 될 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Julia 의 &lt;code&gt;Ptr&lt;/code&gt; 유형 에 대한 산술 (예 : &lt;code&gt;+&lt;/code&gt; )은 C의 포인터 산술과 동일하게 동작하지 않습니다. Julia 에서 &lt;code&gt;Ptr&lt;/code&gt; 에 정수를 추가하면 요소가 아닌 항상 &lt;em&gt;바이트&lt;/em&gt; 수만큼 포인터가 이동합니다 . 이런 식으로 포인터 산술에서 얻은 주소 값은 포인터의 요소 유형에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">희소 행렬에 대한 산술 연산은 밀도가 높은 행렬에서와 마찬가지로 작동합니다. 희소 행렬의 인덱싱, 할당 및 연결은 밀도가 높은 행렬과 동일한 방식으로 작동합니다. 인덱싱 작업, 특히 할당은 한 번에 한 요소를 수행 할 때 비용이 많이 듭니다. 대부분의 경우 &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; 를&lt;/a&gt; 사용하여 희소 행렬을 &lt;code&gt;(I,J,V)&lt;/code&gt; 형식 으로 변환하고 , 치밀한 벡터 &lt;code&gt;(I,J,V)&lt;/code&gt; 의 값 또는 구조를 조작 한 다음 희소 행렬을 재구성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">배열 및 벡터화 된 연산자 및 함수</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">배열 함수</target>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">배열 특성</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">결 측값이있는 배열</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">결 측값을 허용하는 배열은 표준 구문으로 구성 할 수 있습니다. 사용 &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; 값 누락 가득 배열을 만들 수 :</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">배열은 연속적으로 메모리에 저장되어 캐싱으로 인해 CPU 벡터화 및 적은 메모리 액세스를 제공합니다. 이는 열-주요 순서로 배열에 액세스하는 것이 권장되는 것과 같은 이유입니다 (위 참조). 불규칙한 액세스 패턴과 비 연속적인보기는 비 순차적 메모리 액세스로 인해 어레이에서 계산 속도를 크게 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">다음 기능을 사용하여 배열을 구성하고 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">값의 임의 변환에 따라 배열을 쉽게 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">결 측값을 포함하는 배열은 다른 배열과 같이 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 배열 (자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 배열 도 지원됩니다. 이들은 각각 &lt;code&gt;N&lt;/code&gt; 차원에 걸쳐있는 스칼라 인덱스의 모음을 나타내며, 때때로 포인트 인덱싱이라고하는 인덱싱 형태를 가능하게합니다. 예를 들어, 위 의 &lt;code&gt;A&lt;/code&gt; 의 첫 번째 &quot;페이지&quot;에서 대각선 요소에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인덱스 에서 요소를 선택하는 부울 배열 (자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">매개 변수 배열은 &lt;code&gt;NTuple&lt;/code&gt; 로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">일반 데이터 형식의 배열은 동일한 동작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">알 수없는 크기의 배열 ( &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;[0]&lt;/code&gt; 에 의해 지정된 C99 호환 가변 길이 구조체 )은 직접 지원되지 않습니다. 이것들을 다루는 가장 좋은 방법은 바이트 오프셋을 직접 다루는 것입니다. 예를 들어, C 라이브러리가 올바른 문자열 유형을 선언하고 이에 대한 포인터를 리턴 한 경우 :</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">오른쪽을 가리키는 화살표</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">오른쪽을 가리키는 화살표</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">Arthur C. Clarke, &lt;em&gt;미래의 프로파일&lt;/em&gt; (1961) : Clarke의 세 번째 법칙.</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">굴절 식 트럭</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">아티스트 팔레트</target>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">로 &lt;code&gt;missing&lt;/code&gt; 정상 줄리아 개체입니다,이 전파 규칙은이 동작을 구현하도록 선택한 기능을 작동합니다. 이는 &lt;code&gt;Missing&lt;/code&gt; 유형의 인수에 대해 정의 된 특정 메소드를 통해 또는 단순히이 유형의 인수를 승인하고이를 전파하는 함수 (표준 연산자와 같은)에 전달하여 수행 할 수 있습니다. 패키지는 새로운 함수를 정의 할 때 결 측값을 전파하는 것이 적절한 지 여부를 고려해야하며, 그러한 경우에는 적절하게 방법을 정의해야합니다. 통과 &lt;code&gt;missing&lt;/code&gt; 형의 인수를 받아 아무런있어서 해당하는 함수 값을 &lt;code&gt;Missing&lt;/code&gt; 정의가 발생하지 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 를&lt;/a&gt; 다른 모든 타입처럼.</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 값은 ISO 8601 표준에 따라 표시 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 은 반올림에 사용 된 일 수 (및 밀리 초)를 시작하는 기준 (또는 &quot;반올림 에포크&quot;)으로 선택되었습니다. 계산. (이것은 Rata Die 표기법을 사용 하는 Julia의 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; s 의 내부 표현과 약간 다릅니다 . 그러나 ISO 8601 표준은 최종 사용자에게 가장 잘 보이기 때문에 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 이 반올림 에포크 대신에 선택되었습니다. &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; 내부적으로 혼동을 최소화하는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">보너스로 모든 기간 산술 객체는 범위와 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">완전하지만 간단한 예제로서 다음 은 표준 C 라이브러리에서 &lt;code&gt;clock&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">편의상 배열에서 &lt;code&gt;CartesianIndices&lt;/code&gt; 인덱스를 구성하면 다양한 인덱스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">일반적으로 기본 라이브러리는 적용 가능한 경우 함수에 다음 순서의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">좀 더 복잡한 예로, &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; 위에 구축 된 자체 장난감 N- 차원 희소 같은 배열 유형을 정의 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">보다 확장되고 복잡한 예로, 다음 &quot;커널&quot;을 병렬로 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">경험상, 단선 &lt;code&gt;show&lt;/code&gt; 메소드는 표시된 오브젝트를 작성하기 위해 유효한 Julia 표현식을 인쇄해야합니다. 이 &lt;code&gt;show&lt;/code&gt; 메소드 에 &lt;code&gt;Polar&lt;/code&gt; 에 대한 단일 행 &lt;code&gt;show&lt;/code&gt; 메소드 의 곱셈 연산자 ( &lt;code&gt;*&lt;/code&gt; ) 와 같은 접두어 연산자가 포함 된 경우 다른 오브젝트의 일부로 인쇄 될 때 올바르게 구문 분석되지 않을 수 있습니다. 이를 확인하려면 &lt;code&gt;Polar&lt;/code&gt; 유형 의 특정 인스턴스의 제곱을 취하는 표현식 객체 ( &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;프로그램 표현&lt;/a&gt; 참조 )를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로,에 정의 된 모든 이름이 &lt;code&gt;Main&lt;/code&gt; 명시 적에서 이름을 내보낼 관용적하지 않기 때문에, &quot;수출&quot;로 간주됩니다 &lt;code&gt;Main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">특별한 경우로, 함수는 익명 인 경우에만 실제로 복사 할 수 있으며, 그렇지 않은 경우 방금 복사됩니다. 차이점은 클로저 (즉, 숨겨진 내부 참조를 포함 할 수있는 함수)의 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Vector{UInt8}&lt;/code&gt; MIME 형식 의 &lt;code&gt;AbstractString&lt;/code&gt; 또는 Vector {UInt8} (2 진 MIME 형식) 인 경우 &lt;code&gt;repr&lt;/code&gt; 함수는 &lt;code&gt;x&lt;/code&gt; 가 이미 요청 된 &lt;code&gt;mime&lt;/code&gt; 형식 인 것으로 가정 하고 단순히 &lt;code&gt;x&lt;/code&gt; 를 반환합니다 . 이 특별한 경우는 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME 유형 에는 적용되지 않습니다 . 이는 원시 데이터를 &lt;code&gt;display(m::MIME, x)&lt;/code&gt; 로 전달할 수 있도록 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 구문의 특별한 부분으로, &lt;code&gt;end&lt;/code&gt; 키워드는 색인이 생성되는 가장 안쪽 배열의 크기에 의해 결정된대로 색인 괄호 안에있는 각 차원의 마지막 색인을 나타내는 데 사용될 수 있습니다. &lt;code&gt;end&lt;/code&gt; 키워드가 없는 인덱싱 구문 은 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 호출과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; 에서 이미 자세히 설명한 것처럼 Julia의 REPL은 효율적인 대화식 워크 플로우를 용이하게하는 풍부한 기능을 제공합니다. 다음은 명령 행에서의 경험을 향상시킬 수있는 몇 가지 팁입니다.</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">매우 간단한 경우에 대한 대안으로 &lt;code&gt;Vector{Any}&lt;/code&gt; 유형의 전역 컨테이너 를 만들고 필요한 경우 요소를 가져 오거나 포인터를 사용하여 포인터 당 하나의 전역 변수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">프로그램이 예상대로 작동하는지 확인하는 데 도움이되는 주장으로,</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">예를 들어 동일한 호스트에서 작업자를 시작하는 관리자 인 &lt;code&gt;LocalManager&lt;/code&gt; 가 어떻게 구현되는지 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">비 TCP / IP 전송의 예로, 구현시 MPI를 사용하도록 선택할 수 &lt;code&gt;--worker&lt;/code&gt; 경우 --worker 를 지정 하면 안됩니다. 대신, 새로 시작된 작업자는 병렬 구조를 사용하기 전에 &lt;code&gt;init_worker(cookie)&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">예를 들어, 패키지 디렉토리의 구조와 내용이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">예를 들어, 모듈의 심볼에 곱셈을 정의하려고한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">예를 들어 내장 된 &lt;code&gt;AbstractRange&lt;/code&gt; 객체는이 메커니즘을 사용하여 모든 단일 요소를 계산하는 대신 시작, 단계 및 길이 (또는 중지) 측면에서 순수하게 평가할 수있는 브로드 캐스트 된 표현 조각을 최적화합니다. 다른 모든 기계와 마찬가지로 &lt;code&gt;broadcasted&lt;/code&gt; 는 인수의 결합 된 브로드 캐스트 스타일도 계산하고 노출하므로 &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; 를 전문화하는 대신 &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; 스타일, 함수 및 인수의 조합</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">이를 확장하면 알고리즘에 입력 배열의 복사본이 필요한 경우 반환 값이 원래 입력의 별칭을 지정할 수 있으므로 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 이 불충분합니다. 결합 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 하고 (출력 배열하도록) &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt;(입력 데이터로 채우려면)는 입력 인수의 변경 가능한 사본에 대한 요구 사항을 표현하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">다른 예로, 다음은 숫자 인수를 두 배로 늘리지 만 표현식 만 남겨 두는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">부동 소수점 값에 대한 계산이 부정확 할 수 있듯이 하나하여 대략 동등 검사를 수행 할 수 &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (여기서 &lt;code&gt;&amp;asymp;&lt;/code&gt; 의 탭 완성 통해 입력 &lt;code&gt;\approx&lt;/code&gt; 은이다 &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; 의&lt;/a&gt; 기능) 또는 사용 &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">다시 한 번 알 수 있듯이, 로컬 노드에 대한 원격 호출은 직접 호출처럼 작동합니다. 이 호출은 인수로 전달 된 로컬 객체를 수정합니다. 원격 호출에서는 인수 사본에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">보다시피, &lt;code&gt;A&lt;/code&gt; 는 정렬 된 배열 &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 됩니다. Julia는 배열을 &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; 로 변환하는 방법, 유형의 크기를 바이트 단위로 계산하는 방법 (C의 &lt;code&gt;sizeof&lt;/code&gt; 연산자와 동일 함) 등을 알고 있습니다. 재미있게, &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 줄을 &lt;code&gt;mycompare&lt;/code&gt; 에 삽입 하면 &lt;code&gt;qsort&lt;/code&gt; 가 수행 하고있는 비교를 볼 수 있고 전달한 Julia 함수를 실제로 호출하는지 확인할 수 있습니다 그것에).</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">보시다시피, &lt;code&gt;put!&lt;/code&gt; 호출간에 동일한 오브젝트 &lt;code&gt;v&lt;/code&gt; 가 수정 된 로컬 소유 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에서 v 동일한 단일 오브젝트 인스턴스가 저장됩니다. &lt;code&gt;rc&lt;/code&gt; 를 소유 한 노드 가 다른 노드 일 때 작성되는 &lt;code&gt;v&lt;/code&gt; 의 사본과 반대로 .</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">알 수 있듯이 전역 변수 &lt;code&gt;A&lt;/code&gt; 는 작업자 2에 정의되어 있지만 &lt;code&gt;B&lt;/code&gt; 는 로컬 변수로 캡처되므로 작업자 2에는 &lt;code&gt;B&lt;/code&gt; 에 대한 바인딩 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">날짜 기간 산술만큼 편리하지만, 날짜에 필요한 계산 종류는 종종 일정 기간이 아닌 &lt;em&gt;금기&lt;/em&gt; 또는 &lt;em&gt;시간&lt;/em&gt; 특성을 취 합니다. 휴일은 완벽한 예입니다. &quot;기념일 = 5 월 마지막 월요일&quot;또는 &quot;추수 감사절 = 11 월 4 일 목요일&quot;과 같은 규칙을 따릅니다. 이러한 종류의 시간적 표현은 첫 번째 또는 마지막 달, 다음 화요일 또는 첫 번째 및 세 번째 수요일 등 달력과 관련된 규칙을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">예상대로 &quot;Hello World&quot;가 인쇄되었습니다. 실제로 배후에서 일어난 일을 실제로 분석해 봅시다. &lt;code&gt;connect&lt;/code&gt; 라고하면 방금 만든 서버에 연결합니다. 한편 accept 함수는 새로 작성된 소켓에 서버 측 연결을 리턴하고 &quot;Hello World&quot;를 인쇄하여 연결에 성공했음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">에 관해서는 &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;SparseVector&lt;/code&gt; 유형을 명시 적으로 저장 0을 포함 할 수 있습니다. ( &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">16 진 리터럴의 경우 2 진 및 8 진 리터럴은 부호없는 정수 유형을 생성합니다. 리터럴의 선행 숫자가 &lt;code&gt;0&lt;/code&gt; 이 아닌 경우 이진 데이터 항목의 크기는 필요한 최소 크기 입니다. 선행 0의 경우, 크기는 길이는 동일하지만 선행 숫자 &lt;code&gt;1&lt;/code&gt; 인 리터럴에 필요한 최소 크기로 결정됩니다 . 이를 통해 사용자는 크기를 제어 할 수 있습니다. &lt;code&gt;UInt128&lt;/code&gt; 에 저장할 수없는 값 은 이러한 리터럴로 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">숫자 형 배열의 경우, 안정적인 정렬 개념이 의미가없는 (즉, 동일한 값을 비교하는 두 값을 구별 할 수없는 경우) 배열 유형에 대해 비 안정적 기본 알고리즘을 선택하는 것이 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">단일 값으로 사용 &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; 치료 &lt;code&gt;missing&lt;/code&gt; 서로 동일한 값으로 &lt;code&gt;missing&lt;/code&gt; 값이지만 비 누락 값과 다른</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">위에서 암시 한 바와 같이 Julia의 매우 유용한 기능 중 하나는 Julia 자체 내에서 Julia 코드를 생성하고 조작하는 기능입니다. 이미 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 객체를 반환하는 함수의 한 가지 예를 보았습니다 . &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 함수는 Julia 코드 문자열을 가져와 해당 &lt;code&gt;Expr&lt;/code&gt; 을 반환합니다 . 함수는 하나 이상의 &lt;code&gt;Expr&lt;/code&gt; 객체를 인수로 사용하고 다른 &lt;code&gt;Expr&lt;/code&gt; 을 반환 할 수도 있습니다 . 다음은 간단하고 동기 부여가되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">위의 예와 같이 &lt;code&gt;|&lt;/code&gt; 문자는 세로로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Java에서와 같이 문자열은 변경할 수 없습니다. &lt;code&gt;AbstractString&lt;/code&gt; 객체 의 값을 변경할 수 없습니다. 다른 문자열 값을 구성하려면 다른 문자열의 일부에서 새 문자열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">위의 예와 같이 문서를 작성할 때 몇 가지 간단한 규칙을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">이 언급 한 것처럼 &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; 의 읽기 전용 배열과 같은 유형의 동작합니다 &lt;code&gt;UInt8&lt;/code&gt; 하고 당신은 당신이 사용하여 변환 할 수있는 표준 벡터해야하는 경우 &lt;code&gt;Vector{UInt8}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">위에서 언급했듯이 새로운 디스플레이 백엔드를 정의 할 수도 있습니다. 예를 들어, 창에 PNG 이미지를 표시 할 수있는 모듈은 Julia에이 기능을 등록 할 수 있으므로 PNG 표현이있는 유형에서 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; 를 호출 하면 모듈의 창을 사용하여 이미지가 자동으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">&lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt; 에서 간단히 언급했듯이 선택적 인수는 여러 메서드 정의의 구문으로 구현됩니다. 예를 들어,이 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">이 글을 쓰는 현재 유효한 유니 코드 코드 포인트는 &lt;code&gt;U+00&lt;/code&gt; ~ &lt;code&gt;U+d7ff&lt;/code&gt; 및 &lt;code&gt;U+e000&lt;/code&gt; ~ &lt;code&gt;U+10ffff&lt;/code&gt; 입니다. 이것들은 아직 이해하기 어려운 의미를 부여 받았거나 응용 프로그램에서 반드시 해석 할 수있는 것은 아니지만, 이러한 값은 모두 유효한 유니 코드 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">여기서 볼 수 있듯이, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; 함은 단순히 주어진 정규 표현식에 대한 일치가 문자열에서 발생하는지 여부를 나타내는 true 또는 false를 반환합니다. 그러나 일반적으로 문자열이 일치하는지 여부뿐만 아니라 문자열이 &lt;em&gt;어떻게&lt;/em&gt; 일치하는지 알고 싶어합니다 . 일치에 대한이 정보를 캡처하려면 대신 &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">오류 상태에서 알 수 있듯이 원격 노드 에서 &lt;code&gt;UndefVarError&lt;/code&gt; 의 직접적인 원인은 해당 이름의 바인딩이 존재하지 않기 때문입니다. 가능한 원인 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">예제에서 알 수 있듯이 &lt;code&gt;julia&lt;/code&gt; 에 대한 다음 명령 줄 인수 는 전역 상수 &lt;code&gt;ARGS&lt;/code&gt; 에 전달 된 &lt;code&gt;script.jl&lt;/code&gt; 프로그램에 대한 명령 줄 인수로 해석됩니다 . 스크립트 자체의 이름은 전역 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 로 전달됩니다 . 참고가 있음을 &lt;code&gt;ARGS&lt;/code&gt; 줄리아 표현이 사용 주어지면도 설정되어 &lt;code&gt;-e&lt;/code&gt; 명령 행 옵션을합니다 (참조 &lt;code&gt;julia&lt;/code&gt; 아래의 도움말 출력)하지만 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 는 비어 있습니다. 예를 들어 스크립트에 주어진 인수를 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">이 예제에서 알 수 있듯이 이러한 배열의 요소 유형은 &lt;code&gt;Union{Missing, T}&lt;/code&gt; 이며, 결 측값이 아닌 &lt;code&gt;T&lt;/code&gt; 의 유형입니다. 이것은 단순히 배열 항목이 &lt;code&gt;T&lt;/code&gt; 유형 (여기서는 &lt;code&gt;Int64&lt;/code&gt; )이거나 &lt;code&gt;Missing&lt;/code&gt; 유형일 수 있다는 사실을 반영합니다 . 이러한 종류의 배열은 항목의 유형 (즉, &lt;code&gt;Missing&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; )을 나타내는 &lt;code&gt;Array{UInt8}&lt;/code&gt; 과 결합 된 실제 값을 보유 하는 &lt;code&gt;Array{T}&lt;/code&gt; 와 동등한 효율적인 메모리 저장 영역을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">평소와 같이 복소수 의 절대 값 ( &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; )은 0과의 거리입니다. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt; 는 절대 값의 제곱을 제공하며 특히 제곱근을 취하지 않으므로 복소수에 사용됩니다. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt; 는 위상 각도를 라디안으로 반환합니다 ( &lt;em&gt;인수&lt;/em&gt; 또는 &lt;em&gt;인수&lt;/em&gt; 함수 라고도 함 ). 다른 &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;기본 함수&lt;/a&gt; 의 전체 영역 도 복소수에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">일반적으로 프로모션 시스템은 다른 숫자 유형과 쉽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">평상시와 같이 &lt;code&gt;DummyModule&lt;/code&gt; 이 프로세스의 범위를 벗어나지 않으므로 &lt;code&gt;using&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 가 필요합니다 . 또한 &lt;code&gt;DummyModule&lt;/code&gt; 이 한 프로세스에서 범위에 도달 하면 다른 프로세스에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;C와 Fortran Code 호출&lt;/a&gt; 에서 보듯이 Julia는 C로 작성된 함수를 호출하는 간단하고 효율적인 방법을 가지고 있습니다. 그러나 C 코드에서 Julia 함수를 호출하는 반대 상황이 있습니다. C / C ++로 모든 것을 다시 작성할 필요없이 Julia 코드를 더 큰 C / C ++ 프로젝트에 통합하는 데 사용할 수 있습니다. Julia는이를 가능하게하는 C API를 가지고 있습니다. 거의 모든 프로그래밍 언어에서 C 함수를 호출 할 수있는 방법이 있으므로 Julia C API를 사용하여 언어 브릿지를 추가로 작성할 수 있습니다 (예 : Python 또는 C #에서 Julia 호출).</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">보시다시피 Julia 객체는 C에서 포인터로 표시됩니다. 이것은 누가이 객체들을 자유롭게 할 책임이 있는지에 대한 의문을 제기합니다.</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">보시다시피 일반적인 매개 변수 유형에는 유형 매개 변수를 알 때 호출되는 내부 생성자가 있습니다. 예를 들어, 그들은에 적용되는 &lt;code&gt;Point{Int}&lt;/code&gt; 하지만에 &lt;code&gt;Point&lt;/code&gt; . 선택적으로 유형 매개 변수를 자동으로 결정하는 외부 생성자를 추가 할 수 있습니다 (예 : 호출 &lt;code&gt;Point(1,2)&lt;/code&gt; 에서 &lt;code&gt;Point{Int}&lt;/code&gt; ) . 외부 생성자는 내부 생성자를 호출하여 실제로 인스턴스를 만듭니다. 그러나 어떤 경우에는 내부 생성자를 제공하지 않으므로 특정 유형 매개 변수를 수동으로 요청할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">우리가 보았 듯이, 이러한 표현은 &lt;code&gt;$&lt;/code&gt; 로 보간을 지원 합니다. 그러나 일부 상황에서는 보간 &lt;em&gt;을&lt;/em&gt; 수행 &lt;em&gt;하지 않고&lt;/em&gt; 코드를 인용해야합니다 . 이러한 종류의 인용에는 아직 구문이 없지만 내부적으로 &lt;code&gt;QuoteNode&lt;/code&gt; 유형의 객체로 표시 됩니다 . 파서 는 심볼과 같은 간단한 인용 항목에 대해 &lt;code&gt;QuoteNode&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">다음에 볼 수 있듯이 특정 인수를 사용하여 Julia 함수를 호출하려면 권투가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 의 연도 및 분기 에 대한 정보는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">고유 값 또는 고유 벡터 찾기와 같은 기타 유용한 작업 :</target>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ccall&lt;/code&gt; 과 마찬가지로 인수 서명을 정확하게 가져와야 합니다. 또한 &lt;code&gt;Core.Intrinsics&lt;/code&gt; 에 의해 노출 된 동등한 Julia 함수와 달리 내장 함수가 현재 대상에서 작동하고 작동하는지 확인하는 호환성 계층이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">생성자에서 반환 된 불완전한 객체와 마찬가지로, &lt;code&gt;complete_me&lt;/code&gt; 또는 해당 수신자 가 초기화되기 전에 &lt;code&gt;Lazy&lt;/code&gt; 객체 의 &lt;code&gt;data&lt;/code&gt; 필드에 액세스하려고 하면 오류가 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">이전 섹션의 리터럴과 마찬가지로 리터럴 백틱을 이중 백틱 내에 작성해야하는 경우 2보다 큰 짝수를 사용하십시오. 단일 리터럴 백틱을 $ \ LaTeX $ 마크 업에 포함시켜야하는 경우 두 개의 엔 클로징 백틱으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">다른 스트림과 마찬가지로 &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 를 사용 하여 소켓을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">변수와 마찬가지로 유니 코드도 함수 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">예제에서 볼 수 있듯이 로깅 명령문은 로그 이벤트의 위치 또는 처리 방법에 대해 언급하지 않습니다. 이것은 시스템을 구성 가능하고 자연스럽게 동시에 사용할 수있게하는 핵심 설계 기능입니다. 두 가지 다른 관심사를 분리하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">보시다시피, 명시 적 형식 매개 변수를 사용하는 생성자 호출의 경우 인수는 암시 적 필드 형식으로 변환됩니다. &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 는 작동하지만 &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; 는 &lt;code&gt;2.5&lt;/code&gt; 를 변환 할 때 &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. 에 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Point(1,2)&lt;/code&gt; 에서처럼 생성자 호출에 대한 인수가 형식을 암시하는 경우 인수 의 형식이 일치해야합니다. 그렇지 않으면 &lt;code&gt;T&lt;/code&gt; 를 결정할 수 없습니다. 그러나 일치하는 형식의 실제 인수 쌍이 제공 될 수 있습니다. 일반 &lt;code&gt;Point&lt;/code&gt; 생성자에</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">보시다시피, 잘못된 컨테이너에 잘못된 수의 요소가 있으면 너무 많은 인수가 명시 적으로 지정된 것처럼 함수 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">보시다시피, 첫 번째 줄에서 프로세스 2에 2x2 랜덤 매트릭스를 만들도록 요청했고 두 번째 줄에서는 1을 추가하도록 요청했습니다. 두 계산의 결과는 두 선물 &lt;code&gt;r&lt;/code&gt; 과 &lt;code&gt;s&lt;/code&gt; 에서 사용할 수 있습니다 . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 매크로 첫번째 인수로 지정된 프로세스에 두 번째 인자의 발현을 평가한다.</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">보시다시피, 인수는 정확하게 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 유형이어야합니다 . 정수 또는 32 비트 부동 소수점 값과 같은 다른 숫자 유형은 64 비트 부동 소수점으로 자동 변환되거나 문자열을 숫자로 구문 분석하지 않습니다. 때문에 &lt;code&gt;Float64&lt;/code&gt; 는 구체적인 유형과 구체적인 유형 줄리아의 서브 클래스화할 수 없으며, 이러한 정의는 정확히 유형이다 인수에 적용 할 수 &lt;code&gt;Float64&lt;/code&gt; . 그러나 선언 된 매개 변수 유형이 추상적 인 일반적인 메소드를 작성하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">보시다시피, &lt;code&gt;Int&lt;/code&gt; 리터럴 을 사용한 두 번째 버전 은 입력 인수의 유형을 유지했지만 첫 번째 버전은 그렇지 않았습니다. 예를 들어 &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; 이고 승격으로 승격이 발생하기 때문입니다. 마찬가지로, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 리터럴은 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 리터럴 보다 유형이 덜 파괴적이지만 &lt;code&gt;Int&lt;/code&gt; 보다 더 파괴적입니다 .</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">보다시피, &lt;code&gt;path&lt;/code&gt; 변수 의 공간 은 적절하게 이스케이프됩니다. 하지만 당신은 어떤 경우 &lt;em&gt;원하는&lt;/em&gt; 여러 단어를 보간? 이 경우 배열 (또는 다른 반복 가능한 컨테이너)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">보다시피, 추가 된 요소의 유형은 추가 된 벡터의 요소 유형과 일치해야합니다 . 그렇지 않으면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 다음 예제에서는 메소드 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 리턴 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">보시다시피 감소 연산자가 필요하지 않으면 생략 할 수 있습니다. 이 경우 루프는 비동기 적으로 실행됩니다. 즉, 사용 가능한 모든 작업자에 대해 독립적 인 작업을 생성 하고 완료를 기다리지 않고 즉시 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 배열을 반환합니다 . 호출자는 기다릴 수 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 호출하여 나중에에서 완료 &lt;code&gt;fetch&lt;/code&gt; 그들에, 또는를 앞에하여 루프의 말에 완료 될 때까지 기다린 &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; 처럼 &lt;code&gt;@sync @distributed for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">아시다시피, 글로벌에 관련된 메모리는 마스터에서 재 할당 될 때 수집 될 수 있지만 바인딩이 계속 유효하기 때문에 워커에 대한 조치는 수행되지 않습니다. &lt;code&gt;clear!&lt;/code&gt; 원격 노드에서 수동으로 재 할당 특정의 전역에 사용할 수 있습니다 &lt;code&gt;nothing&lt;/code&gt; 그들이 더 이상 필요하지 않습니다 번. 그러면 일반 가비지 콜렉션주기의 일부로 연관된 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 유형의 &lt;code&gt;value&lt;/code&gt; 으로 명명 된 필드에 &lt;code&gt;x&lt;/code&gt; 를 지정하십시오 . &lt;code&gt;value&lt;/code&gt; 변경 가능해야하며 &lt;code&gt;x&lt;/code&gt; 의 하위 유형이어야합니다 &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; . &lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">현재 작업의 작업 로컬 저장소에있는 키에 값을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 를 할당 해도 컬렉션에서 요소가 제거되지는 않습니다. 대신 &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">할당 에 &lt;code&gt;b&lt;/code&gt; 의 복사본을 만들지 않습니다 &lt;code&gt;b&lt;/code&gt; ; 대신 &lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">숫자를 &lt;code&gt;a&lt;/code&gt; 에 할당하면 숫자 가 &lt;code&gt;Float64&lt;/code&gt; 로 변환 되고 &lt;code&gt;a&lt;/code&gt; 는 효율적으로 조작 할 수있는 64 비트 부동 소수점 값의 연속 블록으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">객체의 필드에 할당하면 선언 된 필드 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">선언 된 유형 (예 : &lt;code&gt;local x::T&lt;/code&gt; ) 이있는 변수에 지정하면 해당 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">배열에 할당하면 배열의 요소 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">범위를 벗어난 인덱스에 할당해도 컬렉션이 커지지 않습니다. 컬렉션이 &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 이면 대신 &lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; 로 재배 할 수 있습니다 ! 또는 &lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">할당은 반복 가능한 값을 사용하여 여러 변수에 대해 병렬로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">대입은 여러 변수를 연속적으로 처리 할 수 ​​있으며 가장 오른쪽 표현식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; 의 수명을 작업과 연결하십시오 . 작업이 종료되면 &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; 이 자동으로 닫힙니다. 작업에서 포착되지 않은 예외는 &lt;code&gt;chnl&lt;/code&gt; 의 모든 웨이터에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 에서 연관 컬렉션 (예 : &lt;code&gt;Dict&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; )을 다시 해시해야합니다 . (향후에는 초기화 기능을 등록하기위한 메커니즘이 제공 될 수있다.)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">위의 것보다 더 구체적인 방법을 찾지 &lt;code&gt;myplus&lt;/code&gt; 가정하면 Julia는 다음 에 위에서 주어진 일반 함수를 기반으로 두 개의 &lt;code&gt;Int&lt;/code&gt; 인수에 대해 myplus 라는 메소드를 내부적으로 정의하고 컴파일합니다. 즉, 암시 적으로 정의하고 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">별표 연산자</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">놀란 얼굴</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">점진적으로 동등한</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">비동기 IO 및 동시 동기 쓰기</target>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">에서 &lt;code&gt;-O3&lt;/code&gt; 컴파일러는 &lt;em&gt;할 수&lt;/em&gt; 자동적으로 튜플에 작업을 벡터화. 예를 들어 다음 프로그램은 &lt;code&gt;julia -O3&lt;/code&gt; 로 컴파일 될 때 x86 시스템에서 두 개의 SIMD 추가 명령어 ( &lt;code&gt;addps&lt;/code&gt; )를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">높은 수준에서 각 환경은 개념적으로 루트, 그래프 및 경로의 세 가지 맵을 정의합니다. &lt;code&gt;import X&lt;/code&gt; 의 의미를 해결할 때 루트와 그래프 맵은 &lt;code&gt;X&lt;/code&gt; 의 아이덴티티를 결정하는 데 사용되고 경로 맵은 &lt;code&gt;X&lt;/code&gt; 의 소스 코드를 찾는 데 사용됩니다 . 세지도의 구체적인 역할은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">처음에 홍당무가 발생하면 9223372036854775807이 -9223372036854775808보다 9223372036854775808에 훨씬 가깝고 정수는 여전히 C 및 Fortran과 호환되는 자연스러운 방식으로 고정 크기로 표시되므로 충분히 합리적입니다. 그러나 포화 정수 산술은 매우 문제가 있습니다. 첫 번째로 가장 명백한 문제는 이것이 기계 정수 연산 방식이 아니라는 점입니다. 따라서 포화 연산을 구현하려면 언더 플로우 또는 오버플로를 확인하고 결과를 &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; &lt;/a&gt; 대체하기 위해 각 기계 정수 연산 후에 명령어를 방출해야합니다.적절한. 이것만으로도 하나의 빠른 명령어에서 분기를 포함하여 십여 개의 명령어로 각 정수 연산을 확장합니다. 아야. 그러나 포화 정수 연산은 연관성이 없습니다. 이 Matlab 계산을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">이 기능의 기본은 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt; 이며 적절한 주소 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">맨 위에 함수의 유추 된 리턴 유형이 &lt;code&gt;Body::Float64&lt;/code&gt; 로 표시됩니다 . 다음 줄은 Julia의 SSA IR 형식 으로 &lt;code&gt;f&lt;/code&gt; 의 본문을 나타냅니다 . 번호가 매겨진 상자는 레이블이며 코드에서 점프 대상 ( &lt;code&gt;goto&lt;/code&gt; 를 통해 )을 나타냅니다 . 몸을 보면 먼저 일어나는 일이 있다는 것을 알 수 있습니다 &lt;code&gt;pos&lt;/code&gt; 호출되고 반환 값으로 추정 된 &lt;code&gt;Union&lt;/code&gt; 형 &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; 가 아닌 구체적인 형태이기 때문에 대문자로 표시. 즉 , 입력 유형에 따라 정확한 반환 유형 &lt;code&gt;pos&lt;/code&gt; 를 알 수 없습니다 . 그러나, 결과 &lt;code&gt;y*x&lt;/code&gt; A는 없다 &lt;code&gt;Float64&lt;/code&gt; 없이 경우 &lt;code&gt;y&lt;/code&gt; A는 &lt;code&gt;Float64&lt;/code&gt; 또는 &lt;code&gt;Int64&lt;/code&gt; 순수한 결과 즉 &lt;code&gt;f(x::Float64)&lt;/code&gt; 중간 계산의 일부 유형에 불안정한 경우에도, 그 종류에 불안정한 출력되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">이 시점에서 프로젝트는 빌드되고 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">운동화</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">원자 객체는 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">원자 연산 은 &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;code&gt;atomic_&lt;/code&gt; 접두사를 사용합니다 . , &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;등</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 적으로 추가 &lt;code&gt;val&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비트와 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 비트-NAND (안-과) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 비트 또는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비트 xor (제외 또는 &lt;code&gt;x&lt;/code&gt; ) 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비교하고 설정 한 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 을 &lt;code&gt;cmp&lt;/code&gt; 와 원자 적으로 비교합니다 . 같으면 &lt;code&gt;newval&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; 에 쓰십시오 . 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 를 수정하지 않은 채로 둡니다 . &lt;code&gt;x&lt;/code&gt; 의 이전 값을 반환합니다 . 반환 된 값을 &lt;code&gt;cmp&lt;/code&gt; ( &lt;code&gt;===&lt;/code&gt; 를 통해 )와 비교하여 &lt;code&gt;x&lt;/code&gt; 가 수정 되었는지 여부를 알고 이제 새 값 &lt;code&gt;newval&lt;/code&gt; 을 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값을 원자 적으로 교환</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 을 &lt;code&gt;newval&lt;/code&gt; 과 원자 적으로 교환합니다 . &lt;strong&gt;이전&lt;/strong&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자의 최대 저장 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자의 최소 저장 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 빼기 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;upstream&lt;/code&gt; 또는 업스트림 추적 분기에서 현재 분기의 자동 병합 리베이스를 시도하십시오 . &lt;code&gt;newbase&lt;/code&gt; 는 리베이스 할 브랜치입니다. 기본적으로 이것은 &lt;code&gt;upstream&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">현금 인출기</target>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">다양한 인수 유형을위한 효율적이고 전문화 된 코드 자동 생성</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">메소드 확장에 사용 가능</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">변수 유형을 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">어떤 것이 인스턴스인지 유형인지에 대한 혼동을 피하십시오</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">추상 유형 매개 변수가있는 컨테이너를 피하십시오</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">정교한 컨테이너 유형을 피하십시오</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">추상 컨테이너가있는 필드 피</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">추상 유형의 필드 피하기</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">전역 변수를 피하십시오</target>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">이상한 형 피 &lt;code&gt;Union&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">I / O에 대한 문자열 보간 방지</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">불법 복제 방지</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">불필요한 배열을 피하십시오. 예를 들어, 대신 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt; 사용 &lt;code&gt;x+y+z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">가능하면 일반 코드에서 숫자 리터럴에 부동 소수점을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">URL에 비밀번호를 사용하지 마십시오. 신임 정보 오브젝트와 달리 Julia는 사용 후 민감한 데이터를 안전하게 제로화하거나 파괴 할 수 없으며 암호는 메모리에 남아있을 수 있습니다. 초기화되지 않은 메모리에 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">지나치게 구체적인 유형을 쓰지 마십시오</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">파이프 라인에서 교착 상태 방지</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">전역 변수의 값을 변경하지 않는 것은 프로그래밍 모범 사례로 간주됩니다. 전역 변수의 값을 변경하면 &quot;원거리에서의 동작&quot;이 발생하여 프로그램의 동작을 추론하기가 더 어려워 질 수 있습니다. 이것이 로컬 범위를 도입하는 범위 블록 에 글로벌 변수를 수정하려는 의도를 선언하기 위해 &lt;code&gt;global&lt;/code&gt; 키워드가 필요한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">글로벌 피하기</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy 및 Nicholas J. Higham, &quot;매트릭스 로그에 대한 역 스케일링 및 제곱 알고리즘 개선&quot;, SIAM Journal on Scientific Computing, 34 (4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;도 : 10.1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy, Nicholas J. Higham 및 Samuel D. Relton, &quot;행렬 로그의 Fr&amp;eacute;chet 파생 상품 계산 및 조건 수 추정&quot;, SIAM Journal on Scientific Computing, 35 (4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;도 : 10.1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">베즈 아웃 계수는 고유하게 정의 &lt;em&gt;되지 않습니다&lt;/em&gt; . &lt;code&gt;gcdx&lt;/code&gt; 는 확장 된 유클리드 알고리즘에 의해 계산 된 최소 B&amp;eacute;zout 계수를 반환합니다. (참고 : D. Knuth, TAoCP, 2 / e, 325 페이지, 알고리즘 X) 부호있는 정수의 경우 이러한 계수 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 $ | u | &amp;lt;| y / d | $ 및 $ | v | &amp;lt;| x / d | $. 또한, &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 부호는 &lt;code&gt;d&lt;/code&gt; 가 양수가 되도록 선택 됩니다. 부호없는 정수의 경우 계수 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;typemax&lt;/code&gt; 근처에있을 수 있으며 , 그 다음 항은 부호없는 정수의 모듈러스 산술을 통해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">BLAS 문자 인수</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS 기능</target>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">아기 천사</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">젖병</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">아기 병아리</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">아기 상징</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">위 왼쪽 화살표와 함께 다시</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">배경과 참조</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )는 이중 백 슬래시 ( &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ) 로 이스케이프됩니다 . 인쇄 할 수없는 문자는 표준 C 이스케이프 코드, NUL (명확한 경우)의 경우 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; , 유니 코드 코드 포인트 ( &lt;code&gt;&quot;\u&quot;&lt;/code&gt; 접두사) 또는 16 진 ( &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 접두사)으로 이스케이프 됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">백 스페이스, &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">박트리아 낙타</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">수하물 수취</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">고유 시스템 또는 슈어 인수 분해를 계산하기 전에 행렬 &lt;code&gt;A&lt;/code&gt; 의 균형을 맞 춥니 다. &lt;code&gt;job&lt;/code&gt; 은 &lt;code&gt;N&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열되거나 크기가 조정되지 않음), &lt;code&gt;P&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열 만), &lt;code&gt;S&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 크기 만 조정 됨) 또는 &lt;code&gt;B&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열 및 크기 조정 됨) 중 하나 일 수 있습니다. 수정 &lt;code&gt;A&lt;/code&gt; 는 자리에서 반환은 &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; , 그리고 &lt;code&gt;scale&lt;/code&gt; . 순열이 설정된 경우 &lt;code&gt;j &amp;gt; i&lt;/code&gt; 및 &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; 또는 &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; 경우 &lt;code&gt;A[i,j] = 0&lt;/code&gt; 입니다. &lt;code&gt;scale&lt;/code&gt; 은 스케일링 / 변경에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">체크 투표 상자</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">달러 기호 지폐</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">유로 기호 지폐</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">파운드 기호 지폐</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">엔 기호 지폐</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">막대 차트</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">이발소의 간판 기둥</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">기본 서브 모듈</target>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">이러한 관찰을 바탕으로, 우리는 피연산자 중 하나가 경우에 결론 수 &lt;code&gt;true&lt;/code&gt; 과 다른 &lt;code&gt;missing&lt;/code&gt; , 우리는 결과는 것을 알고 &lt;code&gt;true&lt;/code&gt; 피연산자 중 하나의 실제 값에 대한 불확실성에도 불구하고. 우리가 두 번째 피연산자의 실제 값을 관찰 할 수 있었다면 그것은 &lt;code&gt;true&lt;/code&gt; 이거나 &lt;code&gt;false&lt;/code&gt; 일 수 있으며, 두 경우 모두 결과는 &lt;code&gt;true&lt;/code&gt; 이 될 것 입니다. 따라서이 특별한 경우에 누락이 전파 되지 &lt;em&gt;않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">기본 스트림 I / O</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">기본 단위 테스트</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">기본 테이블은 아래 설명 된 구문을 사용하여 작성할 수 있습니다. 마크 다운 테이블은 기능이 제한되어 있으며 위에서 설명한 다른 요소와 달리 중첩 된 최상위 요소를 포함 할 수 없습니다. 인라인 요소 만 허용됩니다. 테이블은 항상 열 이름을 가진 헤더 행을 포함해야합니다. 셀은 테이블의 여러 행 또는 열에 걸쳐있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">농구와 후프</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">매크로가 실제로 함수가 될 수있는시기를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">이 전략에는 하나 이상의 주요 단점이 있습니다. 많은 경우 사용자가 내 보낸 함수 &lt;code&gt;f&lt;/code&gt; 의 추가 전문화를 정의 하여 &lt;code&gt;f&lt;/code&gt; 동작을 추가로 사용자 정의 할 수는 없습니다 . 대신 내부 메소드 &lt;code&gt;_fA&lt;/code&gt; 및 &lt;code&gt;_fB&lt;/code&gt; 에 대한 전문화를 정의해야 하며 이는 내 보낸 메소드와 내부 메소드 사이의 경계를 흐리게합니다.</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">이 함수의 결과가 사용되는 한 &lt;code&gt;x&lt;/code&gt; 에 대한 Julia 참조가 존재 하도록주의하십시오 . 따라서이 함수 의 인수 &lt;code&gt;x&lt;/code&gt; 는 표현식이 아니고 변수 이름 또는 필드 참조 일뿐입니다. 예를 들어, &lt;code&gt;x=a.b.c&lt;/code&gt; 는 허용되지만 &lt;code&gt;x=[a,b,c]&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">유형 평등에주의하십시오</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">빔 여덟 메모 / 막대 여덟 메모</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">곰 얼굴</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">쿵쿵 거리는 심장</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 추상 유형 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 의 배열 이므로 모든 &lt;code&gt;Real&lt;/code&gt; 값 을 보유 할 수 있어야 합니다. 이후 &lt;code&gt;Real&lt;/code&gt; 오브젝트가 임의의 크기 및 구조 일 수 있으며, &lt;code&gt;a&lt;/code&gt; 개별적으로 할당 된 포인터 배열로 표현되어야 &lt;code&gt;Real&lt;/code&gt; 객체. 우리가 대신에만 허용하는 경우에는 동일한 유형, 예를 들면의 숫자 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 에 저장하기, 이보다 효율적으로 저장할 수 있습니다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">C는 다중 반환 값을 지원하지 않기 때문에 종종 C 함수는 함수가 수정할 데이터에 대한 포인터를 가져옵니다. &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 내에서이를 수행하려면 먼저 해당 유형의 &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; 안에 값을 캡슐화해야 합니다. 이 &lt;code&gt;Ref&lt;/code&gt; 객체를 인수로 전달하면 Julia는 캡슐화 된 데이터에 C 포인터를 자동으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Julia의 컴파일러는 Python 또는 R과 같은 언어에 사용되는 인터프리터와 다르기 때문에 처음에는 Julia의 성능이 직관적이지 않을 수 있습니다. 무언가가 느리다는 것을 알게되면 다른 것을 시도하기 전에 &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 섹션을 읽는 것이 좋습니다 . Julia의 작동 방식을 이해하면 C만큼 빠른 코드를 작성하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">이러한 공유 특성으로 인해 이러한 유형은 내부적으로 동일한 유형 인 &lt;code&gt;DataType&lt;/code&gt; 의 인스턴스로 표시되며 , 이는 이러한 유형의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">가변 길이 인코딩으로 인해 문자열의 문자 수 ( &lt;code&gt;length(s)&lt;/code&gt; )가 항상 마지막 색인과 같지는 않습니다. 색인 1부터 &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt; 까지 색인을 반복 하고 &lt;code&gt;s&lt;/code&gt; 로 색인을 생성하는 경우, 오류가 발생하지 않을 때 리턴되는 문자 순서는 문자열 &lt;code&gt;s&lt;/code&gt; 를 구성하는 문자 순서입니다 . 따라서 문자열의 각 문자에는 고유 색인이 있어야하므로 &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; 라는 ID가 있습니다 . 다음은 &lt;code&gt;s&lt;/code&gt; 의 문자를 반복하는 비효율적이고 장황한 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">일반 프로그래밍을 지원하는 것은 다른 방법 (예 : 명시 적 루프 사용)으로 수행 할 수있는 잠재적 인 성능 최적화보다 중요하므로 &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;*=&lt;/code&gt; 와 같은 연산자는 새 값을 리 바인드하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">때문에 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 유형이 단일로 저장 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 값 날짜 부분 또는 필드 액세서 함수를 통해 검색 될 수있다. 소문자 접근자는 필드를 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">컴파일러는 정수 덧셈과 곱셈이 연관되어 있고 곱셈이 덧셈에 산포되는 것을 알기 때문에 (포화 산술에 해당되지 않음) 전체 루프를 곱셈과 덧셈으로 최적화 할 수 있습니다. 포화 연산은 각 루프 반복에서 연관성 및 분 산성이 실패 할 수 있기 때문에 이러한 종류의 최적화를 완전히 무효화하므로, 실패가 발생한 반복에 따라 다른 결과가 발생할 수 있습니다. 컴파일러는 루프를 언 롤링 할 수 있지만 여러 연산을 적은 수의 동등한 연산으로 대수적으로 줄일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">연산자 &lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;*&lt;/code&gt; 보다 우선 순위가 높기 때문에 ( &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;연산자 우선 순위 및 연관성&lt;/a&gt; 참조 )이 출력은 표현식 &lt;code&gt;a ^ 2&lt;/code&gt; 를 &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 동일 하게 나타내지 않습니다 . 이 문제를 해결하려면 인쇄 할 때 표현식 객체에 의해 내부적으로 호출되는 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; 대한 사용자 정의 메소드를 작성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">맥주 잔</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">Julia 1.2 이전에는이 ​​서명이 &lt;code&gt;f::Function&lt;/code&gt; 으로 제한되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Julia를 실행하기 전에 환경 변수 &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; 을 1로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; 본문을 실행하기 전에 &lt;code&gt;Random.seed!(seed)&lt;/code&gt; 대한 암시 적 호출이 있습니다. 여기서 &lt;code&gt;seed&lt;/code&gt; 는 전역 RNG의 현재 시드입니다. 또한 본문 실행 후 전역 RNG의 상태는 &lt;code&gt;@testset&lt;/code&gt; 이전의 상태로 복원됩니다 . 이는 실패시 재현성을 용이하게 하고 글로벌 RNG 상태에 대한 부작용과 상관없이 &lt;code&gt;@testset&lt;/code&gt; 의 원활한 재 배열을 허용하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">프로그램이 종료되기 전에 &lt;code&gt;jl_atexit_hook&lt;/code&gt; 을 호출하는 것이 좋습니다 . 위 예제 프로그램은 &lt;code&gt;main&lt;/code&gt; 에서 돌아 오기 전에 이것을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Julia GC를 통해 메모리를 관리 할 수 있는 &lt;code&gt;Ptr{T}&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; 대해 &lt;code&gt;nextind&lt;/code&gt; 를 &lt;code&gt;n&lt;/code&gt; 번 적용하는 것처럼 동작 합니다. 유일한 차이점은 &lt;code&gt;n&lt;/code&gt; 이 너무 커서 &lt;code&gt;nextind&lt;/code&gt; 를 적용 하면 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 도달 할 때마다 나머지 반복마다 반환 값이 &lt;code&gt;1&lt;/code&gt; 증가한다는 것 입니다. 이것은이 경우 &lt;code&gt;nextind&lt;/code&gt; 가 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 보다 큰 값을 반환 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 &lt;code&gt;prevind&lt;/code&gt; 를 적용하는 것처럼 동작 합니다. 유일한 차이점은 &lt;code&gt;n&lt;/code&gt; 이 너무 커서 &lt;code&gt;prevind&lt;/code&gt; 를 적용 하면 &lt;code&gt;0&lt;/code&gt; 에 도달 할 때마다 나머지 반복마다 반환 된 값이 &lt;code&gt;1&lt;/code&gt; 만큼 감소한다는 것 입니다. 이는이 경우 &lt;code&gt;prevind&lt;/code&gt; 가 음수 값을 반환 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">취소 스트로크 벨</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">다음은 일부 표준에서 하위 표준이 현저하게 성능에 영향을주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">아래에서는 특정 문제와 이러한 문제를 해결하기위한 대체 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">도시락 상자</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">벤젠 반지</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">원 벤젠 반지</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">&lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; 상수 에 사용되는 것 외에도 &lt;code&gt;VersionNumber&lt;/code&gt; 객체는 패키지 버전 및 해당 종속성을 지정하기 위해 &lt;code&gt;Pkg&lt;/code&gt; 모듈 에서 널리 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">내기 기호 / 두 번째 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">BigFloats 및 BigInts</target>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; )를 반환하여 &lt;code&gt;A&lt;/code&gt; 를 양방향으로 치환 합니다. 열 순열 &lt;code&gt;q&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 열 개수 와 일치해야합니다 ( &lt;code&gt;length(q) == A.n&lt;/code&gt; ). 행 순열 &lt;code&gt;p&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 행 개수 와 일치해야합니다 ( &lt;code&gt;length(p) == A.m&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">양측 순열 &lt;code&gt;A&lt;/code&gt; , 결과 &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; )를 &lt;code&gt;X&lt;/code&gt; 에 저장 합니다. 중간 결과 &lt;code&gt;(AQ)^T&lt;/code&gt; ( &lt;code&gt;transpose(A[:,q])&lt;/code&gt; )를 옵션 인수 &lt;code&gt;C&lt;/code&gt; 에 저장합니다 (있는 경우). &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 및 존재하는 경우 &lt;code&gt;C&lt;/code&gt; 가 서로 별명 을 지정하지 않아야합니다 . 결과 &lt;code&gt;PAQ&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 에 다시 저장 하려면 &lt;code&gt;X&lt;/code&gt; 가없는 다음 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.+&lt;/code&gt; 와 같은 이진 (또는 단항) 연산자 는 동일한 메커니즘으로 처리됩니다 . &lt;code&gt;broadcast&lt;/code&gt; 통화와 동일 하며 다른 중첩 된 &quot;도트&quot;통화와 융합됩니다. &lt;code&gt;X .+= Y&lt;/code&gt; 등은 &lt;code&gt;X .= X .+ Y&lt;/code&gt; 와 동일하며, 적절한 제자리 할당을 초래합니다. &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;도트 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">이진 및 8 진 리터럴도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">이진 산술 - &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">이진, 8 진 및 16 진 리터럴은 부호없는 리터럴 바로 앞에 &lt;code&gt;-&lt;/code&gt; 로 서명 할 수 있습니다 . 그들은 부호없는 리터럴과 같은 크기의 부호없는 정수를 생성합니다. 두 값의 보수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">지정된 &lt;code&gt;host:port&lt;/code&gt; 에 &lt;code&gt;socket&lt;/code&gt; 을 바인드 하십시오 . 참고 &lt;code&gt;0.0.0.0&lt;/code&gt; 은 모든 장치에서 수신합니다.</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">생일 케이크</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
