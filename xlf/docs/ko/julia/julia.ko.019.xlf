<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="ebec4412f970972bae4c03bf49efe1d61a1518db" translate="yes" xml:space="preserve">
          <source>Upwards Double Arrow / Up Double Arrow</source>
          <target state="translated">위쪽 화살표 / 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="451da9751f65845a47efc254a97d6c9d93c01a6f" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 위쪽 작살 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="885a72e32db57383a338d645a6ec5f4b3a84c37e" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 위쪽 작살 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="8dbcdbf7a91d6691a730607574ade3b070517f85" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Left From Bar</source>
          <target state="translated">바에서 왼쪽 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="c48f274014a84ac28be3ae008f6fee5b2dabf7a8" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Left To Bar</source>
          <target state="translated">바가 왼쪽에있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="9ab7cd30084b7065a4f1908b303068ca0164b119" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Leftwards / Up Harpoon With Barb Left</source>
          <target state="translated">왼쪽으로 바브가있는 위쪽 작살 / 왼쪽으로 바른이있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="1823143ac88fac95c7a172abf39eacf583342225" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Right From Bar</source>
          <target state="translated">바에서 바로 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="cf0eedea90d05abe73536dcddde59648851f49f2" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Right To Bar</source>
          <target state="translated">바에서 오른쪽 막대로 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="054a68e049c32af85ec106146f1c9d49703a5a32" translate="yes" xml:space="preserve">
          <source>Upwards Harpoon With Barb Rightwards / Up Harpoon With Barb Right</source>
          <target state="translated">오른쪽 바브가있는 위쪽 작살 / 오른쪽 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="52570d5f31c410f5871d41a198881ad11859b2f8" translate="yes" xml:space="preserve">
          <source>Upwards Paired Arrows / Up Paired Arrows</source>
          <target state="translated">위쪽 화살표 / 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="e2bb6ca806f317b31034fe74bd58c64cfd1d2de9" translate="yes" xml:space="preserve">
          <source>Upwards Quadruple Arrow</source>
          <target state="translated">위쪽으로 4 배 화살표</target>
        </trans-unit>
        <trans-unit id="e0293c09ade0452364d29d560cce13e5bd4d334f" translate="yes" xml:space="preserve">
          <source>Upwards Triple Arrow</source>
          <target state="translated">상향 트리플 화살표</target>
        </trans-unit>
        <trans-unit id="8a1494f8ee6c5ee3a3b8efc6ee623b9ab34472ba" translate="yes" xml:space="preserve">
          <source>Upwards Two Headed Arrow / Up Two Headed Arrow</source>
          <target state="translated">위쪽 화살표 두 개 / 위쪽 화살표 두 개</target>
        </trans-unit>
        <trans-unit id="813eb4d285528b78ca67b70c64ef6320ea54f9f0" translate="yes" xml:space="preserve">
          <source>Upwards Two-Headed Arrow From Small Circle</source>
          <target state="translated">작은 원에서 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b2469885ff05b9cc90e880e142fd5896188598ee" translate="yes" xml:space="preserve">
          <source>Upwards White Arrow / White Up Arrow</source>
          <target state="translated">위쪽 흰색 화살표 / 흰색 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="906d90e89656334b7437d43c9b30e29f00d00f8d" translate="yes" xml:space="preserve">
          <source>Upwards White Arrow From Bar / White Up Arrow From Bar</source>
          <target state="translated">바에서 위쪽 흰색 화살표 / 바에서 흰색 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="e4458dd128aa6efaff132fdd10fa70177926007b" translate="yes" xml:space="preserve">
          <source>Uranus</source>
          <target state="translated">Uranus</target>
        </trans-unit>
        <trans-unit id="cdb412e2ca5e6ba493c591c8c2043869bf396180" translate="yes" xml:space="preserve">
          <source>Usage is very straightforward:</source>
          <target state="translated">사용법은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="adf928890fa0bf2818758d8852ab302ab63640ba" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to &lt;code&gt;collection&lt;/code&gt;. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt; 사용 ! 또 다른 콜렉션의 모든 요소를 추가 &lt;code&gt;collection&lt;/code&gt; . 앞의 예의 결과는 &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dba88b41b71a6676d0481b8696709dd68423768" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;Base.include&lt;/code&gt;&lt;/a&gt; to evaluate a file into another module.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;Base.include&lt;/code&gt; &lt;/a&gt; 를 사용 하여 파일을 다른 모듈로 평가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e8760c00a8697e5b8aeb582fe1473eb0e29463e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last valid index of an indexable collection.</source>
          <target state="translated">&lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; 를 사용 하여 색인 가능한 콜렉션의 마지막 유효한 색인을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="b112cddecaeaffc3c8cf54e44abf77315a9f8acf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; to add individual items to &lt;code&gt;collection&lt;/code&gt; which are not already themselves in another collection. The result of the preceding example is equivalent to &lt;code&gt;push!([1, 2, 3], 4, 5, 6)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 다른 컬렉션에 아직없는 개별 항목을 &lt;code&gt;collection&lt;/code&gt; 에 추가 합니다. 앞의 예의 결과는 &lt;code&gt;push!([1, 2, 3], 4, 5, 6)&lt;/code&gt; 와 같습니다 ([1, 2, 3], 4, 5, 6) .</target>
        </trans-unit>
        <trans-unit id="77c9ba2a7f72e5d0f8b6c5f71aa620d5e3c742f3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; to access the value wrapped by a &lt;code&gt;Some&lt;/code&gt; object.</source>
          <target state="translated">사용 &lt;a href=&quot;#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt; a로 포장 값 액세스 &lt;code&gt;Some&lt;/code&gt; 객체로 .</target>
        </trans-unit>
        <trans-unit id="253fb0c8daa4e7ce4c9d69eb091a0cb44d5f50cf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#LinearAlgebra.opnorm&quot;&gt;&lt;code&gt;opnorm&lt;/code&gt;&lt;/a&gt; to compute the operator norm of a matrix.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.opnorm&quot;&gt; &lt;code&gt;opnorm&lt;/code&gt; &lt;/a&gt; 사용 을 하여 행렬의 연산자 규범을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="b236b0bc0e26f22cae584435e191add5139d35df" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../base/base/index#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; 사용표현식 내에서 배열 경계 검사를 제거 를 . 이 작업을 수행하기 전에 확인하십시오. 아래 첨자가 범위를 벗어나면 충돌 또는 자동 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d306f68003307110fc26b73cfcc7afc0fc9abd9c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../base/math/index#Base.FastMath.@fastmath&quot;&gt;&lt;code&gt;@fastmath&lt;/code&gt;&lt;/a&gt; to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option of clang.</source>
          <target state="translated">사용 &lt;a href=&quot;../../base/math/index#Base.FastMath.@fastmath&quot;&gt; &lt;code&gt;@fastmath&lt;/code&gt; 는&lt;/a&gt; 실수에 적합한 소수점 최적화를 떠 허용하지만, IEEE 번호는 차이가 발생할 수 있습니다. 수치 결과가 변경 될 수 있으므로주의하십시오. 이것은 &lt;code&gt;-ffast-math&lt;/code&gt; 에 해당합니다. clang 옵션에 .</target>
        </trans-unit>
        <trans-unit id="3cac4bd068dbdaa848d7cc91268aece2ec2791ed" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2(z)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;abs(z)^2&lt;/code&gt; for complex &lt;code&gt;z&lt;/code&gt;. In general, try to rewrite code to use &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; for complex arguments.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;abs(z)^2&lt;/code&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2(z)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 일반적으로 복잡한 인수에 대해 &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt; 를 사용하도록 코드를 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="97d4b359bc1904cf184f779a48c13e4ababd9bcc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../base/math/index#Base.div&quot;&gt;&lt;code&gt;div(x,y)&lt;/code&gt;&lt;/a&gt; for truncating division of integers instead of &lt;a href=&quot;../../base/math/index#Base.trunc&quot;&gt;&lt;code&gt;trunc(x/y)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.fld&quot;&gt;&lt;code&gt;fld(x,y)&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../../base/math/index#Base.floor&quot;&gt;&lt;code&gt;floor(x/y)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.cld&quot;&gt;&lt;code&gt;cld(x,y)&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../../base/math/index#Base.ceil&quot;&gt;&lt;code&gt;ceil(x/y)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;a href=&quot;../../base/math/index#Base.div&quot;&gt; &lt;code&gt;div(x,y)&lt;/code&gt; &lt;/a&gt; 이 아닌 정수의 나눗셈을 절단 용 &lt;a href=&quot;../../base/math/index#Base.trunc&quot;&gt; &lt;code&gt;trunc(x/y)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.fld&quot;&gt; &lt;code&gt;fld(x,y)&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.floor&quot;&gt; &lt;code&gt;floor(x/y)&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;../../base/math/index#Base.cld&quot;&gt; &lt;code&gt;cld(x,y)&lt;/code&gt; &lt;/a&gt; 대신에 &lt;a href=&quot;../../base/math/index#Base.ceil&quot;&gt; &lt;code&gt;ceil(x/y)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed20df03617ffa631ba3c736bd4f57a7ec7da56b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../base/math/index#Base.div&quot;&gt;&lt;code&gt;div(x,y)&lt;/code&gt;&lt;/a&gt; for truncating division of integers instead of &lt;code&gt;trunc(x/y)&lt;/code&gt;, &lt;a href=&quot;../../base/math/index#Base.fld&quot;&gt;&lt;code&gt;fld(x,y)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;floor(x/y)&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.cld&quot;&gt;&lt;code&gt;cld(x,y)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;ceil(x/y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trunc(x/y)&lt;/code&gt; 대신 정수 나누기 , &lt;code&gt;floor(x/y)&lt;/code&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.fld&quot;&gt; &lt;code&gt;fld(x,y)&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;ceil(x/y)&lt;/code&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.cld&quot;&gt; &lt;code&gt;cld(x,y)&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../base/math/index#Base.div&quot;&gt; &lt;code&gt;div(x,y)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오. ) .</target>
        </trans-unit>
        <trans-unit id="cbd9f39fcb30d6c8593e579f82799578e0b0fa66" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../file/index#Base.Filesystem.dirname&quot;&gt;&lt;code&gt;dirname&lt;/code&gt;&lt;/a&gt; to get the directory part and &lt;a href=&quot;../file/index#Base.Filesystem.basename&quot;&gt;&lt;code&gt;basename&lt;/code&gt;&lt;/a&gt; to get the file name part of the path.</source>
          <target state="translated">디렉토리 부분과 &lt;a href=&quot;../file/index#Base.Filesystem.basename&quot;&gt; &lt;code&gt;basename&lt;/code&gt; &lt;/a&gt; 을 얻으려면 &lt;a href=&quot;../file/index#Base.Filesystem.dirname&quot;&gt; &lt;code&gt;dirname&lt;/code&gt; &lt;/a&gt; 을 사용하십시오. 하고 경로의 파일 이름 부분을 얻으려면 을 .</target>
        </trans-unit>
        <trans-unit id="c2e799feae8fa513489e0daa4c3f185d8cf11c0d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Debug&lt;/code&gt; for verbose information that could be useful when debugging an application or module. These events are disabled by default.</source>
          <target state="translated">응용 프로그램 또는 모듈을 디버깅 할 때 유용한 자세한 정보에 &lt;code&gt;Debug&lt;/code&gt; 를 사용하십시오 . 이러한 이벤트는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0928e79ba9fd55c12a3eefaa790b4b08148347" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Error&lt;/code&gt; to report errors where the code has enough context to recover and continue. (When the code doesn't have enough context, an exception or early return is more appropriate.)</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; 를 사용 하여 코드에 복구 및 계속하기에 충분한 컨텍스트가있는 오류 를보고 하십시오 . 코드에 컨텍스트가 충분하지 않은 경우 예외 또는 조기 반환이 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e86b08aafca134e6fd8d7a93c33dea4d8b4e5e85" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Info&lt;/code&gt; to inform the user about the normal operation of the program.</source>
          <target state="translated">&lt;code&gt;Info&lt;/code&gt; 를 사용 하여 프로그램의 정상적인 작동에 대해 사용자에게 알리십시오.</target>
        </trans-unit>
        <trans-unit id="8c4187945e9e4e8ad7fe21490eeae3ab5745e787" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Warn&lt;/code&gt; when a potential problem is detected.</source>
          <target state="translated">잠재적 인 문제가 감지되면 &lt;code&gt;Warn&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38f7e6f35c48f80e5317615158f0db45821da3da" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;collect&lt;/code&gt; to extract non-&lt;code&gt;missing&lt;/code&gt; values and store them in an array</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; 를 사용 하여 &lt;code&gt;missing&lt;/code&gt; 값 을 추출 하고 배열에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="c15be8234ef12b9a7a7d5794b1d59b19e6393dc6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;collect&lt;/code&gt; to obtain an &lt;code&gt;Array&lt;/code&gt; containing the non-&lt;code&gt;missing&lt;/code&gt; values in &lt;code&gt;itr&lt;/code&gt;. Note that even if &lt;code&gt;itr&lt;/code&gt; is a multidimensional array, the result will always be a &lt;code&gt;Vector&lt;/code&gt; since it is not possible to remove missings while preserving dimensions of the input.</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; 를 사용 하여 &lt;code&gt;itr&lt;/code&gt; 에 &lt;code&gt;missing&lt;/code&gt; 값이 포함 된 &lt;code&gt;Array&lt;/code&gt; 를 얻습니다 . 경우에도하는 것으로 &lt;code&gt;itr&lt;/code&gt; 다차원 배열, 결과는 항상있을 것 &lt;code&gt;Vector&lt;/code&gt; 입력의 차원을 유지하면서 누락 된 부분을 제거 할 수 없으므로 가됩니다.</target>
        </trans-unit>
        <trans-unit id="c3faffd725f2f09e5f4e7fbbe19f38edbe638510" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;import&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="64230d1dd313790498f6cbea1b850278a5b2bdf0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;julia&lt;/code&gt; with &lt;code&gt;--compiled-modules=no&lt;/code&gt; flag to turn off precompilation.</source>
          <target state="translated">&lt;code&gt;--compiled-modules=no&lt;/code&gt; 플래그 와 함께 &lt;code&gt;julia&lt;/code&gt; 를 사용 하여 사전 컴파일을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="be6047af5c0d2bfb4e695d572e7b2e68d170fdb8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;rm&lt;/code&gt; to remove this package by name:</source>
          <target state="translated">&lt;code&gt;rm&lt;/code&gt; 을 사용 하여 이름으로이 패키지를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="88a8f5cf6c63986cbddfbeb683baa495ffb2458a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;update&lt;/code&gt; to update an installed package:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 를 사용하여 설치된 패키지를 업데이트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="faa02645b797b97f27299fe67bce9b0039a88864" translate="yes" xml:space="preserve">
          <source>Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.</source>
          <target state="translated">휴리스틱을 사용하여 파일이 이진인지 추측합니다. NULL 바이트를 검색하고 처음 8000 바이트 중에서 인쇄 가능한 문자와 인쇄 할 수없는 문자의 적절한 비율을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="97af4a7c67b7c83eeca7e643db74ac873a965026" translate="yes" xml:space="preserve">
          <source>Use an explicit conversion by &lt;code&gt;x = oneunit(Float64)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x = oneunit(Float64)&lt;/code&gt; 의한 명시 적 변환 사용</target>
        </trans-unit>
        <trans-unit id="88358f29dfd758f460e28a67196b545279d41f43" translate="yes" xml:space="preserve">
          <source>Use an explicit conversion: &lt;code&gt;x = oneunit(Float64)&lt;/code&gt;</source>
          <target state="translated">명시 적 변환 사용 : &lt;code&gt;x = oneunit(Float64)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6770a727a84b74b281a528ef665b748645523911" translate="yes" xml:space="preserve">
          <source>Use backticks to identify code and equations.</source>
          <target state="translated">백틱을 사용하여 코드와 방정식을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="70ddc8cd15e7e7d64472323fbb2ce74dc97af2ec" translate="yes" xml:space="preserve">
          <source>Use in Makefiles</source>
          <target state="translated">메이크 파일에서 사용</target>
        </trans-unit>
        <trans-unit id="08e8cc7da923f6fd03e4d859e3d2010bdbf5a589" translate="yes" xml:space="preserve">
          <source>Use multiple arguments like so:</source>
          <target state="translated">다음과 같이 여러 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac721de84c14d925fb2b4f9baf4d8bd1f070ead3" translate="yes" xml:space="preserve">
          <source>Use naming conventions consistent with Julia &lt;code&gt;base/&lt;/code&gt;</source>
          <target state="translated">Julia &lt;code&gt;base/&lt;/code&gt; 와 일치하는 이름 지정 규칙 사용</target>
        </trans-unit>
        <trans-unit id="2edbe387f9c0f39642268d3da72bf656df7ef46b" translate="yes" xml:space="preserve">
          <source>Use native code from system image if available</source>
          <target state="translated">가능한 경우 시스템 이미지의 고유 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc2d79932b3fbbb05016d0144fe877e6d22b3ea3" translate="yes" xml:space="preserve">
          <source>Used in a stream redirect to discard all data written to it. Essentially equivalent to &lt;code&gt;/dev/null&lt;/code&gt; on Unix or &lt;code&gt;NUL&lt;/code&gt; on Windows. Usage:</source>
          <target state="translated">스트림 재 지정에 사용되어 기록 된 모든 데이터를 삭제합니다. 기본적 으로 Unix의 &lt;code&gt;/dev/null&lt;/code&gt; 또는 Windows의 &lt;code&gt;NUL&lt;/code&gt; 과 같습니다. 용법:</target>
        </trans-unit>
        <trans-unit id="9cde8b01939e704886f95991687885c1bfbd5672" translate="yes" xml:space="preserve">
          <source>User-defined plain-data types without &lt;code&gt;write&lt;/code&gt; methods can be written when wrapped in a &lt;code&gt;Ref&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 메소드가 없는 사용자 정의 일반 데이터 유형 은 &lt;code&gt;Ref&lt;/code&gt; 에 랩핑 될 때 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1bc0b4fef463a1a11ba0c7feb894e0c57617f8b" translate="yes" xml:space="preserve">
          <source>User-defined types are as fast and compact as built-ins</source>
          <target state="translated">내장형만큼 빠르고 컴팩트 한 사용자 정의 유형</target>
        </trans-unit>
        <trans-unit id="3c729f1cba74cb6c5ffde754c64511e3fe9d9c3f" translate="yes" xml:space="preserve">
          <source>Username/password plain text</source>
          <target state="translated">아이디 / 비밀번호 일반 텍스트</target>
        </trans-unit>
        <trans-unit id="3c17149033d4c3d14412d998ae2de25ee7497296" translate="yes" xml:space="preserve">
          <source>Users should refer to &lt;code&gt;LineEdit.jl&lt;/code&gt; to discover the available actions on key input.</source>
          <target state="translated">키 입력에 대해 사용 가능한 조치 를 &lt;code&gt;LineEdit.jl&lt;/code&gt; 려면 LineEdit.jl 을 참조해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c9ffbb24bf63c0d26fa820ccaad97db5b5d7c4c0" translate="yes" xml:space="preserve">
          <source>Uses multiple concurrent tasks to map &lt;code&gt;f&lt;/code&gt; over a collection (or multiple equal length collections). For multiple collection arguments, &lt;code&gt;f&lt;/code&gt; is applied elementwise.</source>
          <target state="translated">여러 개의 동시 작업을 사용 하여 컬렉션 (또는 여러 개의 동일한 길이의 컬렉션)에 &lt;code&gt;f&lt;/code&gt; 를 매핑 합니다. 여러 콜렉션 인수의 경우 &lt;code&gt;f&lt;/code&gt; 가 요소 단위로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaf90400780ceb1859683501af570570487d3f2" translate="yes" xml:space="preserve">
          <source>Uses of non-constant globals can be optimized by annotating their types at the point of use:</source>
          <target state="translated">일정하지 않은 전역의 사용은 사용 시점에 유형에 주석을 달아 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="688afb99bff61a9584ff045ba5eb7014ef89e708" translate="yes" xml:space="preserve">
          <source>Using &quot;outside&quot; variables in parallel loops is perfectly reasonable if the variables are read-only:</source>
          <target state="translated">변수가 읽기 전용 인 경우 병렬 루프에서 &quot;외부&quot;변수를 사용하는 것이 매우 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="0e688a58936b31583f452f63485c5d5aac4efae6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@inbounds&lt;/code&gt; may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use &lt;code&gt;@inbounds&lt;/code&gt; when it is certain from the information locally available that all accesses are in bounds.</source>
          <target state="translated">&lt;code&gt;@inbounds&lt;/code&gt; 를 사용하면 범위를 벗어난 지수에 대해 잘못된 결과 / 충돌 / 손상을 반환 할 수 있습니다. 사용자는 수동으로 확인해야합니다. &lt;code&gt;@inbounds&lt;/code&gt; 는 로컬에서 사용할 수있는 정보에서 확실하게 모든 액세스가 범위 내에있는 경우 에만 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="d5bc6baeeb67dcbf6611dff279c2c4eee51ea334" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;begin&lt;/code&gt; in an indexing expression to refer to the first index requires at least Julia 1.5.</source>
          <target state="translated">인덱싱 식에서 &lt;code&gt;begin&lt;/code&gt; 을 사용 하여 첫 번째 인덱스를 참조하려면 최소한 Julia 1.5가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e537d4f221185177f4eaa3de9c5f176d574cec48" translate="yes" xml:space="preserve">
          <source>Using Loggers</source>
          <target state="translated">로거 사용</target>
        </trans-unit>
        <trans-unit id="4594347fb664dcf4c2e1f34027a9288d5babb1f4" translate="yes" xml:space="preserve">
          <source>Using an index less than 1 or greater than &lt;code&gt;end&lt;/code&gt; raises an error:</source>
          <target state="translated">1보다 작거나 &lt;code&gt;end&lt;/code&gt; 보다 큰 색인을 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fd6e027b6c0183a57f969b2f0c1a67224243a456" translate="yes" xml:space="preserve">
          <source>Using an index less than &lt;code&gt;begin&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) or greater than &lt;code&gt;end&lt;/code&gt; raises an error:</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 보다 작거나 ( &lt;code&gt;1&lt;/code&gt; ) &lt;code&gt;end&lt;/code&gt; 보다 큰 인덱스를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6956b3efd735f97450c62b06daef893328f716ca" translate="yes" xml:space="preserve">
          <source>Using distinct algorithms for scalar or array generation</source>
          <target state="translated">스칼라 또는 배열 생성에 고유 한 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="d0c7e17c286ccbac76a5a27970a8f4dc4a2438ec" translate="yes" xml:space="preserve">
          <source>Using julia-config to automatically determine build parameters</source>
          <target state="translated">julia-config를 사용하여 빌드 매개 변수 자동 결정</target>
        </trans-unit>
        <trans-unit id="6c6ec39234314353f60f2f3bfa4894a480f5bb32" translate="yes" xml:space="preserve">
          <source>Using resources of &lt;code&gt;x&lt;/code&gt; which would be cleaned up in the finalizer.</source>
          <target state="translated">종료 자 에서 정리 될 &lt;code&gt;x&lt;/code&gt; 의 리소스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8d40e4dac1bcd568d35cfc3572f2a015fc1c1052" translate="yes" xml:space="preserve">
          <source>Using semicolons (or newlines) and spaces (or tabs) can be combined to concatenate both horizontally and vertically at the same time.</source>
          <target state="translated">세미콜론 (또는 줄 바꿈)과 공백 (또는 탭)을 사용하여 동시에 가로 및 세로로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf9f6136824ad4f2ee2bbca487125e42112f823" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#LibGit2.GitRevWalker&quot;&gt;&lt;code&gt;GitRevWalker&lt;/code&gt;&lt;/a&gt;&lt;code&gt;walker&lt;/code&gt; to &quot;walk&quot; over every commit in the repository's history, apply &lt;code&gt;f&lt;/code&gt; to each commit in the walk. The keyword arguments are: * &lt;code&gt;oid&lt;/code&gt;: The &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the commit to begin the walk from. The default is to use &lt;a href=&quot;#LibGit2.push_head!&quot;&gt;&lt;code&gt;push_head!&lt;/code&gt;&lt;/a&gt; and therefore the HEAD commit and all its ancestors. * &lt;code&gt;range&lt;/code&gt;: A range of &lt;code&gt;GitHash&lt;/code&gt;s in the format &lt;code&gt;oid1..oid2&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; will be applied to all commits between the two. * &lt;code&gt;by&lt;/code&gt;: The sorting method. The default is not to sort. Other options are to sort by topology (&lt;code&gt;LibGit2.Consts.SORT_TOPOLOGICAL&lt;/code&gt;), to sort forwards in time (&lt;code&gt;LibGit2.Consts.SORT_TIME&lt;/code&gt;, most ancient first) or to sort backwards in time (&lt;code&gt;LibGit2.Consts.SORT_REVERSE&lt;/code&gt;, most recent first). * &lt;code&gt;rev&lt;/code&gt;: Whether to reverse the sorted order (for instance, if topological sorting is used).</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitRevWalker&quot;&gt; &lt;code&gt;GitRevWalker&lt;/code&gt; &lt;/a&gt; &lt;code&gt;walker&lt;/code&gt; 를 사용하여 저장소 히스토리의 모든 커밋을 &quot;보행&quot; 하여 워크의 각 커밋에 &lt;code&gt;f&lt;/code&gt; 를 적용 하십시오. 키워드 인수는 다음과 같습니다. * &lt;code&gt;oid&lt;/code&gt; : 걸음을 시작하는 커밋 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 기본값은 &lt;a href=&quot;#LibGit2.push_head!&quot;&gt; &lt;code&gt;push_head!&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다! 따라서 HEAD 커밋과 모든 조상. * &lt;code&gt;range&lt;/code&gt; :의 범위 &lt;code&gt;GitHash&lt;/code&gt; 는 형식 입력 S &lt;code&gt;oid1..oid2&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 는 둘 사이의 모든 커밋에 적용됩니다. * &lt;code&gt;by&lt;/code&gt; : 정렬 방법. 기본값은 정렬하지 않는 것입니다. 다른 옵션은 토폴로지별로 정렬하는 것입니다 ( &lt;code&gt;LibGit2.Consts.SORT_TOPOLOGICAL&lt;/code&gt; ), 시간 &lt;code&gt;LibGit2.Consts.SORT_TIME&lt;/code&gt; 으로 정렬 ( LibGit2.Consts.SORT_TIME , 가장 오래된 것부터 ) 또는 시간 &lt;code&gt;LibGit2.Consts.SORT_REVERSE&lt;/code&gt; 으로 정렬 ( LibGit2.Consts.SORT_REVERSE , 가장 최근의 것). * &lt;code&gt;rev&lt;/code&gt; : (위상 정렬을 사용하는 경우, 예를 들어) 여부가 정렬 된 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="6ec4842754e5953917652390962c1ff76956e408" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#LibGit2.GitRevWalker&quot;&gt;&lt;code&gt;GitRevWalker&lt;/code&gt;&lt;/a&gt;&lt;code&gt;walker&lt;/code&gt; to &quot;walk&quot; over every commit in the repository's history, find the number of commits which return &lt;code&gt;true&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; is applied to them. The keyword arguments are: * &lt;code&gt;oid&lt;/code&gt;: The &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; of the commit to begin the walk from. The default is to use &lt;a href=&quot;#LibGit2.push_head!&quot;&gt;&lt;code&gt;push_head!&lt;/code&gt;&lt;/a&gt; and therefore the HEAD commit and all its ancestors. * &lt;code&gt;by&lt;/code&gt;: The sorting method. The default is not to sort. Other options are to sort by topology (&lt;code&gt;LibGit2.Consts.SORT_TOPOLOGICAL&lt;/code&gt;), to sort forwards in time (&lt;code&gt;LibGit2.Consts.SORT_TIME&lt;/code&gt;, most ancient first) or to sort backwards in time (&lt;code&gt;LibGit2.Consts.SORT_REVERSE&lt;/code&gt;, most recent first). * &lt;code&gt;rev&lt;/code&gt;: Whether to reverse the sorted order (for instance, if topological sorting is used).</source>
          <target state="translated">&lt;a href=&quot;#LibGit2.GitRevWalker&quot;&gt; &lt;code&gt;GitRevWalker&lt;/code&gt; &lt;/a&gt; &lt;code&gt;walker&lt;/code&gt; 를 사용하여 저장소 히스토리의 모든 커밋을 &quot;통과&quot;하여 &lt;code&gt;f&lt;/code&gt; 가 적용될 때 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 커밋 수를 찾으십시오 . 키워드 인수는 다음과 같습니다. * &lt;code&gt;oid&lt;/code&gt; : 걸음을 시작하는 커밋 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;기본값은 &lt;a href=&quot;#LibGit2.push_head!&quot;&gt; &lt;code&gt;push_head!&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다! 따라서 HEAD 커밋과 모든 조상. * &lt;code&gt;by&lt;/code&gt; : 정렬 방법. 기본값은 정렬하지 않는 것입니다. 다른 옵션은 토폴로지 ( &lt;code&gt;LibGit2.Consts.SORT_TOPOLOGICAL&lt;/code&gt; ) 별로 정렬하고 시간 &lt;code&gt;LibGit2.Consts.SORT_TIME&lt;/code&gt; 으로 정렬하는 것입니다 ( LibGit2.Consts.SORT_TIME &lt;code&gt;rev&lt;/code&gt; 하거나 , 가장 오래된 )하거나 으로 정렬하는 것입니다 ( &lt;code&gt;LibGit2.Consts.SORT_REVERSE&lt;/code&gt; , 가장 최근의 첫 번째). *: 정렬 순서를 반대로할지 여부 (예 : 토폴로지 정렬을 사용하는 경우)</target>
        </trans-unit>
        <trans-unit id="c413028736212fe9357e9b5b1dc5c398cc081dcd" translate="yes" xml:space="preserve">
          <source>Using the project Properties dialog, go to &lt;code&gt;C/C++&lt;/code&gt; | &lt;code&gt;General&lt;/code&gt; and add &lt;code&gt;$(JULIA_DIR)\include\julia\&lt;/code&gt; to the Additional Include Directories property. Then, go to the &lt;code&gt;Linker&lt;/code&gt; | &lt;code&gt;General&lt;/code&gt; section and add &lt;code&gt;$(JULIA_DIR)\lib&lt;/code&gt; to the Additional Library Directories property. Finally, under &lt;code&gt;Linker&lt;/code&gt; | &lt;code&gt;Input&lt;/code&gt;, add &lt;code&gt;libjulia.dll.a;libopenlibm.dll.a;&lt;/code&gt; to the list of libraries.</source>
          <target state="translated">프로젝트 속성 대화 상자를 사용하여 &lt;code&gt;C/C++&lt;/code&gt; | &lt;code&gt;General&lt;/code&gt; 및 &lt;code&gt;$(JULIA_DIR)\include\julia\&lt;/code&gt; 를 추가 포함 디렉토리 특성에 추가하십시오. 그런 다음 &lt;code&gt;Linker&lt;/code&gt; | &lt;code&gt;General&lt;/code&gt; 섹션에서 &lt;code&gt;$(JULIA_DIR)\lib&lt;/code&gt; 를 추가 라이브러리 디렉토리 특성에 추가하십시오. 마지막으로 &lt;code&gt;Linker&lt;/code&gt; | &lt;code&gt;Input&lt;/code&gt; 하고 &lt;code&gt;libjulia.dll.a;libopenlibm.dll.a;&lt;/code&gt; 추가하십시오 . 도서관 목록에.</target>
        </trans-unit>
        <trans-unit id="8486afb99169a641f479a3a3c9bb4fcde8005d8e" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;begin&lt;/code&gt; will not be necessary, since keywords such as &lt;a href=&quot;#function&quot;&gt;&lt;code&gt;function&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; implicitly begin blocks of code. See also &lt;a href=&quot;#;&quot;&gt;&lt;code&gt;;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#function&quot;&gt; &lt;code&gt;function&lt;/code&gt; &lt;/a&gt; 과 같은 키워드 &lt;a href=&quot;#let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 암시 적으로 코드 블록을 시작 하므로 일반적으로 &lt;code&gt;begin&lt;/code&gt; 은 필요하지 않습니다 . 또한보십시오 &lt;a href=&quot;#;&quot;&gt; &lt;code&gt;;&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="32aeab02a74532020ea8342a8515157c825ef703" translate="yes" xml:space="preserve">
          <source>Usually a function has 4 methods defined, one each for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;ComplexF64&lt;/code&gt; and &lt;code&gt;ComplexF32&lt;/code&gt; arrays.</source>
          <target state="translated">일반적으로 함수에는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;ComplexF64&lt;/code&gt; 및 &lt;code&gt;ComplexF32&lt;/code&gt; 배열에 각각 하나씩 4 개의 메소드가 정의 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67e26c63c1724df60d067a3aaa25a98d5abbf4a" translate="yes" xml:space="preserve">
          <source>Utilities for capturing, filtering and presenting streams of log events. Normally you don't need to import &lt;code&gt;Logging&lt;/code&gt; to create log events; for this the standard logging macros such as &lt;code&gt;@info&lt;/code&gt; are already exported by &lt;code&gt;Base&lt;/code&gt; and available by default.</source>
          <target state="translated">로그 이벤트 스트림을 캡처, 필터링 및 표시하기위한 유틸리티 일반적으로 로그 이벤트를 작성하기 위해 &lt;code&gt;Logging&lt;/code&gt; 을 가져올 필요는 없습니다 . 이를 위해 다음과 같은 표준 로깅 매크로 &lt;code&gt;@info&lt;/code&gt; 은 이미 내 보낸 &lt;code&gt;Base&lt;/code&gt; 와 기본적으로 사용할.</target>
        </trans-unit>
        <trans-unit id="6a681da6b0fa29ce81a94277f5bd3f0a9276fbf0" translate="yes" xml:space="preserve">
          <source>Utility Collections</source>
          <target state="translated">유틸리티 컬렉션</target>
        </trans-unit>
        <trans-unit id="d8041011401dc800a6ef88f382bc39cf1b615aba" translate="yes" xml:space="preserve">
          <source>V (vector)</source>
          <target state="translated">V (벡터)</target>
        </trans-unit>
        <trans-unit id="18ba99a2e2b417b08555df0928741485f7c523bd" translate="yes" xml:space="preserve">
          <source>V (vectors)</source>
          <target state="translated">V (벡터)</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="66771bf9a86898929e11d8280264a532271f941a" translate="yes" xml:space="preserve">
          <source>Val</source>
          <target state="translated">Val</target>
        </trans-unit>
        <trans-unit id="08dd90402b12e9c88291ba119e611cc5ba9ab615" translate="yes" xml:space="preserve">
          <source>Valid rounding modes for &lt;code&gt;round(::Period, ::T, ::RoundingMode)&lt;/code&gt; are &lt;code&gt;RoundNearestTiesUp&lt;/code&gt; (default), &lt;code&gt;RoundDown&lt;/code&gt; (&lt;code&gt;floor&lt;/code&gt;), and &lt;code&gt;RoundUp&lt;/code&gt; (&lt;code&gt;ceil&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;round(::Period, ::T, ::RoundingMode)&lt;/code&gt; 유효한 반올림 모드 는 &lt;code&gt;RoundNearestTiesUp&lt;/code&gt; (기본값), &lt;code&gt;RoundDown&lt;/code&gt; ( &lt;code&gt;floor&lt;/code&gt; ) 및 &lt;code&gt;RoundUp&lt;/code&gt; ( &lt;code&gt;ceil&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="e229542993641075d277cab335befb1ae3dc141e" translate="yes" xml:space="preserve">
          <source>Valid rounding modes for &lt;code&gt;round(::TimeType, ::Period, ::RoundingMode)&lt;/code&gt; are &lt;code&gt;RoundNearestTiesUp&lt;/code&gt; (default), &lt;code&gt;RoundDown&lt;/code&gt; (&lt;code&gt;floor&lt;/code&gt;), and &lt;code&gt;RoundUp&lt;/code&gt; (&lt;code&gt;ceil&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;round(::TimeType, ::Period, ::RoundingMode)&lt;/code&gt; 유효한 반올림 모드 는 &lt;code&gt;RoundNearestTiesUp&lt;/code&gt; (기본값), &lt;code&gt;RoundDown&lt;/code&gt; ( &lt;code&gt;floor&lt;/code&gt; ) 및 &lt;code&gt;RoundUp&lt;/code&gt; ( &lt;code&gt;ceil&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="1177a18f70b2bb097f1359141743708a01d953b5" translate="yes" xml:space="preserve">
          <source>Value (Int)</source>
          <target state="translated">값 (Int)</target>
        </trans-unit>
        <trans-unit id="a746d4614f2c8d263b81621b92d48c15618301c7" translate="yes" xml:space="preserve">
          <source>Value returned by &lt;code&gt;IteratorEltype(IterType)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IteratorEltype(IterType)&lt;/code&gt; 리턴 한 값</target>
        </trans-unit>
        <trans-unit id="696aa1f3090aa306169dbbcd87d65ab566c6fb8e" translate="yes" xml:space="preserve">
          <source>Value returned by &lt;code&gt;IteratorSize(IterType)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IteratorSize(IterType)&lt;/code&gt; 돌려주는 값</target>
        </trans-unit>
        <trans-unit id="8dbeffeaf7d26e3574474d9149c27ff30a4b3dcd" translate="yes" xml:space="preserve">
          <source>Values can also be specified inside a &lt;code&gt;begin&lt;/code&gt; block, e.g.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 블록 내에서 값을 지정할 수도 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="58b8d8e0cc20bd561990f4bb053e439ba7b1a7a6" translate="yes" xml:space="preserve">
          <source>Values can be converted to &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; easily:</source>
          <target state="translated">값을 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; 로&lt;/a&gt; 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54fd969a40a4590a5e37b505ecdc00c8fcdea460" translate="yes" xml:space="preserve">
          <source>Values can be interpolated into &lt;code&gt;@async&lt;/code&gt; via &lt;code&gt;$&lt;/code&gt;, which copies the value directly into the constructed underlying closure. This allows you to insert the &lt;em&gt;value&lt;/em&gt; of a variable, isolating the aysnchronous code from changes to the variable's value in the current task.</source>
          <target state="translated">값은 &lt;code&gt;$&lt;/code&gt; 를 통해 &lt;code&gt;@async&lt;/code&gt; 로 보간 될 수 있으며 , 이는 값을 생성 된 기본 클로저에 직접 복사합니다. 이를 통해 변수 &lt;em&gt;값&lt;/em&gt; 을 삽입 하여 현재 작업의 변수 값 변경에서 비동기 코드를 분리 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b1cd2449da5e0e91d48452010ff76e262ea87fcd" translate="yes" xml:space="preserve">
          <source>Values can be interpolated into &lt;code&gt;@spawn&lt;/code&gt; via &lt;code&gt;$&lt;/code&gt;, which copies the value directly into the constructed underlying closure. This allows you to insert the &lt;em&gt;value&lt;/em&gt; of a variable, isolating the aysnchronous code from changes to the variable's value in the current task.</source>
          <target state="translated">값은 &lt;code&gt;$&lt;/code&gt; 를 통해 &lt;code&gt;@spawn&lt;/code&gt; 으로 보간 될 수 있으며 , 이는 값을 생성 된 기본 클로저에 직접 복사합니다. 이를 통해 변수 &lt;em&gt;값&lt;/em&gt; 을 삽입 하여 현재 작업의 변수 값 변경에서 비동기 코드를 분리 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddf483076f265858393b29ed989b1873d2e7a8e3" translate="yes" xml:space="preserve">
          <source>Values that are normally unordered, such as &lt;code&gt;NaN&lt;/code&gt;, are ordered in an arbitrary but consistent fashion. &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values are ordered last.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 과 같이 일반적으로 정렬되지 않은 값 은 임의적이지만 일관된 방식으로 정렬됩니다. &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 은 마지막에 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="03572b0c8598fe7cd07df82b0e9920bb7de722a3" translate="yes" xml:space="preserve">
          <source>Vararg Tuple Types</source>
          <target state="translated">Vararg 튜플 유형</target>
        </trans-unit>
        <trans-unit id="382fbc37c5cfb465437b195cd4bad0fff65a9b68" translate="yes" xml:space="preserve">
          <source>Varargs Functions</source>
          <target state="translated">Varargs 함수</target>
        </trans-unit>
        <trans-unit id="47b78c15d0fa2b4ea4d1d2b05e8208800687165c" translate="yes" xml:space="preserve">
          <source>Varargs are supported with the following convention:</source>
          <target state="translated">Varargs는 다음 규칙으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="df9191935912f85d859043667e9941151178e6c8" translate="yes" xml:space="preserve">
          <source>Variable names must begin with a letter (A-Z or a-z), underscore, or a subset of Unicode code points greater than 00A0; in particular, &lt;a href=&quot;http://www.fileformat.info/info/unicode/category/index.htm&quot;&gt;Unicode character categories&lt;/a&gt; Lu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and other symbols), and a few other letter-like characters (e.g. a subset of the Sm math symbols) are allowed. Subsequent characters may also include ! and digits (0-9 and other characters in categories Nd/No), as well as other Unicode code points: diacritics and other modifying marks (categories Mn/Mc/Me/Sk), some punctuation connectors (category Pc), primes, and a few other characters.</source>
          <target state="translated">변수 이름은 문자 (AZ 또는 az), 밑줄 또는 00A0보다 큰 유니 코드 코드 포인트의 하위 집합으로 시작해야합니다. 특히, &lt;a href=&quot;http://www.fileformat.info/info/unicode/category/index.htm&quot;&gt;유니 코드 문자 범주&lt;/a&gt; Lu / Ll / Lt / Lm / Lo / Nl (문자), Sc / So (통화 및 기타 기호) 및 몇 가지 다른 문자와 유사한 문자 (예 : Sm 수학 기호의 하위 집합) 허용됩니다. 후속 문자에는!가 포함될 수도 있습니다. 및 숫자 (0-9 및 Nd / No 범주의 다른 문자) 및 기타 유니 코드 코드 포인트 : 분음 부호 및 기타 수정 표시 (범주 Mn / Mc / Me / Sk), 일부 문장 부호 커넥터 (범주 Pc), 소수, 그리고 다른 캐릭터들.</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="973c98f8ec2704255a1037ca6cefd4104098ec96" translate="yes" xml:space="preserve">
          <source>Variables can also have lower bounds:</source>
          <target state="translated">변수는 하한을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6312673cd4e08ae646a5dc5b0fa180b46d3ef898" translate="yes" xml:space="preserve">
          <source>Variant of &lt;a href=&quot;#Base.Sort.partialsort!&quot;&gt;&lt;code&gt;partialsort!&lt;/code&gt;&lt;/a&gt; which copies &lt;code&gt;v&lt;/code&gt; before partially sorting it, thereby returning the same thing as &lt;code&gt;partialsort!&lt;/code&gt; but leaving &lt;code&gt;v&lt;/code&gt; unmodified.</source>
          <target state="translated">&lt;a href=&quot;#Base.Sort.partialsort!&quot;&gt; &lt;code&gt;partialsort!&lt;/code&gt; &lt;/a&gt; 변형 ! &lt;code&gt;v&lt;/code&gt; 는 부분적으로 정렬하기 전에 v 를 복사 하여 &lt;code&gt;partialsort!&lt;/code&gt; 와 같은 것을 반환합니다 ! &lt;code&gt;v&lt;/code&gt; 는 수정 하지 않고 그대로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="ea0d65af26fddc33c72a84dbe68995163f1d5904" translate="yes" xml:space="preserve">
          <source>Variant of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt; that returns a sorted copy of &lt;code&gt;v&lt;/code&gt; leaving &lt;code&gt;v&lt;/code&gt; itself unmodified.</source>
          <target state="translated">&lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; 변종 ! &lt;code&gt;v&lt;/code&gt; 자체를 수정하지 않은 채로 정렬 된 &lt;code&gt;v&lt;/code&gt; 사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="099e0303f2658cdf82256a3185bfb0c3094bde80" translate="yes" xml:space="preserve">
          <source>Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;Multi-dimensional Arrays&lt;/a&gt;).</source>
          <target state="translated">다양한 유형의 반복 가능한 컨테이너가 매뉴얼의 뒷부분에서 소개되고 논의 될 것입니다 (예 : &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;다차원 배열 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc6ba2473e2753b36bcc2d690f41319c47e7d4f9" translate="yes" xml:space="preserve">
          <source>Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;Multi-dimensional Arrays&lt;/a&gt;).</source>
          <target state="translated">다양한 유형의 반복 가능한 컨테이너가 설명서의 뒷부분에서 소개되고 논의됩니다 (예 : &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;다차원 배열 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f625899326d51a58569ee688860f4767ebf2e302" translate="yes" xml:space="preserve">
          <source>VecOrMat</source>
          <target state="translated">VecOrMat</target>
        </trans-unit>
        <trans-unit id="a57e06f45491067f031284fb03d3a20a0abf04fd" translate="yes" xml:space="preserve">
          <source>Vector</source>
          <target state="translated">Vector</target>
        </trans-unit>
        <trans-unit id="e681c39f4e2c29eed8261e191272b7fca77a9c4b" translate="yes" xml:space="preserve">
          <source>Vector Or Cross Product</source>
          <target state="translated">벡터 또는 교차 제품</target>
        </trans-unit>
        <trans-unit id="ce239837ecd44e25f6f247a56fa730d6a4823074" translate="yes" xml:space="preserve">
          <source>Vector type for storing sparse vectors.</source>
          <target state="translated">희소 벡터를 저장하기위한 벡터 유형.</target>
        </trans-unit>
        <trans-unit id="8bbbd2eeb202ade49225a4f2e7942a3447ab3322" translate="yes" xml:space="preserve">
          <source>Vector()</source>
          <target state="translated">Vector()</target>
        </trans-unit>
        <trans-unit id="13b136054b35a3cebfee1d05d794ba71cbd26cf1" translate="yes" xml:space="preserve">
          <source>Vectorized &quot;dot&quot; operators</source>
          <target state="translated">벡터화 된 &quot;점&quot;연산자</target>
        </trans-unit>
        <trans-unit id="bc9291e5dce9436485c2013f50e2ce1162733428" translate="yes" xml:space="preserve">
          <source>Vectors and multidimensional arrays of integers</source>
          <target state="translated">정수로 구성된 벡터 및 다차원 배열</target>
        </trans-unit>
        <trans-unit id="9b7af30a2daf7acc8dfa153d97b4943cb1e0d136" translate="yes" xml:space="preserve">
          <source>Verifies that a credential is ready for use in authentication.</source>
          <target state="translated">자격 증명이 인증에 사용할 준비가되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cc0c6486c895f3039458f341e76e91cb7780448a" translate="yes" xml:space="preserve">
          <source>Version Number Literals</source>
          <target state="translated">버전 번호 리터럴</target>
        </trans-unit>
        <trans-unit id="840940d2b34c4d5b1ded250105162a1f63ce0844" translate="yes" xml:space="preserve">
          <source>Version number type which follow the specifications of &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also &lt;a href=&quot;#Base.@v_str&quot;&gt;&lt;code&gt;@v_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://semver.org/&quot;&gt;시맨틱 버전 관리&lt;/a&gt; 사양을 따르는 버전 번호 유형 으로, 주요, 부 및 패치 숫자 값으로 구성되며 시험판 ​​및 빌드 영숫자 주석이 뒤 따릅니다. &lt;a href=&quot;#Base.@v_str&quot;&gt; &lt;code&gt;@v_str&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a725950201de2fb1ac976f520070a65a2e88a90c" translate="yes" xml:space="preserve">
          <source>Version numbers can easily be expressed with non-standard string literals of the form &lt;a href=&quot;../../base/base/index#Base.@v_str&quot;&gt;&lt;code&gt;v&quot;...&quot;&lt;/code&gt;&lt;/a&gt;. Version number literals create &lt;a href=&quot;../../base/base/index#Base.VersionNumber&quot;&gt;&lt;code&gt;VersionNumber&lt;/code&gt;&lt;/a&gt; objects which follow the specifications of &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;, and therefore are composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. For example, &lt;code&gt;v&quot;0.2.1-rc1+win64&quot;&lt;/code&gt; is broken into major version &lt;code&gt;0&lt;/code&gt;, minor version &lt;code&gt;2&lt;/code&gt;, patch version &lt;code&gt;1&lt;/code&gt;, pre-release &lt;code&gt;rc1&lt;/code&gt; and build &lt;code&gt;win64&lt;/code&gt;. When entering a version literal, everything except the major version number is optional, therefore e.g. &lt;code&gt;v&quot;0.2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;v&quot;0.2.0&quot;&lt;/code&gt; (with empty pre-release/build annotations), &lt;code&gt;v&quot;2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;v&quot;2.0.0&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">버전 번호는 &lt;a href=&quot;../../base/base/index#Base.@v_str&quot;&gt; &lt;code&gt;v&quot;...&quot;&lt;/code&gt; &lt;/a&gt; 형식의 비표준 문자열 리터럴로 쉽게 표현할 수 있습니다 . 버전 번호 리터럴 은 &lt;a href=&quot;https://semver.org/&quot;&gt;시맨틱 버전 지정&lt;/a&gt; 사양을 따르는 &lt;a href=&quot;../../base/base/index#Base.VersionNumber&quot;&gt; &lt;code&gt;VersionNumber&lt;/code&gt; &lt;/a&gt; 객체를 작성 하므로 주, 부 및 패치 숫자 값으로 구성되고 시험판 및 빌드 영숫자 주석으로 구성됩니다. 예를 들어, &lt;code&gt;v&quot;0.2.1-rc1+win64&quot;&lt;/code&gt; 는 주요 버전 &lt;code&gt;0&lt;/code&gt; , 부 버전 &lt;code&gt;2&lt;/code&gt; , 패치 버전 &lt;code&gt;1&lt;/code&gt; , 시험판 &lt;code&gt;rc1&lt;/code&gt; 및 빌드 &lt;code&gt;win64&lt;/code&gt; 로 나뉩니다 . 버전 리터럴을 입력 할 때 주 버전 번호를 제외한 모든 항목은 선택 사항이므로 &lt;code&gt;v&quot;0.2&quot;&lt;/code&gt; 에 해당 &lt;code&gt;v&quot;0.2.0&quot;&lt;/code&gt; (빈 시험판 / 빌드 주석), &lt;code&gt;v&quot;2&quot;&lt;/code&gt; 에 해당 &lt;code&gt;v&quot;2.0.0&quot;&lt;/code&gt; , 등등.</target>
        </trans-unit>
        <trans-unit id="74ca9be91c967075fcdd2bbc6d1263539be41f2a" translate="yes" xml:space="preserve">
          <source>VersionNumber</source>
          <target state="translated">VersionNumber</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="6c837db00b975f19f0ba6c749c7f02fb45a75996" translate="yes" xml:space="preserve">
          <source>Vertical Bar Beside Right Triangle</source>
          <target state="translated">오른쪽 삼각형 옆에 세로 막대</target>
        </trans-unit>
        <trans-unit id="a468f19138c967f465d18bb3d4e19b98f3336def" translate="yes" xml:space="preserve">
          <source>Vertical Bar Beside Right Triangle + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">오른쪽 삼각형 옆의 세로 막대 + 긴 솔리드 오버레이 / 비 간격 긴 슬래시 ​​오버레이 결합</target>
        </trans-unit>
        <trans-unit id="d0c79970994459f8933a235bb69e83cc040e00e6" translate="yes" xml:space="preserve">
          <source>Vertical Bar Double Left Turnstile</source>
          <target state="translated">수직 바 더블 좌측 십자형 회전식 문</target>
        </trans-unit>
        <trans-unit id="3a4b1492c64df3b0ebe959084058d3c7e44acaf3" translate="yes" xml:space="preserve">
          <source>Vertical Ellipsis</source>
          <target state="translated">세로 줄임표</target>
        </trans-unit>
        <trans-unit id="85654619bc65a9e5e4aa04358cadb455bde3f5f4" translate="yes" xml:space="preserve">
          <source>Vertical Traffic Light</source>
          <target state="translated">수직 신호등</target>
        </trans-unit>
        <trans-unit id="0fd57d0e0d51781315415bae3e4dcd95ee338231" translate="yes" xml:space="preserve">
          <source>Very Much Greater-Than / Very Much Greater Than</source>
          <target state="translated">매우 큼 /보다 훨씬 큼</target>
        </trans-unit>
        <trans-unit id="dcb7da13aed9121a1d37058fdbf6964b34d24029" translate="yes" xml:space="preserve">
          <source>Very Much Less-Than / Very Much Less Than</source>
          <target state="translated">매우 적음 / 매우 적음</target>
        </trans-unit>
        <trans-unit id="8b22dde6a21b3a00457b198409a5900843726950" translate="yes" xml:space="preserve">
          <source>Very few operations are defined on Colons directly; instead they are converted by &lt;a href=&quot;#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt; to an internal vector type (&lt;code&gt;Base.Slice&lt;/code&gt;) to represent the collection of indices they span before being used.</source>
          <target state="translated">콜론에 직접 정의 된 작업은 거의 없습니다. 대신 &lt;a href=&quot;#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; 에 의해 내부 벡터 형식 ( &lt;code&gt;Base.Slice&lt;/code&gt; )으로 변환되어 사용되기 전에 확장 된 인덱스 모음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76dfb3491d119e5519addb4c3e23e281cad05fa2" translate="yes" xml:space="preserve">
          <source>Vibration Mode</source>
          <target state="translated">진동 모드</target>
        </trans-unit>
        <trans-unit id="00416ac0206eeb19bcbdaefda8ab643c20b70d6c" translate="yes" xml:space="preserve">
          <source>Victory Hand</source>
          <target state="translated">승리의 손</target>
        </trans-unit>
        <trans-unit id="0cc4b58b439f3228d73765f0de7bf812cc9b4238" translate="yes" xml:space="preserve">
          <source>Video Camera</source>
          <target state="translated">비디오 카메라</target>
        </trans-unit>
        <trans-unit id="7f01866ab45271f0dfa12184523966d4a3b5815e" translate="yes" xml:space="preserve">
          <source>Video Game</source>
          <target state="translated">비디오 게임</target>
        </trans-unit>
        <trans-unit id="2c80f0cab4afba2fa27c199aefcd29cf64ce8dbf" translate="yes" xml:space="preserve">
          <source>Videocassette</source>
          <target state="translated">Videocassette</target>
        </trans-unit>
        <trans-unit id="9568ab6197c20797ef7250c030ffac3b0cf028d7" translate="yes" xml:space="preserve">
          <source>Viewdata Square</source>
          <target state="translated">뷰 데이터 광장</target>
        </trans-unit>
        <trans-unit id="ed1e68321de928793ee07ea5fe03956e64af46bb" translate="yes" xml:space="preserve">
          <source>Viewing a stack trace</source>
          <target state="translated">스택 추적보기</target>
        </trans-unit>
        <trans-unit id="5e0bd50fdb165ff5eea765ea67ef0112f77cca8d" translate="yes" xml:space="preserve">
          <source>Views (SubArrays and other view types)</source>
          <target state="translated">뷰 (하위 배열 및 기타 뷰 유형)</target>
        </trans-unit>
        <trans-unit id="c64d3409dcdd8152fa3df75455bfc567c1050921" translate="yes" xml:space="preserve">
          <source>Violin</source>
          <target state="translated">Violin</target>
        </trans-unit>
        <trans-unit id="0f6f6df133ed6ac243cb306e16b3c97677996488" translate="yes" xml:space="preserve">
          <source>Virgo</source>
          <target state="translated">Virgo</target>
        </trans-unit>
        <trans-unit id="310ab3071155ff081bc588d8dce0840f2c1db5b6" translate="yes" xml:space="preserve">
          <source>Visit this &lt;a href=&quot;https://julialang.org/blog/2019/07/multithreading/&quot;&gt;blog post&lt;/a&gt; for a presentation of Julia multi-threading features.</source>
          <target state="translated">Julia 멀티 스레딩 기능에 대한 프레젠테이션을 보려면 이 &lt;a href=&quot;https://julialang.org/blog/2019/07/multithreading/&quot;&gt;블로그 게시물&lt;/a&gt; 을 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studio 코드</target>
        </trans-unit>
        <trans-unit id="8ea2c5b5f236297f327f1c4b74f3faa6e41a0626" translate="yes" xml:space="preserve">
          <source>Volcano</source>
          <target state="translated">Volcano</target>
        </trans-unit>
        <trans-unit id="3435bdb02b0cd637470f09185300f98914ecbabf" translate="yes" xml:space="preserve">
          <source>Volume Integral</source>
          <target state="translated">볼륨 적분</target>
        </trans-unit>
        <trans-unit id="4a22d4b48472fa25ad58e33b26aad65175777536" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Five Eighths / Fraction Five Eighths</source>
          <target state="translated">불분명 분수 5 분의 8 / 분수 5 분의 8</target>
        </trans-unit>
        <trans-unit id="2ffaa1b3f0a7068587451e32ec2d77c7b9fca7af" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Five Sixths / Fraction Five Sixths</source>
          <target state="translated">저속 분수 5 분의 1 / 분수 5 분의 1</target>
        </trans-unit>
        <trans-unit id="e4f79cd34a21bf7565ffa9564108d106398b89f9" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Four Fifths / Fraction Four Fifths</source>
          <target state="translated">저속 분수 4 분의 1 / 분수 4 분의 5</target>
        </trans-unit>
        <trans-unit id="de91e6ed7b9551ac836b4b7620665dd412d396bc" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Eighth / Fraction One Eighth</source>
          <target state="translated">불릿 분수 하나 여덟 / 분수 하나 여덟</target>
        </trans-unit>
        <trans-unit id="73a5459d60b79f176337ca7f2581a21e48217ad1" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Fifth / Fraction One Fifth</source>
          <target state="translated">Vulgar Fraction 1/5 / 분수 1/5</target>
        </trans-unit>
        <trans-unit id="a03faa6cb45424752e687589d775c2e7ca16d904" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Half / Fraction One Half</source>
          <target state="translated">저속한 분수 절반 / 분수 절반</target>
        </trans-unit>
        <trans-unit id="4a49020d16507f59e732507c20917b4f04877588" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Ninth</source>
          <target state="translated">불분명 분수 9 분의 1</target>
        </trans-unit>
        <trans-unit id="fc2cd9a24a1b8820b1de3f240e0c733e1b2cb00f" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Quarter / Fraction One Quarter</source>
          <target state="translated">Vulgar Fraction 1 Quarter / 분수 1 쿼터</target>
        </trans-unit>
        <trans-unit id="c3dc27da6531a07b9639c96eeb57f3c6166b854d" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Seventh</source>
          <target state="translated">저속한 분수 하나 일곱 번째</target>
        </trans-unit>
        <trans-unit id="a5b497ee93232519615401c8f274683da6ac9e31" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Sixth / Fraction One Sixth</source>
          <target state="translated">불릿 분수 1/6 / 분수 1/6</target>
        </trans-unit>
        <trans-unit id="ada7f7ea5dfbd4c19ba9c3e580d06159c80a1e52" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Tenth</source>
          <target state="translated">불가 분수 분율 1/10</target>
        </trans-unit>
        <trans-unit id="4fe9918b0f58d14d507e3c3ac80d2abe0b2b2c00" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction One Third / Fraction One Third</source>
          <target state="translated">저속 분수 1/3 / 분수 1/3</target>
        </trans-unit>
        <trans-unit id="533f02ec1b18beabada67383f82de17ba9397a9f" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Seven Eighths / Fraction Seven Eighths</source>
          <target state="translated">불분명 분수 일곱 여덟 / 분수 일곱 여덟</target>
        </trans-unit>
        <trans-unit id="772183d1aa4241b593aae736d3517cb349b6502d" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Three Eighths / Fraction Three Eighths</source>
          <target state="translated">저속한 분수 3 8 분의 1 분율</target>
        </trans-unit>
        <trans-unit id="f41956a7c6db371ccf04a21004f0afd7c3fdfbb0" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Three Fifths / Fraction Three Fifths</source>
          <target state="translated">저속 분수 3 분의 3 / 분수 3 분의 5</target>
        </trans-unit>
        <trans-unit id="96bbd2d7245dd133a3f9a78e5320abff3ef4e207" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Three Quarters / Fraction Three Quarters</source>
          <target state="translated">불가 분수 3/4 분율</target>
        </trans-unit>
        <trans-unit id="e3ae2856dd94274c80a8e6426b4994dc2779632b" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Two Fifths / Fraction Two Fifths</source>
          <target state="translated">저속 분수 2 분의 5 / 분수 2 분의 5</target>
        </trans-unit>
        <trans-unit id="7fa906e09060606fdcb3fd3c63c507358187596c" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Two Thirds / Fraction Two Thirds</source>
          <target state="translated">저속 분수 2/3 / 분수 2/3</target>
        </trans-unit>
        <trans-unit id="924c01e5f46e201273bd64cb92dc787e33fcf371" translate="yes" xml:space="preserve">
          <source>Vulgar Fraction Zero Thirds</source>
          <target state="translated">저속 분수 제로 3 분의 1</target>
        </trans-unit>
        <trans-unit id="0746ad7fab8b17b9696764cb8215894c325800cd" translate="yes" xml:space="preserve">
          <source>Wait for a Task to finish, then return its result value. If the task fails with an exception, a &lt;code&gt;TaskFailedException&lt;/code&gt; (which wraps the failed task) is thrown.</source>
          <target state="translated">작업이 완료 될 때까지 기다린 다음 결과 값을 반환합니다. 작업이 예외와 함께 실패하면 &lt;code&gt;TaskFailedException&lt;/code&gt; (실패한 작업을 래핑)이 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="700756d9987ff8eb1bf98e15bdd0cb4f7b0b4c43" translate="yes" xml:space="preserve">
          <source>Wait for a Task to finish, then return its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called fetch).</source>
          <target state="translated">작업이 완료 될 때까지 기다린 다음 결과 값을 반환하십시오. 작업이 예외와 함께 실패하면 예외가 전파됩니다 (fetch를 호출 한 작업에서 다시 발생).</target>
        </trans-unit>
        <trans-unit id="673aefa6be6107ab62aedf7c032815d166f52464" translate="yes" xml:space="preserve">
          <source>Wait for a value to become available for the specified &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 값을 사용할 수있을 때까지 기다 립니다.</target>
        </trans-unit>
        <trans-unit id="8ead67a72786e6cde16e53095e4c792246b473f0" translate="yes" xml:space="preserve">
          <source>Wait for a value to become available on the specified &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에서 값을 사용할 수있을 때까지 기다 립니다 .</target>
        </trans-unit>
        <trans-unit id="a2da391139615691051e202fac8e36602c8d8b55" translate="yes" xml:space="preserve">
          <source>Wait for and get a value from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;. Exceptions raised are the same as for a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Does not remove the item fetched.</source>
          <target state="translated">기다렸다가 &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에서 값을 가져 옵니다 . 발생한 예외는 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 가져온 항목을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26af15450a38e48475b5ea5e4cb3ccfc6b0ebec8" translate="yes" xml:space="preserve">
          <source>Wait for and get a value from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;. Exceptions raised are the same as for a &lt;code&gt;Future&lt;/code&gt;. Does not remove the item fetched.</source>
          <target state="translated">대기하고 &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에서 값을 가져 옵니다 . 제기 된 예외는 &lt;code&gt;Future&lt;/code&gt; 와 동일 합니다. 가져온 항목을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f9cad1615350aa88fc30de4eb3475c1aec850b6" translate="yes" xml:space="preserve">
          <source>Wait for and get the first available item from the channel. Does not remove the item. &lt;code&gt;fetch&lt;/code&gt; is unsupported on an unbuffered (0-size) channel.</source>
          <target state="translated">채널에서 사용 가능한 첫 번째 항목을 기다립니다. 항목을 제거하지 않습니다. 버퍼링되지 않은 (0 크기) 채널에서는 &lt;code&gt;fetch&lt;/code&gt; 가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="352dbfcf93af85a3591da1d5ec38648c6abb53e1" translate="yes" xml:space="preserve">
          <source>Wait for and get the value of a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. The fetched value is cached locally. Further calls to &lt;code&gt;fetch&lt;/code&gt; on the same reference return the cached value. If the remote value is an exception, throws a &lt;a href=&quot;#Distributed.RemoteException&quot;&gt;&lt;code&gt;RemoteException&lt;/code&gt;&lt;/a&gt; which captures the remote exception and backtrace.</source>
          <target state="translated">기다렸다가 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 의 가치를 얻으십시오 . 가져온 값은 로컬로 캐시됩니다. 동일한 참조 에서 &lt;code&gt;fetch&lt;/code&gt; 하기위한 추가 호출 은 캐시 된 값을 리턴합니다. 원격 값이 예외 인 &lt;a href=&quot;#Distributed.RemoteException&quot;&gt; &lt;code&gt;RemoteException&lt;/code&gt; &lt;/a&gt; 원격 예외와 역 추적을 캡처 하는 RemoteException 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6b7b622d11b105cf23e49505960529494a392b04" translate="yes" xml:space="preserve">
          <source>Wait for one of the &lt;code&gt;sem_size&lt;/code&gt; permits to be available, blocking until one can be acquired.</source>
          <target state="translated">&lt;code&gt;sem_size&lt;/code&gt; 권한 중 하나를 사용할 수있을 때까지 기다렸다가 획득 할 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="a017114c4d0dd517c996d0a2c594edadea16c041" translate="yes" xml:space="preserve">
          <source>Wait until all lexically-enclosed uses of &lt;code&gt;@async&lt;/code&gt;, &lt;code&gt;@spawn&lt;/code&gt;, &lt;code&gt;@spawnat&lt;/code&gt; and &lt;code&gt;@distributed&lt;/code&gt; are complete. All exceptions thrown by enclosed async operations are collected and thrown as a &lt;code&gt;CompositeException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@async&lt;/code&gt; , &lt;code&gt;@spawn&lt;/code&gt; , &lt;code&gt;@spawnat&lt;/code&gt; 및 &lt;code&gt;@distributed&lt;/code&gt; 의 사 전적으로 동봉 된 사용 이 완료 될 때까지 기다리십시오 . 동봉 된 비동기 작업에서 발생하는 모든 예외는 &lt;code&gt;CompositeException&lt;/code&gt; 으로 수집되어 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="72fc4cb0feac4737de18649536c986d639721b93" translate="yes" xml:space="preserve">
          <source>Waiting tasks are woken after an initial delay of &lt;code&gt;delay&lt;/code&gt; seconds, and then repeating with the given &lt;code&gt;interval&lt;/code&gt; in seconds. If &lt;code&gt;interval&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;, the timer is only triggered once. When the timer is closed (by &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; waiting tasks are woken with an error. Use &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt;&lt;code&gt;isopen&lt;/code&gt;&lt;/a&gt; to check whether a timer is still active.</source>
          <target state="translated">대기 지연 작업은 &lt;code&gt;delay&lt;/code&gt; 초)이 처음 지연된 후 깨어 난 후 지정된 &lt;code&gt;interval&lt;/code&gt; (초)으로 반복됩니다 . 경우 &lt;code&gt;interval&lt;/code&gt; IS가 동일 &lt;code&gt;0&lt;/code&gt; , 타이머는 한 번만 실행됩니다. 타이머가 닫히면 ( &lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 대기 작업은 오류와 함께 깨어납니다. &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt; &lt;code&gt;isopen&lt;/code&gt; &lt;/a&gt; 을 사용 하여 타이머가 여전히 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1071d3e2d3b79d4d8bb7daf85adf19588062a6b7" translate="yes" xml:space="preserve">
          <source>Waiting tasks are woken and the function &lt;code&gt;callback&lt;/code&gt; is called after an initial delay of &lt;code&gt;delay&lt;/code&gt; seconds, and then repeating with the given &lt;code&gt;interval&lt;/code&gt; in seconds. If &lt;code&gt;interval&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;, the timer is only triggered once. The function &lt;code&gt;callback&lt;/code&gt; is called with a single argument, the timer itself. When the timer is closed (by &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; waiting tasks are woken with an error. Use &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt;&lt;code&gt;isopen&lt;/code&gt;&lt;/a&gt; to check whether a timer is still active.</source>
          <target state="translated">대기중인 작업이 시작되고 지연 &lt;code&gt;delay&lt;/code&gt; 초) 이 지연된 후 지정된 &lt;code&gt;interval&lt;/code&gt; (초)으로 반복 된 후 함수 &lt;code&gt;callback&lt;/code&gt; 이 호출 됩니다. 경우 &lt;code&gt;interval&lt;/code&gt; IS가 동일 &lt;code&gt;0&lt;/code&gt; , 타이머는 한 번만 실행됩니다. 함수 &lt;code&gt;callback&lt;/code&gt; 은 타이머 자체 인 단일 인수로 호출됩니다. 타이머가 닫히면 ( &lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 대기 작업은 오류와 함께 깨어납니다. &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt; &lt;code&gt;isopen&lt;/code&gt; &lt;/a&gt; 을 사용 하여 타이머가 여전히 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="384445ca71f292b1676c085911adc7efa7f44a24" translate="yes" xml:space="preserve">
          <source>Waits until &lt;code&gt;testcb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; or for &lt;code&gt;secs&lt;/code&gt; seconds, whichever is earlier. &lt;code&gt;testcb&lt;/code&gt; is polled every &lt;code&gt;pollint&lt;/code&gt; seconds.</source>
          <target state="translated">&lt;code&gt;testcb&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;secs&lt;/code&gt; 초 중 빠른 것을 반환 할 때까지 기다립니다 . &lt;code&gt;testcb&lt;/code&gt; 는 매 &lt;code&gt;pollint&lt;/code&gt; 초 마다 폴링됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a6f339c134e36072927cf0fd66259fb6ad6c909" translate="yes" xml:space="preserve">
          <source>Waits until &lt;code&gt;testcb&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; or for &lt;code&gt;timeout&lt;/code&gt; seconds, whichever is earlier. &lt;code&gt;testcb&lt;/code&gt; is polled every &lt;code&gt;pollint&lt;/code&gt; seconds. The minimum duration for &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;pollint&lt;/code&gt; is 1 millisecond or &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;testcb&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 또는 &lt;code&gt;timeout&lt;/code&gt; 초 중 빠른 시간 동안 기다립니다 . &lt;code&gt;testcb&lt;/code&gt; 는 &lt;code&gt;pollint&lt;/code&gt; 초 마다 폴링됩니다 . &lt;code&gt;timeout&lt;/code&gt; 및 &lt;code&gt;pollint&lt;/code&gt; 의 최소 ​​기간 은 1 밀리 초 또는 &lt;code&gt;0.001&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58fe2746e814a18dfed92008014ef09975c04f23" translate="yes" xml:space="preserve">
          <source>Wake up tasks waiting for a condition, passing them &lt;code&gt;val&lt;/code&gt;. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), all waiting tasks are woken, otherwise only one is. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the passed value is raised as an exception in the woken tasks.</source>
          <target state="translated">조건을 기다리는 작업을 일어나서 &lt;code&gt;val&lt;/code&gt; 을 전달합니다 . 경우 &lt;code&gt;all&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; (기본값), 모든 대기 중의 태스크 그렇지 않으면 하나는, 깨어 있습니다. 경우 &lt;code&gt;error&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 전달 된 값은 깨어 작업에서 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ab901b7e5b8bd4f885d9c6a8cbc8ae091c1b076" translate="yes" xml:space="preserve">
          <source>Waning Crescent Moon Symbol</source>
          <target state="translated">완잉 초승달 기호</target>
        </trans-unit>
        <trans-unit id="5ca89a5dd3637ddb705adb67e86886b8842de63a" translate="yes" xml:space="preserve">
          <source>Waning Gibbous Moon Symbol</source>
          <target state="translated">멍청한 멍청한 달 상징</target>
        </trans-unit>
        <trans-unit id="3009d557c90c919cd9d0ea8a12b75430344b5929" translate="yes" xml:space="preserve">
          <source>Warn</source>
          <target state="translated">Warn</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="b32fd871aad45a3830f5319cd5329b94c1730bca" translate="yes" xml:space="preserve">
          <source>Warning Sign</source>
          <target state="translated">경고 표시</target>
        </trans-unit>
        <trans-unit id="2e960da975b92f1fcb07b7378eb672fc07701597" translate="yes" xml:space="preserve">
          <source>Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or segmentation faults.</source>
          <target state="translated">경고 : 기본 스토리지가 실제로 스트 라이딩되지 않은 경우이 메소드를 구현하지 마십시오. 결과가 잘못되거나 세그먼트 화 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91ebf5887cf9ee3c9f843d1887a6d922dc78c46" translate="yes" xml:space="preserve">
          <source>Watch</source>
          <target state="translated">Watch</target>
        </trans-unit>
        <trans-unit id="95dfef8d44a4bee27fe25561a3c9c0487432f65b" translate="yes" xml:space="preserve">
          <source>Watch file or directory &lt;code&gt;path&lt;/code&gt; for changes until a change occurs or &lt;code&gt;timeout_s&lt;/code&gt; seconds have elapsed.</source>
          <target state="translated">변경 사항이 발생하거나 &lt;code&gt;timeout_s&lt;/code&gt; 초가 경과 할 때까지 변경 사항이 있는지 파일 또는 디렉토리 &lt;code&gt;path&lt;/code&gt; 를 감시하십시오 .</target>
        </trans-unit>
        <trans-unit id="59134ad32d2b5206214dcf33380079d24664842d" translate="yes" xml:space="preserve">
          <source>Watches a file or directory &lt;code&gt;path&lt;/code&gt; for changes until a change has occurred or &lt;code&gt;timeout_s&lt;/code&gt; seconds have elapsed.</source>
          <target state="translated">변경이 발생하거나 &lt;code&gt;timeout_s&lt;/code&gt; 초가 경과 할 때까지 파일 또는 디렉토리 &lt;code&gt;path&lt;/code&gt; 에서 변경 사항을 감시 합니다.</target>
        </trans-unit>
        <trans-unit id="1ca35816415b36528899a025f235ead5b493c4c6" translate="yes" xml:space="preserve">
          <source>Water Buffalo</source>
          <target state="translated">물소</target>
        </trans-unit>
        <trans-unit id="e06db6b2e3d7113b354825a671bcfd66f3f37636" translate="yes" xml:space="preserve">
          <source>Water Closet</source>
          <target state="translated">화장실</target>
        </trans-unit>
        <trans-unit id="26d7518c22143e2c303ad5d3b3b76e99881c89f4" translate="yes" xml:space="preserve">
          <source>Water Wave</source>
          <target state="translated">물결</target>
        </trans-unit>
        <trans-unit id="654a5083667369ba4ea98c6fad0fba9b362d84f9" translate="yes" xml:space="preserve">
          <source>Watermelon</source>
          <target state="translated">Watermelon</target>
        </trans-unit>
        <trans-unit id="efcfd2863140aff2c4eb2bdd6fa9656ad7057054" translate="yes" xml:space="preserve">
          <source>Wave Arrow Pointing Directly Left</source>
          <target state="translated">직접 왼쪽을 가리키는 웨이브 화살표</target>
        </trans-unit>
        <trans-unit id="1d1fa735e928bfc4e19cadbd3eae648f435c998b" translate="yes" xml:space="preserve">
          <source>Waving Hand Sign</source>
          <target state="translated">손 기호를 흔들며</target>
        </trans-unit>
        <trans-unit id="5f0c28665bc4f163773e677f770df64f28f10a09" translate="yes" xml:space="preserve">
          <source>Wavy Dash</source>
          <target state="translated">물결 모양의 대시</target>
        </trans-unit>
        <trans-unit id="78a2e376b64ecbcd255eac49c815de57f72c8cc7" translate="yes" xml:space="preserve">
          <source>Waxing Crescent Moon Symbol</source>
          <target state="translated">왁싱 초승달 기호</target>
        </trans-unit>
        <trans-unit id="369994eb3b0ebd5d85b9b8c5c1054fdb4a4e6a45" translate="yes" xml:space="preserve">
          <source>Waxing Gibbous Moon Symbol</source>
          <target state="translated">왁싱 Gibbous 문 기호</target>
        </trans-unit>
        <trans-unit id="3761de263d1138df106d8089687e0582792188a8" translate="yes" xml:space="preserve">
          <source>We also define a convenience wrapper for a &lt;code&gt;SharedArray&lt;/code&gt; implementation</source>
          <target state="translated">또한 &lt;code&gt;SharedArray&lt;/code&gt; 구현을 위한 편의 래퍼를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3cd7937c29f83be5fa8d995ae61932aae9d922a0" translate="yes" xml:space="preserve">
          <source>We can also specify multiple packages at once:</source>
          <target state="translated">한 번에 여러 패키지를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf25eada1cacba577a55ee72c0083a1f8723a92" translate="yes" xml:space="preserve">
          <source>We can ask for information about the active environment by using &lt;code&gt;status&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 를 사용하여 활성 환경에 대한 정보를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e272c4ad190b0938bc9c69088b0d3965bfa5c474" translate="yes" xml:space="preserve">
          <source>We can now execute &lt;code&gt;sub2ind_gen_impl&lt;/code&gt; and examine the expression it returns:</source>
          <target state="translated">이제 &lt;code&gt;sub2ind_gen_impl&lt;/code&gt; 을 실행 하고 그것이 반환하는 표현식을 검사 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6faffdfd84b81290f711f7dea5e21f96d49747fe" translate="yes" xml:space="preserve">
          <source>We can put our tests for the &lt;code&gt;foo(x)&lt;/code&gt; function in a test set:</source>
          <target state="translated">&lt;code&gt;foo(x)&lt;/code&gt; 함수에 대한 테스트를 테스트 세트에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="908493f843edf7ee66a6309d8ae472662e884e33" translate="yes" xml:space="preserve">
          <source>We can see &lt;code&gt;tutorial&lt;/code&gt; now contains &lt;code&gt;Example&lt;/code&gt; as a dependency.</source>
          <target state="translated">우리는 &lt;code&gt;tutorial&lt;/code&gt; 이 이제 &lt;code&gt;Example&lt;/code&gt; 으로 의존하는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="965750ca8edc73d5edaf9b850ece4c5b04a1af65" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;&quot;human&quot;&lt;/code&gt; literal has been interpolated into the expression.</source>
          <target state="translated">&lt;code&gt;&quot;human&quot;&lt;/code&gt; 리터럴이 표현에 삽입 된 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41d616faac9f0af3ed6de89012b5a9c6f5afd1ce" translate="yes" xml:space="preserve">
          <source>We can see that the first two code units in the string &lt;code&gt;s&lt;/code&gt; form an overlong encoding of space character. It is invalid, but is accepted in a string as a single character. The next two code units form a valid start of a three-byte UTF-8 sequence. However, the fifth code unit &lt;code&gt;\xe2&lt;/code&gt; is not its valid continuation. Therefore code units 3 and 4 are also interpreted as malformed characters in this string. Similarly code unit 5 forms a malformed character because &lt;code&gt;|&lt;/code&gt; is not a valid continuation to it. Finally the string &lt;code&gt;s2&lt;/code&gt; contains one too high code point.</source>
          <target state="translated">우리는 문자열의 처음 두 코드 단위 것을 알 수 있습니다 &lt;code&gt;s&lt;/code&gt; 는 공백 문자의 너무 긴 인코딩을 형성한다. 유효하지 않지만 문자열에서 단일 문자로 허용됩니다. 다음 두 코드 단위는 3 바이트 UTF-8 시퀀스의 유효한 시작을 형성합니다. 그러나 다섯 번째 코드 단위 &lt;code&gt;\xe2&lt;/code&gt; 는 유효한 연속이 아닙니다. 따라서 코드 단위 3과 4도이 문자열에서 형식이 잘못된 문자로 해석됩니다. 마찬가지로 코드 단위 5는 잘못된 문자를 형성하기 때문에 &lt;code&gt;|&lt;/code&gt; 올바른 연속이 아닙니다. 마지막으로 문자열 &lt;code&gt;s2&lt;/code&gt; 에 코드 포인트가 너무 높습니다.</target>
        </trans-unit>
        <trans-unit id="5ec722680d02359489f3e45fa2c4562e09c9cd1c" translate="yes" xml:space="preserve">
          <source>We can see the &lt;a href=&quot;#Base.Filesystem.mtime&quot;&gt;&lt;code&gt;mtime&lt;/code&gt;&lt;/a&gt; has been modified by &lt;code&gt;touch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;touch&lt;/code&gt; 하여 &lt;a href=&quot;#Base.Filesystem.mtime&quot;&gt; &lt;code&gt;mtime&lt;/code&gt; &lt;/a&gt; 이 수정 된 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05b69d4e7a91a49ec3c428dbce42702598bb1b02" translate="yes" xml:space="preserve">
          <source>We can test the info message using</source>
          <target state="translated">우리는 정보 메시지를 사용하여 테스트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d2480cee187d2cc1cc597f470eaeb54baa754265" translate="yes" xml:space="preserve">
          <source>We can use many of the builtin methods that work with iterables, like &lt;a href=&quot;../../base/collections/index#Base.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../stdlib/statistics/index#Statistics.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/statistics/index#Statistics.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;Statistics&lt;/code&gt; standard library module:</source>
          <target state="translated">우리는 내장 방법을 많이 사용할 수와 같은 반복 가능 객체와 직장 &lt;a href=&quot;../../base/collections/index#Base.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../../stdlib/statistics/index#Statistics.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../stdlib/statistics/index#Statistics.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 로부터 &lt;code&gt;Statistics&lt;/code&gt; 표준 라이브러리 모듈 :</target>
        </trans-unit>
        <trans-unit id="863e927f5402597cd052d4595ad76ea62614af53" translate="yes" xml:space="preserve">
          <source>We can verify that this constructor works and constructs objects that are, in fact, self-referential:</source>
          <target state="translated">이 생성자가 작동하고 실제로 자기 참조적인 객체를 생성하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8792a0f0d8b29fc2a8023ec8a7dd90ce3d0d4dbf" translate="yes" xml:space="preserve">
          <source>We can view the quoted return expression using the function &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; (&lt;strong&gt;important note:&lt;/strong&gt; this is an extremely useful tool for debugging macros):</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 따옴표가있는 반환 표현식을 볼 수 있습니다 ( &lt;strong&gt;중요 :&lt;/strong&gt; 매크로 디버깅에 매우 유용한 도구입니다).</target>
        </trans-unit>
        <trans-unit id="d4c6277bb37a454f2d70270bbbbe4dad7ec0b9f7" translate="yes" xml:space="preserve">
          <source>We define &lt;code&gt;prod(())&lt;/code&gt; to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array is &lt;code&gt;()&lt;/code&gt;, and therefore its length is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prod(())&lt;/code&gt; 를 1로 정의 하고 배열의 총 요소 수는 크기의 곱입니다. 0 차원 배열의 크기는 &lt;code&gt;()&lt;/code&gt; 이므로 길이는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f52fa955d41415a30b99848d48db3fb9c65e8a90" translate="yes" xml:space="preserve">
          <source>We define a &lt;code&gt;dlclose()&lt;/code&gt; method that accepts a parameter of type &lt;code&gt;Nothing&lt;/code&gt;, so that user code does not have to change its behavior for the case that &lt;code&gt;library_name&lt;/code&gt; was not found.</source>
          <target state="translated">&lt;code&gt;Nothing&lt;/code&gt; 유형의 매개 변수를 허용 하는 &lt;code&gt;dlclose()&lt;/code&gt; 메소드를 정의 하므로 &lt;code&gt;library_name&lt;/code&gt; 을 찾을 수없는 경우 사용자 코드의 동작을 변경할 필요 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc149b91af6eb560f65443e1ee253cae2c610859" translate="yes" xml:space="preserve">
          <source>We find that global names are frequently constants, and declaring them as such greatly improves performance:</source>
          <target state="translated">우리는 전역 이름이 자주 상수라는 것을 발견하고 그렇게 선언하면 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="483b04db385b0851198da03cd29da645e4ce9af2" translate="yes" xml:space="preserve">
          <source>We have already seen a function &lt;code&gt;f(::Expr...) -&amp;gt; Expr&lt;/code&gt; in a previous section. In fact, &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is also such a function. So, why do macros exist?</source>
          <target state="translated">우리는 이미 이전 섹션에서 함수 &lt;code&gt;f(::Expr...) -&amp;gt; Expr&lt;/code&gt; 을 보았습니다 . 실제로 &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; 도 그러한 기능입니다. 그렇다면 매크로가 존재하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="344d6b40dfaca1361099ea7869e0ae03b90d8acf" translate="yes" xml:space="preserve">
          <source>We have now covered all the local scope rules, but before wrapping up this section, perhaps a few words should be said about why the ambiguous soft scope case is handled differently in interactive and non-interactive contexts. There are two obvious questions one could ask:</source>
          <target state="translated">이제 모든 로컬 범위 규칙을 다루었지만이 섹션을 마무리하기 전에 모호한 소프트 범위 케이스가 대화 형 및 비대화 형 컨텍스트에서 다르게 처리되는 이유에 대해 몇 마디 말해야합니다. 다음과 같은 두 가지 분명한 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6795658430c35f4c900b3f1e2f337a0f0021d3be" translate="yes" xml:space="preserve">
          <source>We have said that a parametric type like &lt;code&gt;Ptr&lt;/code&gt; acts as a supertype of all its instances (&lt;code&gt;Ptr{Int64}&lt;/code&gt; etc.). How does this work? &lt;code&gt;Ptr&lt;/code&gt; itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations. The answer is that &lt;code&gt;Ptr&lt;/code&gt; (or other parametric types like &lt;code&gt;Array&lt;/code&gt;) is a different kind of type called a &lt;a href=&quot;../../base/base/index#Core.UnionAll&quot;&gt;&lt;code&gt;UnionAll&lt;/code&gt;&lt;/a&gt; type. Such a type expresses the &lt;em&gt;iterated union&lt;/em&gt; of types for all values of some parameter.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 과 같은 파라 메트릭 유형 은 모든 인스턴스 ( &lt;code&gt;Ptr{Int64}&lt;/code&gt; 등) 의 수퍼 타입 ​​역할을합니다 . 어떻게 작동합니까? &lt;code&gt;Ptr&lt;/code&gt; 자체는 일반 데이터 유형이 될 수 없습니다. 참조 된 데이터의 유형을 모르면 유형을 메모리 조작에 명확하게 사용할 수 없기 때문입니다. 답은 &lt;code&gt;Ptr&lt;/code&gt; (또는 &lt;code&gt;Array&lt;/code&gt; 와 같은 다른 매개 변수 유형 )이 &lt;a href=&quot;../../base/base/index#Core.UnionAll&quot;&gt; &lt;code&gt;UnionAll&lt;/code&gt; &lt;/a&gt; 유형 이라고하는 다른 종류의 유형이라는 것 입니다. 이러한 유형 은 일부 매개 변수의 모든 값에 대해 &lt;em&gt;반복&lt;/em&gt; 된 유형의 &lt;em&gt;조합&lt;/em&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="636e3e40c3c73838a97fed4217e3ac9db49c3e9d" translate="yes" xml:space="preserve">
          <source>We now add some new definitions for &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;f(x)&lt;/code&gt; 대한 새로운 정의를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cfea8865c7e95aca15b99514b9e0cd50e09aceff" translate="yes" xml:space="preserve">
          <source>We now use &lt;code&gt;Regex(&quot;1&quot;)&lt;/code&gt; instead of &lt;code&gt;r&quot;1&quot;&lt;/code&gt; to make sure that Julia creates separate instances of &lt;code&gt;Regex&lt;/code&gt; object for each entry of &lt;code&gt;rx&lt;/code&gt; vector.</source>
          <target state="translated">우리는 이제 &lt;code&gt;r&quot;1&quot;&lt;/code&gt; 대신 &lt;code&gt;Regex(&quot;1&quot;)&lt;/code&gt; 를 사용하여 Julia가 &lt;code&gt;rx&lt;/code&gt; 벡터의 각 항목에 대해 별도의 &lt;code&gt;Regex&lt;/code&gt; 객체 인스턴스를 생성하도록 합니다 .</target>
        </trans-unit>
        <trans-unit id="ec35a5b84bcc09ce12511e4f9859c93b1a12cef2" translate="yes" xml:space="preserve">
          <source>We pass the &lt;code&gt;r&lt;/code&gt; vector to &lt;code&gt;g_fix&lt;/code&gt; as generating several RGNs is an expensive operation so we do not want to repeat it every time we run the function.</source>
          <target state="translated">여러 &lt;code&gt;g_fix&lt;/code&gt; 을 생성하는 것은 많은 비용이 드는 작업이므로 함수를 실행할 때마다 반복하지 않기 때문에 &lt;code&gt;r&lt;/code&gt; 벡터를 g_fix에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="581b814b87b04c0b0319df4ca93ccb93aadd9579" translate="yes" xml:space="preserve">
          <source>We provide examples for each of these. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">우리는 이들 각각에 대한 예를 제공합니다. 여기서 알고리즘 선택은 RNG와 무관하다고 가정하므로 서명에 &lt;code&gt;AbstractRNG&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="c18a4ee9acbd3ff8d3e3a474425776415e254fbf" translate="yes" xml:space="preserve">
          <source>We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in &lt;a href=&quot;../types/index#man-types&quot;&gt;Types&lt;/a&gt; and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">이것은 함수 정의에 대한 완전한 그림과는 거리가 멀다는 것을 여기서 언급해야합니다. Julia는 정교한 유형 시스템을 가지고 있으며 인수 유형에 대한 다중 디스패치를 ​​허용합니다. 여기에 제공된 예제는 인수에 대한 유형 주석을 제공하지 않으므로 모든 유형의 인수에 적용 할 수 있습니다. 타입 시스템이 설명된다 &lt;a href=&quot;../types/index#man-types&quot;&gt;유형&lt;/a&gt; 및 런타임 인수 형 여러 디스패치가 선택한 방법의 관점에서 함수를 정의하는 단계에서 설명하는 &lt;a href=&quot;../methods/index#Methods&quot;&gt;방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7268f16539c91dcce2fef5a6e0c3e4f4529fa7f0" translate="yes" xml:space="preserve">
          <source>We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt; and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">여기서는 함수 정의에 대한 완전한 그림과는 거리가 멀다는 점을 언급해야합니다. Julia는 정교한 유형 시스템을 가지고 있으며 인수 유형에 대해 여러 디스패치를 ​​허용합니다. 여기에 제공된 예제 중 어느 것도 인수에 대한 유형 주석을 제공하지 않으므로 모든 유형의 인수에 적용 할 수 있습니다. 타입 시스템이 설명된다 &lt;a href=&quot;../types/index#man-types-1&quot;&gt;유형&lt;/a&gt; 및 런타임 인수 형 여러 디스패치가 선택한 방법의 관점에서 함수를 정의하는 단계에서 설명하는 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a67f0f52d7f08e2b4d80e7a86d1e32e2246dae" translate="yes" xml:space="preserve">
          <source>We start 4 workers to process a single &lt;code&gt;jobs&lt;/code&gt; remote channel. Jobs, identified by an id (&lt;code&gt;job_id&lt;/code&gt;), are written to the channel. Each remotely executing task in this simulation reads a &lt;code&gt;job_id&lt;/code&gt;, waits for a random amount of time and writes back a tuple of &lt;code&gt;job_id&lt;/code&gt;, time taken and its own &lt;code&gt;pid&lt;/code&gt; to the results channel. Finally all the &lt;code&gt;results&lt;/code&gt; are printed out on the master process.</source>
          <target state="translated">단일 &lt;code&gt;jobs&lt;/code&gt; 원격 채널 을 처리하기 위해 4 명의 작업자를 시작 합니다. ID ( &lt;code&gt;job_id&lt;/code&gt; )로 식별 된 작업 은 채널에 작성됩니다. 이 시뮬레이션의 각 원격 실행 작업은 읽기 &lt;code&gt;job_id&lt;/code&gt; , 임의의 시간을 대기와 쓰기는의 튜플 백업 &lt;code&gt;job_id&lt;/code&gt; , 촬영 시간과 자신의 &lt;code&gt;pid&lt;/code&gt; 결과 채널. 마지막으로 모든 &lt;code&gt;results&lt;/code&gt; 가 마스터 프로세스에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c7602ad29472f270cdd747ca5767f7b21541f864" translate="yes" xml:space="preserve">
          <source>We start by opening Visual Studio and creating a new Console Application project. To the 'stdafx.h' header file, add the following lines at the end:</source>
          <target state="translated">먼저 Visual Studio를 열고 새 콘솔 응용 프로그램 프로젝트를 만듭니다. 'stdafx.h'헤더 파일의 끝에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5e7e52dbeb18f4aab9e295bb6c3fe3b794d7460e" translate="yes" xml:space="preserve">
          <source>We start with a simple C program that initializes Julia and calls some Julia code:</source>
          <target state="translated">우리는 Julia를 초기화하고 Julia 코드를 호출하는 간단한 C 프로그램으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1ec966563751785e709c57a1206d5b2323de7847" translate="yes" xml:space="preserve">
          <source>We strongly encourage you to try all these examples to see how they work.</source>
          <target state="translated">이 예제가 어떻게 작동하는지 확인하기 위해이 예제를 모두 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c178bdaf4eca20bba89f0485a67fed8fb6985604" translate="yes" xml:space="preserve">
          <source>We will first consider Julia &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; and other modules that rely on the Julia runtime library, that allow us to suspend and resume computations with full control of inter-&lt;code&gt;Tasks&lt;/code&gt; communication without having to manually interface with the operating system's scheduler. Julia also supports communication between &lt;code&gt;Tasks&lt;/code&gt; through operations like &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch&lt;/code&gt;. Communication and data synchronization is managed through &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s, which are the conduits that provide inter-&lt;code&gt;Tasks&lt;/code&gt; communication.</source>
          <target state="translated">먼저 Julia 런타임 라이브러리에 의존하는 Julia &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (일명 Coroutines)&lt;/a&gt; 및 기타 모듈을 고려 하여 운영 체제의 스케줄러와 수동으로 인터페이스하지 않고도 &lt;code&gt;Tasks&lt;/code&gt; 간 통신 을 완벽하게 제어하여 계산을 일시 중단 및 재개 할 수 있습니다. Julia는 또한 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;fetch&lt;/code&gt; 와 같은 &lt;code&gt;Tasks&lt;/code&gt; 통해 작업 간 통신을 지원합니다 . 통신 및 데이터 동기화는 &lt;code&gt;Tasks&lt;/code&gt; 간 통신 을 제공하는 도관 인 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 통해 관리됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd2f826c12c0cde32ff9c2aa3aacbda20d8da94e" translate="yes" xml:space="preserve">
          <source>We'll begin with a nice and clear-cut situation&amp;mdash;assignment inside of a hard scope, in this case a function body, when no local variable by that name already exists:</source>
          <target state="translated">우리는 멋지고 명확한 상황으로 시작할 것입니다. 하드 스코프 (이 경우 함수 본문) 내 할당은 해당 이름의 지역 변수가 이미 존재하지 않을 때입니다.</target>
        </trans-unit>
        <trans-unit id="14bf173ec6449dfc053db0f852d649e379980987" translate="yes" xml:space="preserve">
          <source>WeakKeyDict</source>
          <target state="translated">WeakKeyDict</target>
        </trans-unit>
        <trans-unit id="f0314de0c1d3e072ee0c5f34821e6e9260b516aa" translate="yes" xml:space="preserve">
          <source>Weary Cat Face</source>
          <target state="translated">지친 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="acc7d3ff4cf1bd52c5872adea707797a48176eb4" translate="yes" xml:space="preserve">
          <source>Weary Face</source>
          <target state="translated">지친 얼굴</target>
        </trans-unit>
        <trans-unit id="ee2bf9bdc622233451493a19e0f78f4514fdb969" translate="yes" xml:space="preserve">
          <source>Wedding</source>
          <target state="translated">Wedding</target>
        </trans-unit>
        <trans-unit id="8bd12f2094b5f4ba0bbdd465685c8e4690ed946b" translate="yes" xml:space="preserve">
          <source>Welcome to the documentation for Julia 1.2.</source>
          <target state="translated">Julia 1.2의 문서에 오신 것을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="98684eeaaae0713e40f7faf02d029d7cc8b3c048" translate="yes" xml:space="preserve">
          <source>Welcome to the documentation for Julia 1.5.</source>
          <target state="translated">Julia 1.5에 대한 문서에 오신 것을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="2be913c6a4cf9189e9c190ec0adc68e90e4c97e4" translate="yes" xml:space="preserve">
          <source>Whale</source>
          <target state="translated">Whale</target>
        </trans-unit>
        <trans-unit id="375144b7f845dc51bb4e72f8e608e2b7199156c4" translate="yes" xml:space="preserve">
          <source>What are the differences between zero-dimensional arrays and scalars?</source>
          <target state="translated">0 차원 배열과 스칼라의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e7076b54a9ebe6ee2099ef19db17f5603e67dda2" translate="yes" xml:space="preserve">
          <source>What are the possible causes of an &lt;code&gt;UndefVarError&lt;/code&gt; during remote execution?</source>
          <target state="translated">원격 실행 중 &lt;code&gt;UndefVarError&lt;/code&gt; 의 가능한 원인은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="28e8482c889872b755ea864c2a6346e9a0dc7c13" translate="yes" xml:space="preserve">
          <source>What does &quot;type-stable&quot; mean?</source>
          <target state="translated">&quot;type-stable&quot;은 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="d18e5df2eb583dbf63c895d771307dc5beb0550b" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;...&lt;/code&gt; operator do?</source>
          <target state="translated">뭐라고합니까 &lt;code&gt;...&lt;/code&gt; 운영자는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="150404929053fe30c3fed0d87906c36fb8c409b2" translate="yes" xml:space="preserve">
          <source>What does this code do? Hint: it's a trick question. The answer is &quot;it depends.&quot; If this code is entered interactively, it behaves the same way it does in a function body. But if the code appears in a file, it prints an ambiguity warning and throws an undefined variable error. Let's see it working in the REPL first:</source>
          <target state="translated">이 코드는 무엇을합니까? 힌트 : 속임수 질문입니다. 대답은 &quot;상황에 따라 다르다&quot;입니다. 이 코드를 대화식으로 입력하면 함수 본문에서와 동일한 방식으로 작동합니다. 그러나 코드가 파일에 나타나면 모호성 경고를 인쇄하고 정의되지 않은 변수 오류를 발생시킵니다. 먼저 REPL에서 작동하는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e403edfbacc5a9300178b028475d72c9ac7f144e" translate="yes" xml:space="preserve">
          <source>What follows is a quick overview of Pkg, Julia's package manager. It should help new users become familiar with basic Pkg features.</source>
          <target state="translated">다음은 Julia의 패키지 관리자 인 Pkg에 대한 간략한 개요입니다. 새로운 사용자가 기본 Pkg 기능에 익숙해 지도록 도와야합니다.</target>
        </trans-unit>
        <trans-unit id="d2f2c51d6b2884ac3c8f43369210b486f5aba512" translate="yes" xml:space="preserve">
          <source>What follows is a very brief introduction to Pkg. For more information on &lt;code&gt;Project.toml&lt;/code&gt; files, &lt;code&gt;Manifest.toml&lt;/code&gt; files, package version compatibility (&lt;code&gt;[compat]&lt;/code&gt;), environments, registries, etc., it is highly recommended to read the full manual, which is available here: &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/&quot;&gt;https://julialang.github.io/Pkg.jl/v1/&lt;/a&gt;.</source>
          <target state="translated">다음은 Pkg에 대한 간략한 소개입니다. &lt;code&gt;Project.toml&lt;/code&gt; 파일, &lt;code&gt;Manifest.toml&lt;/code&gt; 파일, 패키지 버전 호환성 ( &lt;code&gt;[compat]&lt;/code&gt; ), 환경, 레지스트리 등에 대한 자세한 내용 은 &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/&quot;&gt;https : // julialang에서&lt;/a&gt; 사용할 수있는 전체 설명서를 읽는 것이 좋습니다 . .github.io / Pkg.jl / V1 / .</target>
        </trans-unit>
        <trans-unit id="a4b5a9178463a6f64c403bbf3579ad70f39858c3" translate="yes" xml:space="preserve">
          <source>What follows is a very brief introduction to Pkg. It is highly recommended to read the full manual, which is available here: &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/&quot;&gt;https://julialang.github.io/Pkg.jl/v1/&lt;/a&gt;.</source>
          <target state="translated">다음은 Pkg에 대한 간단한 소개입니다. &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/&quot;&gt;https://julialang.github.io/Pkg.jl/v1/&lt;/a&gt; 에서 전체 설명서를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1b405051e8aa0f8bb9f6f6cf42b1ad141a9ba2" translate="yes" xml:space="preserve">
          <source>What happens if &lt;code&gt;import Zebra&lt;/code&gt; is evaluated in the main &lt;code&gt;App&lt;/code&gt; code base? Since &lt;code&gt;Zebra&lt;/code&gt; does not appear in the project file, the import will fail even though &lt;code&gt;Zebra&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; appear in the manifest file. Moreover, if &lt;code&gt;import Zebra&lt;/code&gt; occurs in the public &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;then that would also fail since that &lt;code&gt;Priv&lt;/code&gt; package has no declared dependencies in the manifest file and therefore cannot load any packages. The &lt;code&gt;Zebra&lt;/code&gt; package can only be loaded by packages for which it appear as an explicit dependency in the manifest file: the &lt;code&gt;Pub&lt;/code&gt; package and one of the &lt;code&gt;Priv&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;import Zebra&lt;/code&gt; 가 기본 &lt;code&gt;App&lt;/code&gt; 코드베이스 에서 평가 되면 어떻게됩니까 ? 이후 &lt;code&gt;Zebra&lt;/code&gt; 프로젝트 파일에 나타나지 않습니다 불구하고, 수입도 실패합니다 &lt;code&gt;Zebra&lt;/code&gt; &lt;em&gt;않습니다&lt;/em&gt; 매니페스트 파일에 나타납니다. 또한 &lt;code&gt;import Zebra&lt;/code&gt; 가 공개 &lt;code&gt;Priv&lt;/code&gt; 패키지 (UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; 가있는 패키지)에서 발생하는 경우 &lt;code&gt;Priv&lt;/code&gt; 패키지가 매니페스트 파일에 선언 된 종속성이 없으므로 패키지를로드 할 수 없으므로 실패 합니다. &lt;code&gt;Zebra&lt;/code&gt; 패키지 만이 매니페스트 파일에 명시 적으로 종속으로 표시되는 패키지를로드 할 수 다음 &lt;code&gt;Pub&lt;/code&gt; 패키지 및 &lt;code&gt;Priv&lt;/code&gt; 패키지 중 하나 .</target>
        </trans-unit>
        <trans-unit id="1df4ea25877d9225bf9beecd2604c556ef2f3aa4" translate="yes" xml:space="preserve">
          <source>What happens if we evaluate &lt;code&gt;foo&lt;/code&gt; again with a type that we have already used?</source>
          <target state="translated">이미 사용한 유형으로 &lt;code&gt;foo&lt;/code&gt; 를 다시 평가하면 어떻게됩니까 ?</target>
        </trans-unit>
        <trans-unit id="e1b168674d9032058d87b14f2643e8b740569003" translate="yes" xml:space="preserve">
          <source>What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of &lt;code&gt;DataType&lt;/code&gt;:</source>
          <target state="translated">과정을 반복하면 어떻게 되나요? 유형의 유형은 무엇입니까? 발생하는 것처럼 유형은 모두 복합 값이므로 모든 유형은 &lt;code&gt;DataType&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="31c8231840d8c0a2ee8876da74fa758be586c4d5" translate="yes" xml:space="preserve">
          <source>What is brought into scope</source>
          <target state="translated">범위로 가져 오는 것</target>
        </trans-unit>
        <trans-unit id="2b0c102525b96cde6901e5f5ceb8c7569053a70f" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;using&quot; and &quot;import&quot;?</source>
          <target state="translated">&quot;사용&quot;과 &quot;가져 오기&quot;의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9bc322e3544ca572c436cc629f272e8f9083662e" translate="yes" xml:space="preserve">
          <source>What is the return value of an assignment?</source>
          <target state="translated">과제의 반환 값은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="2269bad70018db37aa152079ee07e395e293de2e" translate="yes" xml:space="preserve">
          <source>What purpose do parametric abstract types like &lt;code&gt;Pointy&lt;/code&gt; serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line &lt;em&gt;x = y&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;Pointy&lt;/code&gt; 와 같은 파라 메트릭 추상 유형은 어떤 용도로 사용됩니까? 점이 대각선 &lt;em&gt;x = y&lt;/em&gt; 에 있기 때문에 단일 좌표 만 필요한 점과 같은 구현을 작성하는 경우를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd4e0eba4d9311f35f7a602da1112be78b3670c2" translate="yes" xml:space="preserve">
          <source>What's going on there? In the first line, we're adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month &lt;em&gt;first&lt;/em&gt;, where we get 2014-02-29, which adjusts down to 2014-02-28, and &lt;em&gt;then&lt;/em&gt; add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods' &lt;em&gt;types&lt;/em&gt;, not their value or positional order; this means &lt;code&gt;Year&lt;/code&gt; will always be added first, then &lt;code&gt;Month&lt;/code&gt;, then &lt;code&gt;Week&lt;/code&gt;, etc. Hence the following &lt;em&gt;does&lt;/em&gt; result in associativity and Just Works:</source>
          <target state="translated">거기 무슨 일 이죠? 첫 번째 줄에서 1 월 29 일에 1 일을 추가하면 2014-01-30이됩니다. 1 개월을 더해서 2014-02-30을 얻습니다. 그러면 2014-02-28로 조정됩니다. 두 번째 예에서는 &lt;em&gt;먼저&lt;/em&gt; 1 개월을 추가 하면 2014-02-29가 2014-02-28로 조정 된 &lt;em&gt;다음&lt;/em&gt; 1 일이 더해져 2014-03-01이됩니다. 이 경우에 도움이되는 한 가지 설계 원칙은 여러 기간이있을 경우 작업 의 가치 나 위치 순서가 아닌 기간 &lt;em&gt;유형별로&lt;/em&gt; 작업이 정렬된다는 것입니다 . 이 수단 &lt;code&gt;Year&lt;/code&gt; 항상 다음 먼저 추가됩니다 &lt;code&gt;Month&lt;/code&gt; , 다음 &lt;code&gt;Week&lt;/code&gt; 등 따라서 다음 &lt;em&gt;수행&lt;/em&gt; 연관성과 그냥 작품의 결과 :</target>
        </trans-unit>
        <trans-unit id="fdfb635074e8ec4cadb7236583c2872a090d4783" translate="yes" xml:space="preserve">
          <source>What's really going on here is that &lt;code&gt;Point&lt;/code&gt;, &lt;code&gt;Point{Float64}&lt;/code&gt; and &lt;code&gt;Point{Int64}&lt;/code&gt; are all different constructor functions. In fact, &lt;code&gt;Point{T}&lt;/code&gt; is a distinct constructor function for each type &lt;code&gt;T&lt;/code&gt;. Without any explicitly provided inner constructors, the declaration of the composite type &lt;code&gt;Point{T&amp;lt;:Real}&lt;/code&gt; automatically provides an inner constructor, &lt;code&gt;Point{T}&lt;/code&gt;, for each possible type &lt;code&gt;T&amp;lt;:Real&lt;/code&gt;, that behaves just like non-parametric default inner constructors do. It also provides a single general outer &lt;code&gt;Point&lt;/code&gt; constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:</source>
          <target state="translated">실제로 여기서 진행되고있는 것은 &lt;code&gt;Point&lt;/code&gt; , &lt;code&gt;Point{Float64}&lt;/code&gt; 및 &lt;code&gt;Point{Int64}&lt;/code&gt; 가 모두 다른 생성자 함수라는 것입니다. 실제로 &lt;code&gt;Point{T}&lt;/code&gt; 는 각 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 고유 한 생성자 함수입니다 . 명시 적으로 제공된 내부 생성자가 없으면 복합 유형 &lt;code&gt;Point{T&amp;lt;:Real}&lt;/code&gt; 의 선언은 매개 변수가 아닌 기본 내부 생성자와 마찬가지로 동작하는 가능한 각 유형 &lt;code&gt;T&amp;lt;:Real&lt;/code&gt; 에 대해 내부 생성자 &lt;code&gt;Point{T}&lt;/code&gt; 자동으로 제공합니다 . 하다. 또한 단일 일반 외부 &lt;code&gt;Point&lt;/code&gt; 제공합니다실제 인수 쌍을 취하는 생성자이며 동일한 유형이어야합니다. 이 자동 생성자 제공은 다음 명시 적 선언과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dac94c61f72cef8a05dc1f143540e80e082b95ca" translate="yes" xml:space="preserve">
          <source>Wheelchair Symbol</source>
          <target state="translated">휠체어 기호</target>
        </trans-unit>
        <trans-unit id="e372ad539a5b6f69cfecd518ffee27baf201194a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--depwarn=no&lt;/code&gt;, simply return the result of executing &lt;code&gt;expression&lt;/code&gt;. When &lt;code&gt;--depwarn=error&lt;/code&gt;, check that an ErrorException is thrown.</source>
          <target state="translated">&lt;code&gt;--depwarn=no&lt;/code&gt; 일 때 간단하게 &lt;code&gt;expression&lt;/code&gt; 실행 결과를 반환합니다 . &lt;code&gt;--depwarn=error&lt;/code&gt; 일 때 ErrorException 이 발생했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="37a200d2bf2141bef32e094222abeb6ea685aeb4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--depwarn=yes&lt;/code&gt;, test that &lt;code&gt;expression&lt;/code&gt; emits a deprecation warning and return the value of &lt;code&gt;expression&lt;/code&gt;. The log message string will be matched against &lt;code&gt;pattern&lt;/code&gt; which defaults to &lt;code&gt;r&quot;deprecated&quot;i&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;--depwarn=yes&lt;/code&gt; , 테스트한다는 &lt;code&gt;expression&lt;/code&gt; 더 이상 사용되지 경고를 방출하고 값 반환 &lt;code&gt;expression&lt;/code&gt; . 로그 메시지 문자열은 기본적으로 &lt;code&gt;r&quot;deprecated&quot;i&lt;/code&gt; &lt;code&gt;pattern&lt;/code&gt; 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="4c1a8dc42946acafa81c5740aa21d2dee07993bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@sayhello&lt;/code&gt; is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:</source>
          <target state="translated">경우 &lt;code&gt;@sayhello&lt;/code&gt; 가 REPL에 입력되어, 식 따라서 우리는 단지 평가 결과를보고, 즉시 실행한다 :</target>
        </trans-unit>
        <trans-unit id="1e793eb591e046c76c38f6001e51ca3fa2243395" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A&lt;/code&gt; is sparse, a similar polyalgorithm is used. For indefinite matrices, the &lt;code&gt;LDLt&lt;/code&gt; factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</source>
          <target state="translated">때 &lt;code&gt;A&lt;/code&gt; 는 스파 스, 유사한 polyalgorithm이 사용됩니다. 무한 행렬의 경우, &lt;code&gt;LDLt&lt;/code&gt; 인수 분해는 수치 인수 분해 동안 피벗을 사용하지 않으므로 절차는 가역 행렬에서도 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a8d30453be3346ceadf6f86b18d6a1b7d2c5482" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;abs&lt;/code&gt; is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when &lt;code&gt;abs&lt;/code&gt; is applied to the minimum representable value of a signed integer. That is, when &lt;code&gt;x == typemin(typeof(x))&lt;/code&gt;, &lt;code&gt;abs(x) == x &amp;lt; 0&lt;/code&gt;, not &lt;code&gt;-x&lt;/code&gt; as might be expected.</source>
          <target state="translated">경우 &lt;code&gt;abs&lt;/code&gt; 부호있는 정수로 도포하고, 오버 플로우가 음의 값의 복귀 결과가 발생할 수있다. 이 오버 플로우는 &lt;code&gt;abs&lt;/code&gt; 가 부호있는 정수의 표현 가능한 최소값에 적용되는 경우에만 발생합니다 . 즉, &lt;code&gt;x == typemin(typeof(x))&lt;/code&gt; , &lt;code&gt;abs(x) == x &amp;lt; 0&lt;/code&gt; 일 때 예상대로 &lt;code&gt;-x&lt;/code&gt; 가 아닌 x 입니다.</target>
        </trans-unit>
        <trans-unit id="7ef7f5c5a085d7dd04543fecd677114d5fd72981" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;check = true&lt;/code&gt;, an error is thrown if the decomposition fails. When &lt;code&gt;check = false&lt;/code&gt;, responsibility for checking the decomposition's validity (via &lt;a href=&quot;#LinearAlgebra.issuccess&quot;&gt;&lt;code&gt;issuccess&lt;/code&gt;&lt;/a&gt;) lies with the user.</source>
          <target state="translated">때 &lt;code&gt;check = true&lt;/code&gt; 분해가 실패 할 경우, 오류가 발생합니다. 때 &lt;code&gt;check = false&lt;/code&gt; (을 통해 분해의 유효성을 확인하기위한 책임 &lt;a href=&quot;#LinearAlgebra.issuccess&quot;&gt; &lt;code&gt;issuccess&lt;/code&gt; &lt;/a&gt; 사용자와) 거짓말을.</target>
        </trans-unit>
        <trans-unit id="a2637af6fced184f7f479f36a4ece7d55ae2e730" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;data&lt;/code&gt; is not given, the buffer will be both readable and writable by default.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 주어지지 않는, 버퍼는 기본적으로 판독 및 기록 가능 둘 것이다.</target>
        </trans-unit>
        <trans-unit id="bb1635e94802425023fba8788c61c2d8926fff7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p=1&lt;/code&gt;, the operator norm is the maximum absolute column sum of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;p=1&lt;/code&gt; , 오퍼레이터 규범의 최대 절대 열 합 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="178ec586817b3a48abe80b928aa2dde1b98626f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p=2&lt;/code&gt;, the operator norm is the spectral norm, equal to the largest singular value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;p=2&lt;/code&gt; , 오퍼레이터 규범 스펙트럼 규범의 가장 큰 특이 값과 동일 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c9763c674d94ae81ec6e72c5aee69686bbab29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p=Inf&lt;/code&gt;, the operator norm is the maximum absolute row sum of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;p=Inf&lt;/code&gt; , 조작 규범의 최대 절대 로우 합 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12ded29676df364ceceab6c572522fc9e2e7af30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sp = Sampler(rng, x, repetition)&lt;/code&gt;, &lt;code&gt;rand(rng, sp)&lt;/code&gt; will be used to draw random values, and should be defined accordingly.</source>
          <target state="translated">되면 &lt;code&gt;sp = Sampler(rng, x, repetition)&lt;/code&gt; , &lt;code&gt;rand(rng, sp)&lt;/code&gt; 랜덤 값을 그리는 데 사용되며, 그에 따라 정의되어야한다.</target>
        </trans-unit>
        <trans-unit id="86f72b2f90cae1c6e82409384ce1f3ceb6b9eefd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wait&lt;/code&gt; is false, the process' I/O streams are directed to &lt;code&gt;devnull&lt;/code&gt;. When &lt;code&gt;wait&lt;/code&gt; is true, I/O streams are shared with the parent process. Use &lt;a href=&quot;#Base.pipeline-Tuple%7BAny,Any,Any,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;pipeline&lt;/code&gt;&lt;/a&gt; to control I/O redirection.</source>
          <target state="translated">때 &lt;code&gt;wait&lt;/code&gt; 거짓, 프로세스는 'I / O 스트림로 연결됩니다 &lt;code&gt;devnull&lt;/code&gt; . 때 &lt;code&gt;wait&lt;/code&gt; 사실, 나는 / O 스트림은 부모 프로세스와 공유됩니다. &lt;a href=&quot;#Base.pipeline-Tuple%7BAny,Any,Any,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;pipeline&lt;/code&gt; &lt;/a&gt; 을 사용 하여 I / O 리디렉션을 제어 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6b99eaf978e18be85274c3305a641971a22fc94" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurs in a local scope, Julia applies the following rules to decide what the expression means based on where the assignment expression occurs and what &lt;code&gt;x&lt;/code&gt; already refers to at that location:</source>
          <target state="translated">경우 &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; 로컬 영역에서 발생 줄리아 발현 수단은, 대입 식 발생 위치에 따라 어떤할지 결정하기 위하여 다음과 같은 규칙을 적용 &lt;code&gt;x&lt;/code&gt; 이미하면 해당 위치를 말한다 :</target>
        </trans-unit>
        <trans-unit id="387339aa06f5aeaa40b73befd69307921f5c8373" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;const&lt;/code&gt; definition is only used to define an alias of another definition, such as is the case with the function &lt;code&gt;div&lt;/code&gt; and its alias &lt;code&gt;&amp;divide;&lt;/code&gt; in &lt;code&gt;Base&lt;/code&gt;, do not document the alias and instead document the actual function.</source>
          <target state="translated">때 &lt;code&gt;const&lt;/code&gt; 정의는 함수의 경우와 같이, 같은 또 다른 정의의 별칭을 정의하는 데 사용됩니다 &lt;code&gt;div&lt;/code&gt; 및 별칭 &lt;code&gt;&amp;divide;&lt;/code&gt; 에서 &lt;code&gt;Base&lt;/code&gt; 별명을 문서화하고 대신 실제 기능을 문서화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66405af7de66d28093c269eb102282edc9ad91d6" translate="yes" xml:space="preserve">
          <source>When a bare identifier or dot expression occurs after a semicolon, the keyword argument name is implied by the identifier or field name. For example &lt;code&gt;plot(x, y; width)&lt;/code&gt; is equivalent to &lt;code&gt;plot(x, y; width=width)&lt;/code&gt; and &lt;code&gt;plot(x, y; options.width)&lt;/code&gt; is equivalent to &lt;code&gt;plot(x, y; width=options.width)&lt;/code&gt;.</source>
          <target state="translated">베어 식별자 또는 점식이 세미콜론 뒤에 나오는 경우 키워드 인수 이름은 식별자 또는 필드 이름에 의해 암시됩니다. 예를 들어, &lt;code&gt;plot(x, y; width)&lt;/code&gt; 는 &lt;code&gt;plot(x, y; width=width)&lt;/code&gt; 와 &lt;code&gt;plot(x, y; options.width)&lt;/code&gt; 는 &lt;code&gt;plot(x, y; width=options.width)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d43f7beafb82d84f0b0ca093d70636ab00d5bb6c" translate="yes" xml:space="preserve">
          <source>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</source>
          <target state="translated">채널이 여러 작업에 바인딩 된 경우 가장 먼저 종료 할 작업이 채널을 닫습니다. 여러 채널이 동일한 작업에 바인딩 된 경우 작업을 종료하면 모든 바인딩 된 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="59c8aa513c5811a7c3a8d7b2460bea25a7005e55" translate="yes" xml:space="preserve">
          <source>When a file is run as the main script using &lt;code&gt;julia file.jl&lt;/code&gt; one might want to activate extra functionality like command line argument handling. A way to determine that a file is run in this fashion is to check if &lt;code&gt;abspath(PROGRAM_FILE) == @__FILE__&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;julia file.jl&lt;/code&gt; 을 사용하여 파일을 기본 스크립트로 실행하면 명령 줄 인수 처리와 같은 추가 기능을 활성화 할 수 있습니다. 이러한 방식으로 파일이 실행되는지 확인하는 방법은 &lt;code&gt;abspath(PROGRAM_FILE) == @__FILE__&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인지 확인하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="5e7501453daabe62281039e1cf6e34fa2839c62e" translate="yes" xml:space="preserve">
          <source>When a piece of computing work (in practice, executing a particular function) is designated as a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, it becomes possible to interrupt it by switching to another &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;. The original &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.</source>
          <target state="translated">컴퓨팅 작업 (실제로 특정 기능 실행)이 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 로 지정된 경우 다른 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 로 전환하여이를 중단 할 수 있습니다 . 나중에 원래 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 다시 시작할 수 있으며,이 시점에서 중단 된 지점에서 바로 시작할 수 있습니다. 처음에는 함수 호출과 비슷하게 보일 수 있습니다. 그러나 두 가지 주요 차이점이 있습니다. 첫째, 작업 전환은 공간을 사용하지 않으므로 호출 스택을 소비하지 않고 여러 작업 전환이 발생할 수 있습니다. 둘째, 함수 호출과 달리 작업간에 전환이 발생할 수 있습니다. 함수 호출은 제어가 호출 함수로 돌아 가기 전에 호출 된 함수의 실행을 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c322e0ffc2096cd6324029e4fa443fabe59bd5d8" translate="yes" xml:space="preserve">
          <source>When a program needs to interact with the outside world, for example communicating with another machine over the internet, operations in the program may need to happen in an unpredictable order. Say your program needs to download a file. We would like to initiate the download operation, perform other operations while we wait for it to complete, and then resume the code that needs the downloaded file when it is available. This sort of scenario falls in the domain of asynchronous programming, sometimes also referred to as concurrent programming (since, conceptually, multiple things are happening at once).</source>
          <target state="translated">예를 들어 인터넷을 통해 다른 컴퓨터와 통신하는 등 프로그램이 외부 세계와 상호 작용해야하는 경우 프로그램의 작업이 예측할 수없는 순서로 발생해야 할 수 있습니다. 프로그램에서 파일을 다운로드해야한다고 가정합니다. 다운로드 작업을 시작하고 완료 될 때까지 기다리는 동안 다른 작업을 수행 한 다음 다운로드 된 파일이 사용 가능할 때 필요한 코드를 다시 시작하려고합니다. 이러한 종류의 시나리오는 동시 프로그래밍이라고도하는 비동기 프로그래밍의 영역에 속합니다 (개념적으로 여러 가지가 한 번에 발생하기 때문에).</target>
        </trans-unit>
        <trans-unit id="6c9979982b20b6ded943786342ff40e25b341c71" translate="yes" xml:space="preserve">
          <source>When a scalar value is passed with &lt;code&gt;&amp;amp;&lt;/code&gt; as an argument of type &lt;code&gt;Ptr{T}&lt;/code&gt;, the value will first be converted to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ptr{T}&lt;/code&gt; 유형의 인수 로 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하여 스칼라 값이 전달 되면 값은 먼저 유형 &lt;code&gt;T&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe81791971f41be5d7864ff7745e79391be55d47" translate="yes" xml:space="preserve">
          <source>When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression interpolation and &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; allow such code generation to take place in the normal course of program execution. For example, consider the following custom type</source>
          <target state="translated">대량의 반복 상용구 코드가 필요한 경우 중복성을 피하기 위해 프로그래밍 방식으로 코드를 생성하는 것이 일반적입니다. 대부분의 언어에서 반복 빌드 코드를 생성하려면 별도의 빌드 단계와 별도의 프로그램이 필요합니다. Julia에서는 표현식 보간 및 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 통해 일반적인 코드 실행 과정에서 이러한 코드 생성을 수행 할 수 있습니다. 예를 들어 다음과 같은 사용자 정의 유형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1094197338bf27238baecc37ce0fa2dfa2098d" translate="yes" xml:space="preserve">
          <source>When a type is applied like a function it is called a &lt;em&gt;constructor&lt;/em&gt;. Two constructors are generated automatically (these are called &lt;em&gt;default constructors&lt;/em&gt;). One accepts any arguments and calls &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; to convert them to the types of the fields, and the other accepts arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions without inadvertently replacing a default constructor.</source>
          <target state="translated">유형이 함수처럼 적용되면 &lt;em&gt;생성자&lt;/em&gt; 라고합니다 . 두 생성자가 자동으로 생성됩니다 ( &lt;em&gt;기본 생성자&lt;/em&gt; 라고 함 ). 하나는 인수를 허용하고 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 를 호출 하여 필드 유형으로 변환하고 다른 하나는 필드 유형과 정확히 일치하는 인수를 허용합니다. 이 두 가지가 생성되는 이유는 기본 생성자를 실수로 바꾸지 않고도 새로운 정의를 쉽게 추가 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="98d1d001e4fb72f4a3da5b80ba6df14e5f1fa86f" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Integer&lt;/code&gt;-type value is needed, use &lt;code&gt;Integer(maxintfloat(T))&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;Integer&lt;/code&gt; 타입 값이 필요하고, 사용하는 &lt;code&gt;Integer(maxintfloat(T))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec02c864c4b4a52ed32380f6bbcf97149ade981" translate="yes" xml:space="preserve">
          <source>When an array is passed to C as a &lt;code&gt;Ptr{T}&lt;/code&gt; argument, it is not reinterpret-cast: Julia requires that the element type of the array matches &lt;code&gt;T&lt;/code&gt;, and the address of the first element is passed.</source>
          <target state="translated">배열이 &lt;code&gt;Ptr{T}&lt;/code&gt; 인수 로 C에 전달되면 해석되지 않습니다. Julia는 배열의 요소 유형이 &lt;code&gt;T&lt;/code&gt; 와 일치해야 하며 첫 번째 요소의 주소가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8566fd6fe66598ffc21c0e41c119f24c167f7a3e" translate="yes" xml:space="preserve">
          <source>When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback. The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger &amp;mdash; that is, the logger should be &lt;em&gt;dynamically scoped&lt;/em&gt;. (This is a point of contrast with logging frameworks where the logger is &lt;em&gt;lexically scoped&lt;/em&gt;; provided explicitly by the module author or as a simple global variable. In such a system it's awkward to control logging while composing functionality from multiple modules.)</source>
          <target state="translated">이벤트가 트리거되면 글로벌 로거를 폴백으로 사용하는 태스크 로컬 로거를 찾아 해당 로거를 찾습니다. 여기서의 아이디어는 응용 프로그램 코드가 로그 이벤트를 처리하는 방법을 알고 있으며 호출 스택 맨 위에 존재한다는 것입니다. 따라서 우리는 로거를 발견하기 위해 호출 스택을 조사해야합니다 . 즉, 로거는 &lt;em&gt;동적으로 범위가 지정&lt;/em&gt; 되어야합니다 . (이것은 로거가 &lt;em&gt;어휘 범위&lt;/em&gt; 가 &lt;em&gt;지정된&lt;/em&gt; 로깅 프레임 워크와 대조적입니다 . 모듈 작성자가 명시 적으로 제공하거나 간단한 전역 변수입니다. 이러한 시스템에서는 여러 모듈의 기능을 구성하는 동안 로깅을 제어하기가 어렵습니다.)</target>
        </trans-unit>
        <trans-unit id="981c7afc180e088292ad80d1981131b0506db6e1" translate="yes" xml:space="preserve">
          <source>When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:</source>
          <target state="translated">이벤트가 발생하면 폐기 될 메시지 생성을 피하기 위해 몇 단계의 조기 필터링이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe255a18b8e1451834d407df7913b2e3977086f0" translate="yes" xml:space="preserve">
          <source>When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller. In such cases, it may be best for the exceptional condition to either terminate the program while printing a diagnostic error message, or if the programmer has provided code to handle such exceptional circumstances then allow that code to take the appropriate action.</source>
          <target state="translated">예기치 않은 조건이 발생하면 함수가 호출자에게 합리적인 값을 반환하지 못할 수 있습니다. 이러한 경우 진단 오류 메시지를 인쇄하는 동안 프로그램을 종료하거나 예외 상황을 처리하는 코드를 프로그래머가 제공 한 경우 예외 조건이 해당 코드가 적절한 조치를 취할 수 있도록하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7d51c32014a3d44fbfbe45092f164ea5ddadbfc7" translate="yes" xml:space="preserve">
          <source>When appended to a variable on the left-hand side of an assignment, or as part of a &lt;code&gt;local&lt;/code&gt; declaration, the &lt;code&gt;::&lt;/code&gt; operator means something a bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to the declared type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">할당의 왼쪽에있는 변수에 추가되거나 &lt;code&gt;local&lt;/code&gt; 선언의 일부로 &lt;code&gt;::&lt;/code&gt; 연산자는 약간 다른 것을 의미합니다 : 변수는 항상 형식 선언과 같은 지정된 유형을 갖도록 선언합니다. C와 같은 정적으로 유형이 지정된 언어. 변수에 지정된 모든 값은 convert를 사용하여 선언 된 유형으로 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef999f924ed2b51c873965e3d0169626b4f532c7" translate="yes" xml:space="preserve">
          <source>When appended to an expression computing a value, the &lt;code&gt;::&lt;/code&gt; operator is read as &quot;is an instance of&quot;. It can be used anywhere to assert that the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the left must have that type as its implementation &amp;ndash; recall that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:</source>
          <target state="translated">값을 계산하는 표현식에 추가 될 때 &lt;code&gt;::&lt;/code&gt; 연산자는 &quot;인스턴스&quot;로 읽습니다. 왼쪽에있는 표현식의 값이 오른쪽에있는 유형의 인스턴스라고 주장하기 위해 어디에서나 사용할 수 있습니다. 오른쪽에있는 유형이 구체적 일 때 왼쪽에있는 값은 구현할 때 해당 유형을 가져야합니다. 모든 구체적인 유형이 최종적이므로 구현이 다른 유형의 하위 유형이 아님을 상기하십시오. 유형이 추상 인 경우 추상 유형의 하위 유형 인 구체적 유형으로 값을 구현하기에 충분합니다. 형식 어설 션이 true가 아니면 예외가 발생하고, 그렇지 않으면 왼쪽 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="15c43c8db23e17e00320a3451d1f8da6af7074e8" translate="yes" xml:space="preserve">
          <source>When are deprecated functions removed?</source>
          <target state="translated">더 이상 사용되지 않는 기능은 언제 제거됩니까?</target>
        </trans-unit>
        <trans-unit id="3ea78d13024c34e2f2791c359e186295012c1709" translate="yes" xml:space="preserve">
          <source>When broadcasting with &lt;code&gt;in.(items, collection)&lt;/code&gt; or &lt;code&gt;items .&amp;isin; collection&lt;/code&gt;, both &lt;code&gt;item&lt;/code&gt; and &lt;code&gt;collection&lt;/code&gt; are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection &lt;code&gt;items&lt;/code&gt; is &lt;code&gt;in&lt;/code&gt; the value at the corresponding position in &lt;code&gt;collection&lt;/code&gt;. To get a vector indicating whether each value in &lt;code&gt;items&lt;/code&gt; is in &lt;code&gt;collection&lt;/code&gt;, wrap &lt;code&gt;collection&lt;/code&gt; in a tuple or a &lt;code&gt;Ref&lt;/code&gt; like this: &lt;code&gt;in.(items, Ref(collection))&lt;/code&gt; or &lt;code&gt;items .&amp;isin; Ref(collection)&lt;/code&gt;.</source>
          <target state="translated">함께 방송 할 때 &lt;code&gt;in.(items, collection)&lt;/code&gt; 또는 &lt;code&gt;items .&amp;isin; collection&lt;/code&gt; 두 &lt;code&gt;item&lt;/code&gt; 및 &lt;code&gt;collection&lt;/code&gt; 목적으로 무엇을 종종 인을 통해 방송된다. 모두 인수 벡터이다 (및 크기가 일치) 예를 들어, 그 결과는 컬렉션의 각 값인지 여부를 나타내는 벡터 인 &lt;code&gt;items&lt;/code&gt; 인 &lt;code&gt;in&lt;/code&gt; 의 해당 위치의 값 &lt;code&gt;collection&lt;/code&gt; . &lt;code&gt;items&lt;/code&gt; 각 값 이 &lt;code&gt;collection&lt;/code&gt; 에 있는지 여부를 나타내는 벡터를 얻으려면 &lt;code&gt;collection&lt;/code&gt; 을 튜플 또는 &lt;code&gt;Ref&lt;/code&gt; 로 다음 과 같이 래핑 합니다. &lt;code&gt;in.(items, Ref(collection))&lt;/code&gt; 또는 &lt;code&gt;items .&amp;isin; Ref(collection)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092ed6ff2b31aa14c009c043eed4169ab86f21f9" translate="yes" xml:space="preserve">
          <source>When broadcasting with &lt;code&gt;items .&amp;notin; collection&lt;/code&gt;, both &lt;code&gt;item&lt;/code&gt; and &lt;code&gt;collection&lt;/code&gt; are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection &lt;code&gt;items&lt;/code&gt; is not in the value at the corresponding position in &lt;code&gt;collection&lt;/code&gt;. To get a vector indicating whether each value in &lt;code&gt;items&lt;/code&gt; is not in &lt;code&gt;collection&lt;/code&gt;, wrap &lt;code&gt;collection&lt;/code&gt; in a tuple or a &lt;code&gt;Ref&lt;/code&gt; like this: &lt;code&gt;items .&amp;notin; Ref(collection)&lt;/code&gt;.</source>
          <target state="translated">함께 방송 할 때 &lt;code&gt;items .&amp;notin; collection&lt;/code&gt; , 두 &lt;code&gt;item&lt;/code&gt; 및 &lt;code&gt;collection&lt;/code&gt; 목적으로 무엇을 종종 인을 통해 방송된다. 예를 들어 두 인수가 모두 벡터이고 차원이 일치하는 경우 결과는 컬렉션 &lt;code&gt;items&lt;/code&gt; 각 값이 collection 의 해당 위치에있는 값에 없는지 여부를 나타내는 벡터 &lt;code&gt;collection&lt;/code&gt; . &lt;code&gt;items&lt;/code&gt; 의 각 값 이 &lt;code&gt;collection&lt;/code&gt; 에 없는지 여부를 나타내는 벡터를 얻으려면 &lt;code&gt;collection&lt;/code&gt; 을 튜플 또는 &lt;code&gt;Ref&lt;/code&gt; 로 다음 과 같이 래핑 하십시오 : &lt;code&gt;items .&amp;notin; Ref(collection)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d2e75685386e4e2827a83db4cca905b6c592eba" translate="yes" xml:space="preserve">
          <source>When building generic code, there is often a need for constructing a similar object with some change made to the layout of the type, also necessitating a change of the type parameters. For instance, you might have some sort of abstract array with an arbitrary element type and want to write your computation on it with a specific element type. We must implement a method for each &lt;code&gt;AbstractArray{T}&lt;/code&gt; subtype that describes how to compute this type transform. There is no general transform of one subtype into another subtype with a different parameter. (Quick review: do you see why this is?)</source>
          <target state="translated">일반 코드를 작성할 때 유형 레이아웃에 약간의 변경이있는 유사한 객체를 생성해야 할 필요가 있으며, 유형 매개 변수도 변경해야합니다. 예를 들어, 임의의 요소 유형을 가진 일종의 추상 배열이 있고 특정 요소 유형으로 계산을 작성하려고 할 수 있습니다. 이 유형 변환을 계산하는 방법을 설명하는 각 &lt;code&gt;AbstractArray{T}&lt;/code&gt; 하위 유형에 대한 메소드를 구현해야합니다 . 하나의 하위 유형을 다른 매개 변수를 가진 다른 하위 유형으로 변환하는 것은 없습니다. (빠른 검토 : 이것이 왜 그런지 아십니까?)</target>
        </trans-unit>
        <trans-unit id="195feaadaa8ee8245dc0e0889f4840c1a8154919" translate="yes" xml:space="preserve">
          <source>When called with no arguments, the temporary name will be an absolute path to a temporary name in the system temporary directory as given by &lt;code&gt;tempdir()&lt;/code&gt;. If a &lt;code&gt;parent&lt;/code&gt; directory argument is given, the temporary path will be in that directory instead.</source>
          <target state="translated">인수없이 호출되면 임시 이름은 &lt;code&gt;tempdir()&lt;/code&gt; 의해 제공된 시스템 임시 디렉토리의 임시 이름에 대한 절대 경로가됩니다 . 경우 &lt;code&gt;parent&lt;/code&gt; 디렉토리 인수가 주어 임시 경로 대신 그 디렉토리에있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="bacb27a3db8ad4d6fa07c864549f990e1b1f9b09" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;#Libdl.dlopen&quot;&gt;&lt;code&gt;dlopen&lt;/code&gt;&lt;/a&gt;, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.</source>
          <target state="translated">&lt;a href=&quot;#Libdl.dlopen&quot;&gt; &lt;code&gt;dlopen&lt;/code&gt; 을&lt;/a&gt; 호출 하면 유효한 라이브러리 핸들에 대한 시스템 위치를 검색하기 전에이 목록의 경로가 순서대로 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7e9d8c42190544bd3e1564f8b8ba2bd51f8bbc" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, you have the option to specify an index at which to start the search. For example:</source>
          <target state="translated">&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; 를&lt;/a&gt; 호출 하면 검색을 시작할 인덱스를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e92c3b1df4a4ce3ed62a3bfa6e7cf7fe1b90182a" translate="yes" xml:space="preserve">
          <source>When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional &lt;code&gt;Ptr{..}&lt;/code&gt; or &lt;code&gt;Ref{..}&lt;/code&gt; wrapper around their type specification.</source>
          <target state="translated">Fortran을 호출 할 때 모든 입력은 힙 또는 스택 할당 값에 대한 포인터를 통해 전달되어야하므로 위의 모든 유형 대응에는 유형 지정에 대한 추가 &lt;code&gt;Ptr{..}&lt;/code&gt; 또는 &lt;code&gt;Ref{..}&lt;/code&gt; 래퍼 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e331cf313a89110c14bb50e3eee2e7301f9cb8b" translate="yes" xml:space="preserve">
          <source>When chaining conditionals (including &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elseif&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;), the &lt;code&gt;@static&lt;/code&gt; must be repeated for each level (parentheses optional, but recommended for readability):</source>
          <target state="translated">조건을 연결하는 &lt;code&gt;if&lt;/code&gt; ( &lt;code&gt;elseif&lt;/code&gt; / elseif / &lt;code&gt;end&lt;/code&gt; 포함 ) 각 레벨에 대해 &lt;code&gt;@static&lt;/code&gt; 을 반복해야합니다 (괄호는 선택 사항이지만 가독성을 위해 권장 됨).</target>
        </trans-unit>
        <trans-unit id="748b100cf67a798bdbecc39743101fa41a0714e1" translate="yes" xml:space="preserve">
          <source>When checking if a value is equal to some singleton it can be better for performance to check for identicality (&lt;code&gt;===&lt;/code&gt;) instead of equality (&lt;code&gt;==&lt;/code&gt;). The same advice applies to using &lt;code&gt;!==&lt;/code&gt; over &lt;code&gt;!=&lt;/code&gt;. These type of checks frequently occur e.g. when implementing the iteration protocol and checking if &lt;code&gt;nothing&lt;/code&gt; is returned from &lt;a href=&quot;../../base/collections/index#Base.iterate&quot;&gt;&lt;code&gt;iterate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값이 어떤 싱글 톤과 같은지 확인할 때 성능 이 동일성 ( &lt;code&gt;==&lt;/code&gt; ) 대신 동일성 ( &lt;code&gt;===&lt;/code&gt; ) 을 확인하는 것이 더 나을 수 있습니다 . &lt;code&gt;!==&lt;/code&gt; over &lt;code&gt;!=&lt;/code&gt; 를 사용하는 경우에도 동일한 조언이 적용됩니다 . 이러한 유형의 검사는 예를 들어 반복 프로토콜을 구현하고 반복 에서 &lt;code&gt;nothing&lt;/code&gt; 반환되지 &lt;a href=&quot;../../base/collections/index#Base.iterate&quot;&gt; &lt;code&gt;iterate&lt;/code&gt; &lt;/a&gt; 확인할 때 자주 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="15b9050639b920ff695156fa848d7ac41786789d" translate="yes" xml:space="preserve">
          <source>When control leaves the &lt;a href=&quot;#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; block (for example, due to a &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;, or just finishing normally), &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close(f)&lt;/code&gt;&lt;/a&gt; will be executed. If the &lt;code&gt;try&lt;/code&gt; block exits due to an exception, the exception will continue propagating. A &lt;code&gt;catch&lt;/code&gt; block may be combined with &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; as well. In this case the &lt;code&gt;finally&lt;/code&gt; block will run after &lt;code&gt;catch&lt;/code&gt; has handled the error.</source>
          <target state="translated">제어가 &lt;a href=&quot;#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 블록을 벗어나면 (예 : &lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 으로 인해 또는 정상적으로 종료 됨) &lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close(f)&lt;/code&gt; &lt;/a&gt; 가 실행됩니다. 경우] &lt;code&gt;try&lt;/code&gt; 블록 종료 예외로 인해 예외가 전파를 계속합니다. &lt;code&gt;catch&lt;/code&gt; 블록과 결합 될 수있다 &lt;code&gt;try&lt;/code&gt; 하고 &lt;code&gt;finally&lt;/code&gt; 뿐만 아니라. 이 경우 &lt;code&gt;finally&lt;/code&gt; 블록은 &lt;code&gt;catch&lt;/code&gt; 가 오류를 처리 한 후에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="174b27ef1832006fe6218d3c983f95e289715bc3" translate="yes" xml:space="preserve">
          <source>When control leaves the &lt;a href=&quot;#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; block (for example, due to a &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;, or just finishing normally), &lt;code&gt;close(f)&lt;/code&gt; will be executed. If the &lt;code&gt;try&lt;/code&gt; block exits due to an exception, the exception will continue propagating. A &lt;code&gt;catch&lt;/code&gt; block may be combined with &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; as well. In this case the &lt;code&gt;finally&lt;/code&gt; block will run after &lt;code&gt;catch&lt;/code&gt; has handled the error.</source>
          <target state="translated">제어가 &lt;a href=&quot;#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 블록을 벗어나면 (예를 들어 &lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 또는 정상적으로 마무리 로 인해 ) &lt;code&gt;close(f)&lt;/code&gt; 가 실행됩니다. 경우] &lt;code&gt;try&lt;/code&gt; 블록 종료 예외로 인해 예외가 전파를 계속합니다. &lt;code&gt;catch&lt;/code&gt; 블록과 결합 될 수있다 &lt;code&gt;try&lt;/code&gt; 하고 &lt;code&gt;finally&lt;/code&gt; 뿐만 아니라. 이 경우 &lt;code&gt;catch&lt;/code&gt; 가 오류를 처리 한 후 &lt;code&gt;finally&lt;/code&gt; 블록이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac01620653b38b07c8e2f2811a030ec92b4e1ad9" translate="yes" xml:space="preserve">
          <source>When control leaves the &lt;code&gt;try&lt;/code&gt; block (for example due to a &lt;code&gt;return&lt;/code&gt;, or just finishing normally), &lt;code&gt;close(f)&lt;/code&gt; will be executed. If the &lt;code&gt;try&lt;/code&gt; block exits due to an exception, the exception will continue propagating. A &lt;code&gt;catch&lt;/code&gt; block may be combined with &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; as well. In this case the &lt;code&gt;finally&lt;/code&gt; block will run after &lt;code&gt;catch&lt;/code&gt; has handled the error.</source>
          <target state="translated">제어가 &lt;code&gt;try&lt;/code&gt; 블록을 벗어나면 (예 : &lt;code&gt;return&lt;/code&gt; 또는 정상적으로 마무리 로 인해 ) &lt;code&gt;close(f)&lt;/code&gt; 가 실행됩니다. 경우] &lt;code&gt;try&lt;/code&gt; 블록 종료 예외로 인해 예외가 전파를 계속합니다. &lt;code&gt;catch&lt;/code&gt; 블록과 결합 될 수있다 &lt;code&gt;try&lt;/code&gt; 하고 &lt;code&gt;finally&lt;/code&gt; 뿐만 아니라. 이 경우 &lt;code&gt;catch&lt;/code&gt; 가 오류를 처리 한 후 &lt;code&gt;finally&lt;/code&gt; 블록이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2509f68dfaaa3b26bf821c041139b558402f6a85" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;format&lt;/code&gt; you can use any non-code characters as a separator. For example to generate the string &quot;1996-01-15T00:00:00&quot; you could use &lt;code&gt;format&lt;/code&gt;: &quot;yyyy-mm-ddTHH:MM:SS&quot;. Note that if you need to use a code character as a literal you can use the escape character backslash. The string &quot;1996y01m&quot; can be produced with the format &quot;yyyy\ymm\m&quot;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 을 만들 때 코드가 아닌 문자를 구분 기호로 사용할 수 있습니다. 예를 들어 &quot;1996-01-15T00 : 00 : 00&quot;문자열을 생성하려면 &quot;yyyy-mm-ddTHH : MM : SS&quot; &lt;code&gt;format&lt;/code&gt; 사용할 수 있습니다 . 코드 문자를 리터럴로 사용해야하는 경우 이스케이프 문자 백 슬래시를 사용할 수 있습니다. 문자열 &quot;1996y01m&quot;은 &quot;yyyy \ ymm \ m&quot;형식으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfb77e0645f23f4b5b667261005ff3593239667" translate="yes" xml:space="preserve">
          <source>When defining a function, one can optionally constrain the types of parameters it is applicable to, using the &lt;code&gt;::&lt;/code&gt; type-assertion operator, introduced in the section on &lt;a href=&quot;../types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt;:</source>
          <target state="translated">함수를 정의 할 때 &lt;a href=&quot;../types/index#Composite-Types&quot;&gt;복합 유형&lt;/a&gt; 섹션에 소개 된 &lt;code&gt;::&lt;/code&gt; 유형 어설 션 연산자를 사용하여 적용 가능한 매개 변수 유형을 선택적으로 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1de1f7de90353d88ef9000e4f79f92b8c808bdb2" translate="yes" xml:space="preserve">
          <source>When defining a function, one can optionally constrain the types of parameters it is applicable to, using the &lt;code&gt;::&lt;/code&gt; type-assertion operator, introduced in the section on &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt;:</source>
          <target state="translated">함수를 정의 할 때, &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; 섹션에 소개 된 &lt;code&gt;::&lt;/code&gt; type-assertion 연산자를 사용하여 적용 가능한 매개 변수 유형을 선택적으로 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="152d609433f05c2afbaef9a063010fb7cf671728" translate="yes" xml:space="preserve">
          <source>When defining a new type, initially all ways of creating it should be defined as constructors. If it becomes clear that implicit conversion would be useful, and that some constructors meet the above &quot;safety&quot; criteria, then &lt;code&gt;convert&lt;/code&gt; methods can be added. These methods are typically quite simple, as they only need to call the appropriate constructor. Such a definition might look like this:</source>
          <target state="translated">새로운 타입을 정의 할 때, 처음에는 타입을 만드는 모든 방법을 생성자로 정의해야합니다. 암시 적 변환이 유용하고 일부 생성자가 위의 &quot;안전성&quot;기준을 충족한다는 것이 명확 해지면 &lt;code&gt;convert&lt;/code&gt; 메소드를 추가 할 수 있습니다. 이러한 메소드는 적절한 생성자를 호출하기 만하면되기 때문에 일반적으로 매우 단순합니다. 이러한 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="884ef6ca30a2264b960b8f9a3b28841cea79d9f1" translate="yes" xml:space="preserve">
          <source>When defining generated functions, there are five main differences to ordinary functions:</source>
          <target state="translated">생성 된 함수를 정의 할 때 일반 함수와는 5 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c61f17e48da1bcacb16f9549d16af7280e11ed" translate="yes" xml:space="preserve">
          <source>When defining generated functions, there are four main differences to ordinary functions:</source>
          <target state="translated">생성 된 함수를 정의 할 때 일반 함수와 4 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49efec53aeb1ae624503fb2c22137ba91bb625ee" translate="yes" xml:space="preserve">
          <source>When designing APIs, adhering to this general order as much as possible is likely to give users of your functions a more consistent experience.</source>
          <target state="translated">API를 디자인 할 때이 일반적인 순서를 최대한 준수하면 함수 사용자에게보다 일관된 환경을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a941f10446d75f8958c1348bd2a746eb967d2e21" translate="yes" xml:space="preserve">
          <source>When exactly one index &lt;code&gt;i&lt;/code&gt; is provided, that index no longer represents a location in a particular dimension of the array. Instead, it selects the &lt;code&gt;i&lt;/code&gt;th element using the column-major iteration order that linearly spans the entire array. This is known as &lt;em&gt;linear indexing&lt;/em&gt;. It essentially treats the array as though it had been reshaped into a one-dimensional vector with &lt;a href=&quot;../../base/arrays/index#Base.vec&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정확히 하나의 인덱스 &lt;code&gt;i&lt;/code&gt; 가 제공되면 해당 인덱스는 더 이상 배열의 특정 차원에서의 위치를 ​​나타내지 않습니다. 대신, 전체 배열에 선형으로 걸쳐있는 열 주요 반복 순서를 사용하여 &lt;code&gt;i&lt;/code&gt; 번째 요소를 선택합니다 . 이것을 &lt;em&gt;선형 인덱싱&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 본질적으로 배열을 &lt;a href=&quot;../../base/arrays/index#Base.vec&quot;&gt; &lt;code&gt;vec&lt;/code&gt; 로&lt;/a&gt; 1 차원 벡터로 재구성 한 것처럼 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="d3d4ab6d8c0ec75d6d289814f9629ec5250796ab" translate="yes" xml:space="preserve">
          <source>When executing a remote function in parallel:</source>
          <target state="translated">원격 기능을 병렬로 실행할 때 :</target>
        </trans-unit>
        <trans-unit id="60bf875610ed5f18bb5771424d18a32cfa69cc45" translate="yes" xml:space="preserve">
          <source>When fetching data from LibGit2, a typical usage would look like:</source>
          <target state="translated">LibGit2에서 데이터를 가져올 때 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f5749e51bc8ddb6474c3a822e03c976f400cb95" translate="yes" xml:space="preserve">
          <source>When is &lt;code&gt;convert&lt;/code&gt; called?</source>
          <target state="translated">언제 &lt;code&gt;convert&lt;/code&gt; 호출됩니까?</target>
        </trans-unit>
        <trans-unit id="0bf200d46aca80912e82e9a0512bf3a557089224" translate="yes" xml:space="preserve">
          <source>When issuing a hint, the output should typically start with &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">힌트를 발행 할 때 출력은 일반적으로 &lt;code&gt;\n&lt;/code&gt; 으로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="033992315c0171a5bb54828a5de11a8f7b44c1ac" translate="yes" xml:space="preserve">
          <source>When loading from a pointer with &lt;code&gt;unsafe_load&lt;/code&gt;, the underlying object is implicitly used, for example &lt;code&gt;x&lt;/code&gt; is implicitly used by &lt;code&gt;unsafe_load(p)&lt;/code&gt; in the following:</source>
          <target state="translated">&lt;code&gt;unsafe_load&lt;/code&gt; 를 사용하여 포인터에서로드 할 때 기본 객체가 암시 적으로 사용됩니다. 예를 들어 &lt;code&gt;x&lt;/code&gt; 는 다음에서 &lt;code&gt;unsafe_load(p)&lt;/code&gt; 에 의해 암시 적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="18bdbef12210d17b4e3031ada949009b49167f95" translate="yes" xml:space="preserve">
          <source>When no supertype is given, the default supertype is &lt;code&gt;Any&lt;/code&gt; &amp;ndash; a predefined abstract type that all objects are instances of and all types are subtypes of. In type theory, &lt;code&gt;Any&lt;/code&gt; is commonly called &quot;top&quot; because it is at the apex of the type graph. Julia also has a predefined abstract &quot;bottom&quot; type, at the nadir of the type graph, which is written as &lt;code&gt;Union{}&lt;/code&gt;. It is the exact opposite of &lt;code&gt;Any&lt;/code&gt;: no object is an instance of &lt;code&gt;Union{}&lt;/code&gt; and all types are supertypes of &lt;code&gt;Union{}&lt;/code&gt;.</source>
          <target state="translated">수퍼 타입이 지정되지 않은 경우 기본 수퍼 타입은 &lt;code&gt;Any&lt;/code&gt; &amp;ndash; 모든 객체가 인스턴스이고 모든 유형이 서브 타입 인 사전 정의 된 추상 유형입니다. 유형 이론에서 &lt;code&gt;Any&lt;/code&gt; 는 유형 그래프의 정점에 있기 때문에 일반적으로 &quot;top&quot;이라고합니다. Julia는 또한 유형 그래프의 nadir에 사전 정의 된 추상 &quot;하단&quot;유형을 가지며 &lt;code&gt;Union{}&lt;/code&gt; 로 작성됩니다 . &lt;code&gt;Any&lt;/code&gt; 와 완전히 반대입니다 . 어떤 개체도 &lt;code&gt;Union{}&lt;/code&gt; 의 인스턴스가 아니며 모든 유형은 &lt;code&gt;Union{}&lt;/code&gt; 수퍼 타입입니다 .</target>
        </trans-unit>
        <trans-unit id="1fcc651112bb76903e5ae0a3bf204e82def56437" translate="yes" xml:space="preserve">
          <source>When omitting &lt;em&gt;all&lt;/em&gt; indices with &lt;code&gt;A[]&lt;/code&gt;, this semantic provides a simple idiom to retrieve the only element in an array and simultaneously ensure that there was only one element.</source>
          <target state="translated">&lt;code&gt;A[]&lt;/code&gt; &lt;em&gt;모든&lt;/em&gt; 인덱스를 생략 할 때이 의미 체계는 배열의 유일한 요소를 검색하고 동시에 하나의 요소 만 있는지 확인하는 간단한 관용구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25a0968a84486d9bb369e312765b66f12f135bdd" translate="yes" xml:space="preserve">
          <source>When only the type of supplied arguments needs to be constrained &lt;code&gt;Vararg{T}&lt;/code&gt; can be equivalently written as &lt;code&gt;T...&lt;/code&gt;. For instance &lt;code&gt;f(x::Int...) = x&lt;/code&gt; is a shorthand for &lt;code&gt;f(x::Vararg{Int}) = x&lt;/code&gt;.</source>
          <target state="translated">제공된 인수의 유형 만 제한 &lt;code&gt;Vararg{T}&lt;/code&gt; 는 &lt;code&gt;T...&lt;/code&gt; 로 동등하게 작성할 수 있습니다 . 예를 들어 &lt;code&gt;f(x::Int...) = x&lt;/code&gt; 는 &lt;code&gt;f(x::Vararg{Int}) = x&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="4bc2691546974788c6f5f633b5af60f15dc7f704" translate="yes" xml:space="preserve">
          <source>When optional and keyword argument default expressions are evaluated, only &lt;em&gt;previous&lt;/em&gt; arguments are in scope. For example, given this definition:</source>
          <target state="translated">선택적 및 키워드 인수 기본 표현식이 평가되면 &lt;em&gt;이전&lt;/em&gt; 인수 만 범위에 있습니다. 예를 들어 다음과 같이 정의하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="328ccbd822376eb34037743aedfc016fe4fbbce4" translate="yes" xml:space="preserve">
          <source>When passed as a &lt;code&gt;ccall&lt;/code&gt; argument (either as a &lt;code&gt;Ptr&lt;/code&gt; or &lt;code&gt;Ref&lt;/code&gt; type), a &lt;code&gt;Ref&lt;/code&gt; object will be converted to a native pointer to the data it references.</source>
          <target state="translated">A와 전달하면 &lt;code&gt;ccall&lt;/code&gt; 의 (중 하나로서 인수 &lt;code&gt;Ptr&lt;/code&gt; 또는 &lt;code&gt;Ref&lt;/code&gt; 형)하는 &lt;code&gt;Ref&lt;/code&gt; 객체는 데이터 그 참조에 네이티브 포인터로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff24cc69534fdb104d1c11f0a561a2d6006bd40" translate="yes" xml:space="preserve">
          <source>When passing data to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, it is best to avoid using the &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt; function. Instead define a convert method and pass the variables directly to the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type &lt;code&gt;Array{Ref,1}&lt;/code&gt; to hold these values, until the C library notifies you that it is finished with them.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 데이터를 전달할 때는 &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt; 함수를 사용하지 않는 것이 가장 좋습니다 . 대신 convert 메소드를 정의하고 변수를 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 직접 전달하십시오 . &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 은 호출이 반환 될 때까지 모든 인수가 가비지 수집에서 유지 되도록 자동으로 정렬합니다. C API가 Julia가 할당 한 메모리에 대한 참조를 저장하는 경우 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 이&lt;/a&gt; 리턴 된 후 오브젝트가 가비지 콜렉터에 계속 표시되도록 정렬해야합니다. 이를 처리하기 위해 제안 된 방법 은 C 라이브러리가 완료되었음을 알릴 때까지 &lt;code&gt;Array{Ref,1}&lt;/code&gt; 유형의 전역 변수 가이 값을 보유하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="621b4b8b5a5149c69191e35b8edeeea1183d955f" translate="yes" xml:space="preserve">
          <source>When passing data to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, it is best to avoid using the &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt; function. Instead define a convert method and pass the variables directly to the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; returns, you must ensure that the object remains visible to the garbage collector. The suggested way to do this is to make a global variable of type &lt;code&gt;Array{Ref,1}&lt;/code&gt; to hold these values, until the C library notifies you that it is finished with them.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 데이터를 전달할 때 &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt; 함수를 사용하지 않는 것이 가장 좋습니다 . 대신 convert 메소드를 정의하고 변수를 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 직접 전달하십시오 . &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 은 호출이 반환 될 때까지 모든 인수가 가비지 수집에서 보존 되도록 자동으로 정렬합니다. C API가 Julia가 할당 한 메모리에 대한 참조를 저장하는 경우 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 이&lt;/a&gt; 반환 된 후 개체가 가비지 수집기에 계속 표시되는지 확인해야합니다. 이를 수행하기위한 제안 된 방법 은 C 라이브러리가 완료되었음을 알릴 때까지 이러한 값을 보유 할 &lt;code&gt;Array{Ref,1}&lt;/code&gt; 유형의 전역 변수를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a03a0776d698aabe1d1ee9b2fbaaca855d289cd3" translate="yes" xml:space="preserve">
          <source>When passing pointers to &lt;code&gt;ccall&lt;/code&gt;, the pointed-to object is implicitly used and should be preserved. (Note however that you should normally just pass &lt;code&gt;x&lt;/code&gt; directly to &lt;code&gt;ccall&lt;/code&gt; which counts as an explicit use.)</source>
          <target state="translated">포인터를 &lt;code&gt;ccall&lt;/code&gt; 에 전달할 때 , 가리키는 객체는 암시 적으로 사용되며 보존되어야합니다. (그러나 일반적으로 명시적인 사용으로 간주되는 &lt;code&gt;ccall&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; 를 직접 전달해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="4e4161f851acf4dfa4cc8665b77ecf5c1170bcb8" translate="yes" xml:space="preserve">
          <source>When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:</source>
          <target state="translated">가능하면 함수가 항상 같은 유형의 값을 반환하도록하는 데 도움이됩니다. 다음 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f980dac273e411c73db2f2997e398dee2af97484" translate="yes" xml:space="preserve">
          <source>When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the data.</source>
          <target state="translated">단일 프로세스에서 파이프 라인의 양쪽 끝을 읽고 쓸 때 커널이 모든 데이터를 버퍼링하지 않도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="432031c93a248af1a362c62ac61d4d3da70d6a24" translate="yes" xml:space="preserve">
          <source>When redefining a method or adding new methods, it is important to realize that these changes don't take effect immediately. This is key to Julia's ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead. Indeed, any new method definition won't be visible to the current runtime environment, including Tasks and Threads (and any previously defined &lt;code&gt;@generated&lt;/code&gt; functions). Let's start with an example to see what this means:</source>
          <target state="translated">분석법을 재정의하거나 새로운 분석법을 추가 할 때 이러한 변경 사항이 즉시 적용되지 않는다는 것을 인식해야합니다. 이는 일반적인 JIT 트릭과 오버 헤드없이 빠르게 실행되도록 코드를 정적으로 추론하고 컴파일하는 Julia의 핵심 기능입니다. 실제로, 새로운 메소드 정의는 작업 및 스레드 (및 이전에 정의 된 &lt;code&gt;@generated&lt;/code&gt; 함수)를 포함하여 현재 런타임 환경에 표시되지 않습니다 . 이것이 무엇을 의미하는지 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="f67015b5342fb583f71d2f0a8849f5c8f2575736" translate="yes" xml:space="preserve">
          <source>When repeatedly generating random values (with the same &lt;code&gt;rand&lt;/code&gt; parameters), it happens for some types that the result of a computation is used for each call. In this case, the computation can be decoupled from actually generating the values. This is the case for example with the default implementation for &lt;code&gt;AbstractArray&lt;/code&gt;. Assume that &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:</source>
          <target state="translated">동일한 &lt;code&gt;rand&lt;/code&gt; 매개 변수를 사용하여 임의의 값을 반복해서 생성 하는 경우 일부 호출에 대해 계산 결과가 각 호출에 사용됩니다. 이 경우 계산에서 실제로 값을 생성하지 않아도됩니다. 예를 들어 &lt;code&gt;AbstractArray&lt;/code&gt; 의 기본 구현이 여기에 해당합니다 . &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; 을 반복해서 반복해서 호출해야 한다고 가정합니다 .이 분리를 활용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5775c96a25e19b8d91a7723e7ea52f8fd816253c" translate="yes" xml:space="preserve">
          <source>When retrieving documentation for a generic function, the metadata for each method is concatenated with the &lt;code&gt;catdoc&lt;/code&gt; function, which can of course be overridden for custom types.</source>
          <target state="translated">일반 함수에 대한 문서를 검색 할 때 각 메소드의 메타 데이터는 &lt;code&gt;catdoc&lt;/code&gt; 함수 와 연결되며 이는 사용자 정의 유형에 대해 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcdae2c11195f3a2ff681be9a1639c0d95a5dceb" translate="yes" xml:space="preserve">
          <source>When searching for files, &lt;code&gt;require&lt;/code&gt; first looks for package code in the global array &lt;a href=&quot;../constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;require&lt;/code&gt; is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.</source>
          <target state="translated">파일을 검색 할 때, &lt;code&gt;require&lt;/code&gt; 글로벌 배열의 패키지 코드에 대한 최초의 외모 &lt;a href=&quot;../constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 을&lt;/a&gt; . macOS 및 Windows와 같이 대소 문자를 구분하지 않는 파일 시스템을 포함하여 모든 플랫폼에서 &lt;code&gt;require&lt;/code&gt; 는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ae50cba0ad7de510b297784111877a1b60718702" translate="yes" xml:space="preserve">
          <source>When single-threaded, code could call the internal &lt;code&gt;jl_gc_enable_finalizers&lt;/code&gt; C function to prevent finalizers from being scheduled inside a critical region. Internally, this is used inside some functions (such as our C locks) to prevent recursion when doing certain operations (incremental package loading, codegen, etc.). The combination of a lock and this flag can be used to make finalizers safe.</source>
          <target state="translated">단일 스레드 인 경우 코드는 내부 &lt;code&gt;jl_gc_enable_finalizers&lt;/code&gt; C 함수를 호출하여 종료 자가 중요한 영역 내에서 예약되는 것을 방지 할 수 있습니다. 내부적으로 이것은 특정 작업 (증분 패키지로드, 코드 생성 등)을 수행 할 때 재귀를 방지하기 위해 일부 함수 (예 : C 잠금) 내에서 사용됩니다. 잠금과이 플래그의 조합을 사용하여 종료자를 안전하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5caa784bb63149c778b19d4371f4d304c538230" translate="yes" xml:space="preserve">
          <source>When strings are created using triple-quotes (&lt;code&gt;&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt;) they have some special behavior that can be useful for creating longer blocks of text.</source>
          <target state="translated">삼중 따옴표 ( &lt;code&gt;&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt; )를 사용하여 문자열 을 만들면 더 긴 텍스트 블록을 만드는 데 유용한 특별한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9c021e0b023c23a7d814288842365e170962500" translate="yes" xml:space="preserve">
          <source>When the command is run, Julia does not capture its output unless you specifically arrange for it to. Instead, the output of the command by default goes to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; as it would using &lt;code&gt;libc&lt;/code&gt;'s &lt;code&gt;system&lt;/code&gt; call.</source>
          <target state="translated">명령이 실행될 때 Julia는 특별히 정렬하지 않는 한 출력을 캡처하지 않습니다. 대신, 기본적으로 명령 출력은 &lt;code&gt;libc&lt;/code&gt; 의 &lt;code&gt;system&lt;/code&gt; 호출을 사용하는 것처럼 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="2fa07c6647099037fc4a9f69e1680570128c974a" translate="yes" xml:space="preserve">
          <source>When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing &lt;code&gt;?&lt;/code&gt;. Julia will attempt to print help or documentation for anything entered in help mode:</source>
          <target state="translated">커서가 줄의 시작 부분에 있으면 &lt;code&gt;?&lt;/code&gt; 를 입력하여 프롬프트를 도움말 모드로 변경할 수 있습니다 . . Julia는 도움말 모드에서 입력 한 내용에 대한 도움말 또는 문서를 인쇄하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="507cfdac68541961a8caed400c02e4110284216d" translate="yes" xml:space="preserve">
          <source>When the function is called, the semicolon is optional: one can either call &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; or &lt;code&gt;plot(x, y; width=2)&lt;/code&gt;, but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.</source>
          <target state="translated">함수가 호출되면 세미콜론은 선택 사항입니다. &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; 또는 &lt;code&gt;plot(x, y; width=2)&lt;/code&gt; 를 호출 할 수 있지만 이전 스타일이 더 일반적입니다. 명시 적 세미콜론은 아래 설명 된대로 varargs 또는 계산 된 키워드를 전달할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="639ad8fb2203031e1f5890076ab452c005551734" translate="yes" xml:space="preserve">
          <source>When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can &quot;look up&quot; the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.</source>
          <target state="translated">후자가 유지되면 그러한 균질 배열을 처리하는 함수는 생산적으로 전문화 될 수 있습니다. Julia는 각 요소의 유형을 미리 알고 있습니다 (컨테이너의 모든 객체는 동일한 콘크리트 유형을 가짐) Julia는 올바른 메소드 호출을 &quot;찾을 수 있습니다&quot; 함수가 컴파일 될 때 (런타임에 검사 할 필요가 없음) 전체 목록을 처리하기위한 효율적인 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b657ed862f19af0ea0f696008e9ac44d556c4b65" translate="yes" xml:space="preserve">
          <source>When these do not hold, then it's likely that you'll get no benefit; worse, the resulting &quot;combinatorial explosion of types&quot; will be counterproductive. If &lt;code&gt;items[i+1]&lt;/code&gt; has a different type than &lt;code&gt;item[i]&lt;/code&gt;, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you're asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.</source>
          <target state="translated">이것들이 유지되지 않으면, 당신은 이익을 얻지 못할 것입니다. 더 나쁘게, 결과적인 &quot;유형의 조합 폭발&quot;은 비생산적 일 것이다. 경우 &lt;code&gt;items[i+1]&lt;/code&gt; 가 아닌 다른 유형이 &lt;code&gt;item[i]&lt;/code&gt; , 줄리아 여부를 결정, 실행시의 형태를 검색하는 방법 테이블의 적절한 방법을 검색, (형의 교차를 통해) 어느 경기를 결정해야한다 아직 JIT 컴파일되었고 (그렇지 않으면 그렇게) 호출합니다. 본질적으로 전체 유형 시스템 및 JIT 컴파일 기계에 기본적으로 사용자 고유 코드에서 switch 문 또는 사전 조회와 동일한 기능을 실행하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="daba9492446bca5f7a6499bbb7ab37d695e92939" translate="yes" xml:space="preserve">
          <source>When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because one method was defined first does not necessarily mean that it can't be modified or eliminated. As a last resort, one developer can define the &quot;band-aid&quot; method</source>
          <target state="translated">이 방법을 사용할 수 없으면 모호성을 해결하는 방법에 대해 다른 개발자와 토론을 시작하는 것이 좋습니다. 하나의 방법이 먼저 정의되었다고해서 반드시 수정하거나 제거 할 수있는 것은 아닙니다. 최후의 수단으로 한 개발자가 &quot;반창고&quot;방법을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c53522c3f28e638cb9b245fd7713a2c2d5ab598" translate="yes" xml:space="preserve">
          <source>When this function returns, the &lt;code&gt;lock&lt;/code&gt; has been released, so the caller should not attempt to &lt;code&gt;unlock&lt;/code&gt; it.</source>
          <target state="translated">이 함수가 반환이의 경우 &lt;code&gt;lock&lt;/code&gt; 해제 된, 그래서 발신자는 시도는 안 &lt;code&gt;unlock&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="afcec4d967a0515eaea7ceb3fcaeb59b279f583b" translate="yes" xml:space="preserve">
          <source>When to use T, Ptr{T} and Ref{T}</source>
          <target state="translated">T, Ptr {T} 및 Ref {T} 사용시기</target>
        </trans-unit>
        <trans-unit id="192e3e787a1f9ea7f9bd564c044daecfe8f0cc3a" translate="yes" xml:space="preserve">
          <source>When used for retrieving documentation, the &lt;code&gt;@doc&lt;/code&gt; macro (or equally, the &lt;code&gt;doc&lt;/code&gt; function) will search all &lt;code&gt;META&lt;/code&gt; dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:</source>
          <target state="translated">문서를 검색 할 때 &lt;code&gt;@doc&lt;/code&gt; 매크로 (또는 &lt;code&gt;doc&lt;/code&gt; 함수)는 주어진 객체와 관련된 메타 데이터에 대한 모든 &lt;code&gt;META&lt;/code&gt; 사전을 검색 하여 반환합니다. 반환 된 객체 (예 : 일부 Markdown 내용)는 기본적으로 지능적으로 표시됩니다. 이 디자인은 또한 문서 시스템을 프로그래밍 방식으로 쉽게 사용할 수있게합니다. 예를 들어, 여러 버전의 함수간에 문서를 재사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0da1440377ce905990ebb1084be997ed9f823f6e" translate="yes" xml:space="preserve">
          <source>When used in a top-level expression (i.e. outside any function), &lt;code&gt;return&lt;/code&gt; causes the entire current top-level expression to terminate early.</source>
          <target state="translated">최상위 식 (즉, 함수 외부)에서 사용될 경우 &lt;code&gt;return&lt;/code&gt; 은 현재 전체 최상위 식을 일찍 종료시킵니다.</target>
        </trans-unit>
        <trans-unit id="ad90f9fad3e865dcdcc8e5c6f4ed1440be5209d1" translate="yes" xml:space="preserve">
          <source>When used in multiplication, &lt;code&gt;false&lt;/code&gt; acts as a &lt;em&gt;strong zero&lt;/em&gt;:</source>
          <target state="translated">곱셈에 사용되는 경우 &lt;code&gt;false&lt;/code&gt; 는 &lt;em&gt;강력한 제로&lt;/em&gt; 역할을 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="62c2368f15add98073b370ac7b8ec7c167ef17f5" translate="yes" xml:space="preserve">
          <source>When used recursively, &lt;code&gt;isbits&lt;/code&gt; types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an &lt;code&gt;isbits&lt;/code&gt; struct type and use that instead. Unnamed structs are not possible in the translation to Julia.</source>
          <target state="translated">재귀 적으로 사용될 때, &lt;code&gt;isbits&lt;/code&gt; 타입은 인라인으로 저장됩니다. 다른 모든 유형은 데이터에 대한 포인터로 저장됩니다. C의 다른 구조체 내에서 값에 의해 사용되는 구조체를 미러링 할 때 올바른 필드 정렬이 유지되지 않으므로 필드를 수동으로 복사하지 마십시오. 대신 &lt;code&gt;isbits&lt;/code&gt; 구조체 타입을 선언하고 대신 사용하십시오. 줄리아로 번역 할 때 이름없는 구조체를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8037800c51683cda76306c47fbd67814674e8ca7" translate="yes" xml:space="preserve">
          <source>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to &lt;code&gt;y&lt;/code&gt;, then it may be rounded to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 값과 함께 사용하면 유형별로 정확한 결과를 표현할 수 없으므로 반올림 오류가 발생할 수 있습니다. 정확한 결과가 매우 가까운 경우 특히 &lt;code&gt;y&lt;/code&gt; , 그것은로 반올림 또는 올림해도 &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd8680746460f581c6030ccf8473f00fb5891fe" translate="yes" xml:space="preserve">
          <source>When used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.</source>
          <target state="translated">인수없이 사용하면 상위 범위의 모든 인수에 적용됩니다. 로컬 범위에서 이것은 포함 함수의 모든 인수를 의미합니다. 전역 (최상위) 범위에서 이는 현재 모듈에서 이후에 정의 된 모든 방법을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fc5d430efeaf46d7a9bbfb42c02ab830cb54a4e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;julia&lt;/code&gt; in high-performance computing (HPC) facilities, invoking &lt;em&gt;n&lt;/em&gt;&lt;code&gt;julia&lt;/code&gt; processes simultaneously creates at most &lt;em&gt;n&lt;/em&gt; temporary copies of precompilation cache files. If this is an issue (slow and/or small distributed file system), you may:</source>
          <target state="translated">HPC (고성능 컴퓨팅) 시설에서 &lt;code&gt;julia&lt;/code&gt; 를 사용할 때 &lt;em&gt;n &lt;/em&gt; &lt;code&gt;julia&lt;/code&gt; 프로세스를 동시에 호출 하면 최대 &lt;em&gt;n 개의&lt;/em&gt; 사전 컴파일 캐시 파일 임시 복사본이 생성됩니다 . 이것이 문제인 경우 (느리고 / 또는 작은 분산 파일 시스템) 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2497c9ba2b3daea7dfb0574cb00ff1e7a9c7db7" translate="yes" xml:space="preserve">
          <source>When using custom transports:</source>
          <target state="translated">사용자 정의 전송을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="c2b8bc3f498fe7ac6fdf02d7ec792cfe70836fab" translate="yes" xml:space="preserve">
          <source>When using multi-threading we have to be careful when using functions that are not &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure&lt;/a&gt; as we might get a wrong answer. For instance functions that have a &lt;a href=&quot;../style-guide/index#bang-convention&quot;&gt;name ending with &lt;code&gt;!&lt;/code&gt;&lt;/a&gt; by convention modify their arguments and thus are not pure.</source>
          <target state="translated">멀티 스레딩을 사용할 때 우리는 잘못된 답을 얻을 수 있으므로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;순수&lt;/a&gt; 하지 않은 함수를 사용할 때주의해야합니다 . 예를 들어 &lt;a href=&quot;../style-guide/index#bang-convention&quot;&gt;이름이 &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;관례 적으로 그들의 주장을 수정하므로 순수하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c37c0d6d64c53d6358f8588b527452529dd78e26" translate="yes" xml:space="preserve">
          <source>When using multi-threading we have to be careful when using functions that are not &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure&lt;/a&gt; as we might get a wrong answer. For instance functions that have their &lt;a href=&quot;https://docs.julialang.org/en/latest/manual/style-guide/#Append-!-to-names-of-functions-that-modify-their-arguments-1&quot;&gt;name ending with &lt;code&gt;!&lt;/code&gt;&lt;/a&gt; by convention modify their arguments and thus are not pure. However, there are functions that have side effects and their name does not end with &lt;code&gt;!&lt;/code&gt;. For instance &lt;code&gt;findfirst(regex, str)&lt;/code&gt; mutates its &lt;code&gt;regex&lt;/code&gt; argument or &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt; changes &lt;code&gt;Base.GLOBAL_RNG&lt;/code&gt; :</source>
          <target state="translated">멀티 스레딩을 사용할 때 우리는 틀린 답을 얻을 수 있으므로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;순수&lt;/a&gt; 하지 않은 함수를 사용할 때주의해야합니다 . 예를 들어 &lt;a href=&quot;https://docs.julialang.org/en/latest/manual/style-guide/#Append-!-to-names-of-functions-that-modify-their-arguments-1&quot;&gt;이름이 &lt;code&gt;!&lt;/code&gt; 로&lt;/a&gt; 끝나는 함수 관례 적으로 그들의 주장을 수정하여 순수하지는 않다. 그러나 부작용이있는 기능이 있으며 그 이름은 &lt;code&gt;!&lt;/code&gt; 로 끝나지 않습니다 . . 예를 들어 &lt;code&gt;findfirst(regex, str)&lt;/code&gt; 은 &lt;code&gt;regex&lt;/code&gt; 인수를 변경 하거나 &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; 변경 &lt;code&gt;Base.GLOBAL_RNG&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b447ea6c22b7217cd1a32ca44046e314803b64e" translate="yes" xml:space="preserve">
          <source>When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.</source>
          <target state="translated">사전 컴파일을 사용하는 경우 컴파일 단계와 실행 단계의 차이점을 명확하게 이해하는 것이 중요합니다. 이 모드에서 Julia는 컴파일 된 코드를 생성하는 독립형 인터프리터가 아닌 임의의 Julia 코드를 실행할 수있는 컴파일러라는 것이 훨씬 더 분명합니다.</target>
        </trans-unit>
        <trans-unit id="0e5558e1451a680e9ddfe72dac1bc38bd5461d8f" translate="yes" xml:space="preserve">
          <source>When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.</source>
          <target state="translated">배열을 포함하여 매개 변수화 된 유형으로 작업 할 때는 가능한 경우 추상 유형으로 매개 변수화를 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="abf66d0515d50ea07459b30e9a61d6da0706813b" translate="yes" xml:space="preserve">
          <source>When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:</source>
          <target state="translated">Julia 호출 가능 함수를 작성할 때 인수를 유효성 검증하고 오류를 표시하기 위해 예외를 발생시켜야합니다. 일반적인 유형 검사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ad650f8bc2dfe7cd7aa17fa3b6b4fd4a9838167" translate="yes" xml:space="preserve">
          <source>When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:</source>
          <target state="translated">인수 목록 내에 여러 차원을 가진 생성기 표현식을 작성할 때 생성기를 후속 인수와 구분하려면 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a210e70d4d8e363a13a615aeef1246bcb22c3b70" translate="yes" xml:space="preserve">
          <source>When writing an error message, it is preferred to make the first word lowercase. For example,</source>
          <target state="translated">오류 메시지를 작성할 때 첫 번째 단어를 소문자로 만드는 것이 좋습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="3b9df752ca25cefae3e41acb8144a7fbee28150d" translate="yes" xml:space="preserve">
          <source>When writing an error message, it is preferred to make the first word lowercase. For example, &lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;size of A not equal to size of B&quot;))&lt;/code&gt;</source>
          <target state="translated">오류 메시지를 작성할 때 첫 단어를 소문자로 만드는 것이 좋습니다. 예를 들어, &lt;code&gt;size(A) == size(B) || throw(DimensionMismatch(&quot;size of A not equal to size of B&quot;))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="746943943c8bd0cb8ffebcb9533c46af3e156c32" translate="yes" xml:space="preserve">
          <source>When writing cross-platform applications or libraries, it is often necessary to allow for differences between operating systems. The variable &lt;code&gt;Sys.KERNEL&lt;/code&gt; can be used to handle such cases. There are several functions in the &lt;code&gt;Sys&lt;/code&gt; module intended to make this easier, such as &lt;code&gt;isunix&lt;/code&gt;, &lt;code&gt;islinux&lt;/code&gt;, &lt;code&gt;isapple&lt;/code&gt;, &lt;code&gt;isbsd&lt;/code&gt;, &lt;code&gt;isfreebsd&lt;/code&gt;, and &lt;code&gt;iswindows&lt;/code&gt;. These may be used as follows:</source>
          <target state="translated">크로스 플랫폼 애플리케이션 또는 라이브러리를 작성할 때 종종 운영 체제 간의 차이를 허용해야합니다. 이러한 경우를 처리하기 위해 변수 &lt;code&gt;Sys.KERNEL&lt;/code&gt; 을 사용할 수 있습니다. &lt;code&gt;Sys&lt;/code&gt; 모듈에는 &lt;code&gt;isunix&lt;/code&gt; , &lt;code&gt;islinux&lt;/code&gt; , &lt;code&gt;isapple&lt;/code&gt; , &lt;code&gt;isbsd&lt;/code&gt; , &lt;code&gt;isfreebsd&lt;/code&gt; 및 &lt;code&gt;iswindows&lt;/code&gt; 와 같은 여러 기능 이 있습니다. 이들은 다음과 같이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="140bfa28c1af35b51bf1fbbfbb494996a50b8788" translate="yes" xml:space="preserve">
          <source>When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:</source>
          <target state="translated">파일 (또는 다른 I / O 장치)에 데이터를 쓸 때 여분의 중간 문자열을 형성하는 것이 오버 헤드의 원인입니다. 대신에:</target>
        </trans-unit>
        <trans-unit id="ea56a87bb36feaf518131b01ee237cf7ed3e22b2" translate="yes" xml:space="preserve">
          <source>When you are done experimenting with &lt;code&gt;tutorial&lt;/code&gt;, you can return to the &lt;strong&gt;default environment&lt;/strong&gt; by running &lt;code&gt;activate&lt;/code&gt; with no arguments:</source>
          <target state="translated">&lt;code&gt;tutorial&lt;/code&gt; 으로 실험을 마치면 , 인수없이 &lt;code&gt;activate&lt;/code&gt; 를 실행 하여 &lt;strong&gt;기본 환경&lt;/strong&gt; 으로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af850b03f79f23506bb562acc1e616e437cdd077" translate="yes" xml:space="preserve">
          <source>When you might be tempted to dispatch on two or more arguments, consider whether a &quot;wrapper&quot; function might make for a simpler design. For example, instead of writing multiple variants:</source>
          <target state="translated">둘 이상의 인수를 디스패치하려고 할 때 &quot;래퍼&quot;함수가 더 단순한 디자인을 만들 수 있는지 고려하십시오. 예를 들어 여러 변형을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="3e23df6a20bd627b8c4a3ef7db880ac462400664" translate="yes" xml:space="preserve">
          <source>When your broadcast operation involves several arguments, individual argument styles get combined to determine a single &lt;code&gt;DestStyle&lt;/code&gt; that controls the type of the output container. For more details, see &lt;a href=&quot;#writing-binary-broadcasting-rules&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스트 작업에 여러 인수가 포함되는 경우 개별 인수 스타일이 결합되어 출력 컨테이너의 유형을 제어 하는 단일 &lt;code&gt;DestStyle&lt;/code&gt; 을 결정합니다 . 자세한 내용은 &lt;a href=&quot;#writing-binary-broadcasting-rules&quot;&gt;아래를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="048e5475f471182cd2ededcf0684d7e52f236fb2" translate="yes" xml:space="preserve">
          <source>When your broadcast operation involves several arguments, individual argument styles get combined to determine a single &lt;code&gt;DestStyle&lt;/code&gt; that controls the type of the output container. For more details, see &lt;a href=&quot;#writing-binary-broadcasting-rules-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스트 작업에 여러 인수가 포함 된 경우 개별 인수 스타일이 결합되어 출력 컨테이너의 유형을 제어 하는 단일 &lt;code&gt;DestStyle&lt;/code&gt; 을 결정합니다 . 자세한 내용은 &lt;a href=&quot;#writing-binary-broadcasting-rules-1&quot;&gt;아래를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d4fb3c9ea296d79d861a0f19e5fe00c5f37399d" translate="yes" xml:space="preserve">
          <source>Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;String&lt;/code&gt; make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is &lt;code&gt;unsafe_wrap&lt;/code&gt; which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</source>
          <target state="translated">Julia 데이터에 대한 포인터를 만들 때마다 포인터 사용이 끝날 때까지 원본 데이터가 존재하는지 확인해야합니다. &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;String&lt;/code&gt; 과 같은 Julia의 많은 메소드 는 버퍼의 소유권을 가져 오는 대신 데이터 사본을 작성하므로 Julia에 영향을주지 않고 원래 데이터를 해제 (또는 변경)하는 것이 안전합니다. 주목할만한 예외는 &lt;code&gt;unsafe_wrap&lt;/code&gt; 이며, 성능상의 이유로 기본 버퍼를 공유하거나 소유권을 갖도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f63c3900c5fc22683d6c7eea47a444379dfc1a7" translate="yes" xml:space="preserve">
          <source>Whenever you have created a pointer to Julia data, you must ensure the original data exists until you have finished using the pointer. Many methods in Julia such as &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;String&lt;/code&gt; make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is &lt;code&gt;unsafe_wrap&lt;/code&gt; which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</source>
          <target state="translated">Julia 데이터에 대한 포인터를 만들 때마다 포인터 사용을 마칠 때까지 원본 데이터가 존재하는지 확인해야합니다. &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;String&lt;/code&gt; 과 같은 Julia의 많은 메서드 는 버퍼의 소유권을 가져 오는 대신 데이터를 복사하므로 Julia에 영향을주지 않고 원본 데이터를 해제 (또는 변경)하는 것이 안전합니다. 주목할만한 예외는 성능상의 이유로 기본 버퍼를 공유 (또는 소유권을 &lt;code&gt;unsafe_wrap&lt;/code&gt; 지시 할 수 있음)하는 unsafe_wrap 입니다.</target>
        </trans-unit>
        <trans-unit id="8cc3e56583b16a50bfba8e692c6fe776fd1cb4f1" translate="yes" xml:space="preserve">
          <source>Whenever you subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;, you also need to define rules for combining dimensionalities, by creating a constructor for your style that takes a &lt;code&gt;Val(N)&lt;/code&gt; argument. For example:</source>
          <target state="translated">&lt;code&gt;AbstractArrayStyle&lt;/code&gt; 의 하위 유형을 지정할 때마다 &lt;code&gt;Val(N)&lt;/code&gt; 인수를 사용 하는 스타일의 생성자를 작성하여 차원 결합 규칙을 정의해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3066b7d4e247d114bdc0ef476727d2a6ba818e4d" translate="yes" xml:space="preserve">
          <source>Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,</source>
          <target state="translated">가능하면 특정 요소 유형의 추상 컨테이너에 디스패치하는 메소드를 정의하지 마십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e4b922c6b5958e9ab31dff7d65b2a0ee19971cda" translate="yes" xml:space="preserve">
          <source>Where required, mutable composite objects can be declared with the keyword &lt;a href=&quot;../../base/base/index#mutable%20struct&quot;&gt;&lt;code&gt;mutable struct&lt;/code&gt;&lt;/a&gt;, to be discussed in the next section.</source>
          <target state="translated">필요한 경우 다음 섹션에서 논의 할 mutable 복합 객체를 키워드 &lt;a href=&quot;../../base/base/index#mutable%20struct&quot;&gt; &lt;code&gt;mutable struct&lt;/code&gt; &lt;/a&gt; 로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c9c509d6368e040525363a2e496308085482cd" translate="yes" xml:space="preserve">
          <source>Wherever possible examples should be &lt;strong&gt;self-contained&lt;/strong&gt; and &lt;strong&gt;runnable&lt;/strong&gt; so that readers are able to try them out without having to include any dependencies.</source>
          <target state="translated">가능한 모든 예제는 &lt;strong&gt;독립&lt;/strong&gt; 적이고 &lt;strong&gt;실행&lt;/strong&gt; 가능해야 독자가 종속성을 포함하지 않고도 예제 를 시험해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef567ac5cd5d2b217cb8d699a0ed8bd87ebc66fa" translate="yes" xml:space="preserve">
          <source>Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal's locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes (&quot;code units&quot;). In UTF-8, ASCII characters &amp;mdash; i.e. those with code points less than 0x80 (128) &amp;ndash; are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes &amp;mdash; up to four per character.</source>
          <target state="translated">이러한 유니 코드 문자가 이스케이프로 표시되는지 또는 특수 문자로 표시되는지는 터미널의 로캘 설정 및 유니 코드 지원에 따라 다릅니다. 문자열 리터럴은 UTF-8 인코딩을 사용하여 인코딩됩니다. UTF-8은 가변 폭 인코딩으로, 모든 문자가 동일한 바이트 수 ( &quot;코드 단위&quot;)로 인코딩되는 것은 아닙니다. UTF-8에서 ASCII 문자 (즉, 코드 포인트가 0x80 (128) 미만인 문자)는 단일 바이트를 사용하여 ASCII 문자 그대로 ASCII 코드로 인코딩되며 0x80 이상 코드 포인트는 문자 당 최대 4 바이트까지 다중 바이트를 사용하여 인코딩됩니다. .</target>
        </trans-unit>
        <trans-unit id="f7fc267bb32bef8de2de3ffe243f0a016d661b84" translate="yes" xml:space="preserve">
          <source>Whether you're at the REPL or in IJulia, you can typically improve your development experience with &lt;a href=&quot;https://github.com/timholy/Revise.jl&quot;&gt;Revise&lt;/a&gt;. It is common to configure Revise to start whenever julia is started, as per the instructions in the &lt;a href=&quot;https://timholy.github.io/Revise.jl/stable/&quot;&gt;Revise documentation&lt;/a&gt;. Once configured, Revise will track changes to files in any loaded modules, and to any files loaded in to the REPL with &lt;code&gt;includet&lt;/code&gt; (but not with plain &lt;code&gt;include&lt;/code&gt;); you can then edit the files and the changes take effect without restarting your julia session. A standard workflow is similar to the REPL-based workflow above, with the following modifications:</source>
          <target state="translated">REPL이든 IJulia이든 &lt;a href=&quot;https://github.com/timholy/Revise.jl&quot;&gt;Revise를&lt;/a&gt; 통해 개발 경험을 향상시킬 수 있습니다 . &lt;a href=&quot;https://timholy.github.io/Revise.jl/stable/&quot;&gt;Revise documentation&lt;/a&gt; 의 지침에 따라 julia가 시작될 때마다 Revise가 시작되도록 구성하는 것이 일반적 입니다. 일단 구성되면 Revise는로드 된 모듈의 파일 및 &lt;code&gt;includet&lt;/code&gt; 를 사용하여 REPL에로드 된 파일의 변경 사항을 추적합니다 (단, 일반 &lt;code&gt;include&lt;/code&gt; 는 아님). 그런 다음 파일을 편집 할 수 있으며 julia 세션을 다시 시작하지 않고도 변경 사항이 적용됩니다. 표준 워크 플로우는 위의 REPL 기반 워크 플로우와 유사하며 다음과 같이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a4dc663436f3244e6df7b1b5d61395f232fa789" translate="yes" xml:space="preserve">
          <source>Which dependencies a package in a package directory can import depends on whether the package contains a project file:</source>
          <target state="translated">패키지 디렉토리의 패키지가 가져올 수있는 종속성은 패키지에 프로젝트 파일이 포함되어 있는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="756eba64f92afee04dba30cffc4bf61294ef8525" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; has an explicit &lt;code&gt;module&lt;/code&gt; argument, &lt;code&gt;@macroexpand&lt;/code&gt; always</source>
          <target state="translated">하지만 &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; 가&lt;/a&gt; 명시 적으로이 &lt;code&gt;module&lt;/code&gt; 인수를 &lt;code&gt;@macroexpand&lt;/code&gt; 항상</target>
        </trans-unit>
        <trans-unit id="184a46eafa36dca281973d7f2d6b87f46821a4c2" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; has an explicit &lt;code&gt;module&lt;/code&gt; argument, &lt;code&gt;@macroexpand&lt;/code&gt; always expands with respect to the module in which it is called.</source>
          <target state="translated">하지만 &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; 가&lt;/a&gt; 명시 적으로이 &lt;code&gt;module&lt;/code&gt; 인수를 &lt;code&gt;@macroexpand&lt;/code&gt; 항상 호출되는 모듈에 대한 확장합니다.</target>
        </trans-unit>
        <trans-unit id="1cc49efbeeb77badc02c9b1bad7194e67a387a92" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; takes a keyword argument &lt;code&gt;recursive&lt;/code&gt;, &lt;code&gt;@macroexpand&lt;/code&gt;</source>
          <target state="translated">하지만 &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; 이&lt;/a&gt; 키워드 인수 소요 &lt;code&gt;recursive&lt;/code&gt; , &lt;code&gt;@macroexpand&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9228b710aa24ac839d6bc3a76205d3aff72284d" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; takes a keyword argument &lt;code&gt;recursive&lt;/code&gt;, &lt;code&gt;@macroexpand&lt;/code&gt; is always recursive. For a non recursive macro version, see &lt;a href=&quot;#Base.@macroexpand1&quot;&gt;&lt;code&gt;@macroexpand1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; 는&lt;/a&gt; 키워드 인수 소요 &lt;code&gt;recursive&lt;/code&gt; , &lt;code&gt;@macroexpand&lt;/code&gt; 항상 재귀입니다. 비 재귀 매크로 버전의 경우 &lt;a href=&quot;#Base.@macroexpand1&quot;&gt; &lt;code&gt;@macroexpand1&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2c2f9203af0f3ce23ef8c2d94a94796ece99629" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;*&lt;/code&gt; may seem like a surprising choice to users of languages that provide &lt;code&gt;+&lt;/code&gt; for string concatenation, this use of &lt;code&gt;*&lt;/code&gt; has precedent in mathematics, particularly in abstract algebra.</source>
          <target state="translated">하지만 &lt;code&gt;*&lt;/code&gt; 가 제공하는 언어의 사용자들에게 놀라운 선택처럼 보일 수 &lt;code&gt;+&lt;/code&gt; 문자열 연결을 위해,이 사용 &lt;code&gt;*&lt;/code&gt; 는 특히 추상 대수학에서, 수학에서 전례가있다.</target>
        </trans-unit>
        <trans-unit id="bbcff3d6feff5ad14e53fb09db15ddf33d0354ee" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;@simd&lt;/code&gt; needs to be placed directly in front of an innermost &lt;code&gt;for&lt;/code&gt; loop, both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@fastmath&lt;/code&gt; can be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g., using &lt;code&gt;@inbounds begin&lt;/code&gt; or &lt;code&gt;@inbounds for ...&lt;/code&gt;.</source>
          <target state="translated">하지만 &lt;code&gt;@simd&lt;/code&gt; 필요가 안쪽의 바로 앞에 배치 할 &lt;code&gt;for&lt;/code&gt; 루프, 모두 &lt;code&gt;@inbounds&lt;/code&gt; 및 &lt;code&gt;@fastmath&lt;/code&gt; 을 사용하여, 예를 들어 하나 하나의 표현 또는 코드의 중첩 된 블록 내에 표시되는 모든 표현에 적용 할 수 &lt;code&gt;@inbounds begin&lt;/code&gt; 또는 &lt;code&gt;@inbounds for ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b0fd7a7891ebce6279ddd6c714b5386fc801ad6" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;jl_eval_string&lt;/code&gt; allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;jl_eval_string&lt;/code&gt; 을 사용하면 C가 Julia 표현식의 결과를 얻을 수 있지만 C로 계산 된 인수를 Julia에 전달할 수는 없습니다. 이를 위해 &lt;code&gt;jl_call&lt;/code&gt; 을 사용하여 Julia 함수를 직접 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f07b0b9c023a9dca4df041f23eee5d568f348dc9" translate="yes" xml:space="preserve">
          <source>While Julia imposes few restrictions on valid names, it has become useful to adopt the following conventions:</source>
          <target state="translated">Julia는 유효한 이름에 대해 거의 제한을 두지 않지만 다음 규칙을 채택하는 것이 유용 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="9611531e19b0b6f41cb83ee6678a76716493dd1f" translate="yes" xml:space="preserve">
          <source>While complex dispatch logic is not required for performance or usability, sometimes it can be the best way to express some algorithm. Here are a few common design patterns that come up sometimes when using dispatch in this way.</source>
          <target state="translated">복잡한 디스패치 로직은 성능이나 유용성에 필요하지 않지만 때로는 일부 알고리즘을 표현하는 가장 좋은 방법 일 수 있습니다. 다음과 같이 디스패치를 ​​사용할 때 가끔 나타나는 몇 가지 일반적인 디자인 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a613d3a63e35707ed9f74c525fa3af91032ab48" translate="yes" xml:space="preserve">
          <source>While consecutive &lt;code&gt;remotecall&lt;/code&gt;s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, &lt;code&gt;remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2)&lt;/code&gt; will serialize the call to &lt;code&gt;f1&lt;/code&gt;, followed by &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;f3&lt;/code&gt; in that order. However, it is not guaranteed that &lt;code&gt;f1&lt;/code&gt; is executed before &lt;code&gt;f3&lt;/code&gt; on worker 2.</source>
          <target state="translated">연속 동안 &lt;code&gt;remotecall&lt;/code&gt; 같은 작업자의가 자신을 호출 한 순서대로 직렬화, 원격 작업자 실행의 순서는 부정이됩니다. 예를 들어, &lt;code&gt;remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2)&lt;/code&gt; 는 &lt;code&gt;f1&lt;/code&gt; 에 대한 호출을 직렬화 한 다음 순서대로 &lt;code&gt;f2&lt;/code&gt; 및 &lt;code&gt;f3&lt;/code&gt; 을 직렬화합니다 . 그러나 작업자 2의 &lt;code&gt;f3&lt;/code&gt; 보다 먼저 &lt;code&gt;f1&lt;/code&gt; 이 실행되는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="51e62aaaf2b53ae1f62514f54b2a553fcf0cfeab" translate="yes" xml:space="preserve">
          <source>While handling an exception further exceptions may be thrown. It can be useful to inspect all these exceptions to identify the root cause of a problem. The julia runtime supports this by pushing each exception onto an internal &lt;em&gt;exception stack&lt;/em&gt; as it occurs. When the code exits a &lt;code&gt;catch&lt;/code&gt; normally, any exceptions which were pushed onto the stack in the associated &lt;code&gt;try&lt;/code&gt; are considered to be successfully handled and are removed from the stack.</source>
          <target state="translated">예외를 처리하는 동안 추가 예외가 발생할 수 있습니다. 문제의 근본 원인을 식별하기 위해 이러한 모든 예외를 검사하는 것이 유용 할 수 있습니다. julia 런타임은 각 예외 가 발생할 때 내부 &lt;em&gt;예외 스택&lt;/em&gt; 으로 &lt;em&gt;푸시&lt;/em&gt; 하여이를 지원합니다. 코드가 &lt;code&gt;catch&lt;/code&gt; 정상적으로 종료 하면 관련 &lt;code&gt;try&lt;/code&gt; 에서 스택으로 푸시 된 예외 가 성공적으로 처리 된 것으로 간주되어 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ca37d3403041f9ab3487c0564b96870987e2b6c" translate="yes" xml:space="preserve">
          <source>While having easy access to information about the current state of the callstack can be helpful in many places, the most obvious application is in error handling and debugging.</source>
          <target state="translated">콜 스택의 현재 상태에 대한 정보에 쉽게 액세스 할 수 있지만 여러 곳에서 도움이 될 수 있지만 가장 분명한 응용 프로그램은 오류 처리 및 디버깅입니다.</target>
        </trans-unit>
        <trans-unit id="df4de512495b592481ddaae589dfa8a7c51cf0bd" translate="yes" xml:space="preserve">
          <source>While it isn't normally necessary, user-defined types can override the default &lt;code&gt;deepcopy&lt;/code&gt; behavior by defining a specialized version of the function &lt;code&gt;deepcopy_internal(x::T, dict::IdDict)&lt;/code&gt; (which shouldn't otherwise be used), where &lt;code&gt;T&lt;/code&gt; is the type to be specialized for, and &lt;code&gt;dict&lt;/code&gt; keeps track of objects copied so far within the recursion. Within the definition, &lt;code&gt;deepcopy_internal&lt;/code&gt; should be used in place of &lt;code&gt;deepcopy&lt;/code&gt;, and the &lt;code&gt;dict&lt;/code&gt; variable should be updated as appropriate before returning.</source>
          <target state="translated">정상적으로 필요는 없지만, 사용자 정의 형식이 기본 대체 할 수 있습니다 &lt;code&gt;deepcopy&lt;/code&gt; 기능의 전문 버전을 정의하여 동작을 &lt;code&gt;deepcopy_internal(x::T, dict::IdDict)&lt;/code&gt; 여기서, (그렇지 않으면 사용할 수 없습니다) &lt;code&gt;T&lt;/code&gt; 를 특수화 할 유형이며 &lt;code&gt;dict&lt;/code&gt; 는 재귀 내에서 지금까지 복사 된 객체를 추적합니다. 정의 내에서 &lt;code&gt;deepcopy_internal&lt;/code&gt; 는 대신에 사용되어야한다 &lt;code&gt;deepcopy&lt;/code&gt; 및 &lt;code&gt;dict&lt;/code&gt; 변수는 반환하기 전에 적절하게 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f3d13eb12580ee4231b089eaa3cb6f0dbbb0c0a" translate="yes" xml:space="preserve">
          <source>While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs &lt;em&gt;inner&lt;/em&gt; constructor methods. An inner constructor method is like an outer constructor method, except for two differences:</source>
          <target state="translated">외부 생성자 메서드는 객체 생성을위한 추가 편리한 방법을 제공하는 문제를 해결하는 데 성공하지만이 장의 소개에서 언급 한 다른 두 가지 사용 사례 인 불변량 적용 및 자기 참조 객체 생성 허용에 대해서는 설명하지 않습니다. 이러한 문제를 해결하려면 &lt;em&gt;내부&lt;/em&gt; 생성자 메서드가 필요 합니다. 내부 생성자 메서드는 두 가지 차이점을 제외하고 외부 생성자 메서드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc7d60dfb2e235e3358134a6468c679f21f0ad14" translate="yes" xml:space="preserve">
          <source>While propercase return the same value in the corresponding &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">적절한 경우 해당 &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 유형 에서 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="342603ec72e053e98ba85ef7e5ec03e87ad74dcc" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; constructor expects a 0-argument function, the &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; method that creates a task-bound channel expects a function that accepts a single argument of type &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0 or 1 argument &lt;a href=&quot;../functions/index#man-anonymous-functions&quot;&gt;anonymous function&lt;/a&gt;.</source>
          <target state="translated">그동안 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 생성자는 0 인수 기능의 기대 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 작업 바인딩 채널을 생성 형의 인수를 허용하는 기능을 기대 방법 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; . 일반적인 패턴은 생산자를 매개 변수화하는 것입니다.이 경우 부분 함수 응용 프로그램이 0 또는 1 인수 &lt;a href=&quot;../functions/index#man-anonymous-functions&quot;&gt;익명 함수&lt;/a&gt; 를 생성해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="0103ec498dfe3018e856d3ce11ad20db1b0525e9" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; constructor expects a 0-argument function, the &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; method which creates a channel bound task expects a function that accepts a single argument of type &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0 or 1 argument &lt;a href=&quot;../functions/index#man-anonymous-functions-1&quot;&gt;anonymous function&lt;/a&gt;.</source>
          <target state="translated">그동안 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 생성자는 0 인수 기능의 기대 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 작업 바운드 채널을 생성 형의 인수를 허용하는 기능을 기대 방법 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; . 공통 패턴은 생산자를 매개 변수화하는 것이며,이 경우 0 또는 1 개의 인수 &lt;a href=&quot;../functions/index#man-anonymous-functions-1&quot;&gt;익명 함수&lt;/a&gt; 를 작성하려면 부분 함수 애플리케이션이 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="218a44d9559edb27cfb4f29479eb4a5c8c1ee312" translate="yes" xml:space="preserve">
          <source>While the casual programmer need not explicitly use types or multiple dispatch, they are the core unifying features of Julia: functions are defined on different combinations of argument types, and applied by dispatching to the most specific matching definition. This model is a good fit for mathematical programming, where it is unnatural for the first argument to &quot;own&quot; an operation as in traditional object-oriented dispatch. Operators are just functions with special notation &amp;ndash; to extend addition to new user-defined data types, you define new methods for the &lt;code&gt;+&lt;/code&gt; function. Existing code then seamlessly applies to the new data types.</source>
          <target state="translated">일반 프로그래머는 명시 적으로 형식이나 다중 디스패치를 ​​사용할 필요는 없지만 Julia의 핵심 통합 기능입니다. 함수는 다양한 인수 유형 조합에 정의되고 가장 구체적인 일치하는 정의로 디스패치하여 적용됩니다. 이 모델은 수학적 프로그래밍에 적합하며, 기존의 객체 지향 디스패치에서와 같이 첫 번째 인수가 연산을 &quot;소유&quot;하는 것은 부자연 스럽습니다. 연산자는 특별한 표기법을 가진 함수일뿐입니다. 새로운 사용자 정의 데이터 형식에 추가 할 수 있도록 &lt;code&gt;+&lt;/code&gt; 함수에 대한 새로운 방법을 정의 합니다. 기존 코드는 새로운 데이터 유형에 완벽하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb2d55855117a6a29dcfe66a2d059180dbf3aa5" translate="yes" xml:space="preserve">
          <source>While the compiler can now do its job perfectly well, there are cases where &lt;em&gt;you&lt;/em&gt; might wish that your code could do different things depending on the &lt;em&gt;element type&lt;/em&gt; of &lt;code&gt;a&lt;/code&gt;. Usually the best way to achieve this is to wrap your specific operation (here, &lt;code&gt;foo&lt;/code&gt;) in a separate function:</source>
          <target state="translated">컴파일러는 이제 완벽하게 그 일을 할 수 있지만, 경우가 있습니다 &lt;em&gt;당신은&lt;/em&gt; 당신의 코드에 따라 다른 것을 할 수 있다고 할 수있는 &lt;em&gt;요소 유형&lt;/em&gt; 의 &lt;code&gt;a&lt;/code&gt; 는 . 일반적으로 이것을 달성하는 가장 좋은 방법은 특정 작업 (여기서는 &lt;code&gt;foo&lt;/code&gt; )을 별도의 함수 로 래핑하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a623753d4cea0b9be23eebbdfff0f9b8d6e62a17" translate="yes" xml:space="preserve">
          <source>While the default transport layer uses plain &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt;, it is possible for a Julia cluster to provide its own transport.</source>
          <target state="translated">기본 전송 계층은 일반 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; 을&lt;/a&gt; 사용하지만 Julia 클러스터는 자체 전송을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30845fa92bdd35d537ad635b6b31f53d4bb049ee" translate="yes" xml:space="preserve">
          <source>While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.</source>
          <target state="translated">스트리밍 I / O API는 동기식이지만 기본 구현은 완전히 비동기식입니다.</target>
        </trans-unit>
        <trans-unit id="5e5cf9df078dc718967f536a7ab7760f447547c9" translate="yes" xml:space="preserve">
          <source>While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created. Indeed, a number is an immutable object; the statements &lt;code&gt;x = 5; x += 1&lt;/code&gt; do not modify the meaning of &lt;code&gt;5&lt;/code&gt;, they modify the value bound to &lt;code&gt;x&lt;/code&gt;. For an immutable, the only way to change the value is to reassign it.</source>
          <target state="translated">이 동작은 일부를 놀라게 할 수 있지만, 선택은 의도적입니다. 주된 이유는 Julia 내에 불변의 객체가 존재하기 때문에 생성 된 값을 변경할 수 없습니다. 실제로, 숫자는 불변 개체입니다. 진술 &lt;code&gt;x = 5; x += 1&lt;/code&gt; 은 &lt;code&gt;5&lt;/code&gt; 의 의미를 수정하지 않고 &lt;code&gt;x&lt;/code&gt; 에 바인딩 된 값을 수정합니다 . 불변의 경우 값을 변경하는 유일한 방법은 값을 다시 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a96e95242dd16f7c7d2c64c54621f6378735368c" translate="yes" xml:space="preserve">
          <source>While this can be inconvenient when you are developing new code, there's an excellent workaround. Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants. You can't import the type names into &lt;code&gt;Main&lt;/code&gt; and then expect to be able to redefine them there, but you can use the module name to resolve the scope. In other words, while developing you might use a workflow something like this:</source>
          <target state="translated">새 코드를 개발할 때는 불편할 수 있지만 훌륭한 해결 방법이 있습니다. 모듈은 모듈을 재정 의하여 교체 할 수 있으므로 모듈에 새 코드를 모두 넣으면 유형과 상수를 재정의 할 수 있습니다. 유형 이름을 &lt;code&gt;Main&lt;/code&gt; 으로 가져올 수 없으며 거기서 재정의 할 수있을 것으로 예상되지만 모듈 이름을 사용하여 범위를 해결할 수 있습니다. 즉, 개발하는 동안 다음과 같은 워크 플로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c0c3d9948638672054e0c07121ec58601d9fa6" translate="yes" xml:space="preserve">
          <source>While this is starting to support more of the &lt;a href=&quot;../arrays/index#man-array-indexing&quot;&gt;indexing operations supported by some of the builtin types&lt;/a&gt;, there's still quite a number of behaviors missing. This &lt;code&gt;Squares&lt;/code&gt; sequence is starting to look more and more like a vector as we've added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 &lt;a href=&quot;../arrays/index#man-array-indexing&quot;&gt;일부 내장 유형&lt;/a&gt; 에서 지원 하는 인덱싱 작업을 더 많이 지원하기 시작했지만 여전히 많은 동작이 누락되었습니다. 이 &lt;code&gt;Squares&lt;/code&gt; 시퀀스는 우리가 행동을 추가함에 따라 점점 더 벡터처럼 보이기 시작했습니다. 이러한 모든 동작을 직접 정의하는 대신에 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 의 하위 유형으로 공식적으로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="649d185e29a40990efde41ef5a4ec1d691dac077" translate="yes" xml:space="preserve">
          <source>While this is starting to support more of the &lt;a href=&quot;../arrays/index#man-array-indexing-1&quot;&gt;indexing operations supported by some of the builtin types&lt;/a&gt;, there's still quite a number of behaviors missing. This &lt;code&gt;Squares&lt;/code&gt; sequence is starting to look more and more like a vector as we've added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 &lt;a href=&quot;../arrays/index#man-array-indexing-1&quot;&gt;일부 내장 유형&lt;/a&gt; 에서 지원하는 더 많은 인덱싱 작업 을 지원하기 시작했지만 여전히 많은 동작이 누락되었습니다. 이 &lt;code&gt;Squares&lt;/code&gt; 시퀀스는 동작을 추가함에 따라 점점 더 벡터처럼 보이기 시작합니다. 이러한 모든 동작을 직접 정의하는 대신 공식적으로 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 의 하위 유형으로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="425afa4408859b9cd15376be9e2c708f0297351c" translate="yes" xml:space="preserve">
          <source>While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there's a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:</source>
          <target state="translated">일반적인 구현에 의존 할 수 있지만 더 간단한 알고리즘이있는 특정 방법을 확장 할 수도 있습니다. 예를 들어, 제곱의 합을 계산하는 수식이 있으므로 일반적인 반복 버전을보다 우수한 솔루션으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e85aee206728001710e24ad54c1cc3e292a7042b" translate="yes" xml:space="preserve">
          <source>While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:</source>
          <target state="translated">초기화되지 않은 필드로 객체를 만들 수는 있지만 초기화되지 않은 참조에 대한 액세스는 즉각적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="cf81a2eac5fd3376ed443fa4628dd130f7562794" translate="yes" xml:space="preserve">
          <source>White Bullet</source>
          <target state="translated">하얀 총알</target>
        </trans-unit>
        <trans-unit id="e494bf31f9dcb1983954232ccfd79f61ec932828" translate="yes" xml:space="preserve">
          <source>White Circle</source>
          <target state="translated">화이트 서클</target>
        </trans-unit>
        <trans-unit id="a7bc8512f73b7bb391a5c2ccf19c842fbda78279" translate="yes" xml:space="preserve">
          <source>White Circle With Dot Right</source>
          <target state="translated">오른쪽 점이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="5b837af6377ef96cf6a166b867c0c8c92c78103a" translate="yes" xml:space="preserve">
          <source>White Circle With Lower Left Quadrant</source>
          <target state="translated">왼쪽 아래 사분면이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="7a596dbaa9fb2296442e407fd5b015383dac7bbf" translate="yes" xml:space="preserve">
          <source>White Circle With Lower Right Quadrant</source>
          <target state="translated">오른쪽 아래 사분면이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="672dc6b358ee6b861860cd20aec5494e0af288b8" translate="yes" xml:space="preserve">
          <source>White Circle With Two Dots</source>
          <target state="translated">두 개의 점이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="1f4da13b448e4c14ba5b609f9bb4745e9e5ca6e9" translate="yes" xml:space="preserve">
          <source>White Circle With Upper Left Quadrant</source>
          <target state="translated">왼쪽 위 사분면이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="461fb2b1ea25d153f7a6aa34a5fd39118d45bba4" translate="yes" xml:space="preserve">
          <source>White Circle With Upper Right Quadrant</source>
          <target state="translated">오른쪽 위 사분면이있는 흰색 원</target>
        </trans-unit>
        <trans-unit id="a6115fcd670ee20901c40ff2b1b9797df7dfa006" translate="yes" xml:space="preserve">
          <source>White Club Suit</source>
          <target state="translated">화이트 클럽 슈트</target>
        </trans-unit>
        <trans-unit id="f952ed3ad8fab1cb62467e61cab89d2d1bc7c141" translate="yes" xml:space="preserve">
          <source>White Diamond</source>
          <target state="translated">화이트 다이아몬드</target>
        </trans-unit>
        <trans-unit id="55ff3a5814a60ca22f7334da0fe0a03866b29690" translate="yes" xml:space="preserve">
          <source>White Diamond Containing Black Small Diamond</source>
          <target state="translated">블랙 스몰 다이아몬드를 포함하는 화이트 다이아몬드</target>
        </trans-unit>
        <trans-unit id="8ede27e8a98dcab5fa658af9ff95c8f2de052979" translate="yes" xml:space="preserve">
          <source>White Diamond Suit</source>
          <target state="translated">화이트 다이아몬드 슈트</target>
        </trans-unit>
        <trans-unit id="25645a80840249c1631ced95a1131fd5693d26a2" translate="yes" xml:space="preserve">
          <source>White Down Pointing Backhand Index</source>
          <target state="translated">화이트 다운 포인팅 백핸드 인덱스</target>
        </trans-unit>
        <trans-unit id="3da143c67945743d6fa21635f9f5531063fb585f" translate="yes" xml:space="preserve">
          <source>White Down-Pointing Small Triangle / White Down Pointing Small Triangle</source>
          <target state="translated">흰색 아래쪽 작은 삼각형 / 흰색 아래쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="d85b319d306b744560c684c8558c3150f25c759e" translate="yes" xml:space="preserve">
          <source>White Down-Pointing Triangle / White Down Pointing Triangle</source>
          <target state="translated">흰색 아래쪽을 가리키는 삼각형 / 흰색 아래쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="e9b368a5d40031b023d531fc80971be08451a032" translate="yes" xml:space="preserve">
          <source>White Exclamation Mark Ornament</source>
          <target state="translated">느낌표 장식 화이트</target>
        </trans-unit>
        <trans-unit id="10d649860b97fdd765058196d5af9ef4b8dbb88c" translate="yes" xml:space="preserve">
          <source>White Flower</source>
          <target state="translated">흰 꽃</target>
        </trans-unit>
        <trans-unit id="f94d39c1cd22b27b47b2f3f915dce302928d66ca" translate="yes" xml:space="preserve">
          <source>White Heart Suit</source>
          <target state="translated">화이트 하트 슈트</target>
        </trans-unit>
        <trans-unit id="26de1b9a5e6c3681524ba9195b2307746d320518" translate="yes" xml:space="preserve">
          <source>White Heavy Check Mark</source>
          <target state="translated">흰색 무거운 확인 표시</target>
        </trans-unit>
        <trans-unit id="613af43285ba7a0ae894f4cfb736239ef65a6154" translate="yes" xml:space="preserve">
          <source>White Hexagon</source>
          <target state="translated">화이트 육각형</target>
        </trans-unit>
        <trans-unit id="7b5e7d13cd121c85b4bb13208c84034861c7cb6e" translate="yes" xml:space="preserve">
          <source>White Horizontal Ellipse</source>
          <target state="translated">흰색 가로 타원</target>
        </trans-unit>
        <trans-unit id="f4d79e99747238a6e41f2d61025ecfbc894087c0" translate="yes" xml:space="preserve">
          <source>White Large Square</source>
          <target state="translated">흰색 큰 광장</target>
        </trans-unit>
        <trans-unit id="e51ee8c21e96d837babac571a1cd183c3ac42093" translate="yes" xml:space="preserve">
          <source>White Left Pointing Backhand Index</source>
          <target state="translated">흰색 왼쪽 포인팅 백핸드 인덱스</target>
        </trans-unit>
        <trans-unit id="680cc5a2c271605dbb7cd76466eaa1ee28fd3e83" translate="yes" xml:space="preserve">
          <source>White Left-Pointing Pointer / White Left Pointing Pointer</source>
          <target state="translated">흰색 왼쪽 포인팅 포인터 / 흰색 왼쪽 포인팅 포인터</target>
        </trans-unit>
        <trans-unit id="2d97b16b2bf05311d60c6154fd15c292463d76a4" translate="yes" xml:space="preserve">
          <source>White Left-Pointing Small Triangle / White Left Pointing Small Triangle</source>
          <target state="translated">흰색 왼쪽 작은 삼각형 / 흰색 왼쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="b2bd60620f1288519f88e1cee597586190d78f96" translate="yes" xml:space="preserve">
          <source>White Left-Pointing Triangle / White Left Pointing Triangle</source>
          <target state="translated">흰색 왼쪽을 가리키는 삼각형 / 흰색 왼쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="a5d0b3f0af3e38060d7de792c6bdcbb1eb5e3f10" translate="yes" xml:space="preserve">
          <source>White Medium Diamond</source>
          <target state="translated">화이트 미디엄 다이아몬드</target>
        </trans-unit>
        <trans-unit id="f7c3621af62bb9ea6bd08a5b8ee3da3a2fd40e3f" translate="yes" xml:space="preserve">
          <source>White Medium Lozenge</source>
          <target state="translated">화이트 미디엄 마름모꼴</target>
        </trans-unit>
        <trans-unit id="ea7abd8f6fe495417dc6ec52a0a1c7afa3e6f9dc" translate="yes" xml:space="preserve">
          <source>White Medium Small Square</source>
          <target state="translated">화이트 미디엄 스몰 스퀘어</target>
        </trans-unit>
        <trans-unit id="a893fa5318683cd059cb5ee66a5b426a43ead599" translate="yes" xml:space="preserve">
          <source>White Medium Square</source>
          <target state="translated">화이트 미디엄 스퀘어</target>
        </trans-unit>
        <trans-unit id="6f8fdba894c29225da318fd533696d2f839ae78e" translate="yes" xml:space="preserve">
          <source>White Medium Star</source>
          <target state="translated">화이트 미디엄 스타</target>
        </trans-unit>
        <trans-unit id="94f0f6d1e4fad29f296a0cc4fee17a4f4b0a35d5" translate="yes" xml:space="preserve">
          <source>White Parallelogram</source>
          <target state="translated">화이트 평행 사변형</target>
        </trans-unit>
        <trans-unit id="ac95a34ae3b4846ba7cad308897ae65184ceb6f9" translate="yes" xml:space="preserve">
          <source>White Pentagon</source>
          <target state="translated">흰 국방부</target>
        </trans-unit>
        <trans-unit id="9907ea5b1099f4ea56141347654e577f39e45ef2" translate="yes" xml:space="preserve">
          <source>White Question Mark Ornament</source>
          <target state="translated">흰색 물음표 장식</target>
        </trans-unit>
        <trans-unit id="dd8532ae60e7384f04353f222ba8f658123bc5cb" translate="yes" xml:space="preserve">
          <source>White Rectangle</source>
          <target state="translated">흰색 사각형</target>
        </trans-unit>
        <trans-unit id="cc520b6f425ec21f629f8629e02c0432fdbb8d02" translate="yes" xml:space="preserve">
          <source>White Right Pointing Backhand Index</source>
          <target state="translated">흰색 오른쪽 포인팅 백핸드 인덱스</target>
        </trans-unit>
        <trans-unit id="727ea857bd3c329445166547fdb91d69eb72e260" translate="yes" xml:space="preserve">
          <source>White Right-Pointing Pentagon</source>
          <target state="translated">화이트 포인팅 펜타곤</target>
        </trans-unit>
        <trans-unit id="ef4a6513f3dbf938488f4c84a4ec11d06b65d445" translate="yes" xml:space="preserve">
          <source>White Right-Pointing Pointer / White Right Pointing Pointer</source>
          <target state="translated">흰색 오른쪽 포인팅 포인터 / 흰색 오른쪽 포인팅 포인터</target>
        </trans-unit>
        <trans-unit id="eef06644e488135d446e5fbd8a4b2af2b92f1fca" translate="yes" xml:space="preserve">
          <source>White Right-Pointing Small Triangle / White Right Pointing Small Triangle</source>
          <target state="translated">흰색 오른쪽을 가리키는 작은 삼각형 / 흰색 오른쪽을 가리키는 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="1b5953087f00f8c08a0eba9649a19ee7ed4ccc61" translate="yes" xml:space="preserve">
          <source>White Right-Pointing Triangle / White Right Pointing Triangle</source>
          <target state="translated">흰색 오른쪽을 가리키는 삼각형 / 흰색 오른쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="4652a549f479384e502bd957e68bce478919740b" translate="yes" xml:space="preserve">
          <source>White Small Lozenge</source>
          <target state="translated">하얀 작은 마름모꼴</target>
        </trans-unit>
        <trans-unit id="819c8924b69ae048832f9f245654a0f3675e7d7f" translate="yes" xml:space="preserve">
          <source>White Small Square</source>
          <target state="translated">화이트 스몰 스퀘어</target>
        </trans-unit>
        <trans-unit id="9edb5e7c110d675d95bbe00187a763284fceeb66" translate="yes" xml:space="preserve">
          <source>White Small Star</source>
          <target state="translated">화이트 스몰 스타</target>
        </trans-unit>
        <trans-unit id="e827fa8115af6a8ff7e8694006fdc84821193ae1" translate="yes" xml:space="preserve">
          <source>White Smiling Face</source>
          <target state="translated">하얀 웃는 얼굴</target>
        </trans-unit>
        <trans-unit id="7292a4d2f1ad67f38f858a5ba2aa2f931216208d" translate="yes" xml:space="preserve">
          <source>White Spade Suit</source>
          <target state="translated">화이트 스페이드 수트</target>
        </trans-unit>
        <trans-unit id="85e6d72ac7d40e888c68f97f937db0275136d4bc" translate="yes" xml:space="preserve">
          <source>White Square</source>
          <target state="translated">화이트 스퀘어</target>
        </trans-unit>
        <trans-unit id="8f0420eb950e967ab932dd0092a9e69b9e847452" translate="yes" xml:space="preserve">
          <source>White Square Button</source>
          <target state="translated">화이트 스퀘어 버튼</target>
        </trans-unit>
        <trans-unit id="49c3968fd08318e52ffe077d152705799435b243" translate="yes" xml:space="preserve">
          <source>White Square Containing Black Small Square</source>
          <target state="translated">검은 색 작은 사각형을 포함하는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="5619b6d53d6541754f6d6468f142e7fa76ad7d27" translate="yes" xml:space="preserve">
          <source>White Square With Lower Left Quadrant</source>
          <target state="translated">왼쪽 아래 사분면이있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="808c9e191bf161e38926f5c5f29bd3081aeff48c" translate="yes" xml:space="preserve">
          <source>White Square With Lower Right Quadrant</source>
          <target state="translated">오른쪽 아래 사분면이있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="4268bdeee136d632856d4e162626b19d1248aac4" translate="yes" xml:space="preserve">
          <source>White Square With Rounded Corners</source>
          <target state="translated">둥근 모서리가있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="72fbf1e699577a2d0f954dab09953632de3c1094" translate="yes" xml:space="preserve">
          <source>White Square With Upper Left Quadrant</source>
          <target state="translated">왼쪽 위 사분면이있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="dd849fbc18756c006103ba9e64207f6b3bdef64c" translate="yes" xml:space="preserve">
          <source>White Square With Upper Right Quadrant</source>
          <target state="translated">오른쪽 위 사분면이있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="2d9cf58f29a3fe6d4f0832346429f7ff203c4dbe" translate="yes" xml:space="preserve">
          <source>White Square With Vertical Bisecting Line</source>
          <target state="translated">수직 이등분 선이있는 흰색 사각형</target>
        </trans-unit>
        <trans-unit id="634d0a78d841ec0b40e03be702c56baf75674da8" translate="yes" xml:space="preserve">
          <source>White Star</source>
          <target state="translated">화이트 스타</target>
        </trans-unit>
        <trans-unit id="059206764751f0f85f8e29888baea1aba1f8ee13" translate="yes" xml:space="preserve">
          <source>White Sun With Rays</source>
          <target state="translated">광선으로 하얀 태양</target>
        </trans-unit>
        <trans-unit id="1224c9826c7ff52b9fa1a2c1f96b20f15f4f5a00" translate="yes" xml:space="preserve">
          <source>White Trapezium</source>
          <target state="translated">백색 사다리꼴</target>
        </trans-unit>
        <trans-unit id="2db4ec41a4066aee4d15a98eb10d2e169c42101a" translate="yes" xml:space="preserve">
          <source>White Triangle Containing Small White Triangle</source>
          <target state="translated">작은 흰색 삼각형을 포함하는 흰색 삼각형</target>
        </trans-unit>
        <trans-unit id="07c000d04b8d0ed25a0985fd7cb107f60bb49aab" translate="yes" xml:space="preserve">
          <source>White Up Pointing Backhand Index</source>
          <target state="translated">화이트 업 포인팅 백핸드 인덱스</target>
        </trans-unit>
        <trans-unit id="c0825f3e41b65ad4e04d89a05f1a919af7180270" translate="yes" xml:space="preserve">
          <source>White Up Pointing Index</source>
          <target state="translated">화이트 업 포인팅 인덱스</target>
        </trans-unit>
        <trans-unit id="c739eac64ca9f680aa4858b15393910c507a241b" translate="yes" xml:space="preserve">
          <source>White Up-Pointing Small Triangle / White Up Pointing Small Triangle</source>
          <target state="translated">흰색 위를 가리키는 작은 삼각형 / 흰색 위를 가리키는 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="2c2fafe73198844e99d5803401863be888da05ec" translate="yes" xml:space="preserve">
          <source>White Up-Pointing Triangle / White Up Pointing Triangle</source>
          <target state="translated">흰색 위쪽을 가리키는 삼각형 / 흰색 위쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="b322ae097e5df051502f9578e5e4927b9661297e" translate="yes" xml:space="preserve">
          <source>White Up-Pointing Triangle With Dot / White Up Pointing Triangle With Dot</source>
          <target state="translated">점을 가진 백색 위쪽을 가리키는 삼각형 / 점을 가진 백색 위쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="a0d24f6c4921190b94a3c24ff9acc8802c79083a" translate="yes" xml:space="preserve">
          <source>White Vertical Ellipse</source>
          <target state="translated">흰색 세로 타원</target>
        </trans-unit>
        <trans-unit id="b6e53c0193060ce68c08e8717dafe1ff48bba21f" translate="yes" xml:space="preserve">
          <source>White Vertical Rectangle</source>
          <target state="translated">흰색 세로 직사각형</target>
        </trans-unit>
        <trans-unit id="f4a3ad9816239183ef5bd3d0d3228e167207e61a" translate="yes" xml:space="preserve">
          <source>White Very Small Square</source>
          <target state="translated">흰색 매우 작은 광장</target>
        </trans-unit>
        <trans-unit id="f7e1fe3853c28a0fe97ed3cd954b7712a00f380f" translate="yes" xml:space="preserve">
          <source>Why are my Julia benchmarks for linear algebra operations different from other languages?</source>
          <target state="translated">Julia가 선형 대수 연산에 대한 벤치 마크가 다른 언어와 다른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4bbb029eb21510032c8af609c080a79c369b7dce" translate="yes" xml:space="preserve">
          <source>Why do concurrent writes to the same stream result in inter-mixed output?</source>
          <target state="translated">동일한 스트림에 동시 쓰기로 인해 혼합 혼합 출력이 발생하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1b4aae83fbf8014ab13afea081bebec6ec7f0b9d" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;x += y&lt;/code&gt; allocate memory when &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are arrays?</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 배열 일 때 왜 &lt;code&gt;x += y&lt;/code&gt; 메모리를 할당 합니까?</target>
        </trans-unit>
        <trans-unit id="00096e7a6fdbbe783ffa3d87f87fff2daaa46322" translate="yes" xml:space="preserve">
          <source>Why does Julia give a &lt;code&gt;DomainError&lt;/code&gt; for certain seemingly-sensible operations?</source>
          <target state="translated">Julia 가 합리적인 것처럼 보이는 특정 작업에 대해 &lt;code&gt;DomainError&lt;/code&gt; 를 제공하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="2e029a53e5754836ebc5f2accd6987b7ec664e47" translate="yes" xml:space="preserve">
          <source>Why does Julia use &lt;code&gt;*&lt;/code&gt; for string concatenation? Why not &lt;code&gt;+&lt;/code&gt; or something else?</source>
          <target state="translated">Julia는 왜 문자열 연결에 &lt;code&gt;*&lt;/code&gt; 를 사용 합니까? 왜 &lt;code&gt;+&lt;/code&gt; 또는 다른 것?</target>
        </trans-unit>
        <trans-unit id="3e93bc1af1398ad92317ee65e0617d4980dd38e8" translate="yes" xml:space="preserve">
          <source>Why does Julia use native machine integer arithmetic?</source>
          <target state="translated">Julia는 왜 기본 기계 정수 산술을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="30a4da2d9f0375ec9c7d6aacf65987f1f3472c14" translate="yes" xml:space="preserve">
          <source>Why doesn't it just work like in files everywhere? And maybe skip the warning?</source>
          <target state="translated">왜 어디서나 파일처럼 작동하지 않습니까? 그리고 경고를 건너 뛸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6c4ad57f8165d0120271f7fec6b3f8432a298f09" translate="yes" xml:space="preserve">
          <source>Why doesn't it just work like the REPL everywhere?</source>
          <target state="translated">왜 어디서나 REPL처럼 작동하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="fcf72338b56ad52314b2887dbaf69181cccb526f" translate="yes" xml:space="preserve">
          <source>Why don't you compile Matlab/Python/R/&amp;hellip; code to Julia?</source>
          <target state="translated">Matlab / Python / R /&amp;hellip; 코드를 Julia로 컴파일하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d2e5203fdb2516ab2f5c1deafbcf63cb32540c19" translate="yes" xml:space="preserve">
          <source>Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).</source>
          <target state="translated">7 월 (홀수)인데도 왜 7 월 첫째 날로 반올림합니까? 핵심은 시간, 분, 초 및 밀리 초 (첫 번째는 0으로 지정됨)와 달리 월은 1- 인덱싱 됨 (첫 번째 달에 1이 할당 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="48ea3ab16df0e58995a85e5e959893106086f0d6" translate="yes" xml:space="preserve">
          <source>Wind Chime</source>
          <target state="translated">바람 차임</target>
        </trans-unit>
        <trans-unit id="983f638e64348ade35b4611d310d66c9145e3880" translate="yes" xml:space="preserve">
          <source>Wine Glass</source>
          <target state="translated">와인 잔</target>
        </trans-unit>
        <trans-unit id="abc7fe153bc9746ac855f60d74d0d8123c77b393" translate="yes" xml:space="preserve">
          <source>Winking Face</source>
          <target state="translated">윙크하는 얼굴</target>
        </trans-unit>
        <trans-unit id="581843091f10902932335f64cd6f3a2c9f96a3d3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s, serializing an already fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to a different node also sends the value since the original remote store may have collected the value by this time.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; 를&lt;/a&gt; 사용하면 이미 가져온 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 다른 노드에 직렬화 하면 원래 원격 저장소가이 시점까지 값을 수집했을 수 있으므로 값을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="75533720d520fbee81b81c1ba5dc661047b34eea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@macroexpand&lt;/code&gt; the expression expands where &lt;code&gt;@macroexpand&lt;/code&gt; appears in the code (module &lt;code&gt;M&lt;/code&gt; in the example). With &lt;code&gt;macroexpand&lt;/code&gt; the expression expands in the module given as the first argument.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; 를 사용 하면 코드 에서 &lt;code&gt;@macroexpand&lt;/code&gt; 가 나타나는 위치에서 표현식이 확장됩니다 ( 예제에서 모듈 &lt;code&gt;M&lt;/code&gt; ). &lt;code&gt;macroexpand&lt;/code&gt; 를 사용 하면 첫 번째 인수로 제공된 모듈에서 표현식이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="dc21453b1fccd61e9c2a2caa2cd4c8a04c421020" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;batch_size&lt;/code&gt; defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. &lt;code&gt;map&lt;/code&gt; is used in the modified mapping function to achieve this.</source>
          <target state="translated">함께 &lt;code&gt;batch_size&lt;/code&gt; 정의 매핑 기능 요구 사항은 인수 튜플의 배열을 수용하고 결과의 배열을 반환하도록 변경합니다. 이를 위해 수정 된 매핑 기능에서 &lt;code&gt;map&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="de6d6c8d7c2f6e5e8324e5783051c41a94f0d494" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ntasks=2&lt;/code&gt; all elements are processed in 2 tasks.</source>
          <target state="translated">&lt;code&gt;ntasks=2&lt;/code&gt; 를 사용하면 모든 요소가 2 개의 작업으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a8e1e2f0076f36b7212590a0b6a34603804f4e" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;waitfor&lt;/code&gt; value of 0, the call returns immediately with the workers scheduled for removal in a different task. The scheduled &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object is returned. The user should call &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the task before invoking any other parallel calls.</source>
          <target state="translated">A를 &lt;code&gt;waitfor&lt;/code&gt; 0의 값, 즉시 다른 작업에서 제거 될 예정 노동자와 호출이 반환. 예약 된 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체가 반환됩니다. 사용자는 다른 병렬 호출을 호출하기 전에 작업 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bded26b5569676e9053ab54c2f9e25c3c3e79857" translate="yes" xml:space="preserve">
          <source>With only &lt;a href=&quot;../../base/collections/index#Base.iterate&quot;&gt;&lt;code&gt;iterate&lt;/code&gt;&lt;/a&gt; definition, the &lt;code&gt;Squares&lt;/code&gt; type is already pretty powerful. We can iterate over all the elements:</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.iterate&quot;&gt; &lt;code&gt;iterate&lt;/code&gt; &lt;/a&gt; 정의 만으로도 &lt;code&gt;Squares&lt;/code&gt; 유형은 이미 매우 강력합니다. 모든 요소를 ​​반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f7b875de446935bd4cc6f1a7d35fb26e7293e3" translate="yes" xml:space="preserve">
          <source>With such a declaration, it is acceptable to use any type that is a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;T&lt;/code&gt;, but not types that are not subtypes of &lt;code&gt;Real&lt;/code&gt;:</source>
          <target state="translated">이러한 선언 으로 &lt;code&gt;T&lt;/code&gt; 대신 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 의 하위 유형 인 모든 유형을 사용할 수 있지만 &lt;code&gt;Real&lt;/code&gt; 의 하위 유형이 아닌 유형은 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fefc09d1374ace4b2cc6f62853ea9d51faf15a8a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;do&lt;/code&gt; block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 블록 구문을 사용하면 문서 또는 구현을 확인하여 사용자 함수의 인수가 초기화되는 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="503bb222a1bcd305845bfa8706594c057e11f9bc" translate="yes" xml:space="preserve">
          <source>With this declaration, &lt;code&gt;Pointy{T}&lt;/code&gt; is a distinct abstract type for each type or integer value of &lt;code&gt;T&lt;/code&gt;. As with parametric composite types, each such instance is a subtype of &lt;code&gt;Pointy&lt;/code&gt;:</source>
          <target state="translated">이 선언에서 &lt;code&gt;Pointy{T}&lt;/code&gt; 는 각 유형 또는 정수 값 &lt;code&gt;T&lt;/code&gt; 의 고유 한 추상 유형입니다 . 파라 메트릭 합성 유형과 마찬가지로 이러한 각 인스턴스는 &lt;code&gt;Pointy&lt;/code&gt; 의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="7a216c8e2bca2ef6b82975092df1fd3a30bc77dd" translate="yes" xml:space="preserve">
          <source>With this definition, the function can be called with either one, two or three arguments, and &lt;code&gt;1&lt;/code&gt; is automatically passed when any of the arguments is not specified:</source>
          <target state="translated">이 정의를 사용하면 하나, 둘 또는 세 개의 인수로 함수를 호출 할 수 있으며 인수가 지정되지 않은 경우 &lt;code&gt;1&lt;/code&gt; 이 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="447b8dfb65dcbfcf6fcad2ab9a9aa921f47048b2" translate="yes" xml:space="preserve">
          <source>With this definition, the function can be called with either one, two or three arguments, and &lt;code&gt;1&lt;/code&gt; is automatically passed when only one or two of the arguments are specified:</source>
          <target state="translated">이 정의를 사용하면 함수는 1 개, 2 개 또는 3 개의 인수로 호출 될 수 있으며 &lt;code&gt;1&lt;/code&gt; 개 또는 2 개의 인수 만 지정 될 때 1 이 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5f10b122d0ba4c967956b4a13f71e5b19ab4662e" translate="yes" xml:space="preserve">
          <source>With this syntax, iterables may still refer to outer loop variables; e.g. &lt;code&gt;for i = 1:n, j = 1:i&lt;/code&gt; is valid. However a &lt;code&gt;break&lt;/code&gt; statement inside such a loop exits the entire nest of loops, not just the inner one. Both variables (&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;) are set to their current iteration values each time the inner loop runs. Therefore, assignments to &lt;code&gt;i&lt;/code&gt; will not be visible to subsequent iterations:</source>
          <target state="translated">이 구문을 사용하면 이터 러블은 여전히 ​​외부 루프 변수를 참조 할 수 있습니다. 예 &lt;code&gt;for i = 1:n, j = 1:i&lt;/code&gt; 들어 i = 1 : n의 경우 j = 1 : i 가 유효합니다. 그러나 이러한 루프 내부 의 &lt;code&gt;break&lt;/code&gt; 문은 내부 루프 만이 아니라 전체 루프 중첩을 종료합니다. 두 개의 변수 ( &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; )는 내부 루프가 실행될 때마다 현재 반복 값으로 설정됩니다. 따라서 &lt;code&gt;i&lt;/code&gt; 에 대한 할당 은 다음 반복에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="974560762d7f9d8809deddf944b7bb6130508cf8" translate="yes" xml:space="preserve">
          <source>Without keyword arguments, &lt;code&gt;x&lt;/code&gt; is rounded to an integer value, returning a value of type &lt;code&gt;T&lt;/code&gt;, or of the same type of &lt;code&gt;x&lt;/code&gt; if no &lt;code&gt;T&lt;/code&gt; is provided. An &lt;a href=&quot;../base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be thrown if the value is not representable by &lt;code&gt;T&lt;/code&gt;, similar to &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키워드 인수가 없으면 &lt;code&gt;x&lt;/code&gt; 는 정수 값으로 반올림되어 &lt;code&gt;T&lt;/code&gt; 유형 또는 &lt;code&gt;T&lt;/code&gt; 가 제공 되지 않은 경우 동일한 &lt;code&gt;x&lt;/code&gt; 유형의 값을 리턴합니다 . &lt;a href=&quot;../base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 는&lt;/a&gt; 값으로 표현할 수없는 경우에 발생합니다 &lt;code&gt;T&lt;/code&gt; 와 유사하게 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b32189c1c5c8ca5b8d9a0a455eb12f4d1954923" translate="yes" xml:space="preserve">
          <source>Without parentheses, the expression &lt;code&gt;f&lt;/code&gt; refers to the function object, and can be passed around like any other value:</source>
          <target state="translated">괄호가 없으면 표현식 &lt;code&gt;f&lt;/code&gt; 는 함수 객체를 참조하며 다른 값처럼 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa3290590d6a6eeac6efebb9b9654e8c0a3a248" translate="yes" xml:space="preserve">
          <source>Without parentheses, the expression &lt;code&gt;f&lt;/code&gt; refers to the function object, and can be passed around like any value:</source>
          <target state="translated">괄호가 없으면 표현식 &lt;code&gt;f&lt;/code&gt; 는 함수 객체를 나타내며 모든 값처럼 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057c67438e0b378de20c837094077aeb4442b98f" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;break&lt;/code&gt; keyword, the above &lt;code&gt;while&lt;/code&gt; loop would never terminate on its own, and the &lt;code&gt;for&lt;/code&gt; loop would iterate up to 1000. These loops are both exited early by using &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 키워드가 없으면 위의 &lt;code&gt;while&lt;/code&gt; 루프는 자체적으로 종료되지 않으며 &lt;code&gt;for&lt;/code&gt; 루프는 최대 1000까지 반복됩니다.이 루프는 모두 &lt;code&gt;break&lt;/code&gt; 를 사용하여 일찍 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="a346da9a68b13b25a9f7cb2fd78eb7978ee0a04a" translate="yes" xml:space="preserve">
          <source>Wolf Face</source>
          <target state="translated">늑대 얼굴</target>
        </trans-unit>
        <trans-unit id="1cb72b9108626d8ac566eba64409dacf9a40b11e" translate="yes" xml:space="preserve">
          <source>Woman</source>
          <target state="translated">Woman</target>
        </trans-unit>
        <trans-unit id="6dfb7f3a8d49e9c60ed61f82d18ca8ac2838458c" translate="yes" xml:space="preserve">
          <source>Woman With Bunny Ears</source>
          <target state="translated">토끼 귀를 가진 여자</target>
        </trans-unit>
        <trans-unit id="5a6394d24a5279ce017885520fdb48ffc70f08d4" translate="yes" xml:space="preserve">
          <source>Womans Boots</source>
          <target state="translated">여자 부츠</target>
        </trans-unit>
        <trans-unit id="7d4124fc5a81619b81859db6f91943ca5bb45e8e" translate="yes" xml:space="preserve">
          <source>Womans Clothes</source>
          <target state="translated">여자의 옷</target>
        </trans-unit>
        <trans-unit id="ce5f716b57b265b131a17fffd163abf4c36c842b" translate="yes" xml:space="preserve">
          <source>Womans Hat</source>
          <target state="translated">여자 모자</target>
        </trans-unit>
        <trans-unit id="85aca00c09071a52aba584e53b36018f9b894c55" translate="yes" xml:space="preserve">
          <source>Womans Sandal</source>
          <target state="translated">여자 샌들</target>
        </trans-unit>
        <trans-unit id="b78031fbb7d05c9d0ff329bbff3f7a6447a90388" translate="yes" xml:space="preserve">
          <source>Womens Symbol</source>
          <target state="translated">여자의 상징</target>
        </trans-unit>
        <trans-unit id="57ecdc70b504efbceec0cd8d34cea25e9063a812" translate="yes" xml:space="preserve">
          <source>Word Joiner</source>
          <target state="translated">단어 소목 장이</target>
        </trans-unit>
        <trans-unit id="c3edbbb14bf867b6bece4274440ffdbbeba538be" translate="yes" xml:space="preserve">
          <source>Word separation can be indicated by underscores (&lt;code&gt;'_'&lt;/code&gt;), but use of underscores is discouraged unless the name would be hard to read otherwise.</source>
          <target state="translated">단어 구분은 밑줄 ( &lt;code&gt;'_'&lt;/code&gt; ) 로 표시 할 수 있지만 이름을 달리 읽기 어려운 경우가 아니라면 밑줄을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="719f23a34b446f1c2b8e5447594bf9f94eb261ef" translate="yes" xml:space="preserve">
          <source>Workflow Tips</source>
          <target state="translated">워크 플로우 팁</target>
        </trans-unit>
        <trans-unit id="72cf6cd09a850a2cf4790c3438a493e200f5281f" translate="yes" xml:space="preserve">
          <source>Working with &lt;code&gt;Broadcasted&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;Broadcasted&lt;/code&gt; 객체 작업</target>
        </trans-unit>
        <trans-unit id="f1554531a14293e9b5f2d548951c2491fa5894fd" translate="yes" xml:space="preserve">
          <source>Working with Arrays</source>
          <target state="translated">배열 작업</target>
        </trans-unit>
        <trans-unit id="83cf1b02634def5b23b868974db450a895a02f92" translate="yes" xml:space="preserve">
          <source>Working with Files</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="e561077dd059f1516770b93796c56838b6b06ebe" translate="yes" xml:space="preserve">
          <source>Working with Test Sets</source>
          <target state="translated">테스트 세트 작업</target>
        </trans-unit>
        <trans-unit id="c94118dce35f5d3b4f01c86d6cba1023a7883418" translate="yes" xml:space="preserve">
          <source>Worried Face</source>
          <target state="translated">걱정스러운 얼굴</target>
        </trans-unit>
        <trans-unit id="643f9be452aad16c5d4b635ba25e01524af427f5" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;code&gt;Vector&lt;/code&gt; of exceptions thrown by a &lt;a href=&quot;../parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under &lt;code&gt;pmap&lt;/code&gt;) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting &lt;code&gt;CompositeException&lt;/code&gt; will contain a &quot;bundle&quot; of information from each worker indicating where and why the exception(s) occurred.</source>
          <target state="translated">랩 &lt;code&gt;Vector&lt;/code&gt; a로 던져 예외 &lt;a href=&quot;../parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; (채널 또는 비동기 적으로 실행 로컬 I / O 쓰기 또는 아래 원격 작업자을 통해 원격 작업자에서 발생 예 &lt;code&gt;pmap&lt;/code&gt; 예외 시리즈에 대한 정보). 예를 들어, 작업자 그룹이 여러 작업을 실행하고 여러 작업자가 실패하는 경우 결과 &lt;code&gt;CompositeException&lt;/code&gt; 에는 예외 발생 위치 및 이유를 나타내는 각 작업자의 &quot;번들&quot;정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ec473d4d05e151c4b0eb94d5d4eceaf44cd4f086" translate="yes" xml:space="preserve">
          <source>Wrap a Julia &lt;code&gt;Array&lt;/code&gt; object around the data at the address given by &lt;code&gt;pointer&lt;/code&gt;, without making a copy. The pointer element type &lt;code&gt;T&lt;/code&gt; determines the array element type. &lt;code&gt;dims&lt;/code&gt; is either an integer (for a 1d array) or a tuple of the array dimensions. &lt;code&gt;own&lt;/code&gt; optionally specifies whether Julia should take ownership of the memory, calling &lt;code&gt;free&lt;/code&gt; on the pointer when the array is no longer referenced.</source>
          <target state="translated">복사하지 않고 &lt;code&gt;pointer&lt;/code&gt; 로 지정된 주소의 데이터 주위에 Julia &lt;code&gt;Array&lt;/code&gt; 객체를 래핑합니다 . 포인터 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 배열 요소 유형을 결정합니다. &lt;code&gt;dims&lt;/code&gt; 는 정수 (1d 배열의 경우) 또는 배열 차원의 튜플입니다. &lt;code&gt;own&lt;/code&gt; 줄리아 여부를 선택적으로 지정하는가 호출되지, 메모리의 소유권을해야 &lt;code&gt;free&lt;/code&gt; 배열이 더 이상 참조 할 때 포인터에.</target>
        </trans-unit>
        <trans-unit id="bb11cd0bd69cc50df511cf85ddf1cd4d48d9cd04" translate="yes" xml:space="preserve">
          <source>Wrap an expression in a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and add it to the local machine's scheduler queue.</source>
          <target state="translated">&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 에서 식을 래핑 하여 로컬 컴퓨터의 스케줄러 대기열에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5073be58d66f221818fcea45c57ca978e66b8268" translate="yes" xml:space="preserve">
          <source>Wrap an expression in a &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; without executing it, and return the &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;. This only creates a task, and does not run it.</source>
          <target state="translated">A의 식 랩 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 실행하지 않고, 그리고 반환 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; . 이것은 작업 만 생성하고 실행하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3a85a4dc41c5c5208ca7b5a5f20305e0dda2cfb" translate="yes" xml:space="preserve">
          <source>Wrap your function in a module:</source>
          <target state="translated">함수를 모듈로 감싸십시오.</target>
        </trans-unit>
        <trans-unit id="0c727aa02984e9265ed720a0cc477eba7864a0a0" translate="yes" xml:space="preserve">
          <source>Wrapped Present</source>
          <target state="translated">포장 된 선물</target>
        </trans-unit>
        <trans-unit id="4c299bd23d0a4bc5197aa857238f132545f5def2" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/group/commit/git_commit_create&quot;&gt;&lt;code&gt;git_commit_create&lt;/code&gt;&lt;/a&gt;. Create a commit in the repository &lt;code&gt;repo&lt;/code&gt;. &lt;code&gt;msg&lt;/code&gt; is the commit message. Return the OID of the new commit.</source>
          <target state="translated">&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/group/commit/git_commit_create&quot;&gt; &lt;code&gt;git_commit_create&lt;/code&gt; &lt;/a&gt; 주위의 래퍼 입니다. A는 저장소에 커밋 만들기 &lt;code&gt;repo&lt;/code&gt; . &lt;code&gt;msg&lt;/code&gt; 는 커밋 메시지입니다. 새로운 커밋의 OID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="914406aad26fbb402914377aadad7a61529e87cf" translate="yes" xml:space="preserve">
          <source>Wrapper types</source>
          <target state="translated">래퍼 유형</target>
        </trans-unit>
        <trans-unit id="7da2bdafb830ea4034b4a9f75526a715fd0d86d0" translate="yes" xml:space="preserve">
          <source>Wreath Product</source>
          <target state="translated">화환 제품</target>
        </trans-unit>
        <trans-unit id="60a77f2daf0e1f4113ff076604e19f8a61f8d079" translate="yes" xml:space="preserve">
          <source>Wrench</source>
          <target state="translated">Wrench</target>
        </trans-unit>
        <trans-unit id="9f4443f6abc474ecd391c80029564af8642f98e3" translate="yes" xml:space="preserve">
          <source>Write &quot;type-stable&quot; functions</source>
          <target state="translated">&quot;type-stable&quot;함수 작성</target>
        </trans-unit>
        <trans-unit id="108ebb82b60e8c92a8619b85402ca125571054b0" translate="yes" xml:space="preserve">
          <source>Write &lt;a href=&quot;../../base/base/index#Base.SimdLoop.@simd&quot;&gt;&lt;code&gt;@simd&lt;/code&gt;&lt;/a&gt; in front of &lt;code&gt;for&lt;/code&gt; loops to promise that the iterations are independent and may be reordered. Note that in many cases, Julia can automatically vectorize code without the &lt;code&gt;@simd&lt;/code&gt; macro; it is only beneficial in cases where such a transformation would otherwise be illegal, including cases like allowing floating-point re-associativity and ignoring dependent memory accesses (&lt;code&gt;@simd ivdep&lt;/code&gt;). Again, be very careful when asserting &lt;code&gt;@simd&lt;/code&gt; as erroneously annotating a loop with dependent iterations may result in unexpected results. In particular, note that &lt;code&gt;setindex!&lt;/code&gt; on some &lt;code&gt;AbstractArray&lt;/code&gt; subtypes is inherently dependent upon iteration order. &lt;strong&gt;This feature is experimental&lt;/strong&gt; and could change or disappear in future versions of Julia.</source>
          <target state="translated">반복문이 독립적이며 재정렬 될 수 있음을 약속 &lt;code&gt;for&lt;/code&gt; 루프 앞에 &lt;a href=&quot;../../base/base/index#Base.SimdLoop.@simd&quot;&gt; &lt;code&gt;@simd&lt;/code&gt; &lt;/a&gt; 를 쓰 십시오 . 많은 경우 Julia는 &lt;code&gt;@simd&lt;/code&gt; 매크로 없이 코드를 자동으로 벡터화 할 수 있습니다 . 부동 소수점 재 연관 허용 및 종속 메모리 액세스 무시 ( &lt;code&gt;@simd ivdep&lt;/code&gt; ) 와 같은 경우를 포함하여 이러한 변환이 불법 인 경우에만 유용 합니다. 반복적으로 종속 반복으로 루프에 주석을 &lt;code&gt;@simd&lt;/code&gt; 때 @simd 를 선언 할 때 예기치 않은 결과가 발생할 수 있으므로 매우주의하십시오 . 특히 &lt;code&gt;setindex!&lt;/code&gt; 일부 &lt;code&gt;AbstractArray&lt;/code&gt; &lt;strong&gt;에서이 기능은 실험적입니다&lt;/strong&gt; 하위 유형에서는 기본적으로 반복 순서에 따라 다릅니다.&lt;strong&gt;&lt;/strong&gt; Julia의 이후 버전에서는 변경되거나 사라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feda5417424a49ab311d7ff404b0540a63818aab" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;A&lt;/code&gt; (a vector, matrix, or an iterable collection of iterable rows) as text to &lt;code&gt;f&lt;/code&gt; (either a filename string or an &lt;code&gt;IO&lt;/code&gt; stream) using the given delimiter &lt;code&gt;delim&lt;/code&gt; (which defaults to tab, but can be any printable Julia object, typically a &lt;code&gt;Char&lt;/code&gt; or &lt;code&gt;AbstractString&lt;/code&gt;).</source>
          <target state="translated">쓰기 에 텍스트로 (벡터, 행렬, 또는 반복 가능한 행의 반복 가능한 컬렉션) &lt;code&gt;f&lt;/code&gt; (파일 이름 문자열 또는 중 &lt;code&gt;IO&lt;/code&gt; 스트림) 지정된 구분 기호 사용 &lt;code&gt;delim&lt;/code&gt; 일반적으로 (기본값 탭에, 그러나 인쇄 가능한 줄리아 객체가 될 수 있습니다 &lt;code&gt;Char&lt;/code&gt; 또는 &lt;code&gt;AbstractString&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="775f113932a5efeffdda634c47beb3eed1ff2fe8" translate="yes" xml:space="preserve">
          <source>Write Permission</source>
          <target state="translated">쓰기 권한</target>
        </trans-unit>
        <trans-unit id="cb1bb77575fa4409af2eee4cd439da1e073d5da8" translate="yes" xml:space="preserve">
          <source>Write a number in REPL and press &lt;code&gt;^Q&lt;/code&gt; to open editor at corresponding stackframe or method</source>
          <target state="translated">REPL에 숫자를 쓰고 &lt;code&gt;^Q&lt;/code&gt; 를 눌러 해당 스택 프레임 또는 메소드에서 편집기를여십시오.</target>
        </trans-unit>
        <trans-unit id="94dd4ad05923ad8ccb38018f26838043a0492298" translate="yes" xml:space="preserve">
          <source>Write a small function &lt;code&gt;op&lt;/code&gt; that expresses the set of operations performed by the kernel of the algorithm.</source>
          <target state="translated">알고리즘의 커널에 의해 수행되는 일련의 &lt;code&gt;op&lt;/code&gt; 을 나타내는 작은 함수 op 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="597661e73835c59aca5441f10be576b8d382a273" translate="yes" xml:space="preserve">
          <source>Write a text representation of a value &lt;code&gt;x&lt;/code&gt; to the output stream &lt;code&gt;io&lt;/code&gt;. New types &lt;code&gt;T&lt;/code&gt; should overload &lt;code&gt;show(io::IO, x::T)&lt;/code&gt;. The representation used by &lt;code&gt;show&lt;/code&gt; generally includes Julia-specific formatting and type information, and should be parseable Julia code when possible.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값의 텍스트 표현을 출력 스트림 &lt;code&gt;io&lt;/code&gt; 에 씁니다 . 새로운 유형 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;show(io::IO, x::T)&lt;/code&gt; 오버로드해야합니다 . &lt;code&gt;show&lt;/code&gt; 에서 사용하는 표현 은 일반적으로 Julia 특정 형식 및 유형 정보를 포함하며 가능한 경우 Julia 코드를 구문 분석 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="873f569b5d6881c314f347be4557cdf37101715d" translate="yes" xml:space="preserve">
          <source>Write an arbitrary value to a stream in an opaque format, such that it can be read back by &lt;a href=&quot;#Serialization.deserialize&quot;&gt;&lt;code&gt;deserialize&lt;/code&gt;&lt;/a&gt;. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. &lt;code&gt;Ptr&lt;/code&gt; values are serialized as all-zero bit patterns (&lt;code&gt;NULL&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;#Serialization.deserialize&quot;&gt; &lt;code&gt;deserialize&lt;/code&gt; 로&lt;/a&gt; 다시 읽을 수 있도록 불투명 한 형식으로 임의의 값을 스트림에 씁니다 . 리드 백 값은 원본과 최대한 동일합니다. 일반적으로이 프로세스는 다른 버전의 Julia 또는 다른 시스템 이미지를 가진 Julia 인스턴스가 읽고 쓰는 경우에는 작동하지 않습니다. &lt;code&gt;Ptr&lt;/code&gt; 값은 모두 0 비트 패턴 ( &lt;code&gt;NULL&lt;/code&gt; ) 으로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cc631af387b0b65068ed32b69656c5387524ad1" translate="yes" xml:space="preserve">
          <source>Write an identifying header to the specified serializer. The header consists of 8 bytes as follows:</source>
          <target state="translated">지정된 시리얼 라이저에 식별 헤더를 작성합니다. 헤더는 다음과 같이 8 바이트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2c562290cfa3ebc3ed60533e7ccb58cb5506dbdf" translate="yes" xml:space="preserve">
          <source>Write an informative text representation of a value to the current output stream. New types should overload &lt;code&gt;show(io::IO, x)&lt;/code&gt; where the first argument is a stream. The representation used by &lt;code&gt;show&lt;/code&gt; generally includes Julia-specific formatting and type information.</source>
          <target state="translated">값의 유익한 텍스트 표현을 현재 출력 스트림에 씁니다. 새 유형은 첫 번째 인수가 스트림 인 &lt;code&gt;show(io::IO, x)&lt;/code&gt; 오버로드해야 합니다. &lt;code&gt;show&lt;/code&gt; 에서 사용하는 표현 에는 일반적으로 Julia 관련 형식 및 유형 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cb2bbf69c8aaaca3e8ea4477fb12294ca0669ad1" translate="yes" xml:space="preserve">
          <source>Write functions with argument ordering similar to Julia Base</source>
          <target state="translated">Julia Base와 비슷한 인수 순서로 함수 작성</target>
        </trans-unit>
        <trans-unit id="70a026cb8be32b7a74394524302a74d531860e33" translate="yes" xml:space="preserve">
          <source>Write functions, not just scripts</source>
          <target state="translated">스크립트뿐만 아니라 함수 작성</target>
        </trans-unit>
        <trans-unit id="8434f9d9d28666de4a462912e8e0e307e3e65b92" translate="yes" xml:space="preserve">
          <source>Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; to write a text representation (with an encoding that may depend upon &lt;code&gt;io&lt;/code&gt;).</source>
          <target state="translated">주어진 I / O 스트림 또는 파일에 값의 표준 이진 표현을 씁니다. 스트림에 쓴 바이트 수를 리턴합니다. 텍스트 표현을 작성하려면 &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 ( &lt;code&gt;io&lt;/code&gt; 에 의존 할 수있는 인코딩 사용 ).</target>
        </trans-unit>
        <trans-unit id="f504d192f85e8f747b7e397b2f6ba281860922fa" translate="yes" xml:space="preserve">
          <source>Write to &lt;code&gt;io&lt;/code&gt; (or to the default output stream &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;io&lt;/code&gt; is not given) a canonical (un-decorated) text representation. The representation used by &lt;code&gt;print&lt;/code&gt; includes minimal formatting and tries to avoid Julia-specific details.</source>
          <target state="translated">표준 (장식되지 않은) 텍스트 표현 으로 &lt;code&gt;io&lt;/code&gt; (또는 &lt;code&gt;io&lt;/code&gt; 가 제공되지 않은 경우 기본 출력 스트림 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; )에&lt;/a&gt; 씁니다 . &lt;code&gt;print&lt;/code&gt; 사용되는 표현 에는 최소한의 서식이 포함되며 Julia 관련 세부 정보를 피하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e16e34e27c72e59ec455f0c0f1a3f2115cd3b225" translate="yes" xml:space="preserve">
          <source>Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.</source>
          <target state="translated">많은 작은 정의를 함수로 작성하면 컴파일러가 가장 적합한 코드를 직접 호출하거나 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e8aec81b31e6aaa5b50b350018faabd22de4c7" translate="yes" xml:space="preserve">
          <source>Writing binary broadcasting rules</source>
          <target state="translated">이진 브로드 캐스트 규칙 작성</target>
        </trans-unit>
        <trans-unit id="97f498290acca274115f78b5edf4bcb344821f93" translate="yes" xml:space="preserve">
          <source>Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia's compiler works.</source>
          <target state="translated">최상위 수준에서 일련의 단계로 코드를 작성하면 문제를 빨리 해결할 수 있지만 가능한 빨리 프로그램을 함수로 분할해야합니다. 기능은 더 재사용 가능하고 테스트 가능하며 수행되는 단계와 입력 및 출력이 무엇인지 명확하게합니다. 또한 Julia의 컴파일러 작동 방식으로 인해 함수 내부의 코드가 최상위 코드보다 훨씬 빠르게 실행되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a484186f293d2862395499a0c5b61beb757d7d54" translate="yes" xml:space="preserve">
          <source>Writing log events to a file</source>
          <target state="translated">파일에 로그 이벤트 쓰기</target>
        </trans-unit>
        <trans-unit id="25744db574969e117a90b833b80467c34acec98d" translate="yes" xml:space="preserve">
          <source>Xor</source>
          <target state="translated">Xor</target>
        </trans-unit>
        <trans-unit id="f198e585f80c9955a647226ad90798053ac6ecf5" translate="yes" xml:space="preserve">
          <source>Yellow Heart</source>
          <target state="translated">옐로우 하트</target>
        </trans-unit>
        <trans-unit id="50b776c9e160796bdb426c1605a23b1af335b715" translate="yes" xml:space="preserve">
          <source>Yen Sign</source>
          <target state="translated">엔 기호</target>
        </trans-unit>
        <trans-unit id="2f53cab7d3c0dbe4951a04ff57f49550638bd4c8" translate="yes" xml:space="preserve">
          <source>You annotate the function declaration with the &lt;code&gt;@generated&lt;/code&gt; macro. This adds some information to the AST that lets the compiler know that this is a generated function.</source>
          <target state="translated">&lt;code&gt;@generated&lt;/code&gt; 매크로를 사용하여 함수 선언에 주석을 달 수 있습니다. 이렇게하면 AST에 일부 정보가 추가되어 컴파일러는 이것이 생성 된 함수임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc8c1c8f5f11957d60869604a47850f7992e1dc" translate="yes" xml:space="preserve">
          <source>You are entirely responsible for ensuring that your program is data-race free, and nothing promised here can be assumed if you do not observe that requirement. The observed results may be highly unintuitive.</source>
          <target state="translated">귀하는 귀하의 프로그램이 데이터 경합이 없는지 확인하는 데 전적으로 책임이 있으며, 해당 요구 사항을 준수하지 않으면 여기서 약속 된 어떤 것도 가정 할 수 없습니다. 관찰 된 결과는 매우 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa58379787fb3328d4b2c9b156cc9d4992b0523" translate="yes" xml:space="preserve">
          <source>You can access the field values of a composite object using the traditional &lt;code&gt;foo.bar&lt;/code&gt; notation:</source>
          <target state="translated">전통적인 &lt;code&gt;foo.bar&lt;/code&gt; 표기법을 사용하여 복합 객체의 필드 값에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e327a40a7bf29c2f099c651d3dd2926aa5926b6" translate="yes" xml:space="preserve">
          <source>You can add information about the push refspecs in two other ways: by setting an option in the repository's &lt;code&gt;GitConfig&lt;/code&gt; (with &lt;code&gt;push.default&lt;/code&gt; as the key) or by calling &lt;a href=&quot;#LibGit2.add_push!&quot;&gt;&lt;code&gt;add_push!&lt;/code&gt;&lt;/a&gt;. Otherwise you will need to explicitly specify a push refspec in the call to &lt;code&gt;push&lt;/code&gt; for it to have any effect, like so: &lt;code&gt;LibGit2.push(repo, refspecs=[&quot;refs/heads/master&quot;])&lt;/code&gt;.</source>
          <target state="translated">리포지토리의 &lt;code&gt;GitConfig&lt;/code&gt; 에서 옵션을 설정하거나 ( &lt;code&gt;push.default&lt;/code&gt; 를 키로 사용) &lt;a href=&quot;#LibGit2.add_push!&quot;&gt; &lt;code&gt;add_push!&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면 &lt;code&gt;push&lt;/code&gt; &lt;code&gt;LibGit2.push(repo, refspecs=[&quot;refs/heads/master&quot;])&lt;/code&gt; 을 명시 적으로 지정하여 푸시 리퍼 스펙을 지정하여 푸시하십시오 . LibGit2.push (repo, refspecs = [ &quot;refs / heads / master&quot;]) .</target>
        </trans-unit>
        <trans-unit id="059c37e831f26b52c6dfe5728025ecfe92438e23" translate="yes" xml:space="preserve">
          <source>You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of &lt;code&gt;repl&lt;/code&gt; in the &lt;code&gt;customize_colors&lt;/code&gt; function above (respectively, &lt;code&gt;help_color&lt;/code&gt;, &lt;code&gt;shell_color&lt;/code&gt;, &lt;code&gt;input_color&lt;/code&gt;, and &lt;code&gt;answer_color&lt;/code&gt;). For the latter two, be sure that the &lt;code&gt;envcolors&lt;/code&gt; field is also set to false.</source>
          <target state="translated">위 의 &lt;code&gt;customize_colors&lt;/code&gt; 함수 (각각 &lt;code&gt;help_color&lt;/code&gt; , &lt;code&gt;shell_color&lt;/code&gt; , &lt;code&gt;input_color&lt;/code&gt; 및 &lt;code&gt;answer_color&lt;/code&gt; ) 에서 적절한 &lt;code&gt;repl&lt;/code&gt; 필드를 설정하여 도움말 및 쉘 프롬프트 및 입력 및 응답 텍스트의 색상을 변경할 수도 있습니다 . 후자의 경우 &lt;code&gt;envcolors&lt;/code&gt; 필드도 false로 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1638c4f5d9428b7a66ce134be7d9554e824e2b6d" translate="yes" xml:space="preserve">
          <source>You can also combine dot operations with function chaining using &lt;code&gt;|&amp;gt;&lt;/code&gt;, as in this example:</source>
          <target state="translated">이 예에서와 같이 &lt;code&gt;|&amp;gt;&lt;/code&gt; 를 사용하여 도트 연산과 함수 체인을 결합 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28db7f89bc085e06b706e35f0b6ac4581558f0a0" translate="yes" xml:space="preserve">
          <source>You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file:</source>
          <target state="translated">적절한 환경 변수를 설정하여 경고 및 정보 메시지를 렌더링하는 데 사용되는 색상을 사용자 정의 할 수도 있습니다. 예를 들어, 오류, 경고 및 정보 메시지를 각각 마젠타, 노랑 및 녹청으로 렌더링하려면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 파일에 다음을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48369480265e913602939792e933438854e1fd21" translate="yes" xml:space="preserve">
          <source>You can also extract a substring using range indexing:</source>
          <target state="translated">범위 색인을 사용하여 하위 문자열을 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9632f04ced8b0d99e58399a64d3197172994959f" translate="yes" xml:space="preserve">
          <source>You can also find the numerical precedence for any given operator via the built-in function &lt;code&gt;Base.operator_precedence&lt;/code&gt;, where higher numbers take precedence:</source>
          <target state="translated">내장 함수 &lt;code&gt;Base.operator_precedence&lt;/code&gt; 를 통해 지정된 연산자의 숫자 우선 순위를 찾을 수도 있습니다 . 여기서 높은 숫자가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bde95e81a4bd07b2fd0aae2c5489099dc8851cd2" translate="yes" xml:space="preserve">
          <source>You can also return multiple values using the &lt;code&gt;return&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 키워드를 사용하여 여러 값을 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8889f871b5013b5f51fc950bfb5b2804adab0a7a" translate="yes" xml:space="preserve">
          <source>You can also return multiple values via an explicit usage of the &lt;code&gt;return&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 키워드를 명시 적으로 사용하여 여러 값을 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd8ba1a0017da212fde89c54b0a00968d72dd8a6" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; string macro. This macro creates the &lt;code&gt;DateFormat&lt;/code&gt; object once when the macro is expanded and uses the same &lt;code&gt;DateFormat&lt;/code&gt; object even if a code snippet is run multiple times.</source>
          <target state="translated">&lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; 문자열 매크로를 사용할 수도 있습니다 . 이 매크로 는 매크로가 확장 될 때 &lt;code&gt;DateFormat&lt;/code&gt; 객체를 한 번 만들고 코드 조각이 여러 번 실행되는 경우에도 동일한 &lt;code&gt;DateFormat&lt;/code&gt; 객체를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="45337346e75761db7f47d57b0a0f2d57b557f00b" translate="yes" xml:space="preserve">
          <source>You can call:</source>
          <target state="translated">전화해도됩니다:</target>
        </trans-unit>
        <trans-unit id="54416a772feee0c2a6abe4feb994c4ff0911f0e5" translate="yes" xml:space="preserve">
          <source>You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let's introduce a parametric type, &lt;code&gt;Val{x}&lt;/code&gt;, and a constructor &lt;code&gt;Val(x) = Val{x}()&lt;/code&gt;, which serves as a customary way to exploit this technique for cases where you don't need a more elaborate hierarchy.</source>
          <target state="translated">값을 매개 변수로 사용하는 사용자 정의 유형을 작성하고이를 사용하여 사용자 정의 유형의 디스패치를 ​​제어 할 수 있습니다. 이 아이디어를 설명하기 위해 매개 변수 유형 &lt;code&gt;Val{x}&lt;/code&gt; 및 생성자 &lt;code&gt;Val(x) = Val{x}()&lt;/code&gt; 을 소개합니다.이 유형은 더 정교한 계층이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67ebafe0bb709b3a3bcb8a53db51ff716e9c8b39" translate="yes" xml:space="preserve">
          <source>You can do better by declaring the type of &lt;code&gt;a&lt;/code&gt;. Here, we are focused on the case where &lt;code&gt;a&lt;/code&gt; might be any one of several types, in which case the natural solution is to use parameters. For example:</source>
          <target state="translated">당신의 유형 선언에 의해 더 잘 할 수 &lt;code&gt;a&lt;/code&gt; . 여기, 우리는 사건에 초점을 맞추고있다 &lt;code&gt;a&lt;/code&gt; 자연 솔루션이 매개 변수를 사용하는 경우에 여러 종류 중 어느 하나 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4caa428e60cf326fe234bff9118f30463ecc984" translate="yes" xml:space="preserve">
          <source>You can do comparisons and a limited amount of arithmetic with &lt;code&gt;Char&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 값을 사용 하여 비교 및 ​​제한된 양의 산술을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="213f6d383b8d704a68bbc7048875f6a46e354817" translate="yes" xml:space="preserve">
          <source>You can easily convert a &lt;code&gt;Char&lt;/code&gt; to its integer value, i.e. code point:</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 를 정수 값, 즉 코드 포인트 로 쉽게 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdf51e2713eacda965f72b9f170006ad6c4671fa" translate="yes" xml:space="preserve">
          <source>You can easily experiment in the same way with the associativity and precedence of various combinations of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 의 다양한 조합의 연관성 및 우선 순위를 사용하여 동일한 방식으로 쉽게 실험 할 수 있습니다. 연산자.</target>
        </trans-unit>
        <trans-unit id="297dd6d932ba3b9c077f90d9ae3e638bbc832d7a" translate="yes" xml:space="preserve">
          <source>You can easily see which methods exist for a function by entering the function object itself in an interactive session:</source>
          <target state="translated">대화 형 세션에서 함수 객체 자체를 입력하여 함수에 어떤 메소드가 있는지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9fc4e50c51febb70c8179dd7d3ee0d25d50a3e" translate="yes" xml:space="preserve">
          <source>You can easily sort in reverse order as well:</source>
          <target state="translated">역순으로 쉽게 정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae353c04e06eae0932d681939a80ca4e623d3dfb" translate="yes" xml:space="preserve">
          <source>You can extract the following info from a &lt;code&gt;RegexMatch&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;RegexMatch&lt;/code&gt; 객체 에서 다음 정보를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="597d6825a8e66617cfc25b05c246ad4b54f231b3" translate="yes" xml:space="preserve">
          <source>You can get a near approximation of a &lt;code&gt;union&lt;/code&gt; if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</source>
          <target state="translated">당신은의 가까운 근사치 얻을 수있는 &lt;code&gt;union&lt;/code&gt; 당신이 알고있는 경우, 사전, (잠재적으로 패딩 포함) 최대의 크기를해야합니다 필드. 필드를 Julia로 변환 할 때 Julia 필드를 해당 유형으로 만 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="b8f2354d5e866a3fef788cc2117a49177430a807" translate="yes" xml:space="preserve">
          <source>You can get an approximation of a &lt;code&gt;union&lt;/code&gt; if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</source>
          <target state="translated">가장 큰 크기 (잠재적으로 패딩 포함)를 가질 필드를 선험적으로 알고있는 경우 &lt;code&gt;union&lt;/code&gt; 의 근사치를 얻을 수 있습니다 . 필드를 Julia로 변환 할 때 Julia 필드를 해당 유형으로 만 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="4fb63027077e534b4bd1d351e2d6f0cd13eea49c" translate="yes" xml:space="preserve">
          <source>You can go in the other direction using the &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; constructor. The &lt;a href=&quot;#SparseArrays.issparse&quot;&gt;&lt;code&gt;issparse&lt;/code&gt;&lt;/a&gt; function can be used to query if a matrix is sparse.</source>
          <target state="translated">&lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 다른 방향으로 갈 수 있습니다 . &lt;a href=&quot;#SparseArrays.issparse&quot;&gt; &lt;code&gt;issparse&lt;/code&gt; 의&lt;/a&gt; 매트릭스가 부족한 경우에 기능 조회하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d3ef6d04d5b1e72dbe8e2e762201178f4553d19d" translate="yes" xml:space="preserve">
          <source>You can input any Unicode character in single quotes using &lt;code&gt;\u&lt;/code&gt; followed by up to four hexadecimal digits or &lt;code&gt;\U&lt;/code&gt; followed by up to eight hexadecimal digits (the longest valid value only requires six):</source>
          <target state="translated">&lt;code&gt;\u&lt;/code&gt; 뒤에 최대 4 개의 16 진수를 사용하거나 &lt;code&gt;\U&lt;/code&gt; 뒤에 최대 8 개의 16 진수를 사용하여 작은 따옴표로 유니 코드 문자를 입력 할 수 있습니다 (가장 긴 유효한 값은 6 개만 필요함).</target>
        </trans-unit>
        <trans-unit id="a1c3136389e599fc278301c384c96c386084d25f" translate="yes" xml:space="preserve">
          <source>You can iteratively modify the code in MyPkg in your editor and re-run the tests with &lt;code&gt;include(&quot;runtests.jl&quot;)&lt;/code&gt;. You generally should not need to restart your Julia session to see the changes take effect (subject to a few limitations, see https://timholy.github.io/Revise.jl/stable/limitations/).</source>
          <target state="translated">편집기에서 MyPkg의 코드를 반복적으로 수정하고 &lt;code&gt;include(&quot;runtests.jl&quot;)&lt;/code&gt; 로 테스트를 다시 실행할 수 있습니다. 변경 사항이 적용되는 것을보기 위해 일반적으로 Julia 세션을 다시 시작할 필요는 없습니다 (몇 가지 제한 사항이 있으므로 https://timholy.github.io/Revise.jl/stable/limitations/ 참조).</target>
        </trans-unit>
        <trans-unit id="01f1a9e77e1dab9c53cf6e54b009fbdd40624504" translate="yes" xml:space="preserve">
          <source>You can lexicographically compare strings using the standard comparison operators:</source>
          <target state="translated">표준 비교 연산자를 사용하여 문자열을 사전 식으로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d7484742424e03da7e9cb1b2e9ef8dd1d529ad" translate="yes" xml:space="preserve">
          <source>You can lock your writes with a &lt;code&gt;ReentrantLock&lt;/code&gt; like this:</source>
          <target state="translated">다음과 같이 &lt;code&gt;ReentrantLock&lt;/code&gt; 으로 쓰기를 잠글 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02da3de9b76002a19afdbabf9d38695160c6abb0" translate="yes" xml:space="preserve">
          <source>You can modify the behavior of regular expressions by some combination of the flags &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; after the closing double quote mark. These flags have the same meaning as they do in Perl, as explained in this excerpt from the &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;perlre manpage&lt;/a&gt;:</source>
          <target state="translated">닫는 큰 따옴표 뒤에 플래그 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 를 조합하여 정규식의 동작을 수정할 수 있습니다 . 이 플래그는 &lt;a href=&quot;http://perldoc.perl.org/perlre.html#Modifiers&quot;&gt;perlre 맨 페이지&lt;/a&gt; 에서 발췌 한 설명과 같이 Perl에서와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d563bb2419fe2e35302ac639bca513eb737c8ce0" translate="yes" xml:space="preserve">
          <source>You can obtain and configure the relevant parameters this way:</source>
          <target state="translated">다음과 같은 방법으로 관련 매개 변수를 확보하고 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af014600f23a52a7d3b0ccd1627fdcdcfa305bf7" translate="yes" xml:space="preserve">
          <source>You can pass incomplete objects to other functions from inner constructors to delegate their completion:</source>
          <target state="translated">불완전한 객체를 내부 생성자에서 다른 함수로 전달하여 완성을 위임 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e5cc0663f902336ac80075e9866fb096894bf72" translate="yes" xml:space="preserve">
          <source>You can perform all the standard arithmetic operations with complex numbers:</source>
          <target state="translated">복소수로 모든 표준 산술 연산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a61677ccdaa8b5a6b40eab46850f79a11022e3" translate="yes" xml:space="preserve">
          <source>You can perform arithmetic and other operations with &lt;a href=&quot;../../base/base/index#end&quot;&gt;&lt;code&gt;end&lt;/code&gt;&lt;/a&gt;, just like a normal value:</source>
          <target state="translated">일반 값과 ​​마찬가지로 &lt;a href=&quot;../../base/base/index#end&quot;&gt; &lt;code&gt;end&lt;/code&gt; 로&lt;/a&gt; 산술 및 기타 연산을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bde51aa2974cdddcc791ab18ecf0b461a4a8f184" translate="yes" xml:space="preserve">
          <source>You can search for the index of a particular character using the &lt;code&gt;findfirst&lt;/code&gt; and &lt;code&gt;findlast&lt;/code&gt; functions:</source>
          <target state="translated">&lt;code&gt;findfirst&lt;/code&gt; 및 &lt;code&gt;findlast&lt;/code&gt; 함수를 사용하여 특정 문자의 색인을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29f0c4ef93a19d9ea8874bfdfe84ad585d18096d" translate="yes" xml:space="preserve">
          <source>You can start the search for a character at a given offset by using the functions &lt;code&gt;findnext&lt;/code&gt; and &lt;code&gt;findprev&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;findnext&lt;/code&gt; 및 &lt;code&gt;findprev&lt;/code&gt; 함수를 사용하여 주어진 오프셋에서 문자 검색을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="983a4e9a838b7c272bd7ce9841a71699f2f5f979" translate="yes" xml:space="preserve">
          <source>You can then run &lt;code&gt;make -C doc doctest=true&lt;/code&gt; to run all the doctests in the Julia Manual and API documentation, which will ensure that your example works.</source>
          <target state="translated">그런 다음 &lt;code&gt;make -C doc doctest=true&lt;/code&gt; 를 실행하여 Julia Manual 및 API 설명서에서 모든 doctest를 실행하면 예제가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4814e310e21d1ccb6a91f06788291ec84faf6155" translate="yes" xml:space="preserve">
          <source>You can think of a &lt;code&gt;Task&lt;/code&gt; as a handle to a unit of computational work to be performed. It has a create-start-run-finish lifecycle. Tasks are created by calling the &lt;code&gt;Task&lt;/code&gt; constructor on a 0-argument function to run, or using the &lt;a href=&quot;../../base/parallel/index#Base.@task&quot;&gt;&lt;code&gt;@task&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; 는 수행 할 계산 작업 단위에 대한 핸들로 생각할 수 있습니다 . create-start-run-finish 수명주기가 있습니다. 작업은 실행할 0 인수 함수 에서 &lt;code&gt;Task&lt;/code&gt; 생성자를 호출 하거나 &lt;a href=&quot;../../base/parallel/index#Base.@task&quot;&gt; &lt;code&gt;@task&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="01884818eeefcdc6c4866d1d82554c6cbab8b4af" translate="yes" xml:space="preserve">
          <source>You can type the composition operator at the REPL and suitably-configured editors using &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; 사용하여 REPL 및 적절하게 구성된 편집기에서 작성 연산자를 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="671bb6ef5bfe755f6871d64b9b0adf82ab7550a3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; function to check if a substring is found within a string:</source>
          <target state="translated">&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; 함수 함수를 사용하여 문자열 내에 하위 문자열이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1889689569d33c12e5c7365a4498ac549f0fa6b4" translate="yes" xml:space="preserve">
          <source>You can write multiple values with the same &lt;code&gt;write&lt;/code&gt; call. i.e. the following are equivalent:</source>
          <target state="translated">동일한 &lt;code&gt;write&lt;/code&gt; 호출로 여러 값을 쓸 수 있습니다 . 즉, 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0a69b3c3747d382e37e0c069a0643adbff045b55" translate="yes" xml:space="preserve">
          <source>You could also add a zero-argument &lt;code&gt;Foo&lt;/code&gt; constructor method that supplies default values for both of the &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; fields:</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 필드 모두에 기본값을 제공하는 인수가없는 &lt;code&gt;Foo&lt;/code&gt; 생성자 메소드를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="748f1f789b535f659a4d83b60f43c95c4a72b9c3" translate="yes" xml:space="preserve">
          <source>You do not have to make any modifications to your code to take timing measurements (in contrast to the alternative &lt;a href=&quot;https://github.com/timholy/IProfile.jl&quot;&gt;instrumenting profiler&lt;/a&gt;).</source>
          <target state="translated">다른 &lt;a href=&quot;https://github.com/timholy/IProfile.jl&quot;&gt;계측기 프로파일 러&lt;/a&gt; 와 달리 타이밍 측정을 위해 코드를 수정할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="515bee5879927c5023670ad7c5704ff12c433189" translate="yes" xml:space="preserve">
          <source>You do not have to make any modifications to your code to take timing measurements.</source>
          <target state="translated">타이밍 측정을 위해 코드를 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6c719aa5a89e4e9d767112f0eb9eee4442b7ddf" translate="yes" xml:space="preserve">
          <source>You do not need to write binary &lt;code&gt;BroadcastStyle&lt;/code&gt; rules unless you want to establish precedence for two or more non-&lt;code&gt;DefaultArrayStyle&lt;/code&gt; types.</source>
          <target state="translated">둘 이상의 비 &lt;code&gt;DefaultArrayStyle&lt;/code&gt; 유형에 우선 순위를 설정하지 않는 한 이진 &lt;code&gt;BroadcastStyle&lt;/code&gt; 규칙 을 작성할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="98dd2765494f1835f8de8c7c9befa3251d03285e" translate="yes" xml:space="preserve">
          <source>You generally want to use &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;:&lt;/code&gt; for testing types, not &lt;code&gt;==&lt;/code&gt;. Checking types for exact equality typically only makes sense when comparing to a known concrete type (e.g. &lt;code&gt;T == Float64&lt;/code&gt;), or if you &lt;em&gt;really, really&lt;/em&gt; know what you're doing.</source>
          <target state="translated">일반적으로 &lt;code&gt;==&lt;/code&gt; 가 아닌 유형을 테스트 하기 위해 &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&amp;lt;:&lt;/code&gt; 을 사용하려고합니다 . 유형이 정확한지 확인하는 것은 일반적으로 알려진 콘크리트 유형 (예 : &lt;code&gt;T == Float64&lt;/code&gt; ) 과 비교할 때 또는 &lt;em&gt;실제로&lt;/em&gt; 수행중인 작업을 알고있는 경우에만 의미가 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14812b00d271b7b5f0ec10d0a35574667eaad1aa" translate="yes" xml:space="preserve">
          <source>You have homogenous lists of the same type of &lt;code&gt;Car&lt;/code&gt; to process, so that you can store them all in an &lt;code&gt;Array{Car{:Honda,:Accord},N}&lt;/code&gt;.</source>
          <target state="translated">처리 할 &lt;code&gt;Car&lt;/code&gt; 와 동일한 유형의 동종 목록이 있으므로 &lt;code&gt;Array{Car{:Honda,:Accord},N}&lt;/code&gt; 모두 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54079830b99730e8b5b0840e83f7e3f6b6fec1f2" translate="yes" xml:space="preserve">
          <source>You may define your own exceptions in the following way:</source>
          <target state="translated">다음과 같은 방법으로 자신의 예외를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a4f74f7e0a2a762b20575e87e4a9f8afac9ea7" translate="yes" xml:space="preserve">
          <source>You may find a list of field names using the &lt;a href=&quot;../../base/base/index#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 필드 이름 목록을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="321a16cad9d72ad66163bddd6d822e5c0fba0fe3" translate="yes" xml:space="preserve">
          <source>You may find that simple benchmarks of linear algebra building blocks like</source>
          <target state="translated">선형 대수 구성 요소의 간단한 벤치 마크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b69612dc47009ecd3936a82f044980d92ef4b91" translate="yes" xml:space="preserve">
          <source>You may have noticed the &lt;code&gt;(v1.1)&lt;/code&gt; in the REPL prompt. This lets us know &lt;code&gt;v1.1&lt;/code&gt; is the &lt;strong&gt;active environment&lt;/strong&gt;. The active environment is the environment that will be modified by Pkg commands such as &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">REPL 프롬프트에서 &lt;code&gt;(v1.1)&lt;/code&gt; 을 확인했을 수 있습니다 . 이것은 &lt;code&gt;v1.1&lt;/code&gt; 이 &lt;strong&gt;활성 환경&lt;/strong&gt; 임을 알려줍니다 . 활성 환경은 &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;rm&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 와 같은 Pkg 명령으로 수정 될 환경입니다 .</target>
        </trans-unit>
        <trans-unit id="94a57765c350792774cf5846e707a163457704ae" translate="yes" xml:space="preserve">
          <source>You may need to &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; and reopen the &lt;code&gt;GitRemote&lt;/code&gt; in question after updating its push refspecs in order for the change to take effect and for calls to &lt;a href=&quot;#LibGit2.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; to work.</source>
          <target state="translated">당신은해야 할 수도 &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 과 다시 &lt;code&gt;GitRemote&lt;/code&gt; 를 변경 내용을 적용하려면 그것의 푸시 refspecs를 업데이트 한 후 질문과 통화하기 위해 &lt;a href=&quot;#LibGit2.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 작업에.</target>
        </trans-unit>
        <trans-unit id="4229325c98965b7733293cd84ce7238967b6b57b" translate="yes" xml:space="preserve">
          <source>You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing your module. For example, external state is not preserved. To accommodate this, explicitly separate any initialization steps that must occur at &lt;em&gt;runtime&lt;/em&gt; from steps that can occur at &lt;em&gt;compile time&lt;/em&gt;. For this purpose, Julia allows you to define an &lt;code&gt;__init__()&lt;/code&gt; function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (&lt;code&gt;--output-*&lt;/code&gt;). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be &amp;ndash; or even should not be &amp;ndash; captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (&lt;code&gt;--output-incremental=yes&lt;/code&gt;), but not if it is being loaded into a full-compilation process.</source>
          <target state="translated">모듈을 작성할 때주의가 필요할 수있는 증분 공유 라이브러리 작성에 고유 한 특정 동작을 알고 있어야합니다. 예를 들어 외부 상태는 유지되지 않습니다. 이를 수용하려면 &lt;em&gt;런타임시&lt;/em&gt; 발생해야하는 초기화 단계를 &lt;em&gt;컴파일시&lt;/em&gt; 발생할 수있는 단계 와 명시 적으로 분리하십시오 . 이를 위해 Julia는 런타임시 발생해야하는 초기화 단계를 실행 하는 &lt;code&gt;__init__()&lt;/code&gt; 함수를 모듈 에 정의 할 수 있습니다 . 이 함수는 컴파일 중에 호출되지 않습니다 ( &lt;code&gt;--output-*&lt;/code&gt; ). 실제로 코드 수명 동안 정확히 한 번만 실행된다고 가정 할 수 있습니다. 물론 필요한 경우 수동으로 호출 할 수도 있지만 기본값은이 기능이 로컬 컴퓨터의 컴퓨팅 상태를 처리한다고 가정하는 것입니다.이 상태는 컴파일 된 이미지에서 캡처 할 필요가 없거나 캡처되어서는 안됩니다. 모듈이 증분 컴파일 ( &lt;code&gt;--output-incremental=yes&lt;/code&gt; ) 에로드되는지 여부를 포함하여 모듈이 프로세스에로드 된 후 호출 되지만 전체 컴파일 프로세스에로드되는 경우에는 호출 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="706389eb857acac994f27512bc713e1991d6229c" translate="yes" xml:space="preserve">
          <source>You may note that in non-interactive contexts the hard and soft scope behaviors are identical except that a warning is printed when an implicitly local variable (i.e. not declared with &lt;code&gt;local x&lt;/code&gt;) shadows a global. In interactive contexts, the rules follow a more complex heuristic for the sake of convenience. This is covered in depth in examples that follow.</source>
          <target state="translated">비대화 형 컨텍스트에서 하드 및 소프트 범위 동작은 암시 적 로컬 변수 (즉, &lt;code&gt;local x&lt;/code&gt; 선언되지 않음 )가 전역을 음영 처리 할 때 경고가 인쇄된다는 점을 제외하면 동일합니다 . 대화 형 컨텍스트에서 규칙은 편의를 위해 더 복잡한 휴리스틱을 따릅니다. 이 내용은 다음 예제에서 자세히 다룹니다.</target>
        </trans-unit>
        <trans-unit id="44e65af1a6b8116a7d6a8ac10e4cee832d255f64" translate="yes" xml:space="preserve">
          <source>You may notice that in the example above the first stack frame points at line 4, where &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; is called, rather than line 2, where &lt;em&gt;bad_function&lt;/em&gt; is called, and &lt;code&gt;bad_function&lt;/code&gt;'s frame is missing entirely. This is understandable, given that &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; is called from the context of the &lt;em&gt;catch&lt;/em&gt;. While in this example it's fairly easy to find the actual source of the error, in complex cases tracking down the source of the error becomes nontrivial.</source>
          <target state="translated">위의 예에서 첫 번째 스택 프레임이 4 번째 줄을 가리킬 수 있습니다. 여기에서 2 번째 줄 이 아니라 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 여기서 &lt;em&gt;bad_function&lt;/em&gt; 이 호출되고 &lt;code&gt;bad_function&lt;/code&gt; 의 프레임이 완전히 누락됩니다. &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;catch&lt;/em&gt; 컨텍스트에서 호출 된다는 점을 고려하면 이해할 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 예에서는 오류의 실제 원인을 찾기가 매우 쉽지만 복잡한 경우 오류의 원인을 추적하는 것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d19cfc137102f94cf8a3e39329b48533e78155c7" translate="yes" xml:space="preserve">
          <source>You may notice that in the example above the first stack frame points points at line 4, where &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; is called, rather than line 2, where &lt;em&gt;bad_function&lt;/em&gt; is called, and &lt;code&gt;bad_function&lt;/code&gt;'s frame is missing entirely. This is understandable, given that &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; is called from the context of the &lt;em&gt;catch&lt;/em&gt;. While in this example it's fairly easy to find the actual source of the error, in complex cases tracking down the source of the error becomes nontrivial.</source>
          <target state="translated">위의 예에서 첫 번째 스택 프레임은 라인 4 가 아니라 라인 2가 아니라 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 가 호출 되는 라인 4, 라인 &lt;em&gt;bad_function&lt;/em&gt; 이 호출되고 &lt;code&gt;bad_function&lt;/code&gt; 프레임이 완전히 누락 된 라인 4를 가리 킵니다 . 이것은 주어진, 이해할 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 의 컨텍스트에서 호출 &lt;em&gt;캐치&lt;/em&gt; . 이 예제에서는 실제 오류의 원인을 찾는 것이 상당히 쉽지만 복잡한 경우 오류의 원인을 추적하는 것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e4c7a6ccbcbfd095ffe6620497bc770c0f876bf" translate="yes" xml:space="preserve">
          <source>You may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base. The current LTS version of Julia is versioned according to SemVer as v1.0.x; this branch will continue to recieve bugfixes until a new LTS branch is chosen, at which point the v1.0.x series will no longer recieved regular bug fixes and all but the most conservative users will be advised to upgrade to the new LTS version series. As a package developer, you may prefer to develop for the LTS version, to maximize the number of users who can use your package. As per SemVer, code written for v1.0 will continue to work for all future LTS and Stable versions. In general, even if targetting the LTS, one can develop and run code in the latest Stable version, to take advantage of the improved performance; so long as one avoids using new features (such as added library functions or new methods).</source>
          <target state="translated">매우 안정적인 코드 기반을 찾고 있다면 Julia의 LTS (Long Term Support) 버전을 선호 할 수 있습니다. Julia의 현재 LTS 버전은 SemVer에 따라 v1.0.x로 버전이 지정됩니다. 이 분기는 새로운 LTS 분기가 선택 될 때까지 계속해서 버그 수정을받을 것입니다.이 시점에서 v1.0.x 시리즈는 더 이상 정기적 인 버그 수정을받지 않으며 가장 보수적 인 사용자를 제외한 모든 사용자는 새로운 LTS 버전 시리즈로 업그레이드하는 것이 좋습니다. . 패키지 개발자는 패키지를 사용할 수있는 사용자 수를 최대화하기 위해 LTS 버전 용으로 개발하는 것을 선호 할 수 있습니다. SemVer에 따라 v1.0 용으로 작성된 코드는 향후 모든 LTS 및 Stable 버전에서 계속 작동합니다. 일반적으로 LTS를 대상으로하더라도 향상된 성능을 활용하기 위해 최신 Stable 버전에서 코드를 개발하고 실행할 수 있습니다.새로운 기능 (예 : 추가 된 라이브러리 함수 또는 새로운 메서드)을 사용하지 않는 한.</target>
        </trans-unit>
        <trans-unit id="b76981634f75e5c11344317b4a4c06f7a789abab" translate="yes" xml:space="preserve">
          <source>You may prefer the beta version of Julia if you don't mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.</source>
          <target state="translated">최신 버그 수정 및 변경 사항보다 약간 뒤지는 않지만 약간 더 빠른 변경 비율이 더 매력적이라면 Julia 베타 버전을 선호 할 수 있습니다. 또한이 바이너리는 게시되기 전에 테스트되어 제대로 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0460fd971f5acf59556e02a1302869132f958a11" translate="yes" xml:space="preserve">
          <source>You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work.</source>
          <target state="translated">언어에 대한 최신 업데이트를 이용하려는 경우 Julia의 야간 버전을 선호 할 수 있으며 오늘날 사용 가능한 버전이 실제로 작동하지 않는 경우에는 신경 쓰지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="36eadd3f0fe870572a5ea4a451370de0fa57fc6f" translate="yes" xml:space="preserve">
          <source>You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work. As the name implies, releases to the nightly version are made roughly every night (depending on build infrastructure stability). In general nightly released are fairly safe to use&amp;mdash;your code will not catch on fire. However, they may be occasional regressions and or issues that will not be found until more thorough pre-release testing. You may wish to test against the nightly version to ensure that such regressions that affect your use case are caught before a release is made.</source>
          <target state="translated">언어에 대한 최신 업데이트를 활용하고 싶다면 Julia의 야간 버전을 선호 할 수 있으며, 오늘날 사용 가능한 버전이 실제로 작동하지 않는 경우에도 신경 쓰지 마십시오. 이름에서 알 수 있듯이 야간 버전에 대한 릴리스는 대략 매일 밤 (빌드 인프라 안정성에 따라 다름)으로 이루어집니다. 일반적으로 야간 릴리스는 사용하기에 상당히 안전합니다. 코드에 불이 붙지 않습니다. 그러나 이러한 현상은 간헐적 인 회귀이거나보다 철저한 시험판 테스트를 거치기 전까지는 발견되지 않는 문제 일 수 있습니다. 릴리스가 이루어지기 전에 유스 케이스에 영향을 미치는 회귀가 포착되는지 확인하기 위해 야간 버전에 대해 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b13c20826345514f072a53cfc2e614b5a875ac2" translate="yes" xml:space="preserve">
          <source>You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.</source>
          <target state="translated">안정적인 코드 기반을 찾고 있다면 릴리스 릴리스의 Julia를 선호 할 수 있습니다. 릴리스는 일반적으로 6 개월마다 발생하므로 코드 작성을위한 안정적인 플랫폼을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8603fb2a99f46c98dd43f967c904e067e7d516b" translate="yes" xml:space="preserve">
          <source>You may want to try this for yourself to see how it works.</source>
          <target state="translated">작동 방식을 확인하기 위해 직접 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71eb424f61bc73bf2ac2a0d6b8ff2e2e2a212793" translate="yes" xml:space="preserve">
          <source>You might expect the second example to behave the same way, but in fact the &lt;code&gt;return&lt;/code&gt; there only breaks out of the &lt;em&gt;inner&lt;/em&gt; function (inside the &lt;code&gt;do&lt;/code&gt; block) and gives a value back to &lt;code&gt;map&lt;/code&gt;. &lt;code&gt;test2([5,6,7])&lt;/code&gt; then returns &lt;code&gt;[5,12,7]&lt;/code&gt;.</source>
          <target state="translated">두 번째 예제가 동일한 방식으로 작동 할 것으로 예상 할 수 있지만 실제로 &lt;code&gt;return&lt;/code&gt; 은 &lt;em&gt;내부&lt;/em&gt; 함수 ( &lt;code&gt;do&lt;/code&gt; 블록 내부) 만 벗어나 &lt;code&gt;map&lt;/code&gt; 에 값을 제공합니다 . &lt;code&gt;test2([5,6,7])&lt;/code&gt; 은 &lt;code&gt;[5,12,7]&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8eed329d4cf528497edb705ccaa35a89edfb626e" translate="yes" xml:space="preserve">
          <source>You might want broadcasting to preserve the &lt;code&gt;char&lt;/code&gt; &quot;metadata.&quot; First we define</source>
          <target state="translated">방송에서 &lt;code&gt;char&lt;/code&gt; &quot;메타 데이터&quot; 를 유지하려고 할 수 있습니다 . 먼저 우리는 정의</target>
        </trans-unit>
        <trans-unit id="01b172c9b8083a729ce8b5e678095c5e53087128" translate="yes" xml:space="preserve">
          <source>You require CPU-intensive processing on each &lt;code&gt;Car&lt;/code&gt;, and it becomes vastly more efficient if you know the &lt;code&gt;Make&lt;/code&gt; and &lt;code&gt;Model&lt;/code&gt; at compile time and the total number of different &lt;code&gt;Make&lt;/code&gt; or &lt;code&gt;Model&lt;/code&gt; that will be used is not too large.</source>
          <target state="translated">각 &lt;code&gt;Car&lt;/code&gt; 에서 CPU를 많이 사용하는 처리가 필요 하며 컴파일 타임에 &lt;code&gt;Make&lt;/code&gt; and &lt;code&gt;Model&lt;/code&gt; 을 알고 있고 사용할 다른 &lt;code&gt;Make&lt;/code&gt; 또는 &lt;code&gt;Model&lt;/code&gt; 의 총 수가 너무 크지 않으면 훨씬 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="cae8f1e8790fd84f821e9cc3eb20a504f4b0534d" translate="yes" xml:space="preserve">
          <source>You should see a list of available commands along with short descriptions. You can ask for more detailed help by specifying a command:</source>
          <target state="translated">간단한 설명과 함께 사용 가능한 명령 목록이 표시됩니다. 명령을 지정하여보다 자세한 도움말을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb798888844269226c94086ebe8f3c7329fdec21" translate="yes" xml:space="preserve">
          <source>Your code must be available on any process that runs it. For example, type the following into the Julia prompt:</source>
          <target state="translated">코드는 코드를 실행하는 모든 프로세스에서 사용할 수 있어야합니다. 예를 들어 Julia 프롬프트에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="57bf44abb3ac22f4d7fc3ab61624aaa4d1a927ab" translate="yes" xml:space="preserve">
          <source>Z Notation Bag Membership</source>
          <target state="translated">Z 표기법 가방 멤버십</target>
        </trans-unit>
        <trans-unit id="74e2105c5405ac305b485ea5d5fbf6c4fbc31a2b" translate="yes" xml:space="preserve">
          <source>Z Notation Schema Composition</source>
          <target state="translated">Z 표기법 스키마 구성</target>
        </trans-unit>
        <trans-unit id="561efdcba775fe560525de0b80ee246bac982519" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays are arrays of the form &lt;code&gt;Array{T,0}&lt;/code&gt;. They behave similar to scalars, but there are important differences. They deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a zero-dimensional array:</source>
          <target state="translated">0 차원 배열은 &lt;code&gt;Array{T,0}&lt;/code&gt; 형식의 배열 입니다. 스칼라와 유사하게 작동하지만 중요한 차이점이 있습니다. 그것들은 배열의 일반적인 정의를 감안할 때 논리적으로 이해되는 특별한 경우이기 때문에 특별한 언급이 필요하지만 처음에는 약간 직관적이지 않을 수 있습니다. 다음 줄은 0 차원 배열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="59e8673a8540d0e191f3f9440981811c0b28178f" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays are the &quot;point&quot; to vector's &quot;line&quot; and matrix's &quot;plane&quot;. Just as a line has no area (but still represents a set of things), a point has no length or any dimensions at all (but still represents a thing).</source>
          <target state="translated">0 차원 배열은 벡터의 &quot;선&quot;과 행렬의 &quot;평면&quot;에 대한 &quot;점&quot;입니다. 선에 면적이 없지만 여전히 일련의 사물을 나타내는 것처럼 점에는 길이나 치수가 전혀 없습니다 (그러나 여전히 사물을 나타냄).</target>
        </trans-unit>
        <trans-unit id="ec2113ef23ab629753d460306640202ef42c12ef" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays don't natively have any dimensions into which you index &amp;ndash; they&amp;rsquo;re just &lt;code&gt;A[]&lt;/code&gt;. We can apply the same &quot;trailing one&quot; rule for them as for all other array dimensionalities, so you can indeed index them as &lt;code&gt;A[1]&lt;/code&gt;, &lt;code&gt;A[1,1]&lt;/code&gt;, etc.</source>
          <target state="translated">0 차원 배열은 기본적으로 색인을 생성하는 차원이 없으며 단지 &lt;code&gt;A[]&lt;/code&gt; 입니다. 다른 모든 배열 차원과 동일한 &quot;후행 하나&quot;규칙을 적용 할 수 있으므로 실제로 &lt;code&gt;A[1]&lt;/code&gt; , &lt;code&gt;A[1,1]&lt;/code&gt; 등 으로 색인을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df74de535f1392e594ef5eeab6807c001df2566f" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays don't natively have any dimensions into which you index &amp;ndash; they&amp;rsquo;re just &lt;code&gt;A[]&lt;/code&gt;. We can apply the same &quot;trailing one&quot; rule for them as for all other array dimensionalities, so you can indeed index them as &lt;code&gt;A[1]&lt;/code&gt;, &lt;code&gt;A[1,1]&lt;/code&gt;, etc; see &lt;a href=&quot;../arrays/index#Omitted-and-extra-indices&quot;&gt;Omitted and extra indices&lt;/a&gt;.</source>
          <target state="translated">0 차원 배열은 기본적으로 인덱싱 할 차원이 없습니다 . &lt;code&gt;A[]&lt;/code&gt; 일뿐 입니다. 다른 모든 배열 차원에 대해 동일한 &quot;후행 1&quot;규칙을 적용 할 수 있으므로 실제로 &lt;code&gt;A[1]&lt;/code&gt; , &lt;code&gt;A[1,1]&lt;/code&gt; 등 으로 인덱싱 할 수 있습니다 . &lt;a href=&quot;../arrays/index#Omitted-and-extra-indices&quot;&gt;생략 및 추가 인덱스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b26e283b9285c59cfe6ee345d840ff32a08052c" translate="yes" xml:space="preserve">
          <source>\()</source>
          <target state="translated">\()</target>
        </trans-unit>
        <trans-unit id="8a50e72bbe47fcaef6adcffd656ebe2d54953f91" translate="yes" xml:space="preserve">
          <source>\0/3</source>
          <target state="translated">\0/3</target>
        </trans-unit>
        <trans-unit id="e9405388bd3e66f4f3f6c02d971bd28ccdccaa7e" translate="yes" xml:space="preserve">
          <source>\1/</source>
          <target state="translated">\1/</target>
        </trans-unit>
        <trans-unit id="f027585d51760b016dc9a17eb250918d79fe1656" translate="yes" xml:space="preserve">
          <source>\1/10</source>
          <target state="translated">\1/10</target>
        </trans-unit>
        <trans-unit id="6dc80eb8fd394a5094b26fce0a091081f171ade1" translate="yes" xml:space="preserve">
          <source>\1/2</source>
          <target state="translated">\1/2</target>
        </trans-unit>
        <trans-unit id="db0136fc9351c47aeacf89b3b63fad4f778dec79" translate="yes" xml:space="preserve">
          <source>\1/3</source>
          <target state="translated">\1/3</target>
        </trans-unit>
        <trans-unit id="4a2d541db798ac9dc012eee3270125d49f7e9e1c" translate="yes" xml:space="preserve">
          <source>\1/4</source>
          <target state="translated">\1/4</target>
        </trans-unit>
        <trans-unit id="a87f8d74f6a7e153af3fff916bf7c031788cc412" translate="yes" xml:space="preserve">
          <source>\1/5</source>
          <target state="translated">\1/5</target>
        </trans-unit>
        <trans-unit id="29a3bc136b5ab0d2bc309b5bb5e1735798643266" translate="yes" xml:space="preserve">
          <source>\1/6</source>
          <target state="translated">\1/6</target>
        </trans-unit>
        <trans-unit id="f06587711719aaef8bc36199cb763a5ca8ed5b90" translate="yes" xml:space="preserve">
          <source>\1/7</source>
          <target state="translated">\1/7</target>
        </trans-unit>
        <trans-unit id="be708686ec340bec50c515ce07649bcbd7b6d749" translate="yes" xml:space="preserve">
          <source>\1/8</source>
          <target state="translated">\1/8</target>
        </trans-unit>
        <trans-unit id="11557e1ac7de358cb1bffae8b8e0c31658c73a34" translate="yes" xml:space="preserve">
          <source>\1/9</source>
          <target state="translated">\1/9</target>
        </trans-unit>
        <trans-unit id="db66670627d1ece8d004dba27bd31bbae103a152" translate="yes" xml:space="preserve">
          <source>\2/3</source>
          <target state="translated">\2/3</target>
        </trans-unit>
        <trans-unit id="594a1082136db6d496ec37c3f2e137ee2b1c2304" translate="yes" xml:space="preserve">
          <source>\2/5</source>
          <target state="translated">\2/5</target>
        </trans-unit>
        <trans-unit id="5e8bc9e533252d09ee6c73afce5da2a72488888e" translate="yes" xml:space="preserve">
          <source>\3/4</source>
          <target state="translated">\3/4</target>
        </trans-unit>
        <trans-unit id="a50e9368238ca82ac4489585387d46083f64cae7" translate="yes" xml:space="preserve">
          <source>\3/5</source>
          <target state="translated">\3/5</target>
        </trans-unit>
        <trans-unit id="9c3d1367082b439189bfb85f04cc1ffae71ef96e" translate="yes" xml:space="preserve">
          <source>\3/8</source>
          <target state="translated">\3/8</target>
        </trans-unit>
        <trans-unit id="47f8a536df17c50df7c82a92959bbd0c66172c07" translate="yes" xml:space="preserve">
          <source>\4/5</source>
          <target state="translated">\4/5</target>
        </trans-unit>
        <trans-unit id="3184741692c487b7052b7005a5dcc990d42ec28b" translate="yes" xml:space="preserve">
          <source>\5/6</source>
          <target state="translated">\5/6</target>
        </trans-unit>
        <trans-unit id="a3e2d08140d306e29d0dd5197b4d63c56018fd06" translate="yes" xml:space="preserve">
          <source>\5/8</source>
          <target state="translated">\5/8</target>
        </trans-unit>
        <trans-unit id="031fd711b0ff2a77753aebd9b5a3ae56bd990afc" translate="yes" xml:space="preserve">
          <source>\7/8</source>
          <target state="translated">\7/8</target>
        </trans-unit>
        <trans-unit id="c0fe4a8468a676d3af614df303545f8085623ffa" translate="yes" xml:space="preserve">
          <source>\:+1:</source>
          <target state="translated">\:+1:</target>
        </trans-unit>
        <trans-unit id="1f409cc5566bb159aa3eb9a43ba7b112abdf8f37" translate="yes" xml:space="preserve">
          <source>\:-1:</source>
          <target state="translated">\:-1:</target>
        </trans-unit>
        <trans-unit id="37a8827d047ba1424645fac130045eb7ce513b10" translate="yes" xml:space="preserve">
          <source>\:100:</source>
          <target state="translated">\:100:</target>
        </trans-unit>
        <trans-unit id="7a8b4088e301737914602cb64abd1cef18d926f6" translate="yes" xml:space="preserve">
          <source>\:1234:</source>
          <target state="translated">\:1234:</target>
        </trans-unit>
        <trans-unit id="91888e08cbedf6bf8862c5b65163ce478af06bf9" translate="yes" xml:space="preserve">
          <source>\:8ball:</source>
          <target state="translated">\:8ball:</target>
        </trans-unit>
        <trans-unit id="893c710f650dbaf6e52a56817de430adc9320c23" translate="yes" xml:space="preserve">
          <source>\:a:</source>
          <target state="translated">\:a:</target>
        </trans-unit>
        <trans-unit id="f853d000810dd26060e2696126e145030271c584" translate="yes" xml:space="preserve">
          <source>\:ab:</source>
          <target state="translated">\:ab:</target>
        </trans-unit>
        <trans-unit id="f37a396dfa857265e3ecd90835458cdae5a6eefb" translate="yes" xml:space="preserve">
          <source>\:abc:</source>
          <target state="translated">\:abc:</target>
        </trans-unit>
        <trans-unit id="06fcc1368ba729df7b1dd45bddcbe5bfcfed511d" translate="yes" xml:space="preserve">
          <source>\:abcd:</source>
          <target state="translated">\:abcd:</target>
        </trans-unit>
        <trans-unit id="897745edd2f35f117be4ac8e8927668c74a4bf23" translate="yes" xml:space="preserve">
          <source>\:accept:</source>
          <target state="translated">\:accept:</target>
        </trans-unit>
        <trans-unit id="a7c6f0363b57fa69b1404b3a64f70c46b68a96e1" translate="yes" xml:space="preserve">
          <source>\:aerial_tramway:</source>
          <target state="translated">\:aerial_tramway:</target>
        </trans-unit>
        <trans-unit id="d6e282198ea6fc6d14a452f54562f9039fe5c632" translate="yes" xml:space="preserve">
          <source>\:airplane:</source>
          <target state="translated">\:airplane:</target>
        </trans-unit>
        <trans-unit id="4742d4fcf02027d38977477be1ea129391060c7b" translate="yes" xml:space="preserve">
          <source>\:alarm_clock:</source>
          <target state="translated">\:alarm_clock:</target>
        </trans-unit>
        <trans-unit id="b9106d98c9e6f148dea1bc5f0d0e2637fecc4f01" translate="yes" xml:space="preserve">
          <source>\:alien:</source>
          <target state="translated">\:alien:</target>
        </trans-unit>
        <trans-unit id="465acd14d1b878bbb5bc7cbb6f6379d1a64b42a3" translate="yes" xml:space="preserve">
          <source>\:ambulance:</source>
          <target state="translated">\:ambulance:</target>
        </trans-unit>
        <trans-unit id="ecc81069e165094bd92ebdeb19f4ff11e1e1fea0" translate="yes" xml:space="preserve">
          <source>\:anchor:</source>
          <target state="translated">\:anchor:</target>
        </trans-unit>
        <trans-unit id="a17c0ed6923a46686bb723b71bfb598646966379" translate="yes" xml:space="preserve">
          <source>\:angel:</source>
          <target state="translated">\:angel:</target>
        </trans-unit>
        <trans-unit id="91e16b740dc786abef7dd112d243ef891aa232d9" translate="yes" xml:space="preserve">
          <source>\:anger:</source>
          <target state="translated">\:anger:</target>
        </trans-unit>
        <trans-unit id="ba42be644a23dad29f524e1209c856fe9e7d20cf" translate="yes" xml:space="preserve">
          <source>\:angry:</source>
          <target state="translated">\:angry:</target>
        </trans-unit>
        <trans-unit id="42e2cd5dfd596ab5db1e024b35e386e2e2b49a82" translate="yes" xml:space="preserve">
          <source>\:anguished:</source>
          <target state="translated">\:anguished:</target>
        </trans-unit>
        <trans-unit id="c09512e256aad16fa471ab20fb66ce91a87e0858" translate="yes" xml:space="preserve">
          <source>\:ant:</source>
          <target state="translated">\:ant:</target>
        </trans-unit>
        <trans-unit id="b8e989820739e8bed885c3ee73871f53e1047f8f" translate="yes" xml:space="preserve">
          <source>\:apple:</source>
          <target state="translated">\:apple:</target>
        </trans-unit>
        <trans-unit id="5d4aff4545ea93d5ab7617ae5a6c4410f9530721" translate="yes" xml:space="preserve">
          <source>\:arrow_double_down:</source>
          <target state="translated">\:arrow_double_down:</target>
        </trans-unit>
        <trans-unit id="2c6437a87ec16150d50ed43e011df1617a29b699" translate="yes" xml:space="preserve">
          <source>\:arrow_double_up:</source>
          <target state="translated">\:arrow_double_up:</target>
        </trans-unit>
        <trans-unit id="622fb3188cbc77dcf0406cdbbe59d7d320d1a821" translate="yes" xml:space="preserve">
          <source>\:arrow_down:</source>
          <target state="translated">\:arrow_down:</target>
        </trans-unit>
        <trans-unit id="7ccd6e47506c0edfc91a361deba3694c4abbd2ab" translate="yes" xml:space="preserve">
          <source>\:arrow_down_small:</source>
          <target state="translated">\:arrow_down_small:</target>
        </trans-unit>
        <trans-unit id="58427091281cc58a0870d92247d87bba1d4f45c5" translate="yes" xml:space="preserve">
          <source>\:arrow_heading_down:</source>
          <target state="translated">\:arrow_heading_down:</target>
        </trans-unit>
        <trans-unit id="db4af64358e09cbbfd78a9c0e07b5649b2969f6a" translate="yes" xml:space="preserve">
          <source>\:arrow_heading_up:</source>
          <target state="translated">\:arrow_heading_up:</target>
        </trans-unit>
        <trans-unit id="6cd09f162aabf62506bcf47da1e2dd795fba514f" translate="yes" xml:space="preserve">
          <source>\:arrow_left:</source>
          <target state="translated">\:arrow_left:</target>
        </trans-unit>
        <trans-unit id="029efa19ad65054f78041ef0ab1986caa55f0a8f" translate="yes" xml:space="preserve">
          <source>\:arrow_right:</source>
          <target state="translated">\:arrow_right:</target>
        </trans-unit>
        <trans-unit id="a50aee4371aed8411b12b2c86a3d096f0add1f0a" translate="yes" xml:space="preserve">
          <source>\:arrow_up:</source>
          <target state="translated">\:arrow_up:</target>
        </trans-unit>
        <trans-unit id="ff525911412bcb2907803ac06c75d82c5b4ff597" translate="yes" xml:space="preserve">
          <source>\:arrow_up_small:</source>
          <target state="translated">\:arrow_up_small:</target>
        </trans-unit>
        <trans-unit id="d87aac00aa0e4b5361e85865a1c5a805ab6ae7d3" translate="yes" xml:space="preserve">
          <source>\:arrows_clockwise:</source>
          <target state="translated">\:arrows_clockwise:</target>
        </trans-unit>
        <trans-unit id="31ab82fa664be73335a42c002b198e517a8ff562" translate="yes" xml:space="preserve">
          <source>\:arrows_counterclockwise:</source>
          <target state="translated">\:arrows_counterclockwise:</target>
        </trans-unit>
        <trans-unit id="64f7bf6d53f6e32ea11bfd7f83b4d7a3154a23a4" translate="yes" xml:space="preserve">
          <source>\:art:</source>
          <target state="translated">\:art:</target>
        </trans-unit>
        <trans-unit id="01023fa1e472f00ebed742f18e78bc70de91f29a" translate="yes" xml:space="preserve">
          <source>\:articulated_lorry:</source>
          <target state="translated">\:articulated_lorry:</target>
        </trans-unit>
        <trans-unit id="aba4fc03b3ec950610688f5d8e84c122ff714e51" translate="yes" xml:space="preserve">
          <source>\:astonished:</source>
          <target state="translated">\:astonished:</target>
        </trans-unit>
        <trans-unit id="d10aae7a1f58e9e6ea766b23562c710dd1ecfd7d" translate="yes" xml:space="preserve">
          <source>\:athletic_shoe:</source>
          <target state="translated">\:athletic_shoe:</target>
        </trans-unit>
        <trans-unit id="7a8f6ac1fb6de318ab2f30c0cb0cff3986b935f1" translate="yes" xml:space="preserve">
          <source>\:atm:</source>
          <target state="translated">\:atm:</target>
        </trans-unit>
        <trans-unit id="e4102b75192b3b25b4b2401036e2755477e569df" translate="yes" xml:space="preserve">
          <source>\:b:</source>
          <target state="translated">\:b:</target>
        </trans-unit>
        <trans-unit id="ab5ac627fdff2cb25d697a44a12d85e6db922218" translate="yes" xml:space="preserve">
          <source>\:baby:</source>
          <target state="translated">\:baby:</target>
        </trans-unit>
        <trans-unit id="9d4fb89796a2777f46797e2c6ab68afa1427226d" translate="yes" xml:space="preserve">
          <source>\:baby_bottle:</source>
          <target state="translated">\:baby_bottle:</target>
        </trans-unit>
        <trans-unit id="d010ec78859c2ca99e025b26cea21b14e33a7900" translate="yes" xml:space="preserve">
          <source>\:baby_chick:</source>
          <target state="translated">\:baby_chick:</target>
        </trans-unit>
        <trans-unit id="09df6582e602512b14ab929b38515ca66e42be79" translate="yes" xml:space="preserve">
          <source>\:baby_symbol:</source>
          <target state="translated">\:baby_symbol:</target>
        </trans-unit>
        <trans-unit id="5df21ba646a8c814d5235aada423405fa74cb50f" translate="yes" xml:space="preserve">
          <source>\:back:</source>
          <target state="translated">\:back:</target>
        </trans-unit>
        <trans-unit id="3d2798f10aac399b833e56efe30b640f72a3556d" translate="yes" xml:space="preserve">
          <source>\:baggage_claim:</source>
          <target state="translated">\:baggage_claim:</target>
        </trans-unit>
        <trans-unit id="cecc206e4d80c1b3e2ab48aa76d5bfc31ff6d0ee" translate="yes" xml:space="preserve">
          <source>\:balloon:</source>
          <target state="translated">\:balloon:</target>
        </trans-unit>
        <trans-unit id="4199cd1e321f3ab1be6522ea6a0b675de67786cd" translate="yes" xml:space="preserve">
          <source>\:ballot_box_with_check:</source>
          <target state="translated">\:ballot_box_with_check:</target>
        </trans-unit>
        <trans-unit id="5d0b3797c7ba31baf2e0749c5d4a4f8ba56bf535" translate="yes" xml:space="preserve">
          <source>\:bamboo:</source>
          <target state="translated">\:bamboo:</target>
        </trans-unit>
        <trans-unit id="d11a6161828f2006e3d052b1adaaa17f606ee989" translate="yes" xml:space="preserve">
          <source>\:banana:</source>
          <target state="translated">\:banana:</target>
        </trans-unit>
        <trans-unit id="d9e595a27732957689ec9b34c1bb3d5dee7fe43c" translate="yes" xml:space="preserve">
          <source>\:bangbang:</source>
          <target state="translated">\:bangbang:</target>
        </trans-unit>
        <trans-unit id="3bb03c94a50b8f9a2294ee0d81b367aa2e825378" translate="yes" xml:space="preserve">
          <source>\:bank:</source>
          <target state="translated">\:bank:</target>
        </trans-unit>
        <trans-unit id="1e4410a56e42d963bfa2389e8187e2058d5a9b6f" translate="yes" xml:space="preserve">
          <source>\:bar_chart:</source>
          <target state="translated">\:bar_chart:</target>
        </trans-unit>
        <trans-unit id="42b83acdd61aec84b4023d5d1462556019f47da0" translate="yes" xml:space="preserve">
          <source>\:barber:</source>
          <target state="translated">\:barber:</target>
        </trans-unit>
        <trans-unit id="8e90d96fb37fe316a951852c3cc3adae8eff65ca" translate="yes" xml:space="preserve">
          <source>\:baseball:</source>
          <target state="translated">\:baseball:</target>
        </trans-unit>
        <trans-unit id="24fc5902a188c38e7efe5373b666a7e0ed2d17ec" translate="yes" xml:space="preserve">
          <source>\:basketball:</source>
          <target state="translated">\:basketball:</target>
        </trans-unit>
        <trans-unit id="6516bcba7024f76199acaa52f93dabe7de0c3521" translate="yes" xml:space="preserve">
          <source>\:bath:</source>
          <target state="translated">\:bath:</target>
        </trans-unit>
        <trans-unit id="d9bf42df05db447416c881c25adc3bb7e92ff193" translate="yes" xml:space="preserve">
          <source>\:bathtub:</source>
          <target state="translated">\:bathtub:</target>
        </trans-unit>
        <trans-unit id="0764d9168dc86c10755f31a62b4e1fbfff2bc957" translate="yes" xml:space="preserve">
          <source>\:battery:</source>
          <target state="translated">\:battery:</target>
        </trans-unit>
        <trans-unit id="1ae619dbbe5a156007f4353dcf0b21ee74031169" translate="yes" xml:space="preserve">
          <source>\:bear:</source>
          <target state="translated">\:bear:</target>
        </trans-unit>
        <trans-unit id="cbd2d7da879ceb97380740ad17ac3fa1d4659910" translate="yes" xml:space="preserve">
          <source>\:bee:</source>
          <target state="translated">\:bee:</target>
        </trans-unit>
        <trans-unit id="7730b8dbf405b6dc525134e6ef15bddc34b74ba0" translate="yes" xml:space="preserve">
          <source>\:beer:</source>
          <target state="translated">\:beer:</target>
        </trans-unit>
        <trans-unit id="2059778557562af988942b1d82227e4db48bd2e8" translate="yes" xml:space="preserve">
          <source>\:beers:</source>
          <target state="translated">\:beers:</target>
        </trans-unit>
        <trans-unit id="f133e91914fba621435d5708c21214b2486852b9" translate="yes" xml:space="preserve">
          <source>\:beetle:</source>
          <target state="translated">\:beetle:</target>
        </trans-unit>
        <trans-unit id="89922ca4b55877f00201f11118edae89680c7dcd" translate="yes" xml:space="preserve">
          <source>\:beginner:</source>
          <target state="translated">\:beginner:</target>
        </trans-unit>
        <trans-unit id="92fffa11964dfbcd06be0baf0273460988e09fde" translate="yes" xml:space="preserve">
          <source>\:bell:</source>
          <target state="translated">\:bell:</target>
        </trans-unit>
        <trans-unit id="4ad4176546e9a9275198c4baae37930e18a9312e" translate="yes" xml:space="preserve">
          <source>\:bento:</source>
          <target state="translated">\:bento:</target>
        </trans-unit>
        <trans-unit id="66c33ece884eb16cbee78356e2077b985aa67765" translate="yes" xml:space="preserve">
          <source>\:bicyclist:</source>
          <target state="translated">\:bicyclist:</target>
        </trans-unit>
        <trans-unit id="7b45e3c06d2f1da9e68a6af916498355b961076f" translate="yes" xml:space="preserve">
          <source>\:bike:</source>
          <target state="translated">\:bike:</target>
        </trans-unit>
        <trans-unit id="d98c194c90e64d31376a0fc97e1df1549772bddd" translate="yes" xml:space="preserve">
          <source>\:bikini:</source>
          <target state="translated">\:bikini:</target>
        </trans-unit>
        <trans-unit id="2552a9f774e659d536071d0b778cb74f12f6edda" translate="yes" xml:space="preserve">
          <source>\:bird:</source>
          <target state="translated">\:bird:</target>
        </trans-unit>
        <trans-unit id="9afad294f5e8c08185c013cb984a63a477319f59" translate="yes" xml:space="preserve">
          <source>\:birthday:</source>
          <target state="translated">\:birthday:</target>
        </trans-unit>
        <trans-unit id="c4d3a9b4eaefd3cbec5fd68111eefed1e334135d" translate="yes" xml:space="preserve">
          <source>\:black_joker:</source>
          <target state="translated">\:black_joker:</target>
        </trans-unit>
        <trans-unit id="061f3ba508039fd9d7ad248b3d1a0e18a0a8db7c" translate="yes" xml:space="preserve">
          <source>\:black_nib:</source>
          <target state="translated">\:black_nib:</target>
        </trans-unit>
        <trans-unit id="b2258ed2f37a23858af129cd56421add469b1aee" translate="yes" xml:space="preserve">
          <source>\:black_square_button:</source>
          <target state="translated">\:black_square_button:</target>
        </trans-unit>
        <trans-unit id="0c2dae2f9b957347a3e8a3d58fc66adc09070687" translate="yes" xml:space="preserve">
          <source>\:blossom:</source>
          <target state="translated">\:blossom:</target>
        </trans-unit>
        <trans-unit id="7d4a6dbd607e8908444532087e30b152a1c8175b" translate="yes" xml:space="preserve">
          <source>\:blowfish:</source>
          <target state="translated">\:blowfish:</target>
        </trans-unit>
        <trans-unit id="3490f851ecfaa4f251e4562cd19bd0803cacb00e" translate="yes" xml:space="preserve">
          <source>\:blue_book:</source>
          <target state="translated">\:blue_book:</target>
        </trans-unit>
        <trans-unit id="bb3afffd8470160efedf54a6588a88d71c1d1a7b" translate="yes" xml:space="preserve">
          <source>\:blue_car:</source>
          <target state="translated">\:blue_car:</target>
        </trans-unit>
        <trans-unit id="25d1442dd04cdca1e685558156eaa54c74bbc879" translate="yes" xml:space="preserve">
          <source>\:blue_heart:</source>
          <target state="translated">\:blue_heart:</target>
        </trans-unit>
        <trans-unit id="82a906b1778e8b0418d9af79c9c483d630420308" translate="yes" xml:space="preserve">
          <source>\:blush:</source>
          <target state="translated">\:blush:</target>
        </trans-unit>
        <trans-unit id="42d166f35790bd6389c4b44548d149a7f1fcdb85" translate="yes" xml:space="preserve">
          <source>\:boar:</source>
          <target state="translated">\:boar:</target>
        </trans-unit>
        <trans-unit id="2b19e6b34cfbdb3124bc8d0240a31d6dd4b062c5" translate="yes" xml:space="preserve">
          <source>\:boat:</source>
          <target state="translated">\:boat:</target>
        </trans-unit>
        <trans-unit id="8590e6a1a42f2b98222f933092ccc7c6023aa363" translate="yes" xml:space="preserve">
          <source>\:bomb:</source>
          <target state="translated">\:bomb:</target>
        </trans-unit>
        <trans-unit id="970d8d3a4fdd5aa9227f9f128f9dea9b092d5b5f" translate="yes" xml:space="preserve">
          <source>\:book:</source>
          <target state="translated">\:book:</target>
        </trans-unit>
        <trans-unit id="a173ff6b6b32a37b87ecca0c64d3a836d68eb516" translate="yes" xml:space="preserve">
          <source>\:bookmark:</source>
          <target state="translated">\:bookmark:</target>
        </trans-unit>
        <trans-unit id="3d519573a0662853bf92a77281e282c0a7e13d70" translate="yes" xml:space="preserve">
          <source>\:bookmark_tabs:</source>
          <target state="translated">\:bookmark_tabs:</target>
        </trans-unit>
        <trans-unit id="62d05f3ed561f3cb7114a826730ffc4258546dd0" translate="yes" xml:space="preserve">
          <source>\:books:</source>
          <target state="translated">\:books:</target>
        </trans-unit>
        <trans-unit id="ad3d774cdc66ee390a39fe571f75485ab4665914" translate="yes" xml:space="preserve">
          <source>\:boom:</source>
          <target state="translated">\:boom:</target>
        </trans-unit>
        <trans-unit id="3879514154f077b60d19362abb7c4e91ea7dc591" translate="yes" xml:space="preserve">
          <source>\:boot:</source>
          <target state="translated">\:boot:</target>
        </trans-unit>
        <trans-unit id="91204e4f6276832e4a953854b072ed696505e25f" translate="yes" xml:space="preserve">
          <source>\:bouquet:</source>
          <target state="translated">\:bouquet:</target>
        </trans-unit>
        <trans-unit id="c8be62d34f03816a417065a229daeb5da3cae06d" translate="yes" xml:space="preserve">
          <source>\:bow:</source>
          <target state="translated">\:bow:</target>
        </trans-unit>
        <trans-unit id="6263825346f295aa99461b59676a511a0252b64b" translate="yes" xml:space="preserve">
          <source>\:bowling:</source>
          <target state="translated">\:bowling:</target>
        </trans-unit>
        <trans-unit id="8bbccc68bff7d5dfb245a413b43fbcf32519f2a8" translate="yes" xml:space="preserve">
          <source>\:boy:</source>
          <target state="translated">\:boy:</target>
        </trans-unit>
        <trans-unit id="272e3d887cd2efd548e12a2a195d5445bcc337c9" translate="yes" xml:space="preserve">
          <source>\:bread:</source>
          <target state="translated">\:bread:</target>
        </trans-unit>
        <trans-unit id="86d6ee0cf6d788a1a253bc8069c6e0782b440662" translate="yes" xml:space="preserve">
          <source>\:bride_with_veil:</source>
          <target state="translated">\:bride_with_veil:</target>
        </trans-unit>
        <trans-unit id="8977b37e2f9f78ad5fd352469ec01ebca11a72e5" translate="yes" xml:space="preserve">
          <source>\:bridge_at_night:</source>
          <target state="translated">\:bridge_at_night:</target>
        </trans-unit>
        <trans-unit id="b69c7466c99448b76af9196fa98455462dd997f4" translate="yes" xml:space="preserve">
          <source>\:briefcase:</source>
          <target state="translated">\:briefcase:</target>
        </trans-unit>
        <trans-unit id="1d4aef8e2d826b9d9a20a959c9e3e7c083369407" translate="yes" xml:space="preserve">
          <source>\:broken_heart:</source>
          <target state="translated">\:broken_heart:</target>
        </trans-unit>
        <trans-unit id="4e08bdb51eef2fdf8195b46b4b8a64a4d5523568" translate="yes" xml:space="preserve">
          <source>\:bug:</source>
          <target state="translated">\:bug:</target>
        </trans-unit>
        <trans-unit id="e8bc29df5cca9498c76eb46ac437dd5eba730bba" translate="yes" xml:space="preserve">
          <source>\:bulb:</source>
          <target state="translated">\:bulb:</target>
        </trans-unit>
        <trans-unit id="b1493ae042dd87073780ca9a3d8bd5ca3ff7f06a" translate="yes" xml:space="preserve">
          <source>\:bullettrain_front:</source>
          <target state="translated">\:bullettrain_front:</target>
        </trans-unit>
        <trans-unit id="616a378a9b1c951df7782861ce06a97afaec4d6c" translate="yes" xml:space="preserve">
          <source>\:bullettrain_side:</source>
          <target state="translated">\:bullettrain_side:</target>
        </trans-unit>
        <trans-unit id="a4e9808a17a429c6b73c22ed790950f52801be8d" translate="yes" xml:space="preserve">
          <source>\:bus:</source>
          <target state="translated">\:bus:</target>
        </trans-unit>
        <trans-unit id="e30a14372184bbc52d5a7cd8cbbe8a4a1f10e23d" translate="yes" xml:space="preserve">
          <source>\:busstop:</source>
          <target state="translated">\:busstop:</target>
        </trans-unit>
        <trans-unit id="19b0242e1c3b01344acbdf4fc3f3902d5f522d6a" translate="yes" xml:space="preserve">
          <source>\:bust_in_silhouette:</source>
          <target state="translated">\:bust_in_silhouette:</target>
        </trans-unit>
        <trans-unit id="eaf0e2984c653e00f1740952845caa79b76beb68" translate="yes" xml:space="preserve">
          <source>\:busts_in_silhouette:</source>
          <target state="translated">\:busts_in_silhouette:</target>
        </trans-unit>
        <trans-unit id="4de9a96892ae20904c12f6fc62dcc760234f1848" translate="yes" xml:space="preserve">
          <source>\:cactus:</source>
          <target state="translated">\:cactus:</target>
        </trans-unit>
        <trans-unit id="804920ea73fb042b9e4b4637b553dab9046683bb" translate="yes" xml:space="preserve">
          <source>\:cake:</source>
          <target state="translated">\:cake:</target>
        </trans-unit>
        <trans-unit id="e14a6944c4c058ded6a348a993afcd9519291ba9" translate="yes" xml:space="preserve">
          <source>\:calendar:</source>
          <target state="translated">\:calendar:</target>
        </trans-unit>
        <trans-unit id="33c0e3dff3361506872cf8789c5ac3b5dbf741d0" translate="yes" xml:space="preserve">
          <source>\:calling:</source>
          <target state="translated">\:calling:</target>
        </trans-unit>
        <trans-unit id="ad24535a1d32a594471fc14ebe91a3c3d6352a2e" translate="yes" xml:space="preserve">
          <source>\:camel:</source>
          <target state="translated">\:camel:</target>
        </trans-unit>
        <trans-unit id="11cf7a36cba684fee5c34c419336074d9db220cd" translate="yes" xml:space="preserve">
          <source>\:camera:</source>
          <target state="translated">\:camera:</target>
        </trans-unit>
        <trans-unit id="d3a930fcdf4c81c50c6f00cf232c86b8268da70c" translate="yes" xml:space="preserve">
          <source>\:candy:</source>
          <target state="translated">\:candy:</target>
        </trans-unit>
        <trans-unit id="c69da1a9b8445e81cbc8f931c2c421769eea9d73" translate="yes" xml:space="preserve">
          <source>\:capital_abcd:</source>
          <target state="translated">\:capital_abcd:</target>
        </trans-unit>
        <trans-unit id="ba2c4dc425438792799e013ffb513e81da66428b" translate="yes" xml:space="preserve">
          <source>\:car:</source>
          <target state="translated">\:car:</target>
        </trans-unit>
        <trans-unit id="d3271c01a5dc6ec121cb9996c5caae7caacbe3f7" translate="yes" xml:space="preserve">
          <source>\:card_index:</source>
          <target state="translated">\:card_index:</target>
        </trans-unit>
        <trans-unit id="45b18e8532d195296dca46bd464c58e3dcfc9e30" translate="yes" xml:space="preserve">
          <source>\:carousel_horse:</source>
          <target state="translated">\:carousel_horse:</target>
        </trans-unit>
        <trans-unit id="76d2e8da1e4a4a21caa389964fa1bd8107b73bfe" translate="yes" xml:space="preserve">
          <source>\:cat2:</source>
          <target state="translated">\:cat2:</target>
        </trans-unit>
        <trans-unit id="5c2065b86b84530c8210be062bcba6e6a3b7e6da" translate="yes" xml:space="preserve">
          <source>\:cat:</source>
          <target state="translated">\:cat:</target>
        </trans-unit>
        <trans-unit id="f4a99889a998bf98fe4aaeb53f1422ac1a4f6ba6" translate="yes" xml:space="preserve">
          <source>\:cd:</source>
          <target state="translated">\:cd:</target>
        </trans-unit>
        <trans-unit id="b4c2bd16ee5b1f1cb87e0e5a6b3389d3e783dbca" translate="yes" xml:space="preserve">
          <source>\:chart:</source>
          <target state="translated">\:chart:</target>
        </trans-unit>
        <trans-unit id="327891e0f62b916ea70df23c9591512503f98d53" translate="yes" xml:space="preserve">
          <source>\:chart_with_downwards_trend:</source>
          <target state="translated">\:chart_with_downwards_trend:</target>
        </trans-unit>
        <trans-unit id="a0d10c9441286bdb39b2aaa95431e49fee31a184" translate="yes" xml:space="preserve">
          <source>\:chart_with_upwards_trend:</source>
          <target state="translated">\:chart_with_upwards_trend:</target>
        </trans-unit>
        <trans-unit id="ece72c3d59793710d32e596e928cee3fc1329324" translate="yes" xml:space="preserve">
          <source>\:checkered_flag:</source>
          <target state="translated">\:checkered_flag:</target>
        </trans-unit>
        <trans-unit id="efa9474e0b8f39b1881fc54935218b4331e451c1" translate="yes" xml:space="preserve">
          <source>\:cherries:</source>
          <target state="translated">\:cherries:</target>
        </trans-unit>
        <trans-unit id="3efe664d4dea4441a603d07026ae945f9d2c66cd" translate="yes" xml:space="preserve">
          <source>\:cherry_blossom:</source>
          <target state="translated">\:cherry_blossom:</target>
        </trans-unit>
        <trans-unit id="bef5b1a8fe633b79f95b2cf4cda2a806f62203a6" translate="yes" xml:space="preserve">
          <source>\:chestnut:</source>
          <target state="translated">\:chestnut:</target>
        </trans-unit>
        <trans-unit id="8ba3cfb2a11087e59f8888ab22c473d13b20e5ed" translate="yes" xml:space="preserve">
          <source>\:chicken:</source>
          <target state="translated">\:chicken:</target>
        </trans-unit>
        <trans-unit id="5afe9cd04be13fa9b25c4f3bd2e42f5b7e3f5b5a" translate="yes" xml:space="preserve">
          <source>\:children_crossing:</source>
          <target state="translated">\:children_crossing:</target>
        </trans-unit>
        <trans-unit id="d51b02aa5143f15d7da7299a05b567d5decf8435" translate="yes" xml:space="preserve">
          <source>\:chocolate_bar:</source>
          <target state="translated">\:chocolate_bar:</target>
        </trans-unit>
        <trans-unit id="ae6f17cbd30e71f8d0c3f60de4cb529343d1f0cd" translate="yes" xml:space="preserve">
          <source>\:christmas_tree:</source>
          <target state="translated">\:christmas_tree:</target>
        </trans-unit>
        <trans-unit id="00cbedbeecde20b181128a57d622eedd0b6a0eea" translate="yes" xml:space="preserve">
          <source>\:church:</source>
          <target state="translated">\:church:</target>
        </trans-unit>
        <trans-unit id="949b17cf645cb7661a6a9a7c6a28034736baa239" translate="yes" xml:space="preserve">
          <source>\:cinema:</source>
          <target state="translated">\:cinema:</target>
        </trans-unit>
        <trans-unit id="b8c8ef3216b0263eda948f7d1606fe83423d2172" translate="yes" xml:space="preserve">
          <source>\:circus_tent:</source>
          <target state="translated">\:circus_tent:</target>
        </trans-unit>
        <trans-unit id="08c6dd2e30e8213b17b6b9a30e42e79da329356e" translate="yes" xml:space="preserve">
          <source>\:city_sunrise:</source>
          <target state="translated">\:city_sunrise:</target>
        </trans-unit>
        <trans-unit id="016020845fd7997dc7231baf5939ea599a8cce35" translate="yes" xml:space="preserve">
          <source>\:city_sunset:</source>
          <target state="translated">\:city_sunset:</target>
        </trans-unit>
        <trans-unit id="0d027291920d722cf1c5b6644aebc5b553faa332" translate="yes" xml:space="preserve">
          <source>\:cl:</source>
          <target state="translated">\:cl:</target>
        </trans-unit>
        <trans-unit id="79ccfb9176f2f11147d70ca12488703e288830ce" translate="yes" xml:space="preserve">
          <source>\:clap:</source>
          <target state="translated">\:clap:</target>
        </trans-unit>
        <trans-unit id="8ac74f199fb3f9a3e2c55edd40ec4877b284555f" translate="yes" xml:space="preserve">
          <source>\:clapper:</source>
          <target state="translated">\:clapper:</target>
        </trans-unit>
        <trans-unit id="876e3689943b957c820a27121b361be1dd903fb9" translate="yes" xml:space="preserve">
          <source>\:clipboard:</source>
          <target state="translated">\:clipboard:</target>
        </trans-unit>
        <trans-unit id="744ed42b56d57b190999f12a2a43146e5f293808" translate="yes" xml:space="preserve">
          <source>\:clock1030:</source>
          <target state="translated">\:clock1030:</target>
        </trans-unit>
        <trans-unit id="435ea5e680721a3247998e4b510e392229e0119f" translate="yes" xml:space="preserve">
          <source>\:clock10:</source>
          <target state="translated">\:clock10:</target>
        </trans-unit>
        <trans-unit id="4f69d805697ab303839e31961a9c187a016bfce0" translate="yes" xml:space="preserve">
          <source>\:clock1130:</source>
          <target state="translated">\:clock1130:</target>
        </trans-unit>
        <trans-unit id="952a864afce948aaea217010227a97438ca7e276" translate="yes" xml:space="preserve">
          <source>\:clock11:</source>
          <target state="translated">\:clock11:</target>
        </trans-unit>
        <trans-unit id="ed60bee35ba5dec27cd13c56d7c882c13d69007a" translate="yes" xml:space="preserve">
          <source>\:clock1230:</source>
          <target state="translated">\:clock1230:</target>
        </trans-unit>
        <trans-unit id="cc6adfa2c6ac16a8cd9dd7f560a0f9462bffd14d" translate="yes" xml:space="preserve">
          <source>\:clock12:</source>
          <target state="translated">\:clock12:</target>
        </trans-unit>
        <trans-unit id="63441d5efb9f24676af5d8ffc2acbe4db2b78441" translate="yes" xml:space="preserve">
          <source>\:clock130:</source>
          <target state="translated">\:clock130:</target>
        </trans-unit>
        <trans-unit id="3d143639e3520cb5fb6c73d981cd76ed8d3d1cb0" translate="yes" xml:space="preserve">
          <source>\:clock1:</source>
          <target state="translated">\:clock1:</target>
        </trans-unit>
        <trans-unit id="0e2251e26f29b0845946a723411149eb25223f7c" translate="yes" xml:space="preserve">
          <source>\:clock230:</source>
          <target state="translated">\:clock230:</target>
        </trans-unit>
        <trans-unit id="959961ac716dab98a87da53cbeb025f08f65ee79" translate="yes" xml:space="preserve">
          <source>\:clock2:</source>
          <target state="translated">\:clock2:</target>
        </trans-unit>
        <trans-unit id="cd584ce39e373efaf2660e564d5f3cd7c5065d9f" translate="yes" xml:space="preserve">
          <source>\:clock330:</source>
          <target state="translated">\:clock330:</target>
        </trans-unit>
        <trans-unit id="bb8744f28b5b86ba6bc42e9d8ba327aecacea9c3" translate="yes" xml:space="preserve">
          <source>\:clock3:</source>
          <target state="translated">\:clock3:</target>
        </trans-unit>
        <trans-unit id="b9dd2bf4f00e61bf73e3ca0e6f2969c9b7ba4ac4" translate="yes" xml:space="preserve">
          <source>\:clock430:</source>
          <target state="translated">\:clock430:</target>
        </trans-unit>
        <trans-unit id="9531eb956b2a8a1bdc0dfc12f457f543d1b98fad" translate="yes" xml:space="preserve">
          <source>\:clock4:</source>
          <target state="translated">\:clock4:</target>
        </trans-unit>
        <trans-unit id="2849116ff28325b0bb3627954dcc7dec952bf8bd" translate="yes" xml:space="preserve">
          <source>\:clock530:</source>
          <target state="translated">\:clock530:</target>
        </trans-unit>
        <trans-unit id="ad8c1f67bae2a02dbb567e041b219f650047c22b" translate="yes" xml:space="preserve">
          <source>\:clock5:</source>
          <target state="translated">\:clock5:</target>
        </trans-unit>
        <trans-unit id="ae3a58504e2fa8889a89a0e053e7fc92792f5e49" translate="yes" xml:space="preserve">
          <source>\:clock630:</source>
          <target state="translated">\:clock630:</target>
        </trans-unit>
        <trans-unit id="756826e14582dca4a14bdfb211f54fec9b88ba1c" translate="yes" xml:space="preserve">
          <source>\:clock6:</source>
          <target state="translated">\:clock6:</target>
        </trans-unit>
        <trans-unit id="f442453ee237ad672534c07a866e44aadbda45e1" translate="yes" xml:space="preserve">
          <source>\:clock730:</source>
          <target state="translated">\:clock730:</target>
        </trans-unit>
        <trans-unit id="1e5700327cd19762fbabeb98183265b66afa634b" translate="yes" xml:space="preserve">
          <source>\:clock7:</source>
          <target state="translated">\:clock7:</target>
        </trans-unit>
        <trans-unit id="b19a562207fc617a4f662dbece9af64dd39ad40e" translate="yes" xml:space="preserve">
          <source>\:clock830:</source>
          <target state="translated">\:clock830:</target>
        </trans-unit>
        <trans-unit id="ddb821b6c6141af68ce6bc4ca8b32ce58108b5bd" translate="yes" xml:space="preserve">
          <source>\:clock8:</source>
          <target state="translated">\:clock8:</target>
        </trans-unit>
        <trans-unit id="367c43d3996675c66df5314d167ad24986ebeab8" translate="yes" xml:space="preserve">
          <source>\:clock930:</source>
          <target state="translated">\:clock930:</target>
        </trans-unit>
        <trans-unit id="8f9acc13159133cd5b9e08035533675276b1214b" translate="yes" xml:space="preserve">
          <source>\:clock9:</source>
          <target state="translated">\:clock9:</target>
        </trans-unit>
        <trans-unit id="e92d71a0adef480e954bf50ef24dcc60ab6c9954" translate="yes" xml:space="preserve">
          <source>\:closed_book:</source>
          <target state="translated">\:closed_book:</target>
        </trans-unit>
        <trans-unit id="e2e9409d8576371be67e1b091466e1324536b70c" translate="yes" xml:space="preserve">
          <source>\:closed_lock_with_key:</source>
          <target state="translated">\:closed_lock_with_key:</target>
        </trans-unit>
        <trans-unit id="5335cfdfcc7b6af2a496aa978d8ca253cfb4ee67" translate="yes" xml:space="preserve">
          <source>\:closed_umbrella:</source>
          <target state="translated">\:closed_umbrella:</target>
        </trans-unit>
        <trans-unit id="f2dbdb894f1aca874a85ca80b3700f9b7a5317b6" translate="yes" xml:space="preserve">
          <source>\:cloud:</source>
          <target state="translated">\:cloud:</target>
        </trans-unit>
        <trans-unit id="bb0df99b24d1bc93f0b3e26a67d7e92dbbd279bc" translate="yes" xml:space="preserve">
          <source>\:cocktail:</source>
          <target state="translated">\:cocktail:</target>
        </trans-unit>
        <trans-unit id="4a30e93f97af8e5aab2f2f2edede845d48a5f944" translate="yes" xml:space="preserve">
          <source>\:coffee:</source>
          <target state="translated">\:coffee:</target>
        </trans-unit>
        <trans-unit id="bebac1677ca37fc0b057d03f209f08f3a270a33b" translate="yes" xml:space="preserve">
          <source>\:cold_sweat:</source>
          <target state="translated">\:cold_sweat:</target>
        </trans-unit>
        <trans-unit id="7a9bab87bafe436374641127c9cd64e048f141d0" translate="yes" xml:space="preserve">
          <source>\:computer:</source>
          <target state="translated">\:computer:</target>
        </trans-unit>
        <trans-unit id="e1867aa8ddb75c011d622db24c5adbf7d9076832" translate="yes" xml:space="preserve">
          <source>\:confetti_ball:</source>
          <target state="translated">\:confetti_ball:</target>
        </trans-unit>
        <trans-unit id="62d40c2748c878a52bae54692ebd319eda8af4ca" translate="yes" xml:space="preserve">
          <source>\:confounded:</source>
          <target state="translated">\:confounded:</target>
        </trans-unit>
        <trans-unit id="2714a15411a00f9313125b6f0e86641488d1620a" translate="yes" xml:space="preserve">
          <source>\:confused:</source>
          <target state="translated">\:confused:</target>
        </trans-unit>
        <trans-unit id="5adf730be91ba2ae73f3645a5ada8a93b2c53c35" translate="yes" xml:space="preserve">
          <source>\:congratulations:</source>
          <target state="translated">\:congratulations:</target>
        </trans-unit>
        <trans-unit id="75e27a4aac67a711d8f609df96f640d36e0139d8" translate="yes" xml:space="preserve">
          <source>\:construction:</source>
          <target state="translated">\:construction:</target>
        </trans-unit>
        <trans-unit id="e6409f5ab3fac7d4270bd0258c3c576add3dcc3f" translate="yes" xml:space="preserve">
          <source>\:construction_worker:</source>
          <target state="translated">\:construction_worker:</target>
        </trans-unit>
        <trans-unit id="9794ebf7753be31f5ff1fe81ea24888d17c1a809" translate="yes" xml:space="preserve">
          <source>\:convenience_store:</source>
          <target state="translated">\:convenience_store:</target>
        </trans-unit>
        <trans-unit id="d4b4b052a2ad50f11cba76c00b6b9093d2fd9daa" translate="yes" xml:space="preserve">
          <source>\:cookie:</source>
          <target state="translated">\:cookie:</target>
        </trans-unit>
        <trans-unit id="91d39a35411cde7ab85bf802c4e9cce80eda4b87" translate="yes" xml:space="preserve">
          <source>\:cool:</source>
          <target state="translated">\:cool:</target>
        </trans-unit>
        <trans-unit id="c06bfa21ae4291ed9151914ced513cfef5ea9f9c" translate="yes" xml:space="preserve">
          <source>\:cop:</source>
          <target state="translated">\:cop:</target>
        </trans-unit>
        <trans-unit id="9244e215fb7575cc8e28f02f1845135e82da5dcf" translate="yes" xml:space="preserve">
          <source>\:corn:</source>
          <target state="translated">\:corn:</target>
        </trans-unit>
        <trans-unit id="b295d76b0beb0af143498cdc9e9328e0c78d476d" translate="yes" xml:space="preserve">
          <source>\:couple:</source>
          <target state="translated">\:couple:</target>
        </trans-unit>
        <trans-unit id="d39ef065b887bd2d13ba05d4eb95b0c32bcf7dca" translate="yes" xml:space="preserve">
          <source>\:couple_with_heart:</source>
          <target state="translated">\:couple_with_heart:</target>
        </trans-unit>
        <trans-unit id="d397db0e5a0d9686f03e8a79e4c036d6de88f361" translate="yes" xml:space="preserve">
          <source>\:couplekiss:</source>
          <target state="translated">\:couplekiss:</target>
        </trans-unit>
        <trans-unit id="0acb28380ae91098e33071cb9d102745a465f68b" translate="yes" xml:space="preserve">
          <source>\:cow2:</source>
          <target state="translated">\:cow2:</target>
        </trans-unit>
        <trans-unit id="ec88a6a443f6512ca0663e7680f021e2165590c3" translate="yes" xml:space="preserve">
          <source>\:cow:</source>
          <target state="translated">\:cow:</target>
        </trans-unit>
        <trans-unit id="767034451067943c3013a2ed1c06b729b8ae4509" translate="yes" xml:space="preserve">
          <source>\:credit_card:</source>
          <target state="translated">\:credit_card:</target>
        </trans-unit>
        <trans-unit id="e27537207e725d715b0b802682cdcfddeafcd9e3" translate="yes" xml:space="preserve">
          <source>\:crescent_moon:</source>
          <target state="translated">\:crescent_moon:</target>
        </trans-unit>
        <trans-unit id="4ac04ed7f3aac47dfb476f964da1458dea4c333a" translate="yes" xml:space="preserve">
          <source>\:crocodile:</source>
          <target state="translated">\:crocodile:</target>
        </trans-unit>
        <trans-unit id="404faf6aee7cb682e8fc697f4c2b945eaa732f54" translate="yes" xml:space="preserve">
          <source>\:crossed_flags:</source>
          <target state="translated">\:crossed_flags:</target>
        </trans-unit>
        <trans-unit id="4b1590a0aee056fad455e6f52e01369b2f3c0755" translate="yes" xml:space="preserve">
          <source>\:crown:</source>
          <target state="translated">\:crown:</target>
        </trans-unit>
        <trans-unit id="e3d209f1725877e7bf4712fdb87fbdaf861b880f" translate="yes" xml:space="preserve">
          <source>\:cry:</source>
          <target state="translated">\:cry:</target>
        </trans-unit>
        <trans-unit id="e7e3ebaa41104a5f63670e42dc09f50fe12b52c4" translate="yes" xml:space="preserve">
          <source>\:crying_cat_face:</source>
          <target state="translated">\:crying_cat_face:</target>
        </trans-unit>
        <trans-unit id="ea2205e04ff6734fab2c1d5c7348f17c96acd2a4" translate="yes" xml:space="preserve">
          <source>\:crystal_ball:</source>
          <target state="translated">\:crystal_ball:</target>
        </trans-unit>
        <trans-unit id="6298689b85b5483f6526e762d4f0409f96cdb710" translate="yes" xml:space="preserve">
          <source>\:cupid:</source>
          <target state="translated">\:cupid:</target>
        </trans-unit>
        <trans-unit id="a1bd8f679d0869072e418184d4b8f12c0444fa7b" translate="yes" xml:space="preserve">
          <source>\:curly_loop:</source>
          <target state="translated">\:curly_loop:</target>
        </trans-unit>
        <trans-unit id="f6e70f6e9e914a8d45564cb9bfe35ddf87abb048" translate="yes" xml:space="preserve">
          <source>\:currency_exchange:</source>
          <target state="translated">\:currency_exchange:</target>
        </trans-unit>
        <trans-unit id="8987fa8fdbb658e5056b34f8d7c2a06dcf7b100e" translate="yes" xml:space="preserve">
          <source>\:curry:</source>
          <target state="translated">\:curry:</target>
        </trans-unit>
        <trans-unit id="bdd61282c42f489e1387c0e31ed63a13e919783f" translate="yes" xml:space="preserve">
          <source>\:custard:</source>
          <target state="translated">\:custard:</target>
        </trans-unit>
        <trans-unit id="5b14ca39208fa1dab5bc777c3c55db01690f31eb" translate="yes" xml:space="preserve">
          <source>\:customs:</source>
          <target state="translated">\:customs:</target>
        </trans-unit>
        <trans-unit id="bb241231f43faa0f1c953a9749b424b5b6a845d8" translate="yes" xml:space="preserve">
          <source>\:cyclone:</source>
          <target state="translated">\:cyclone:</target>
        </trans-unit>
        <trans-unit id="7eefdc42e63a3a082765dfe6c2a6d87f835f0027" translate="yes" xml:space="preserve">
          <source>\:dancer:</source>
          <target state="translated">\:dancer:</target>
        </trans-unit>
        <trans-unit id="a2ffecb4690d13bb6d45329d061ce6a0ee5c605d" translate="yes" xml:space="preserve">
          <source>\:dancers:</source>
          <target state="translated">\:dancers:</target>
        </trans-unit>
        <trans-unit id="03600dc9aa3a5c8ebee1c4f7e4472404baca8eeb" translate="yes" xml:space="preserve">
          <source>\:dango:</source>
          <target state="translated">\:dango:</target>
        </trans-unit>
        <trans-unit id="4d3fb56abaebee7059f1129afa3f6c1bdffe61d9" translate="yes" xml:space="preserve">
          <source>\:dart:</source>
          <target state="translated">\:dart:</target>
        </trans-unit>
        <trans-unit id="8e6b7b0ee69309159fb8fa003d5580eeec491377" translate="yes" xml:space="preserve">
          <source>\:dash:</source>
          <target state="translated">\:dash:</target>
        </trans-unit>
        <trans-unit id="b800a41fcc4f9cf35ef55ed4b79e721c93d9ddb1" translate="yes" xml:space="preserve">
          <source>\:date:</source>
          <target state="translated">\:date:</target>
        </trans-unit>
        <trans-unit id="643b0ebfff2d297c07ff233de84ed9cb1c681693" translate="yes" xml:space="preserve">
          <source>\:deciduous_tree:</source>
          <target state="translated">\:deciduous_tree:</target>
        </trans-unit>
        <trans-unit id="b63cb7e512d56e698d0d07fd2ec6d397a34ba88d" translate="yes" xml:space="preserve">
          <source>\:department_store:</source>
          <target state="translated">\:department_store:</target>
        </trans-unit>
        <trans-unit id="9ba23c4464cd777d80899efcb17adb558780372b" translate="yes" xml:space="preserve">
          <source>\:diamond_shape_with_a_dot_inside:</source>
          <target state="translated">\:diamond_shape_with_a_dot_inside:</target>
        </trans-unit>
        <trans-unit id="6148e36f0aaba2457944b7921279e800a77318e5" translate="yes" xml:space="preserve">
          <source>\:disappointed:</source>
          <target state="translated">\:disappointed:</target>
        </trans-unit>
        <trans-unit id="1ac552d9778439cbd29ca541abaa32f62299a310" translate="yes" xml:space="preserve">
          <source>\:disappointed_relieved:</source>
          <target state="translated">\:disappointed_relieved:</target>
        </trans-unit>
        <trans-unit id="fb264230cde9cd68792fe328aad265e09dcf1a77" translate="yes" xml:space="preserve">
          <source>\:dizzy:</source>
          <target state="translated">\:dizzy:</target>
        </trans-unit>
        <trans-unit id="821f665e372508c6b8c69e5be501e485c595aead" translate="yes" xml:space="preserve">
          <source>\:dizzy_face:</source>
          <target state="translated">\:dizzy_face:</target>
        </trans-unit>
        <trans-unit id="764860e5d3d307b2aff89ef14e445a32e803beec" translate="yes" xml:space="preserve">
          <source>\:do_not_litter:</source>
          <target state="translated">\:do_not_litter:</target>
        </trans-unit>
        <trans-unit id="6f726947c6593155c8dc8ce2f3a58462b0607223" translate="yes" xml:space="preserve">
          <source>\:dog2:</source>
          <target state="translated">\:dog2:</target>
        </trans-unit>
        <trans-unit id="3374cbb709c7d6e8bf376a8f05325994110fde20" translate="yes" xml:space="preserve">
          <source>\:dog:</source>
          <target state="translated">\:dog:</target>
        </trans-unit>
        <trans-unit id="5cd2ff987dd63c867407aa215dd7653c862cbc0e" translate="yes" xml:space="preserve">
          <source>\:dollar:</source>
          <target state="translated">\:dollar:</target>
        </trans-unit>
        <trans-unit id="f3a1517b3b7668ac1095971b3172f9dcc4fff257" translate="yes" xml:space="preserve">
          <source>\:dolls:</source>
          <target state="translated">\:dolls:</target>
        </trans-unit>
        <trans-unit id="65e4bbc2ac31da523d6cf16d8730001ce34e4ecf" translate="yes" xml:space="preserve">
          <source>\:dolphin:</source>
          <target state="translated">\:dolphin:</target>
        </trans-unit>
        <trans-unit id="857282940e6936cc4a33f785b572a1aa7d9214b4" translate="yes" xml:space="preserve">
          <source>\:door:</source>
          <target state="translated">\:door:</target>
        </trans-unit>
        <trans-unit id="ae9bd8fc08335edc3ca71130aad0de4a41fa93ba" translate="yes" xml:space="preserve">
          <source>\:doughnut:</source>
          <target state="translated">\:doughnut:</target>
        </trans-unit>
        <trans-unit id="0aede83161185f05fb2b22ed1c040503b8a89dce" translate="yes" xml:space="preserve">
          <source>\:dragon:</source>
          <target state="translated">\:dragon:</target>
        </trans-unit>
        <trans-unit id="9e3ab55a027f0ee996efd59d0fbbcc012524914b" translate="yes" xml:space="preserve">
          <source>\:dragon_face:</source>
          <target state="translated">\:dragon_face:</target>
        </trans-unit>
        <trans-unit id="779b0b3212aa6cb1eb8c6270bf4ff17962dc62b3" translate="yes" xml:space="preserve">
          <source>\:dress:</source>
          <target state="translated">\:dress:</target>
        </trans-unit>
        <trans-unit id="51bc9477b437f4edfae4d5baded16fcec1173ff1" translate="yes" xml:space="preserve">
          <source>\:dromedary_camel:</source>
          <target state="translated">\:dromedary_camel:</target>
        </trans-unit>
        <trans-unit id="ddb855dfe102ba121b656ec6e6f388d30224991e" translate="yes" xml:space="preserve">
          <source>\:droplet:</source>
          <target state="translated">\:droplet:</target>
        </trans-unit>
        <trans-unit id="808e96a27b009dd71cdc5d0d17579dffad24171c" translate="yes" xml:space="preserve">
          <source>\:dvd:</source>
          <target state="translated">\:dvd:</target>
        </trans-unit>
        <trans-unit id="afc96c6cd14cfa77828de9a6695edecde86313c5" translate="yes" xml:space="preserve">
          <source>\:e-mail:</source>
          <target state="translated">\:e-mail:</target>
        </trans-unit>
        <trans-unit id="342b70334bbf5720445703775c579f7cca630a44" translate="yes" xml:space="preserve">
          <source>\:ear:</source>
          <target state="translated">\:ear:</target>
        </trans-unit>
        <trans-unit id="c8e215e17efdfe62d5180ca350c30dc2c3e681fe" translate="yes" xml:space="preserve">
          <source>\:ear_of_rice:</source>
          <target state="translated">\:ear_of_rice:</target>
        </trans-unit>
        <trans-unit id="8fe147b153746a63be25a328682e94ae978d1a7c" translate="yes" xml:space="preserve">
          <source>\:earth_africa:</source>
          <target state="translated">\:earth_africa:</target>
        </trans-unit>
        <trans-unit id="7872b354412ad6d0b26df4c9231e578224bde948" translate="yes" xml:space="preserve">
          <source>\:earth_americas:</source>
          <target state="translated">\:earth_americas:</target>
        </trans-unit>
        <trans-unit id="0f993bb7636b6a0221ad9b88f34849a4313f8471" translate="yes" xml:space="preserve">
          <source>\:earth_asia:</source>
          <target state="translated">\:earth_asia:</target>
        </trans-unit>
        <trans-unit id="2f0ff4228a9405fbb15562a48de301eb0143cbe6" translate="yes" xml:space="preserve">
          <source>\:egg:</source>
          <target state="translated">\:egg:</target>
        </trans-unit>
        <trans-unit id="60f5274b6430a0018392ff2c991781ec36f29258" translate="yes" xml:space="preserve">
          <source>\:eggplant:</source>
          <target state="translated">\:eggplant:</target>
        </trans-unit>
        <trans-unit id="ef6acc31fb78fb128d4aa6f3acfbdb96de042353" translate="yes" xml:space="preserve">
          <source>\:eight_pointed_black_star:</source>
          <target state="translated">\:eight_pointed_black_star:</target>
        </trans-unit>
        <trans-unit id="256871451345e0f8e2ad97ed1208214576af9cc1" translate="yes" xml:space="preserve">
          <source>\:eight_spoked_asterisk:</source>
          <target state="translated">\:eight_spoked_asterisk:</target>
        </trans-unit>
        <trans-unit id="463109f5aeb93e25d89da877aff2aa4a14c1e4c4" translate="yes" xml:space="preserve">
          <source>\:electric_plug:</source>
          <target state="translated">\:electric_plug:</target>
        </trans-unit>
        <trans-unit id="ae2112e4e4295f2b00f98fc19bab100bf405cbae" translate="yes" xml:space="preserve">
          <source>\:elephant:</source>
          <target state="translated">\:elephant:</target>
        </trans-unit>
        <trans-unit id="430b53e07cf0921d8fcaaa28bfa4e09b38098d6e" translate="yes" xml:space="preserve">
          <source>\:email:</source>
          <target state="translated">\:email:</target>
        </trans-unit>
        <trans-unit id="9960b453dddfdb466f65d7059b568addc3c383f6" translate="yes" xml:space="preserve">
          <source>\:end:</source>
          <target state="translated">\:end:</target>
        </trans-unit>
        <trans-unit id="76cdfeaf2a123479fcdaaec950745b5eeddf28ef" translate="yes" xml:space="preserve">
          <source>\:envelope_with_arrow:</source>
          <target state="translated">\:envelope_with_arrow:</target>
        </trans-unit>
        <trans-unit id="aaa8a40648743ea99ae7678d8e79ab592e84e2a5" translate="yes" xml:space="preserve">
          <source>\:euro:</source>
          <target state="translated">\:euro:</target>
        </trans-unit>
        <trans-unit id="023c0837bf821e216e39a1cafc6a7160051929fd" translate="yes" xml:space="preserve">
          <source>\:european_castle:</source>
          <target state="translated">\:european_castle:</target>
        </trans-unit>
        <trans-unit id="bdc20bcd7b0b6003706f5884c64437172cf1c04c" translate="yes" xml:space="preserve">
          <source>\:european_post_office:</source>
          <target state="translated">\:european_post_office:</target>
        </trans-unit>
        <trans-unit id="1b34f0e2cf43911c47177c7d6d3765026f801092" translate="yes" xml:space="preserve">
          <source>\:evergreen_tree:</source>
          <target state="translated">\:evergreen_tree:</target>
        </trans-unit>
        <trans-unit id="c6b6d0855b38729dfb84e26e84f49c30fc57bb59" translate="yes" xml:space="preserve">
          <source>\:exclamation:</source>
          <target state="translated">\:exclamation:</target>
        </trans-unit>
        <trans-unit id="ba5d1dbcaed41ac5c6bc5f64c6e1a1392ae2b453" translate="yes" xml:space="preserve">
          <source>\:expressionless:</source>
          <target state="translated">\:expressionless:</target>
        </trans-unit>
        <trans-unit id="18622e64ebd3e7de2b598df632ad63f8912ffa0d" translate="yes" xml:space="preserve">
          <source>\:eyeglasses:</source>
          <target state="translated">\:eyeglasses:</target>
        </trans-unit>
        <trans-unit id="a7da1b0807a892623f1c3727673d7ef72f65e554" translate="yes" xml:space="preserve">
          <source>\:eyes:</source>
          <target state="translated">\:eyes:</target>
        </trans-unit>
        <trans-unit id="d02f32a504982d86559b47f4c00a214b67ae1503" translate="yes" xml:space="preserve">
          <source>\:facepunch:</source>
          <target state="translated">\:facepunch:</target>
        </trans-unit>
        <trans-unit id="5a907517c618b26c91f1cfeabb2f5c4f40fdc791" translate="yes" xml:space="preserve">
          <source>\:factory:</source>
          <target state="translated">\:factory:</target>
        </trans-unit>
        <trans-unit id="c0e0da6907735eb5e0206302eb5951180c550861" translate="yes" xml:space="preserve">
          <source>\:fallen_leaf:</source>
          <target state="translated">\:fallen_leaf:</target>
        </trans-unit>
        <trans-unit id="b66642210fdefcbf23c2b7917817fb677011db2b" translate="yes" xml:space="preserve">
          <source>\:family:</source>
          <target state="translated">\:family:</target>
        </trans-unit>
        <trans-unit id="ed3ec616e68cc66512e14f769aa1253ff266259e" translate="yes" xml:space="preserve">
          <source>\:fast_forward:</source>
          <target state="translated">\:fast_forward:</target>
        </trans-unit>
        <trans-unit id="f0b8bb6286c35f069e4a1e90f8604f4bc62dc2a1" translate="yes" xml:space="preserve">
          <source>\:fax:</source>
          <target state="translated">\:fax:</target>
        </trans-unit>
        <trans-unit id="0bbcbc25c0eecfc841481e67fa9f6777fbd464a0" translate="yes" xml:space="preserve">
          <source>\:fearful:</source>
          <target state="translated">\:fearful:</target>
        </trans-unit>
        <trans-unit id="dfb7722d0a5f42db1ca95fce7cc4ad3a412d9431" translate="yes" xml:space="preserve">
          <source>\:feet:</source>
          <target state="translated">\:feet:</target>
        </trans-unit>
        <trans-unit id="a533586c1f3d88f9447dbd85e75f0159dfc758fa" translate="yes" xml:space="preserve">
          <source>\:ferris_wheel:</source>
          <target state="translated">\:ferris_wheel:</target>
        </trans-unit>
        <trans-unit id="8410fcb5f50c7b6b36a37c81dfce2f21c9289728" translate="yes" xml:space="preserve">
          <source>\:file_folder:</source>
          <target state="translated">\:file_folder:</target>
        </trans-unit>
        <trans-unit id="5f642a74f415d530d9e0c5161e141061f5048c2f" translate="yes" xml:space="preserve">
          <source>\:fire:</source>
          <target state="translated">\:fire:</target>
        </trans-unit>
        <trans-unit id="d31178ced29d67a2d79dd6806b8e2734a7210f59" translate="yes" xml:space="preserve">
          <source>\:fire_engine:</source>
          <target state="translated">\:fire_engine:</target>
        </trans-unit>
        <trans-unit id="99166886600ea54e3424e6eae7527e172415ab58" translate="yes" xml:space="preserve">
          <source>\:fireworks:</source>
          <target state="translated">\:fireworks:</target>
        </trans-unit>
        <trans-unit id="a5f27d6c8f245d7efcbee12ce0f0d34ecb795074" translate="yes" xml:space="preserve">
          <source>\:first_quarter_moon:</source>
          <target state="translated">\:first_quarter_moon:</target>
        </trans-unit>
        <trans-unit id="92ba03d67176c69aac120e23be17056ff654a2af" translate="yes" xml:space="preserve">
          <source>\:first_quarter_moon_with_face:</source>
          <target state="translated">\:first_quarter_moon_with_face:</target>
        </trans-unit>
        <trans-unit id="a477f6e7c890ec3d6a197083a8a5b84507070518" translate="yes" xml:space="preserve">
          <source>\:fish:</source>
          <target state="translated">\:fish:</target>
        </trans-unit>
        <trans-unit id="754188072f05e7845676bd8f59cd34073cc59ec8" translate="yes" xml:space="preserve">
          <source>\:fish_cake:</source>
          <target state="translated">\:fish_cake:</target>
        </trans-unit>
        <trans-unit id="96350c7bb269406ba40216612c5b8d8a4aa4046f" translate="yes" xml:space="preserve">
          <source>\:fishing_pole_and_fish:</source>
          <target state="translated">\:fishing_pole_and_fish:</target>
        </trans-unit>
        <trans-unit id="afb2fdba94eafd33339972c9cde902bd8d88183d" translate="yes" xml:space="preserve">
          <source>\:fist:</source>
          <target state="translated">\:fist:</target>
        </trans-unit>
        <trans-unit id="6fba42d42662f10baaf9aae465a0d330b9a22fe7" translate="yes" xml:space="preserve">
          <source>\:flags:</source>
          <target state="translated">\:flags:</target>
        </trans-unit>
        <trans-unit id="dee86e1eb9c34ff3fd2e76ab21e66155ddd1bfb9" translate="yes" xml:space="preserve">
          <source>\:flashlight:</source>
          <target state="translated">\:flashlight:</target>
        </trans-unit>
        <trans-unit id="ab7a714e6d6af892bbcefc56f3a9caf380f61cbe" translate="yes" xml:space="preserve">
          <source>\:floppy_disk:</source>
          <target state="translated">\:floppy_disk:</target>
        </trans-unit>
        <trans-unit id="3f3b11bf344ed631f7b08ed824e958f2d197eebd" translate="yes" xml:space="preserve">
          <source>\:flower_playing_cards:</source>
          <target state="translated">\:flower_playing_cards:</target>
        </trans-unit>
        <trans-unit id="07becb107390b18996293a798ac6171d731bb60b" translate="yes" xml:space="preserve">
          <source>\:flushed:</source>
          <target state="translated">\:flushed:</target>
        </trans-unit>
        <trans-unit id="aac07be89b7f97da8ff1714957e0b50c78fb3b0e" translate="yes" xml:space="preserve">
          <source>\:foggy:</source>
          <target state="translated">\:foggy:</target>
        </trans-unit>
        <trans-unit id="ea6f3ffda4db63053ed2b11fc0754de51566bff9" translate="yes" xml:space="preserve">
          <source>\:football:</source>
          <target state="translated">\:football:</target>
        </trans-unit>
        <trans-unit id="e2920013962db56b799e663f9371401f9f2e73ae" translate="yes" xml:space="preserve">
          <source>\:footprints:</source>
          <target state="translated">\:footprints:</target>
        </trans-unit>
        <trans-unit id="3f9c7ada8df9f30aa5e97fb8cd42a3be0a699c41" translate="yes" xml:space="preserve">
          <source>\:fork_and_knife:</source>
          <target state="translated">\:fork_and_knife:</target>
        </trans-unit>
        <trans-unit id="6e1c0b1dc5050db6421453bced78b829513f7532" translate="yes" xml:space="preserve">
          <source>\:fountain:</source>
          <target state="translated">\:fountain:</target>
        </trans-unit>
        <trans-unit id="91a454402bd64ebedd25f162a55553e97822bfec" translate="yes" xml:space="preserve">
          <source>\:four_leaf_clover:</source>
          <target state="translated">\:four_leaf_clover:</target>
        </trans-unit>
        <trans-unit id="f42b4f6d94e68b9ab012088fff26ded02f4b0d89" translate="yes" xml:space="preserve">
          <source>\:free:</source>
          <target state="translated">\:free:</target>
        </trans-unit>
        <trans-unit id="4ab8d77ca9e28c670e1bea7f6edf233ab8c04a0c" translate="yes" xml:space="preserve">
          <source>\:fried_shrimp:</source>
          <target state="translated">\:fried_shrimp:</target>
        </trans-unit>
        <trans-unit id="0b6eb9d008cc870e6d1d4ca5c5782cf925f58769" translate="yes" xml:space="preserve">
          <source>\:fries:</source>
          <target state="translated">\:fries:</target>
        </trans-unit>
        <trans-unit id="d650a0682549be1169559081c897bd1a56d82e3d" translate="yes" xml:space="preserve">
          <source>\:frog:</source>
          <target state="translated">\:frog:</target>
        </trans-unit>
        <trans-unit id="2742ac6926f4f88b9410f04c7ea56e51f3ebd6d0" translate="yes" xml:space="preserve">
          <source>\:frowning:</source>
          <target state="translated">\:frowning:</target>
        </trans-unit>
        <trans-unit id="56e48a8d3eaa7a4f9ee58730de2264a44c88c922" translate="yes" xml:space="preserve">
          <source>\:fuelpump:</source>
          <target state="translated">\:fuelpump:</target>
        </trans-unit>
        <trans-unit id="e9ee232804c33596308c636be649e8dfd7c6fc6f" translate="yes" xml:space="preserve">
          <source>\:full_moon:</source>
          <target state="translated">\:full_moon:</target>
        </trans-unit>
        <trans-unit id="1d17e3b9fd7f6470516768046b2614531b6138bf" translate="yes" xml:space="preserve">
          <source>\:full_moon_with_face:</source>
          <target state="translated">\:full_moon_with_face:</target>
        </trans-unit>
        <trans-unit id="ec1a93f48d5e8cc69f0397c1b86ec8ab1ae25967" translate="yes" xml:space="preserve">
          <source>\:game_die:</source>
          <target state="translated">\:game_die:</target>
        </trans-unit>
        <trans-unit id="3d22d282de92c405ea93daa9629d228a8ef356fc" translate="yes" xml:space="preserve">
          <source>\:gem:</source>
          <target state="translated">\:gem:</target>
        </trans-unit>
        <trans-unit id="61586c797e3f46bbc0fdc4374035a13e4388ac91" translate="yes" xml:space="preserve">
          <source>\:ghost:</source>
          <target state="translated">\:ghost:</target>
        </trans-unit>
        <trans-unit id="09e8db1424aa970a7b9eea0aadcdb8ed8e45f4ba" translate="yes" xml:space="preserve">
          <source>\:gift:</source>
          <target state="translated">\:gift:</target>
        </trans-unit>
        <trans-unit id="56b72e78e1ce7805c74a02df7e25841d36162fbf" translate="yes" xml:space="preserve">
          <source>\:gift_heart:</source>
          <target state="translated">\:gift_heart:</target>
        </trans-unit>
        <trans-unit id="25543880f70d890dc66d24e9fe21aaec7f1772b3" translate="yes" xml:space="preserve">
          <source>\:girl:</source>
          <target state="translated">\:girl:</target>
        </trans-unit>
        <trans-unit id="a3e89e111cc47eec6e460db70096e82175ab465a" translate="yes" xml:space="preserve">
          <source>\:globe_with_meridians:</source>
          <target state="translated">\:globe_with_meridians:</target>
        </trans-unit>
        <trans-unit id="ab196f2bec3cd3ab9d82813f9cf081a40365a79e" translate="yes" xml:space="preserve">
          <source>\:goat:</source>
          <target state="translated">\:goat:</target>
        </trans-unit>
        <trans-unit id="ed719de38fda896d8db1c163b43b8157544140d8" translate="yes" xml:space="preserve">
          <source>\:golf:</source>
          <target state="translated">\:golf:</target>
        </trans-unit>
        <trans-unit id="bad4d3ba66fc07b0bd85318625927109db2adffe" translate="yes" xml:space="preserve">
          <source>\:grapes:</source>
          <target state="translated">\:grapes:</target>
        </trans-unit>
        <trans-unit id="5c87f82bfdb61a23911d2cf5896ade45203f2e51" translate="yes" xml:space="preserve">
          <source>\:green_apple:</source>
          <target state="translated">\:green_apple:</target>
        </trans-unit>
        <trans-unit id="838189fcc067ca8397914e14f9e3eb8d1c7deb96" translate="yes" xml:space="preserve">
          <source>\:green_book:</source>
          <target state="translated">\:green_book:</target>
        </trans-unit>
        <trans-unit id="e183cff3dbc896f379685e638915b49016745afe" translate="yes" xml:space="preserve">
          <source>\:green_heart:</source>
          <target state="translated">\:green_heart:</target>
        </trans-unit>
        <trans-unit id="85aa6c7ad1d80e64f9bef0fad00d4043610a2602" translate="yes" xml:space="preserve">
          <source>\:grey_exclamation:</source>
          <target state="translated">\:grey_exclamation:</target>
        </trans-unit>
        <trans-unit id="17166e8e051ae3338b296ce626f5cb30e270e614" translate="yes" xml:space="preserve">
          <source>\:grey_question:</source>
          <target state="translated">\:grey_question:</target>
        </trans-unit>
        <trans-unit id="68520e5886a6f2a0abb47b6e25fc0963b580ad26" translate="yes" xml:space="preserve">
          <source>\:grimacing:</source>
          <target state="translated">\:grimacing:</target>
        </trans-unit>
        <trans-unit id="cce5340e57d64117cf21db918db8874a204e435a" translate="yes" xml:space="preserve">
          <source>\:grin:</source>
          <target state="translated">\:grin:</target>
        </trans-unit>
        <trans-unit id="0f1fa781c7642a02f5643799bf74c4e077ca3f5c" translate="yes" xml:space="preserve">
          <source>\:grinning:</source>
          <target state="translated">\:grinning:</target>
        </trans-unit>
        <trans-unit id="ef032ad2a13d8da2bb56339e65e775441a4c25e3" translate="yes" xml:space="preserve">
          <source>\:guardsman:</source>
          <target state="translated">\:guardsman:</target>
        </trans-unit>
        <trans-unit id="a972d453cbd7205b6a9a1dddedcc068bdf796581" translate="yes" xml:space="preserve">
          <source>\:guitar:</source>
          <target state="translated">\:guitar:</target>
        </trans-unit>
        <trans-unit id="a51d6f0b9190d629b1cda30f1c1e56bf449f22aa" translate="yes" xml:space="preserve">
          <source>\:gun:</source>
          <target state="translated">\:gun:</target>
        </trans-unit>
        <trans-unit id="f66b152c44faf9c0a24a1dd6fef7c89340f0fdaf" translate="yes" xml:space="preserve">
          <source>\:haircut:</source>
          <target state="translated">\:haircut:</target>
        </trans-unit>
        <trans-unit id="85aedcca8045f08a05c87f20bfac292819a4ad93" translate="yes" xml:space="preserve">
          <source>\:hamburger:</source>
          <target state="translated">\:hamburger:</target>
        </trans-unit>
        <trans-unit id="907fc978124793d22347e3e7fcd877d3caa89f6c" translate="yes" xml:space="preserve">
          <source>\:hammer:</source>
          <target state="translated">\:hammer:</target>
        </trans-unit>
        <trans-unit id="90fdea0c85a38788e5f5cecd739e98eaf2e645b8" translate="yes" xml:space="preserve">
          <source>\:hamster:</source>
          <target state="translated">\:hamster:</target>
        </trans-unit>
        <trans-unit id="85a6bd90152b5e22c307422b0767db692e5ec5d7" translate="yes" xml:space="preserve">
          <source>\:hand:</source>
          <target state="translated">\:hand:</target>
        </trans-unit>
        <trans-unit id="2b2b9d3e7357b586a98195211be59627e129df14" translate="yes" xml:space="preserve">
          <source>\:handbag:</source>
          <target state="translated">\:handbag:</target>
        </trans-unit>
        <trans-unit id="811b2dc747d647624b10868bf5a4d7f1ad1f15ee" translate="yes" xml:space="preserve">
          <source>\:hankey:</source>
          <target state="translated">\:hankey:</target>
        </trans-unit>
        <trans-unit id="b826819abd18a9e381b7bb08e8b393cf3ec13354" translate="yes" xml:space="preserve">
          <source>\:hatched_chick:</source>
          <target state="translated">\:hatched_chick:</target>
        </trans-unit>
        <trans-unit id="961fc5347826968c129900e146ec149afc14d1b1" translate="yes" xml:space="preserve">
          <source>\:hatching_chick:</source>
          <target state="translated">\:hatching_chick:</target>
        </trans-unit>
        <trans-unit id="fd13dbe756c2f7bec1e5fd3f11e35040bb929423" translate="yes" xml:space="preserve">
          <source>\:headphones:</source>
          <target state="translated">\:headphones:</target>
        </trans-unit>
        <trans-unit id="5b74b867b4e85bc99a8d4e081b412a2068bebfa2" translate="yes" xml:space="preserve">
          <source>\:hear_no_evil:</source>
          <target state="translated">\:hear_no_evil:</target>
        </trans-unit>
        <trans-unit id="ccb6fe30b2099b698ab1757148bbbfa20ded47b2" translate="yes" xml:space="preserve">
          <source>\:heart:</source>
          <target state="translated">\:heart:</target>
        </trans-unit>
        <trans-unit id="d19130804fd189a3217365acd20e8a55fee661c7" translate="yes" xml:space="preserve">
          <source>\:heart_decoration:</source>
          <target state="translated">\:heart_decoration:</target>
        </trans-unit>
        <trans-unit id="7fd7fc7da096929d65b442d3078005adbde95ec5" translate="yes" xml:space="preserve">
          <source>\:heart_eyes:</source>
          <target state="translated">\:heart_eyes:</target>
        </trans-unit>
        <trans-unit id="c743497e2a8415cb9689c73e20b2b475d6dc0aa4" translate="yes" xml:space="preserve">
          <source>\:heart_eyes_cat:</source>
          <target state="translated">\:heart_eyes_cat:</target>
        </trans-unit>
        <trans-unit id="0303cea12f05193a6575a3b06833743a2df98ec8" translate="yes" xml:space="preserve">
          <source>\:heartbeat:</source>
          <target state="translated">\:heartbeat:</target>
        </trans-unit>
        <trans-unit id="84eec40ef310877af50ac181032f31f711ecc75e" translate="yes" xml:space="preserve">
          <source>\:heartpulse:</source>
          <target state="translated">\:heartpulse:</target>
        </trans-unit>
        <trans-unit id="cce17d7c17b286ec8e76fbf2a7a635ef5af4da4f" translate="yes" xml:space="preserve">
          <source>\:heavy_check_mark:</source>
          <target state="translated">\:heavy_check_mark:</target>
        </trans-unit>
        <trans-unit id="ef2574882ba67253be321721a0d7a0a3789d0853" translate="yes" xml:space="preserve">
          <source>\:heavy_division_sign:</source>
          <target state="translated">\:heavy_division_sign:</target>
        </trans-unit>
        <trans-unit id="564cf55cbce579e6f0f2d5b6020c6d1079eadab8" translate="yes" xml:space="preserve">
          <source>\:heavy_dollar_sign:</source>
          <target state="translated">\:heavy_dollar_sign:</target>
        </trans-unit>
        <trans-unit id="3389894352ab55798f8586d6c0676e638f24a8b4" translate="yes" xml:space="preserve">
          <source>\:heavy_minus_sign:</source>
          <target state="translated">\:heavy_minus_sign:</target>
        </trans-unit>
        <trans-unit id="6d2a946978c021a995c0dbf7d6c667f1e213586d" translate="yes" xml:space="preserve">
          <source>\:heavy_multiplication_x:</source>
          <target state="translated">\:heavy_multiplication_x:</target>
        </trans-unit>
        <trans-unit id="51a3048909873e66e79db2a1c679d08d8e9946c3" translate="yes" xml:space="preserve">
          <source>\:heavy_plus_sign:</source>
          <target state="translated">\:heavy_plus_sign:</target>
        </trans-unit>
        <trans-unit id="4c209dc1b46c2d4fd1aabc606840cbf509597492" translate="yes" xml:space="preserve">
          <source>\:helicopter:</source>
          <target state="translated">\:helicopter:</target>
        </trans-unit>
        <trans-unit id="3d16f46b09472f5a35b37d0c88263766997edde5" translate="yes" xml:space="preserve">
          <source>\:herb:</source>
          <target state="translated">\:herb:</target>
        </trans-unit>
        <trans-unit id="0eda427d63afb6f8ae8c62ad3e610657974a1b8d" translate="yes" xml:space="preserve">
          <source>\:hibiscus:</source>
          <target state="translated">\:hibiscus:</target>
        </trans-unit>
        <trans-unit id="6301055ebc5235af7cfeb4a122046758607536d1" translate="yes" xml:space="preserve">
          <source>\:high_brightness:</source>
          <target state="translated">\:high_brightness:</target>
        </trans-unit>
        <trans-unit id="65de326b7d761878713c699bbe8d05c23928a01f" translate="yes" xml:space="preserve">
          <source>\:high_heel:</source>
          <target state="translated">\:high_heel:</target>
        </trans-unit>
        <trans-unit id="fdfbe50c4aba5f5092263322db165d7fba907cc6" translate="yes" xml:space="preserve">
          <source>\:hocho:</source>
          <target state="translated">\:hocho:</target>
        </trans-unit>
        <trans-unit id="efef59ac159cef18702821b259808a7da7d50a49" translate="yes" xml:space="preserve">
          <source>\:honey_pot:</source>
          <target state="translated">\:honey_pot:</target>
        </trans-unit>
        <trans-unit id="fa75f94f6f067c66c1972fd3d2091e70048c180b" translate="yes" xml:space="preserve">
          <source>\:horse:</source>
          <target state="translated">\:horse:</target>
        </trans-unit>
        <trans-unit id="fdef0d6640eb2571ffb16308c7980b77e524e7d1" translate="yes" xml:space="preserve">
          <source>\:horse_racing:</source>
          <target state="translated">\:horse_racing:</target>
        </trans-unit>
        <trans-unit id="61a9e5a0a7da234ce5f398aaa93c7dc9b62d313b" translate="yes" xml:space="preserve">
          <source>\:hospital:</source>
          <target state="translated">\:hospital:</target>
        </trans-unit>
        <trans-unit id="9a3b691ad4e378ca43461334f9515ec92433e64d" translate="yes" xml:space="preserve">
          <source>\:hotel:</source>
          <target state="translated">\:hotel:</target>
        </trans-unit>
        <trans-unit id="fc2dde6eaf60d12623f07c2628a1d58bff256517" translate="yes" xml:space="preserve">
          <source>\:hotsprings:</source>
          <target state="translated">\:hotsprings:</target>
        </trans-unit>
        <trans-unit id="78bff1fafe56bf8662de8f05039252c1f7ed3058" translate="yes" xml:space="preserve">
          <source>\:hourglass:</source>
          <target state="translated">\:hourglass:</target>
        </trans-unit>
        <trans-unit id="d6660d4ab7468bd130a788a520b856ddc92c34fe" translate="yes" xml:space="preserve">
          <source>\:hourglass_flowing_sand:</source>
          <target state="translated">\:hourglass_flowing_sand:</target>
        </trans-unit>
        <trans-unit id="77a74b1d6af5e0dd2f6744cb27fc9118cd9fa21f" translate="yes" xml:space="preserve">
          <source>\:house:</source>
          <target state="translated">\:house:</target>
        </trans-unit>
        <trans-unit id="3d97ad3a63f759728a7e1f0386effe24bba77e9f" translate="yes" xml:space="preserve">
          <source>\:house_with_garden:</source>
          <target state="translated">\:house_with_garden:</target>
        </trans-unit>
        <trans-unit id="3120a7b7a3bad39a47e81918bf4e7e5443442b12" translate="yes" xml:space="preserve">
          <source>\:hushed:</source>
          <target state="translated">\:hushed:</target>
        </trans-unit>
        <trans-unit id="2114ae059b0712fa881f9dbd5aa0b92c8265c78b" translate="yes" xml:space="preserve">
          <source>\:ice_cream:</source>
          <target state="translated">\:ice_cream:</target>
        </trans-unit>
        <trans-unit id="69460a6f4e102904e016c71a19fb5c40f59fa1ec" translate="yes" xml:space="preserve">
          <source>\:icecream:</source>
          <target state="translated">\:icecream:</target>
        </trans-unit>
        <trans-unit id="195ae110176e1c867d178e722909a436085d86c1" translate="yes" xml:space="preserve">
          <source>\:id:</source>
          <target state="translated">\:id:</target>
        </trans-unit>
        <trans-unit id="7b74738ca9656136db50876c02ded7440575effa" translate="yes" xml:space="preserve">
          <source>\:ideograph_advantage:</source>
          <target state="translated">\:ideograph_advantage:</target>
        </trans-unit>
        <trans-unit id="ac990dfb12419d28446a4bd3c2b4cb80477dc84a" translate="yes" xml:space="preserve">
          <source>\:imp:</source>
          <target state="translated">\:imp:</target>
        </trans-unit>
        <trans-unit id="9abf48ff7a2c9750bf4bacad546b7adfa108e924" translate="yes" xml:space="preserve">
          <source>\:inbox_tray:</source>
          <target state="translated">\:inbox_tray:</target>
        </trans-unit>
        <trans-unit id="ab6e8553cef846648ef74ec5c61e35dfd082f8f1" translate="yes" xml:space="preserve">
          <source>\:incoming_envelope:</source>
          <target state="translated">\:incoming_envelope:</target>
        </trans-unit>
        <trans-unit id="e5aae8be037b97e78d7d65435935ad1b926376a1" translate="yes" xml:space="preserve">
          <source>\:information_desk_person:</source>
          <target state="translated">\:information_desk_person:</target>
        </trans-unit>
        <trans-unit id="50696eca6dd53cce15313edffee9061f37583805" translate="yes" xml:space="preserve">
          <source>\:information_source:</source>
          <target state="translated">\:information_source:</target>
        </trans-unit>
        <trans-unit id="6a9d7f8e7caa52b913fcf42f28c2114f6973f06d" translate="yes" xml:space="preserve">
          <source>\:innocent:</source>
          <target state="translated">\:innocent:</target>
        </trans-unit>
        <trans-unit id="88c7780aa2b2754523f92f40c468e5f02243faaa" translate="yes" xml:space="preserve">
          <source>\:interrobang:</source>
          <target state="translated">\:interrobang:</target>
        </trans-unit>
        <trans-unit id="89553831067427a04402446076288a41f51d85c7" translate="yes" xml:space="preserve">
          <source>\:iphone:</source>
          <target state="translated">\:iphone:</target>
        </trans-unit>
        <trans-unit id="c6e95ab229f02caa9f80f351f0a2976966b1417d" translate="yes" xml:space="preserve">
          <source>\:izakaya_lantern:</source>
          <target state="translated">\:izakaya_lantern:</target>
        </trans-unit>
        <trans-unit id="d8b754896fdce4300cabebb06d1bb59f26449b87" translate="yes" xml:space="preserve">
          <source>\:jack_o_lantern:</source>
          <target state="translated">\:jack_o_lantern:</target>
        </trans-unit>
        <trans-unit id="e0d94d3bbdd2ae49e2e4cc952ab59f7c8db1bfd1" translate="yes" xml:space="preserve">
          <source>\:japan:</source>
          <target state="translated">\:japan:</target>
        </trans-unit>
        <trans-unit id="5d9efac54e6bacab40c7150f14c9996cbfe9de74" translate="yes" xml:space="preserve">
          <source>\:japanese_castle:</source>
          <target state="translated">\:japanese_castle:</target>
        </trans-unit>
        <trans-unit id="7a2838cc26d1ae0cd5a4f3e4de5b6604f149b3d8" translate="yes" xml:space="preserve">
          <source>\:japanese_goblin:</source>
          <target state="translated">\:japanese_goblin:</target>
        </trans-unit>
        <trans-unit id="2d6bb67fbb099c8b915fe9b9f0c0265286b7046f" translate="yes" xml:space="preserve">
          <source>\:japanese_ogre:</source>
          <target state="translated">\:japanese_ogre:</target>
        </trans-unit>
        <trans-unit id="a2146516486da5e5e9f8e7e4e2e7acb85870f2a7" translate="yes" xml:space="preserve">
          <source>\:jeans:</source>
          <target state="translated">\:jeans:</target>
        </trans-unit>
        <trans-unit id="ea868455085d13fef4fd5d894fc2ad2ded7b6ba6" translate="yes" xml:space="preserve">
          <source>\:joy:</source>
          <target state="translated">\:joy:</target>
        </trans-unit>
        <trans-unit id="064e1e4713eac1885087b8bd7438a16ced15082f" translate="yes" xml:space="preserve">
          <source>\:joy_cat:</source>
          <target state="translated">\:joy_cat:</target>
        </trans-unit>
        <trans-unit id="fbdd023d93f6bb1eaecb2d6c3fe0da079f796ed9" translate="yes" xml:space="preserve">
          <source>\:key:</source>
          <target state="translated">\:key:</target>
        </trans-unit>
        <trans-unit id="e849055eebefe6f4329c1bf5a14250673db58252" translate="yes" xml:space="preserve">
          <source>\:keycap_ten:</source>
          <target state="translated">\:keycap_ten:</target>
        </trans-unit>
        <trans-unit id="3a2438f7610437821d2e284acb513c43f16640ce" translate="yes" xml:space="preserve">
          <source>\:kimono:</source>
          <target state="translated">\:kimono:</target>
        </trans-unit>
        <trans-unit id="69836882bf2b229a60c7fc26e8dd2d39a0e6d632" translate="yes" xml:space="preserve">
          <source>\:kiss:</source>
          <target state="translated">\:kiss:</target>
        </trans-unit>
        <trans-unit id="b374f6fdedd99db97ebf74dbc217db0acb4fdbb6" translate="yes" xml:space="preserve">
          <source>\:kissing:</source>
          <target state="translated">\:kissing:</target>
        </trans-unit>
        <trans-unit id="401a71d1412dcacb36be5cdf24c21d5a7f00cb92" translate="yes" xml:space="preserve">
          <source>\:kissing_cat:</source>
          <target state="translated">\:kissing_cat:</target>
        </trans-unit>
        <trans-unit id="a87dcdd91fd62b83066f99f9ea1880b7c26d534c" translate="yes" xml:space="preserve">
          <source>\:kissing_closed_eyes:</source>
          <target state="translated">\:kissing_closed_eyes:</target>
        </trans-unit>
        <trans-unit id="87910c1eeadffb904163cb525409dfaa694da84a" translate="yes" xml:space="preserve">
          <source>\:kissing_heart:</source>
          <target state="translated">\:kissing_heart:</target>
        </trans-unit>
        <trans-unit id="219370630e5b4d1939866226f2b74bd305891f60" translate="yes" xml:space="preserve">
          <source>\:kissing_smiling_eyes:</source>
          <target state="translated">\:kissing_smiling_eyes:</target>
        </trans-unit>
        <trans-unit id="4be31d8193dae2129e450851916b924b8f08fea3" translate="yes" xml:space="preserve">
          <source>\:koala:</source>
          <target state="translated">\:koala:</target>
        </trans-unit>
        <trans-unit id="68a542b4ef03b641b9d47a3084da38002028562d" translate="yes" xml:space="preserve">
          <source>\:koko:</source>
          <target state="translated">\:koko:</target>
        </trans-unit>
        <trans-unit id="c04969d1c03a33477b9b68d52d3f316f04d4f03b" translate="yes" xml:space="preserve">
          <source>\:large_blue_circle:</source>
          <target state="translated">\:large_blue_circle:</target>
        </trans-unit>
        <trans-unit id="1484bf2ecab7017bdfc7353b9cca9f0b2b19c2bb" translate="yes" xml:space="preserve">
          <source>\:large_blue_diamond:</source>
          <target state="translated">\:large_blue_diamond:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
