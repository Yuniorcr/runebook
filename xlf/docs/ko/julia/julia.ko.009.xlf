<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="de317509d863583987ae78748b3c0fbd35bb5918" translate="yes" xml:space="preserve">
          <source>It is common to want to create a task and schedule it right away, so the macro &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; is provided for that purpose &amp;ndash;- &lt;code&gt;@async x&lt;/code&gt; is equivalent to &lt;code&gt;schedule(@task x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">캡처 구문을 배열로 반환하여 구조화 구문을 사용하여 로컬 변수에 바인딩하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">선언 된 C 유형을 Julia의 선언과 정확하게 일치시키는 것이 중요합니다. 불일치로 인해 한 시스템에서 올바르게 작동하는 코드가 실패하거나 다른 시스템에서 불확실한 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">일반적인 메소드처럼 외부가 아닌 형식 선언의 블록 내부에 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">가능한 한 적은 내부 생성자 메소드를 제공하는 것이 좋습니다. 모든 인수를 명시 적으로 취하고 필수 오류 검사 및 변환을 시행하는 메소드 만 가능합니다. 기본값 또는 보조 변환을 제공하는 추가 편의 생성자 메소드는 내부 생성자를 호출하여 무거운 리프팅을 수행하는 외부 생성자로 제공해야합니다. 이 분리는 일반적으로 매우 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">이러한 특수 버전을 비교에 사용하는 것이 좋습니다 (특히 후행 &lt;code&gt;-&lt;/code&gt; 특별한 이유가없는 한 항상 상한에 사용해야 함). 그러나 실제 버전 번호로 사용해서는 안됩니다. 시맨틱 버전 관리 체계에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">매크로는 인수를 표현식, 리터럴 또는 기호로 받는다는 점을 강조하는 것이 중요합니다. 매크로 인수를 탐색하는 한 가지 방법 은 매크로 본문 내에서 &lt;code&gt;show&lt;/code&gt; 함수 를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">객체가 로컬로 가비지 수집 되는 &lt;em&gt;시기&lt;/em&gt; 는 객체의 크기와 시스템의 현재 메모리 압력에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">런타임시 어떤 값이 오래 될지 예측하는 것은 일반적으로 불가능하므로 모든 명시 적 저장소 뒤에 쓰기 장벽을 삽입해야합니다. 주목할만한 예외 중 하나는 &lt;code&gt;parent&lt;/code&gt; 객체가 방금 할당되었고 그 이후 가비지 수집이 실행되지 않은 경우입니다. 대부분의 &lt;code&gt;jl_...&lt;/code&gt; 함수는 때때로 가비지 콜렉션을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">불변 유형의 값을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">타입의 생성자가 제공하는 불변을 위반하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">임의의 수의 인수를 사용하여 함수를 작성할 수있는 것이 종종 편리합니다. 이러한 함수는 전통적으로 &quot;varargs&quot;함수로 알려져 있으며 &quot;가변 인수&quot;의 약자입니다. 줄임표로 마지막 인수를 따라 varargs 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d37775863d3d8aefef1deee1f9fba7a5cc77f8" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last positional argument with an ellipsis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">모든 유형의 값 ( &lt;code&gt;Array{Any}&lt;/code&gt; 유형의 배열)을 포함 할 수있는 데이터 구조로 작업하는 것이 편리합니다 . 그러나 이러한 구조 중 하나를 사용하고 있고 요소의 유형을 알고 있다면이 지식을 컴파일러와 공유하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="096c719abfea35b0b455d36ba64fc9420aa68bfd" translate="yes" xml:space="preserve">
          <source>It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4293de250d5dd5832be57fecdaa6e0a3c7af489c" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">변수 인수로 전달 된 값의 수를 제한 할 수 있습니다. 이것에 후술 &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;패라 제약 가변 인자 방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">일부 인수 조합에 적용 할 수있는 고유 한 가장 구체적인 방법이 없도록 일련의 함수 방법을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="637c214ddc147146d30043be14f7af002a6afb37" translate="yes" xml:space="preserve">
          <source>It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-interpolation within the docstring you will need to use an extra &lt;code&gt;$&lt;/code&gt; as shown with &lt;code&gt;$($name)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">Julia 함수를 함수 포인터 인수를 허용하는 기본 C 함수로 전달할 수 있습니다. 예를 들어 양식의 C 프로토 타입을 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">다음과 같은 정의를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">보다 효율적인 구현을 제공하기 위해 하위 유형 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 가 다음 메소드 서명을 대체하는 것이 좋습니다 . &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">보다 효율적인 구현을 제공하기 위해 하위 유형 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 가 다음 메소드 서명을 대체하는 것이 좋습니다 . &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">명확하지 않은 방법은 먼저 정의하는 것이 좋습니다. 그렇지 않으면 일시적인 경우보다 구체적인 방법이 정의 될 때까지 모호성이 존재하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">축소 변수를 특별히 고려하여 임의 또는 겹치는 순서로 반복을 실행하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">같은 것이 중요 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; , 이전과 이후의 표현은 &lt;code&gt;:&lt;/code&gt; 단지 평가에 조건 식 평가되면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 각각 :</target>
        </trans-unit>
        <trans-unit id="6b7dd92481471c3be503cbed8b0ada7bae73d043" translate="yes" xml:space="preserve">
          <source>It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way. The former operation requires division &amp;mdash; a very costly operation &amp;mdash; whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an &lt;code&gt;IndexCartesian&lt;/code&gt; array than it is to use Cartesian indexing with an &lt;code&gt;IndexLinear&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">테스트 조건이 위조되기 전에 &lt;code&gt;while&lt;/code&gt; 반복을 종료 하거나 반복 가능한 객체의 끝에 도달하기 전에 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복을 중지하는 것이 편리한 경우 가 있습니다. 이는 &lt;code&gt;break&lt;/code&gt; 키워드를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">증분 사전 컴파일을 해제하는 것이 모듈 개발 중에 도움이되는 경우가 있습니다. 명령 줄 플래그 &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; 사용하면 모듈 사전 컴파일을 켜거나 끌 수 있습니다. Julia가 &lt;code&gt;--compiled-modules=no&lt;/code&gt; 로 시작하면 모듈 및 모듈 종속성을로드 할 때 컴파일 캐시의 직렬화 된 모듈이 무시됩니다. &lt;code&gt;Base.compilecache&lt;/code&gt; 는 여전히 수동으로 호출 할 수 있습니다. 이 명령 줄 플래그의 상태는 패키지를 설치, 업데이트 및 명시 적으로 빌드 할 때 자동 사전 컴파일 트리거링을 비활성화 하기 위해 &lt;code&gt;Pkg.build&lt;/code&gt; 로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">라이브러리를 다시로드 할 수 있도록 라이브러리를 닫거나 언로드하는 것이 유용한 경우가 있습니다. 예를 들어 Julia와 함께 사용할 C 코드를 개발할 때는 컴파일하고 Julia에서 C 코드를 호출 한 다음 라이브러리를 닫고 편집, 재 컴파일 및 새 변경 사항을로드해야합니다. 다음 과 같이 Julia를 다시 시작하거나 &lt;code&gt;Libdl&lt;/code&gt; 함수를 사용하여 라이브러리를 명시 적으로 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">행렬의 각 열에 벡터를 추가하는 것과 같이 서로 다른 크기의 배열에서 요소 별 이진 연산을 수행하는 것이 유용한 경우가 있습니다. 이렇게하는 비효율적 인 방법은 벡터를 행렬 크기로 복제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">이것은 일반적으로 문제가되지 않습니다. 객체가 로컬에 저장되고 호출 후 수정 된 경우에만 고려되어야합니다. 이러한 경우 대상 의 &lt;code&gt;deepcopy&lt;/code&gt; 를 저장하는 것이 적절할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">일반적으로 &lt;code&gt;Method&lt;/code&gt; , &lt;code&gt;MethodInstance&lt;/code&gt; , &lt;code&gt;MethodTable&lt;/code&gt; , &lt;code&gt;TypeMapLevel&lt;/code&gt; , &lt;code&gt;TypeMapEntry&lt;/code&gt; 및 해당 객체의 필드 와 같은 내부 메타 데이터 객체의 인스턴스에 대한 참조를 캡처하지 않는 것이 좋습니다 . 이로 인해 serializer가 혼동되어 원하는 결과를 얻지 못할 수 있습니다. 이 작업이 반드시 오류는 아니지만 시스템이 이들 중 일부를 복사하고 다른 고유 한 단일 인스턴스를 작성하려고 시도하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">일반적으로 다음과 같은 배열을 구성하는 데별로 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">호출 된 함수가 segfault와 같이 Julia를 다시 호출하지 않는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="334c0921872b88ab33e359bc32c0c7cf09fbdeba" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">선택적 키워드 인수가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">이는 입력 유형에서 출력 유형을 예측할 수 있음을 의미합니다. 특히, 출력 유형은 입력 &lt;em&gt;값&lt;/em&gt; 에 따라 달라질 수 없음을 의미합니다 . 다음 코드는 형식이 안정적 &lt;em&gt;이지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">정수 값의 비율 만 취하는 것이 합리적이므로 매개 변수 유형 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 의 하위 유형으로 제한되며 정수 의 비율은 실수 라인의 값을 나타내므로 모든 &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 추상화 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">그것은 반복자와 그것의 반복 상태 주위에 가변 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1341640325353ec21dd6ae9c9b69ddf97792b73e" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">인수 값에 따라 &lt;code&gt;Int&lt;/code&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . Julia는 컴파일 타임에이 함수의 리턴 유형을 예측할 수 없으므로이 함수를 사용하는 계산은 두 가지 유형 모두 발생하지 않도록 보호해야하므로 빠른 기계 코드 생성이 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">그러나 컴파일러는 &lt;code&gt;mynorm&lt;/code&gt; 예제 로 작성된 코드에서 죽은 분기를 최적화하는 데 매우 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">반복자와 같은 추상화를 &lt;code&gt;Channel&lt;/code&gt; 과 같은 추상화로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">Julia의 JIT 컴파일러를 프로파일 링하지 않으려는 경우 프로파일 링하려는 코드를 최소한 한 번 이상 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">Julia 문서 자체의 다른 문서화 된 함수 / 메소드 / 변수에 상호 참조를 추가 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">항목이 생성 될 때마다 자체 휴식 반복자가되도록 돌연변이하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">예를 들어 이것을 가장 쉽게 설명 할 수 있습니다. 생성 된 함수 &lt;code&gt;foo&lt;/code&gt; 를 다음 과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ecf0f0b27cffd70c113f40a095f8c8f53901430" translate="yes" xml:space="preserve">
          <source>It's far less clear what should happen here. Since &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; is a method error, it seems probable that the intention is for &lt;code&gt;x&lt;/code&gt; to be local to the &lt;code&gt;for&lt;/code&gt; loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia &amp;le; 0.6 behavior, it's especially concerning that someone might have written the &lt;code&gt;for&lt;/code&gt; loop first, had it working just fine, but later when someone else adds a new global far away&amp;mdash;possibly in a different file&amp;mdash;the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;&quot;spooky action at a distance&quot;&lt;/a&gt; is something that good programming language designs should prevent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">처리해야 할 &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;까다로운 문제&lt;/a&gt; 가 있기 때문에 날짜 / 날짜 산술을 처리하는 방법에 익숙해 지려면 언어 / 날짜 프레임 워크를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">유효하지 않은 UTF-8 문자열 연결과 같은 잠재적으로 위험한 상황을 인식하는 것이 중요합니다. 결과 문자열은 입력 문자열과 다른 문자를 포함 할 수 있으며 해당 문자 수는 연결된 문자열의 문자 수의 합보다 작을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">이러한 전환 실적에는 비대칭 성이 매우 크다는 점에 유의해야합니다. 선형 인덱스를 데카르트 인덱스 세트로 변환하려면 나머지를 나누고 가져 가야하지만, 다른 방법으로는 곱하고 추가합니다. 최신 프로세서에서 정수 나누기는 곱셈보다 10-50 배 느릴 수 있습니다. &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 자체 와 같은 일부 배열 은 선형 메모리 청크를 사용하여 구현되고 구현에서 선형 인덱스를 직접 사용하지만 &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt; 과 같은 다른 배열 은 조회를 수행하기 위해 전체 직교 인덱스 집합이 필요합니다 (인덱스를 참조하려면 &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt; 참조 ). 어느). 따라서 전체 배열을 반복 할 때 각 &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt; 대신 반복하는 것이 훨씬 좋습니다. &lt;code&gt;1:length(A)&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;IndexCartesian&lt;/code&gt; 인 경우 전자가 훨씬 빠를 뿐만 아니라 OffsetArray도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ae198b8fe13fc0c80ed5149210f17463c0121d1" translate="yes" xml:space="preserve">
          <source>It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug it&amp;mdash;you have to add &lt;code&gt;global&lt;/code&gt; annotations and then remove them again to go back;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">그것은와 샘플러를 얻기 위해 지금 가능 &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; , 사용의 &lt;code&gt;sp&lt;/code&gt; 대신 &lt;code&gt;die&lt;/code&gt; 어떤에서 &lt;code&gt;rand&lt;/code&gt; 와 관련된 전화 &lt;code&gt;rng&lt;/code&gt; . 위의 간단한 예에서, &lt;code&gt;die&lt;/code&gt; 는 &lt;code&gt;SamplerDie&lt;/code&gt; 에 저장 될 필요 는 없지만 실제로는 종종 그러합니다.</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">간단한 함수를 위해 생성 된 순전히 코드를 비교하는 것은 매우 유익합니다.</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">&lt;code&gt;localindices&lt;/code&gt; 는 순전히 편의상 존재 한다는 점을 강조 할 가치가 있으며 원하는 방식으로 작업자간에 배열 작업을 분할 할 수 있습니다. A의 &lt;code&gt;SharedArray&lt;/code&gt; , 모든 인덱스는 동등하게 빨리 각 작업자 프로세스해야한다.</target>
        </trans-unit>
        <trans-unit id="948d6de7c32c1a31093f07d2e218322318e4b407" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read &lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;the more extensive discussion in the performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; 을 포함하여 파라 메트릭 &quot;값&quot;유형을 잘못 사용하는 것이 매우 쉽다는 점은 주목할 가치가 있습니다 . 바람직하지 않은 경우에는 코드 성능이 훨씬 &lt;em&gt;나빠질 수&lt;/em&gt; 있습니다. 특히, 위에서 설명한 실제 코드를 작성하고 싶지 않을 것입니다. &lt;code&gt;Val&lt;/code&gt; 의 올바른 (부적절한) 사용에 대한 자세한 내용은 &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 에서 더 광범위한 토론을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">반복 가능한 컬렉션</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">한 번에 &lt;code&gt;n&lt;/code&gt; 개의 요소를 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">반복 발송</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">&lt;code&gt;axes(::Broadcasted)&lt;/code&gt; 의 &lt;code&gt;CartesianIndices&lt;/code&gt; 를 반복 하고 결과 &lt;code&gt;CartesianIndex&lt;/code&gt; 객체 와 함께 인덱싱 을 사용하여 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 &lt;code&gt;F.S&lt;/code&gt; , &lt;code&gt;F.T&lt;/code&gt; , &lt;code&gt;F.Q&lt;/code&gt; , &lt;code&gt;F.Z&lt;/code&gt; , &lt;code&gt;F.&amp;alpha;&lt;/code&gt; 및 &lt;code&gt;F.&amp;beta;&lt;/code&gt; 성분이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 구성 요소 &lt;code&gt;F.T&lt;/code&gt; , &lt;code&gt;F.Z&lt;/code&gt; 및 &lt;code&gt;F.values&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 구성 요소 &lt;code&gt;F.values&lt;/code&gt; 및 &lt;code&gt;F.vectors&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 성분 &lt;code&gt;Q&lt;/code&gt; 및 &lt;code&gt;R&lt;/code&gt; 이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 성분 &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 성분 &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; 및 존재하는 &lt;code&gt;p&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 &lt;code&gt;S.uplo&lt;/code&gt; 및 &lt;code&gt;S.p&lt;/code&gt; 따라 구성 요소 &lt;code&gt;S.D&lt;/code&gt; , &lt;code&gt;S.U&lt;/code&gt; 또는 &lt;code&gt;S.L&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 구성 요소 &lt;code&gt;S.L&lt;/code&gt; 및 &lt;code&gt;S.Q&lt;/code&gt; 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 성분 &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 성분 &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;Q&lt;/code&gt; , &lt;code&gt;D1&lt;/code&gt; , &lt;code&gt;D2&lt;/code&gt; 및 &lt;code&gt;R0&lt;/code&gt; 이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="58ad8afd3ef50f0b4cdfded417b61d5f6036a1c3" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">분해를 반복하면 요인 &lt;code&gt;F.Q&lt;/code&gt; 및 &lt;code&gt;F.H&lt;/code&gt; 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">인수 분해를 반복하면 구성 요소 &lt;code&gt;F.L&lt;/code&gt; , &lt;code&gt;F.U&lt;/code&gt; 및 &lt;code&gt;F.p&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; 을 반복 하면 이름이없는 &lt;em&gt;값이&lt;/em&gt; 생성 됩니다. (아래 예 참조) 이름-값 쌍을 반복하려면 &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">반복 유틸리티</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;jl_value_t*&lt;/code&gt; 인수 의 배열 이고 &lt;code&gt;nargs&lt;/code&gt; 는 인수 수입니다.</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">이자카야 랜턴</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="translated">JR Bunch 및 L Kaufman, 관성 계산을위한 안정적인 방법</target>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">일본 성</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">일본 인형</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="translated">일본 고블린</target>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="translated">일본 오우거</target>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">일본 우체국</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">초보자를위한 일본어 기호</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="3b3813dad3290588a2d14e75a092fcd63a072388" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter (if any) between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; 배열을 단일 문자열 로 결합하여 인접한 문자열 사이에 주어진 구분자를 삽입하십시오. 경우 &lt;code&gt;last&lt;/code&gt; 주어집니다, 그것은 대신 사용됩니다 &lt;code&gt;delim&lt;/code&gt; 마지막 두 문자열 사이. 경우 &lt;code&gt;io&lt;/code&gt; 주어, 그 결과에 기록됩니다 &lt;code&gt;io&lt;/code&gt; 보다는 등으로 반환 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">경로 구성 요소를 전체 경로로 결합하십시오. 일부 인수가 절대 경로이거나 (Windows의 경우) 이전 경로의 결합에 대해 계산 된 드라이브와 일치하지 않는 드라이브 스펙이있는 경우 이전 구성 요소가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">줄리아 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">줄리아 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Julia 1.2 설명서</target>
        </trans-unit>
        <trans-unit id="735bc5320f837b1441f2cfffa31dd786468645d6" translate="yes" xml:space="preserve">
          <source>Julia 1.5 Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">줄리아 기본 유형</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Base에는 과학 및 수치 계산을 수행하는 데 적합한 다양한 기능과 매크로가 포함되어 있지만 많은 범용 프로그래밍 언어의 기능과 마찬가지로 광범위합니다. 사용 가능한 패키지 모음에서 추가 기능을 사용할 수 있습니다. 기능은 아래 주제별로 그룹화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">줄리아 자료는 전체에이 규칙을 사용하고 모두 복사 및 수정 형태와 기능의 예를 포함 (예를 들면, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; ) 그냥 수정하는 다른 사람 (예를 들어, &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt; ). 이러한 함수는 편의상 수정 된 배열을 반환하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">줄리아 코 루틴 (그린 스레딩)</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">Julia GPU 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">줄리아 출시</target>
        </trans-unit>
        <trans-unit id="799d12425163528cdf3dbdb65e3972da06d0f30c" translate="yes" xml:space="preserve">
          <source>Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer processes, and similar patterns. Tasks can synchronize through operations like &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch&lt;/code&gt;, and communicate via &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">Julia는 전례없는 단일 언어로 사용 편의성, 기능 및 효율성을 결합시키는 것을 목표로합니다. 위의 것 외에도 Julia는 비교 가능한 시스템에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">Julia는 쉼표가 코드의 의미를 변경하지 않는 경우 선택적 후행 쉼표를 허용합니다. 배열로 인덱싱 할 때 R 사용자간에 혼동을 일으킬 수 있습니다. 예를 들어, R의 &lt;code&gt;x[1,]&lt;/code&gt; 은 행렬의 첫 번째 행을 반환합니다. 그러나 Julia에서는 쉼표가 무시되므로 &lt;code&gt;x[1,] == x[1]&lt;/code&gt; 이며 첫 번째 요소를 반환합니다. 행을 추출하려면 &lt;code&gt;x[1,:]&lt;/code&gt; 에서와 같이 &lt;code&gt;:&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Julia는 또한 &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;UInt&lt;/code&gt; 유형을 정의 하는데 , 이는 시스템의 부호있는 원시 정수 유형 및 부호없는 원시 정수 유형의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Julia는 또한 문자열 연결을 위해 &lt;code&gt;*&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Julia는 &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; &lt;/a&gt; 함수를 제공하여 다음으로 가장 큰 또는 가장 작은 표현 가능한 부동 소수점 숫자를 각각 인수에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Julia는 또한 &lt;a href=&quot;#man-multithreading-1&quot;&gt;실험적인 멀티 스레딩을&lt;/a&gt; 지원하며 , 여기서 실행은 중단되고 익명 함수는 모든 스레드에서 실행됩니다. 포크-조인 방식으로 알려진 병렬 스레드는 독립적으로 실행되며 궁극적으로 직렬 실행을 계속하려면 Julia의 기본 스레드에 연결되어야합니다. Julia는 아직 완전히 스레드 안전하지 않기 때문에 여전히 실험적인 것으로 간주 되는 &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 다중 스레딩이 지원됩니다 . 특히 segfault는 I / O 작업 및 작업 전환 중에 발생하는 것으로 보입니다. 최신 참조 자료로 &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;이슈 트래커를&lt;/a&gt; 주시 하십시오 . 다중 스레딩은 전역 변수, 잠금 및 원자를 고려한 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">Julia와 C는 복사하지 않고 어레이 데이터를 공유 할 수 있습니다. 다음 예제는 이것이 어떻게 작동하는지 보여줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia와 패키지 에코 시스템에는 문제를 진단하고 코드 성능을 향상시키는 데 도움이되는 도구가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">Julia는 가장 높은 우선 순위에서 가장 낮은 순서로 다음 순서와 연산의 연관성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a2d556e852ab5ec005eba2ee374bde91855e354e" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia 배열은 열 주요 (Fortran 순서)이지만 C / C ++ 배열은 기본적으로 행 주요 순서입니다. 배열을 반복 할 때 최적의 성능을 얻으려면 Julia에서 C / C ++에 비해 루프 순서를 반대로해야합니다 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁의&lt;/a&gt; 관련 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="c5aee379485d3e8989f69a590d396666e706c30b" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia 배열은 열 주요 (Fortran 순서)이지만 NumPy 배열은 기본적으로 행 주요 (C 순서)입니다. 배열을 반복 할 때 최적의 성능을 얻으려면 Julia에서 NumPy를 기준으로 루프 순서를 바꿔야합니다 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁의&lt;/a&gt; 관련 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Julia 배열은 대괄호 &lt;code&gt;A[i,j]&lt;/code&gt; 로 색인됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Julia 배열은 대괄호로 색인화되며 &lt;code&gt;A[i,j]&lt;/code&gt; 차원을 둘 이상 가질 수 있습니다 . 이 구문은 C / C ++에서와 같이 포인터 나 주소에 대한 참조를위한 구문 설탕이 아닙니다. 배열 구성 구문에 대해서는 Julia 설명서를 참조하십시오 (버전마다 변경됨).</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">Julia 변수는 다른 변수에 할당 될 때 복사되지 않습니다. &lt;code&gt;A = B&lt;/code&gt; 이후 에 &lt;code&gt;B&lt;/code&gt; 의 요소를 변경 하면 &lt;code&gt;A&lt;/code&gt; 도 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">Julia 변수는 다른 변수에 할당 될 때 복사되지 않습니다. &lt;code&gt;A = B&lt;/code&gt; 이후 에 &lt;code&gt;B&lt;/code&gt; 의 요소를 변경 하면 &lt;code&gt;A&lt;/code&gt; 도 수정 됩니다. &lt;code&gt;+=&lt;/code&gt; 와 같은 업데이트 연산자 는 제자리에서 작동하지 않으며 &lt;code&gt;A = A + B&lt;/code&gt; 와 같습니다.이 연산자 는 왼쪽을 오른쪽 식의 결과에 리 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Julia 배열은 C에서 &lt;code&gt;jl_array_t*&lt;/code&gt; 데이터 유형으로 표시됩니다 . 기본적으로 &lt;code&gt;jl_array_t&lt;/code&gt; 는 다음을 포함하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Julia는 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; 함수 에 대한 호출을 자동으로 삽입하여 각 인수를 지정된 유형으로 변환합니다. 예를 들어 다음과 같은 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Julia는 쉘, Perl 및 Ruby에서 명령에 대한 백틱 표기법을 빌립니다. 그러나 줄리아에서는</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Julia는 여러 환경 변수로 구성 할 수 있으며 각 운영 체제에 대해 일반적인 방식으로 설정하거나 Julia 내에서 이식 가능한 방식으로 설정할 수 있습니다. 환경 변수 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; 를 &lt;code&gt;vim&lt;/code&gt; 으로 설정하려는 경우 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (예 : REPL)을 입력하여 상황에 따라이 변경을 수행하거나 다음과 같이 추가 할 수 있습니다. 사용자의 홈 디렉토리에 있는 사용자 구성 파일 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 은 영구적 인 영향을 미칩니다. &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; 를 평가하여 동일한 환경 변수의 현재 값을 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">Julia는 &lt;code&gt;-p&lt;/code&gt; 또는 &lt;code&gt;--machine-file&lt;/code&gt; 옵션 을 사용하여 병렬 모드에서 시작할 수 있습니다 . &lt;code&gt;-p n&lt;/code&gt; 은 추가 &lt;code&gt;n&lt;/code&gt; 작업자 프로세스 를 시작하는 반면 &lt;code&gt;--machine-file file&lt;/code&gt; 은 file file의 각 줄에 대해 작업자를 시작 &lt;code&gt;file&lt;/code&gt; . Julia는 현재 호스트와 동일한 위치에 설치되어 있으며 비밀번호가없는 &lt;code&gt;ssh&lt;/code&gt; 로그인을 통해 &lt;code&gt;file&lt;/code&gt; 정의 된 시스템에 액세스 할 수 있어야합니다 . 각 기계 정의는 &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; 형식을 취합니다 . &lt;code&gt;user&lt;/code&gt; 는 기본적으로 현재 사용자, &lt;code&gt;port&lt;/code&gt; 는 표준 ssh 포트입니다. &lt;code&gt;count&lt;/code&gt; 선택적인 &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; 는 다른 워커가이 워커에 연결하기 위해 사용해야하는 IP 주소와 포트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Julia는 문자열을 색인화하여 하위 문자열을 작성할 수 있습니다. R에서 하위 문자열을 만들기 전에 문자열을 문자형 벡터로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Julia는 여러 명령을 병렬로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Julia는 대입 조작의 왼쪽에있는 함수 호출 결과에 대입 할 수 없습니다. &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; 쓸 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Julia 클러스터는 로컬 랩톱, 부서별 클러스터 또는 클라우드와 같은 인프라의 이미 보안 된 환경에서 실행되도록 설계되었습니다. 이 섹션에서는 내장 &lt;code&gt;LocalManager&lt;/code&gt; 및 &lt;code&gt;SSHManager&lt;/code&gt; 에 대한 네트워크 보안 요구 사항에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Julia 코드는 예외를 던질 수 있습니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Julia에는 &lt;code&gt;julia&lt;/code&gt; 실행 파일에 내장 된 완전한 기능을 갖춘 대화식 명령 줄 REPL (읽기 평가판 인쇄 루프)이 제공됩니다 . Julia 명령문을 빠르고 쉽게 평가할 수있을뿐만 아니라 검색 가능한 히스토리, 탭 완성, 많은 유용한 키 바인딩 및 전용 도움말 및 쉘 모드가 있습니다. 인수없이 &lt;code&gt;julia&lt;/code&gt; 를 호출 하거나 실행 파일을 두 번 클릭하여 REPL을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">Julia는 현재 &lt;code&gt;8&lt;/code&gt; (또는 코어 수)에 스레드가있는 자체 OpenBLAS 사본을 컴파일하고 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">Julia는 대괄호를 사용하여 벡터를 생성합니다. Julia의 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 은 R의 &lt;code&gt;c(1, 2, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">Julia는 기본 네임 스페이스를 함수로 채우는 것을 권장하지 않습니다. Julia의 통계 기능은 대부분 &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats 조직의 &lt;/a&gt;&lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;패키지&lt;/a&gt; 에서 찾을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">Julia는 세미콜론을 사용하여 진술을 끝내는 것을 권장하지 않습니다. 명령문의 결과는 대화식 프롬프트를 제외하고 자동으로 인쇄되지 않으며 코드 행은 세미콜론으로 끝날 필요가 없습니다. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 출력을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Julia는 할당 문에서 배열을 자동으로 확장하지 않습니다. MATLAB에서 &lt;code&gt;a(4) = 3.2&lt;/code&gt; 는 배열 &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; 만들 수 있고 &lt;code&gt;a(5) = 7&lt;/code&gt; 은 &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; 으로 성장할 수 있지만 해당 Julia 문 &lt;code&gt;a[5] = 7&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 의 길이 가 5 미만이거나이 명령문이 식별자 &lt;code&gt;a&lt;/code&gt; 의 첫 번째 사용 인 경우 = 7 은 오류를 발생시킵니다 . 줄리아가 &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; 그리고 &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt; 는 MATLAB의 &lt;code&gt;a(end+1) = val&lt;/code&gt; 보다 훨씬 효율적으로 &lt;code&gt;Vector&lt;/code&gt; 를 성장 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">Julia에게는 MATLAB의 &lt;code&gt;clear&lt;/code&gt; 기능에 대한 아날로그가 없습니다 . Julia 세션 (기술적으로 &lt;code&gt;Main&lt;/code&gt; 모듈에서)에 이름이 정의되면 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">Julia는 &lt;code&gt;nrow&lt;/code&gt; 와 &lt;code&gt;ncol&lt;/code&gt; 을 제공하지 않습니다 . 대신 사용 &lt;code&gt;size(M, 1)&lt;/code&gt; 에 대한 &lt;code&gt;nrow(M)&lt;/code&gt; 및 &lt;code&gt;size(M, 2)&lt;/code&gt; 용 &lt;code&gt;ncol(M)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">쓰는 줄리아 괄호를 필요로하지 않는 &lt;code&gt;if&lt;/code&gt; 문이나 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 루프 : 사용 &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 이 아닌 &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; 과 &lt;code&gt;if i == 1&lt;/code&gt; 아닌 &lt;code&gt;if (i == 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Julia는 &lt;code&gt;if&lt;/code&gt; 문 또는 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 루프 를 작성할 때 괄호를 요구하지 않습니다 . &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; 대신 &lt;code&gt;if i == 1&lt;/code&gt; 대신 &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 사용 하고 i == 1 인 경우 &lt;code&gt;if (i == 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">Julia는 명령문을 끝내기 위해 세미콜론을 사용할 필요가 없습니다. 표현식 결과는 대화식 프롬프트 (예 : REPL 제외)를 제외하고 자동으로 인쇄되지 않으며 코드 줄은 세미콜론으로 끝나지 않아도됩니다. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 출력을 인쇄 할 수 있습니다. REPL에서 &lt;code&gt;;&lt;/code&gt; 출력을 억제하는 데 사용할 수 있습니다. &lt;code&gt;;&lt;/code&gt; 또한 &lt;code&gt;[ ]&lt;/code&gt; 내에서 다른 의미를 가지므로주의 해야합니다. &lt;code&gt;;&lt;/code&gt; 한 줄에 식을 구분하는 데 사용할 수 있지만 많은 경우에 꼭 필요한 것은 아니며 가독성을 높이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">Julia는 음수 인덱스를 지원하지 않습니다. 특히,리스트 나 배열의 마지막 요소는 파이썬 에서처럼 &lt;code&gt;-1&lt;/code&gt; 이 아니라 Julia에서 &lt;code&gt;end&lt;/code&gt; 로 색인됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Julia는 &lt;code&gt;NULL&lt;/code&gt; 유형을 지원하지 않습니다 . 가장 가까운 것은 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 아니지만 목록처럼 스칼라 값처럼 동작합니다. &lt;code&gt;is.null(x)&lt;/code&gt; 대신 &lt;code&gt;x === nothing&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">Julia는 숫자 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 을 부울로 취급하지 않습니다 . &lt;code&gt;if&lt;/code&gt; 문은 부울 만 허용 하므로 Julia에서 &lt;code&gt;if (1)&lt;/code&gt; 을 쓸 수 없습니다 . 대신 &lt;code&gt;if true&lt;/code&gt; , &lt;code&gt;if Bool(1)&lt;/code&gt; 또는 &lt;code&gt;if 1==1&lt;/code&gt; 인 경우 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">Julia는 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; 의 조건 주위에 parens를 요구하지 않습니다 . 쓰다:</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">Julia는 패키지 개발자와 사용자가 Julia 0.4부터 내장 문서 시스템을 통해 기능, 유형 및 기타 객체를 쉽게 문서화 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">줄리아 S3 또는 S4 R. 줄리아의 여러 파견 시스템 수단에 객체를보다 사용하기 쉽게 자신의 유형을 작성하는 사용자를 장려하는 &lt;code&gt;table(x::TypeA)&lt;/code&gt; 와 &lt;code&gt;table(x::TypeB)&lt;/code&gt; R의 같은 행동 &lt;code&gt;table.TypeA(x)&lt;/code&gt; 및 &lt;code&gt;table.TypeB(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">Julia는 함수가 정의 될 때 기본값이 한 번만 평가되는 Python과 달리 메소드가 호출 될 때마다 함수 인수의 기본값을 평가합니다. 예를 들어, 함수 &lt;code&gt;f(x=rand()) = x&lt;/code&gt; 는 인수없이 호출 될 때마다 새로운 난수를 반환합니다. 반면에 &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; 함수 는 &lt;code&gt;g()&lt;/code&gt; 로 호출 될 때마다 &lt;code&gt;[1,2,3]&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Julia는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM을&lt;/a&gt; 사용하여 구현 된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;JIT (&lt;/a&gt; Type Inference and Just-In-Time) 컴파일을 사용하여 선택적인 타이핑, 다중 디스패치 및 우수한 성능을 제공 합니다. 명령형, 기능성 및 객체 지향 프로그래밍 기능을 결합한 다중 패러다임입니다. Julia는 R, MATLAB 및 Python과 같은 언어와 같은 방식으로 높은 수준의 수치 계산을위한 용이성과 표현성을 제공하지만 일반 프로그래밍도 지원합니다. 이를 달성하기 위해 Julia는 수학 프로그래밍 언어의 계보를 기반으로하지만 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby를&lt;/a&gt; 포함하여 널리 사용되는 동적 언어에서 많은 부분을 차용 합니다.</target>
        </trans-unit>
        <trans-unit id="20fa6f6d170887fa888519e147a5de3f67149aab" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">Julia는 유니 코드 문자 및 문자열을 완벽하게 지원합니다. 마찬가지로 &lt;a href=&quot;#man-characters-1&quot;&gt;상술&lt;/a&gt; 문자 리터럴에서 유니 코드 코드 포인트가 유니 코드를 이용하여 표현 될 수 &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; 이스케이프 시퀀스뿐만 아니라 모든 표준 C 이스케이프 시퀀스. 이것들은 문자열 리터럴을 쓰는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Julia 함수 인수는 때때로 &quot;공유로 전달&quot;이라는 규칙을 따릅니다. 즉, 함수에 전달 될 때 값이 복사되지 않습니다. 함수 인수 자체는 새로운 변수 &lt;em&gt;바인딩&lt;/em&gt; (값을 참조 할 수있는 새로운 위치)으로 작동하지만 참조되는 값은 전달 된 값과 동일합니다. 함수 내 에서 변경 가능한 값 (예 : &lt;code&gt;Array&lt;/code&gt; )을 수정하면 호출자가 볼 수 있습니다. 이것은 다른 동적 언어 중에서 Scheme, 대부분의 Lisp, Python, Ruby 및 Perl에서 발견되는 것과 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">Julia는 &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; 라이브러리에서 제공하는 Perl 호환 정규식 (정규식)을 가지고 있습니다 (구문에 대한 설명은 &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;여기 참조&lt;/a&gt; ). 정규 표현식은 두 가지 방식으로 문자열과 관련됩니다. 명백한 연결은 정규 표현식을 사용하여 문자열에서 정규 패턴을 찾는 것입니다. 다른 연결은 정규식 자체가 문자열로 입력되는 것이며, 문자열에서 패턴을 효율적으로 검색하는 데 사용할 수있는 상태 머신으로 구문 분석됩니다. Julia에서는 정규식이 &lt;code&gt;r&lt;/code&gt; 로 시작하는 다양한 식별자가 접두사가 아닌 비표준 문자열 리터럴을 사용하여 입력됩니다 . 옵션이 설정되지 않은 가장 기본적인 정규 표현식 리터럴은 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">Julia에는 함수 인수 및 반환 값과 밀접한 관련이 있는 &lt;em&gt;튜플&lt;/em&gt; 이라는 내장 데이터 구조 가 있습니다. 튜플은 임의의 값을 보유 할 수 있지만 수정할 수없는 고정 길이 컨테이너입니다 ( &lt;em&gt;불변&lt;/em&gt; ). 튜플은 쉼표와 괄호로 구성되며 색인을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Julia에는 정수의 정확한 비율을 나타내는 합리적인 숫자 유형이 있습니다. 이론은 &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f16da71d7eefd561befb9a12573735daa1e67ea2" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">Julia에는 스칼라 함수를 &quot;벡터화 된&quot;함수 호출로 변환하고 모든 연산자를 &quot;벡터화 된&quot;연산자로 변환 하는 특수한 &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;점 구문&lt;/a&gt; 이 있습니다. 중첩 된 &quot;점 호출&quot;이 &lt;em&gt;융합&lt;/em&gt; 된 특수 특성을 사용 하면 구문 레벨에서 다음과 같이 결합됩니다. 임시 배열을 할당하지 않고 단일 루프. 당신이 사용하는 경우 &lt;code&gt;.=&lt;/code&gt; 및 이와 유사한 대입 연산자, 결과는 자리에서 미리 할당 된 배열에 저장할 수 있습니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">Julia에는 &lt;code&gt;Val{::Int}&lt;/code&gt; 인스턴스를 두 번째 매개 변수로 허용 하는 특수 버전의 &lt;code&gt;ntuple&lt;/code&gt; 이 있습니다 . &lt;code&gt;N&lt;/code&gt; 을 형식 매개 변수로 전달 하면 컴파일러에서 &quot;값&quot;을 알 수 있습니다. 결과적으로이 버전의 &lt;code&gt;array3&lt;/code&gt; 을 사용하면 컴파일러가 반환 유형을 예측할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dbaaf5104fbb919890d9bf95a666a5ce54dc8a0" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Julia는 수학 연산자의 인수를 공통 유형으로 승격시키는 시스템을 가지고 있으며, &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;정수 및 부동 소수점 숫자&lt;/a&gt; , &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;수학 연산 및 기본 함수&lt;/a&gt; , &lt;a href=&quot;../types/index#man-types-1&quot;&gt;유형&lt;/a&gt; 및 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;메소드를&lt;/a&gt; 포함한 다양한 섹션에서 언급되었습니다 . 이 섹션에서는이 프로모션 시스템의 작동 방식과 새로운 유형으로 확장하고 내장 수학 연산자 이외의 함수에 적용하는 방법에 대해 설명합니다. 전통적으로 프로그래밍 언어는 산술 인수 홍보와 관련하여 두 가지 캠프로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">Julia에는 &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; 매크로를 사용하여 표현 된 열거 유형이 있습니다. 예 : &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Julia에는 이미 정렬 된 값 배열을 정렬하고 상호 작용하기위한 광범위하고 유연한 API가 있습니다. 기본적으로 Julia는 합리적인 알고리즘을 선택하고 표준 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">Julia는 줄 연속 구문이 없습니다. 줄 끝에서 입력이 완전한 표현식이면 완료된 것으로 간주됩니다. 그렇지 않으면 입력이 계속됩니다. 식이 계속되도록하는 한 가지 방법은 괄호로 묶는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia에는 인수를 변경하는 몇 가지 기능이 있습니다. 예를 들어, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; 이 모두 있습니다 ! .</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">Julia는 &lt;code&gt;SparseArrays&lt;/code&gt; stdlib 모듈 에서 희소 벡터와 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;희소 행렬&lt;/a&gt; 을 지원 합니다. 희소 배열은 특정 데이터 구조에 저장하기에 충분한 제로를 포함하는 배열로 밀도가 높은 배열에 비해 공간 및 실행 시간을 절약합니다.</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">Julia는 진정한 1 차원 배열을 가지고 있습니다. 열 벡터의 크기는 &lt;code&gt;Nx1&lt;/code&gt; 이 아니라 &lt;code&gt;N&lt;/code&gt; 입니다. 예를 들어, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt; 은 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">Julia에는 코드를로드하는 두 가지 메커니즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">Julia에는 오른쪽 시프트 연산자 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 있습니다. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 산술 시프트를 수행하고 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; C / C ++와 달리 항상 논리 시프트를 수행합니다. 여기서 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 의 의미는 시프트되는 값의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">줄리아 식별자와 코드 발췌는 항상 강조 표시를 위해 백틱 ( &lt;code&gt;`&lt;/code&gt; ) 사이에 나타나야 합니다. LaTeX 구문의 방정식은 이중 백틱 &lt;code&gt;``&lt;/code&gt; 사이에 삽입 할 수 있습니다 . LaTeX 이스케이프 시퀀스 대신 유니 코드 문자를 사용하십시오 (예 : &lt;code&gt;``\\alpha = 1``&lt;/code&gt; 대신 &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; '') .</target>
        </trans-unit>
        <trans-unit id="ad9eda654d6c5b8e4f3d947e9256ba07cba9012f" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Julia는 복소수와 유리수 모두에 대해 사전 정의 된 유형을 포함하며 모든 표준 &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;수학 연산 및 기본 함수&lt;/a&gt; 를 지원합니다. 원시 및 복합에 관계없이 사전 정의 된 숫자 유형의 조합에 대한 조작이 예상대로 작동하도록 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;변환 및 승격&lt;/a&gt; 이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">사전 컴파일 된 바이너리를 사용하든 소스에서 컴파일하든 Julia 설치는 간단합니다. &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt; 의 지침에 따라 Julia를 다운로드하여 설치 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">Julia는 스칼라, 벡터 및 행렬을 구별하기 위해주의합니다. R에서 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;c(1)&lt;/code&gt; 은 동일합니다. Julia에서는 서로 바꿔 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Julia는 열심히 평가되며 R 스타일 지연 평가를 지원하지 않습니다. 대부분의 사용자에게 이것은 인용되지 않은 표현식이나 열 이름이 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Julia는 빠른 개발 단계에 있으며 여러 플랫폼에서 기능을 검증 할 수있는 광범위한 테스트 스위트를 보유하고 있습니다. 소스에서 Julia를 빌드하는 경우 &lt;code&gt;make test&lt;/code&gt; 로이 테스트 스위트를 실행할 수 있습니다 . 바이너리 설치에서는 &lt;code&gt;Base.runtests()&lt;/code&gt; 사용하여 테스트 스위트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">Julia &lt;code&gt;get&lt;/code&gt; R의 &lt;code&gt;assign&lt;/code&gt; 또는 get 과 같은 기능이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Julia 매크로는 프로그램의 텍스트가 아닌 구문 분석 된 표현식에서 작동하므로 Julia 코드의 정교한 변환을 수행 할 수 있습니다. 매크로 이름은 &lt;code&gt;@&lt;/code&gt; 문자로 시작하며 &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; 구문 @mymacro (arg1, arg2, arg3) 과 명령 &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; 구문 @mymacro arg1 arg2 arg3이 있습니다. 양식은 서로 바꿔 사용할 수 있습니다. 함수와 유사한 형식은 매크로가 다른 표현식 내에 나타날 때 특히 유용하며 종종 가장 명확합니다. 문처럼 형태가 종종 같이 주석 블록에 사용되는 분산 &lt;code&gt;for&lt;/code&gt; 구문 : &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; . 매크로 구문의 끝이 명확하지 않은 경우 함수와 유사한 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Julia는 &lt;code&gt;transpose&lt;/code&gt; 함수를 사용하여 행렬 전치 와 &lt;code&gt;'&lt;/code&gt; 연산자 또는 &lt;code&gt;adjoint&lt;/code&gt; 함수를 사용하여 켤레 전치를 수행합니다. 따라서 Julia의 &lt;code&gt;transpose(A)&lt;/code&gt; 는 R의 &lt;code&gt;t(A)&lt;/code&gt; . 또한 Julia의 &lt;code&gt;permutedims&lt;/code&gt; 귀적 전치가 순열 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Julia는 &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 를 제공하여 &lt;code&gt;1.0&lt;/code&gt; 과 다음으로 큰 다음 부동 소수점 값 사이의 거리를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">Julia는 이 문제를 해결하기위한 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 메커니즘을 제공합니다 . &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 때 Waitable가 선입 선출 큐 여러 작업에서 읽고 그것을 쓰기를 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="476c4c45db4a5f4592324ce839944c2c37cd8d0a" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Julia는 광범위한 기본 숫자 유형을 제공하며 표준 수학 함수뿐만 아니라 모든 산술 및 비트 연산자를 보완합니다. 이는 최신 컴퓨터에서 기본적으로 지원되는 숫자 유형 및 작업에 직접 매핑되므로 Julia는 계산 리소스를 최대한 활용할 수 있습니다. 또한 Julia는 &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic에&lt;/a&gt; 대한 소프트웨어 지원을 제공 하여 기본 하드웨어 표현에서는 효과적으로 표현할 수 없지만 성능이 상대적으로 느려진 숫자 값에 대한 작업을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Julia는 모든 숫자 기본 유형에 대한 기본 산술 및 비트 연산자의 전체 모음을 제공 할뿐만 아니라 포괄적 인 표준 수학 함수 모음의 이식 가능하고 효율적인 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Julia는 포괄적 인 수학 함수 및 연산자 모음을 제공합니다. 이러한 수학적 연산은 정수, 부동 소수점 수, 유리수 및 복소수를 포함하여 의미있는 정의를 허용하는 넓은 범위의 숫자 값으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">줄리아는 예약어 제공 &lt;code&gt;do&lt;/code&gt; 더 명확하게이 코드를 다시 작성을 위해 :</target>
        </trans-unit>
        <trans-unit id="657c78188298a00e823c4644aeb3647f8f14a312" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Julia는 터미널, 파이프 및 TCP 소켓과 같은 스트리밍 I / O 객체를 처리 할 수있는 풍부한 인터페이스를 제공합니다. 이 인터페이스는 시스템 수준에서 비동기식이지만 프로그래머에게 동기식으로 표시되며 기본 비동기 작업에 대해 생각할 필요가 없습니다. 이는 Julia 협업 스레딩 ( &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;코 루틴&lt;/a&gt; ) 기능 을 많이 사용함으로써 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Julia는 다양한 제어 흐름 구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Julia는 특수 값에 대한 숫자를 테스트하기위한 추가 함수를 제공하며, 이는 해시 키 비교와 같은 상황에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Julia는 변수 이름 지정을위한 매우 유연한 시스템을 제공합니다. 변수 이름은 대소 문자를 구분하며 의미 적 의미가 없습니다 (즉, 언어는 이름에 따라 변수를 다르게 처리하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Julia는 &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; &lt;/a&gt; 라고하는 홀수 및 짝수 를 테스트 할 수있는 내장 된 효율적인 기능을 제공 하므로 위의 정의는 효율적인 디자인이 아니라 범위의 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Julia는 지정된 유형 또는 주어진 변수의 유형에 해당하는 리터럴 0과 1을 리턴하는 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Julia는 통계적 의미에서 결 측값을 나타내는 기능을 지원합니다. 즉, 관측치에서 변수에 값을 사용할 수 없지만 이론적으로 유효한 값이 존재하는 상황입니다. 누락 값 비아 표현 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 타입의 단일 인스턴스 인 객체 &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;missing&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;SQL의 &lt;/a&gt; &lt;code&gt;NULL&lt;/code&gt; 및 &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;R의 &lt;/a&gt; &lt;code&gt;NA&lt;/code&gt; 와 동일 하며 대부분의 상황 에서처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Julia는 튜플과 실제 해시 테이블을 제공하지만 R 스타일 목록은 제공하지 않습니다. 여러 항목을 반환 할 때는 일반적으로 &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; 대신 튜플 또는 명명 된 튜플을 사용해야합니다. &lt;code&gt;(1, 2)&lt;/code&gt; 또는 &lt;code&gt;(a=1, b=2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Julia는 두 개의 내장 클러스터 관리자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46d26e39331065ec318009a2e11c1e691fbfaee6" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; for indexing until the last element. &lt;code&gt;x[1:]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[2:end]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">Julia 는 블록을 끝내기 위해 &lt;code&gt;end&lt;/code&gt; 을 요구합니다 . Python과 달리 Julia에는 &lt;code&gt;pass&lt;/code&gt; 키워드 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">Julia는 새 코드를로드해야합니다. 테스트 해보자.</target>
        </trans-unit>
        <trans-unit id="50af488570ea82992b042e6982e9d5b39f404c93" translate="yes" xml:space="preserve">
          <source>Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Julia는 &lt;em&gt;원자 적으로&lt;/em&gt; , 즉 &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;경쟁 조건&lt;/a&gt; 을 피하기 위해 스레드로부터 안전한 방식 &lt;em&gt;으로&lt;/em&gt; 값에 액세스하고 수정하는 것을 지원합니다 . 기본 형식이어야하는 값을 &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; &lt;/a&gt; 으로 래핑 하여 이러한 방식으로 액세스해야 함을 나타냅니다. 여기에서 예를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Julia는 페더레이션 패키지 관리를 지원합니다. 즉, 여러 독립 당사자가 공용 및 개인 패키지와 패키지 레지스트리를 모두 유지할 수 있으며 프로젝트는 다른 레지스트리의 공용 및 개인 패키지를 혼합하여 사용할 수 있습니다. 다양한 레지스트리의 패키지는 공통 도구 및 워크 플로우 세트를 사용하여 설치 및 관리됩니다. Julia와 함께 제공 되는 &lt;code&gt;Pkg&lt;/code&gt; 패키지 관리자를 사용하면 프로젝트의 종속성을 설치하고 관리 할 수 ​​있습니다. 프로젝트 파일 (프로젝트가 의존하는 다른 프로젝트를 설명)과 매니페스트 파일 (프로젝트의 완전한 의존성 그래프의 정확한 버전을 스냅 샷)을 생성하고 조작하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Julia는 &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 병렬 루프를 지원합니다 . 이 매크로는 루프가 다중 스레드 영역임을 Julia에게 표시하기 &lt;code&gt;for&lt;/code&gt; 루프 앞에 부착됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Julia는 부정확 한 변환 처리 방식이 다른 세 가지 유형의 숫자 ​​변환을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8cd4a62b540f64bfcf5a4bbfe0bf9740f9b0515a" translate="yes" xml:space="preserve">
          <source>Julia supports three main categories of features for concurrent and parallel programming:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e2d62c4e474d2e3cdad1aedacbc766563cd1d6" translate="yes" xml:space="preserve">
          <source>Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;index offsets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Julia는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;어휘 범위 지정을&lt;/a&gt; 사용 합니다. 즉, 함수 범위는 호출자의 범위에서 상속되지 않고 함수가 정의 된 범위에서 상속됩니다. 예를 들어, 다음 코드에서 &lt;code&gt;x&lt;/code&gt; 내부 &lt;code&gt;foo&lt;/code&gt; 받는 의미 &lt;code&gt;x&lt;/code&gt; 는 모듈의 전역 범위에서 &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Julia는 &lt;code&gt;end&lt;/code&gt; 를 사용하여 &lt;code&gt;if&lt;/code&gt; 와 같은 조건부 블록의 끝 , &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 와 같은 루프 블록 및 함수를 나타냅니다. 줄은 &lt;code&gt;if ( cond ) statement&lt;/code&gt; 대신에 줄리아는 &lt;code&gt;if cond; statement; end&lt;/code&gt; 형식의 문을 허용합니다 . 성명서; end , &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 및 &lt;code&gt;!cond || statement&lt;/code&gt; . 후자의 두 구문에서 대 &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 은 연산자 우선 순위 때문에 괄호로 명시 적으로 묶어야합니다 (예 : cond &amp;amp;&amp;amp; (x = value)) .</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Julia는 &lt;code&gt;end&lt;/code&gt; 를 사용하여 &lt;code&gt;if&lt;/code&gt; 와 같은 조건부 블록의 끝 , &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 와 같은 루프 블록 및 함수를 나타냅니다. 줄은 &lt;code&gt;if ( cond ) statement&lt;/code&gt; 대신에 줄리아는 &lt;code&gt;if cond; statement; end&lt;/code&gt; 형식의 문을 허용합니다 . 성명서; end , &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 및 &lt;code&gt;!cond || statement&lt;/code&gt; . 후자의 두 구문에서 할당 문은 괄호로 명시 적으로 묶어야합니다 (예 : &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07096f6426ddf7d6431c3e711ca9f0c89cf1dd4d" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;nothing&lt;/code&gt; of type &lt;code&gt;Nothing&lt;/code&gt; to represent a null value, whereas Python uses &lt;code&gt;None&lt;/code&gt; of type &lt;code&gt;NoneType&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Julia는 정수 계산에 기계 산술을 사용합니다. 즉, &lt;code&gt;Int&lt;/code&gt; 값 의 범위 가 제한되고 양쪽 끝을 감싸서 정수를 더하고 빼고 곱하면 오버플로 또는 언더 플로가 발생하여 처음에는 불안정해질 수있는 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89c53eee9d134c8dd587da06fe96b8ba48e316ee" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">Julia는 기본적으로 UTF-8 인코딩을 사용하며 패키지를 통해 새로운 인코딩 지원을 추가 할 수 있습니다. 예를 들어 &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; 패키지는 &lt;code&gt;UTF16String&lt;/code&gt; 및 &lt;code&gt;UTF32String&lt;/code&gt; 유형을 구현 합니다. 다른 인코딩에 대한 추가 논의와 지원을 구현하는 방법은 당분간이 문서의 범위를 벗어납니다. UTF-8 인코딩 문제에 대한 자세한 내용은 아래 &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;바이트 배열 리터럴&lt;/a&gt; 섹션을 참조하십시오 . &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt; 기능은 주로 외부 데이터와 라이브러리로 작업, 다양한 UTF-XX 인코딩 사이의 데이터를 변환하기 위해 제공된다.</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Julia는 존재하는 것 중 첫 번째 파일 을 사용하여 발견 된 저장소에있는 &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; 파일에서 공개 &lt;code&gt;Priv&lt;/code&gt; 패키지 를로드하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Julia는 시스템의 로케일 및 언어 설정을 사용하여 그대로 인쇄 할 수있는 문자와 이스케이프 된 &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 입력 양식을 사용하여 출력 할 문자를 결정 합니다. 이러한 유니 코드 이스케이프 형식 외에도 모든 &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C의 기존 이스케이프 입력 형식을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">Julia 값은 함수에 지정되거나 함수에 전달 될 때 복사되지 않습니다. 함수가 배열을 수정하면 변경 사항이 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">Julia 값은 함수에 전달 될 때 복사되지 않습니다. 함수가 배열을 수정하면 변경 사항이 호출자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">Julia는 필요한 경우 내장 상수와 함수를 재정의 할 수도 있습니다 (잠재적 인 혼동을 피하기 위해 권장되지는 않지만).</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">Julia 워커는 &lt;code&gt;--worker&lt;/code&gt; 로 시작해서는 안됩니다 . &lt;code&gt;--worker&lt;/code&gt; 로 시작 하면 새로 시작된 작업자가 기본적으로 TCP / IP 소켓 전송 구현으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 은 먼저 함수를 취한 다음 &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; 와 달리 인수를 취합니다 . 마찬가지로 R에서 Julia의 &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; 와 &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt; 함수 는 mapslices입니다 . 첫 번째 주장입니다.</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt; 은 R의 대응 항목과 다릅니다. 모두 선택적인 키워드 인수 &lt;code&gt;dims&lt;/code&gt; 를 허용합니다.이 매개 변수 는 작업이 수행되는 차원을 나타냅니다. 예를 들어, &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; Julia에서 &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; 4] 와 B &amp;lt;-rbind (c (1,2), c (3,4)) 는 R에서 동일한 행렬이됩니다. 그러면 &lt;code&gt;sum(A)&lt;/code&gt; 는 &lt;code&gt;sum(B)&lt;/code&gt; 와 같은 결과를 주지만 &lt;code&gt;sum(A, dims=1)&lt;/code&gt; 은 각 열에 대한 합계를 포함하는 행 벡터이고 &lt;code&gt;sum(A, dims=2)&lt;/code&gt; 는 각 행에 대한 합계를 포함하는 열 벡터입니다. 이것은 별도의 R의 동작과 대조됩니다. &lt;code&gt;colSums(B)&lt;/code&gt; 및 &lt;code&gt;rowSums(B)&lt;/code&gt; 함수는 이러한 기능을 제공합니다. 는 IF &lt;code&gt;dims&lt;/code&gt; 키워드 인수 벡터가 합산 배열 등의 치수를 유지하면서, 그때는 그 합이 수행되는 동안 모든 측정 기준을 지정 &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; . 두 번째 인수에 관한 오류 검사는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 은 각각 R에서 &lt;code&gt;pmax&lt;/code&gt; 와 &lt;code&gt;pmin&lt;/code&gt; 과 동일 하지만 두 인수의 크기는 동일해야합니다. 동안 &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt; 대체 &lt;code&gt;max&lt;/code&gt; 와 &lt;code&gt;min&lt;/code&gt; R에, 중요한 차이가있다.</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; 은 각 함수 호출이 많은 양의 작업을 수행하는 경우를 위해 설계되었습니다. 반대로 &lt;code&gt;@distributed for&lt;/code&gt; 는 각 반복이 작은 상황 , 즉 두 숫자를 합산하는 상황을 처리 할 수 ​​있습니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;@distributed for&lt;/code&gt; 는 작업자 프로세스 만 병렬 계산에 사용합니다. &lt;code&gt;@distributed for&lt;/code&gt; 의 경우 호출 프로세스에서 최종 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt; 은 R 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">Julia의 &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt; 는 고밀도 대각선 행렬 대신 벡터로 특이 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Julia의 &lt;code&gt;*&lt;/code&gt; 연산자는 R과 달리 행렬 곱셈을 수행 할 수 있습니다. &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 행렬 인 경우 &lt;code&gt;A * B&lt;/code&gt; 는 Julia의 행렬 곱셈을 나타냅니다. 이는 R의 &lt;code&gt;A %*% B&lt;/code&gt; 와 같습니다 . R에서 이와 동일한 표기법은 요소 별 (Hadamard) 제품을 수행합니다. 요소 별 곱셈 연산을 얻으려면 Julia에서 &lt;code&gt;A .* B&lt;/code&gt; 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Julia의 &lt;code&gt;-&amp;gt;&lt;/code&gt; 는 익명 함수를 작성하며 포인터를 통해 멤버에 액세스하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">Julia의 &lt;code&gt;-&amp;gt;&lt;/code&gt; 익명 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Julia의 &lt;code&gt;Char&lt;/code&gt; 유형은 32 비트이며 모든 플랫폼 에서 와이드 문자 유형 ( &lt;code&gt;wchar_t&lt;/code&gt; 또는 &lt;code&gt;wint_t&lt;/code&gt; ) 과 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">Julia의 &lt;code&gt;^&lt;/code&gt; 는 C / C ++에서와 같이 비트 XOR이 아닌 지수 (pow)입니다 ( Julia에서 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Julia의 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 등 블록은 &lt;code&gt;end&lt;/code&gt; 키워드 로 종료됩니다 . 들여 쓰기 수준은 파이썬 에서처럼 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f389c4a1d318e9dd00a0e8de7e401cb98f80629" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia의 &lt;code&gt;struct&lt;/code&gt; 는 MATLAB의 &lt;code&gt;class&lt;/code&gt; es 와 달리 런타임에 필드를 동적으로 추가하는 것을 지원하지 않습니다 . 대신 &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4b03ee02a08f7deb55748f11f6cdeb8e4ae72ba" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;\ex&quot;&lt;/code&gt;, and Control plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Julia의 REPL 키 바인딩은 사전을 &lt;code&gt;REPL.setup_interface&lt;/code&gt; 에 전달하여 사용자 환경 설정에 맞게 완전히 사용자 정의 할 수 있습니다 . 이 사전의 키는 문자 또는 문자열 일 수 있습니다. 키 &lt;code&gt;'*'&lt;/code&gt; 는 기본 동작을 나타냅니다. 제어 플러스 문자 &lt;code&gt;x&lt;/code&gt; 바인딩은 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 됩니다. 메타 플러스 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; 로 쓸 수 있습니다 . 사용자 정의 키맵의 값은 &lt;code&gt;nothing&lt;/code&gt; 거나 (입력을 무시해야 함을 나타냄) 서명을 승인하는 함수 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; 가 아니 어야합니다 . &lt;code&gt;REPL.setup_interface&lt;/code&gt; 의 REPL가 초기화되기 전에 기능과 동작을 등록하여, 호출해야&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt; . 예를 들어, 위 / 아래 화살표 키를 접두사 검색없이 히스토리를 통해 이동하려면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 에 다음 코드를 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dfc06368777a16cdc231cc0f47af0adaed5f388" translate="yes" xml:space="preserve">
          <source>Julia's advantage is that good performance is not limited to a small subset of &amp;ldquo;built-in&amp;rdquo; types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">줄리아베이스 라이브러리는에게 내부 갖는다 &lt;code&gt;sub2ind&lt;/code&gt; 의 즉, 지수 계산하는 - (A)의 세트 N multilinear 인덱스에 기초하여 N 차원 배열로 선형 인덱스를 계산하는 함수 &lt;code&gt;i&lt;/code&gt; 배열로 인덱스하는데 사용될 수 사용하여 &lt;code&gt;A[i]&lt;/code&gt; &lt;code&gt;A[x,y,z,...]&lt;/code&gt; 대신 A [i ] . 가능한 구현은 다음과 같습니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2b028dd5553cdb221b0a0e50311b3fadf26a8fa" translate="yes" xml:space="preserve">
          <source>Julia's base library has an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">그것의 유형을 알 수 없습니다 원래 구현 있도록 줄리아의 컴파일러는 함수의 경계에서 인수 유형의 코드를 전문 (가 무작위로 선택되어 있기 때문에) 루프 동안을. 따라서 내부 루프가 &lt;code&gt;fill_twos!&lt;/code&gt; 일부로 다시 컴파일 될 수 있으므로 두 번째 버전은 일반적으로 더 빠릅니다 ! 서로 다른 유형의 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Julia의 메시지 전달 구현은 MPI와 같은 다른 환경과 다릅니다 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; . Julia의 통신은 일반적으로 &quot;단면&quot;입니다. 즉, 프로그래머는 2 개의 프로세스 작업에서 하나의 프로세스 만 명시 적으로 관리해야합니다. 또한 이러한 작업은 일반적으로 &quot;메시지 전송&quot;및 &quot;메시지 수신&quot;처럼 보이지 않고 사용자 기능 호출과 같은 상위 수준 작업과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6c32163901432dfb93ac8223e9799a51677fe0b8" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Julia의 내부 인덱싱 기계는 모든 인덱싱 작업을 선호하는 스타일로 자동으로 (그리고 보이지 않게) 변환합니다. 이를 통해 사용자는 명시 적 방법이 제공되지 않은 경우에도 인덱싱 스타일을 사용하여 배열 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29a0ad9426578653cfa0a913517c4cd61d66687" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Julia의 매크로 확장기는 다음과 같은 방식으로 이러한 문제를 해결합니다. 먼저, 매크로 결과 내의 변수는 지역 또는 전역으로 분류됩니다. 변수가 전역 변수로 지정되고 전역으로 선언되거나 로컬로 선언되거나 함수 인수 이름으로 사용되는 경우 변수는 로컬로 간주됩니다. 그렇지 않으면 전역으로 간주됩니다. 그런 다음 지역 변수의 이름이 고유 한 것으로 바뀌고 ( 새 기호를 생성 하는 &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt; 함수 사용 ) 전역 변수는 매크로 정의 환경 내에서 분석됩니다. 따라서 위의 두 가지 문제가 모두 해결됩니다. 매크로의 지역은 사용자 변수와 충돌하지 않으며 &lt;code&gt;time&lt;/code&gt; 과 &lt;code&gt;println&lt;/code&gt; 은 Julia Base 정의를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Julia의 마크 다운은 기본 문자열 리터럴과 매우 유사한 방식으로 보간을 지원하지만, 오브젝트를 문자열로 변환하는 대신 마크 다운 트리에 저장한다는 점이 다릅니다. Markdown 내용이 렌더링 될 때 일반적인 &lt;code&gt;show&lt;/code&gt; 메소드가 호출되며, 평소처럼 재정의 될 수 있습니다. 이 디자인을 사용하면 기본적인 구문을 어지럽히 지 않고 임의의 복잡한 기능 (예 : 참조)으로 마크 다운을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f193759d498fbc023e5548ecbd3efb90a55de4f4" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">Julia의 방법 다형성은 가장 강력한 기능 중 하나이지만이 기능을 활용하면 설계 문제가 발생할 수 있습니다. 특히,보다 복잡한 방법 계층에서는 &lt;a href=&quot;#man-ambiguities-1&quot;&gt;모호성&lt;/a&gt; 이 발생하는 경우가 드물지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">Julia의 다차원 배열은 열 주요 순서로 메모리에 저장됩니다. 다음은 2D 배열을 만들고 해당 속성에 액세스하는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Julia의 병렬 프로그래밍 플랫폼은 &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;작업 (일명 Coroutines)&lt;/a&gt; 을 사용하여 여러 계산간에 전환합니다. 경량 스레드 간의 실행 순서를 표현하려면 통신 기본 요소가 필요합니다. 줄리아가 제공하는 &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; 에서 새 작업을 생성 &lt;code&gt;func&lt;/code&gt; , 타입의 새로운 채널 결합을 &lt;code&gt;ctype&lt;/code&gt; 및 크기 &lt;code&gt;csize&lt;/code&gt; 하고 작업을 예약합니다. &lt;code&gt;Channels&lt;/code&gt; 같은 태스크 간 통신하는 방법이 될 수있는 &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; 타입의 버퍼링 채널 생성 &lt;code&gt;T&lt;/code&gt; 및 크기 &lt;code&gt;sz&lt;/code&gt; . 코드가 &lt;code&gt;fetch&lt;/code&gt; 또는&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 현재 작업이 일시 중지되고 스케줄러가 실행할 다른 작업을 선택합니다. 대기중인 이벤트가 완료되면 작업이 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="8fbc199e2173262fbbf9a789a4bc09af6495b0ec" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">Julia의 프로모션 시스템은 인수 유형의 혼합에 대한 산술 연산을 자연스럽고 자동으로 &quot;그냥 작동&quot;합니다. 프로모션 시스템에 대한 자세한 내용은 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;변환 및 프로모션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34b8049f71f2dca17e15f3a691f349cd09ad4d7f" translate="yes" xml:space="preserve">
          <source>Julia's range indexing has the format of &lt;code&gt;x[start:step:stop]&lt;/code&gt;, whereas Python's format is &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt;. Hence, &lt;code&gt;x[0:10:2]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[1:2:10]&lt;/code&gt; in Julia. Similarly, &lt;code&gt;x[::-1]&lt;/code&gt; in Python, which refers to the reversed array, is equivalent to &lt;code&gt;x[end:-1:1]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">Julia의 작은 따옴표는 문자열이 아닌 문자를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">Julia의 슬라이스 인덱싱에는 Python과 달리 마지막 요소가 포함됩니다. &lt;code&gt;a[2:3]&lt;/code&gt; 줄리아이다 &lt;code&gt;a[1:3]&lt;/code&gt; 파이썬있다.</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Julia의 타입 시스템은 강력하고 표현력이 뛰어나지 만 명확하고 직관적이며 눈에 거슬리지 않도록 설계되었습니다. 많은 Julia 프로그래머는 명시 적으로 형식을 사용하는 코드를 작성할 필요가 없다고 생각할 수 있습니다. 그러나 일부 유형의 프로그래밍은 선언 된 유형으로 더 명확하고 단순하며 빠르고 강력합니다.</target>
        </trans-unit>
        <trans-unit id="328e404443e1e3ee36bbd28ef0bec3925e10b36e" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">Julia의 유형 시스템은 동적이지만 특정 값이 특정 유형임을 나타낼 수있게하여 정적 유형 시스템의 장점을 얻습니다. 이것은 효율적인 코드 생성에 큰 도움이 될 수 있지만 훨씬 더 중요한 것은 함수 인수 유형에 대한 메소드 디스패치가 언어와 깊이 통합 될 수있게합니다. 방법 파견에 자세히 탐구되는 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;방법&lt;/a&gt; ,하지만 여기에 제시된 유형 시스템에 뿌리를두고있다.</target>
        </trans-unit>
        <trans-unit id="452075601195cf61defe5474343bae547d7dc931" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Julia의 업데이트 연산자 (예 : &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , ...)는 &lt;em&gt;제자리에 있지&lt;/em&gt; 않지만 NumPy 는 &lt;em&gt;없습니다&lt;/em&gt; . 이것은 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 값을 변경하지 않고 오히려 이름 &lt;code&gt;B&lt;/code&gt; 를 오른쪽 배열 &lt;code&gt;B = B + 3&lt;/code&gt; 의 결과로 리 바인드합니다 . 이는 새로운 배열입니다. 전체 작업의 경우 &lt;code&gt;B .+= 3&lt;/code&gt; ( &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;도트 연산자&lt;/a&gt; 참조 ), 명시 적 루프 또는 &lt;code&gt;InplaceOps.jl&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd01ffb3135bea5db94d9c0cd4c8376ed4d4ff72" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">Julia는 대부분의 기술 컴퓨팅 언어와 마찬가지로 일류 어레이 구현을 제공합니다. 대부분의 기술 컴퓨팅 언어는 다른 컨테이너를 희생하면서 배열 구현에 많은주의를 기울입니다. Julia는 배열을 특별한 방식으로 취급하지 않습니다. 배열 라이브러리는 Julia 자체에서 거의 완벽하게 구현되며 Julia로 작성된 다른 코드와 마찬가지로 컴파일러에서 성능을 얻습니다. 따라서 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 에서 상속하여 사용자 정의 배열 유형을 정의 할 수도 있습니다. . 사용자 정의 배열 유형 구현에 대한 자세한 내용 &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;은 AbstractArray 인터페이스&lt;/a&gt; 의 매뉴얼 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">&lt;code&gt;^R&lt;/code&gt; 이 역방향 검색 인 것처럼 &lt;code&gt;^S&lt;/code&gt; 는 프롬프트 &lt;code&gt;(i-search)`':&lt;/code&gt; 와 함께 정방향 검색 입니다. 이 둘은 서로 함께 사용되어 이전 또는 다음 일치 결과를 통해 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">도움말 모드가 문서에 빠르게 액세스하는 데 유용한 것처럼 다른 일반적인 작업은 시스템 셸을 사용하여 시스템 명령을 실행하는 것입니다. 그냥 &lt;code&gt;?&lt;/code&gt; 줄의 시작 부분에 도움말 모드로 들어가면 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )이 쉘 모드로 들어갑니다. 그리고 줄의 시작 부분에서 백 스페이스를 눌러 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="456f4e9fab32e1339e01f38c693667415e6a7374" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다만 같이 &lt;a href=&quot;#man-array-indexing-1&quot;&gt;인덱싱&lt;/a&gt; 의 &lt;code&gt;end&lt;/code&gt; 에 할당되는 배열의 크기에 의해 결정되는 키워드 인덱싱 괄호 내의 각 차원의 마지막 인덱스를 나타 내기 위해 사용될 수있다. &lt;code&gt;end&lt;/code&gt; 키워드가 없는 인덱스 할당 구문 은&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">텍스트 출력이 &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 의해 수행되는 것처럼 사용자 정의 유형은 과부하로 텍스트 표현을 나타낼 수 있습니다&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; 것처럼&lt;/a&gt; Julia는 3 가지 부분으로 구성된 풍부한 멀티미디어 출력 (예 : 이미지, 서식있는 텍스트 또는 오디오 및 비디오)을위한 표준화 된 메커니즘을 제공합니다. :</target>
        </trans-unit>
        <trans-unit id="03d45fce37a205fcf4faeb89d82409711b9d7cca" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c6961e570c4d224922a2a92f75eca4d8e9afac" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">유형 선언에서 유형 매개 변수에 하위 유형 제한 조건을 둘 수있는 것처럼 (참조 &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt; 파라 메트릭 유형&lt;/a&gt; , 당신은 또한 방법의 형태 파라미터를 제한 할 수) :</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">그냥 사용 조건 표현 등에 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elseif&lt;/code&gt; 또는 삼항 연산자의 피연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 나 &lt;code&gt;||&lt;/code&gt; 부울 값이어야합니다 ( &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; ). 조건부 체인의 마지막 항목을 제외하고 부울이 아닌 값을 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">Juxtaposed 리터럴 계수 구문은 16 진수 정수 리터럴과 부동 소수점 리터럴에 대한 엔지니어링 표기법의 두 가지 숫자 리터럴 구문과 충돌 할 수 있습니다. 구문 충돌이 발생하는 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">일부 Julia 기능은 현재 CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; 에서 지원하지 않습니다 . 특히 &lt;code&gt;sin&lt;/code&gt; 과 같은 일부 기능은 다음과 같이 대체해야합니다. &lt;code&gt;CUDAnative.sin&lt;/code&gt; (cc : @maleadt) .</target>
        </trans-unit>
        <trans-unit id="ed1dc2aa59f2bcc19af822ca3015689f0776b65a" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">키 바인딩</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">키캡 텐</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">키워드 인수</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">키워드 인수 &lt;code&gt;debuginfo&lt;/code&gt; 는 &lt;code&gt;:source&lt;/code&gt; 또는 &lt;code&gt;:none&lt;/code&gt; 중 하나 일 수 있습니다 . 코드 설명의 세부 정보를 지정하기 위해 (기본값) .</target>
        </trans-unit>
        <trans-unit id="64ff3dfa226c767a3f6429283e3a4ecc260532b6" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;init&lt;/code&gt; is added in Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">키워드 인수 &lt;code&gt;lazy=true|false&lt;/code&gt; 는 &lt;code&gt;topology&lt;/code&gt; 옵션 &lt;code&gt;:all_to_all&lt;/code&gt; 에만 영향을줍니다 . 경우 &lt;code&gt;true&lt;/code&gt; 클러스터는 모든 근로자에 연결된 마스터와 함께 시작합니다. 두 작업자 간의 첫 원격 호출에서 특정 작업자-작업자 연결이 설정됩니다. 클러스터 내 통신에 할당 된 초기 리소스를 줄이는 데 도움이됩니다. 병렬 프로그램의 런타임 요구 사항에 따라 연결이 설정됩니다. &lt;code&gt;lazy&lt;/code&gt; 의 기본값 은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">키워드 인수 기본값은 필요한 경우 (해당 키워드 인수가 전달되지 않은 경우) 왼쪽에서 오른쪽으로 만 평가됩니다. 따라서 기본 표현식은 이전 키워드 인수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">키워드 인수는 일반적인 위치 인수와 상당히 다르게 작동합니다. 특히, 메소드 디스패치에는 참여하지 않습니다. 일치하는 메소드가 식별 된 후 키워드 인수가 처리 된 위치 인수 만 기반으로 메소드가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a802505edaa907c65ced69e373b2128c6752ff80" translate="yes" xml:space="preserve">
          <source>Keyword arguments can also be used in varargs functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">키워드 인수가 있으면 &lt;code&gt;f&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">키워드 인수 :</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">키워드는 다음에 제안 된 방법으로 표시됩니다 &lt;code&gt;;&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;keepempty&lt;/code&gt; 가 키워드 인수 인 아래 행을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">키스 마크</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">닫힌 된 눈을 가진 고양이 얼굴 키스</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">키스하는 얼굴</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">닫힌 된 눈으로 얼굴 키스</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">웃는 눈으로 얼굴을 키스</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Konstantinos Konstantinides와 Kung Yao, &quot;매트릭스 순위 결정에서 유효 특이 값의 통계 분석&quot;, 음향 처리, 음성 및 신호 처리에 관한 IEEE 거래, 36 (5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;도 : 10.1109 / 29.1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">두 벡터 또는 두 행렬의 크로네 커 텐서 곱.</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">LAPACK 기능</target>
        </trans-unit>
        <trans-unit id="d12a2cf0b16bda2d0e8799f01c41ee6d60d4d6a5" translate="yes" xml:space="preserve">
          <source>LAPACK functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1b6f39a46d5337c0aad867bbe073b5b049053" translate="yes" xml:space="preserve">
          <source>LDL(T) factorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">생체 부분 간 이식 (참조 &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVM 인터페이스</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU ( &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">LU 분해</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt; 행렬에 대한 LU 분해</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기호 레이블 &lt;code&gt;name&lt;/code&gt; 으로 명령문에 레이블을 지정 합니다. 레이블은 &lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt; 과 함께 무조건 점프의 끝점을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">레이디 비틀</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">단락 내에 인라인에 맞지 않는 큰 $ \ LaTeX $ 방정식은 &quot;language&quot; &lt;code&gt;math&lt;/code&gt; 함께 분리 된 코드 블록을 사용하여 디스플레이 방정식으로 작성 될 수 있습니다. 아래 예 으로 .</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">큰 파란색 원</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">큰 블루 다이아몬드</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">큰 원</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">큰 다운 택</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">큰 주황색 다이아몬드</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">큰 빨간 원</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">큰 압정</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">모듈에서 모든 명령문을 실행하면 많은 양의 코드가 컴파일되는 경우가 많으므로 큰 모듈을로드하는 데 몇 초가 걸릴 수 있습니다. Julia는이 시간을 줄이기 위해 미리 컴파일 된 모듈 캐시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">보다 큰</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">32 비트 만 사용하여 표현할 수 없지만 64 비트로 표현할 수있는 더 큰 정수 리터럴은 시스템 유형에 관계없이 항상 64 비트 정수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x/y&lt;/code&gt; 보다 작거나 같은 가장 큰 정수 .</target>
        </trans-unit>
        <trans-unit id="b1b42ea4b0b1e511fffb01ce016fa0bdcff72dd5" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;. Equivalent to &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">가장 큰 가치</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">마지막 분기</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">마지막 분기 문 기호</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">얼굴을 가진 마지막 분기</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">위의 고리가있는 라틴어 대문자 A / 라틴어 대문자 A 링</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">라틴 대문자 Ae / 라틴 대문자 AE</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">스트로크가있는 라틴어 대문자 D / 라틴어 대문자 D 막대</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">라틴어 대문자 영어</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">라틴 대문자 Eth</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">스트로크 / 라틴 대문자 L 슬래시가있는 라틴어 대문자 L</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">스트로크 / 라틴 대문자 O 슬래시가있는 라틴어 대문자 O</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">라틴어 대문자 가시</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">치기 / 라틴 대문자 Z 막대기를 가진 라틴어 대문자 Z</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">라틴어 대문자 합자 Oe / 라틴어 대문자 OE</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">라틴 문자 폐포 클릭 / 라틴 문자 파이프 더블 바</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">라틴 문자 글로 탈 스탑</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">라틴 문자 역전 정지</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">라틴 문자 인두 음성 마찰 / 라틴 문자 역전 정지</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">위의 고리가있는 라틴어 소문자 A / 라틴어 소문자 A 반지</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">라틴 소문자 Ae / 라틴 소문자 AE</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">라틴어 소문자 닫힌 오메가</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">스트로크가있는 라틴어 소문자 D / 라틴어 소문자 D 바</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">꼬리를 가진 라틴어 소문자 D / 라틴어 소문자 D Retroflex 훅</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">라틴어 소문자 Dezh Digraph / 라틴어 소문자 D Yogh</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">라틴어 소문자 Dotless I</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">라틴어 소문자 Dotless J</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">라틴어 소문자 영어</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">라틴어 소문자 Esh</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">라틴 소문자 Eth</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">라틴어 소문자 Ezh / 라틴어 소문자 Yogh</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">라틴어 소문자 감마</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">치기를 가진 라틴어 소문자 H / 라틴어 소문자 H 바</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">라틴어 소문자 Hv / 라틴어 소문자 HV</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">벨트가있는 라틴어 소문자 L / 라틴어 소문자 L 벨트</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">Retroflex 훅 / 라틴어 소문자 L Retroflex 훅이있는 라틴어 소문자 L</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">스트로크 / 라틴어 소문자 L 슬래시가있는 라틴어 소문자 L</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">후크가있는 라틴어 소문자 M / 라틴어 소문자 M 훅</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">왼쪽 훅 / 라틴어 소문자 N 훅이있는 라틴어 소문자 N</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">오른쪽 다리가 긴 라틴 소문자 N</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">Retroflex 훅 / 라틴어 소문자 N Retroflex 훅을 가진 라틴어 소문자 N</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">스트로크 / 라틴어 소문자 O 슬래시가있는 라틴어 소문자 O</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">라틴 소문자 공개 O</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">라틴어 소문자 피</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">Fishhook / 라틴어 소문자 Fishhook R를 가진 라틴어 소문자 R</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">긴 다리가있는 라틴어 소문자 R</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">꼬리를 가진 라틴어 소문자 R / 라틴어 소문자 R 훅</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">라틴어 소문자 램 혼 / 라틴어 소문자 아기 감마</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">걸이 / 라틴 문자 S 걸이를 가진 라틴어 소문자 S</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">라틴어 소문자 Schwa</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">라틴 소문자 샤프 S</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">Retroflex 훅 / 라틴어 소문자 T Retroflex 훅이있는 라틴어 소문자 T</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">라틴어 소문자 문자 그래프 / 라틴어 소문자 T Esh</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">라틴어 소문자 가시</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">라틴어 소문자 A</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">라틴어 소문자 문자 알파 / 라틴 문자 소문자 스크립트 A</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">라틴어 소문자 H 설정</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">라틴어 소문자 K 설정</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">라틴어 소문자 M</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">긴 다리가있는 라틴어 소문자</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">라틴어 소문자 R</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">라틴어 작은 편지는 R를 가진 R를 돌았습니다</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">긴 다리를 가진 라틴어 소문자 편지 R</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">라틴어 소문자 문자 T</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">라틴어 소문자 문자 V</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">라틴어 소문자 W</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">라틴어 소문자 Y</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">라틴어 소문자 업 실론</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">후크가있는 라틴어 소문자 V / 라틴어 소문자 스크립트 V</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">Retroflex 훅 / 라틴어 소문자 Z Retroflex 훅이있는 라틴어 소문자 Z</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">라틴어 소문자 합자 Oe / Latin 소문자 OE</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">라틴 첨자 소문자 A</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">라틴 첨자 소문자 E</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">라틴 첨자 소문자 H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">라틴 첨자 소문자 I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">라틴 첨자 소문자 J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">라틴 첨자 소문자 K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">라틴 첨자 소문자 L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">라틴 첨자 소문자 M</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">라틴 첨자 소문자 N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">라틴 첨자 소문자 O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">라틴 첨자 소문자 P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">라틴 첨자 소문자 R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">라틴 첨자 소문자 S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">라틴 첨자 소문자 Schwa</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">라틴 첨자 소문자 T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">라틴 첨자 소문자 U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">라틴 첨자 소문자 V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">라틴 첨자 소문자 X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">지정된 클러스터 관리자를 통해 작업자 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">인 - 내장하여 출시 노동자 &lt;code&gt;LocalManager&lt;/code&gt; 로컬 호스트에서만 출시 노동자. 여러 코어를 활용하는 데 사용할 수 있습니다. &lt;code&gt;addprocs(4)&lt;/code&gt; 는 로컬 머신에 4 개의 프로세스를 추가합니다. 경우 &lt;code&gt;restrict&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 바인딩이 제한됩니다 &lt;code&gt;127.0.0.1&lt;/code&gt; . 키워드 인수 &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;exename&lt;/code&gt; , &lt;code&gt;exeflags&lt;/code&gt; , &lt;code&gt;topology&lt;/code&gt; , &lt;code&gt;lazy&lt;/code&gt; 및 &lt;code&gt;enable_threaded_blas&lt;/code&gt; 는 문서화와 같은 효과를 &lt;code&gt;addprocs(machines)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">게으른 인접 (접합 전치) (또한 접미사 &lt;code&gt;'&lt;/code&gt; ). 참고 &lt;code&gt;adjoint&lt;/code&gt; 요소 재귀인가된다.</target>
        </trans-unit>
        <trans-unit id="1a484bd65bd99903b9e6433e56a7ce5feb1a88b4" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">게으른 전치. 반환 된 객체를 변경하면 &lt;code&gt;A&lt;/code&gt; 가 적절하게 변경 됩니다. 항상 그런 것은 아니지만 종종 &lt;code&gt;Transpose(A)&lt;/code&gt; . 여기서 &lt;code&gt;Transpose&lt;/code&gt; 는 게으른 전치 래퍼입니다. 이 작업은 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 선형 대수 객체 (일반적으로 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; 이지만 일부 &lt;code&gt;Factorization&lt;/code&gt; ) 의 조옮김 뷰에 대한 Lazy wrapper 유형입니다 . 일반적으로 &lt;code&gt;Transpose&lt;/code&gt; 생성자는 직접 호출해서는 안되며 대신 &lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; 를&lt;/a&gt; 사용하십시오. 뷰를 구체화하려면 &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 선형 대수 객체, 일반적으로 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; 뿐만 아니라 일부 &lt;code&gt;Factorization&lt;/code&gt; 의 인접 뷰에 대한 래퍼 래퍼 유형입니다 . 일반적으로 &lt;code&gt;Adjoint&lt;/code&gt; 생성자는 직접 호출해서는 안되며 대신 &lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; 를&lt;/a&gt; 사용하십시오. 뷰를 구체화하려면 &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">바람에 나 부 끼고 잎</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">최소 공통 (음수가 아닌) 배수</target>
        </trans-unit>
        <trans-unit id="df7cd86f236b8cca642b834576ccdcaabf497db7" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple. The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">동그라미 더하기 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">작은 원이있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">왼쪽 바브 아래로 오른쪽 바브 아래로 작살</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">왼쪽 바브 아래 오른쪽 바브</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">왼쪽 바브 위로 오른쪽 바브</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">왼쪽 바브 위로 오른쪽 바브 위로 작살</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">왼쪽 천장</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">왼쪽 이중 인용 부호 / 이중 회전 쉼표 인용 부호</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="translated">왼쪽 층</target>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">왼쪽 반 검은 원</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">왼쪽 절반 블록</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">왼쪽 수하물</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">왼쪽 정규 인자 반제품</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">왼쪽 외부 조인</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">왼쪽 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">작은 원을 통해 왼쪽 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">이중 수직 스트로크가있는 왼쪽 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">획이있는 왼쪽 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">수직 스트로크가있는 왼쪽 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">왼쪽 오른쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">뇌졸중과 왼쪽 오른쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">수직 스트로크가있는 왼쪽 오른쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">왼쪽 오른쪽 열린 화살표</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">왼쪽 오른쪽 파 화살표</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">좌반 직접 제품</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">왼쪽 단일 인용 부호 / 단일 회전 쉼표 인용 부호</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">왼쪽 대괄호 하단 코너</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">왼쪽 압정</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">수직 막대 옆의 왼쪽 삼각형</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">세로 막대 옆에 왼쪽 삼각형 + 긴 고 상선 오버레이 / 비 간격 긴 슬래시 ​​오버레이 결합</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">왼쪽 세로 박스 라인</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">왼쪽 화살표, &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">왼쪽 비트 시프트 연산자, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; . 들면 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 의 결과는 &lt;code&gt;B&lt;/code&gt; 는 요소 시프트로 &lt;code&gt;n&lt;/code&gt; 로 채우기 거꾸로 위치 &lt;code&gt;false&lt;/code&gt; 값. 경우 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , 요소는 전방 시프트된다. &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">왼쪽 비트 쉬프트 연산자, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; . 들면 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 의 결과는 &lt;code&gt;x&lt;/code&gt; 왼쪽으로 시프트 &lt;code&gt;n&lt;/code&gt; 으로 채우는 비트 &lt;code&gt;0&lt;/code&gt; S. 이것은 &lt;code&gt;x * 2^n&lt;/code&gt; 과 같습니다 . 들면 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , 이것에 상당 &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">왼쪽 나누기 연산자 : &lt;code&gt;y&lt;/code&gt; 에 왼쪽 &lt;code&gt;x&lt;/code&gt; 의 역수를 곱 합니다. 정수 인수에 대한 부동 소수점 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">왼쪽을 향한 돋보기</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">왼쪽으로 회전하는 행렬 &lt;code&gt;A&lt;/code&gt; 는 시계 반대 방향으로 정수 &lt;code&gt;k&lt;/code&gt; 의 횟수로 90 도입니다 . 경우 &lt;code&gt;k&lt;/code&gt; 네 (0을 포함)의 배수이고, 이것은 동등 &lt;code&gt;copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="927f085de46b51d7752a0f754c30861f6cbe6126" translate="yes" xml:space="preserve">
          <source>Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">왼쪽 화살표 / 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">거의 같은 위의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">거의 같은 방향으로 위의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">역 틸트 연산자 위의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">바에서 왼쪽 화살표 / 바에서 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">바에서 블랙 다이아몬드로의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">왼쪽 화살표 오른쪽 화살표 / 왼쪽 화살표 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">X를 통과하는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">왼쪽 화살표 막대 / 왼쪽 화살표 막대</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">왼쪽 화살표에서 막대 위로 오른쪽 화살표에서 막대 / 왼쪽 화살표에서 막대 오른쪽 화살표에서 막대</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">왼쪽으로 화살표 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">점선 줄기가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">이중 수직 스트로크가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">후크가있는 왼쪽 화살표 / 후크가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">루프가있는 왼쪽 화살표 / 루프가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">왼쪽 아래에 화살표가있는 화살표</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">스트로크가있는 왼쪽 화살표 / 스트로크가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">꼬리가있는 왼쪽 화살표 / 꼬리가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">이중 수직 스트로크 꼬리가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">세로 선으로 꼬리를 가진 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">수직 스트로크가있는 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">왼쪽 검은 색 화살표</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">왼쪽 점선 화살표 / 왼쪽 점선 화살표</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">왼쪽 이중 화살표 / 왼쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">바에서 왼쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">스트로크가있는 왼쪽 이중 화살표 / 스트로크가있는 왼쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">수직 스트로크가있는 왼쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">왼쪽 이중 대시 화살표</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">오른쪽 작살 위 왼쪽 작살 / 오른쪽 작살 위 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">아래로 바브와 함께 왼쪽으로 작살 아래로 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">긴 대시 아래에 바브가있는 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">바에서 아래로 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">바에서 바까지 아래로 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">바브가있는 왼쪽 작살 / 바브가있는 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">바브와 함께 왼쪽으로 작살 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">긴 대시 위에 바브가있는 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">위로 바브와 함께 왼쪽으로 작살 위로 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">바에서 위로 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">바까지 바브와 함께 왼쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">바브가있는 왼쪽 작살 / 바브가있는 왼쪽 작살</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">왼쪽으로 향하는 화살표</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">왼쪽 쌍 화살표 / 왼쪽 쌍 화살표</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">왼쪽 쿼드 러플 화살표</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">왼쪽 구불 구불 한 화살 / 왼쪽 구불 구불 한 화살</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">왼쪽 트리플 화살표 / 왼쪽 트리플 화살표</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">왼쪽 트리플 대시 화살표</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">왼쪽 방향 화살표 / 왼쪽 방향 화살표</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">바에서 왼쪽 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">이중 수직 스트로크가있는 왼쪽 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">꼬리가있는 왼쪽 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">이중 수직 스트로크가있는 꼬리가있는 왼쪽 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">세로 획이있는 왼쪽의 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">수직 스트로크가있는 왼쪽 양방향 화살표</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">왼쪽 양방향 트리플 대시 화살표</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">좌파 화살표 / 좌파 화살표</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">왼쪽 흰색 화살표 / 흰색 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">이중선보다 작은 선보다 큰 선보다 큼</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">2 줄 이상에서보다 큼</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">위의 것보다 위의 것</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">유사하거나 동등한 것보다 적음</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">경사보다 같음 이상 경사보다 같음 이상</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">덜하고 대략적인</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">보다 작고 한 줄은 같지 않음</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">작지만 같지 않음 / 같지 않음</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">작지만 같지 않음 / 같지 않음 + 변형 선택기 -1</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">작지만 같지 않음 / 같지 않음</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">곡선으로 닫힌 것보다</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">기울어 진 동등 이상의 커브로 닫힌 것보다</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">같거나 크거나 같음 / 같거나 작음</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">덜 또는 대략</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">보다 작거나 같거나보다 작거나 같음</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">보다 작거나 같거나보다 작거나 같음</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">보다 작거나보다 큼 /보다 작거나 큼</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">보다 작거나 기울어 짐</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">작거나 기울어 짐 같음 + 긴 Solidus 오버레이 결합 / 간격없는 긴 슬래시 ​​오버레이</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">위의 점과 같거나 그보다 작음</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">오른쪽 위의 점과 같거나 그보다 작음</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">점 내부와 같거나 그보다 작음</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">동일 이상 / 이하 이상</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">안쪽에 동그라미가없는 것</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">도트보다 작음 / 도트보다 작음</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">위의 물음표와 함께</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">비교 연산자보다 적습니다. 에 폭포 다시 &lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; . 부동 소수점 NaN 값의 동작으로 인해이 연산자는 부분 순서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 비교 연산자 에 폭포 다시 &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">블록을 보자</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">작업 전환의 작동 방식을 이해 하기 위해 낮은 수준의 구성 &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 을 살펴 보겠습니다 . &lt;code&gt;yieldto(task,value)&lt;/code&gt; 는 현재 작업을 일시 중단하고 지정된 &lt;code&gt;task&lt;/code&gt; 전환하며 해당 작업의 마지막 &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 호출로 지정된 &lt;code&gt;value&lt;/code&gt; 을 반환합니다 . 것을 알 수 &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; 가&lt;/a&gt; 사용하는 작업 스타일 제어 흐름에 필요한 유일한 작업입니다; 전화를 걸고 돌아가는 대신 항상 다른 작업으로 전환합니다. 이것이 바로이 기능을 &quot;대칭 코 루틴&quot;이라고하는 이유입니다. 각 작업은 동일한 메커니즘을 사용하거나 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">논리적 인 &quot;or&quot;연산자로이 원리를 설명해 봅시다. &lt;code&gt;|&lt;/code&gt; . 부울 논리의 규칙에 따라 피연산자 중 하나가 &lt;code&gt;true&lt;/code&gt; 이면 다른 피연산자의 값은 결과에 영향을 미치지 않으며 항상 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">4 개의 스레드를 사용하여이 어레이에서 동시에 작동하도록하겠습니다. 각 스레드가 스레드 ID를 각 위치에 쓰도록합니다.</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">Julia의 숫자 계층을 구성하는 추상 유형 중 일부를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; 통해 값을 생성하는 생산자 작업을 정의합시다 ! 요구. 값을 사용하려면 생산자가 새 작업에서 실행되도록 일정을 계획해야합니다. 1-arg 함수를 인수로 허용하는 특수 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 채널에 바인딩 된 작업을 실행할 수 있습니다. 그러면 &lt;code&gt;take!&lt;/code&gt; 수 있습니다! 채널 객체에서 반복적으로 값 :</target>
        </trans-unit>
        <trans-unit id="d05f0c73a4331f267ffda8d64fbec89860b0ccf5" translate="yes" xml:space="preserve">
          <source>Let's dig into the fact that the &lt;code&gt;for&lt;/code&gt; loop body has its own scope for a second by writing a slightly more verbose variation which we'll call &lt;code&gt;sum_to&amp;prime;&lt;/code&gt;, in which we save the sum &lt;code&gt;s + i&lt;/code&gt; in a variable &lt;code&gt;t&lt;/code&gt; before updating &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">먼저 두 개의 위치 인수와 나중에 키워드 인수에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">TCP 소켓과 관련된 간단한 예제를 살펴 보겠습니다. 이 기능은 &lt;code&gt;Sockets&lt;/code&gt; 라는 표준 라이브러리 패키지에 있습니다. 먼저 간단한 서버를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="9d1274ee3906a8208793462a30f6e28d1823afa2" translate="yes" xml:space="preserve">
          <source>Let's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting the bodies of the &lt;code&gt;greet&lt;/code&gt; and &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; functions into soft scope contexts. First, let's put the body of &lt;code&gt;greet&lt;/code&gt; in a &lt;code&gt;for&lt;/code&gt; loop&amp;mdash;which is soft, rather than hard&amp;mdash;and evaluate it in the REPL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">각 축을 따라 크기가 3 인 &lt;code&gt;N&lt;/code&gt; 차원 배열 을 생성한다고 가정 해 보겠습니다 . 이러한 배열은 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">실험 할 수 있도록 새로운 환경을 설정합시다. 활성 환경을 설정하려면 &lt;code&gt;activate&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c76b2235d981c65461960877af26f1dbe64a8ee1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df8e39d6c6cb9f345698606b67ad54d1b7ae227" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a &lt;code&gt;Die&lt;/code&gt; with a random number of up to 20 sides (and at least 4):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">다음 예제를 보자 : 우리 는 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;n&lt;/code&gt; 까지 번호가 매겨진 가변 개수 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;Die&lt;/code&gt; 타입 을 구현한다 . 우리는 &lt;code&gt;rand(Die)&lt;/code&gt; 가 최대 20면 (및 4 개 이상)의 난수를 가진 다이를 생산하기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">사용해 봅시다. 먼저 &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; 에서 파일을 수정하고 간단한 함수를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">이것을 시도해 봅시다. &lt;code&gt;julia -p n&lt;/code&gt; 시작 하면 로컬 시스템에서 &lt;code&gt;n&lt;/code&gt; 작업자 프로세스가 제공 됩니다. 일반적으로 &lt;code&gt;n&lt;/code&gt; 은 머신의 CPU 스레드 (논리 코어) 수와 동일합니다. 있습니다 &lt;code&gt;-p&lt;/code&gt; 인수가 암시 적으로로드 모듈 &lt;code&gt;Distributed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">우리의 처분에 4 개의 스레드가 있는지 확인합시다.</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">기본 스레드를 사용하여 간단한 예를 살펴 보겠습니다. 0으로 구성된 배열을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">간단한 테스트 사례로 작업 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7dd0810d04c75d2aee9682c9c0e389c01969f9df" translate="yes" xml:space="preserve">
          <source>Lets start Julia with 4 threads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">경전철</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">가벼운 그늘</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">경량 &quot;녹색&quot;스레딩 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;코 루틴&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 하지만, 결과 저장 &lt;code&gt;broadcast(f, As...)&lt;/code&gt; 의 &lt;code&gt;dest&lt;/code&gt; 어레이. 참고 &lt;code&gt;dest&lt;/code&gt; 유일한 결과를 저장하는 데 사용되며, 인수를 제공하지 않는 &lt;code&gt;f&lt;/code&gt; 이도에 표시되지 않는 한 &lt;code&gt;As&lt;/code&gt; 같이 &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; 수행 &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 파일을 소유하지 않았거나 파일을 소유 한 그룹의 구성원이 아닌 사람에 대한 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 파일을 소유 한 그룹의 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="28e1f410620d4fc1c47d7926e96c9bea23f8d4c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt; the same size as &lt;code&gt;v&lt;/code&gt;, which is used to store (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 사전 할당 된 인덱스 벡터 &lt;code&gt;ix&lt;/code&gt; 를 허용합니다 . 경우 &lt;code&gt;initialized&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; (기본), &lt;code&gt;ix&lt;/code&gt; 값을 포함하도록 초기화 &lt;code&gt;1:length(ix)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">&lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 콜렉션을 리턴하지 않고 &lt;code&gt;results&lt;/code&gt; 출력을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">파일이 아닌 주어진 문자열에서 코드를 읽는 것을 제외하고 &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; ,하지만 매장에서 결과 &lt;code&gt;destination&lt;/code&gt; 가 아닌 새 컬렉션. &lt;code&gt;destination&lt;/code&gt; 은 최소한 첫 번째 컬렉션만큼 커야합니다.</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt; ,하지만 같이 연관성을 왼쪽으로 보장되는와 &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt; . 제공된 경우 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 정확히 한 번 사용됩니다. 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt; ,하지만 같이 보장 된 권리 연관성와 &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; &lt;/a&gt; . 제공된 경우 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 정확히 한 번 사용됩니다. 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; ,하지만 반환하거나 요청 된 형식의 값, 또는 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 문자열이 유효한 숫자를 포함하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">&lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt; 처럼 ! 그러나 주어진 순열의 역수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt; 만에 &lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt; 만에 &lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; 을&lt;/a&gt; . 리턴 튜플의 순서는 여전히 &lt;code&gt;(rd, wr)&lt;/code&gt; 이며, 즉 &lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 에서 읽을 데이터 는 &lt;code&gt;wr&lt;/code&gt; 에 기록 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 되나 보장은 왼쪽 연관성. 제공된 경우 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 정확히 한 번 사용됩니다. 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 되나 보장은 바로 연관성. 제공된 경우 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 정확히 한 번 사용됩니다. 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt; 하지만, 미리 할당 된 인덱스 벡터 받아 &lt;code&gt;ix&lt;/code&gt; . 경우 &lt;code&gt;initialized&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; (기본), &lt;code&gt;ix&lt;/code&gt; 값을 포함하도록 초기화 &lt;code&gt;1:length(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 하지만 기호 링크에 대한 링크 자체가 아니라 그것을 참조하는 파일에 대한 정보를 얻을 수 있습니다. 이 함수는 파일 객체 나 파일 설명자가 아닌 파일 경로에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f60e04278b9015f6c3e9ffaf7e10b12cd6419309" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.systemerror&quot;&gt;&lt;code&gt;systemerror&lt;/code&gt;&lt;/a&gt;, but for Windows API functions that use &lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt;&lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; to return an error code instead of setting &lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 결과는 &lt;code&gt;S&lt;/code&gt; 에 저장됩니다 (필요에 따라 크기가 조정 됨).</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 하지만, 입력 벡터를 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 복사를 수행하는 대신 주어진 색인으로 상위 배열 &lt;code&gt;A&lt;/code&gt; 에보기를 리턴합니다 . &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 호출 ! 반환 된 &lt;code&gt;SubArray&lt;/code&gt; 에서 바운드를 확인하지 않고 즉시 부모 배열에 대한 인덱스를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 복사를하는 대신 &lt;code&gt;i:j&lt;/code&gt; 또는 &lt;code&gt;r&lt;/code&gt; 범위 내의 상위 문자열 &lt;code&gt;s&lt;/code&gt; 로보기를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c974955b45097854e43f11799b1b6bcc9d8f3eee" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SamplerDie&lt;/code&gt;, any custom sampler must be a subtype of &lt;code&gt;Sampler{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the generated values. Note that &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt;, so this constrains what the first argument to &lt;code&gt;SamplerSimple&lt;/code&gt; can be (it's recommended to use &lt;code&gt;SamplerSimple&lt;/code&gt; like in the &lt;code&gt;Die&lt;/code&gt; example, where &lt;code&gt;x&lt;/code&gt; is simply forwarded while defining a &lt;code&gt;Sampler&lt;/code&gt; method). Similarly, &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">C 및 Java와 유사하지만 대부분의 동적 언어와 달리 Julia는 &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt; 라는 단일 문자를 나타내는 최고급 유형을 가지고 있습니다. &lt;code&gt;AbstractChar&lt;/code&gt; 의 내장 &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; 하위 유형 은 모든 유니 코드 문자 (UTF-8 인코딩을 기반으로 함)를 나타낼 수있는 32 비트 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">ccall과 마찬가지로 이러한 모든 인수는 포함 메소드가 정의 될 때 컴파일 타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">다른 언어와 마찬가지로 Julia는 벡터가 공통 인덱스 범위 만 공유하면되는 R과 달리 길이가 다른 벡터에 대한 연산을 항상 허용하지는 않습니다. 예를 들어 &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; 는 유효한 R이지만 동등한 &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; 는 Julia에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">다른 많은 환경과 마찬가지로 Julia에는 파일 이름 을 사용하고 파일에서 내용을 읽고 쓰는 데 사용할 수 있는 &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; 객체를 반환 하는 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 기능 이 있습니다. 예를 들어, &lt;code&gt;hello.txt&lt;/code&gt; 파일이 있으면 내용은 &lt;code&gt;Hello, World!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">비표준 문자열 리터럴과 마찬가지로 비표준 명령 리터럴은 명령 리터럴 구문의 접두사 변형을 사용하여 존재합니다. 리터럴 &lt;code&gt;custom`literal`&lt;/code&gt; 명령 은 &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; 로 구문 분석됩니다 . Julia 자체에는 비표준 명령 리터럴이 포함되어 있지 않지만 패키지는이 구문을 사용할 수 있습니다. &lt;code&gt;_str&lt;/code&gt; 접미사 대신 다른 구문 및 &lt;code&gt;_cmd&lt;/code&gt; 접미사를 제외하고 비표준 명령 리터럴은 비표준 문자열 리터럴과 똑같이 동작합니다.</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">원격 참조와 마찬가지로 공유 배열은 생성 노드의 가비지 수집에 종속되어 모든 참여 작업자의 참조를 해제합니다. 수명이 짧은 공유 배열 객체를 많이 만드는 코드는 가능한 빨리 이러한 객체를 명시 적으로 마무리하는 것이 좋습니다. 결과적으로 공유 세그먼트를 맵핑하는 메모리 및 파일 핸들이 더 빨리 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">마찬가지로 전역 변수 &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; 은 구성 파일 디렉토리에 대한 상대 경로를 결정합니다. 그런 다음 Julia는에서 &lt;code&gt;startup.jl&lt;/code&gt; 파일을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">CPU 기능 사용을 &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; 까지 제한하십시오 . 설정 &lt;code&gt;help&lt;/code&gt; 사용할 수있는 옵션을 보려면</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">&lt;code&gt;myfunc&lt;/code&gt; 의 3 행 에는 &lt;code&gt;maximum&lt;/code&gt; 에 대한 호출이 포함되어 있으며 여기에서 가져온 역 추적은 28 개 (80 개 중)입니다. 아래 에서이 유형의 입력 데이터 에 대한 &lt;code&gt;maximum&lt;/code&gt; 기능으로 시간이 많이 걸리는 작업을 수행하는 &lt;code&gt;base/reduce.jl&lt;/code&gt; 의 특정 위치를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">극을 포함하지 않는 선 통합</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">극 주위에 직사각형 경로를 가진 선 통합</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">극 주위 반원형 경로와 선 통합</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">선형 대수</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Julia의 선형 대수 함수는 &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt; 에서 함수를 호출하여 주로 구현됩니다 . 희소 분해는 &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt; 에서 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">선형 인덱스에서 데카르트 인덱스로의 변환은 &lt;code&gt;CartesianIndices&lt;/code&gt; 가 &lt;code&gt;AbstractArray&lt;/code&gt; 이고 선형으로 인덱스 될 수 있다는 사실을 이용합니다 .</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">선형 인덱싱</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
        <trans-unit id="848b264dd28237efb792aa43901c5f8f5aab83f0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cond()</source>
          <target state="translated">LinearAlgebra.cond()</target>
        </trans-unit>
        <trans-unit id="763a7ceb07efeb8156da716b3ef8c72573b2e7a4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.condskeel()</source>
          <target state="translated">LinearAlgebra.condskeel()</target>
        </trans-unit>
        <trans-unit id="639f206bebf5466d93a4ba2c03f4c4a29b6d5ea5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cross()</source>
          <target state="translated">LinearAlgebra.cross()</target>
        </trans-unit>
        <trans-unit id="d362f85f49e425d14c9978220ba2468f026a4067" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.det()</source>
          <target state="translated">LinearAlgebra.det()</target>
        </trans-unit>
        <trans-unit id="9abda27c81a472d3c63a1a657c4bee31686d49bc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diag()</source>
          <target state="translated">LinearAlgebra.diag()</target>
        </trans-unit>
        <trans-unit id="a7c7cacbbacea0c74222541b31910df567bdb6fb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagind()</source>
          <target state="translated">LinearAlgebra.diagind()</target>
        </trans-unit>
        <trans-unit id="1aef8c46a780d7765016e06dcf0a60d28ea11f98" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagm()</source>
          <target state="translated">LinearAlgebra.diagm()</target>
        </trans-unit>
        <trans-unit id="a943f01470875cdccf0a181e83dd06c730b15424" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.dot()</source>
          <target state="translated">LinearAlgebra.dot()</target>
        </trans-unit>
        <trans-unit id="03ea5670e94fee3cdb29e27ac132cc775f5e56ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen!()</source>
          <target state="translated">LinearAlgebra.eigen!()</target>
        </trans-unit>
        <trans-unit id="cc8ed4ca720004997b29c2c20ec5efc0988c78b6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen()</source>
          <target state="translated">LinearAlgebra.eigen()</target>
        </trans-unit>
        <trans-unit id="2006a7e56e96f08e8b101a5a98e0ce5438f051fd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmax()</source>
          <target state="translated">LinearAlgebra.eigmax()</target>
        </trans-unit>
        <trans-unit id="495e81e9aba12ed4873afb4fbfc9910161c06935" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmin()</source>
          <target state="translated">LinearAlgebra.eigmin()</target>
        </trans-unit>
        <trans-unit id="26373fb486681d828210b9eb0ada3db569ae5c9f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals!()</source>
          <target state="translated">LinearAlgebra.eigvals!()</target>
        </trans-unit>
        <trans-unit id="0ea943b4827b5ab3ec563686a13cb3fa1fff55de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals()</source>
          <target state="translated">LinearAlgebra.eigvals()</target>
        </trans-unit>
        <trans-unit id="28aa4c8f8bdda4caedf38b6c3a8bdcbdcb929bd5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvecs()</source>
          <target state="translated">LinearAlgebra.eigvecs()</target>
        </trans-unit>
        <trans-unit id="c1f95e8750fd563a65769748339ff1021d07a664" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.factorize()</source>
          <target state="translated">LinearAlgebra.factorize()</target>
        </trans-unit>
        <trans-unit id="245f91f9f7fc9cc2df2bdf9c6e80f2d0014ba521" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.givens()</source>
          <target state="translated">LinearAlgebra.givens()</target>
        </trans-unit>
        <trans-unit id="42383aca01a3095d7de60dfdd23a34e7aff90f64" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg!()</source>
          <target state="translated">LinearAlgebra.hessenberg!()</target>
        </trans-unit>
        <trans-unit id="4470ba44b04e09b558f06c669c830f27803c6604" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg()</source>
          <target state="translated">LinearAlgebra.hessenberg()</target>
        </trans-unit>
        <trans-unit id="6c9988c8648ff7a78199a102f477a45b0d53eb2c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isdiag()</source>
          <target state="translated">LinearAlgebra.isdiag()</target>
        </trans-unit>
        <trans-unit id="86f33205a580fff63ee19ac4843205922d3b8fbe" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ishermitian()</source>
          <target state="translated">LinearAlgebra.ishermitian()</target>
        </trans-unit>
        <trans-unit id="bad9e76616b147a9a6b22ef39daed46e374592df" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef!()</source>
          <target state="translated">LinearAlgebra.isposdef!()</target>
        </trans-unit>
        <trans-unit id="a3eff21980aaad7c0e8ab2571fde20cb7f9a4ac3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef()</source>
          <target state="translated">LinearAlgebra.isposdef()</target>
        </trans-unit>
        <trans-unit id="f184fbce8f26db2479a19308ee554a971eb91845" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issuccess()</source>
          <target state="translated">LinearAlgebra.issuccess()</target>
        </trans-unit>
        <trans-unit id="3b45090c87a6e9b6490c1b86caef6bc289e9811b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issymmetric()</source>
          <target state="translated">LinearAlgebra.issymmetric()</target>
        </trans-unit>
        <trans-unit id="27361a0db065863449e5514f392695a8843c50d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istril()</source>
          <target state="translated">LinearAlgebra.istril()</target>
        </trans-unit>
        <trans-unit id="154536c971d912aac5c55987e04b500058382262" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istriu()</source>
          <target state="translated">LinearAlgebra.istriu()</target>
        </trans-unit>
        <trans-unit id="8702b95d8a1b1c5f29f2af932f7b339f131fc979" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldiv!()</source>
          <target state="translated">LinearAlgebra.ldiv!()</target>
        </trans-unit>
        <trans-unit id="f628486016bf8bb2592d19dea3a4ef558655d6d8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt!()</source>
          <target state="translated">LinearAlgebra.ldlt!()</target>
        </trans-unit>
        <trans-unit id="c666984e1b5f4107efe1cc308dd23df3742d794b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt()</source>
          <target state="translated">LinearAlgebra.ldlt()</target>
        </trans-unit>
        <trans-unit id="87445caeed19ddaad799f1582737a52e40bde9e9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lmul!()</source>
          <target state="translated">LinearAlgebra.lmul!()</target>
        </trans-unit>
        <trans-unit id="f5e67426386e0244313c54bbe9e11137664a7611" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logabsdet()</source>
          <target state="translated">LinearAlgebra.logabsdet()</target>
        </trans-unit>
        <trans-unit id="a6c4efc9dcb4f29a594919d0a4a0c4ecc1b0eb49" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logdet()</source>
          <target state="translated">LinearAlgebra.logdet()</target>
        </trans-unit>
        <trans-unit id="aed69ea345782519298a7b83289a6fd2a0d20a22" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate!()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate!()</target>
        </trans-unit>
        <trans-unit id="065afe0c96edc42ef451662159895201fbe9f74e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate()</target>
        </trans-unit>
        <trans-unit id="10584a564acc8cafcbd880790d5a3223c614e997" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate!()</source>
          <target state="translated">LinearAlgebra.lowrankupdate!()</target>
        </trans-unit>
        <trans-unit id="952be3b610fe2e74216ee89053ff75f7419d4b28" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate()</source>
          <target state="translated">LinearAlgebra.lowrankupdate()</target>
        </trans-unit>
        <trans-unit id="47c1af320726090525f6d61978444c2ea6c9d0ab" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq!()</source>
          <target state="translated">LinearAlgebra.lq!()</target>
        </trans-unit>
        <trans-unit id="5375dc727ff35daa144ad173772170766a77fc84" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq()</source>
          <target state="translated">LinearAlgebra.lq()</target>
        </trans-unit>
        <trans-unit id="19c721bb8412a08453cd493f076ec151ec21919f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu!()</source>
          <target state="translated">LinearAlgebra.lu!()</target>
        </trans-unit>
        <trans-unit id="416610984f232609e5a5300d47b309939683e378" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu()</source>
          <target state="translated">LinearAlgebra.lu()</target>
        </trans-unit>
        <trans-unit id="e5fa084cafc39d82b66f8c8dc2e12353e03f3704" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lyap()</source>
          <target state="translated">LinearAlgebra.lyap()</target>
        </trans-unit>
        <trans-unit id="7c99824c12d49750627f623ddd871e015e24c8c8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.mul!()</source>
          <target state="translated">LinearAlgebra.mul!()</target>
        </trans-unit>
        <trans-unit id="24933f7d1d932d73149fe8820b01ff0b8033488b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.norm()</source>
          <target state="translated">LinearAlgebra.norm()</target>
        </trans-unit>
        <trans-unit id="1639614f72f390991f3c415b26fb661709818686" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize!()</source>
          <target state="translated">LinearAlgebra.normalize!()</target>
        </trans-unit>
        <trans-unit id="bfa13b34d43df925bb276eb2b2712a5d9852eb7e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize()</source>
          <target state="translated">LinearAlgebra.normalize()</target>
        </trans-unit>
        <trans-unit id="123d380f57ea839fe9386bdced9ecbd4bfa56d19" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.nullspace()</source>
          <target state="translated">LinearAlgebra.nullspace()</target>
        </trans-unit>
        <trans-unit id="c473c4d32b408a10287aa2043ce1410d94d0f8ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.opnorm()</source>
          <target state="translated">LinearAlgebra.opnorm()</target>
        </trans-unit>
        <trans-unit id="27873174504747d088813d705a5c2057e78a6fa4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur!()</source>
          <target state="translated">LinearAlgebra.ordschur!()</target>
        </trans-unit>
        <trans-unit id="a0cf19c8a32916092aead5343f54d5c29799bf44" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur()</source>
          <target state="translated">LinearAlgebra.ordschur()</target>
        </trans-unit>
        <trans-unit id="f7c256ca3b590fa1c68a6c5c968889de72035a1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.peakflops()</source>
          <target state="translated">LinearAlgebra.peakflops()</target>
        </trans-unit>
        <trans-unit id="3b416155a9648251a3dab2c1f86f654cbc45f766" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.pinv()</source>
          <target state="translated">LinearAlgebra.pinv()</target>
        </trans-unit>
        <trans-unit id="24a51a0a6b9a091503d04d18751653ab70e63907" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr!()</source>
          <target state="translated">LinearAlgebra.qr!()</target>
        </trans-unit>
        <trans-unit id="32cd922076c561139a5133388ff3de86aee2f838" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr()</source>
          <target state="translated">LinearAlgebra.qr()</target>
        </trans-unit>
        <trans-unit id="25c16b6062a5721edfc89f6f1b58866c9999fd30" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rank()</source>
          <target state="translated">LinearAlgebra.rank()</target>
        </trans-unit>
        <trans-unit id="292d72424657c4aa082122899b52a2ca37500f51" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rdiv!()</source>
          <target state="translated">LinearAlgebra.rdiv!()</target>
        </trans-unit>
        <trans-unit id="12f33b8246f53c039178bae0493a696a7aff5605" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rmul!()</source>
          <target state="translated">LinearAlgebra.rmul!()</target>
        </trans-unit>
        <trans-unit id="3ce18ca8ac025f0f6376582ad516bf09b60beb97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur!()</source>
          <target state="translated">LinearAlgebra.schur!()</target>
        </trans-unit>
        <trans-unit id="d1c7d7a7be766a0227fceaaeba6b125494ecacc5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur()</source>
          <target state="translated">LinearAlgebra.schur()</target>
        </trans-unit>
        <trans-unit id="875a6969d0c4c9e685666728e0a075eb8c05fd34" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.stride1()</source>
          <target state="translated">LinearAlgebra.stride1()</target>
        </trans-unit>
        <trans-unit id="e830629f4eb2b2f684c386f2e83c4cd8d40d08c7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd!()</source>
          <target state="translated">LinearAlgebra.svd!()</target>
        </trans-unit>
        <trans-unit id="9ac0ee09de07e5d20a225d6487f69df6607076ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd()</source>
          <target state="translated">LinearAlgebra.svd()</target>
        </trans-unit>
        <trans-unit id="988da18329a53e16de1bd6da5c1f8e417469db10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals!()</source>
          <target state="translated">LinearAlgebra.svdvals!()</target>
        </trans-unit>
        <trans-unit id="5f88c1d8eeb98c086bcbe1a4efbb1ecfea5359dd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals()</source>
          <target state="translated">LinearAlgebra.svdvals()</target>
        </trans-unit>
        <trans-unit id="08228eabf0d0dbc8efbc58ae8f1948646134de59" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.sylvester()</source>
          <target state="translated">LinearAlgebra.sylvester()</target>
        </trans-unit>
        <trans-unit id="b64e39526f66a386113f15a1ffcc6de69561a7ea" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tr()</source>
          <target state="translated">LinearAlgebra.tr()</target>
        </trans-unit>
        <trans-unit id="421907594b9500deaf9ebf0a78b09e30e97d0969" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.transpose!()</source>
          <target state="translated">LinearAlgebra.transpose!()</target>
        </trans-unit>
        <trans-unit id="9e11fafcc7c6da90f84fe85de7b987df1ab51a50" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril!()</source>
          <target state="translated">LinearAlgebra.tril!()</target>
        </trans-unit>
        <trans-unit id="943eef9228abf32d3acece710a792a24018ad5d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril()</source>
          <target state="translated">LinearAlgebra.tril()</target>
        </trans-unit>
        <trans-unit id="a45cd5a2a1e79b5eba2cf22f01b2ab8a64dcfeec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu!()</source>
          <target state="translated">LinearAlgebra.triu!()</target>
        </trans-unit>
        <trans-unit id="6fa6a88dc15e19a67b21c0de2d88e00b6f996707" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu()</source>
          <target state="translated">LinearAlgebra.triu()</target>
        </trans-unit>
        <trans-unit id="3c8e04f396865f7c2a68d63b51786aa52075e28e" translate="yes" xml:space="preserve">
          <source>LinearIndices</source>
          <target state="translated">LinearIndices</target>
        </trans-unit>
        <trans-unit id="97539d497456e8ae64ab21e30e72713379418284" translate="yes" xml:space="preserve">
          <source>Link Symbol</source>
          <target state="translated">링크 심볼</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="6b94a7684e8c9e36ac262755ad390b4f84d2ef0f" translate="yes" xml:space="preserve">
          <source>Links to each of these download types can be found on the download page at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;. Note that not all versions of Julia are available for all platforms.</source>
          <target state="translated">이러한 각 다운로드 유형에 대한 링크는 다운로드 페이지 ( &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/)&lt;/a&gt; 에서 찾을 수 있습니다 . 모든 플랫폼에서 모든 버전의 Julia를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0bd309fe8c158ca93bf01439f879abad96a2d9ae" translate="yes" xml:space="preserve">
          <source>Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">외부 또는 내부 주소에 대한 링크는 다음 구문을 사용하여 작성할 수 있습니다. 여기서 대괄호로 묶인 텍스트 &lt;code&gt;[ ]&lt;/code&gt; 는 링크 이름이고 괄호로 묶인 텍스트 &lt;code&gt;( )&lt;/code&gt; 는 URL입니다.</target>
        </trans-unit>
        <trans-unit id="800618f12f938e53d9c627356df00435b9a51301" translate="yes" xml:space="preserve">
          <source>Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f988d8955026b4558444945785c9b5dbc82a7b4f" translate="yes" xml:space="preserve">
          <source>Lipstick</source>
          <target state="translated">Lipstick</target>
        </trans-unit>
        <trans-unit id="97c285fe5eb710455fe67ecf43ec5d1858f0c7b3" translate="yes" xml:space="preserve">
          <source>Lisp-like macros and other metaprogramming facilities</source>
          <target state="translated">리스프와 유사한 매크로 및 기타 메타 프로그래밍 기능</target>
        </trans-unit>
        <trans-unit id="17810a1438ef5dd3fd5dc6cdd00bf4fbecb5795c" translate="yes" xml:space="preserve">
          <source>List the number of revisions between &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; (committish OIDs in string form). Since &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; may be on different branches, &lt;code&gt;revcount&lt;/code&gt; performs a &quot;left-right&quot; revision list (and count), returning a tuple of &lt;code&gt;Int&lt;/code&gt;s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.</source>
          <target state="translated">&lt;code&gt;commit1&lt;/code&gt; 과 &lt;code&gt;commit2&lt;/code&gt; 사이의 개정 횟수를 나열하십시오 (문자열 형식의 OID 커미트). 이후 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 은 , 다른 지점에있을 수 &lt;code&gt;revcount&lt;/code&gt; 행한다는 &quot;좌우&quot;수정리스트 (카운트)의 튜플 반환 &lt;code&gt;Int&lt;/code&gt; S - 각각 좌우 커밋 수가. 왼쪽 (또는 오른쪽) 커밋은 커밋에 도달 할 수있는 트리에서 대칭 차이의 어느 쪽을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="388721610609dc9098cd8f36e62807e84d1fade7" translate="yes" xml:space="preserve">
          <source>Listen on port on the address specified by &lt;code&gt;addr&lt;/code&gt;. By default this listens on &lt;code&gt;localhost&lt;/code&gt; only. To listen on all interfaces pass &lt;code&gt;IPv4(0)&lt;/code&gt; or &lt;code&gt;IPv6(0)&lt;/code&gt; as appropriate. &lt;code&gt;backlog&lt;/code&gt; determines how many connections can be pending (not having called &lt;a href=&quot;#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;) before the server will begin to reject them. The default value of &lt;code&gt;backlog&lt;/code&gt; is 511.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 에 의해 지정된 주소에서 포트를 청취하십시오 . 기본적으로 &lt;code&gt;localhost&lt;/code&gt; 에서만 청취합니다 . 모든 인터페이스에서 청취하려면 &lt;code&gt;IPv4(0)&lt;/code&gt; 또는 &lt;code&gt;IPv6(0)&lt;/code&gt; 을 적절하게 전달하십시오. &lt;code&gt;backlog&lt;/code&gt; 그는 서버가 연결을 거부하기 전에 보류중인 연결 수 ( &lt;a href=&quot;#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 를 호출하지 않은 연결 수)를 결정 합니다. &lt;code&gt;backlog&lt;/code&gt; 의 기본값 은 511입니다.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="8aa67be98327d7646247b7e62d87af940b94fc8a" translate="yes" xml:space="preserve">
          <source>Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.</source>
          <target state="translated">목록에는 목록, 코드 블록 또는 따옴표 블록과 같은 다른 중첩 된 최상위 요소가 포함될 수 있습니다. 목록에 최상위 요소를 포함시킬 때는 각 목록 항목 사이에 빈 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c9fcbea9e81be568fdc5a4af6993f666806fde2" translate="yes" xml:space="preserve">
          <source>Literal floating-point numbers are represented in the standard formats, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E-notation&lt;/a&gt; when necessary:</source>
          <target state="translated">리터럴 부동 소수점 숫자는 필요한 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E- 표기법을&lt;/a&gt; 사용하여 표준 형식 으로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="3562cae13eedce4e4d416c818141141826f44ea7" translate="yes" xml:space="preserve">
          <source>Literal integers are represented in the standard manner:</source>
          <target state="translated">리터럴 정수는 표준 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ab27329d47948b21415226c577e214e77fab191" translate="yes" xml:space="preserve">
          <source>Literal one of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">유형 &lt;code&gt;x&lt;/code&gt; 또는 변수 &lt;code&gt;x&lt;/code&gt; 유형의 리터럴</target>
        </trans-unit>
        <trans-unit id="a585d71445ba7f9e68c5da186d786f4437873367" translate="yes" xml:space="preserve">
          <source>Literal zero and one</source>
          <target state="translated">리터럴 0과 1</target>
        </trans-unit>
        <trans-unit id="24e8678ee4be704fc611c4a474de77fa54f1d95f" translate="yes" xml:space="preserve">
          <source>Literal zero of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 유형 또는 변수 &lt;code&gt;x&lt;/code&gt; 유형의 리터럴 0</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="c6a4e1f3b4978cbaedfb2e99a34a61a5e64f4b8d" translate="yes" xml:space="preserve">
          <source>Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.</source>
          <target state="translated">변수, 함수 또는 Julia 프로그램의 다른 부분을 나타내는 텍스트를 작성할 때 리터럴을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cccfebf2b6bb84af7b7416c30102f0fb5345d20a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; immediately on all processors</source>
          <target state="translated">모든 프로세서에서 즉시 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 로드</target>
        </trans-unit>
        <trans-unit id="221a8e52842df5b19245cbcdd992a3dedaa109d5" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 로드</target>
        </trans-unit>
        <trans-unit id="ea8d49a8f75a3b101a94caadd4a63e8ab235d750" translate="yes" xml:space="preserve">
          <source>Load a shared library, returning an opaque handle.</source>
          <target state="translated">불투명 한 핸들을 돌려주는 공유 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="c25f7156c983ea8a18f757a2b60fb37dd817a64d" translate="yes" xml:space="preserve">
          <source>Load a value of type &lt;code&gt;T&lt;/code&gt; from the address of the &lt;code&gt;i&lt;/code&gt;th element (1-indexed) starting at &lt;code&gt;p&lt;/code&gt;. This is equivalent to the C expression &lt;code&gt;p[i-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 시작 하여 &lt;code&gt;i&lt;/code&gt; 번째 요소 의 주소 (1 색인) 에서 &lt;code&gt;T&lt;/code&gt; 유형의 값을로드합니다 . 이것은 C 표현식 &lt;code&gt;p[i-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37f3c2f4c2bbe8c48d77f7372d4681f5071a6c1b" translate="yes" xml:space="preserve">
          <source>Load or save history</source>
          <target state="translated">히스토리로드 또는 저장</target>
        </trans-unit>
        <trans-unit id="2a3d64c128591f94e5fcdc12bbe22bc691844af1" translate="yes" xml:space="preserve">
          <source>Load the file using &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, evaluate all expressions, and return the value of the last one.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; 를&lt;/a&gt; 사용하여 파일을로드하고 모든 표현식을 평가 한 후 마지막 표현식의 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1c25d02a3443b64be0a5e8874e859825f3a072cf" translate="yes" xml:space="preserve">
          <source>Loads a source file, in the context of the &lt;code&gt;Main&lt;/code&gt; module, on every active node, searching standard locations for files. &lt;code&gt;require&lt;/code&gt; is considered a top-level operation, so it sets the current &lt;code&gt;include&lt;/code&gt; path but does not use it to search for files (see help for &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;). This function is typically used to load library code, and is implicitly called by &lt;code&gt;using&lt;/code&gt; to load packages.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 모듈 의 컨텍스트 에서 모든 활성 노드에 소스 파일을로드하여 파일의 표준 위치를 검색합니다. &lt;code&gt;require&lt;/code&gt; 는 최상위 작업으로 간주되므로 현재 &lt;code&gt;include&lt;/code&gt; 경로를 설정하지만 파일을 검색하는 데 사용하지는 않습니다 ( &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 도움말 참조 ). 이 함수는 일반적으로 라이브러리 코드를로드하는 데 사용되며 패키지를로드 하는 데 &lt;code&gt;using&lt;/code&gt; 암시 적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2aaca902d4d3758e11a3b458199407392409931c" translate="yes" xml:space="preserve">
          <source>Local Scope</source>
          <target state="translated">지역 범위</target>
        </trans-unit>
        <trans-unit id="53e6be3ba94721357dc8f1cd8a4a35bc46260d53" translate="yes" xml:space="preserve">
          <source>Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.</source>
          <target state="translated">지역 상수는 상당히 다릅니다. 컴파일러는 로컬 변수가 상수 인 경우 자동으로 결정할 수 있으므로 로컬 상수 선언이 필요하지 않으며 실제로는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bc74c802188a5ae5dd86ce1121ca4599d93af45" translate="yes" xml:space="preserve">
          <source>Local invocations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea223f531a712477fac84f8fcf490b4f65ae3a6" translate="yes" xml:space="preserve">
          <source>Local invocations(@id man-distributed-local-invocations)</source>
          <target state="translated">로컬 호출 (@id man-distributed-local-vocations)</target>
        </trans-unit>
        <trans-unit id="40051a807238da75ab231f8a8a71c830f614ed27" translate="yes" xml:space="preserve">
          <source>Local variable &lt;code&gt;x&lt;/code&gt; starts as an integer, and after one loop iteration becomes a floating-point number (the result of &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</source>
          <target state="translated">지역 변수 &lt;code&gt;x&lt;/code&gt; 는 정수로 시작하고 한 루프 반복 후 부동 소수점 숫자 ( &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; 연산자 의 결과 )가됩니다. 이로 인해 컴파일러에서 루프 본문을 최적화하기가 더 어려워집니다. 몇 가지 가능한 수정 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="7e9d4e021d5117e7b0d661a7918f799df5c20541" translate="yes" xml:space="preserve">
          <source>Lock With Ink Pen</source>
          <target state="translated">잉크 펜으로 잠금</target>
        </trans-unit>
        <trans-unit id="2d7a18ee66cedde04088fccb894adfaa5d0be6f1" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 에서 &lt;code&gt;logger&lt;/code&gt; 에 메시지를 로그하십시오 . 메시지가 생성 된 논리적 위치는 모듈 &lt;code&gt;_module&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 의해 제공됩니다 . &lt;code&gt;file&lt;/code&gt; 과 &lt;code&gt;line&lt;/code&gt; 소스 위치 . &lt;code&gt;id&lt;/code&gt; 는 필터링시 로그 문을 식별하기위한 키로 사용되는 임의의 고유 한 &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2db3a05837e9b250facfd93e1fe4f8c7f938c9cc" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique value (typically a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;) to be used as a key to identify the log statement when filtering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ccff841d7f5fb35e7f3223eae831d879121ed8" translate="yes" xml:space="preserve">
          <source>Log event structure</source>
          <target state="translated">로그 이벤트 구조</target>
        </trans-unit>
        <trans-unit id="5de4f5e761f85511e1c9dded76464677e6b5b91b" translate="yes" xml:space="preserve">
          <source>Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The &lt;code&gt;Test&lt;/code&gt; module provides a &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt;&lt;code&gt;@test_logs&lt;/code&gt;&lt;/a&gt; macro that can be used to pattern match against the log event stream.</source>
          <target state="translated">로그 이벤트는 일반 코드 실행의 부작용이지만 특정 정보 메시지 및 경고를 테스트하려는 경우가 있습니다. &lt;code&gt;Test&lt;/code&gt; 모듈이 제공 &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt; &lt;code&gt;@test_logs&lt;/code&gt; 을&lt;/a&gt; 로그 이벤트 스트림에 대한 패턴 일치에 사용할 수있는 매크로를.</target>
        </trans-unit>
        <trans-unit id="39e0c0b6171a5e937cc4b913037f6617883ef778" translate="yes" xml:space="preserve">
          <source>Log levels less than &lt;code&gt;min_level&lt;/code&gt; are filtered out.</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; 미만의 로그 수준 이 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="b95a88cbf9b7104d12a1c6e6be0a2df585c9c414" translate="yes" xml:space="preserve">
          <source>Log of absolute value of matrix determinant. Equivalent to &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">행렬식 결정자의 절대 값 로그. 동등 &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt; 이지만 증가 제공 정확성 및 / 또는 속도.</target>
        </trans-unit>
        <trans-unit id="25e0bc59a9512a0f503efed371b6e58c737cb2b5" translate="yes" xml:space="preserve">
          <source>Log of matrix determinant. Equivalent to &lt;code&gt;log(det(M))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">행렬 결정의 로그. 당량 &lt;code&gt;log(det(M))&lt;/code&gt; 하지만, 높은 정확도 및 / 또는 속도를 제공 할 수있다.</target>
        </trans-unit>
        <trans-unit id="09b41ebbca90f28e72616fb548aed5c2cdb190af" translate="yes" xml:space="preserve">
          <source>Logger installation and inspection:</source>
          <target state="translated">로거 설치 및 검사 :</target>
        </trans-unit>
        <trans-unit id="3e0a58fce8ac790c3d3776b2f9cb69da4b8e968b" translate="yes" xml:space="preserve">
          <source>Logger which disables all messages and produces no output - the logger equivalent of /dev/null.</source>
          <target state="translated">모든 메시지를 비활성화하고 출력을 생성하지 않는 로거-로거는 / dev / null과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c489f7460af4426236655b519a2e843c0796afcf" translate="yes" xml:space="preserve">
          <source>Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.</source>
          <target state="translated">Julia REPL과의 대화식 작업과 같이 텍스트 콘솔에서 가독성에 최적화 된 형식의 로거</target>
        </trans-unit>
        <trans-unit id="012294fbc07fc652fdbbd3b8b48183b6e7925dda" translate="yes" xml:space="preserve">
          <source>Loggers</source>
          <target state="translated">Loggers</target>
        </trans-unit>
        <trans-unit id="ab6dfdab464b019150c40525f7d8fef7f42317d8" translate="yes" xml:space="preserve">
          <source>Loggers that are supplied with the system:</source>
          <target state="translated">시스템과 함께 제공되는 로거 :</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="84dd6708d003df0c49c9ba90e02bb2e238e90fae" translate="yes" xml:space="preserve">
          <source>Logging module</source>
          <target state="translated">로깅 모듈</target>
        </trans-unit>
        <trans-unit id="89da04acc02b6d97d3dda5b51691b7f2df8ab3f2" translate="yes" xml:space="preserve">
          <source>Logical (or boolean) operators &lt;code&gt;|&lt;/code&gt;, &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; are another special case, as they only propagate &lt;code&gt;missing&lt;/code&gt; values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;three-valued logic&lt;/em&gt;&lt;/a&gt; which are also implemented by &lt;code&gt;NULL&lt;/code&gt; in SQL and &lt;code&gt;NA&lt;/code&gt; in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.</source>
          <target state="translated">논리 (또는 부울) 연산자 &lt;code&gt;|&lt;/code&gt; , &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; 는 논리적으로 필요한 경우 결 &lt;code&gt;missing&lt;/code&gt; 만 전파하므로 또 다른 특수한 경우 입니다. 이러한 연산자의 경우 결과가 불확실한 지 여부 는 SQL의 &lt;code&gt;NULL&lt;/code&gt; 및 R의 &lt;code&gt;NA&lt;/code&gt; 에 의해 구현되는 잘 정립 된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;3 값 논리&lt;/em&gt;&lt;/a&gt; 규칙에 따라 특정 작업에 따라 다릅니다 .이 추상 정의는 실제로 비교적 자연에 해당합니다. 구체적인 예를 통해 가장 잘 설명되는 행동.</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">논리 및</target>
        </trans-unit>
        <trans-unit id="67c3357e4a7007cce9dad8abe1e464a6faaed6cf" translate="yes" xml:space="preserve">
          <source>Logical And With Dot Above</source>
          <target state="translated">논리와 위의 점</target>
        </trans-unit>
        <trans-unit id="ad73258bccc391936166d8f628d173e6ce3c7d3d" translate="yes" xml:space="preserve">
          <source>Logical And With Double Overbar</source>
          <target state="translated">논리적 및 이중 오버 바</target>
        </trans-unit>
        <trans-unit id="3a27d20134d696f264e94d803f411cd413383e05" translate="yes" xml:space="preserve">
          <source>Logical And With Double Underbar</source>
          <target state="translated">논리적 및 이중 언더 바</target>
        </trans-unit>
        <trans-unit id="cb54d54f9d2ab29ccd05e2998f6679b7b0a51e55" translate="yes" xml:space="preserve">
          <source>Logical And With Horizontal Dash</source>
          <target state="translated">논리적 및 수평 대시</target>
        </trans-unit>
        <trans-unit id="f6e1b3f2c2e3537f4121f6786ee7d2f1fdcc7214" translate="yes" xml:space="preserve">
          <source>Logical And With Middle Stem</source>
          <target state="translated">논리적 및 중간 줄기</target>
        </trans-unit>
        <trans-unit id="cee1bd132c4db9d40b5015470294a3309557d652" translate="yes" xml:space="preserve">
          <source>Logical And With Underbar</source>
          <target state="translated">논리적 및 언더 바</target>
        </trans-unit>
        <trans-unit id="fed4dc8cd8f466453469c24bdf945b136419ffef" translate="yes" xml:space="preserve">
          <source>Logical Operations on Arrays</source>
          <target state="translated">어레이의 논리 연산</target>
        </trans-unit>
        <trans-unit id="6b4765205b7632c3acd6f4b0016fe8b785f2d3e7" translate="yes" xml:space="preserve">
          <source>Logical Or</source>
          <target state="translated">논리 또는</target>
        </trans-unit>
        <trans-unit id="090611a42c7037c3c2bfae57153874d16efc59fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Dot Above</source>
          <target state="translated">논리적 또는 위의 점</target>
        </trans-unit>
        <trans-unit id="563b798880b958c47070de3da511383e45a77828" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Overbar</source>
          <target state="translated">논리적 또는 이중 오버 바</target>
        </trans-unit>
        <trans-unit id="7d683350404e6e9be8c9e2e65c1b673dedd263fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Underbar</source>
          <target state="translated">논리적 또는 이중 언더 바 있음</target>
        </trans-unit>
        <trans-unit id="66977fa56bf367cf9edb7c775c7703db1cb43216" translate="yes" xml:space="preserve">
          <source>Logical Or With Horizontal Dash</source>
          <target state="translated">논리적 또는 수평 대시</target>
        </trans-unit>
        <trans-unit id="04ee9b0a538e88f1af58f8f182ea27dfc50a851f" translate="yes" xml:space="preserve">
          <source>Logical Or With Middle Stem</source>
          <target state="translated">논리적 또는 중간 줄기</target>
        </trans-unit>
        <trans-unit id="daaabe581776a9024a83133896be28214c21d330" translate="yes" xml:space="preserve">
          <source>Logical indexing</source>
          <target state="translated">논리적 인덱싱</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="621d5dc0716b80a4b24a2ab36703beb47f8e9970" translate="yes" xml:space="preserve">
          <source>Lollipop</source>
          <target state="translated">Lollipop</target>
        </trans-unit>
        <trans-unit id="3dd8963fe38f95d47b45ad8afdc61266eb3c705b" translate="yes" xml:space="preserve">
          <source>Long Left Right Arrow</source>
          <target state="translated">왼쪽 긴 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c35393bc1526e081d6c45ef1fbb48cf17d0c8bf0" translate="yes" xml:space="preserve">
          <source>Long Left Right Double Arrow</source>
          <target state="translated">왼쪽 긴 오른쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="e284c1dcf57b9e16654ce906eebd4ade05f805b3" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow</source>
          <target state="translated">긴 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="0b53faa1153d8df2a62532b492821e710a37aaad" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow From Bar</source>
          <target state="translated">바에서 긴 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="88125db03adc91c18e4b911d1e8543cb06fb2b1b" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow</source>
          <target state="translated">긴 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="f84697639bf777eba1549b50e7d78fe9fc6c3b1a" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow From Bar</source>
          <target state="translated">바에서 왼쪽으로 길게 두 번 화살표</target>
        </trans-unit>
        <trans-unit id="b98fbfea9069a23125b4969bdb4539cfde1d985c" translate="yes" xml:space="preserve">
          <source>Long Leftwards Squiggle Arrow</source>
          <target state="translated">긴 왼쪽 구불 구불 한 화살</target>
        </trans-unit>
        <trans-unit id="ea5233fe4b9cd95205a27a4dce0a7bbfb8aae26f" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow</source>
          <target state="translated">긴 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="529625a98773524bc52c828a69957fbaaca9fd91" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow From Bar</source>
          <target state="translated">바에서 긴 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="0e2515e3d0dae9c81aaf0c44bf451d94396badbf" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow</source>
          <target state="translated">긴 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="1278f556f7a008b8d9f849c9d7f07ad7d2fda02a" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow From Bar</source>
          <target state="translated">바에서 긴 오른쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="3c3264b81769074f17253d6ac449ae0214eb0511" translate="yes" xml:space="preserve">
          <source>Long Rightwards Squiggle Arrow</source>
          <target state="translated">오른쪽으로 긴 구불 구불 한 화살</target>
        </trans-unit>
        <trans-unit id="f9731487237a7d36eb57c97e02893eb0fcbe12b9" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using its name and URL. Uses the default fetch refspec.</source>
          <target state="translated">이름과 URL을 사용하여 원격 자식 저장소를 찾으십시오. 기본 페치 참조 스펙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3e71ff4dab9481f1e14a82514827c17c83dee43" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using only its URL, not its name.</source>
          <target state="translated">이름이 아닌 URL 만 사용하여 원격 자식 저장소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6d614bcd7bb6dd66d43226d39894a37944a369ee" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).</source>
          <target state="translated">리포지토리의 이름과 URL을 사용하여 원격 git 리포지토리를 찾고 원격에서 페치하는 방법 (예 : 페치 할 원격 브랜치)에 대한 사양을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="297e4906774f5b0f9f9ea2352dd36b66f2c9d575" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, return callable function pointer on success.</source>
          <target state="translated">공유 라이브러리 핸들에서 심볼을 찾고 성공하면 호출 가능한 함수 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b2554c797a77ef5cd564f4094822fce342e2ced7" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, silently return &lt;code&gt;C_NULL&lt;/code&gt; on lookup failure. This method is now deprecated in favor of &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt;.</source>
          <target state="translated">공유 라이브러리 핸들에서 심볼을 &lt;code&gt;C_NULL&lt;/code&gt; 조회 실패시 C_NULL 을 자동으로 반환 합니다. 이 메소드는 이제 &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c18a26a0372be6990fb3f7d9280fb8a4395903a4" translate="yes" xml:space="preserve">
          <source>Look up the value of a key in the current task's task-local storage.</source>
          <target state="translated">현재 작업의 작업 로컬 저장소에서 키 값을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1a5964da6a0276ac045eacedf1ca054ba281575e" translate="yes" xml:space="preserve">
          <source>Lookup the name of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;repo&lt;/code&gt; is currently detached, return the name of the HEAD it's detached from.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; 의 현재 HEAD 이름을 검색하십시오 . &lt;code&gt;repo&lt;/code&gt; 가 현재 분리되어있는 경우 분리 된 HEAD의 이름을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="c7d22d27b21054a2d862fb3e778055ec62497845" translate="yes" xml:space="preserve">
          <source>Lookup the object id of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; 의 현재 HEAD의 오브젝트 ID를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="2897343d4dfca50b3dbd880e6b406397dfc276be" translate="yes" xml:space="preserve">
          <source>Lookup the status of the file at &lt;code&gt;path&lt;/code&gt; in the git repository &lt;code&gt;repo&lt;/code&gt;. For instance, this can be used to check if the file at &lt;code&gt;path&lt;/code&gt; has been modified and needs to be staged and committed.</source>
          <target state="translated">git 저장소 &lt;code&gt;repo&lt;/code&gt; 의 &lt;code&gt;path&lt;/code&gt; 에서 파일의 상태를 찾으십시오 . 예를 들어, &lt;code&gt;path&lt;/code&gt; 파일이 있는지 확인하는 데 사용할 수 있습니다 이 수정되었고 준비 및 커밋해야하는지 .</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292714b14a57c3b911bea2bc02c843a11e53cd72" translate="yes" xml:space="preserve">
          <source>Loudly Crying Face</source>
          <target state="translated">큰 소리로 우는 얼굴</target>
        </trans-unit>
        <trans-unit id="68479172d96d6399ed79d6c3cc2275a9e4cb417d" translate="yes" xml:space="preserve">
          <source>Love Hotel</source>
          <target state="translated">러브 호텔</target>
        </trans-unit>
        <trans-unit id="e8ed5bf829210dcfddc85b2455095cf9764bc443" translate="yes" xml:space="preserve">
          <source>Love Letter</source>
          <target state="translated">연애 편지</target>
        </trans-unit>
        <trans-unit id="1e20259076165d87571f777f8f501c9eec6cf077" translate="yes" xml:space="preserve">
          <source>Low Brightness Symbol</source>
          <target state="translated">저휘도 기호</target>
        </trans-unit>
        <trans-unit id="3c768d286c3fa1a1be3b0b32968dce7e2bf6df5f" translate="yes" xml:space="preserve">
          <source>Low-level (C kernel) based operations &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt; which are respectively an OpenCL interface and a CUDA wrapper.</source>
          <target state="translated">각각 OpenCL 인터페이스 및 CUDA 랩퍼 인 저수준 (C 커널) 기반 작업 &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d470f206b953bd94a63cddee039b55b43eb02d8" translate="yes" xml:space="preserve">
          <source>Low-level (Julia Kernel) interfaces like &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt; which is a Julia native CUDA implementation.</source>
          <target state="translated">Julia 네이티브 CUDA 구현 인 &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt; 과 같은 저수준 (Julia Kernel) 인터페이스</target>
        </trans-unit>
        <trans-unit id="8a939192d22d6941f17735b112fcce8351ea8eba" translate="yes" xml:space="preserve">
          <source>Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.</source>
          <target state="translated">문서화해야하는 매크로에 의해 리턴 된 표현식을 표시하는 데 사용되는 저수준 매크로. 둘 이상의 표현식이 표시되면 동일한 docstring이 각 표현식에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="93d0030ec86c684d10a9c49e09b2634f0ca13492" translate="yes" xml:space="preserve">
          <source>Low-level matrix operations</source>
          <target state="translated">저수준 매트릭스 연산</target>
        </trans-unit>
        <trans-unit id="c33ae1bfbf8999a2bc79cecceab734ada1f32053" translate="yes" xml:space="preserve">
          <source>Low-level synchronization primitives</source>
          <target state="translated">저수준 동기화 기본 요소</target>
        </trans-unit>
        <trans-unit id="69c6e547fabb23ad635ac8fe93ede5712392e080" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt;</source>
          <target state="translated">하부 &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;삼각 행렬&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23a4f4335d144fa2497d4fe37f2b528b18f4e240" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt; with unit diagonal</source>
          <target state="translated">단위 대각선이있는 하부 &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;삼각 행렬&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e67838aee8be4e7755da1c297ec68ae6e282902c" translate="yes" xml:space="preserve">
          <source>Lower Half Block</source>
          <target state="translated">하반부 블록</target>
        </trans-unit>
        <trans-unit id="b7bfddef31a484ac690f541d1587c0a82f9ea2c7" translate="yes" xml:space="preserve">
          <source>Lower Half Circle</source>
          <target state="translated">하반 원</target>
        </trans-unit>
        <trans-unit id="0a46dc7d5d38dbb0f9593bbac09bb5a5e1168df1" translate="yes" xml:space="preserve">
          <source>Lower Half Inverse White Circle</source>
          <target state="translated">하 반반 화이트 서클</target>
        </trans-unit>
        <trans-unit id="19c077435147598603f42bc8543d280b80283f3c" translate="yes" xml:space="preserve">
          <source>Lower Left Quadrant Circular Arc</source>
          <target state="translated">왼쪽 아래 사분면 원호</target>
        </trans-unit>
        <trans-unit id="a3a82cb0d0923582f86a3cfde8b8e51e4ca1a96a" translate="yes" xml:space="preserve">
          <source>Lower Left Triangle</source>
          <target state="translated">왼쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="01b22a0cc9e2a392fdb90f606abf5d1b88f864a7" translate="yes" xml:space="preserve">
          <source>Lower Right Quadrant Circular Arc</source>
          <target state="translated">오른쪽 아래 사분면 원호</target>
        </trans-unit>
        <trans-unit id="70aee1ac83a2f1a5579bf9159c07bceb364ffd0e" translate="yes" xml:space="preserve">
          <source>Lower Right Triangle</source>
          <target state="translated">오른쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="fe9cd1617eaf77e57754425b931c1afef95157bf" translate="yes" xml:space="preserve">
          <source>Lower bound for log level of accepted events</source>
          <target state="translated">허용 된 이벤트의 로그 레벨에 대한 하한</target>
        </trans-unit>
        <trans-unit id="44e79a7195ba19b673d8eec03c4e37479443f063" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix, overwriting &lt;code&gt;M&lt;/code&gt; in the process. See also &lt;a href=&quot;#LinearAlgebra.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스에서 &lt;code&gt;M&lt;/code&gt; 을 덮어 쓰는 행렬의 아래쪽 삼각형 . &lt;a href=&quot;#LinearAlgebra.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b635a689678f453635c9ee1b78fc69558f89e909" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix.</source>
          <target state="translated">행렬의 아래쪽 삼각형.</target>
        </trans-unit>
        <trans-unit id="3b856a21fe98568ae306d713f4ed924f2bea5deb" translate="yes" xml:space="preserve">
          <source>Lozenge</source>
          <target state="translated">Lozenge</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
