<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">그리고 도트</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">그리고 그 테스트 세트를 사용하는 것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">분노 기호</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">안쪽으로 S를 가진 각</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">언더 바 각도</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">화난 얼굴</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">옹스트롬 부호 / 옹스트롬 단위</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">고뇌 된 얼굴</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프에 주석을 달아서 컴파일러가 루프를 다시 정렬 할 수 있도록 추가 자유를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">형식화되지 않은 위치에서 가져온 값에 주석 달기</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;blk&lt;/code&gt; 표현식을 경계 검사 블록으로 주석 처리하여 &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; 에&lt;/a&gt; 의해 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">또 다른 일반적인 솔루션은 파이프 라인의 리더와 라이터를 별도의 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 으로 분리하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">다른 경우에는 다른 도우미 유형 인 &lt;code&gt;Random.SamplerTag&lt;/code&gt; 가 현재 사용 가능 하지만 내부 API로 간주되며 적절한 지원 중단없이 언제든지 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">또 다른 비 - 표준 버전 사양을 확장 한 뒤에를 사용할 수 있습니다 &lt;code&gt;+&lt;/code&gt; 빌드 버전에 대한 상한을 표현하기 위해, 예를 들어 &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; 위의 모든 버전을 의미 할 수 있습니다 &lt;code&gt;0.2-rc1&lt;/code&gt; 과 그 중 하나를 빌드 : 그것은 반환 &lt;code&gt;false&lt;/code&gt; 버전에 대한 &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; 와 &lt;code&gt;true&lt;/code&gt; 에 대한 &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">어떤 유형에 적용하는 또 다른 작업은 &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; 타입의 슈퍼 타입을 보여준다. 선언 된 유형 ( &lt;code&gt;DataType&lt;/code&gt; ) 에만 명확한 수퍼 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">또 다른 가능성은 다음과 같으며, 이는 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 보다 좁게 일치시켜야하는 경우에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">또 다른 유용한 비표준 문자열 리터럴은 바이트 배열 문자열 리터럴입니다 ( &lt;code&gt;b&quot;...&quot;&lt;/code&gt; . 이 형식을 사용하면 문자열 표기법을 사용하여 읽기 전용 리터럴 바이트 배열, 즉 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 값의 배열을 표현할 수 있습니다. 해당 오브젝트의 유형은 &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; 입니다. 바이트 배열 리터럴의 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">희소 배열을 만드는 또 다른 방법은 &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 밀도가 높은 배열을 희소 배열로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">뷰 표현하는 또 다른 방법은 함께 &lt;code&gt;Meta.show_sexpr&lt;/code&gt; 디스플레이, &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-표현&lt;/a&gt; 주어진 형태 &lt;code&gt;Expr&lt;/code&gt; 리스프의 사용자에게 매우 친숙한 보일 수 있습니다. 다음은 중첩 된 &lt;code&gt;Expr&lt;/code&gt; 의 표시를 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">Julia v0.6에서 삼각형 디스패치가 출현하기 전에 유일하게 올바른 방법이었던 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">바 안테나</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">반 시계 방향 컨투어 일체형</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">반 시계 방향 및 위쪽으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">반 시계 방향 통합</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">반 시계 방향으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">반 시계 방향 반원형 화살표</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">배열 값을 변경하면 (예 : &lt;code&gt;A[3] = 0&lt;/code&gt; ) 디스크의 값도 변경됩니다</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">성능이 중요하거나 벤치마킹되는 모든 코드는 함수 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형 인 스칼라 인덱스의 사용자 정의 배열</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">모든 사용자 정의 테스트 세트 유형 ( &lt;code&gt;AbstractTestSet&lt;/code&gt; 의 하위 유형 )을 제공 할 수 있으며 중첩 된 &lt;code&gt;@testset&lt;/code&gt; 호출 에도 사용 됩니다. 주어진 옵션은 테스트 세트에만 적용됩니다. 기본 테스트 세트 유형에는 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">모든 오류는 &lt;code&gt;pmap&lt;/code&gt; 이 나머지 콜렉션을 처리하지 못하게합니다. 이 동작을 무시하려면 단일 인수 (예 : 예외)를 &lt;code&gt;on_error&lt;/code&gt; 인수를 통해 오류 처리 기능을 지정할 수 있습니다 . 이 함수는 오류를 다시 발생시켜 처리를 중지하거나 계속하려면 결과와 함께 호출자에게 반환되는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에 의해 발생 된 예외 는 원격 작업자의 &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;eigen&lt;/code&gt; 에 전달 된 모든 키워드 인수 는 하위 수준 &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt; 전달됩니다 ! 함수.</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">이런 식으로 많은 표현이 함께 문서화됩니다. 이 구문은 비 변형 버전과 변이 버전 &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;f!&lt;/code&gt; 와 같은 두 가지 기능이 관련된 경우에 유용합니다 ! .</target>
        </trans-unit>
        <trans-unit id="0687dd78d1b30c2783be213375797ef6105a33d2" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">이 함수를 정의하는 모든 객체는 반복 가능 &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;하며 반복에 의존&lt;/a&gt; 하는 많은 함수 에서 사용될 수 있습니다 . 구문 때문에 &lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프 에서 직접 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">유형이 아닌 모든 객체는 &lt;code&gt;Type&lt;/code&gt; 인스턴스가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">오류를 발생시키는 모든 작업은 현재 구현되지 않았으며 해결 될 수 있도록 버그로 게시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 을&lt;/a&gt; 참조하는 모든 프로세스 는 채널에서 항목을 넣고 가져올 수 있습니다. 데이터는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 과 연관된 프로세스로 자동 전송되거나 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Apl 기능 기호 백 슬래시 바</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl 기능성 심볼 서클 스타일</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Apl 기능성 기호 I- 빔</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Apl 기능 기호 쿼드 질문</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl 기능 기호 쿼드 업 캐럿</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl 기능 기호 슬래시 바</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">추가 &lt;code&gt;!&lt;/code&gt; 인수를 수정하는 함수 이름</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">채널 &lt;code&gt;c&lt;/code&gt; 에 항목 &lt;code&gt;v&lt;/code&gt; 를 추가하십시오 . 채널이 가득 찬 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">함수 인수 이름에 적용되면 메소드가 해당 인수의 다른 유형에 특화된 것이 아니라 각 인수에 대해 선언 된 유형을 정확하게 사용해야한다는 것을 컴파일러에 알립니다. 이것은 과도한 코드 생성을 피하기위한 힌트 일뿐입니다. 형식 인수 목록 또는 함수 본문의 인수에 적용 할 수 있습니다. 인수에 적용될 때 매크로는 전체 인수 표현식을 랩핑해야합니다. 함수 본문에서 사용될 때 매크로는 명령문 위치에서 코드 앞에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">함수 또는 매크로 호출에 적용되면 지정된 호출에 대한 인수를 평가하고 해당 인수에 대해 호출 될 메소드의 위치를 ​​제공 하는 튜플 &lt;code&gt;(filename,line)&lt;/code&gt; 을 리턴합니다 . &lt;code&gt;functionloc&lt;/code&gt; 함수 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">함수 또는 매크로 호출에 적용되면 지정된 호출에 대한 인수를 평가하고 해당 인수에 대해 호출 될 메소드 의 &lt;code&gt;Method&lt;/code&gt; 오브젝트를 리턴합니다 . 변수에 적용되면 변수가 바인딩 된 모듈을 반환합니다. &lt;code&gt;which&lt;/code&gt; 함수 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">앞의 인수에 함수를 적용합니다. 이는 쉬운 기능 체인을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; 의 각 요소에 함수 &lt;code&gt;f&lt;/code&gt; 를 적용한 다음 이진 함수 &lt;code&gt;op&lt;/code&gt; 를 사용하여 결과를 줄 입니다. 제공된 경우 &lt;code&gt;init&lt;/code&gt; 는 빈 컬렉션에 대해 반환 될 &lt;code&gt;op&lt;/code&gt; 의 중립 요소 여야합니다 . 비어 있지 않은 컬렉션에 &lt;code&gt;init&lt;/code&gt; 를 사용 할지 여부는 지정되지 않았습니다 . 일반적으로 빈 컬렉션으로 작업하려면 &lt;code&gt;init&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 git 저장소 &lt;code&gt;repo&lt;/code&gt; 에 적용하고 &lt;code&gt;f&lt;/code&gt; 를 적용하기 전에 &lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt; 을 작성하십시오 . &lt;code&gt;f&lt;/code&gt; 내에서 오류가 발생하면 , &lt;code&gt;repo&lt;/code&gt; 는 &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; 를&lt;/a&gt; 사용하여 스냅 샷 상태로 돌아갑니다 . 발생한 오류는 다시 발생하지만 &lt;code&gt;repo&lt;/code&gt; 상태는 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6b68e61d0fe49a5c4e043952feeeef90f5166fd" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of array &lt;code&gt;A&lt;/code&gt; and take the mean over dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">함수 적용 &lt;code&gt;f&lt;/code&gt; 집합의 각 요소에 &lt;code&gt;itr&lt;/code&gt; , 평균 걸릴.</target>
        </trans-unit>
        <trans-unit id="939711ce79fa9b7db5fc7f83d19a0a73f949253d" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; &lt;/a&gt; 결과에 적용하고 완료시 임시 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="2dbf8268105b7901616a7ac6d30feda3dbda5ed9" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt; 결과에 적용하고 완료시 임시 디렉토리의 모든 내용을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; 의 결과에 적용하고 완료되면 결과 파일 디스크립터를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다른 유형의 인수에 적용하면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">한계에 접근</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">주어진 정수 유형의 구성 요소를 갖는 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 로서의 대략적인 부동 소수점 수 &lt;code&gt;x&lt;/code&gt; 결과는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;tol&lt;/code&gt; 만큼 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">대략 동일하지는 않지만</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">대략 같거나 같음</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">대략 동일</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">대략 같거나 이미지</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">임의 정밀 산술</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">임의의 정밀도 부동 소수점 숫자 유형.</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">임의 정밀도 정수 유형.</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">인수 &lt;code&gt;waitfor&lt;/code&gt; 노동자가 종료 때까지 기다려야하는 시간을 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">인수 전달 동작</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">인수 파괴</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">LLVM 백엔드로 전달 될 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Julia 의 &lt;code&gt;Ptr&lt;/code&gt; 유형 에 대한 산술 (예 : &lt;code&gt;+&lt;/code&gt; )은 C의 포인터 산술과 동일하게 동작하지 않습니다. Julia 에서 &lt;code&gt;Ptr&lt;/code&gt; 에 정수를 추가하면 요소가 아닌 항상 &lt;em&gt;바이트&lt;/em&gt; 수만큼 포인터가 이동합니다 . 이런 식으로 포인터 산술에서 얻은 주소 값은 포인터의 요소 유형에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">희소 행렬에 대한 산술 연산은 밀도가 높은 행렬에서와 마찬가지로 작동합니다. 희소 행렬의 인덱싱, 할당 및 연결은 밀도가 높은 행렬과 동일한 방식으로 작동합니다. 인덱싱 작업, 특히 할당은 한 번에 한 요소를 수행 할 때 비용이 많이 듭니다. 대부분의 경우 &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; 를&lt;/a&gt; 사용하여 희소 행렬을 &lt;code&gt;(I,J,V)&lt;/code&gt; 형식 으로 변환하고 , 치밀한 벡터 &lt;code&gt;(I,J,V)&lt;/code&gt; 의 값 또는 구조를 조작 한 다음 희소 행렬을 재구성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">배열 및 벡터화 된 연산자 및 함수</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">배열 함수</target>
        </trans-unit>
        <trans-unit id="051f0d6bd098df06454138ddf1bfe22d07625d2a" translate="yes" xml:space="preserve">
          <source>Array literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">배열 특성</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">결 측값이있는 배열</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">결 측값을 허용하는 배열은 표준 구문으로 구성 할 수 있습니다. 사용 &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; 값 누락 가득 배열을 만들 수 :</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">배열은 연속적으로 메모리에 저장되어 캐싱으로 인해 CPU 벡터화 및 적은 메모리 액세스를 제공합니다. 이는 열-주요 순서로 배열에 액세스하는 것이 권장되는 것과 같은 이유입니다 (위 참조). 불규칙한 액세스 패턴과 비 연속적인보기는 비 순차적 메모리 액세스로 인해 어레이에서 계산 속도를 크게 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd16e2399bb6c0b0c5a0ea05fbdc7c6bf1a6ee2" translate="yes" xml:space="preserve">
          <source>Arrays can also be directly constructed with square braces; the syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its &lt;code&gt;eltype&lt;/code&gt;. If they all have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; and that type is the array's &lt;code&gt;eltype&lt;/code&gt;. Otherwise, a heterogeneous array that can hold anything &amp;mdash; a &lt;code&gt;Vector{Any}&lt;/code&gt; &amp;mdash; is constructed; this includes the literal &lt;code&gt;[]&lt;/code&gt; where no arguments are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">다음 기능을 사용하여 배열을 구성하고 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">값의 임의 변환에 따라 배열을 쉽게 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">결 측값을 포함하는 배열은 다른 배열과 같이 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 배열 (자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 배열 도 지원됩니다. 이들은 각각 &lt;code&gt;N&lt;/code&gt; 차원에 걸쳐있는 스칼라 인덱스의 모음을 나타내며, 때때로 포인트 인덱싱이라고하는 인덱싱 형태를 가능하게합니다. 예를 들어, 위 의 &lt;code&gt;A&lt;/code&gt; 의 첫 번째 &quot;페이지&quot;에서 대각선 요소에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인덱스 에서 요소를 선택하는 부울 배열 (자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="36fa144c795f904dbf232a8e653525a3d0ba71b7" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;. For example, the struct in C notation written as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">매개 변수 배열은 &lt;code&gt;NTuple&lt;/code&gt; 로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">일반 데이터 형식의 배열은 동일한 동작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">알 수없는 크기의 배열 ( &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;[0]&lt;/code&gt; 에 의해 지정된 C99 호환 가변 길이 구조체 )은 직접 지원되지 않습니다. 이것들을 다루는 가장 좋은 방법은 바이트 오프셋을 직접 다루는 것입니다. 예를 들어, C 라이브러리가 올바른 문자열 유형을 선언하고 이에 대한 포인터를 리턴 한 경우 :</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">오른쪽을 가리키는 화살표</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">오른쪽을 가리키는 화살표</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">Arthur C. Clarke, &lt;em&gt;미래의 프로파일&lt;/em&gt; (1961) : Clarke의 세 번째 법칙.</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">굴절 식 트럭</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">아티스트 팔레트</target>
        </trans-unit>
        <trans-unit id="07d39beaf4ec4f6ab344410b6e2ddcbafeee07b5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard math operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">로 &lt;code&gt;missing&lt;/code&gt; 정상 줄리아 개체입니다,이 전파 규칙은이 동작을 구현하도록 선택한 기능을 작동합니다. 이는 &lt;code&gt;Missing&lt;/code&gt; 유형의 인수에 대해 정의 된 특정 메소드를 통해 또는 단순히이 유형의 인수를 승인하고이를 전파하는 함수 (표준 연산자와 같은)에 전달하여 수행 할 수 있습니다. 패키지는 새로운 함수를 정의 할 때 결 측값을 전파하는 것이 적절한 지 여부를 고려해야하며, 그러한 경우에는 적절하게 방법을 정의해야합니다. 통과 &lt;code&gt;missing&lt;/code&gt; 형의 인수를 받아 아무런있어서 해당하는 함수 값을 &lt;code&gt;Missing&lt;/code&gt; 정의가 발생하지 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 를&lt;/a&gt; 다른 모든 타입처럼.</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 값은 ISO 8601 표준에 따라 표시 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 은 반올림에 사용 된 일 수 (및 밀리 초)를 시작하는 기준 (또는 &quot;반올림 에포크&quot;)으로 선택되었습니다. 계산. (이것은 Rata Die 표기법을 사용 하는 Julia의 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; s 의 내부 표현과 약간 다릅니다 . 그러나 ISO 8601 표준은 최종 사용자에게 가장 잘 보이기 때문에 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 이 반올림 에포크 대신에 선택되었습니다. &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; 내부적으로 혼동을 최소화하는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">보너스로 모든 기간 산술 객체는 범위와 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1d37396b19dff556a9f0928d3fb79a1f9a87b4bb" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library on most Unix-derived systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">완전하지만 간단한 예제로서 다음 은 표준 C 라이브러리에서 &lt;code&gt;clock&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">편의상 배열에서 &lt;code&gt;CartesianIndices&lt;/code&gt; 인덱스를 구성하면 다양한 인덱스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">일반적으로 기본 라이브러리는 적용 가능한 경우 함수에 다음 순서의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0aeaa033e5a0e531782e60f4be3543a306118072" translate="yes" xml:space="preserve">
          <source>As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases: &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Vararg&lt;/code&gt;. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/functions/#compiler-efficiency-issues&quot;&gt;improves compiler performance&lt;/a&gt;. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">좀 더 복잡한 예로, &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; 위에 구축 된 자체 장난감 N- 차원 희소 같은 배열 유형을 정의 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">보다 확장되고 복잡한 예로, 다음 &quot;커널&quot;을 병렬로 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="abc7b3fc409ca00052233fccf9f3605c7724641a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">경험상, 단선 &lt;code&gt;show&lt;/code&gt; 메소드는 표시된 오브젝트를 작성하기 위해 유효한 Julia 표현식을 인쇄해야합니다. 이 &lt;code&gt;show&lt;/code&gt; 메소드 에 &lt;code&gt;Polar&lt;/code&gt; 에 대한 단일 행 &lt;code&gt;show&lt;/code&gt; 메소드 의 곱셈 연산자 ( &lt;code&gt;*&lt;/code&gt; ) 와 같은 접두어 연산자가 포함 된 경우 다른 오브젝트의 일부로 인쇄 될 때 올바르게 구문 분석되지 않을 수 있습니다. 이를 확인하려면 &lt;code&gt;Polar&lt;/code&gt; 유형 의 특정 인스턴스의 제곱을 취하는 표현식 객체 ( &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;프로그램 표현&lt;/a&gt; 참조 )를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로,에 정의 된 모든 이름이 &lt;code&gt;Main&lt;/code&gt; 명시 적에서 이름을 내보낼 관용적하지 않기 때문에, &quot;수출&quot;로 간주됩니다 &lt;code&gt;Main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">특별한 경우로, 함수는 익명 인 경우에만 실제로 복사 할 수 있으며, 그렇지 않은 경우 방금 복사됩니다. 차이점은 클로저 (즉, 숨겨진 내부 참조를 포함 할 수있는 함수)의 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Vector{UInt8}&lt;/code&gt; MIME 형식 의 &lt;code&gt;AbstractString&lt;/code&gt; 또는 Vector {UInt8} (2 진 MIME 형식) 인 경우 &lt;code&gt;repr&lt;/code&gt; 함수는 &lt;code&gt;x&lt;/code&gt; 가 이미 요청 된 &lt;code&gt;mime&lt;/code&gt; 형식 인 것으로 가정 하고 단순히 &lt;code&gt;x&lt;/code&gt; 를 반환합니다 . 이 특별한 경우는 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME 유형 에는 적용되지 않습니다 . 이는 원시 데이터를 &lt;code&gt;display(m::MIME, x)&lt;/code&gt; 로 전달할 수 있도록 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 구문의 특별한 부분으로, &lt;code&gt;end&lt;/code&gt; 키워드는 색인이 생성되는 가장 안쪽 배열의 크기에 의해 결정된대로 색인 괄호 안에있는 각 차원의 마지막 색인을 나타내는 데 사용될 수 있습니다. &lt;code&gt;end&lt;/code&gt; 키워드가 없는 인덱싱 구문 은 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 호출과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bae7191c8b712d7ed7a7918d6d667ad51becb2b6" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; 에서 이미 자세히 설명한 것처럼 Julia의 REPL은 효율적인 대화식 워크 플로우를 용이하게하는 풍부한 기능을 제공합니다. 다음은 명령 행에서의 경험을 향상시킬 수있는 몇 가지 팁입니다.</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">매우 간단한 경우에 대한 대안으로 &lt;code&gt;Vector{Any}&lt;/code&gt; 유형의 전역 컨테이너 를 만들고 필요한 경우 요소를 가져 오거나 포인터를 사용하여 포인터 당 하나의 전역 변수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">프로그램이 예상대로 작동하는지 확인하는 데 도움이되는 주장으로,</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">예를 들어 동일한 호스트에서 작업자를 시작하는 관리자 인 &lt;code&gt;LocalManager&lt;/code&gt; 가 어떻게 구현되는지 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">비 TCP / IP 전송의 예로, 구현시 MPI를 사용하도록 선택할 수 &lt;code&gt;--worker&lt;/code&gt; 경우 --worker 를 지정 하면 안됩니다. 대신, 새로 시작된 작업자는 병렬 구조를 사용하기 전에 &lt;code&gt;init_worker(cookie)&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab91e9f8f6b72a78ebd5768f4d6d25cd797012df" translate="yes" xml:space="preserve">
          <source>As an example, consider</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fdf4e4340eb940fd457afeeed7b812831f6609" translate="yes" xml:space="preserve">
          <source>As an example, consider this call to &lt;a href=&quot;../../base/collections/index#Base.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">예를 들어, 패키지 디렉토리의 구조와 내용이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">예를 들어, 모듈의 심볼에 곱셈을 정의하려고한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">예를 들어 내장 된 &lt;code&gt;AbstractRange&lt;/code&gt; 객체는이 메커니즘을 사용하여 모든 단일 요소를 계산하는 대신 시작, 단계 및 길이 (또는 중지) 측면에서 순수하게 평가할 수있는 브로드 캐스트 된 표현 조각을 최적화합니다. 다른 모든 기계와 마찬가지로 &lt;code&gt;broadcasted&lt;/code&gt; 는 인수의 결합 된 브로드 캐스트 스타일도 계산하고 노출하므로 &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; 를 전문화하는 대신 &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; 스타일, 함수 및 인수의 조합</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">이를 확장하면 알고리즘에 입력 배열의 복사본이 필요한 경우 반환 값이 원래 입력의 별칭을 지정할 수 있으므로 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 이 불충분합니다. 결합 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 하고 (출력 배열하도록) &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt;(입력 데이터로 채우려면)는 입력 인수의 변경 가능한 사본에 대한 요구 사항을 표현하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">다른 예로, 다음은 숫자 인수를 두 배로 늘리지 만 표현식 만 남겨 두는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">부동 소수점 값에 대한 계산이 부정확 할 수 있듯이 하나하여 대략 동등 검사를 수행 할 수 &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (여기서 &lt;code&gt;&amp;asymp;&lt;/code&gt; 의 탭 완성 통해 입력 &lt;code&gt;\approx&lt;/code&gt; 은이다 &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; 의&lt;/a&gt; 기능) 또는 사용 &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">다시 한 번 알 수 있듯이, 로컬 노드에 대한 원격 호출은 직접 호출처럼 작동합니다. 이 호출은 인수로 전달 된 로컬 객체를 수정합니다. 원격 호출에서는 인수 사본에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">보다시피, &lt;code&gt;A&lt;/code&gt; 는 정렬 된 배열 &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 됩니다. Julia는 배열을 &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; 로 변환하는 방법, 유형의 크기를 바이트 단위로 계산하는 방법 (C의 &lt;code&gt;sizeof&lt;/code&gt; 연산자와 동일 함) 등을 알고 있습니다. 재미있게, &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 줄을 &lt;code&gt;mycompare&lt;/code&gt; 에 삽입 하면 &lt;code&gt;qsort&lt;/code&gt; 가 수행 하고있는 비교를 볼 수 있고 전달한 Julia 함수를 실제로 호출하는지 확인할 수 있습니다 그것에).</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">보시다시피, &lt;code&gt;put!&lt;/code&gt; 호출간에 동일한 오브젝트 &lt;code&gt;v&lt;/code&gt; 가 수정 된 로컬 소유 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에서 v 동일한 단일 오브젝트 인스턴스가 저장됩니다. &lt;code&gt;rc&lt;/code&gt; 를 소유 한 노드 가 다른 노드 일 때 작성되는 &lt;code&gt;v&lt;/code&gt; 의 사본과 반대로 .</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">알 수 있듯이 전역 변수 &lt;code&gt;A&lt;/code&gt; 는 작업자 2에 정의되어 있지만 &lt;code&gt;B&lt;/code&gt; 는 로컬 변수로 캡처되므로 작업자 2에는 &lt;code&gt;B&lt;/code&gt; 에 대한 바인딩 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">날짜 기간 산술만큼 편리하지만, 날짜에 필요한 계산 종류는 종종 일정 기간이 아닌 &lt;em&gt;금기&lt;/em&gt; 또는 &lt;em&gt;시간&lt;/em&gt; 특성을 취 합니다. 휴일은 완벽한 예입니다. &quot;기념일 = 5 월 마지막 월요일&quot;또는 &quot;추수 감사절 = 11 월 4 일 목요일&quot;과 같은 규칙을 따릅니다. 이러한 종류의 시간적 표현은 첫 번째 또는 마지막 달, 다음 화요일 또는 첫 번째 및 세 번째 수요일 등 달력과 관련된 규칙을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">예상대로 &quot;Hello World&quot;가 인쇄되었습니다. 실제로 배후에서 일어난 일을 실제로 분석해 봅시다. &lt;code&gt;connect&lt;/code&gt; 라고하면 방금 만든 서버에 연결합니다. 한편 accept 함수는 새로 작성된 소켓에 서버 측 연결을 리턴하고 &quot;Hello World&quot;를 인쇄하여 연결에 성공했음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a7387cbdd9f992b642e060d8d4bc6f44c8177451" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">에 관해서는 &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;SparseVector&lt;/code&gt; 유형을 명시 적으로 저장 0을 포함 할 수 있습니다. ( &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">16 진 리터럴의 경우 2 진 및 8 진 리터럴은 부호없는 정수 유형을 생성합니다. 리터럴의 선행 숫자가 &lt;code&gt;0&lt;/code&gt; 이 아닌 경우 이진 데이터 항목의 크기는 필요한 최소 크기 입니다. 선행 0의 경우, 크기는 길이는 동일하지만 선행 숫자 &lt;code&gt;1&lt;/code&gt; 인 리터럴에 필요한 최소 크기로 결정됩니다 . 이를 통해 사용자는 크기를 제어 할 수 있습니다. &lt;code&gt;UInt128&lt;/code&gt; 에 저장할 수없는 값 은 이러한 리터럴로 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">숫자 형 배열의 경우, 안정적인 정렬 개념이 의미가없는 (즉, 동일한 값을 비교하는 두 값을 구별 할 수없는 경우) 배열 유형에 대해 비 안정적 기본 알고리즘을 선택하는 것이 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">단일 값으로 사용 &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; 치료 &lt;code&gt;missing&lt;/code&gt; 서로 동일한 값으로 &lt;code&gt;missing&lt;/code&gt; 값이지만 비 누락 값과 다른</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">위에서 암시 한 바와 같이 Julia의 매우 유용한 기능 중 하나는 Julia 자체 내에서 Julia 코드를 생성하고 조작하는 기능입니다. 이미 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 객체를 반환하는 함수의 한 가지 예를 보았습니다 . &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 함수는 Julia 코드 문자열을 가져와 해당 &lt;code&gt;Expr&lt;/code&gt; 을 반환합니다 . 함수는 하나 이상의 &lt;code&gt;Expr&lt;/code&gt; 객체를 인수로 사용하고 다른 &lt;code&gt;Expr&lt;/code&gt; 을 반환 할 수도 있습니다 . 다음은 간단하고 동기 부여가되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">위의 예와 같이 &lt;code&gt;|&lt;/code&gt; 문자는 세로로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Java에서와 같이 문자열은 변경할 수 없습니다. &lt;code&gt;AbstractString&lt;/code&gt; 객체 의 값을 변경할 수 없습니다. 다른 문자열 값을 구성하려면 다른 문자열의 일부에서 새 문자열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="10a53b8655071d9e82e3aaf67177dfbc302c86e3" translate="yes" xml:space="preserve">
          <source>As in keyword arguments, identifiers and dot expressions imply names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">위의 예와 같이 문서를 작성할 때 몇 가지 간단한 규칙을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a760e2170f972850310e9b6d50d6aa2fdbfb2289" translate="yes" xml:space="preserve">
          <source>As in the previous example, the first assignment to &lt;code&gt;s&lt;/code&gt; at the top of &lt;code&gt;sum_to&lt;/code&gt; causes &lt;code&gt;s&lt;/code&gt; to be a new local variable in the body of the function. The &lt;code&gt;for&lt;/code&gt; loop has its own inner local scope within the function scope. At the point where &lt;code&gt;s = s + i&lt;/code&gt; occurs, &lt;code&gt;s&lt;/code&gt; is already a local variable, so the assignment updates the existing &lt;code&gt;s&lt;/code&gt; instead of creating a new local. We can test this out by calling &lt;code&gt;sum_to&lt;/code&gt; in the REPL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">이 언급 한 것처럼 &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; 의 읽기 전용 배열과 같은 유형의 동작합니다 &lt;code&gt;UInt8&lt;/code&gt; 하고 당신은 당신이 사용하여 변환 할 수있는 표준 벡터해야하는 경우 &lt;code&gt;Vector{UInt8}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">위에서 언급했듯이 새로운 디스플레이 백엔드를 정의 할 수도 있습니다. 예를 들어, 창에 PNG 이미지를 표시 할 수있는 모듈은 Julia에이 기능을 등록 할 수 있으므로 PNG 표현이있는 유형에서 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; 를 호출 하면 모듈의 창을 사용하여 이미지가 자동으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3464c75addc4046f2d5407323c1df1db4f1784" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">&lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt; 에서 간단히 언급했듯이 선택적 인수는 여러 메서드 정의의 구문으로 구현됩니다. 예를 들어,이 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be2578b9d9f02697184689069f4eff8d3539a32a" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, functions defined by &lt;code&gt;@deprecate&lt;/code&gt; do not print warning when &lt;code&gt;julia&lt;/code&gt; is run without the &lt;code&gt;--depwarn=yes&lt;/code&gt; flag set, as the default value of &lt;code&gt;--depwarn&lt;/code&gt; option is &lt;code&gt;no&lt;/code&gt;. The warnings are printed from tests run by &lt;code&gt;Pkg.test()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512c2f7db98f68697b03e7fce5871064de0272a9" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, this code works without the &lt;code&gt;global&lt;/code&gt; annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48e9ac18414a96f1e01471c6b6626466797c864" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+0000&lt;/code&gt; through &lt;code&gt;U+D7FF&lt;/code&gt; and &lt;code&gt;U+E000&lt;/code&gt; through &lt;code&gt;U+10FFFF&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">이 글을 쓰는 현재 유효한 유니 코드 코드 포인트는 &lt;code&gt;U+00&lt;/code&gt; ~ &lt;code&gt;U+d7ff&lt;/code&gt; 및 &lt;code&gt;U+e000&lt;/code&gt; ~ &lt;code&gt;U+10ffff&lt;/code&gt; 입니다. 이것들은 아직 이해하기 어려운 의미를 부여 받았거나 응용 프로그램에서 반드시 해석 할 수있는 것은 아니지만, 이러한 값은 모두 유효한 유니 코드 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">여기서 볼 수 있듯이, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; 함은 단순히 주어진 정규 표현식에 대한 일치가 문자열에서 발생하는지 여부를 나타내는 true 또는 false를 반환합니다. 그러나 일반적으로 문자열이 일치하는지 여부뿐만 아니라 문자열이 &lt;em&gt;어떻게&lt;/em&gt; 일치하는지 알고 싶어합니다 . 일치에 대한이 정보를 캡처하려면 대신 &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">오류 상태에서 알 수 있듯이 원격 노드 에서 &lt;code&gt;UndefVarError&lt;/code&gt; 의 직접적인 원인은 해당 이름의 바인딩이 존재하지 않기 때문입니다. 가능한 원인 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">예제에서 알 수 있듯이 &lt;code&gt;julia&lt;/code&gt; 에 대한 다음 명령 줄 인수 는 전역 상수 &lt;code&gt;ARGS&lt;/code&gt; 에 전달 된 &lt;code&gt;script.jl&lt;/code&gt; 프로그램에 대한 명령 줄 인수로 해석됩니다 . 스크립트 자체의 이름은 전역 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 로 전달됩니다 . 참고가 있음을 &lt;code&gt;ARGS&lt;/code&gt; 줄리아 표현이 사용 주어지면도 설정되어 &lt;code&gt;-e&lt;/code&gt; 명령 행 옵션을합니다 (참조 &lt;code&gt;julia&lt;/code&gt; 아래의 도움말 출력)하지만 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 는 비어 있습니다. 예를 들어 스크립트에 주어진 인수를 인쇄하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="109c1f4fb3ce88e11db771658301b6b14b390770" translate="yes" xml:space="preserve">
          <source>As the example shows, the original Julia array &lt;code&gt;A&lt;/code&gt; has now been sorted: &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia &lt;a href=&quot;#automatic-type-conversion&quot;&gt;takes care of converting the array to a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;&lt;/a&gt;), computing the size of the element type in bytes, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">이 예제에서 알 수 있듯이 이러한 배열의 요소 유형은 &lt;code&gt;Union{Missing, T}&lt;/code&gt; 이며, 결 측값이 아닌 &lt;code&gt;T&lt;/code&gt; 의 유형입니다. 이것은 단순히 배열 항목이 &lt;code&gt;T&lt;/code&gt; 유형 (여기서는 &lt;code&gt;Int64&lt;/code&gt; )이거나 &lt;code&gt;Missing&lt;/code&gt; 유형일 수 있다는 사실을 반영합니다 . 이러한 종류의 배열은 항목의 유형 (즉, &lt;code&gt;Missing&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; )을 나타내는 &lt;code&gt;Array{UInt8}&lt;/code&gt; 과 결합 된 실제 값을 보유 하는 &lt;code&gt;Array{T}&lt;/code&gt; 와 동등한 효율적인 메모리 저장 영역을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ed6ee60a4bf819b8376da694ce11cd02fe61b3bd" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">평소와 같이 복소수 의 절대 값 ( &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; )은 0과의 거리입니다. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt; 는 절대 값의 제곱을 제공하며 특히 제곱근을 취하지 않으므로 복소수에 사용됩니다. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt; 는 위상 각도를 라디안으로 반환합니다 ( &lt;em&gt;인수&lt;/em&gt; 또는 &lt;em&gt;인수&lt;/em&gt; 함수 라고도 함 ). 다른 &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;기본 함수&lt;/a&gt; 의 전체 영역 도 복소수에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">일반적으로 프로모션 시스템은 다른 숫자 유형과 쉽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">평상시와 같이 &lt;code&gt;DummyModule&lt;/code&gt; 이 프로세스의 범위를 벗어나지 않으므로 &lt;code&gt;using&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 가 필요합니다 . 또한 &lt;code&gt;DummyModule&lt;/code&gt; 이 한 프로세스에서 범위에 도달 하면 다른 프로세스에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98525fef666cf45bd35cbb0c018ea8c9988be2ad" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;C와 Fortran Code 호출&lt;/a&gt; 에서 보듯이 Julia는 C로 작성된 함수를 호출하는 간단하고 효율적인 방법을 가지고 있습니다. 그러나 C 코드에서 Julia 함수를 호출하는 반대 상황이 있습니다. C / C ++로 모든 것을 다시 작성할 필요없이 Julia 코드를 더 큰 C / C ++ 프로젝트에 통합하는 데 사용할 수 있습니다. Julia는이를 가능하게하는 C API를 가지고 있습니다. 거의 모든 프로그래밍 언어에서 C 함수를 호출 할 수있는 방법이 있으므로 Julia C API를 사용하여 언어 브릿지를 추가로 작성할 수 있습니다 (예 : Python 또는 C #에서 Julia 호출).</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">보시다시피 Julia 객체는 C에서 포인터로 표시됩니다. 이것은 누가이 객체들을 자유롭게 할 책임이 있는지에 대한 의문을 제기합니다.</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">보시다시피 일반적인 매개 변수 유형에는 유형 매개 변수를 알 때 호출되는 내부 생성자가 있습니다. 예를 들어, 그들은에 적용되는 &lt;code&gt;Point{Int}&lt;/code&gt; 하지만에 &lt;code&gt;Point&lt;/code&gt; . 선택적으로 유형 매개 변수를 자동으로 결정하는 외부 생성자를 추가 할 수 있습니다 (예 : 호출 &lt;code&gt;Point(1,2)&lt;/code&gt; 에서 &lt;code&gt;Point{Int}&lt;/code&gt; ) . 외부 생성자는 내부 생성자를 호출하여 실제로 인스턴스를 만듭니다. 그러나 어떤 경우에는 내부 생성자를 제공하지 않으므로 특정 유형 매개 변수를 수동으로 요청할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">우리가 보았 듯이, 이러한 표현은 &lt;code&gt;$&lt;/code&gt; 로 보간을 지원 합니다. 그러나 일부 상황에서는 보간 &lt;em&gt;을&lt;/em&gt; 수행 &lt;em&gt;하지 않고&lt;/em&gt; 코드를 인용해야합니다 . 이러한 종류의 인용에는 아직 구문이 없지만 내부적으로 &lt;code&gt;QuoteNode&lt;/code&gt; 유형의 객체로 표시 됩니다 . 파서 는 심볼과 같은 간단한 인용 항목에 대해 &lt;code&gt;QuoteNode&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8358ced5c8aa8043f6548995886cf6fc9b1c22a3" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">다음에 볼 수 있듯이 특정 인수를 사용하여 Julia 함수를 호출하려면 권투가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 의 연도 및 분기 에 대한 정보는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">고유 값 또는 고유 벡터 찾기와 같은 기타 유용한 작업 :</target>
        </trans-unit>
        <trans-unit id="4983ba754d4bcba44195d81235402b223d67bb4c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ccall&lt;/code&gt;, the return type and tuple of input types must be literal constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ccall&lt;/code&gt; 과 마찬가지로 인수 서명을 정확하게 가져와야 합니다. 또한 &lt;code&gt;Core.Intrinsics&lt;/code&gt; 에 의해 노출 된 동등한 Julia 함수와 달리 내장 함수가 현재 대상에서 작동하고 작동하는지 확인하는 호환성 계층이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">생성자에서 반환 된 불완전한 객체와 마찬가지로, &lt;code&gt;complete_me&lt;/code&gt; 또는 해당 수신자 가 초기화되기 전에 &lt;code&gt;Lazy&lt;/code&gt; 객체 의 &lt;code&gt;data&lt;/code&gt; 필드에 액세스하려고 하면 오류가 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">이전 섹션의 리터럴과 마찬가지로 리터럴 백틱을 이중 백틱 내에 작성해야하는 경우 2보다 큰 짝수를 사용하십시오. 단일 리터럴 백틱을 $ \ LaTeX $ 마크 업에 포함시켜야하는 경우 두 개의 엔 클로징 백틱으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">다른 스트림과 마찬가지로 &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 를 사용 하여 소켓을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">변수와 마찬가지로 유니 코드도 함수 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">예제에서 볼 수 있듯이 로깅 명령문은 로그 이벤트의 위치 또는 처리 방법에 대해 언급하지 않습니다. 이것은 시스템을 구성 가능하고 자연스럽게 동시에 사용할 수있게하는 핵심 설계 기능입니다. 두 가지 다른 관심사를 분리하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">보시다시피, 명시 적 형식 매개 변수를 사용하는 생성자 호출의 경우 인수는 암시 적 필드 형식으로 변환됩니다. &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 는 작동하지만 &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; 는 &lt;code&gt;2.5&lt;/code&gt; 를 변환 할 때 &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. 에 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Point(1,2)&lt;/code&gt; 에서처럼 생성자 호출에 대한 인수가 형식을 암시하는 경우 인수 의 형식이 일치해야합니다. 그렇지 않으면 &lt;code&gt;T&lt;/code&gt; 를 결정할 수 없습니다. 그러나 일치하는 형식의 실제 인수 쌍이 제공 될 수 있습니다. 일반 &lt;code&gt;Point&lt;/code&gt; 생성자에</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">보시다시피, 잘못된 컨테이너에 잘못된 수의 요소가 있으면 너무 많은 인수가 명시 적으로 지정된 것처럼 함수 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">보시다시피, 첫 번째 줄에서 프로세스 2에 2x2 랜덤 매트릭스를 만들도록 요청했고 두 번째 줄에서는 1을 추가하도록 요청했습니다. 두 계산의 결과는 두 선물 &lt;code&gt;r&lt;/code&gt; 과 &lt;code&gt;s&lt;/code&gt; 에서 사용할 수 있습니다 . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 매크로 첫번째 인수로 지정된 프로세스에 두 번째 인자의 발현을 평가한다.</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">보시다시피, 인수는 정확하게 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 유형이어야합니다 . 정수 또는 32 비트 부동 소수점 값과 같은 다른 숫자 유형은 64 비트 부동 소수점으로 자동 변환되거나 문자열을 숫자로 구문 분석하지 않습니다. 때문에 &lt;code&gt;Float64&lt;/code&gt; 는 구체적인 유형과 구체적인 유형 줄리아의 서브 클래스화할 수 없으며, 이러한 정의는 정확히 유형이다 인수에 적용 할 수 &lt;code&gt;Float64&lt;/code&gt; . 그러나 선언 된 매개 변수 유형이 추상적 인 일반적인 메소드를 작성하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">보시다시피, &lt;code&gt;Int&lt;/code&gt; 리터럴 을 사용한 두 번째 버전 은 입력 인수의 유형을 유지했지만 첫 번째 버전은 그렇지 않았습니다. 예를 들어 &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; 이고 승격으로 승격이 발생하기 때문입니다. 마찬가지로, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 리터럴은 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 리터럴 보다 유형이 덜 파괴적이지만 &lt;code&gt;Int&lt;/code&gt; 보다 더 파괴적입니다 .</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">보다시피, &lt;code&gt;path&lt;/code&gt; 변수 의 공간 은 적절하게 이스케이프됩니다. 하지만 당신은 어떤 경우 &lt;em&gt;원하는&lt;/em&gt; 여러 단어를 보간? 이 경우 배열 (또는 다른 반복 가능한 컨테이너)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">보다시피, 추가 된 요소의 유형은 추가 된 벡터의 요소 유형과 일치해야합니다 . 그렇지 않으면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 다음 예제에서는 메소드 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 리턴 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">보시다시피 감소 연산자가 필요하지 않으면 생략 할 수 있습니다. 이 경우 루프는 비동기 적으로 실행됩니다. 즉, 사용 가능한 모든 작업자에 대해 독립적 인 작업을 생성 하고 완료를 기다리지 않고 즉시 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 배열을 반환합니다 . 호출자는 기다릴 수 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 호출하여 나중에에서 완료 &lt;code&gt;fetch&lt;/code&gt; 그들에, 또는를 앞에하여 루프의 말에 완료 될 때까지 기다린 &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; 처럼 &lt;code&gt;@sync @distributed for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">아시다시피, 글로벌에 관련된 메모리는 마스터에서 재 할당 될 때 수집 될 수 있지만 바인딩이 계속 유효하기 때문에 워커에 대한 조치는 수행되지 않습니다. &lt;code&gt;clear!&lt;/code&gt; 원격 노드에서 수동으로 재 할당 특정의 전역에 사용할 수 있습니다 &lt;code&gt;nothing&lt;/code&gt; 그들이 더 이상 필요하지 않습니다 번. 그러면 일반 가비지 콜렉션주기의 일부로 연관된 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 유형의 &lt;code&gt;value&lt;/code&gt; 으로 명명 된 필드에 &lt;code&gt;x&lt;/code&gt; 를 지정하십시오 . &lt;code&gt;value&lt;/code&gt; 변경 가능해야하며 &lt;code&gt;x&lt;/code&gt; 의 하위 유형이어야합니다 &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; . &lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">현재 작업의 작업 로컬 저장소에있는 키에 값을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 를 할당 해도 컬렉션에서 요소가 제거되지는 않습니다. 대신 &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">할당 에 &lt;code&gt;b&lt;/code&gt; 의 복사본을 만들지 않습니다 &lt;code&gt;b&lt;/code&gt; ; 대신 &lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">숫자를 &lt;code&gt;a&lt;/code&gt; 에 할당하면 숫자 가 &lt;code&gt;Float64&lt;/code&gt; 로 변환 되고 &lt;code&gt;a&lt;/code&gt; 는 효율적으로 조작 할 수있는 64 비트 부동 소수점 값의 연속 블록으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">객체의 필드에 할당하면 선언 된 필드 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">선언 된 유형 (예 : &lt;code&gt;local x::T&lt;/code&gt; ) 이있는 변수에 지정하면 해당 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">배열에 할당하면 배열의 요소 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">범위를 벗어난 인덱스에 할당해도 컬렉션이 커지지 않습니다. 컬렉션이 &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 이면 대신 &lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; 로 재배 할 수 있습니다 ! 또는 &lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">할당은 반복 가능한 값을 사용하여 여러 변수에 대해 병렬로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">대입은 여러 변수를 연속적으로 처리 할 수 ​​있으며 가장 오른쪽 표현식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4c2fee77618ccc921a63bc548e408d4da3037fb" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;s&lt;/code&gt; in soft scope is ambiguous because a global variable by the same name exists: &lt;code&gt;s&lt;/code&gt; will be treated as a new local. Disambiguate by using &lt;code&gt;local s&lt;/code&gt; to suppress this warning or &lt;code&gt;global s&lt;/code&gt; to assign to the existing global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; 의 수명을 작업과 연결하십시오 . 작업이 종료되면 &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; 이 자동으로 닫힙니다. 작업에서 포착되지 않은 예외는 &lt;code&gt;chnl&lt;/code&gt; 의 모든 웨이터에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 에서 연관 컬렉션 (예 : &lt;code&gt;Dict&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; )을 다시 해시해야합니다 . (향후에는 초기화 기능을 등록하기위한 메커니즘이 제공 될 수있다.)</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">위의 것보다 더 구체적인 방법을 찾지 &lt;code&gt;myplus&lt;/code&gt; 가정하면 Julia는 다음 에 위에서 주어진 일반 함수를 기반으로 두 개의 &lt;code&gt;Int&lt;/code&gt; 인수에 대해 myplus 라는 메소드를 내부적으로 정의하고 컴파일합니다. 즉, 암시 적으로 정의하고 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">별표 연산자</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">놀란 얼굴</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">점진적으로 동등한</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="1b797bdd1bcf1af4799cd31c8e25a767ad70f14e" translate="yes" xml:space="preserve">
          <source>Asynchronous &quot;tasks&quot;, or coroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">비동기 IO 및 동시 동기 쓰기</target>
        </trans-unit>
        <trans-unit id="8148eff566285bcd48743fb742f972c7a1dd962f" translate="yes" xml:space="preserve">
          <source>Asynchronous Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">에서 &lt;code&gt;-O3&lt;/code&gt; 컴파일러는 &lt;em&gt;할 수&lt;/em&gt; 자동적으로 튜플에 작업을 벡터화. 예를 들어 다음 프로그램은 &lt;code&gt;julia -O3&lt;/code&gt; 로 컴파일 될 때 x86 시스템에서 두 개의 SIMD 추가 명령어 ( &lt;code&gt;addps&lt;/code&gt; )를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">높은 수준에서 각 환경은 개념적으로 루트, 그래프 및 경로의 세 가지 맵을 정의합니다. &lt;code&gt;import X&lt;/code&gt; 의 의미를 해결할 때 루트와 그래프 맵은 &lt;code&gt;X&lt;/code&gt; 의 아이덴티티를 결정하는 데 사용되고 경로 맵은 &lt;code&gt;X&lt;/code&gt; 의 소스 코드를 찾는 데 사용됩니다 . 세지도의 구체적인 역할은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">처음에 홍당무가 발생하면 9223372036854775807이 -9223372036854775808보다 9223372036854775808에 훨씬 가깝고 정수는 여전히 C 및 Fortran과 호환되는 자연스러운 방식으로 고정 크기로 표시되므로 충분히 합리적입니다. 그러나 포화 정수 산술은 매우 문제가 있습니다. 첫 번째로 가장 명백한 문제는 이것이 기계 정수 연산 방식이 아니라는 점입니다. 따라서 포화 연산을 구현하려면 언더 플로우 또는 오버플로를 확인하고 결과를 &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; &lt;/a&gt; 대체하기 위해 각 기계 정수 연산 후에 명령어를 방출해야합니다.적절한. 이것만으로도 하나의 빠른 명령어에서 분기를 포함하여 십여 개의 명령어로 각 정수 연산을 확장합니다. 아야. 그러나 포화 정수 연산은 연관성이 없습니다. 이 Matlab 계산을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9939b5009359c95078c2105da459f4858711c0ae" translate="yes" xml:space="preserve">
          <source>At least Julia 1.4 is required for specifying a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">이 기능의 기본은 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt; 이며 적절한 주소 확인을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">맨 위에 함수의 유추 된 리턴 유형이 &lt;code&gt;Body::Float64&lt;/code&gt; 로 표시됩니다 . 다음 줄은 Julia의 SSA IR 형식 으로 &lt;code&gt;f&lt;/code&gt; 의 본문을 나타냅니다 . 번호가 매겨진 상자는 레이블이며 코드에서 점프 대상 ( &lt;code&gt;goto&lt;/code&gt; 를 통해 )을 나타냅니다 . 몸을 보면 먼저 일어나는 일이 있다는 것을 알 수 있습니다 &lt;code&gt;pos&lt;/code&gt; 호출되고 반환 값으로 추정 된 &lt;code&gt;Union&lt;/code&gt; 형 &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; 가 아닌 구체적인 형태이기 때문에 대문자로 표시. 즉 , 입력 유형에 따라 정확한 반환 유형 &lt;code&gt;pos&lt;/code&gt; 를 알 수 없습니다 . 그러나, 결과 &lt;code&gt;y*x&lt;/code&gt; A는 없다 &lt;code&gt;Float64&lt;/code&gt; 없이 경우 &lt;code&gt;y&lt;/code&gt; A는 &lt;code&gt;Float64&lt;/code&gt; 또는 &lt;code&gt;Int64&lt;/code&gt; 순수한 결과 즉 &lt;code&gt;f(x::Float64)&lt;/code&gt; 중간 계산의 일부 유형에 불안정한 경우에도, 그 종류에 불안정한 출력되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">이 시점에서 프로젝트는 빌드되고 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07f4310d23db89112b431f6fd02d1ccd231d2fd9" translate="yes" xml:space="preserve">
          <source>At this time, most operations in the Julia runtime and standard libraries can be used in a thread-safe manner, if the user code is data-race free. However, in some areas work on stabilizing thread support is ongoing. Multi-threaded programming has many inherent difficulties, and if a program using threads exhibits unusual or undesirable behavior (e.g. crashes or mysterious results), thread interactions should typically be suspected first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">운동화</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">원자 객체는 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">원자 연산 은 &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;code&gt;atomic_&lt;/code&gt; 접두사를 사용합니다 . , &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;등</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 적으로 추가 &lt;code&gt;val&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비트와 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 비트-NAND (안-과) &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 비트 또는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비트 xor (제외 또는 &lt;code&gt;x&lt;/code&gt; ) 와 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 적으로 비교하고 설정 한 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 을 &lt;code&gt;cmp&lt;/code&gt; 와 원자 적으로 비교합니다 . 같으면 &lt;code&gt;newval&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; 에 쓰십시오 . 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 를 수정하지 않은 채로 둡니다 . &lt;code&gt;x&lt;/code&gt; 의 이전 값을 반환합니다 . 반환 된 값을 &lt;code&gt;cmp&lt;/code&gt; ( &lt;code&gt;===&lt;/code&gt; 를 통해 )와 비교하여 &lt;code&gt;x&lt;/code&gt; 가 수정 되었는지 여부를 알고 이제 새 값 &lt;code&gt;newval&lt;/code&gt; 을 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값을 원자 적으로 교환</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 을 &lt;code&gt;newval&lt;/code&gt; 과 원자 적으로 교환합니다 . &lt;strong&gt;이전&lt;/strong&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자의 최대 저장 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자의 최소 저장 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;val&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">원자 빼기 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;upstream&lt;/code&gt; 또는 업스트림 추적 분기에서 현재 분기의 자동 병합 리베이스를 시도하십시오 . &lt;code&gt;newbase&lt;/code&gt; 는 리베이스 할 브랜치입니다. 기본적으로 이것은 &lt;code&gt;upstream&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">현금 인출기</target>
        </trans-unit>
        <trans-unit id="674ab38ea62e0b4a07e2dda58e235dd6968ef52f" translate="yes" xml:space="preserve">
          <source>Automatic Type Conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">다양한 인수 유형을위한 효율적이고 전문화 된 코드 자동 생성</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">메소드 확장에 사용 가능</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">변수 유형을 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">어떤 것이 인스턴스인지 유형인지에 대한 혼동을 피하십시오</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">추상 유형 매개 변수가있는 컨테이너를 피하십시오</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">정교한 컨테이너 유형을 피하십시오</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">추상 컨테이너가있는 필드 피</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">추상 유형의 필드 피하기</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">전역 변수를 피하십시오</target>
        </trans-unit>
        <trans-unit id="8c84ddcd06891b88969d0af7db4510b7be8ee56a" translate="yes" xml:space="preserve">
          <source>Avoid running top-level operations, e.g. &lt;code&gt;include&lt;/code&gt;, or &lt;code&gt;eval&lt;/code&gt; of type, method, and module definitions in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">이상한 형 피 &lt;code&gt;Union&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">I / O에 대한 문자열 보간 방지</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">불법 복제 방지</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">불필요한 배열을 피하십시오. 예를 들어, 대신 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt; 사용 &lt;code&gt;x+y+z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">가능하면 일반 코드에서 숫자 리터럴에 부동 소수점을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">URL에 비밀번호를 사용하지 마십시오. 신임 정보 오브젝트와 달리 Julia는 사용 후 민감한 데이터를 안전하게 제로화하거나 파괴 할 수 없으며 암호는 메모리에 남아있을 수 있습니다. 초기화되지 않은 메모리에 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">지나치게 구체적인 유형을 쓰지 마십시오</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">파이프 라인에서 교착 상태 방지</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">전역 변수의 값을 변경하지 않는 것은 프로그래밍 모범 사례로 간주됩니다. 전역 변수의 값을 변경하면 &quot;원거리에서의 동작&quot;이 발생하여 프로그램의 동작을 추론하기가 더 어려워 질 수 있습니다. 이것이 로컬 범위를 도입하는 범위 블록 에 글로벌 변수를 수정하려는 의도를 선언하기 위해 &lt;code&gt;global&lt;/code&gt; 키워드가 필요한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">글로벌 피하기</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy 및 Nicholas J. Higham, &quot;매트릭스 로그에 대한 역 스케일링 및 제곱 알고리즘 개선&quot;, SIAM Journal on Scientific Computing, 34 (4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;도 : 10.1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy, Nicholas J. Higham 및 Samuel D. Relton, &quot;행렬 로그의 Fr&amp;eacute;chet 파생 상품 계산 및 조건 수 추정&quot;, SIAM Journal on Scientific Computing, 35 (4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;도 : 10.1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">베즈 아웃 계수는 고유하게 정의 &lt;em&gt;되지 않습니다&lt;/em&gt; . &lt;code&gt;gcdx&lt;/code&gt; 는 확장 된 유클리드 알고리즘에 의해 계산 된 최소 B&amp;eacute;zout 계수를 반환합니다. (참고 : D. Knuth, TAoCP, 2 / e, 325 페이지, 알고리즘 X) 부호있는 정수의 경우 이러한 계수 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 $ | u | &amp;lt;| y / d | $ 및 $ | v | &amp;lt;| x / d | $. 또한, &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 부호는 &lt;code&gt;d&lt;/code&gt; 가 양수가 되도록 선택 됩니다. 부호없는 정수의 경우 계수 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;typemax&lt;/code&gt; 근처에있을 수 있으며 , 그 다음 항은 부호없는 정수의 모듈러스 산술을 통해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">BLAS 문자 인수</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS 기능</target>
        </trans-unit>
        <trans-unit id="38726bba2d45fa38b747b2e7e3f161c3f4fb4718" translate="yes" xml:space="preserve">
          <source>BLAS character arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10410d90763f9147a245aec96798dc0ea5a38e4" translate="yes" xml:space="preserve">
          <source>BLAS functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">아기 천사</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">젖병</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">아기 병아리</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">아기 상징</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">위 왼쪽 화살표와 함께 다시</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">배경과 참조</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )는 이중 백 슬래시 ( &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ) 로 이스케이프됩니다 . 인쇄 할 수없는 문자는 표준 C 이스케이프 코드, NUL (명확한 경우)의 경우 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; , 유니 코드 코드 포인트 ( &lt;code&gt;&quot;\u&quot;&lt;/code&gt; 접두사) 또는 16 진 ( &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 접두사)으로 이스케이프 됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">백 스페이스, &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">박트리아 낙타</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">수하물 수취</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">고유 시스템 또는 슈어 인수 분해를 계산하기 전에 행렬 &lt;code&gt;A&lt;/code&gt; 의 균형을 맞 춥니 다. &lt;code&gt;job&lt;/code&gt; 은 &lt;code&gt;N&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열되거나 크기가 조정되지 않음), &lt;code&gt;P&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열 만), &lt;code&gt;S&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 크기 만 조정 됨) 또는 &lt;code&gt;B&lt;/code&gt; ( &lt;code&gt;A&lt;/code&gt; 는 순열 및 크기 조정 됨) 중 하나 일 수 있습니다. 수정 &lt;code&gt;A&lt;/code&gt; 는 자리에서 반환은 &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; , 그리고 &lt;code&gt;scale&lt;/code&gt; . 순열이 설정된 경우 &lt;code&gt;j &amp;gt; i&lt;/code&gt; 및 &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; 또는 &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; 경우 &lt;code&gt;A[i,j] = 0&lt;/code&gt; 입니다. &lt;code&gt;scale&lt;/code&gt; 은 스케일링 / 변경에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">체크 투표 상자</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">달러 기호 지폐</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">유로 기호 지폐</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">파운드 기호 지폐</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">엔 기호 지폐</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">막대 차트</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">이발소의 간판 기둥</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">기본 서브 모듈</target>
        </trans-unit>
        <trans-unit id="13b575497d7efff2ec5b49faf71dbac3532ee190" translate="yes" xml:space="preserve">
          <source>Base collection types require manual locking if used simultaneously by multiple threads where at least one thread modifies the collection (common examples include &lt;code&gt;push!&lt;/code&gt; on arrays, or inserting items into a &lt;code&gt;Dict&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">이러한 관찰을 바탕으로, 우리는 피연산자 중 하나가 경우에 결론 수 &lt;code&gt;true&lt;/code&gt; 과 다른 &lt;code&gt;missing&lt;/code&gt; , 우리는 결과는 것을 알고 &lt;code&gt;true&lt;/code&gt; 피연산자 중 하나의 실제 값에 대한 불확실성에도 불구하고. 우리가 두 번째 피연산자의 실제 값을 관찰 할 수 있었다면 그것은 &lt;code&gt;true&lt;/code&gt; 이거나 &lt;code&gt;false&lt;/code&gt; 일 수 있으며, 두 경우 모두 결과는 &lt;code&gt;true&lt;/code&gt; 이 될 것 입니다. 따라서이 특별한 경우에 누락이 전파 되지 &lt;em&gt;않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="791f5b6a2aaabca7a2c4cad24b70f6e46c76fdcc" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Task&lt;/code&gt; operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">기본 스트림 I / O</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">기본 단위 테스트</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">기본 테이블은 아래 설명 된 구문을 사용하여 작성할 수 있습니다. 마크 다운 테이블은 기능이 제한되어 있으며 위에서 설명한 다른 요소와 달리 중첩 된 최상위 요소를 포함 할 수 없습니다. 인라인 요소 만 허용됩니다. 테이블은 항상 열 이름을 가진 헤더 행을 포함해야합니다. 셀은 테이블의 여러 행 또는 열에 걸쳐있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">농구와 후프</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="5efe26975abbced9003edb837133f3af03f436e7" translate="yes" xml:space="preserve">
          <source>Be aware of when Julia avoids specializing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">매크로가 실제로 함수가 될 수있는시기를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0826b18a2138cb79c2b1a66c614cdb664f937ef" translate="yes" xml:space="preserve">
          <source>Be aware that finalizers registered by a library may break if threads are enabled. This may require some transitional work across the ecosystem before threading can be widely adopted with confidence. See the next section for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">이 전략에는 하나 이상의 주요 단점이 있습니다. 많은 경우 사용자가 내 보낸 함수 &lt;code&gt;f&lt;/code&gt; 의 추가 전문화를 정의 하여 &lt;code&gt;f&lt;/code&gt; 동작을 추가로 사용자 정의 할 수는 없습니다 . 대신 내부 메소드 &lt;code&gt;_fA&lt;/code&gt; 및 &lt;code&gt;_fB&lt;/code&gt; 에 대한 전문화를 정의해야 하며 이는 내 보낸 메소드와 내부 메소드 사이의 경계를 흐리게합니다.</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">이 함수의 결과가 사용되는 한 &lt;code&gt;x&lt;/code&gt; 에 대한 Julia 참조가 존재 하도록주의하십시오 . 따라서이 함수 의 인수 &lt;code&gt;x&lt;/code&gt; 는 표현식이 아니고 변수 이름 또는 필드 참조 일뿐입니다. 예를 들어, &lt;code&gt;x=a.b.c&lt;/code&gt; 는 허용되지만 &lt;code&gt;x=[a,b,c]&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe66257c8592b5cf4fc84f98162f41a3e02473c6" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;invoke&lt;/code&gt; for functions that you don't write. What definition is used for given &lt;code&gt;argtypes&lt;/code&gt; is an implementation detail unless the function is explicitly states that calling with certain &lt;code&gt;argtypes&lt;/code&gt; is a part of public API. For example, the change between &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-&lt;code&gt;invoke&lt;/code&gt;) call. However, the change is visible if you use &lt;code&gt;invoke&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590d4269627728c65164df59752ab3f2172388df" translate="yes" xml:space="preserve">
          <source>Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">유형 평등에주의하십시오</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">빔 여덟 메모 / 막대 여덟 메모</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">곰 얼굴</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">쿵쿵 거리는 심장</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 추상 유형 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 의 배열 이므로 모든 &lt;code&gt;Real&lt;/code&gt; 값 을 보유 할 수 있어야 합니다. 이후 &lt;code&gt;Real&lt;/code&gt; 오브젝트가 임의의 크기 및 구조 일 수 있으며, &lt;code&gt;a&lt;/code&gt; 개별적으로 할당 된 포인터 배열로 표현되어야 &lt;code&gt;Real&lt;/code&gt; 객체. 우리가 대신에만 허용하는 경우에는 동일한 유형, 예를 들면의 숫자 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 에 저장하기, 이보다 효율적으로 저장할 수 있습니다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">C는 다중 반환 값을 지원하지 않기 때문에 종종 C 함수는 함수가 수정할 데이터에 대한 포인터를 가져옵니다. &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 내에서이를 수행하려면 먼저 해당 유형의 &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; 안에 값을 캡슐화해야 합니다. 이 &lt;code&gt;Ref&lt;/code&gt; 객체를 인수로 전달하면 Julia는 캡슐화 된 데이터에 C 포인터를 자동으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d44d25a0390ec817de43e662485f00ec7ef00a32" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Julia의 컴파일러는 Python 또는 R과 같은 언어에 사용되는 인터프리터와 다르기 때문에 처음에는 Julia의 성능이 직관적이지 않을 수 있습니다. 무언가가 느리다는 것을 알게되면 다른 것을 시도하기 전에 &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 섹션을 읽는 것이 좋습니다 . Julia의 작동 방식을 이해하면 C만큼 빠른 코드를 작성하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="7d35da8223bf95881284388f273666759cae71cf" translate="yes" xml:space="preserve">
          <source>Because finalizers can interrupt any code, they must be very careful in how they interact with any global state. Unfortunately, the main reason that finalizers are used is to update global state (a pure function is generally rather pointless as a finalizer). This leads us to a bit of a conundrum. There are a few approaches to dealing with this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">이러한 공유 특성으로 인해 이러한 유형은 내부적으로 동일한 유형 인 &lt;code&gt;DataType&lt;/code&gt; 의 인스턴스로 표시되며 , 이는 이러한 유형의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">가변 길이 인코딩으로 인해 문자열의 문자 수 ( &lt;code&gt;length(s)&lt;/code&gt; )가 항상 마지막 색인과 같지는 않습니다. 색인 1부터 &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt; 까지 색인을 반복 하고 &lt;code&gt;s&lt;/code&gt; 로 색인을 생성하는 경우, 오류가 발생하지 않을 때 리턴되는 문자 순서는 문자열 &lt;code&gt;s&lt;/code&gt; 를 구성하는 문자 순서입니다 . 따라서 문자열의 각 문자에는 고유 색인이 있어야하므로 &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; 라는 ID가 있습니다 . 다음은 &lt;code&gt;s&lt;/code&gt; 의 문자를 반복하는 비효율적이고 장황한 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">일반 프로그래밍을 지원하는 것은 다른 방법 (예 : 명시 적 루프 사용)으로 수행 할 수있는 잠재적 인 성능 최적화보다 중요하므로 &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;*=&lt;/code&gt; 와 같은 연산자는 새 값을 리 바인드하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">때문에 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 유형이 단일로 저장 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 값 날짜 부분 또는 필드 액세서 함수를 통해 검색 될 수있다. 소문자 접근자는 필드를 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">컴파일러는 정수 덧셈과 곱셈이 연관되어 있고 곱셈이 덧셈에 산포되는 것을 알기 때문에 (포화 산술에 해당되지 않음) 전체 루프를 곱셈과 덧셈으로 최적화 할 수 있습니다. 포화 연산은 각 루프 반복에서 연관성 및 분 산성이 실패 할 수 있기 때문에 이러한 종류의 최적화를 완전히 무효화하므로, 실패가 발생한 반복에 따라 다른 결과가 발생할 수 있습니다. 컴파일러는 루프를 언 롤링 할 수 있지만 여러 연산을 적은 수의 동등한 연산으로 대수적으로 줄일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0fb1c1b010730bc0463b629ac89a10341b04531" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">연산자 &lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;*&lt;/code&gt; 보다 우선 순위가 높기 때문에 ( &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;연산자 우선 순위 및 연관성&lt;/a&gt; 참조 )이 출력은 표현식 &lt;code&gt;a ^ 2&lt;/code&gt; 를 &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 동일 하게 나타내지 않습니다 . 이 문제를 해결하려면 인쇄 할 때 표현식 객체에 의해 내부적으로 호출되는 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; 대한 사용자 정의 메소드를 작성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f808dfd9f99fca14db2870360d26f322b8ed85e2" translate="yes" xml:space="preserve">
          <source>Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">맥주 잔</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">Julia 1.2 이전에는이 ​​서명이 &lt;code&gt;f::Function&lt;/code&gt; 으로 제한되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Julia를 실행하기 전에 환경 변수 &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; 을 1로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; 본문을 실행하기 전에 &lt;code&gt;Random.seed!(seed)&lt;/code&gt; 대한 암시 적 호출이 있습니다. 여기서 &lt;code&gt;seed&lt;/code&gt; 는 전역 RNG의 현재 시드입니다. 또한 본문 실행 후 전역 RNG의 상태는 &lt;code&gt;@testset&lt;/code&gt; 이전의 상태로 복원됩니다 . 이는 실패시 재현성을 용이하게 하고 글로벌 RNG 상태에 대한 부작용과 상관없이 &lt;code&gt;@testset&lt;/code&gt; 의 원활한 재 배열을 허용하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">프로그램이 종료되기 전에 &lt;code&gt;jl_atexit_hook&lt;/code&gt; 을 호출하는 것이 좋습니다 . 위 예제 프로그램은 &lt;code&gt;main&lt;/code&gt; 에서 돌아 오기 전에 이것을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4b47e5d0ff5715fb37f74adf8fc2abb257a9578b" translate="yes" xml:space="preserve">
          <source>Beginners will write this kind of code without the &lt;code&gt;global&lt;/code&gt; and have no idea why their code doesn't work&amp;mdash;the error that they get is that &lt;code&gt;s&lt;/code&gt; is undefined, which does not seem to enlighten anyone who happens to make this mistake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Julia GC를 통해 메모리를 관리 할 수 있는 &lt;code&gt;Ptr{T}&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; 대해 &lt;code&gt;nextind&lt;/code&gt; 를 &lt;code&gt;n&lt;/code&gt; 번 적용하는 것처럼 동작 합니다. 유일한 차이점은 &lt;code&gt;n&lt;/code&gt; 이 너무 커서 &lt;code&gt;nextind&lt;/code&gt; 를 적용 하면 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 도달 할 때마다 나머지 반복마다 반환 값이 &lt;code&gt;1&lt;/code&gt; 증가한다는 것 입니다. 이것은이 경우 &lt;code&gt;nextind&lt;/code&gt; 가 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 보다 큰 값을 반환 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 &lt;code&gt;prevind&lt;/code&gt; 를 적용하는 것처럼 동작 합니다. 유일한 차이점은 &lt;code&gt;n&lt;/code&gt; 이 너무 커서 &lt;code&gt;prevind&lt;/code&gt; 를 적용 하면 &lt;code&gt;0&lt;/code&gt; 에 도달 할 때마다 나머지 반복마다 반환 된 값이 &lt;code&gt;1&lt;/code&gt; 만큼 감소한다는 것 입니다. 이는이 경우 &lt;code&gt;prevind&lt;/code&gt; 가 음수 값을 반환 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">취소 스트로크 벨</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">다음은 일부 표준에서 하위 표준이 현저하게 성능에 영향을주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">아래에서는 특정 문제와 이러한 문제를 해결하기위한 대체 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">도시락 상자</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">벤젠 반지</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">원 벤젠 반지</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">&lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; 상수 에 사용되는 것 외에도 &lt;code&gt;VersionNumber&lt;/code&gt; 객체는 패키지 버전 및 해당 종속성을 지정하기 위해 &lt;code&gt;Pkg&lt;/code&gt; 모듈 에서 널리 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">내기 기호 / 두 번째 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">BigFloats 및 BigInts</target>
        </trans-unit>
        <trans-unit id="669a7400e7ecdc8abb5def5c2be2775fd1a39afb" translate="yes" xml:space="preserve">
          <source>Bignums are supported, but conversion is not automatic; ordinary integers &lt;a href=&quot;../faq/index#faq-integer-arithmetic&quot;&gt;overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; )를 반환하여 &lt;code&gt;A&lt;/code&gt; 를 양방향으로 치환 합니다. 열 순열 &lt;code&gt;q&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 열 개수 와 일치해야합니다 ( &lt;code&gt;length(q) == A.n&lt;/code&gt; ). 행 순열 &lt;code&gt;p&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 행 개수 와 일치해야합니다 ( &lt;code&gt;length(p) == A.m&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5033e83ebc769b610ff5842eedc3584eb861a747" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == size(A, 2)&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == size(A, 1)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">양측 순열 &lt;code&gt;A&lt;/code&gt; , 결과 &lt;code&gt;PAQ&lt;/code&gt; ( &lt;code&gt;A[p,q]&lt;/code&gt; )를 &lt;code&gt;X&lt;/code&gt; 에 저장 합니다. 중간 결과 &lt;code&gt;(AQ)^T&lt;/code&gt; ( &lt;code&gt;transpose(A[:,q])&lt;/code&gt; )를 옵션 인수 &lt;code&gt;C&lt;/code&gt; 에 저장합니다 (있는 경우). &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 및 존재하는 경우 &lt;code&gt;C&lt;/code&gt; 가 서로 별명 을 지정하지 않아야합니다 . 결과 &lt;code&gt;PAQ&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 에 다시 저장 하려면 &lt;code&gt;X&lt;/code&gt; 가없는 다음 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="c1d93ced1617078468dc67be83745c4934553581" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.+&lt;/code&gt; 와 같은 이진 (또는 단항) 연산자 는 동일한 메커니즘으로 처리됩니다 . &lt;code&gt;broadcast&lt;/code&gt; 통화와 동일 하며 다른 중첩 된 &quot;도트&quot;통화와 융합됩니다. &lt;code&gt;X .+= Y&lt;/code&gt; 등은 &lt;code&gt;X .= X .+ Y&lt;/code&gt; 와 동일하며, 적절한 제자리 할당을 초래합니다. &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;도트 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">이진 및 8 진 리터럴도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">이진 산술 - &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c4e4b4e465473735caeea3bbe55395f833f831" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 11 exponent, 52 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2dc88cfba0517f9a198be3d135a4aa4ba4c99" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 5 exponent, 10 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8b640f698cc5a43263f00b745c9489369b4eda" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 8 exponent, 23 fraction bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">이진, 8 진 및 16 진 리터럴은 부호없는 리터럴 바로 앞에 &lt;code&gt;-&lt;/code&gt; 로 서명 할 수 있습니다 . 그들은 부호없는 리터럴과 같은 크기의 부호없는 정수를 생성합니다. 두 값의 보수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">지정된 &lt;code&gt;host:port&lt;/code&gt; 에 &lt;code&gt;socket&lt;/code&gt; 을 바인드 하십시오 . 참고 &lt;code&gt;0.0.0.0&lt;/code&gt; 은 모든 장치에서 수신합니다.</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">생일 케이크</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
        <trans-unit id="d102341c9ef55fb595a96df06da32dfabaf31707" translate="yes" xml:space="preserve">
          <source>Bits Types</source>
          <target state="translated">비트 유형</target>
        </trans-unit>
        <trans-unit id="3d60896c2746f9344a7ec07d0c544abfbd6ac054" translate="yes" xml:space="preserve">
          <source>Bitshifts</source>
          <target state="translated">Bitshifts</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="003769240202348f8c8c50c01088aea9a66d1338" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">비트와. 하나의 피연산자가 &lt;code&gt;missing&lt;/code&gt; 되고 다른 피연산자 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3을 반환하는 논리를&lt;/a&gt; 구현하여 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="39242907d8fbb94d63ee93aa69c2eae1e3bdde37" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;. Add parentheses for function application form: &lt;code&gt;(&amp;amp;)(x, y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8386afef0f71e44b527049e051999293a919fac" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one of the arguments is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">배타적 논리합의 비트 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; . 구현 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;로직을 세 값&lt;/a&gt; 반환 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 인수 중 하나가되면 &lt;code&gt;missing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95edcf566466d2b1f53eaf47da115b29e2f2b799" translate="yes" xml:space="preserve">
          <source>Bitwise not.</source>
          <target state="translated">비트 단위는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="55d4c457eca0630bcbc6d9ef2deac549be6e9eb1" translate="yes" xml:space="preserve">
          <source>Bitwise or. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비트 또는. 하나의 피연산자가 &lt;code&gt;missing&lt;/code&gt; 되고 다른 피연산자 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 반환 논리를&lt;/a&gt; 구현하여 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbd4e8d6d33b0a0cb69eddf98c203dfb76b59494" translate="yes" xml:space="preserve">
          <source>Black Circle</source>
          <target state="translated">검은 원</target>
        </trans-unit>
        <trans-unit id="0548413521ae8836d60c83abbcac0b4ffd5b48c9" translate="yes" xml:space="preserve">
          <source>Black Circle With Two White Dots</source>
          <target state="translated">두 개의 흰색 점이있는 검은 원</target>
        </trans-unit>
        <trans-unit id="d7fd466be098000d71600e8371d0c45e2c49fceb" translate="yes" xml:space="preserve">
          <source>Black Circle With White Dot Right</source>
          <target state="translated">흰색 점이있는 검은 원</target>
        </trans-unit>
        <trans-unit id="757cd02902cbeae20fd43d03ee03d7081baecb82" translate="yes" xml:space="preserve">
          <source>Black Club Suit</source>
          <target state="translated">블랙 클럽 슈트</target>
        </trans-unit>
        <trans-unit id="9450d23785e56cc9d47bc85752234baaa5f58935" translate="yes" xml:space="preserve">
          <source>Black Diamond</source>
          <target state="translated">블랙 다이아몬드</target>
        </trans-unit>
        <trans-unit id="1e863cdb2d578f5fa6a621df1fbd38ab6818ad43" translate="yes" xml:space="preserve">
          <source>Black Diamond Suit</source>
          <target state="translated">블랙 다이아몬드 슈트</target>
        </trans-unit>
        <trans-unit id="143603a649d02ce401e75e3d4b9853da1d1fab9f" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Double Triangle</source>
          <target state="translated">블랙 다운 포인팅 더블 트라이앵글</target>
        </trans-unit>
        <trans-unit id="7131227a767e1555b67aefca3c1775aaf0e8eee4" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle</source>
          <target state="translated">검은 색 아래쪽 작은 삼각형 / 검은 색 아래쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="157034cbc1651891d53bf3735a8280c2c9e17261" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Triangle / Black Down Pointing Triangle</source>
          <target state="translated">블랙 다운 포인팅 트라이앵글 / 블랙 다운 포인팅 트라이앵글</target>
        </trans-unit>
        <trans-unit id="79bb28413b3c0425fd63303d0da05ee06907711e" translate="yes" xml:space="preserve">
          <source>Black Heart Suit</source>
          <target state="translated">검은 심장 정장</target>
        </trans-unit>
        <trans-unit id="84860fcb2778d5994fb2e1ec4ed5e1ff25be0c69" translate="yes" xml:space="preserve">
          <source>Black Hexagon</source>
          <target state="translated">검은 육각형</target>
        </trans-unit>
        <trans-unit id="eb3fe0b35214fe985deafdd4923cb6b5b71ecc00" translate="yes" xml:space="preserve">
          <source>Black Horizontal Ellipse</source>
          <target state="translated">검은 가로 타원</target>
        </trans-unit>
        <trans-unit id="3d24dccec23ef173830493e234a9797701114f4b" translate="yes" xml:space="preserve">
          <source>Black Large Circle</source>
          <target state="translated">검은 색 큰 원</target>
        </trans-unit>
        <trans-unit id="546e54ab988bdc54b4d67a0c87d99ffab31da61d" translate="yes" xml:space="preserve">
          <source>Black Large Square</source>
          <target state="translated">검은 큰 광장</target>
        </trans-unit>
        <trans-unit id="6c8aa0f6c88d86e760e667a1cfc3b50d0980df03" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Double Triangle</source>
          <target state="translated">검은 색 왼쪽 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="cc1db57a30b84796696c95aebddd648e97e8d503" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Pointer / Black Left Pointing Pointer</source>
          <target state="translated">검은 색 왼쪽 포인터 / 검은 색 왼쪽 포인터</target>
        </trans-unit>
        <trans-unit id="f5b4fdf2d1f644120341bc595bfdc32acb38d8d9" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle</source>
          <target state="translated">검은 색 왼쪽 작은 삼각형 / 검은 색 왼쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="394197a1901b539e852cc0120322c6a8cc9c8a83" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Triangle / Black Left Pointing Triangle</source>
          <target state="translated">검은 색 왼쪽을 가리키는 삼각형 / 검은 색 왼쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="651c14702ebcf7b7b2d5b2b8b2d4c78353cf3dc3" translate="yes" xml:space="preserve">
          <source>Black Lower Left Triangle</source>
          <target state="translated">검은 색 왼쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="a993e08e4e58513d7c168e38a98af83c1b823e70" translate="yes" xml:space="preserve">
          <source>Black Lower Right Triangle</source>
          <target state="translated">검은 오른쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="7784160f9d8de2c5b48e65c73c3ba7c32077d5d3" translate="yes" xml:space="preserve">
          <source>Black Lozenge</source>
          <target state="translated">검은 마름모꼴</target>
        </trans-unit>
        <trans-unit id="f51954be7eb46c9d2126809c883eed1d9b6af3da" translate="yes" xml:space="preserve">
          <source>Black Medium Diamond</source>
          <target state="translated">블랙 미디엄 다이아몬드</target>
        </trans-unit>
        <trans-unit id="e638cf3b3eda8a7622b5719c7bc597161ec84dff" translate="yes" xml:space="preserve">
          <source>Black Medium Lozenge</source>
          <target state="translated">블랙 미디엄 마름모꼴</target>
        </trans-unit>
        <trans-unit id="7d1eb991c64f2c0aa6c491bf46495204bab8b980" translate="yes" xml:space="preserve">
          <source>Black Medium Small Square</source>
          <target state="translated">블랙 미디엄 스몰 스퀘어</target>
        </trans-unit>
        <trans-unit id="35e1e8816c4ad0b081b1abc5f0b5e6e68515fdd3" translate="yes" xml:space="preserve">
          <source>Black Medium Square</source>
          <target state="translated">블랙 미디엄 스퀘어</target>
        </trans-unit>
        <trans-unit id="bd88cc2496f705279f693662165cafc22758e595" translate="yes" xml:space="preserve">
          <source>Black Nib</source>
          <target state="translated">검은 펜촉</target>
        </trans-unit>
        <trans-unit id="17a74c499db585ffc78ad964cf24f74eeab12fbc" translate="yes" xml:space="preserve">
          <source>Black Parallelogram</source>
          <target state="translated">검은 색 평행 사변형</target>
        </trans-unit>
        <trans-unit id="a5e0106e423905d56ce64cbee75d3dab7ab613a8" translate="yes" xml:space="preserve">
          <source>Black Pentagon</source>
          <target state="translated">검은 국방부</target>
        </trans-unit>
        <trans-unit id="641e8ed8cc5074283080ad85521696fc93454500" translate="yes" xml:space="preserve">
          <source>Black Question Mark Ornament</source>
          <target state="translated">검은 색 물음표 장식</target>
        </trans-unit>
        <trans-unit id="d17f522d42443e1dee4d94f18ac22410a504bd60" translate="yes" xml:space="preserve">
          <source>Black Rectangle</source>
          <target state="translated">검은 사각형</target>
        </trans-unit>
        <trans-unit id="c7dbb16f8d25cc978eab91325f13bfbb34eb443b" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Double Triangle</source>
          <target state="translated">검은 색 오른쪽을 가리키는 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="9a22fd5458a747bf2f8b9190b0800a8f327c6da4" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pentagon</source>
          <target state="translated">검은 오른쪽 포인팅 국방부</target>
        </trans-unit>
        <trans-unit id="08e8d8d34fe44b6c1da81bad30dfbb3dd0e4dc17" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pointer / Black Right Pointing Pointer</source>
          <target state="translated">검은 오른쪽 포인팅 포인터 / 검은 오른쪽 포인팅 포인터</target>
        </trans-unit>
        <trans-unit id="356acd32b10439549774affb8876e75924c2d411" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle</source>
          <target state="translated">검은 색 오른쪽 포인팅 작은 삼각형 / 검은 색 오른쪽 포인팅 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="91e55728177959f6eb733905e6d5d4b3b30df4c9" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Triangle / Black Right Pointing Triangle</source>
          <target state="translated">검은 색 오른쪽을 가리키는 삼각형 / 검은 색 오른쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="7d35d74427ef7783600f70aed6734b005afcf3a5" translate="yes" xml:space="preserve">
          <source>Black Rightwards Arrow / Black Right Arrow</source>
          <target state="translated">검은 색 오른쪽 화살표 / 검은 색 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="4e1227a3b661c19e11075ce6c898353138a6cae4" translate="yes" xml:space="preserve">
          <source>Black Scissors</source>
          <target state="translated">검은 가위</target>
        </trans-unit>
        <trans-unit id="3a1f9cf604664d5b2cfd7032309a96005ebcdd85" translate="yes" xml:space="preserve">
          <source>Black Small Diamond</source>
          <target state="translated">블랙 스몰 다이아몬드</target>
        </trans-unit>
        <trans-unit id="560e8f05828a680fa9a4f86877ed9847156b94a9" translate="yes" xml:space="preserve">
          <source>Black Small Lozenge</source>
          <target state="translated">검은 작은 마름모꼴</target>
        </trans-unit>
        <trans-unit id="2b77f77dfe2cfd17e674571a7ea6fb868ae1d0ef" translate="yes" xml:space="preserve">
          <source>Black Small Square</source>
          <target state="translated">검은 작은 광장</target>
        </trans-unit>
        <trans-unit id="53c256b922dbb0b4f34a326b72cef14e0af86c98" translate="yes" xml:space="preserve">
          <source>Black Small Star</source>
          <target state="translated">검은 작은 별</target>
        </trans-unit>
        <trans-unit id="0ae1e3c46db08b1fb9b73728e2d7c428044fafa6" translate="yes" xml:space="preserve">
          <source>Black Smiling Face</source>
          <target state="translated">검은 웃는 얼굴</target>
        </trans-unit>
        <trans-unit id="8e05108bb9601bfdc9ba0035253f2d64bdf60694" translate="yes" xml:space="preserve">
          <source>Black Spade Suit</source>
          <target state="translated">검은 스페이드 슈트</target>
        </trans-unit>
        <trans-unit id="a01d4a6e7dbc191a1cae5b3bc838a6150cf238dd" translate="yes" xml:space="preserve">
          <source>Black Square</source>
          <target state="translated">블랙 스퀘어</target>
        </trans-unit>
        <trans-unit id="034b512bb5927fe50340904cd99432e1e4d73c3e" translate="yes" xml:space="preserve">
          <source>Black Square Button</source>
          <target state="translated">블랙 스퀘어 버튼</target>
        </trans-unit>
        <trans-unit id="fc626f5b71fcc01fb3ad79538a1fdd9c2c9068b3" translate="yes" xml:space="preserve">
          <source>Black Star</source>
          <target state="translated">검은 별</target>
        </trans-unit>
        <trans-unit id="cb52335be163268292bf2e0b734ba8007620b51b" translate="yes" xml:space="preserve">
          <source>Black Sun With Rays</source>
          <target state="translated">광선으로 검은 태양</target>
        </trans-unit>
        <trans-unit id="337ee67e4218483768c29454b46d3636ae0684a9" translate="yes" xml:space="preserve">
          <source>Black Telephone</source>
          <target state="translated">검은 전화</target>
        </trans-unit>
        <trans-unit id="35536366f9217c4ba0ce04cd1f6ccbeed6b48c42" translate="yes" xml:space="preserve">
          <source>Black Universal Recycling Symbol</source>
          <target state="translated">검은 보편적 인 재활용 기호</target>
        </trans-unit>
        <trans-unit id="b63e9c12f3af70d3503bfb12a43507958e2cc9a3" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Double Triangle</source>
          <target state="translated">검은 색 위쪽 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="5f6c177d2a76e96c788cfff6b45ea350fc5d5f85" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle</source>
          <target state="translated">검은 색 위를 가리키는 작은 삼각형 / 검은 색 위를 가리키는 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="b019fe1ecc9d7bb3e20c546241096de99470763e" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Triangle / Black Up Pointing Triangle</source>
          <target state="translated">검은 색 위를 가리키는 삼각형 / 검은 색 위를 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="fd38c797487c28729bfa7084dbd1bc7a8bd9f832" translate="yes" xml:space="preserve">
          <source>Black Upper Left Triangle</source>
          <target state="translated">검은 상단 왼쪽 삼각형</target>
        </trans-unit>
        <trans-unit id="330a4e0eb7ba380f3677a102ba04f4ed4533c835" translate="yes" xml:space="preserve">
          <source>Black Upper Right Triangle</source>
          <target state="translated">검은 오른쪽 위 삼각형</target>
        </trans-unit>
        <trans-unit id="b5b860326f4e45d10acdc58e96248cded912b473" translate="yes" xml:space="preserve">
          <source>Black Vertical Ellipse</source>
          <target state="translated">검은 세로 타원</target>
        </trans-unit>
        <trans-unit id="12f762cae12dfd257dbcc1ff1c80f6e21ca05f3a" translate="yes" xml:space="preserve">
          <source>Black Vertical Rectangle</source>
          <target state="translated">검은 세로 직사각형</target>
        </trans-unit>
        <trans-unit id="b6c6da3063676ec7403eb5eae23f28a26cc0a5b1" translate="yes" xml:space="preserve">
          <source>Black Very Small Square</source>
          <target state="translated">검은 매우 작은 광장</target>
        </trans-unit>
        <trans-unit id="f56700596b30b0c05182a7f770b5570cc76ca6d1" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital C / Black-Letter C</source>
          <target state="translated">검은 글자 대문자 C / 검은 글자 C</target>
        </trans-unit>
        <trans-unit id="3212f9c9a227cc0ef9fc8c3906dee3d018e41215" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital H / Black-Letter H</source>
          <target state="translated">검은 글자 대문자 H / 검은 글자 H</target>
        </trans-unit>
        <trans-unit id="882d2d7aaddec9c72be91b9b04d8760d1ae0ecd3" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital I / Black-Letter I</source>
          <target state="translated">검은 글자 대문자 I / 검은 글자 I</target>
        </trans-unit>
        <trans-unit id="8fc35324b6b0420a0444517c7f25614eb146dba4" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital R / Black-Letter R</source>
          <target state="translated">검은 글자 대문자 R / 검은 글자 R</target>
        </trans-unit>
        <trans-unit id="4d139693ac24fa1ff39a927bee456e508f1aa95b" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital Z / Black-Letter Z</source>
          <target state="translated">검은 글자 대문자 Z / 검은 글자 Z</target>
        </trans-unit>
        <trans-unit id="b847d9aaffd54e2b50551787d032091550aee835" translate="yes" xml:space="preserve">
          <source>Blank Symbol / Blank</source>
          <target state="translated">공백 기호 / 공백</target>
        </trans-unit>
        <trans-unit id="9a1f6bbeb59612c3b0d54abe35a469485c6370c0" translate="yes" xml:space="preserve">
          <source>Block quotes</source>
          <target state="translated">따옴표</target>
        </trans-unit>
        <trans-unit id="413fe7b76bad922e0442b15508cafb42d749001b" translate="yes" xml:space="preserve">
          <source>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">지정된 시간 (초) 동안 현재 작업을 차단합니다. 최소 절전 시간은 1 밀리 초 또는 &lt;code&gt;0.001&lt;/code&gt; 입력입니다 .</target>
        </trans-unit>
        <trans-unit id="da010911be728132526ebfb6c6611c41bf6de799" translate="yes" xml:space="preserve">
          <source>Block the current task until some event occurs, depending on the type of the argument:</source>
          <target state="translated">인수 유형에 따라 일부 이벤트가 발생할 때까지 현재 작업을 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="53a69c53a3e2458ff176a179fec2def0b4121cba" translate="yes" xml:space="preserve">
          <source>Blossom</source>
          <target state="translated">Blossom</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="5963e560ae138684a55eeb248a0ec6a3d3e89c64" translate="yes" xml:space="preserve">
          <source>Blue Book</source>
          <target state="translated">블루 북</target>
        </trans-unit>
        <trans-unit id="a660e98a286d13e32848e06494a9c4e64598de77" translate="yes" xml:space="preserve">
          <source>Blue Heart</source>
          <target state="translated">푸른 마음</target>
        </trans-unit>
        <trans-unit id="30efd20f542ce356dcbbbbb0473393dd8189443b" translate="yes" xml:space="preserve">
          <source>Boar</source>
          <target state="translated">Boar</target>
        </trans-unit>
        <trans-unit id="19e07430eed6d97d6d73cb4a2967b1f316520f54" translate="yes" xml:space="preserve">
          <source>Bold</source>
          <target state="translated">Bold</target>
        </trans-unit>
        <trans-unit id="d5bf9d845ab97255cb3ab1100656db4f59731808" translate="yes" xml:space="preserve">
          <source>Bomb</source>
          <target state="translated">Bomb</target>
        </trans-unit>
        <trans-unit id="441da1bf0eb8dcaca895f5d48325eab484ada1e0" translate="yes" xml:space="preserve">
          <source>Bookmark</source>
          <target state="translated">Bookmark</target>
        </trans-unit>
        <trans-unit id="d51cc7068c060eda1ab4c1992e8e7188251dc5d0" translate="yes" xml:space="preserve">
          <source>Bookmark Tabs</source>
          <target state="translated">북마크 탭</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="9110e7395759cef34c9766cb75b920652e0ab037" translate="yes" xml:space="preserve">
          <source>Boolean not. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">부울이 아닙니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;missing&lt;/code&gt; 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; 을&lt;/a&gt; 반환하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 값 논리를&lt;/a&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="29a8f9f9b6a1cad56addb73a669797d31b6ebe67" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e74670608867d2d5a7f2c19b7656691fac4def" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">부울 연산 &lt;em&gt;없이&lt;/em&gt; 단락 평가는 비트에 도입 부울 연산자와 함께 할 수있는 &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;수학 운영 및 초등학교 기능&lt;/a&gt; : &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; . 이들은 보통 연산자이며, 중위 연산자 구문을 지원하지만 항상 인수를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6aee8c1403b8f533d1b1cfe7c809aba2942d98a3" translate="yes" xml:space="preserve">
          <source>Boolean type, containing the values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 포함 된 부울 유형, &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3edec84ef05d40009ef42ad79a184127ff2d32" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">두 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 기본적으로 불변 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 래퍼. 두 유형 중 하나 의 단일 &lt;code&gt;instant&lt;/code&gt; 필드는 실제로 &lt;code&gt;UTInstant{P}&lt;/code&gt; 유형이며, 이는 UT 초를 기준으로 지속적으로 증가하는 머신 타임 라인을 나타냅니다 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; . &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 유형 (시간대 인식하지 &lt;em&gt;순진한&lt;/em&gt; A와 비슷한 파이썬 용어로,), &lt;em&gt;LocalDateTime&lt;/em&gt; 8. 추가 시간대 기능은 통해 추가 할 수 있습니다 자바 &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl 패키지&lt;/a&gt; 컴파일, &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA 시간대 데이터베이스를&lt;/a&gt; . &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 모두&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;/a&gt;Proleptic Gregorian 달력을 따르는 ISO 8601 표준. 한 가지 주목할 점은 ISO 8601 표준이 BC / BCE 날짜와 관련이 있다는 것입니다. 일반적으로 BC / BCE 시대의 마지막 날인 1-12-31 BC / BCE 다음에 1-1-1 AD / CE가 있었으므로 0 년이 존재하지 않습니다. 그러나 ISO 표준에 따르면 1 BC / BCE는 0 년이므로 &lt;code&gt;0000-12-31&lt;/code&gt; 은 &lt;code&gt;0001-01-01&lt;/code&gt; 전날 이고 연도 &lt;code&gt;-0001&lt;/code&gt; (예, 음수는 1)은 2 BC / BCE입니다. &lt;code&gt;-0002&lt;/code&gt; 년 은 3 BC / BCE 등입니다.</target>
        </trans-unit>
        <trans-unit id="9bd9372ad6716aa533ad19c4f4344f9f861990d8" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bf1ed5d0b3dee373193977f771d3d28aa04eff" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fdot&lt;/code&gt; compute the same thing. However, &lt;code&gt;fdot&lt;/code&gt; (defined with the help of the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) is significantly faster when applied to an array:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;fdot&lt;/code&gt; 는 모두 같은 것을 계산합니다. 그러나 배열에 적용하면 &lt;code&gt;fdot&lt;/code&gt; ( &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 정의 됨 )가 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="894facd8272490d18ae36dfbd0aea23dbfd8d0be" translate="yes" xml:space="preserve">
          <source>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; returns true (essentially, things like numbers and bools that are stored like C types or &lt;code&gt;struct&lt;/code&gt;s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</source>
          <target state="translated">추상 및 콘크리트 유형 모두 다른 유형으로 매개 변수화 할 수 있습니다. 또한 기호, &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt; 가 true를 리턴 하는 모든 유형의 값 (실제로 C 유형 또는 &lt;code&gt;struct&lt;/code&gt; 처럼 다른 객체에 대한 포인터없이 저장된 숫자 및 부울 과 같은 것)과 그 튜플에 의해 매개 변수화 될 수 있습니다 . 유형 매개 변수는 참조하거나 제한 할 필요가없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63dac16e286415a31cf4c5cfa7d67dab90fd4b82" translate="yes" xml:space="preserve">
          <source>Both concatenation and string interpolation call &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to convert objects into string form. However, &lt;code&gt;string&lt;/code&gt; actually just returns the output of &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, so new types should add methods to &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">연결 및 문자열 보간 모두 &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 을 호출 하여 개체를 문자열 형식으로 변환합니다. 그러나 &lt;code&gt;string&lt;/code&gt; 은 실제로는 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 출력 만 반환 하므로 새로운 유형은 &lt;code&gt;string&lt;/code&gt; 대신 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;show&lt;/code&gt; 메소드를 추가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="007479614c6ddfc352db8c91872c6cdcf690ee04" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92cf62db18ffc6b16befca5871ba839cf28860c" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">두 표현식 모두 함수 애플리케이션으로 해석됩니다. 숫자 리터럴이 아닌 표현식은 바로 뒤에 괄호가 붙는 경우 괄호 안의 값에 적용되는 함수로 해석됩니다 ( &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;함수에&lt;/a&gt; 대한 자세한 내용은 함수 참조). 따라서 두 경우 모두 왼쪽 값이 함수가 아니기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe2f60cb62bba939fc1814f0702994179d2cc9fd" translate="yes" xml:space="preserve">
          <source>Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</source>
          <target state="translated">이 두 구현은 서로 다르지만 본질적으로 동일한 작업을 수행합니다. 즉, 배열 차원에 대한 런타임 루프를 통해 각 차원의 오프셋을 최종 인덱스로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="9c695a21716f0561a4e4e8d8969c9a67ff3ac14a" translate="yes" xml:space="preserve">
          <source>Bottom Curly Bracket</source>
          <target state="translated">바텀 컬리 브라켓</target>
        </trans-unit>
        <trans-unit id="5c381cbda1ed56fa362cad0521e4ca378f6df12d" translate="yes" xml:space="preserve">
          <source>Bottom Left Corner</source>
          <target state="translated">왼쪽 하단</target>
        </trans-unit>
        <trans-unit id="8b91a1776362601aa94f5e511fc42880fb137818" translate="yes" xml:space="preserve">
          <source>Bottom Right Corner</source>
          <target state="translated">오른쪽 하단</target>
        </trans-unit>
        <trans-unit id="408cb2c9aacb6c00f4eea9f155e68230edfc13be" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket</source>
          <target state="translated">바텀 스퀘어 브라켓</target>
        </trans-unit>
        <trans-unit id="b587f4044bf50468cb606a8c8b879cf7bf3a57b0" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket Over Top Square Bracket</source>
          <target state="translated">상단 사각 브래킷 위에 하단 사각 브래킷</target>
        </trans-unit>
        <trans-unit id="be63873217899f3efce2481a86c1d5a6e1aa9ff7" translate="yes" xml:space="preserve">
          <source>Bouquet</source>
          <target state="translated">Bouquet</target>
        </trans-unit>
        <trans-unit id="527e7050bb885ff38897eb7cbe0d818d6e05448e" translate="yes" xml:space="preserve">
          <source>Bowling</source>
          <target state="translated">Bowling</target>
        </trans-unit>
        <trans-unit id="df3f8f8f9dfd1bd2fca6e5c445d1a47fa385ede3" translate="yes" xml:space="preserve">
          <source>Bowtie</source>
          <target state="translated">Bowtie</target>
        </trans-unit>
        <trans-unit id="2365940089f0b35468618bed420a02ff8d78ea80" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right</source>
          <target state="translated">박스 도면 라이트 대각선 위 왼쪽에서 오른쪽 아래로 / 형태 라이트 대각선 위 왼쪽에서 오른쪽 아래로</target>
        </trans-unit>
        <trans-unit id="510ae6748e0c9b114a5f8b83c8badc7f63a16bc0" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left</source>
          <target state="translated">상자 그림 빛 대각선 위 오른쪽 아래 왼쪽 / 형태 빛 대각선 위 오른쪽 아래 왼쪽</target>
        </trans-unit>
        <trans-unit id="12f6d098ab5b7193c3d26b08f696b2a980dca3f4" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical</source>
          <target state="translated">상자 그림 가벼운 3 배 돌진 수직 / 형태 가벼운 3 배 돌진 수직</target>
        </trans-unit>
        <trans-unit id="85230437c79e72b707969ab19fa9c93e520c40d0" translate="yes" xml:space="preserve">
          <source>Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy</source>
          <target state="translated">상자 그리기 가볍고 무거움 / 가볍고 무거움</target>
        </trans-unit>
        <trans-unit id="b9dc9d8cb52edb821b0da78df2b6682eb917d791" translate="yes" xml:space="preserve">
          <source>Boy</source>
          <target state="translated">Boy</target>
        </trans-unit>
        <trans-unit id="c61eb5df5d78529f719e752eeef8ece81e0caaa8" translate="yes" xml:space="preserve">
          <source>Bread</source>
          <target state="translated">Bread</target>
        </trans-unit>
        <trans-unit id="67334b607f6cd61759a7703ce073645a7bb380d4" translate="yes" xml:space="preserve">
          <source>Break functions into multiple definitions</source>
          <target state="translated">함수를 여러 정의로 나누기</target>
        </trans-unit>
        <trans-unit id="8a10e4a625ea22134f5962dee4da949a99868e13" translate="yes" xml:space="preserve">
          <source>Break out of a loop immediately.</source>
          <target state="translated">루프를 즉시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="392384778265e06187313603c1377439a8615e6f" translate="yes" xml:space="preserve">
          <source>Break the &lt;code&gt;ConfigEntry&lt;/code&gt; up to the following pieces: section, subsection, name, and value.</source>
          <target state="translated">휴식 &lt;code&gt;ConfigEntry&lt;/code&gt; 을 다음 조각까지 : 섹션, 하위 섹션, 이름 및 값입니다.</target>
        </trans-unit>
        <trans-unit id="7632e2c1e249278468e77e6447234ae7607c5253" translate="yes" xml:space="preserve">
          <source>Breve / Spacing Breve</source>
          <target state="translated">브 리브 / 간격 브 리브</target>
        </trans-unit>
        <trans-unit id="daaf045cb7109dd158210ed8775987a60503bbb6" translate="yes" xml:space="preserve">
          <source>Bride With Veil</source>
          <target state="translated">베일과 신부</target>
        </trans-unit>
        <trans-unit id="4e7371d09f6498019117c2fcbb67ffe9a940c17f" translate="yes" xml:space="preserve">
          <source>Bridge At Night</source>
          <target state="translated">밤에 다리</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">간단한 설명</target>
        </trans-unit>
        <trans-unit id="b11bca2ce38ace33f9cb3a0f0323440cce89dd0f" translate="yes" xml:space="preserve">
          <source>Briefcase</source>
          <target state="translated">Briefcase</target>
        </trans-unit>
        <trans-unit id="77ca3fc6500edac54d325df1bbb7ac8e363c54b5" translate="yes" xml:space="preserve">
          <source>Broadcast</source>
          <target state="translated">Broadcast</target>
        </trans-unit>
        <trans-unit id="5959941fc9ce31c144990539361b6855d239f922" translate="yes" xml:space="preserve">
          <source>Broadcast Styles</source>
          <target state="translated">방송 스타일</target>
        </trans-unit>
        <trans-unit id="cdaa679362eaad18a4a290d4b2177d1c9eddf091" translate="yes" xml:space="preserve">
          <source>Broadcast and vectorization</source>
          <target state="translated">방송 및 벡터화</target>
        </trans-unit>
        <trans-unit id="7df7947bfeebee1e64e3a5fe7acfcbaa176cd869" translate="yes" xml:space="preserve">
          <source>Broadcast the function &lt;code&gt;f&lt;/code&gt; over the arrays, tuples, collections, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt;s and/or scalars &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">배열, 튜플, 컬렉션, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; 및 / 또는 스칼라 &lt;code&gt;As&lt;/code&gt; 로 함수 &lt;code&gt;f&lt;/code&gt; 를 브로드 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="074efe61b6453184efecedf79f56223cb3b56a06" translate="yes" xml:space="preserve">
          <source>Broadcast.@__dot__</source>
          <target state="translated">Broadcast.@__dot__</target>
        </trans-unit>
        <trans-unit id="d9974c014c3e7a0c286c1e54c44afebb2e5a2605" translate="yes" xml:space="preserve">
          <source>Broadcast.AbstractArrayStyle</source>
          <target state="translated">Broadcast.AbstractArrayStyle</target>
        </trans-unit>
        <trans-unit id="e479e2fec9cd8edd73518e3aa9d740af4ffed128" translate="yes" xml:space="preserve">
          <source>Broadcast.ArrayStyle</source>
          <target state="translated">Broadcast.ArrayStyle</target>
        </trans-unit>
        <trans-unit id="46b115d26f9c6f955c31e3892d4b89859d8782ab" translate="yes" xml:space="preserve">
          <source>Broadcast.BroadcastStyle</source>
          <target state="translated">Broadcast.BroadcastStyle</target>
        </trans-unit>
        <trans-unit id="dfd372b601ba77b3813f2634bb5fb9643c14c102" translate="yes" xml:space="preserve">
          <source>Broadcast.DefaultArrayStyle</source>
          <target state="translated">Broadcast.DefaultArrayStyle</target>
        </trans-unit>
        <trans-unit id="6969d3cd7b2ed2ce0f9a60fb4945dade93d4e117" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast!()</source>
          <target state="translated">Broadcast.broadcast!()</target>
        </trans-unit>
        <trans-unit id="2d33589d08eead5af3fe72a94a8b53b3373f4645" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast()</source>
          <target state="translated">Broadcast.broadcast()</target>
        </trans-unit>
        <trans-unit id="d8be6debc5bb7fb35ee9eb11d215775cae452707" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcastable()</source>
          <target state="translated">Broadcast.broadcastable()</target>
        </trans-unit>
        <trans-unit id="48464259628c114acb1957dc941186fb95dc6984" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_axes()</source>
          <target state="translated">Broadcast.combine_axes()</target>
        </trans-unit>
        <trans-unit id="65a7f7386144353a37453858bdd5ecb6ccb1274f" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_styles()</source>
          <target state="translated">Broadcast.combine_styles()</target>
        </trans-unit>
        <trans-unit id="d36a0668f40c2a01499f97eb697585c01ce9b9ab" translate="yes" xml:space="preserve">
          <source>Broadcast.result_style()</source>
          <target state="translated">Broadcast.result_style()</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="0e83693fd8be7602fb86ef05c34ce5d03fd5fce4" translate="yes" xml:space="preserve">
          <source>Broadcasting applies the function &lt;code&gt;f&lt;/code&gt; over the elements of the container arguments and the scalars themselves in &lt;code&gt;As&lt;/code&gt;. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">브로드 캐스팅 은 컨테이너 인수의 요소와 &lt;code&gt;As&lt;/code&gt; 의 스칼라 자체에 함수 &lt;code&gt;f&lt;/code&gt; 를 적용합니다 . 단일 값과 누락 된 차원은 값을 사실상 반복하여 다른 인수의 범위와 일치하도록 확장됩니다. 기본적으로 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; , &lt;code&gt;Type&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; 및 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 과 같은 일반적인 싱글 톤을 포함하여 제한된 수의 유형 만 스칼라로 간주됩니다 . 다른 모든 인수는 요소 단위로 반복되거나 색인화됩니다.</target>
        </trans-unit>
        <trans-unit id="7b246945f4825122c3abc36d497da5fe651d872b" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior of &lt;code&gt;SrcType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SrcType&lt;/code&gt; 의 브로드 캐스트 동작</target>
        </trans-unit>
        <trans-unit id="0e2fa4ca8541a569a98cefd4832f00fffb8a668a" translate="yes" xml:space="preserve">
          <source>Broadcasting of CartesianIndices requires at least Julia 1.1.</source>
          <target state="translated">데카르트 인덱스를 브로드 캐스트하려면 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de4b71257ec056201227e217cf933d2e092cf0c7" translate="yes" xml:space="preserve">
          <source>Broken Bar / Broken Vertical Bar</source>
          <target state="translated">깨진 바 / 깨진 수직 바</target>
        </trans-unit>
        <trans-unit id="0d35795616ab98cd5aa59673de45c7c6c73a4a9c" translate="yes" xml:space="preserve">
          <source>Broken Heart</source>
          <target state="translated">상한 마음</target>
        </trans-unit>
        <trans-unit id="79b7916b0d6bd1fa29180da64a852f6051cdd3b6" translate="yes" xml:space="preserve">
          <source>Broken Tests</source>
          <target state="translated">깨진 테스트</target>
        </trans-unit>
        <trans-unit id="8cb75fd2f909d7fe2d9ebdd702d582785b35815a" translate="yes" xml:space="preserve">
          <source>Browser-based workflow</source>
          <target state="translated">브라우저 기반 워크 플로우</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="a0ff1503de64d75563fdaa852cd66a5161072182" translate="yes" xml:space="preserve">
          <source>Build the output matrix as &lt;code&gt;similar(R, dims)&lt;/code&gt;, where &lt;code&gt;dims&lt;/code&gt; are the desired dimensions of the output array.</source>
          <target state="translated">출력 행렬을 &lt;code&gt;similar(R, dims)&lt;/code&gt; 로 빌드합니다 . 여기서 &lt;code&gt;dims&lt;/code&gt; 는 원하는 출력 배열 크기입니다.</target>
        </trans-unit>
        <trans-unit id="9b68712d139bce25a7399715ee37cf5a89ca4787" translate="yes" xml:space="preserve">
          <source>Building a similar type with a different type parameter</source>
          <target state="translated">다른 유형 매개 변수로 유사한 유형 작성</target>
        </trans-unit>
        <trans-unit id="472631cf7902fb6cb7b3cc2952c6a64c270752fa" translate="yes" xml:space="preserve">
          <source>Building an advanced macro</source>
          <target state="translated">고급 매크로 작성</target>
        </trans-unit>
        <trans-unit id="fe79fc1370416c81e94ca362477853ed355de172" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;Exception&lt;/code&gt;s</source>
          <target state="translated">내장 &lt;code&gt;Exception&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="b98da0ccc81f4f734434572f19ccc66972aae344" translate="yes" xml:space="preserve">
          <source>Bullet</source>
          <target state="translated">Bullet</target>
        </trans-unit>
        <trans-unit id="b2e3c9a189a187c73db37aa7676051a963459c1a" translate="yes" xml:space="preserve">
          <source>Bullet Operator</source>
          <target state="translated">총알 연산자</target>
        </trans-unit>
        <trans-unit id="ffb3a635db82436b5aade99cffc92370f3f7ed19" translate="yes" xml:space="preserve">
          <source>Bullseye</source>
          <target state="translated">Bullseye</target>
        </trans-unit>
        <trans-unit id="6380df8107fb2d9626efb1aee5cb211de2982cbd" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman (see &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; &lt;/a&gt; -카우프만 ( bunchkaufman 참조 )</target>
        </trans-unit>
        <trans-unit id="d42c62a3c53679a83b69d0fce6f99bfd41a308aa" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman factorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56070a568367d5a4e9970cfff19cb97578ce1361" translate="yes" xml:space="preserve">
          <source>Bus</source>
          <target state="translated">Bus</target>
        </trans-unit>
        <trans-unit id="de2d017d398674ca4eafe20ca3761f2f657234b8" translate="yes" xml:space="preserve">
          <source>Bus Stop</source>
          <target state="translated">버스 정류장</target>
        </trans-unit>
        <trans-unit id="97d53e844a4148a55c4152e5e7736932ca111090" translate="yes" xml:space="preserve">
          <source>Bust In Silhouette</source>
          <target state="translated">실루엣에 흉상</target>
        </trans-unit>
        <trans-unit id="45f0d298267aa05679aedb20cf6611cfa3d2a5d1" translate="yes" xml:space="preserve">
          <source>Busts In Silhouette</source>
          <target state="translated">실루엣에 흉상</target>
        </trans-unit>
        <trans-unit id="e7a7510504bc122560ba5c8208e379522ff06902" translate="yes" xml:space="preserve">
          <source>But here is a thing you should pay attention to: suppose &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you can change its content. For example:</source>
          <target state="translated">그러나 여기에주의해야 할 사항이 있습니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Array&lt;/code&gt; 유형의 객체 (또는 다른 &lt;em&gt;변경 가능한&lt;/em&gt; 유형)에 바인딩되어 있다고 가정하십시오 . 함수 내 에서이 배열에서 &lt;code&gt;x&lt;/code&gt; 를 &quot;바인드 해제&quot; 할 수 없지만 내용을 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0adf28177ba73d224bb6721567052c88af510023" translate="yes" xml:space="preserve">
          <source>But how does one construct the first instance when no instance exists to provide as a valid value for its &lt;code&gt;obj&lt;/code&gt; field? The only solution is to allow creating an incompletely initialized instance of &lt;code&gt;SelfReferential&lt;/code&gt; with an unassigned &lt;code&gt;obj&lt;/code&gt; field, and using that incomplete instance as a valid value for the &lt;code&gt;obj&lt;/code&gt; field of another instance, such as, for example, itself.</source>
          <target state="translated">그러나 &lt;code&gt;obj&lt;/code&gt; 필드에 유효한 값으로 제공 할 인스턴스가없는 경우 첫 번째 인스턴스를 어떻게 구성 합니까? 유일한 해결책은 할당되지 않은 &lt;code&gt;obj&lt;/code&gt; 필드를 사용하여 불완전하게 초기화 된 &lt;code&gt;SelfReferential&lt;/code&gt; 인스턴스를 작성하고 해당 불완전한 인스턴스 를 다른 인스턴스 의 &lt;code&gt;obj&lt;/code&gt; 필드 (예 : 자체)에 대한 유효한 값으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64b3ab17aa40196bbbe2b14cd1e8633f165597c6" translate="yes" xml:space="preserve">
          <source>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well &amp;ndash; assuming GNU make because of the use of the &lt;strong&gt;shell&lt;/strong&gt; macro expansions. Additionally, though many times &lt;code&gt;julia-config.jl&lt;/code&gt; may be found in the directory &lt;code&gt;/usr/local&lt;/code&gt;, this is not necessarily the case, but Julia can be used to locate &lt;code&gt;julia-config.jl&lt;/code&gt; too, and the makefile can be used to take advantage of that. The above example is extended to use a Makefile:</source>
          <target state="translated">그러나 일반적으로 프로젝트 임베드는 위의 것보다 복잡하므로 다음은 &lt;strong&gt;쉘&lt;/strong&gt; 매크로 확장 의 사용으로 인해 GNU make를 가정 할 때 일반적인 makefile도 지원 합니다. 또한 여러 번 &lt;code&gt;julia-config.jl&lt;/code&gt; 이 &lt;code&gt;/usr/local&lt;/code&gt; 디렉토리에있을 수 있지만, 반드시 그런 것은 아니지만 Julia를 사용하여 &lt;code&gt;julia-config.jl&lt;/code&gt; 을 찾을 수 있으며 makefile을 사용하여 makefile을 사용할 수 있습니다. 그것의 장점. 위의 예는 Makefile을 사용하도록 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="26a3e909feee0f8ba5a7fedacb473c7c1f12eb3d" translate="yes" xml:space="preserve">
          <source>But now let's say you want to write a function that creates a 3&amp;times;3&amp;times;... array in arbitrary dimensions; you might be tempted to write a function</source>
          <target state="translated">그러나 이제 임의의 차원에서 3 &amp;times; 3 &amp;times; ... 배열을 만드는 함수를 작성한다고 가정 해 봅시다. 함수를 작성하고 싶을 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="7e347dfe55eb3d3f84185c35ba67fdd467b54efe" translate="yes" xml:space="preserve">
          <source>But there's an exception: future calls to &lt;code&gt;newfun&lt;/code&gt;&lt;em&gt;from the REPL&lt;/em&gt; work as expected, being able to both see and call the new definition of &lt;code&gt;newfun&lt;/code&gt;.</source>
          <target state="translated">그러나 예외 &lt;em&gt;는 REPL에서 &lt;/em&gt; &lt;code&gt;newfun&lt;/code&gt; 에&lt;em&gt;대한&lt;/em&gt; 향후 호출이 예상대로 작동하며 &lt;code&gt;newfun&lt;/code&gt; 의 새로운 정의를보고 호출 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7dcbe9aaf1e0a6755fccfa933b76845ffa848937" translate="yes" xml:space="preserve">
          <source>But we are currently on the master thread. To check, we use the function &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt;&lt;code&gt;Threads.threadid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">그러나 우리는 현재 마스터 스레드에 있습니다. 확인하려면 &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt; &lt;code&gt;Threads.threadid&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c84f932b434e9c92f4f20cc3eb7ea04021d4d339" translate="yes" xml:space="preserve">
          <source>By convention, function names ending with an exclamation point (&lt;code&gt;!&lt;/code&gt;) modify their arguments. Some functions have both modifying (e.g., &lt;code&gt;sort!&lt;/code&gt;) and non-modifying (&lt;code&gt;sort&lt;/code&gt;) versions.</source>
          <target state="translated">일반적으로 느낌표 ( &lt;code&gt;!&lt;/code&gt; )로 끝나는 함수 이름 은 인수를 수정합니다. 일부 함수에는 수정 (예 : &lt;code&gt;sort!&lt;/code&gt; ) 및 비 수정 ( &lt;code&gt;sort&lt;/code&gt; ) 버전이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d3b6d57737895d1e4453b18b72e5f94ecdeb4e" translate="yes" xml:space="preserve">
          <source>By convention, functions that modify their arguments have a &lt;code&gt;!&lt;/code&gt; at the end of the name, for example &lt;code&gt;push!&lt;/code&gt;.</source>
          <target state="translated">일반적으로 인수를 수정하는 함수에는 &lt;code&gt;!&lt;/code&gt; 예를 들어 이름의 끝에 &lt;code&gt;push!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab2ce248423f04c77b0bad395e4714e39c7fb937" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(itr)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760f93efed44d4a2ba0963c541f9ed0ec06bfb96" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(v)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a501bd6222e05849ace3fea85fb677e79bd185" translate="yes" xml:space="preserve">
          <source>By default a worker will listen on a free port at the address returned by a call to &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt;&lt;code&gt;getipaddr()&lt;/code&gt;&lt;/a&gt;. A specific address to listen on may be specified by optional argument &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt;. This is useful for multi-homed hosts.</source>
          <target state="translated">기본적으로 작업자는 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt; &lt;code&gt;getipaddr()&lt;/code&gt; &lt;/a&gt; 호출에 의해 리턴 된 주소에서 사용 가능한 포트를 청취합니다 . 수신 할 특정 주소는 선택적 인수 &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt; 로 지정할 수 있습니다 . 멀티 홈 호스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cb670232f9c9a08075052bf52fba2ffbf6b303ba" translate="yes" xml:space="preserve">
          <source>By default all exceptions are caught to prevent log message generation from crashing the program. This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</source>
          <target state="translated">기본적으로 모든 예외는 로그 메시지 생성으로 인해 프로그램이 충돌하는 것을 방지합니다. 이를 통해 사용자는 프로덕션 시스템에서 디버그 로깅과 같은 거의 사용되지 않는 기능을 자신있게 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3274665bf281763d801f2b3f0f09acc363497f47" translate="yes" xml:space="preserve">
          <source>By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set &lt;code&gt;wait=true&lt;/code&gt; and julia will wait for the editor to close before resuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09501703ac8c23ae9a60cea7e5421daf3cd18b0" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;@testset&lt;/code&gt; macro will return the testset object itself, though this behavior can be customized in other testset types. If a &lt;code&gt;for&lt;/code&gt; loop is used then the macro collects and returns a list of the return values of the &lt;code&gt;finish&lt;/code&gt; method, which by default will return a list of the testset objects used in each iteration.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; 매크로는 기본적으로 테스트 세트 객체 자체를 반환하지만이 동작은 다른 테스트 세트 유형에서 사용자 지정할 수 있습니다. 경우 &lt;code&gt;for&lt;/code&gt; 루프가 다음 매크로를 수집을 사용하고의 반환 값의 목록을 반환 &lt;code&gt;finish&lt;/code&gt; 기본적으로 테스트 세트의 목록을 반환 방법, 각 반복에 사용되는 객체.</target>
        </trans-unit>
        <trans-unit id="62c321cdf328de0b934c0ed64ba600400a916f6d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pmap&lt;/code&gt; distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify &lt;code&gt;distributed=false&lt;/code&gt;. This is equivalent to using &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; is equivalent to &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;code&gt;pmap&lt;/code&gt; 은 지정된 모든 작업자에게 계산을 분산시킵니다. 로컬 프로세스 만 사용하고 태스크를 분배하려면 &lt;code&gt;distributed=false&lt;/code&gt; 지정하십시오 . 이것은 &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 예를 들어, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; 는 &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="869bf1d13613c15994bb6c5a2998c89afa6bc5e7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;readdir&lt;/code&gt; sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use &lt;code&gt;readir(dir, sort=false)&lt;/code&gt; to opt out of sorting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f89fa8608376528e1d0c826b9825a253fbd041b" translate="yes" xml:space="preserve">
          <source>By default, Fortran compilers &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;generate mangled names&lt;/a&gt; (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</source>
          <target state="translated">기본적으로 포트란 컴파일러 &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;는 맹 글링 된 이름&lt;/a&gt; (예 : 함수 이름을 소문자 또는 대문자로 변환하고 밑줄을 추가하는 경우)을 생성하므로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 을 통해 포트란 함수를 호출 하려면 규칙에 해당하는 맹 글링 된 식별자를 전달해야합니다. . 또한 포트란 함수를 호출 할 때 모든 입력은 힙 또는 스택에서 할당 된 값에 대한 포인터로 전달되어야합니다. 이것은 일반적으로 힙 할당되는 배열 및 기타 가변 객체뿐만 아니라 C 또는 Julia 호출 규칙을 사용할 때 일반적으로 스택 할당되고 일반적으로 레지스터에 전달되는 정수 및 부동 소수점과 같은 스칼라 값에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b4db9ff202a42835afe09d8709e3f5d83b19913" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97954da2a37348f9b604be87e49342f9bb3f535a" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Julia는 &lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt; 함수뿐만 아니라 부울 요소 ( &lt;code&gt;.==&lt;/code&gt; 와 같은 점으로 구분 된 비교 포함)를 생성하는 &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;브로드 캐스트&lt;/a&gt; 조작 에서 &lt;code&gt;BitArrays&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b61e736cef16f73d649bec40a1cb5e23234e0fb3" translate="yes" xml:space="preserve">
          <source>By default, Julia starts up with a single thread of execution. This can be verified by using the command &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt;&lt;code&gt;Threads.nthreads()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Julia는 단일 실행 스레드로 시작합니다. &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt; &lt;code&gt;Threads.nthreads()&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a32e1e323d14dc3db4577d3f3c64972051fa6f1a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;redisplay&lt;/code&gt; functions simply call &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt;. However, some display backends may override &lt;code&gt;redisplay&lt;/code&gt; to modify an existing display of &lt;code&gt;x&lt;/code&gt; (if any). Using &lt;code&gt;redisplay&lt;/code&gt; is also a hint to the backend that &lt;code&gt;x&lt;/code&gt; may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</source>
          <target state="translated">기본적으로 &lt;code&gt;redisplay&lt;/code&gt; 기능은 단순히 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 . 그러나 일부 디스플레이 백엔드는 &lt;code&gt;x&lt;/code&gt; 의 기존 디스플레이 (있는 경우) 를 수정하기 위해 &lt;code&gt;redisplay&lt;/code&gt; 디스플레이를 재정의 할 수 있습니다 . &lt;code&gt;redisplay&lt;/code&gt; 사용 하는 것은 &lt;code&gt;x&lt;/code&gt; 가 여러 번 다시 표시 될 수 있다는 백엔드의 힌트 이며 백엔드는 다음 대화식 프롬프트가 나타날 때까지 표시를 연기하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a789ab7e78cdd1c9fcc76d1aa6c29cc8860d633" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2434a57ba6bd0a71b3ac08a278b454d4192e915f" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;code&gt;Diagonal&lt;/code&gt; or &lt;code&gt;SymTridiagonal&lt;/code&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">기본적으로 고유 값과 벡터는 사전 순으로 &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; 로 정렬됩니다 . &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; 다른 비교 함수 를 &lt;code&gt;sortby&lt;/code&gt; 로 전달 하거나 &lt;code&gt;sortby=nothing&lt;/code&gt; 을 전달 하여 고유 값을 임의의 순서로 남겨 둘 수 있습니다 . 일부 특수 행렬 유형 (예 : &lt;code&gt;Diagonal&lt;/code&gt; 또는 &lt;code&gt;SymTridiagonal&lt;/code&gt; )은 자체 정렬 규칙을 구현하고 &lt;code&gt;sortby&lt;/code&gt; 키워드를 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1522d8655f0697d6a68319f9a29fb0897d5118" translate="yes" xml:space="preserve">
          <source>By default, the relative tolerance &lt;code&gt;rtol&lt;/code&gt; is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">기본적으로 상대 공차 &lt;code&gt;rtol&lt;/code&gt; 은 &lt;code&gt;n*ϵ&lt;/code&gt; 이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 의 가장 작은 치수의 크기 이고 &lt;code&gt;ϵ&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 요소 유형의 &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="36562c471751aaedc6db712652b89541573e3bb4" translate="yes" xml:space="preserve">
          <source>By extension any odd number of backticks may be used to enclose a lesser number of backticks.</source>
          <target state="translated">확장하여, 적은 수의 백틱을 포함하기 위해 임의의 홀수의 백틱이 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="300c0d12698af77dc8e2c084d058d532e1315b6c" translate="yes" xml:space="preserve">
          <source>By printing the array, one can verify that the elements of &lt;code&gt;x&lt;/code&gt; are now reversed.</source>
          <target state="translated">배열을 인쇄하면 &lt;code&gt;x&lt;/code&gt; 의 요소가 반전 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="760e88f232085bdc1aa9ba910e6eb19bee1e689b" translate="yes" xml:space="preserve">
          <source>By running &quot;infrequently&quot; there is very little performance overhead; while profiling, your code can run at nearly native speed.</source>
          <target state="translated">&quot;가끔&quot;실행하면 성능 오버 헤드가 거의 없습니다. 프로파일 링하는 동안 코드는 거의 기본 속도로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b6f4faddfdd9853ff8e907fd6f47265a9f07a0" translate="yes" xml:space="preserve">
          <source>By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times. However, a minor release of Julia (e.g. 1.3 to 1.4) &lt;em&gt;may change&lt;/em&gt; the sequence of pseudorandom numbers generated from a specific seed. (Even if the sequence produced by a low-level function like &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; does not change, the output of higher-level functions like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt; may change due to algorithm updates.) Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24780bfad6073c3cb5039801b32f126d34c1cde" translate="yes" xml:space="preserve">
          <source>Byte Array Literals</source>
          <target state="translated">바이트 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="c950fe9e51a4a280dd4bb58c0d0951450fe7bbf3" translate="yes" xml:space="preserve">
          <source>C &lt;strong&gt;MUST NOT&lt;/strong&gt; modify the memory returned via &lt;code&gt;Ref{T}&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;isbits&lt;/code&gt; type</source>
          <target state="translated">C는 &lt;strong&gt;안&lt;/strong&gt; 통해 반환 된 메모리 수정 &lt;code&gt;Ref{T}&lt;/code&gt; 하면 &lt;code&gt;T&lt;/code&gt; 가 입니다 &lt;code&gt;isbits&lt;/code&gt; 의 유형</target>
        </trans-unit>
        <trans-unit id="a10776e7bb2378d8306c9c38209f9a25bdd03a13" translate="yes" xml:space="preserve">
          <source>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi:10.1137/0908009&lt;/a&gt;</source>
          <target state="translated">C Bischof 및 C Van Loan, &quot;가계 매트릭스 제품의 WY 표현&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;도 : 10.1137 / 0908009&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C 인터페이스</target>
        </trans-unit>
        <trans-unit id="6592ddb6b4a1a593e3571fb32f8e7a37a9f3a350" translate="yes" xml:space="preserve">
          <source>C Standard Library</source>
          <target state="translated">C 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="3a8599236e86a8cb6d00c7c55845e656c7c05673" translate="yes" xml:space="preserve">
          <source>C Wrapper Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e127f5f8d00244c8e1c9f0ff88de5ec4ac1783" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;credentials_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;credentials_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="c33ee7fd9016392ef47ce064a1a8200fb287dc56" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetchhead_foreach_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="bf80fd7e58e3463df2196d9d8b7daa3fb24795de" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;mirror_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mirror_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="5cb63f576281637ef8721a44852ed39bd47bda3e" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of the type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">&lt;code&gt;char**&lt;/code&gt; 유형의 인수를 사용하는 C 함수는 Julia 내에서 &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; 유형 을 사용하여 호출 할 수 있습니다 . 예를 들어, 다음 형식의 C 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb931938945d732d0cc3c0bc381f1e2e03fc8a86" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272eaa6fb30cbc6d678d9c3342e07f66e1c123e0" translate="yes" xml:space="preserve">
          <source>C name</source>
          <target state="translated">C 이름</target>
        </trans-unit>
        <trans-unit id="315194526a16e46e96fc7a6c9fe2f734e368a015" translate="yes" xml:space="preserve">
          <source>C shell on Linux/macOS, CMD on Windows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="7877de4c10096f42fa8b542b38a0c8abfeff2993" translate="yes" xml:space="preserve">
          <source>CFunction</source>
          <target state="translated">CFunction</target>
        </trans-unit>
        <trans-unit id="d6deb7587f97d7c2e002671a4a7ec9c17092aa98" translate="yes" xml:space="preserve">
          <source>CRC32c</source>
          <target state="translated">CRC32c</target>
        </trans-unit>
        <trans-unit id="946e46ea933373d5acfe718ba4c46ff0c631d8da" translate="yes" xml:space="preserve">
          <source>C_NULL</source>
          <target state="translated">C_NULL</target>
        </trans-unit>
        <trans-unit id="062c01810c7f050347900909c2a5c905fb7f6b61" translate="yes" xml:space="preserve">
          <source>Caches credential information for re-use</source>
          <target state="translated">재사용을 위해 신임 정보를 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="9f296c645c05d20e8d397ba3c6535ccc69ae356d" translate="yes" xml:space="preserve">
          <source>Caching of native pointers.</source>
          <target state="translated">기본 포인터 캐싱.</target>
        </trans-unit>
        <trans-unit id="ffbcb973995142c82bf466dc886625f88d2fbcf8" translate="yes" xml:space="preserve">
          <source>Cactus</source>
          <target state="translated">Cactus</target>
        </trans-unit>
        <trans-unit id="ac32f232b7ff982020ec20b1d05cbfe41644842d" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result.</source>
          <target state="translated">행렬 행렬 곱 $ AB $를 계산하고 &lt;code&gt;A&lt;/code&gt; 를 덮어 쓰고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="129c66daa23d40a052d78c17325451f781f1cd27" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result. Here, &lt;code&gt;B&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d41dc1e33975c5f259e3c41e3a555f7d4e2007c" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result.</source>
          <target state="translated">행렬 행렬 곱 $ AB $를 계산하고 &lt;code&gt;B&lt;/code&gt; 를 덮어 쓰고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f409cbcda5b59decdd240fd1a21ee0be89005565" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result. Here, &lt;code&gt;A&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c95fa1680ff9d2f9d27d1192e3762d37dafb02b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;-x&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;-typemin(Int)&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;-x&lt;/code&gt; 를 계산합니다 . 예를 들어 표준 2의 보수 부호있는 정수 (예 : &lt;code&gt;Int&lt;/code&gt; )는 &lt;code&gt;-typemin(Int)&lt;/code&gt; 나타낼 수 없으므로 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6167c036f7bc22425fe096ac27be440fe0ac62c7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;abs(x)&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;abs(typemin(Int))&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">해당하는 경우 오버플로 오류를 확인하여 &lt;code&gt;abs(x)&lt;/code&gt; 계산 합니다. 예를 들어 표준 2의 보수 부호있는 정수 (예 : &lt;code&gt;Int&lt;/code&gt; )는 &lt;code&gt;abs(typemin(Int))&lt;/code&gt; 나타낼 수 없으므로 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28790cf90cf177147936302a9d1094b853b086f9" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;cld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;cld(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="4c05dcdfe5d48ed5364bba76a8d88216a7900800" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;div(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;div(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="a3d2d9753cdcfd6dd922be36bbcacaaf32453196" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;fld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;fld(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="2c843612cbe327e35009726e8d036ba9b466e318" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;mod(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;mod(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="3ff6965bc32424b3a4e9ae967a2b78b31c8687be" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x*y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x*y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="31af4e89c705ea1b47696c4b34bfb97a778c9f15" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x+y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x+y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="fd998eb3f6f3e0335eab6ff45b9ad97358dd0ca0" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x-y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x-y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="efdf3f45f374c38b59fd728eaad712d7890f84ff" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x%y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x%y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="08676bba541f171d54d453c583476f048c4309ad" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x*y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x*y&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="dd10e9d48c83e327a775e0dc3fbaa5b8a6d8c773" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x+y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x+y&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="7bc22057d7126532dbb6ba4068b470e14e78325a" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x-y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x-y&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="aba6566e0673d1e53c249760fa025027d921398e" translate="yes" xml:space="preserve">
          <source>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in &lt;code&gt;Y&lt;/code&gt;, overwriting the existing value of &lt;code&gt;Y&lt;/code&gt;. Note that &lt;code&gt;Y&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">행렬의 행렬 또는 벡터 행렬 AB 제품 $ $ 저장 결과를 계산 &lt;code&gt;Y&lt;/code&gt; 의 기존 값 겹쳐 &lt;code&gt;Y&lt;/code&gt; 를 . 참고 &lt;code&gt;Y&lt;/code&gt; 가 하나에 별명해서는 안 또는 &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="4ba307e0d2e402f172b3a88156165205934537c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;calloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;calloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="56834381560a3dd99cb2329bb238ba01df160757" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;a href=&quot;#Base.Libc.malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, not on pointers retrieved from other C libraries. &lt;a href=&quot;../c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd40525129514b0914afc63feb30f354e65a4d9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;code&gt;malloc&lt;/code&gt;, not on pointers retrieved from other C libraries. &lt;code&gt;Ptr&lt;/code&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;free&lt;/code&gt; 로 전화하십시오 . 다른 C 라이브러리에서 검색 한 포인터가 아니라 &lt;code&gt;malloc&lt;/code&gt; 에서 얻은 메모리에서만 이것을 사용하십시오 . 시스템에 여러 &lt;code&gt;libc&lt;/code&gt; 라이브러리가있는 경우 어설 션 오류를 피하려면 C 라이브러리에서 얻은 &lt;code&gt;Ptr&lt;/code&gt; 오브젝트를 해당 라이브러리에 정의 된 자유 함수로 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9203b7a42060148350d2e8b3d4cff8d77d5adeaf" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;malloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;malloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d59c9f90d0e1176d4cad8b98ecd8773005b655fb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;realloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;realloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="04826291b163107f55d0704047219ec8c7242923" translate="yes" xml:space="preserve">
          <source>Call C functions directly (no wrappers or special APIs needed)</source>
          <target state="translated">C 함수를 직접 호출 (래퍼 또는 특수 API 필요 없음)</target>
        </trans-unit>
        <trans-unit id="176405e1dde8747bb226b06f36937d8d5df0ebaf" translate="yes" xml:space="preserve">
          <source>Call LLVM IR string in the first argument. Similar to an LLVM function &lt;code&gt;define&lt;/code&gt; block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</source>
          <target state="translated">첫 번째 인수에서 LLVM IR 문자열을 호출하십시오. LLVM 함수 &lt;code&gt;define&lt;/code&gt; 블록과 유사하게 인수는 이름없는 연속적인 SSA 변수 (% 0, % 1 등)로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801735440ba4554b8dcf3670b61d4a15d05b05d1" translate="yes" xml:space="preserve">
          <source>Call a function &lt;code&gt;f&lt;/code&gt; asynchronously on the given arguments on the specified process. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">지정된 프로세스에서 주어진 인수에 대해 함수 &lt;code&gt;f&lt;/code&gt; 를 비동기 적으로 호출합니다 . &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 돌려 줍니다. 키워드 인수가 있으면 &lt;code&gt;f&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="e66b49e037c9bfd84faa519573d27e88a8767628" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by &lt;code&gt;library.function_name&lt;/code&gt;, where &lt;code&gt;library&lt;/code&gt; is a string constant or literal. The library may be omitted, in which case the &lt;code&gt;function_name&lt;/code&gt; is resolved in the current process. Alternatively, &lt;code&gt;@ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;$function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a025fbe4a998cb1c2319eebb3e04b735a78fa3" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by the tuple &lt;code&gt;(function_name, library)&lt;/code&gt;, where each component is either a string or symbol. Instead of specifying a library, one can also use a &lt;code&gt;function_name&lt;/code&gt; symbol or string, which is resolved in the current process. Alternatively, &lt;code&gt;ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;(function_name, library)&lt;/code&gt; 지정된 C 내보내기 공유 라이브러리에서 함수를 호출하십시오. 여기서 각 구성 요소는 문자열 또는 기호입니다. 라이브러리를 지정하는 대신 현재 프로세스에서 해결되는 &lt;code&gt;function_name&lt;/code&gt; 기호 또는 문자열을 사용할 수도 있습니다 . 또는 &lt;code&gt;ccall&lt;/code&gt; 을 사용하여 &lt;code&gt;dlsym&lt;/code&gt; 에 의해 리턴 된 함수 포인터 &lt;code&gt;function_pointer&lt;/code&gt; 를 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d59f24dd0afcb729960eb267538b17e7042fcc85" translate="yes" xml:space="preserve">
          <source>Call function &lt;code&gt;f&lt;/code&gt; on each element of iterable &lt;code&gt;c&lt;/code&gt;. For multiple iterable arguments, &lt;code&gt;f&lt;/code&gt; is called elementwise. &lt;code&gt;foreach&lt;/code&gt; should be used instead of &lt;code&gt;map&lt;/code&gt; when the results of &lt;code&gt;f&lt;/code&gt; are not needed, for example in &lt;code&gt;foreach(println, array)&lt;/code&gt;.</source>
          <target state="translated">반복 가능한 &lt;code&gt;c&lt;/code&gt; 의 각 요소에서 함수 &lt;code&gt;f&lt;/code&gt; 를 호출하십시오 . 반복 가능한 여러 인수의 경우 &lt;code&gt;f&lt;/code&gt; 를 요소 단위라고합니다. &lt;code&gt;foreach&lt;/code&gt; 는이 대신 사용되어야 &lt;code&gt;map&lt;/code&gt; 결과 때 &lt;code&gt;f&lt;/code&gt; 필요하지 않은, 예를 들어, &lt;code&gt;foreach(println, array)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb83c3d13bcfdfda803f0b35d77b6d7243cd9fe" translate="yes" xml:space="preserve">
          <source>Call the Win32 &lt;code&gt;GetLastError&lt;/code&gt; function [only available on Windows].</source>
          <target state="translated">Win32 &lt;code&gt;GetLastError&lt;/code&gt; 함수를 호출하십시오 ( Windows에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="ce4eab5c7f440edfe5b683c8baa8b023cc553366" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;body&lt;/code&gt; with a modified task-local storage, in which &lt;code&gt;value&lt;/code&gt; is assigned to &lt;code&gt;key&lt;/code&gt;; the previous value of &lt;code&gt;key&lt;/code&gt;, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 이 할당 된 수정 된 태스크 로컬 스토리지를 사용 하여 함수 &lt;code&gt;body&lt;/code&gt; 을 호출하십시오 . &lt;code&gt;key&lt;/code&gt; 의 이전 값 또는 그 부족은 나중에 복원됩니다. 동적 범위를 모방하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eaa0c352f0575f82994206173cabc3866ad95796" translate="yes" xml:space="preserve">
          <source>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. &lt;code&gt;context&lt;/code&gt; can be either an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; whose properties will be used, or a &lt;code&gt;Pair&lt;/code&gt; specifying a property and its value. &lt;code&gt;sizehint&lt;/code&gt; suggests the capacity of the buffer (in bytes).</source>
          <target state="translated">I / O 스트림과 제공된 추가 인수를 사용하여 지정된 함수를 호출하십시오. 이 I / O 스트림에 쓰여진 모든 것은 문자열로 반환됩니다. &lt;code&gt;context&lt;/code&gt; 는 속성이 사용될 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 이거나 속성과 해당 값을 지정하는 &lt;code&gt;Pair&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;sizehint&lt;/code&gt; 는 버퍼 용량 (바이트)을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="2664dee6a3ad5a12623406c5af1cda40ecf12ba0" translate="yes" xml:space="preserve">
          <source>Callback settings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt;&lt;code&gt;git_remote_callbacks&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">콜백 설정. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt; &lt;code&gt;git_remote_callbacks&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c8256faf5b345c67f126415204dbd66a186005c2" translate="yes" xml:space="preserve">
          <source>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; has the effect of initializing a process as a worker using TCP/IP sockets for transport. &lt;code&gt;cookie&lt;/code&gt; is a &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt;&lt;code&gt;cluster_cookie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 지정 전송을 구현하는 클러스터 관리자가 호출합니다. 새로 시작된 프로세스를 작업자로 초기화합니다. 명령 행 인수 &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; 는 전송에 TCP / IP 소켓을 사용하여 작업자로서 프로세스를 초기화하는 효과가 있습니다. &lt;code&gt;cookie&lt;/code&gt; 는 &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt; &lt;code&gt;cluster_cookie&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="caea39a5ffed5cf53b4f9992aa9aebdfdb841ef9" translate="yes" xml:space="preserve">
          <source>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two &lt;code&gt;IO&lt;/code&gt; objects, one for incoming messages and the other for messages addressed to the remote worker. If &lt;code&gt;incoming&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</source>
          <target state="translated">사용자 지정 전송을 사용하여 클러스터 관리자가 호출합니다. 사용자 정의 전송 구현이 원격 작업자로부터 첫 번째 메시지를 수신 할 때 호출되어야합니다. 사용자 지정 전송은 원격 작업자에 대한 논리적 연결을 관리하고 하나는 들어오는 메시지와 다른 하나는 원격 작업자로 주소 지정된 메시지에 대한 두 개의 &lt;code&gt;IO&lt;/code&gt; 개체를 제공 해야합니다. 경우 &lt;code&gt;incoming&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 원격 피어가 연결을 시작했다. 쌍을 시작하면 연결이 클러스터 쿠키와 해당 Julia 버전 번호를 전송하여 인증 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66dd1be7576a64af07b2ce99b1a2ed2a7c06b791" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#Core.Ref&quot;&gt;&lt;code&gt;Ref(array[, index])&lt;/code&gt;&lt;/a&gt; is generally preferable to this function as it guarantees validity.</source>
          <target state="translated">&lt;a href=&quot;#Core.Ref&quot;&gt; &lt;code&gt;Ref(array[, index])&lt;/code&gt; &lt;/a&gt; 호출 은 일반적으로 유효성을 보장하므로이 함수보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="0d16198678162c2927c2f17ed3e602251edd7089" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</source>
          <target state="translated">매크로 안에서 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 을&lt;/a&gt; 호출 하는 것은 특히 위험한 경고 신호입니다. 매크로가 최상위 수준에서 호출 될 때만 작동한다는 것을 의미합니다. 이러한 매크로가 대신 함수로 작성되면 필요한 런타임 값에 자연스럽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b72748e09098c6bd97f55e59c563c3a122bb6331" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</source>
          <target state="translated">다른 모듈에서 부작용을 일으키기 위해 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 호출 합니다. 또한 증분 프리 컴파일 플래그가 설정 될 때 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41aa7e1fcfd92670fa5a846085d3341583baabcf" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s. For ease of use, the alias &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt;&lt;code&gt;StackTraces.StackTrace&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;code&gt;Vector{StackFrame}&lt;/code&gt;. (Examples with &lt;code&gt;[...]&lt;/code&gt; indicate that output may vary depending on how the code is run.)</source>
          <target state="translated">&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; 호출 하면 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; 의 벡터가 반환 됩니다. 사용하기 쉽도록 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 대신 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt; &lt;code&gt;StackTraces.StackTrace&lt;/code&gt; &lt;/a&gt; 라는 별칭을 사용할 수 있습니다 . ( &lt;code&gt;[...]&lt;/code&gt; 로 표시된 예 는 코드 실행 방법에 따라 출력이 달라질 수 있음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="4a4f549c9307f9b4d84be21408b77dbb68a1f198" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;rand&lt;/code&gt; and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt;&lt;code&gt;MersenneTwister&lt;/code&gt;&lt;/a&gt; (or other pseudorandom number generator) and pass it to the functions you are doctesting.</source>
          <target state="translated">호출 &lt;code&gt;rand&lt;/code&gt; 서로 다른 줄리아 세션 동안 일관성있는 출력을 생성하지 않으므로 다른 RNG 관련 기능은 doctest를 피해야한다. 임의의 난수 생성 관련 기능을 표시하려는 경우 한 가지 옵션은 자신의 &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt; &lt;code&gt;MersenneTwister&lt;/code&gt; &lt;/a&gt; (또는 다른 의사 난수 생성기) 를 명시 적으로 구성하고 시드하여 문서화중인 함수에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d7425b9bc6bdd37cfb5d8f6425582078c2424c2" translate="yes" xml:space="preserve">
          <source>Calling C and Fortran Code</source>
          <target state="translated">C와 포트란 코드 호출</target>
        </trans-unit>
        <trans-unit id="0a72734e5b9d7e776161f32d3bf09af339418e1e" translate="yes" xml:space="preserve">
          <source>Calling Convention</source>
          <target state="translated">전화 컨벤션</target>
        </trans-unit>
        <trans-unit id="9abfa6ddb5caaadbeab0376e3006f230505bfdea" translate="yes" xml:space="preserve">
          <source>Calling Julia Functions</source>
          <target state="translated">Julia 함수 호출</target>
        </trans-unit>
        <trans-unit id="85116a89bb1c5c01cfc46fa63875b231c5d2c577" translate="yes" xml:space="preserve">
          <source>Calling a method of a class in Python (&lt;code&gt;a = MyClass(x), x.func(y)&lt;/code&gt;) corresponds to a function call in Julia, e.g. &lt;code&gt;a = MyStruct(x), func(x::MyStruct, y)&lt;/code&gt;. In general, multiple dispatch is more flexible and powerful than the Python class system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49d09ca1110825e69afa568f7e07eeec5300e61" translate="yes" xml:space="preserve">
          <source>Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</source>
          <target state="translated">생성 된 함수의 본문 다음에 정의 된 함수를 호출합니다. 이 조건은 증분로드 된 사전 컴파일 된 모듈에서 완화되어 모듈의 모든 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41d74c50b2c67c3ddc7b0e22937873f076e4b22e" translate="yes" xml:space="preserve">
          <source>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</source>
          <target state="translated">이 함수를 호출하는 것은 선형 인덱싱을 이용하는 알고리즘을 작성하는 &quot;안전한&quot;방법입니다.</target>
        </trans-unit>
        <trans-unit id="0a19b7e26b2ba75ac27255f31f21e98a34d62953" translate="yes" xml:space="preserve">
          <source>Calls</source>
          <target state="translated">Calls</target>
        </trans-unit>
        <trans-unit id="19d45b5117925d478df6d24e3b83936bcd7c78e0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;f(args...; kwargs...)&lt;/code&gt;, but guarantees that the most recent method of &lt;code&gt;f&lt;/code&gt; will be executed. This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function &lt;code&gt;f&lt;/code&gt;. (The drawback is that &lt;code&gt;invokelatest&lt;/code&gt; is somewhat slower than calling &lt;code&gt;f&lt;/code&gt; directly, and the type of the result cannot be inferred by the compiler.)</source>
          <target state="translated">&lt;code&gt;f(args...; kwargs...)&lt;/code&gt; 호출 하지만 가장 최근 &lt;code&gt;f&lt;/code&gt; 메소드 가 실행되도록합니다. 이는 오래된 버전의 함수 &lt;code&gt;f&lt;/code&gt; 를 호출 할 수있는 장기 실행 이벤트 루프 또는 콜백 함수와 같은 특수한 환경에서 유용합니다 . 단점은 &lt;code&gt;invokelatest&lt;/code&gt; 가 &lt;code&gt;f&lt;/code&gt; 를 직접 호출하는 것보다 다소 느리고 결과 유형이 컴파일러에 의해 유추 될 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="f01f585ee537bca9460fb6cd89d91523ae410c34" translate="yes" xml:space="preserve">
          <source>Can I use &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; inside a function?</source>
          <target state="translated">함수 내에서 &lt;code&gt;using&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="07d6cb97820e052be2b530d0dd83bba8edfc5e64" translate="yes" xml:space="preserve">
          <source>Cancer</source>
          <target state="translated">Cancer</target>
        </trans-unit>
        <trans-unit id="dbffdf1f157a14a19d2c2aeb64068a16056948d8" translate="yes" xml:space="preserve">
          <source>Candy</source>
          <target state="translated">Candy</target>
        </trans-unit>
        <trans-unit id="f20a12fff18e89250e7a4fc78447ee7170895a65" translate="yes" xml:space="preserve">
          <source>Cannot exactly convert &lt;code&gt;val&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt; in a method of function &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;name&lt;/code&gt; 의 메소드에서 &lt;code&gt;val&lt;/code&gt; 을 유형 &lt;code&gt;T&lt;/code&gt; 로 정확하게 변환 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91fe73e52f951e9f466713424d00ece47cdc7524" translate="yes" xml:space="preserve">
          <source>Canonicalize a path by expanding symbolic links and removing &quot;.&quot; and &quot;..&quot; entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.</source>
          <target state="translated">심볼릭 링크를 확장하고 &quot;.&quot;를 제거하여 경로를 표준화하십시오. 및 &quot;..&quot;항목. 대소 문자를 구분하지 않는 대소 문자를 유지하는 파일 시스템 (일반적으로 Mac 및 Windows)에서 파일 시스템의 경로에 대해 저장된 대소 문자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="90a16c05e849a5af3a6ddd19c2db0fa10e54dd2d" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of each word in &lt;code&gt;s&lt;/code&gt;; if &lt;code&gt;strict&lt;/code&gt; is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the &lt;code&gt;wordsep&lt;/code&gt; keyword to determine which characters should be considered as word separators. See also &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt;&lt;code&gt;uppercasefirst&lt;/code&gt;&lt;/a&gt; to capitalize only the first character in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에서 각 단어의 첫 문자를 대문자로 사용하십시오 . 경우 &lt;code&gt;strict&lt;/code&gt; 사실이다, 다른 모든 문자는 그렇지 않으면 변경되지 않고 남아 있습니다, 소문자로 변환됩니다. 기본적으로 모든 비 레터는 단어 구분자로 간주됩니다. 술어를 &lt;code&gt;wordsep&lt;/code&gt; 키워드로 전달 하여 단어 분리 자로 간주 할 문자를 결정할 수 있습니다. &lt;code&gt;s&lt;/code&gt; 의 첫 문자 만 &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt; &lt;code&gt;uppercasefirst&lt;/code&gt; &lt;/a&gt; 하려면 대문자 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9bf29452874274eefd7cb3833b9f64b68215e7a" translate="yes" xml:space="preserve">
          <source>Capricorn</source>
          <target state="translated">Capricorn</target>
        </trans-unit>
        <trans-unit id="7a60d3a75036d27b63be0e55a67bb26ec4e25de4" translate="yes" xml:space="preserve">
          <source>Captures can also be accessed by indexing the &lt;code&gt;RegexMatch&lt;/code&gt; object with the number or name of the capture group:</source>
          <target state="translated">캡처 그룹의 번호 또는 이름으로 &lt;code&gt;RegexMatch&lt;/code&gt; 개체를 색인화하여 캡처에 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88b6c532d029fa2352cf701d32470679db245f1e" translate="yes" xml:space="preserve">
          <source>Captures can be referenced in a substitution string when using &lt;code&gt;replace&lt;/code&gt; by using &lt;code&gt;\n&lt;/code&gt; to refer to the nth capture group and prefixing the substitution string with &lt;code&gt;s&lt;/code&gt;. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 을 사용하여 n 번째 캡처 그룹을 참조하고 대체 문자열 앞에 &lt;code&gt;s&lt;/code&gt; 를 붙여서 &lt;code&gt;replace&lt;/code&gt; 를 사용할 때 대체 문자열에서 캡처를 참조 할 수 있습니다 . 캡처 그룹 0은 전체 일치 오브젝트를 나타냅니다. 명명 된 캡처 그룹은 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 대체하여 참조 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2a9f7332f7a09946296f88c18131b92dbb1279f" translate="yes" xml:space="preserve">
          <source>Card Index</source>
          <target state="translated">카드 인덱스</target>
        </trans-unit>
        <trans-unit id="0cca55f8e3afeb49c40b1e95517a9c1135c7a560" translate="yes" xml:space="preserve">
          <source>Carousel Horse</source>
          <target state="translated">회전 목마</target>
        </trans-unit>
        <trans-unit id="255e5aac2127bb14392d1d0c859050548a802598" translate="yes" xml:space="preserve">
          <source>Carp Streamer</source>
          <target state="translated">잉어 깃발</target>
        </trans-unit>
        <trans-unit id="722d5852eba2640d07e63d26f677b7d3dce6d40c" translate="yes" xml:space="preserve">
          <source>Cartesian indexing</source>
          <target state="translated">데카르트 인덱싱</target>
        </trans-unit>
        <trans-unit id="2a2b1fd0558d005d15bb6a090f84de302c0d4517" translate="yes" xml:space="preserve">
          <source>Cartesian indices</source>
          <target state="translated">데카르트 인덱스</target>
        </trans-unit>
        <trans-unit id="2111431e539d8078cb148dae299ad435bcf94b27" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f1c61da11e76b12eda645d65ffd7fe29682099" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 0&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a059f07d864d6895c8f26aada84e3e2ae48daa" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 1&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n == 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5a951eefa4da8021cf83c2a312ac9db2161e292" translate="yes" xml:space="preserve">
          <source>Case Study: Rational</source>
          <target state="translated">사례 연구 : 합리적인</target>
        </trans-unit>
        <trans-unit id="226c8be8625b7e7ff2acf9e7afa1f2c1a67ee20d" translate="yes" xml:space="preserve">
          <source>Case Study: Rational Promotions</source>
          <target state="translated">사례 연구 : 합리적인 프로모션</target>
        </trans-unit>
        <trans-unit id="cebe54c7626cb1cefaca5f7f5ea6c96b4a7a2882" translate="yes" xml:space="preserve">
          <source>Cat</source>
          <target state="translated">Cat</target>
        </trans-unit>
        <trans-unit id="e321d6511fec0b2a4b2f0a4b6c9161ea67d3b862" translate="yes" xml:space="preserve">
          <source>Cat Face</source>
          <target state="translated">고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="0304d8e66e7196a0cbe56d1a1e3f50a5d44586dc" translate="yes" xml:space="preserve">
          <source>Cat Face With Tears Of Joy</source>
          <target state="translated">기쁨의 눈물을 가진 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="8694b8421f68b951f951f9af799f80af5160aedd" translate="yes" xml:space="preserve">
          <source>Cat Face With Wry Smile</source>
          <target state="translated">지친 미소로 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="34dfec8f22dde17704da94df2192063529be5d2d" translate="yes" xml:space="preserve">
          <source>Catalan's constant.</source>
          <target state="translated">카탈로니아 어 상수.</target>
        </trans-unit>
        <trans-unit id="b8c6b9519d52cad00665d92e155963171c5e725d" translate="yes" xml:space="preserve">
          <source>Catch exceptions during event evaluation</source>
          <target state="translated">이벤트 평가 중 예외 포착</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="1a80861772b0484c4f5af5303cebead59df45b86" translate="yes" xml:space="preserve">
          <source>Caution Sign</source>
          <target state="translated">주의 표시</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="e4c530b1c24d3c230e2d840c8f5a4bd61e8f0170" translate="yes" xml:space="preserve">
          <source>Cchar</source>
          <target state="translated">Cchar</target>
        </trans-unit>
        <trans-unit id="98ea122cbe5434a5105ed227191d1c86da875820" translate="yes" xml:space="preserve">
          <source>Cdouble</source>
          <target state="translated">Cdouble</target>
        </trans-unit>
        <trans-unit id="ef6d3da178771ba00eefbc1133066d5d42ce7c22" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. The constructs introducing scope blocks are:</source>
          <target state="translated">언어의 특정 구문 은 일부 변수 세트의 범위에 해당하는 코드 영역 인 &lt;em&gt;범위 블록을&lt;/em&gt; 도입 합니다. 변수의 범위는 임의의 소스 행 세트가 될 수 없습니다. 대신 항상이 블록 중 하나와 정렬됩니다. Julia에는 &lt;em&gt;전역 범위&lt;/em&gt; 와 &lt;em&gt;로컬 범위&lt;/em&gt; 의 두 가지 주요 &lt;em&gt;범위가&lt;/em&gt; 있습니다. 후자는 중첩 될 수 있습니다. 범위 블록을 도입하는 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79d6412ea668dd527aa9bd5226b88db41d88b00b" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. There is also a distinction in Julia between constructs which introduce a &quot;hard scope&quot; and those which only introduce a &quot;soft scope&quot;, which affects whether shadowing a global variable by the same name is allowed or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a436f524b4f30d26cce25c6fb61307697fefc2aa" translate="yes" xml:space="preserve">
          <source>Certain operations make mathematical sense but result in errors:</source>
          <target state="translated">특정 연산은 수학적으로 이해되지만 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b83c053cc3abf67280351793fa40fe0857a1ef12" translate="yes" xml:space="preserve">
          <source>Cfloat</source>
          <target state="translated">Cfloat</target>
        </trans-unit>
        <trans-unit id="1bf8d41c6633f510ee163ba63fad81c499b65c06" translate="yes" xml:space="preserve">
          <source>Chaining comparisons</source>
          <target state="translated">체인 비교</target>
        </trans-unit>
        <trans-unit id="e4b02f736800960ffeb31d1ce4d94bc68e9b3522" translate="yes" xml:space="preserve">
          <source>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator for scalar comparisons, and the &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; operator for elementwise comparisons, which allows them to work on arrays. For example, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; gives a boolean array whose entries are true where the corresponding elements of &lt;code&gt;A&lt;/code&gt; are between 0 and 1.</source>
          <target state="translated">연쇄 비교는 종종 숫자 코드에서 매우 편리합니다. 연쇄 비교 는 스칼라 비교에 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하고 요소 별 비교에 &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 배열에서 작업 할 수 있도록합니다. 예를 들어, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 해당 요소가 0과 1 사이에 있는 항목이 참인 부울 배열을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e392d2ea4fb56f31affc92a17a7f093445989a1e" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;T&lt;/code&gt; arithmetic precision (in bits) for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 기간 동안 &lt;code&gt;T&lt;/code&gt; 산술 정밀도 (비트)를 변경하십시오 . 논리적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa7aae11d28e8bd4a1ac0973becf0187af2f72ff" translate="yes" xml:space="preserve">
          <source>Change the next word to lowercase</source>
          <target state="translated">다음 단어를 소문자로 변경</target>
        </trans-unit>
        <trans-unit id="a9d00290564b5f132466d2d65a5760e410b77379" translate="yes" xml:space="preserve">
          <source>Change the next word to titlecase</source>
          <target state="translated">다음 단어를 titlecase로 변경</target>
        </trans-unit>
        <trans-unit id="a1848e10eea50d9a7d51e412b6c651b68fe304e4" translate="yes" xml:space="preserve">
          <source>Change the next word to uppercase</source>
          <target state="translated">다음 단어를 대문자로 변경</target>
        </trans-unit>
        <trans-unit id="52116f45eb7f0166da051d04ad38b63f5e208b1f" translate="yes" xml:space="preserve">
          <source>Change the owner and/or group of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;owner&lt;/code&gt; and/or &lt;code&gt;group&lt;/code&gt;. If the value entered for &lt;code&gt;owner&lt;/code&gt; or &lt;code&gt;group&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; the corresponding ID will not change. Only integer &lt;code&gt;owner&lt;/code&gt;s and &lt;code&gt;group&lt;/code&gt;s are currently supported. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">의 소유자 및 / 또는 그룹 변경 &lt;code&gt;path&lt;/code&gt; 에 &lt;code&gt;owner&lt;/code&gt; 및 / 또는 &lt;code&gt;group&lt;/code&gt; . &lt;code&gt;owner&lt;/code&gt; 또는 &lt;code&gt;group&lt;/code&gt; 입력 한 값 이 &lt;code&gt;-1&lt;/code&gt; 이면 해당 ID가 변경되지 않습니다. 정수 &lt;code&gt;owner&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 만 현재 지원됩니다. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b4cadce06d0cab691571969b2bd50452957441f5" translate="yes" xml:space="preserve">
          <source>Change the permissions mode of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;mode&lt;/code&gt;. Only integer &lt;code&gt;mode&lt;/code&gt;s (e.g. &lt;code&gt;0o777&lt;/code&gt;) are currently supported. If &lt;code&gt;recursive=true&lt;/code&gt; and the path is a directory all permissions in that directory will be recursively changed. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">의 권한 모드 변경 &lt;code&gt;path&lt;/code&gt; 로 &lt;code&gt;mode&lt;/code&gt; . 정수 &lt;code&gt;mode&lt;/code&gt; (예 : &lt;code&gt;0o777&lt;/code&gt; ) 만 현재 지원됩니다. 경우 &lt;code&gt;recursive=true&lt;/code&gt; 과 경로가 디렉토리 디렉토리에있는 모든 권한을 반복적으로 변경됩니다. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="32a989fb98b8f1dbfc4dbfdbda4cfa7a8f5a564e" translate="yes" xml:space="preserve">
          <source>Change the rounding mode of floating point type &lt;code&gt;T&lt;/code&gt; for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 기간 동안 부동 소수점 유형 &lt;code&gt;T&lt;/code&gt; 의 반올림 모드를 변경하십시오 . 논리적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6826b0c27162177562d5dac46bf63880b08e8521" translate="yes" xml:space="preserve">
          <source>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; interprets the 4 bytes corresponding to &lt;code&gt;UInt32(7)&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 블록의 유형 해석을 변경하십시오. 배열의 경우, 지정된 배열과 동일한 이진 데이터를 사용하지만 지정된 요소 유형을 가진 배열의보기를 구성합니다. 예를 들어, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; 는 &lt;code&gt;UInt32(7)&lt;/code&gt; 해당하는 4 바이트를 &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="d4eec72c597c649417c08cf8310c3fd12582209e" translate="yes" xml:space="preserve">
          <source>Change to the first history entry (of the current session if it is before the current position in history)</source>
          <target state="translated">첫 번째 히스토리 항목으로 변경 (현재 세션이 히스토리에서 현재 위치 이전 인 경우)</target>
        </trans-unit>
        <trans-unit id="2d9790ce2e89644c1d5ef1d4178a0e20ffa229c9" translate="yes" xml:space="preserve">
          <source>Change to the last history entry</source>
          <target state="translated">마지막 기록 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="f00c73a7c5134c054bca76810185e125c387bc0a" translate="yes" xml:space="preserve">
          <source>Change to the next history entry</source>
          <target state="translated">다음 이력 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="cfe48d07ba26c0afb2979f42a242b38ee82c88da" translate="yes" xml:space="preserve">
          <source>Change to the previous history entry</source>
          <target state="translated">이전 이력 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="879f0b1bef59eeebf78cfd3a22f6f8077810cecf" translate="yes" xml:space="preserve">
          <source>Channel</source>
          <target state="translated">Channel</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="5d2585d6b1ebe562ed90e098229697dd1edbced3" translate="yes" xml:space="preserve">
          <source>Channels and RemoteChannels</source>
          <target state="translated">채널 및 원격 채널</target>
        </trans-unit>
        <trans-unit id="5de527ad4b50c6e5971cd0c9d1c61d30dff8242c" translate="yes" xml:space="preserve">
          <source>Channels are created via the &lt;code&gt;Channel{T}(sz)&lt;/code&gt; constructor. The channel will only hold objects of type &lt;code&gt;T&lt;/code&gt;. If the type is not specified, the channel can hold objects of any type. &lt;code&gt;sz&lt;/code&gt; refers to the maximum number of elements that can be held in the channel at any time. For example, &lt;code&gt;Channel(32)&lt;/code&gt; creates a channel that can hold a maximum of 32 objects of any type. A &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; can hold up to 64 objects of &lt;code&gt;MyType&lt;/code&gt; at any time.</source>
          <target state="translated">채널은 &lt;code&gt;Channel{T}(sz)&lt;/code&gt; 생성자 를 통해 생성됩니다 . 채널은 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트 만 보유합니다 . 유형을 지정하지 않으면 채널은 모든 유형의 객체를 보유 할 수 있습니다. &lt;code&gt;sz&lt;/code&gt; 는 언제든지 채널에 보유 할 수있는 최대 요소 수를 나타냅니다. 예를 들어 &lt;code&gt;Channel(32)&lt;/code&gt; 은 모든 유형의 최대 32 개의 객체를 보유 할 수있는 채널을 만듭니다. &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; 의 64 개체를 보유 할 수 있습니다 &lt;code&gt;MyType&lt;/code&gt; 언제든지.</target>
        </trans-unit>
        <trans-unit id="f0af2b3f98cdd8293e5cd590c14f3ad654402a21" translate="yes" xml:space="preserve">
          <source>Character Tie</source>
          <target state="translated">캐릭터 타이</target>
        </trans-unit>
        <trans-unit id="ed74ee0fd869597bc8b7e61e821510ccb8a627ec" translate="yes" xml:space="preserve">
          <source>Character literals use the same behavior.</source>
          <target state="translated">문자 리터럴은 동일한 동작을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="af451d4e9c685856e4c14256f0f0685adcf83857" translate="yes" xml:space="preserve">
          <source>Character(s)</source>
          <target state="translated">Character(s)</target>
        </trans-unit>
        <trans-unit id="69803692f05446db28128e4d652fcda3604ec718" translate="yes" xml:space="preserve">
          <source>Characteristics:</source>
          <target state="translated">Characteristics:</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="d9a77eec8cc54d9b9059ecff9f7f8b0c3d4a4b0c" translate="yes" xml:space="preserve">
          <source>Characters not listed above are normally treated as delimiters between date and time slots. For example a &lt;code&gt;dt&lt;/code&gt; string of &quot;1996-01-15T00:00:00.0&quot; would have a &lt;code&gt;format&lt;/code&gt; string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</source>
          <target state="translated">위에 나열되지 않은 문자는 일반적으로 날짜와 시간 슬롯 사이의 구분 기호로 처리됩니다. 예를 들어 &quot;1996-01-15T00 : 00 : 00.0&quot; 의 &lt;code&gt;dt&lt;/code&gt; 문자열은 &quot;ym-dTH : M : Ss&quot;와 같은 &lt;code&gt;format&lt;/code&gt; 문자열을 갖습니다 . 코드 문자를 구분 기호로 사용해야하는 경우 백 슬래시를 사용하여 이스케이프 처리 할 수 ​​있습니다. 날짜 &quot;1995y01m&quot;의 형식은 &quot;y \ ym \ m&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ebef4e9d21d309d10e724345b9594679b3cd6e69" translate="yes" xml:space="preserve">
          <source>Chart With Downwards Trend</source>
          <target state="translated">하향 추세가있는 차트</target>
        </trans-unit>
        <trans-unit id="fda4f4461a399f03823d93f75ef10112a332c903" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend</source>
          <target state="translated">상승 추세가있는 차트</target>
        </trans-unit>
        <trans-unit id="a4a446b006052a5af669c7f6d998cf1743a7f6f9" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend And Yen Sign</source>
          <target state="translated">상승 추세와 엔 기호 차트</target>
        </trans-unit>
        <trans-unit id="73e89165960f554ff917c3b3ac9d3b096b8d5eaf" translate="yes" xml:space="preserve">
          <source>Check Mark</source>
          <target state="translated">체크 표시</target>
        </trans-unit>
        <trans-unit id="6af7b65d95d1fd3d3c46eeef377ffa00fb6e86a4" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;ex&lt;/code&gt; is an expression with head &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cccac008dc853e30120df3e9a70c3898d9b2bee" translate="yes" xml:space="preserve">
          <source>Check if commit &lt;code&gt;id&lt;/code&gt; (which is a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) is in the repository.</source>
          <target state="translated">커밋 &lt;code&gt;id&lt;/code&gt; ( 문자열 형식 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; )가 저장소에 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="36465e7df054d1a8db11c41ceb01463ffd339488" translate="yes" xml:space="preserve">
          <source>Check if the current branch is an &quot;orphan&quot; branch, i.e. has no commits. The first commit to this branch will have no parents.</source>
          <target state="translated">현재 브랜치가 &quot;고아&quot;브랜치인지 확인하십시오. 즉 커밋이 없습니다. 이 지점에 대한 첫 번째 커밋에는 부모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b66e0b7684d9561bc0ff2976ce4bdbc130c0a5c9" translate="yes" xml:space="preserve">
          <source>Check if there have been any changes to tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">작업 트리 ( &lt;code&gt;cached=false&lt;/code&gt; 인 경우 ) 또는 색인 ( &lt;code&gt;cached=true&lt;/code&gt; 인 경우) 에 추적 된 파일이 변경되었는지 확인하십시오 . &lt;code&gt;pathspecs&lt;/code&gt; 는 diff 옵션의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="10941e2df89576fa668bf1f89fbe0ad9fb195edb" translate="yes" xml:space="preserve">
          <source>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</source>
          <target state="translated">행렬이 정사각형인지 확인한 다음 공통 차원을 반환합니다. 여러 인수의 경우 벡터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6861a1cca611ecd76d506c1580f9dd38e9dfec32" translate="yes" xml:space="preserve">
          <source>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</source>
          <target state="translated">호환성을 위해 두 개의 배열 모양을 확인하여 후행 싱글 톤 치수를 허용하고 더 많은 치수를 가진 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5847f57e4c8ac4313a08831cbbd9321dc7c8aa94" translate="yes" xml:space="preserve">
          <source>Check whether the &lt;code&gt;lock&lt;/code&gt; is held by any task/thread. This should not be used for synchronization (see instead &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">작업 / 스레드가 &lt;code&gt;lock&lt;/code&gt; 을 보유하고 있는지 확인하십시오 . 동기화에 사용해서는 안됩니다 (대신 &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="387def941a675fd43bb90cd2f103bc1835695e36" translate="yes" xml:space="preserve">
          <source>Checked.add_with_overflow()</source>
          <target state="translated">Checked.add_with_overflow()</target>
        </trans-unit>
        <trans-unit id="5861f86d2198b43b150ea6be20eecd4f4ca194fb" translate="yes" xml:space="preserve">
          <source>Checked.checked_abs()</source>
          <target state="translated">Checked.checked_abs()</target>
        </trans-unit>
        <trans-unit id="0e340663d314653dc7f7258455c8c64ec865a402" translate="yes" xml:space="preserve">
          <source>Checked.checked_add()</source>
          <target state="translated">Checked.checked_add()</target>
        </trans-unit>
        <trans-unit id="793b46bf345ea840a66fc3ce7be504df87f6aad8" translate="yes" xml:space="preserve">
          <source>Checked.checked_cld()</source>
          <target state="translated">Checked.checked_cld()</target>
        </trans-unit>
        <trans-unit id="cbb75d95e9a638cb0354f430f1c41528c16d5f1e" translate="yes" xml:space="preserve">
          <source>Checked.checked_div()</source>
          <target state="translated">Checked.checked_div()</target>
        </trans-unit>
        <trans-unit id="10f25d8f5722c731db35c0585785eb14e0947047" translate="yes" xml:space="preserve">
          <source>Checked.checked_fld()</source>
          <target state="translated">Checked.checked_fld()</target>
        </trans-unit>
        <trans-unit id="844d8f377decea211f1aa04e5b41ffd6aa8ec8aa" translate="yes" xml:space="preserve">
          <source>Checked.checked_mod()</source>
          <target state="translated">Checked.checked_mod()</target>
        </trans-unit>
        <trans-unit id="6e287962b9c64e9790cebd017023df56a743a004" translate="yes" xml:space="preserve">
          <source>Checked.checked_mul()</source>
          <target state="translated">Checked.checked_mul()</target>
        </trans-unit>
        <trans-unit id="8cddbe8ee88213cf9e9d56a609fa85a89e086da7" translate="yes" xml:space="preserve">
          <source>Checked.checked_neg()</source>
          <target state="translated">Checked.checked_neg()</target>
        </trans-unit>
        <trans-unit id="e44667638c3a1dc209bda165095e1d1cd133cc75" translate="yes" xml:space="preserve">
          <source>Checked.checked_rem()</source>
          <target state="translated">Checked.checked_rem()</target>
        </trans-unit>
        <trans-unit id="0088d172f06fff6ea323397de23669a32c31474b" translate="yes" xml:space="preserve">
          <source>Checked.checked_sub()</source>
          <target state="translated">Checked.checked_sub()</target>
        </trans-unit>
        <trans-unit id="ab7e607ffaab3ede22444bf0bafb0736dd5575b5" translate="yes" xml:space="preserve">
          <source>Checked.mul_with_overflow()</source>
          <target state="translated">Checked.mul_with_overflow()</target>
        </trans-unit>
        <trans-unit id="44a69fd61235a11b4b6edaa45c7d2594c6702f55" translate="yes" xml:space="preserve">
          <source>Checked.sub_with_overflow()</source>
          <target state="translated">Checked.sub_with_overflow()</target>
        </trans-unit>
        <trans-unit id="f66ee858da2bed315f19a0831545acdc098092b9" translate="yes" xml:space="preserve">
          <source>Checking for equality with a singleton</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099aaa95277770b044f9e7efabb37f097dce362a" translate="yes" xml:space="preserve">
          <source>Checkout a new git branch in the &lt;code&gt;repo&lt;/code&gt; repository. &lt;code&gt;commit&lt;/code&gt; is the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt;, in string form, which will be the start of the new branch. If &lt;code&gt;commit&lt;/code&gt; is an empty string, the current HEAD will be used.</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; 저장소 에서 새로운 자식 분기를 체크 아웃하십시오 . &lt;code&gt;commit&lt;/code&gt; 은 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 이며 문자열 형식으로 새 브랜치의 시작이됩니다. 경우 &lt;code&gt;commit&lt;/code&gt; 빈 문자열, 현재 HEAD가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a01db35293e447e7dfa93e429ed3057a3d6edb4e" translate="yes" xml:space="preserve">
          <source>Checks if there are any differences between the tree specified by &lt;code&gt;treeish&lt;/code&gt; and the tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">&lt;code&gt;treeish&lt;/code&gt; 에 의해 지정된 트리 와 작업 트리 ( &lt;code&gt;cached=false&lt;/code&gt; 인 경우 ) 또는 추적 된 파일 ( &lt;code&gt;cached=true&lt;/code&gt; 인 경우) 에서 추적 된 파일 간에 차이가 있는지 확인합니다 . &lt;code&gt;pathspecs&lt;/code&gt; 는 diff 옵션의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="80497c05495db1c1e51a0b937bd9ffa77fb142ff" translate="yes" xml:space="preserve">
          <source>Cheering Megaphone</source>
          <target state="translated">응원 메가폰</target>
        </trans-unit>
        <trans-unit id="e81bedf047792fbe90c699c0d92561bd6df81796" translate="yes" xml:space="preserve">
          <source>Chequered Flag</source>
          <target state="translated">바둑판 무늬 깃발</target>
        </trans-unit>
        <trans-unit id="78bc6d7859d13eaa4171edc4973a040f60c5efa2" translate="yes" xml:space="preserve">
          <source>Cherries</source>
          <target state="translated">Cherries</target>
        </trans-unit>
        <trans-unit id="d980b2a4bed67957e89a2bfcbf9122253661d3b9" translate="yes" xml:space="preserve">
          <source>Cherry Blossom</source>
          <target state="translated">벚꽃</target>
        </trans-unit>
        <trans-unit id="c712b8835755410091fbe89cfba2f9989bcdddf1" translate="yes" xml:space="preserve">
          <source>Chestnut</source>
          <target state="translated">Chestnut</target>
        </trans-unit>
        <trans-unit id="baaa18844b8db958c57edddf824f4a8b5cd9e298" translate="yes" xml:space="preserve">
          <source>Chicken</source>
          <target state="translated">Chicken</target>
        </trans-unit>
        <trans-unit id="6684f920ddf587816828d0949794d536f2044d85" translate="yes" xml:space="preserve">
          <source>Children Crossing</source>
          <target state="translated">어린이 건널목</target>
        </trans-unit>
        <trans-unit id="be60ee4f4851b8d244bba0827efe90ca53080f02" translate="yes" xml:space="preserve">
          <source>Chocolate Bar</source>
          <target state="translated">초콜릿 바</target>
        </trans-unit>
        <trans-unit id="36f117bd7dd482a1010ab9584c224f54936b91cc" translate="yes" xml:space="preserve">
          <source>Cholesky (see &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; 스키 ( cholesky 참조 )</target>
        </trans-unit>
        <trans-unit id="e3c96b15f464a32f9dbfcd9be5dcfbc00bda9510" translate="yes" xml:space="preserve">
          <source>Cholesky factorization</source>
          <target state="translated">hole 레 스키 분해</target>
        </trans-unit>
        <trans-unit id="da141a0edd85453be825d6aa02b625b2d8b12905" translate="yes" xml:space="preserve">
          <source>Christmas Tree</source>
          <target state="translated">크리스마스 트리</target>
        </trans-unit>
        <trans-unit id="e72e88ea6123b50e6208c2e997da2b67631286d6" translate="yes" xml:space="preserve">
          <source>Church</source>
          <target state="translated">Church</target>
        </trans-unit>
        <trans-unit id="f4ea571bfe0617f587935723651430356fc70f4c" translate="yes" xml:space="preserve">
          <source>Cinema</source>
          <target state="translated">Cinema</target>
        </trans-unit>
        <trans-unit id="20638d5f9a181ef513cf00b55dcce4c98adb55f7" translate="yes" xml:space="preserve">
          <source>Cint</source>
          <target state="translated">Cint</target>
        </trans-unit>
        <trans-unit id="810c53332cece6a0ba48a6c0ba3b4f10aa580f90" translate="yes" xml:space="preserve">
          <source>Cintmax_t</source>
          <target state="translated">Cintmax_t</target>
        </trans-unit>
        <trans-unit id="f012b4aef95600337cc3ea8a98c28a295ab93f2f" translate="yes" xml:space="preserve">
          <source>Circle With All But Upper Left Quadrant Black</source>
          <target state="translated">왼쪽 위 사분면 검정을 제외한 모든 원</target>
        </trans-unit>
        <trans-unit id="e64a2f1f5550310ac4fcf3d82a1eba3eb03373e3" translate="yes" xml:space="preserve">
          <source>Circle With Left Half Black</source>
          <target state="translated">왼쪽 반 검은 원</target>
        </trans-unit>
        <trans-unit id="4242c36ce736c0ae2d9e13bbac4c03ddccb00e63" translate="yes" xml:space="preserve">
          <source>Circle With Lower Half Black</source>
          <target state="translated">낮은 반 검은 원</target>
        </trans-unit>
        <trans-unit id="9946dda080b1d6f72432e4888afcc095dde79ea8" translate="yes" xml:space="preserve">
          <source>Circle With Right Half Black</source>
          <target state="translated">오른쪽 반 검은 원</target>
        </trans-unit>
        <trans-unit id="d869eafe06cb16bdb3bb0bc2e1be15db03901859" translate="yes" xml:space="preserve">
          <source>Circle With Upper Half Black</source>
          <target state="translated">상단 반 검은 원</target>
        </trans-unit>
        <trans-unit id="a8f7c61db4ce9bd030f686d3b28ef55edb06c05f" translate="yes" xml:space="preserve">
          <source>Circle With Upper Right Quadrant Black</source>
          <target state="translated">오른쪽 위 사분면 검정 원</target>
        </trans-unit>
        <trans-unit id="7ac2156e5b2912f2254d2f3ae90f1a8c149be7ab" translate="yes" xml:space="preserve">
          <source>Circle With Vertical Fill</source>
          <target state="translated">수직 채우기가있는 원</target>
        </trans-unit>
        <trans-unit id="bdade6bd883a792ea7c7650d2326b104f190c6db" translate="yes" xml:space="preserve">
          <source>Circled Anticlockwise-Rotated Division Sign</source>
          <target state="translated">반 시계 방향으로 회전 된 구간 표시</target>
        </trans-unit>
        <trans-unit id="288b0220ab4dfdbd33067b22c1e4248e5492c4f4" translate="yes" xml:space="preserve">
          <source>Circled Asterisk Operator</source>
          <target state="translated">동그라미 별표 연산자</target>
        </trans-unit>
        <trans-unit id="c23f14422e51f91da407f474f9afc3cc0d6b1a61" translate="yes" xml:space="preserve">
          <source>Circled Bullet</source>
          <target state="translated">동그라미 글 머리 기호</target>
        </trans-unit>
        <trans-unit id="317b273eb94a369a8c28e6bf5cd7c75c54af9e35" translate="yes" xml:space="preserve">
          <source>Circled Dash</source>
          <target state="translated">동그라미 대시</target>
        </trans-unit>
        <trans-unit id="f5d528c73ab76ab5f33f09420750954ff64b51f9" translate="yes" xml:space="preserve">
          <source>Circled Division Sign</source>
          <target state="translated">동그라미 사단 표시</target>
        </trans-unit>
        <trans-unit id="af5e4fc428d95afd21ff1ec53e8506a2bd73fb48" translate="yes" xml:space="preserve">
          <source>Circled Division Slash</source>
          <target state="translated">동그라미 구분 슬래시</target>
        </trans-unit>
        <trans-unit id="1540fdfaea096a26f649db63c8e3d97ec047096a" translate="yes" xml:space="preserve">
          <source>Circled Dot Operator</source>
          <target state="translated">원형 도트 연산자</target>
        </trans-unit>
        <trans-unit id="13716b865f5fa5c0c59b298bdb824a0403d1d0a8" translate="yes" xml:space="preserve">
          <source>Circled Equals</source>
          <target state="translated">동그라미 같음</target>
        </trans-unit>
        <trans-unit id="6fb20198e34869ba5357fb1484d789a4a9cf41a3" translate="yes" xml:space="preserve">
          <source>Circled Greater-Than</source>
          <target state="translated">동그라미 그레이터 탄</target>
        </trans-unit>
        <trans-unit id="768c6a3e34cf1fa1fe17c4122cd2eb756b5c8db1" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Accept</source>
          <target state="translated">동그라미 표시</target>
        </trans-unit>
        <trans-unit id="cd7d8396b4543ec8eac2c933faab0d381b5eddf4" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Advantage</source>
          <target state="translated">동그라미 표시가있는 이점</target>
        </trans-unit>
        <trans-unit id="68de940ba4435005de139e8e8a3c0d351749a305" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Congratulation</source>
          <target state="translated">Circled Ideograph 축하</target>
        </trans-unit>
        <trans-unit id="73f2e57c66e79ca73dc25a784afe3bf12db57991" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Secret</source>
          <target state="translated">동그라미 이데 오 그래프 비밀</target>
        </trans-unit>
        <trans-unit id="a40a39ec3a6682d21b6ef060b4feb0021bb56a91" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter M</source>
          <target state="translated">동그라미 라틴 대문자 M</target>
        </trans-unit>
        <trans-unit id="0737d90c41767eac9bb882a65f60e50a52a763a4" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter S</source>
          <target state="translated">동그라미 라틴 대문자 S</target>
        </trans-unit>
        <trans-unit id="3921273fcb7324637d2df323be0460e56b6c07e5" translate="yes" xml:space="preserve">
          <source>Circled Less-Than</source>
          <target state="translated">원이 적은 탄</target>
        </trans-unit>
        <trans-unit id="11ab89c625b1e2be31e3ce88e58467e9d8b591d3" translate="yes" xml:space="preserve">
          <source>Circled Minus</source>
          <target state="translated">동그라미 빼기</target>
        </trans-unit>
        <trans-unit id="49fb7ea6102e3ddbe3f49605b323255242257db1" translate="yes" xml:space="preserve">
          <source>Circled Multiplication Sign With Circumflex Accent</source>
          <target state="translated">곡절 악센트 원으로 곱셈 기호</target>
        </trans-unit>
        <trans-unit id="b54193aa1a494f0d833f0a8740fb732847cecb8a" translate="yes" xml:space="preserve">
          <source>Circled Parallel</source>
          <target state="translated">원형 평행</target>
        </trans-unit>
        <trans-unit id="8f99a8867a889f5ea35c2600d3c7f7047a7990e2" translate="yes" xml:space="preserve">
          <source>Circled Plus</source>
          <target state="translated">동그라미 플러스</target>
        </trans-unit>
        <trans-unit id="b2f2ab10cbdb08e806c050f7e4c9abf4807d102e" translate="yes" xml:space="preserve">
          <source>Circled Reverse Solidus</source>
          <target state="translated">원형 역 고 상선</target>
        </trans-unit>
        <trans-unit id="7a06e50e7385bdb39935cdfabe9072e82b9447d8" translate="yes" xml:space="preserve">
          <source>Circled Ring Operator</source>
          <target state="translated">원형 링 연산자</target>
        </trans-unit>
        <trans-unit id="3118f0f5bf53391e1d64d00f6fd9c8f83519338c" translate="yes" xml:space="preserve">
          <source>Circled Times</source>
          <target state="translated">동그라미 시간</target>
        </trans-unit>
        <trans-unit id="e0d7ab77f8105b38fa7df093b28a79c9646ca42a" translate="yes" xml:space="preserve">
          <source>Circled White Bullet</source>
          <target state="translated">동그라미 흰색 총알</target>
        </trans-unit>
        <trans-unit id="9d61e5de58e6dee3981e042fcf23eeed9646f7cf" translate="yes" xml:space="preserve">
          <source>Circled White Star</source>
          <target state="translated">동그라미 화이트 스타</target>
        </trans-unit>
        <trans-unit id="7748321d0967d869f81325b4585f9b2588000677" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in &lt;code&gt;src&lt;/code&gt;, storing the result in &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;shifts&lt;/code&gt; specifies the amount to shift in each dimension.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 데이터를 순환 적으로 이동, 즉 회전시켜 결과를 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다 . &lt;code&gt;shifts&lt;/code&gt; 는 각 차원에서 이동할 양을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d8d1450c5aa55fa70cdef969d2aed9b6bea5b253" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</source>
          <target state="translated">배열에서 데이터를 순환 적으로 이동, 즉 회전시킵니다. 두 번째 인수는 각 차원에서 이동할 양을 제공하는 튜플 또는 벡터이거나 첫 번째 차원에서만 이동할 정수입니다.</target>
        </trans-unit>
        <trans-unit id="a48e6cb43386bd05dea50af46a123ad0d776b80b" translate="yes" xml:space="preserve">
          <source>Circulation Function</source>
          <target state="translated">순환 기능</target>
        </trans-unit>
        <trans-unit id="37536a1d3cc9b23bf2b06cce0eca23c6a4e7e102" translate="yes" xml:space="preserve">
          <source>Circus Tent</source>
          <target state="translated">서커스 텐트</target>
        </trans-unit>
        <trans-unit id="2db191558345453d3d04631fffed018826e9442e" translate="yes" xml:space="preserve">
          <source>Cityscape At Dusk</source>
          <target state="translated">황혼에서 도시</target>
        </trans-unit>
        <trans-unit id="4010aa5c7daa771d33be51467b1f2b3303269a35" translate="yes" xml:space="preserve">
          <source>Clamp &lt;code&gt;x&lt;/code&gt; between &lt;code&gt;typemin(T)&lt;/code&gt; and &lt;code&gt;typemax(T)&lt;/code&gt; and convert the result to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11cf0a77f6ee3236fe15d4a64163013e4f57ac86" translate="yes" xml:space="preserve">
          <source>Clapper Board</source>
          <target state="translated">클래퍼 보드</target>
        </trans-unit>
        <trans-unit id="1a53c684edaeea21a3a7c9865bbc7c7a6b647d98" translate="yes" xml:space="preserve">
          <source>Clapping Hands Sign</source>
          <target state="translated">박수 손 기호</target>
        </trans-unit>
        <trans-unit id="516efc45347d5f1d25705370de6f7e8790454c94" translate="yes" xml:space="preserve">
          <source>Clear any existing backtraces from the internal buffer.</source>
          <target state="translated">내부 버퍼에서 기존 역 추적을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="82280dd39a2e304ec7a95875634d07334aea409a" translate="yes" xml:space="preserve">
          <source>Clear console screen</source>
          <target state="translated">콘솔 화면 지우기</target>
        </trans-unit>
        <trans-unit id="fb1b9ef26d7247fef7acad9f0bc4d393aa69d604" translate="yes" xml:space="preserve">
          <source>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</source>
          <target state="translated">분명히 이것은 수학 정수의 동작 방식과는 거리가 멀기 때문에 고급 프로그래밍 언어가 이것을 사용자에게 노출시키는 것이 이상적이지 않다고 생각할 수 있습니다. 그러나 효율성과 투명성이 중요한 수치 작업의 경우 대안이 더 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="ec4842b9335f240ce519c3e7eb35a6d7dd134038" translate="yes" xml:space="preserve">
          <source>Clears any stored memory allocation data when running julia with &lt;code&gt;--track-allocation&lt;/code&gt;. Execute the command(s) you want to test (to force JIT-compilation), then call &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;clear_malloc_data&lt;/code&gt;&lt;/a&gt;. Then execute your command(s) again, quit Julia, and examine the resulting &lt;code&gt;*.mem&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;--track-allocation&lt;/code&gt; 으로 julia를 실행할 때 저장된 메모리 할당 데이터를 지 웁니다 . 테스트하려는 명령을 실행하고 (JIT 컴파일을 강제 실행) &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;clear_malloc_data&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오 . 그런 다음 명령을 다시 실행하고 Julia를 종료하고 결과 &lt;code&gt;*.mem&lt;/code&gt; 파일을 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1508fb36867e2dc32f615b5c14b90813384914e" translate="yes" xml:space="preserve">
          <source>Clears global bindings in modules by initializing them to &lt;code&gt;nothing&lt;/code&gt;. &lt;code&gt;syms&lt;/code&gt; should be of type &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; or a collection of &lt;code&gt;Symbol&lt;/code&gt;s . &lt;code&gt;pids&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under &lt;code&gt;mod&lt;/code&gt; are cleared.</source>
          <target state="translated">모듈의 전역 바인딩을 &lt;code&gt;nothing&lt;/code&gt; 초기화 하지 않고 지 웁니다 . &lt;code&gt;syms&lt;/code&gt; 유형을 사용해야 &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 또는 모음 &lt;code&gt;Symbol&lt;/code&gt; 들. &lt;code&gt;pids&lt;/code&gt; 및 &lt;code&gt;mod&lt;/code&gt; 는 전역 변수를 다시 초기화 할 프로세스 및 모듈을 식별합니다. &lt;code&gt;mod&lt;/code&gt; 에서 정의 된 이름 만 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4a37999e16f7842ef3bf129008cd89f6cdc6cb0f" translate="yes" xml:space="preserve">
          <source>Clinking Beer Mugs</source>
          <target state="translated">만나요 맥주 머그잔</target>
        </trans-unit>
        <trans-unit id="5efe0c9323a499a8546aeac42d4b659bd2a4039f" translate="yes" xml:space="preserve">
          <source>Clipboard</source>
          <target state="translated">Clipboard</target>
        </trans-unit>
        <trans-unit id="80b2a110ce7d7c4741fab08718b7b0bad1a6e22a" translate="yes" xml:space="preserve">
          <source>Clock Face Eight Oclock</source>
          <target state="translated">시계 문자판 8시</target>
        </trans-unit>
        <trans-unit id="890e9e574fe3a811e9c99a391d98d07a63fc0336" translate="yes" xml:space="preserve">
          <source>Clock Face Eight-Thirty</source>
          <target state="translated">8시 30 분을 가리키는 시계</target>
        </trans-unit>
        <trans-unit id="a9b707e0c691e0552e2f8bc3916fe311413cb1c1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven Oclock</source>
          <target state="translated">시계 문자판 11시</target>
        </trans-unit>
        <trans-unit id="8ae5c10b2e512ab4d1e9f3ac4882a5accd7c7ae1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven-Thirty</source>
          <target state="translated">11시 30 분 시계 문자판</target>
        </trans-unit>
        <trans-unit id="e22dfa89a765cf1fb21d2f5d1bc38f3ade0afd76" translate="yes" xml:space="preserve">
          <source>Clock Face Five Oclock</source>
          <target state="translated">시계 문자판 5시</target>
        </trans-unit>
        <trans-unit id="3a7136e9fc05d844d8d22ef7e7a4065f750e1bbb" translate="yes" xml:space="preserve">
          <source>Clock Face Five-Thirty</source>
          <target state="translated">시계 문자판 5-30</target>
        </trans-unit>
        <trans-unit id="6c604425f0ef3b9a4e6a798a11e9cb980c5f5643" translate="yes" xml:space="preserve">
          <source>Clock Face Four Oclock</source>
          <target state="translated">시계 문자판 4시</target>
        </trans-unit>
        <trans-unit id="1d7bba61675982358fbf74be54ea171922d5d085" translate="yes" xml:space="preserve">
          <source>Clock Face Four-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="8effbf7e8f00a8276bde132d10680427c2d5ec2c" translate="yes" xml:space="preserve">
          <source>Clock Face Nine Oclock</source>
          <target state="translated">시계 얼굴 9시</target>
        </trans-unit>
        <trans-unit id="b0f219a4f731970988c8def9f6a9220234b63061" translate="yes" xml:space="preserve">
          <source>Clock Face Nine-Thirty</source>
          <target state="translated">시계 얼굴 아홉 서른</target>
        </trans-unit>
        <trans-unit id="2aa0624b2187d35a495fb74b7a70417ce4d8cdc6" translate="yes" xml:space="preserve">
          <source>Clock Face One Oclock</source>
          <target state="translated">시계 문자판 1시</target>
        </trans-unit>
        <trans-unit id="92624a0e738083d85292206e98f359ce3546ed05" translate="yes" xml:space="preserve">
          <source>Clock Face One-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="4ee4d2dec1cb5fcd6697bd397977fe18c3d4992c" translate="yes" xml:space="preserve">
          <source>Clock Face Seven Oclock</source>
          <target state="translated">시계 문자판 7시</target>
        </trans-unit>
        <trans-unit id="17aef1804b57cd3ede0fe80570334485de56eaea" translate="yes" xml:space="preserve">
          <source>Clock Face Seven-Thirty</source>
          <target state="translated">시계 문자판 세 번째</target>
        </trans-unit>
        <trans-unit id="f2ce5a71eefd68ceefa6e2f6811d47032f42f6eb" translate="yes" xml:space="preserve">
          <source>Clock Face Six Oclock</source>
          <target state="translated">시계 문자판 6시</target>
        </trans-unit>
        <trans-unit id="78a9100a5f02623dca735f3dacc48fead261c2cd" translate="yes" xml:space="preserve">
          <source>Clock Face Six-Thirty</source>
          <target state="translated">6시 문자반 시계</target>
        </trans-unit>
        <trans-unit id="29ed028a4b2d7ccf27a87e9aa08dd08fd6ebb1a6" translate="yes" xml:space="preserve">
          <source>Clock Face Ten Oclock</source>
          <target state="translated">시계 문자판 10시</target>
        </trans-unit>
        <trans-unit id="288b3a0678ebc38844da6df6f1e87880c74baafc" translate="yes" xml:space="preserve">
          <source>Clock Face Ten-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="bb465de467c2b010bb6b846eb78c2a1229522242" translate="yes" xml:space="preserve">
          <source>Clock Face Three Oclock</source>
          <target state="translated">시계 문자판 3시</target>
        </trans-unit>
        <trans-unit id="cfd958f3c422c51d841c78b6b7f3d9e44fc3ad75" translate="yes" xml:space="preserve">
          <source>Clock Face Three-Thirty</source>
          <target state="translated">3시 시계 얼굴</target>
        </trans-unit>
        <trans-unit id="7f669cae21a33d00c881936310a0c78e765a67d2" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve Oclock</source>
          <target state="translated">시계 문자판 12시</target>
        </trans-unit>
        <trans-unit id="1ef2e813447d172d893056c5340a57fc6839f314" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve-Thirty</source>
          <target state="translated">12시 30 분 시계 문자판</target>
        </trans-unit>
        <trans-unit id="4f6902106020e062d23dd43ecf72cd67020b6c3e" translate="yes" xml:space="preserve">
          <source>Clock Face Two Oclock</source>
          <target state="translated">시계 문자판 2시</target>
        </trans-unit>
        <trans-unit id="bcda9b95a7f9d026cc96f88e4ef6597b3948c3f5" translate="yes" xml:space="preserve">
          <source>Clock Face Two-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="3343394a9f3b65dd62d440bfd227fa40ca3918a2" translate="yes" xml:space="preserve">
          <source>Clockwise Contour Integral</source>
          <target state="translated">시계 방향 컨투어 일체형</target>
        </trans-unit>
        <trans-unit id="bef25f4fbfeb987aed2d95c207d8122fa87692e3" translate="yes" xml:space="preserve">
          <source>Clockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">시계 방향 아래쪽 및 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b8015a573f0320267e05a1e6968f148a65bd38e5" translate="yes" xml:space="preserve">
          <source>Clockwise Integral</source>
          <target state="translated">시계 방향으로 적분</target>
        </trans-unit>
        <trans-unit id="7dcd16fa461353aaddde398802c410edb65684a9" translate="yes" xml:space="preserve">
          <source>Clockwise Open Circle Arrow</source>
          <target state="translated">시계 방향으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="0de2e9fdaa78d1a87383fa303df054177c3eef28" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows</source>
          <target state="translated">시계 방향으로 오른쪽 및 왼쪽으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="78f3f16a08531e7f8a413160ff88e095df7562f2" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay</source>
          <target state="translated">시계 방향으로 오른쪽 및 왼쪽으로 원이 표시된 원 화살표</target>
        </trans-unit>
        <trans-unit id="5a2532914552dd4a4df03ca6c532a1cda0ad9c3e" translate="yes" xml:space="preserve">
          <source>Clockwise Top Semicircle Arrow</source>
          <target state="translated">시계 방향 반원형 화살표</target>
        </trans-unit>
        <trans-unit id="bd5a088aabea6d4dfe11cc8a8a32a9c1483fc8dd" translate="yes" xml:space="preserve">
          <source>Clone a remote repository located at &lt;code&gt;repo_url&lt;/code&gt; to the local filesystem location &lt;code&gt;repo_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; 에있는 원격 저장소 를 로컬 파일 시스템 위치 &lt;code&gt;repo_path&lt;/code&gt; 로 복제하십시오 .</target>
        </trans-unit>
        <trans-unit id="c018fd37cc98046cd18021dbc1501935677a8d0b" translate="yes" xml:space="preserve">
          <source>Clone the remote repository at &lt;code&gt;repo_url&lt;/code&gt; (which can be a remote URL or a path on the local filesystem) to &lt;code&gt;repo_path&lt;/code&gt; (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt;&lt;code&gt;CloneOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; (원격 URL 또는 로컬 파일 시스템의 경로 일 수 있음) 의 원격 저장소를 repo_path (로컬 파일 시스템 의 경로 여야 함 )로 &lt;code&gt;repo_path&lt;/code&gt; 하십시오. &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt; &lt;code&gt;CloneOptions&lt;/code&gt; &lt;/a&gt; 복제 수행 여부와 같은 복제 옵션은 CloneOptions에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="03c26d678d2b5f993e8a4888363c7faf8f7499f8" translate="yes" xml:space="preserve">
          <source>Clong</source>
          <target state="translated">Clong</target>
        </trans-unit>
        <trans-unit id="ba9c34e2f3436e5d9b8a5291e72a776889a2ff30" translate="yes" xml:space="preserve">
          <source>Clonglong</source>
          <target state="translated">Clonglong</target>
        </trans-unit>
        <trans-unit id="b5209dad4d3f1bed9db6402ecbcc5727437490f8" translate="yes" xml:space="preserve">
          <source>Close a channel. An exception (optionally given by &lt;code&gt;excp&lt;/code&gt;), is thrown by:</source>
          <target state="translated">채널을 닫습니다. 예외 ( &lt;code&gt;excp&lt;/code&gt; 옵션으로 제공 )는 다음에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="10c5d49bb09afa0ca8e3334711e18326dcf891af" translate="yes" xml:space="preserve">
          <source>Close an I/O stream. Performs a &lt;a href=&quot;#Base.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">I / O 스트림을 닫습니다. &lt;a href=&quot;#Base.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 먼저 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="454adf74b3f6704e85f70c7ddf537bda059f03dd" translate="yes" xml:space="preserve">
          <source>Close shared library referenced by handle.</source>
          <target state="translated">핸들이 참조하는 공유 라이브러리를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="8170fa95b5dabb39e3ab1424d8d01e1c3b92e425" translate="yes" xml:space="preserve">
          <source>Closed Book</source>
          <target state="translated">닫힌 책</target>
        </trans-unit>
        <trans-unit id="f01ec4341502afd5ff0fd4449550b0f2d821118a" translate="yes" xml:space="preserve">
          <source>Closed Intersection With Serifs</source>
          <target state="translated">세리프가있는 닫힌 교차점</target>
        </trans-unit>
        <trans-unit id="f96d5b0a19b4b209a04614ed2d984814137842d3" translate="yes" xml:space="preserve">
          <source>Closed Lock With Key</source>
          <target state="translated">열쇠로 닫힌 자물쇠</target>
        </trans-unit>
        <trans-unit id="fc6222181031539686fbc1981c6536202f4eebfd" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Lowered Flag</source>
          <target state="translated">플래그가 낮아진 닫힌 사서함</target>
        </trans-unit>
        <trans-unit id="675cf6fab44f887f9851bda94e48adbe87600a21" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Raised Flag</source>
          <target state="translated">제기 플래그로 닫힌 사서함</target>
        </trans-unit>
        <trans-unit id="deb82abc2edb75e5d2559fdc5e14496f68ebe0bb" translate="yes" xml:space="preserve">
          <source>Closed Subset</source>
          <target state="translated">닫힌 부분 집합</target>
        </trans-unit>
        <trans-unit id="27f828ad61dfe0b96ce6597aa9645041a206cb0a" translate="yes" xml:space="preserve">
          <source>Closed Subset Or Equal To</source>
          <target state="translated">닫힌 부분 집합 또는 같음</target>
        </trans-unit>
        <trans-unit id="9ca1f162310be3f8fde01956aa333063b943a628" translate="yes" xml:space="preserve">
          <source>Closed Superset</source>
          <target state="translated">닫힌 슈퍼 세트</target>
        </trans-unit>
        <trans-unit id="c1a77c6e35a02621888adfea720e18df739c611e" translate="yes" xml:space="preserve">
          <source>Closed Superset Or Equal To</source>
          <target state="translated">닫힌 수퍼 셋 또는 같음</target>
        </trans-unit>
        <trans-unit id="1d0ef3df97ab3df50e949a9a1324005eda6b8edb" translate="yes" xml:space="preserve">
          <source>Closed Umbrella</source>
          <target state="translated">닫힌 우산</target>
        </trans-unit>
        <trans-unit id="2509ab5953079af2e5239350a2c4c20c24bf4b87" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs</source>
          <target state="translated">세리프와 닫힌 연합</target>
        </trans-unit>
        <trans-unit id="f8612daffee734ab8fe7ac27e4779293f47bd9f2" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs And Smash Product</source>
          <target state="translated">세리프 및 스매시 제품과의 닫힌 연합</target>
        </trans-unit>
        <trans-unit id="6d5a3633bf3066d6ab42acadf4720d0c57381f8b" translate="yes" xml:space="preserve">
          <source>Closing a Library</source>
          <target state="translated">라이브러리 닫기</target>
        </trans-unit>
        <trans-unit id="aaaf708c53d56650e9ea07591d01dc353b945138" translate="yes" xml:space="preserve">
          <source>Closure &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a1d4177a6fdb9b5f67b13428352c7562697b82" translate="yes" xml:space="preserve">
          <source>Closure cfunctions</source>
          <target state="translated">폐쇄 기능</target>
        </trans-unit>
        <trans-unit id="b2efeaa1a7d6d2185ea02473cf758203dfcea3fe" translate="yes" xml:space="preserve">
          <source>Cloud</source>
          <target state="translated">Cloud</target>
        </trans-unit>
        <trans-unit id="ac3f2b0304dbad8004f320d418e21b773f559bef" translate="yes" xml:space="preserve">
          <source>Cluster Cookie</source>
          <target state="translated">클러스터 쿠키</target>
        </trans-unit>
        <trans-unit id="2719f92d9319470b062026857b1b798355606f18" translate="yes" xml:space="preserve">
          <source>Cluster Manager Interface</source>
          <target state="translated">클러스터 관리자 인터페이스</target>
        </trans-unit>
        <trans-unit id="24b40ea7b4c6d2a2754b767ef66941a1b621105f" translate="yes" xml:space="preserve">
          <source>Cluster Managers with Custom Transports</source>
          <target state="translated">사용자 지정 전송 기능이있는 클러스터 관리자</target>
        </trans-unit>
        <trans-unit id="c66ed07e93160ccf42e9560935c19321d18456bf" translate="yes" xml:space="preserve">
          <source>ClusterManagers</source>
          <target state="translated">ClusterManagers</target>
        </trans-unit>
        <trans-unit id="36a5cc40f84a6918339448f7f9c84d698b78ed22" translate="yes" xml:space="preserve">
          <source>Cmd</source>
          <target state="translated">Cmd</target>
        </trans-unit>
        <trans-unit id="598ac4d5aadd51518cf7408c7b09c93d77fd77bc" translate="yes" xml:space="preserve">
          <source>Cocktail Glass</source>
          <target state="translated">칵테일 글라스</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="a99f20e7919aa57d6d229cdc49d476b887823796" translate="yes" xml:space="preserve">
          <source>Code Availability and Loading Packages</source>
          <target state="translated">코드 가용성 및로드 패키지</target>
        </trans-unit>
        <trans-unit id="d0078b16e6e193ac2fab2fcfbc625d4cc9fdb7f5" translate="yes" xml:space="preserve">
          <source>Code Generation</source>
          <target state="translated">코드 생성</target>
        </trans-unit>
        <trans-unit id="f24dc61405e4a6ac1922198818e95b7dcd3db014" translate="yes" xml:space="preserve">
          <source>Code Loading</source>
          <target state="translated">코드 로딩</target>
        </trans-unit>
        <trans-unit id="b69ba088ce9ad1ce235332dd2372fe802609e0da" translate="yes" xml:space="preserve">
          <source>Code blocks</source>
          <target state="translated">코드 블록</target>
        </trans-unit>
        <trans-unit id="42113fe2d252dc34afb2007f91d2f4059784abe7" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a9d7c94aa1ad1ba8632efb3563e42b2453a554" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules-1&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">코드 포함은 매우 간단하고 간단합니다. 호출자의 컨텍스트에서 지정된 소스 파일을 평가합니다. 패키지 로딩은 코드 포함 위에 구축되며 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;다른 목적으로 사용&lt;/a&gt; 됩니다. 이 장의 나머지 부분에서는 패키지 로딩의 동작 및 메커니즘에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="35b9be6a9b072a2d90be1ca50990262602cae797" translate="yes" xml:space="preserve">
          <source>Code point(s)</source>
          <target state="translated">코드 포인트</target>
        </trans-unit>
        <trans-unit id="33284c9a71b782e3478512a7869d4dc33c4b362d" translate="yes" xml:space="preserve">
          <source>Code should be as generic as possible. Instead of writing:</source>
          <target state="translated">코드는 가능한 한 일반적이어야합니다. 글을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="aae5cfaaacaac3a30cf57079dd346c86a7f7fc5e" translate="yes" xml:space="preserve">
          <source>Code using immutable objects can be easier to reason about.</source>
          <target state="translated">불변 객체를 사용하는 코드는 추론하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80674c31d4ab113b84f8bfda79f90e7c65f5531a" translate="yes" xml:space="preserve">
          <source>Collect a list of log records generated by &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;collect_test_logs&lt;/code&gt;, check that they match the sequence &lt;code&gt;log_patterns&lt;/code&gt;, and return the value of &lt;code&gt;expression&lt;/code&gt;. The &lt;code&gt;keywords&lt;/code&gt; provide some simple filtering of log records: the &lt;code&gt;min_level&lt;/code&gt; keyword controls the minimum log level which will be collected for the test, the &lt;code&gt;match_mode&lt;/code&gt; keyword defines how matching will be performed (the default &lt;code&gt;:all&lt;/code&gt; checks that all logs and patterns match pairwise; use &lt;code&gt;:any&lt;/code&gt; to check that the pattern matches at least once somewhere in the sequence.)</source>
          <target state="translated">에 의해 생성 된 로그 기록의 목록을 수집 &lt;code&gt;expression&lt;/code&gt; 사용 &lt;code&gt;collect_test_logs&lt;/code&gt; 을 , 그들은 순서와 일치하는지 확인 &lt;code&gt;log_patterns&lt;/code&gt; 을 , 그리고 값 반환 &lt;code&gt;expression&lt;/code&gt; . &lt;code&gt;keywords&lt;/code&gt; : 로그 레코드의 몇 가지 간단한 필터링을 제공 &lt;code&gt;min_level&lt;/code&gt; 의 키워드 컨트롤의 테스트를 위해 수집됩니다 최소 로그 수준 &lt;code&gt;match_mode&lt;/code&gt; 의 매칭 (수행 방법 키워드가 정의 기본 &lt;code&gt;:all&lt;/code&gt; 검사가 모든 로그와 패턴이 페어를 일치를, 사용 &lt;code&gt;:any&lt;/code&gt; 어딘가에서 패턴이 적어도 한 번 일치하는지 확인하십시오.)</target>
        </trans-unit>
        <trans-unit id="0a8af36fa1d1619f2da90f35bd9c11b35a37e433" translate="yes" xml:space="preserve">
          <source>Collect information about the status of each file in the git repository &lt;code&gt;repo&lt;/code&gt; (e.g. is the file modified, staged, etc.). &lt;code&gt;status_opts&lt;/code&gt; can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt;&lt;code&gt;StatusOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">망할 놈의 저장소에있는 각 파일의 상태에 대한 수집 정보 &lt;code&gt;repo&lt;/code&gt; (예를 들면, 무대 등을 수정하는 파일입니다). &lt;code&gt;status_opts&lt;/code&gt; 는 추적되지 않은 파일을 볼지 여부 또는 하위 모듈을 포함할지 여부와 같은 다양한 옵션을 설정하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt; &lt;code&gt;StatusOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e2ef8c695440679e7d61620a3e6f58db57bb36f" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="translated">컬렉션 및 데이터 구조</target>
        </trans-unit>
        <trans-unit id="b600a07f6e2a178ebfbe565ac70dc1d11d80d058" translate="yes" xml:space="preserve">
          <source>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)</source>
          <target state="translated">함수에 전달 된 컬렉션도 복사되지 않습니다. 함수는 인수가 참조하는 객체의 내용을 수정 (돌연변이) 할 수 있습니다. (이를 수행하는 함수의 이름은 일반적으로 '!'로 접미사가 붙습니다.)</target>
        </trans-unit>
        <trans-unit id="7a2802907d31a8ef64806a9e6c2120bb1e4caacf" translate="yes" xml:space="preserve">
          <source>Collision Symbol</source>
          <target state="translated">충돌 기호</target>
        </trans-unit>
        <trans-unit id="ac30df75efbedb8442edcd22700caca733d79868" translate="yes" xml:space="preserve">
          <source>Colon</source>
          <target state="translated">Colon</target>
        </trans-unit>
        <trans-unit id="0a14c37ba89fcb5b7168d9ef916ce4e00e67937f" translate="yes" xml:space="preserve">
          <source>Colon Equals / Colon Equal</source>
          <target state="translated">콜론 같음 / 콜론 같음</target>
        </trans-unit>
        <trans-unit id="bb11dae2a053933f6bc7422a2373bf8281b97e57" translate="yes" xml:space="preserve">
          <source>Colons (:) are used to signify indexing entire objects or dimensions at once.</source>
          <target state="translated">콜론 (:)은 전체 개체 또는 차원의 색인을 한 번에 색인화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f95263d15db043d5d52856caad1fadeda6d1c2bc" translate="yes" xml:space="preserve">
          <source>Combinatorics</source>
          <target state="translated">Combinatorics</target>
        </trans-unit>
        <trans-unit id="5350d59289c3e9b699c68a850143c7c2aca47e8e" translate="yes" xml:space="preserve">
          <source>Combined inplace matrix-matrix or matrix-vector multiply-add $A B &amp;alpha; + C &amp;beta;$. The result is stored in &lt;code&gt;C&lt;/code&gt; by overwriting it. Note that &lt;code&gt;C&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173cad0d0654b3f6eb52faa1ce6c93b0376b3f89" translate="yes" xml:space="preserve">
          <source>Combined multiply-add: computes &lt;code&gt;x*y+z&lt;/code&gt;, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt; if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 곱셈 추가 : &lt;code&gt;x*y+z&lt;/code&gt; 를 계산 하지만 더하기 및 곱하기를 서로 또는 성능을 위해 주변 작업과 병합 할 수 있습니다. 예를 들어, 하드웨어가 효율적으로 지원하는 경우 &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt; 로 구현 될 수 있습니다 . 결과는 시스템마다 다를 수 있으며 지속적인 전파 또는 기타 최적화로 인해 동일한 시스템에서 다를 수 있습니다. &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4f01a71c42b25ea3da620732f8db11437dd099b" translate="yes" xml:space="preserve">
          <source>Combining Acute Accent / Non-Spacing Acute</source>
          <target state="translated">급성 악센트 / 비 간격 급성 결합</target>
        </trans-unit>
        <trans-unit id="0734b67961e0eb56239f8b7b60c539fb6834880e" translate="yes" xml:space="preserve">
          <source>Combining Annuity Symbol</source>
          <target state="translated">연금 기호 결합</target>
        </trans-unit>
        <trans-unit id="95ae63a999d098981e7621ee2008c43b0f6a60c6" translate="yes" xml:space="preserve">
          <source>Combining Asterisk Above</source>
          <target state="translated">위의 별표 결합</target>
        </trans-unit>
        <trans-unit id="685cd2e09ad265192e0356f28e46509d84ab4d71" translate="yes" xml:space="preserve">
          <source>Combining Breve / Non-Spacing Breve</source>
          <target state="translated">Breve / Non-Spacing Breve 결합</target>
        </trans-unit>
        <trans-unit id="8e2be6c64a88e84a6f429cab4bdb53ba4fe80660" translate="yes" xml:space="preserve">
          <source>Combining Bridge Below / Non-Spacing Bridge Below</source>
          <target state="translated">아래 다리 / 비 간격 다리 결합</target>
        </trans-unit>
        <trans-unit id="a3f38dbfee0a0277b8fc6dd5b6eb831595bf84a0" translate="yes" xml:space="preserve">
          <source>Combining Candrabindu / Non-Spacing Candrabindu</source>
          <target state="translated">Candrabindu / 비 간격 Candrabindu 결합</target>
        </trans-unit>
        <trans-unit id="8aff768b42edc639adecd3dd04d42d7aed791251" translate="yes" xml:space="preserve">
          <source>Combining Caron / Non-Spacing Hacek</source>
          <target state="translated">카론 / 비 간격 Hacek 결합</target>
        </trans-unit>
        <trans-unit id="3c4e117dd5db64357d4d73eb9cdd1ba25f04fdb1" translate="yes" xml:space="preserve">
          <source>Combining Cedilla / Non-Spacing Cedilla</source>
          <target state="translated">Cedilla / 비 간격 Cedilla 결합</target>
        </trans-unit>
        <trans-unit id="91f0dba538ac66d644d07a8387e2e7e115f196c5" translate="yes" xml:space="preserve">
          <source>Combining Circumflex Accent / Non-Spacing Circumflex</source>
          <target state="translated">Circumflex 악센트 / 비 간격 Circumflex 결합</target>
        </trans-unit>
        <trans-unit id="a43cbdb97b8f699aa2f8714ed59973b90ec0f295" translate="yes" xml:space="preserve">
          <source>Combining Comma Above Right / Non-Spacing Comma Above Right</source>
          <target state="translated">오른쪽 위의 쉼표 결합 / 오른쪽 위의 비 간격 쉼표 결합</target>
        </trans-unit>
        <trans-unit id="a33ec808d6857cd58bedcf6f6f9afde52f57d4fd" translate="yes" xml:space="preserve">
          <source>Combining Diaeresis / Non-Spacing Diaeresis</source>
          <target state="translated">분음 / 비 간격 분만</target>
        </trans-unit>
        <trans-unit id="becaf6a97e81c19ea9f31b976c527ddc1bbea3ee" translate="yes" xml:space="preserve">
          <source>Combining Dot Above / Non-Spacing Dot Above</source>
          <target state="translated">위의 점을 결합 / 위의 비 간격 점</target>
        </trans-unit>
        <trans-unit id="d95e2893d2008e3fc0c1b9bc24115f37f1791066" translate="yes" xml:space="preserve">
          <source>Combining Double Acute Accent / Non-Spacing Double Acute</source>
          <target state="translated">이중 급성 악센트 / 비 간격 이중 급성 결합</target>
        </trans-unit>
        <trans-unit id="f08f92ba4b2bb682dc3e2d5e9c8df57b5dedb3f6" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Circle / Enclosing Circle</source>
          <target state="translated">엔 클로징 서클 / 엔 클로징 서클 결합</target>
        </trans-unit>
        <trans-unit id="83f22c6a001242a5a561f3a7895cf7d7aaaebd0b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Diamond / Enclosing Diamond</source>
          <target state="translated">엔 클로징 다이아몬드 / 엔 클로징 다이아몬드 결합</target>
        </trans-unit>
        <trans-unit id="ec76e2f012d98e1337784adeec747df1b78cf15b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Square / Enclosing Square</source>
          <target state="translated">엔 클로징 스퀘어 / 엔 클로징 스퀘어 결합</target>
        </trans-unit>
        <trans-unit id="efc364102d3ca81f092b677aca701ad08ab10de7" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Upward Pointing Triangle</source>
          <target state="translated">위쪽 포인팅 삼각형 둘러싸 기</target>
        </trans-unit>
        <trans-unit id="22bab50c74edd0eb4d138ac01ac71ba994064528" translate="yes" xml:space="preserve">
          <source>Combining Four Dots Above / Non-Spacing Four Dots Above</source>
          <target state="translated">위의 네 개의 점 결합 / 위의 비 간격 네 점</target>
        </trans-unit>
        <trans-unit id="38e73c84dac801257b0f5e15b8402de9de60fd4a" translate="yes" xml:space="preserve">
          <source>Combining Grave Accent / Non-Spacing Grave</source>
          <target state="translated">그레이브 악센트 / 비 간격 그레이브 결합</target>
        </trans-unit>
        <trans-unit id="fb49a0f3994aaa3fea7e9d53f4e24c6dd93638a6" translate="yes" xml:space="preserve">
          <source>Combining Hook Above / Non-Spacing Hook Above</source>
          <target state="translated">위의 후크 결합 / 비 간격 후크</target>
        </trans-unit>
        <trans-unit id="4cb010ffd9ffa4a05013b3488b30c23afb01fdf1" translate="yes" xml:space="preserve">
          <source>Combining Left Angle Above / Non-Spacing Left Angle Above</source>
          <target state="translated">위의 왼쪽 각도 결합 / 비 간격의 왼쪽 각도</target>
        </trans-unit>
        <trans-unit id="08e42cf0385a0528419967690402d2f77fea8ecf" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Above / Non-Spacing Left Arrow Above</source>
          <target state="translated">위의 왼쪽 화살표 결합 / 비 간격의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="877d024a8659b4afa7238332933b7ad143528441" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Below</source>
          <target state="translated">아래 왼쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="8e6257e591a7e8d45ef0764ba2aea89c01420024" translate="yes" xml:space="preserve">
          <source>Combining Left Harpoon Above / Non-Spacing Left Harpoon Above</source>
          <target state="translated">위의 왼쪽 작살 결합 / 비 간격의 왼쪽 작살 결합</target>
        </trans-unit>
        <trans-unit id="98b334c8eb46b8b78fdd86ea856a3c01a529a309" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above</source>
          <target state="translated">위의 왼쪽 오른쪽 화살표 결합 / 위의 비 간격 왼쪽 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="cedc5fa73afb530ac1a47e52244635331691700e" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Below</source>
          <target state="translated">아래 왼쪽 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="3ecd111368eb8e38f96414851bb4b26f50509766" translate="yes" xml:space="preserve">
          <source>Combining Leftwards Harpoon With Barb Downwards</source>
          <target state="translated">왼쪽으로 작살과 바브를 아래쪽으로 결합</target>
        </trans-unit>
        <trans-unit id="0dfea306ba6d2c2199ba2e9e71aebfc34b9abf34" translate="yes" xml:space="preserve">
          <source>Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Long Solidus 오버레이 / 비 간격 Long 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="9f887140bfcfd6f9e5fb967ba98a3207c8b16bb7" translate="yes" xml:space="preserve">
          <source>Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay</source>
          <target state="translated">롱 스트로크 오버레이 / 비 간격 롱 바 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="739259d807921f9f328b7781ee790a60e450a0a1" translate="yes" xml:space="preserve">
          <source>Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay</source>
          <target state="translated">긴 세로 선 오버레이 / 비 간격 긴 세로 막대 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="2fa244bc31952195840fcfc3a299980dbf801f6f" translate="yes" xml:space="preserve">
          <source>Combining Low Line / Non-Spacing Underscore</source>
          <target state="translated">로우 라인 / 비 간격 밑줄 결합</target>
        </trans-unit>
        <trans-unit id="bf4b2a4b27fa69268427f002d7db69ac9dc2b07c" translate="yes" xml:space="preserve">
          <source>Combining Macron / Non-Spacing Macron</source>
          <target state="translated">마크로 / 비 간격 마크로 결합</target>
        </trans-unit>
        <trans-unit id="a27d4c9bf29370f4faabca36676f0b74743a74d7" translate="yes" xml:space="preserve">
          <source>Combining Ogonek / Non-Spacing Ogonek</source>
          <target state="translated">Ogonek / 비 간격 Ogonek 결합</target>
        </trans-unit>
        <trans-unit id="6d0be0f1d7e1edefb9f72a94ba4677970ba978c9" translate="yes" xml:space="preserve">
          <source>Combining Overline / Non-Spacing Overscore</source>
          <target state="translated">오버 라인 / 비 간격 오버 스코어 결합</target>
        </trans-unit>
        <trans-unit id="7fad7b377dc7ab955143e3c864e92020afd810c8" translate="yes" xml:space="preserve">
          <source>Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below</source>
          <target state="translated">아래 팔라타 이징 후크 결합 / 비 간격 팔라타 이징 후크 아래</target>
        </trans-unit>
        <trans-unit id="a8de9e264b7b283c54023c71a0b50c54c5639e6e" translate="yes" xml:space="preserve">
          <source>Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below</source>
          <target state="translated">아래 Retroflex 후크 결합 / 비 간격 Retroflex 후크 아래</target>
        </trans-unit>
        <trans-unit id="2ba0d1fd66790c9bf8dd50de28c5fd6f05110ed4" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Above / Non-Spacing Right Arrow Above</source>
          <target state="translated">위 오른쪽 화살표 / 비 간격 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="8a30e8c07ae1959f3cd09497d8080f6227316b77" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Below</source>
          <target state="translated">아래 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="4befcc9e0a743f1dd40b3e9e50041b9252baebcb" translate="yes" xml:space="preserve">
          <source>Combining Right Harpoon Above / Non-Spacing Right Harpoon Above</source>
          <target state="translated">위 오른쪽 오른쪽 작살 / 비 간격 오른쪽 작살 결합</target>
        </trans-unit>
        <trans-unit id="aeddc0f0eef5dd1ae0bb9d2d0caf8ade2b689afe" translate="yes" xml:space="preserve">
          <source>Combining Rightwards Harpoon With Barb Downwards</source>
          <target state="translated">오른쪽 아래쪽 작살과 Barb 아래쪽으로 결합</target>
        </trans-unit>
        <trans-unit id="59a9a29108a67d4f908b40c8ecffadfd41391c2c" translate="yes" xml:space="preserve">
          <source>Combining Ring Above / Non-Spacing Ring Above</source>
          <target state="translated">위의 링 / 비 간격 링 결합</target>
        </trans-unit>
        <trans-unit id="5111c307faa772b3a9538095159cefe4c37acd0e" translate="yes" xml:space="preserve">
          <source>Combining Three Dots Above / Non-Spacing Three Dots Above</source>
          <target state="translated">위의 3 개의 점 결합 / 비 간격 3 개의 점</target>
        </trans-unit>
        <trans-unit id="b28cdba8bdbc1c8dbf325c4c84adf50cfa7b9f07" translate="yes" xml:space="preserve">
          <source>Combining Tilde / Non-Spacing Tilde</source>
          <target state="translated">틸드 / 비 간격 틸드 결합</target>
        </trans-unit>
        <trans-unit id="415941ac9a1882af5b80885af204940e2087908c" translate="yes" xml:space="preserve">
          <source>Combining Tilde Below / Non-Spacing Tilde Below</source>
          <target state="translated">아래 물결표 결합 / 비 간격 물결표 아래</target>
        </trans-unit>
        <trans-unit id="890e5eec0caff7a7e81de77d0eefa045a1434041" translate="yes" xml:space="preserve">
          <source>Combining Triple Underdot</source>
          <target state="translated">트리플 언더 도트 결합</target>
        </trans-unit>
        <trans-unit id="308897e651f5347eeb783d7242b9d33cce1a8f1b" translate="yes" xml:space="preserve">
          <source>Combining Turned Comma Above / Non-Spacing Turned Comma Above</source>
          <target state="translated">회전 쉼표 위 / 비 간격 회전 쉼표 결합</target>
        </trans-unit>
        <trans-unit id="866e577b99c41379b3aa42c4489796f50fe38cc1" translate="yes" xml:space="preserve">
          <source>Combining Wide Bridge Above</source>
          <target state="translated">위의 넓은 다리를 결합</target>
        </trans-unit>
        <trans-unit id="88113a7dbb8d79749cd6e0f0600302ccfd5aa3c0" translate="yes" xml:space="preserve">
          <source>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether &lt;code&gt;1.+x&lt;/code&gt; means &lt;code&gt;1. + x&lt;/code&gt; or &lt;code&gt;1 .+ x&lt;/code&gt;. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</source>
          <target state="translated">도트 연산자를 숫자 리터럴과 결합하면 모호 할 수 있습니다. 예를 들어,인지 분명하지 않다 &lt;code&gt;1.+x&lt;/code&gt; 수단 &lt;code&gt;1. + x&lt;/code&gt; 또는 &lt;code&gt;1 .+ x&lt;/code&gt; . 따라서이 구문은 허용되지 않으며 이러한 경우 연산자 주위에 공백을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="8ddf0393cc298edc03dc88f0719f2655cd0574b7" translate="yes" xml:space="preserve">
          <source>Commit all currently buffered writes to the given stream.</source>
          <target state="translated">현재 버퍼링 된 모든 쓰기를 지정된 스트림에 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="a347aae8b8a9fc1e2f6210e5e5378437485857d4" translate="yes" xml:space="preserve">
          <source>Commit the current patch to the rebase &lt;code&gt;rb&lt;/code&gt;, using &lt;code&gt;sig&lt;/code&gt; as the committer. Is silent if the commit has already been applied.</source>
          <target state="translated">&lt;code&gt;sig&lt;/code&gt; 를 커미터로 사용하여 현재 패치를 rebase &lt;code&gt;rb&lt;/code&gt; 에 커밋하십시오. 커밋이 이미 적용된 경우 자동입니다.</target>
        </trans-unit>
        <trans-unit id="2be9168624323737db43ee381ca8992f9a73de9d" translate="yes" xml:space="preserve">
          <source>Common Operations</source>
          <target state="translated">일반적인 작업</target>
        </trans-unit>
        <trans-unit id="a204c5d42b8380165174afefc8c02b676b132a6b" translate="yes" xml:space="preserve">
          <source>Communicating with Channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66508cd4da8f90000c3284eb64d70b8945911d14" translate="yes" xml:space="preserve">
          <source>Compact WY form of the QR factorization</source>
          <target state="translated">QR 분해의 소형 WY 양식</target>
        </trans-unit>
        <trans-unit id="6bf1e82b56d17bf4bd651ed651f5ad4b9fb92d04" translate="yes" xml:space="preserve">
          <source>Compare how these results differ:</source>
          <target state="translated">이 결과가 어떻게 다른지 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="3937ff70415e32705a844575737929096286a5fd" translate="yes" xml:space="preserve">
          <source>Compare two strings. Return &lt;code&gt;0&lt;/code&gt; if both strings have the same length and the character at each index is the same in both strings. Return &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is a prefix of &lt;code&gt;b&lt;/code&gt;, or if &lt;code&gt;a&lt;/code&gt; comes before &lt;code&gt;b&lt;/code&gt; in alphabetical order. Return &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is a prefix of &lt;code&gt;a&lt;/code&gt;, or if &lt;code&gt;b&lt;/code&gt; comes before &lt;code&gt;a&lt;/code&gt; in alphabetical order (technically, lexicographical order by Unicode code points).</source>
          <target state="translated">두 문자열을 비교하십시오. 반환 &lt;code&gt;0&lt;/code&gt; 을 두 문자열이 동일한 길이와 각 인덱스에있는 문자는 모두 문자열에서 동일해야합니다. 돌아 &lt;code&gt;-1&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 의 접두어 &lt;code&gt;b&lt;/code&gt; 는 경우, 또는 &lt;code&gt;a&lt;/code&gt; 는 앞에 오는 &lt;code&gt;b&lt;/code&gt; 알파벳 순서로한다. 반환 &lt;code&gt;1&lt;/code&gt; 하면 &lt;code&gt;b&lt;/code&gt; 의 접두어 경우, 또는 &lt;code&gt;b&lt;/code&gt; 는 앞에 오는 알파벳 순서 (기술적, 유니 코드 코드 포인트에 의한 사전 순). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058bad1213f1f21ce991a75b5be44ee324a930b6" translate="yes" xml:space="preserve">
          <source>Compared to using &lt;a href=&quot;../math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, directly constructing a &lt;code&gt;LinRange&lt;/code&gt; should have less overhead but won't try to correct for floating point errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3294837eea456d1d9b5c37c0aa8f59ea86b3c495" translate="yes" xml:space="preserve">
          <source>Comparison &amp;ndash; &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;asymp;&lt;/code&gt; (&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;≉&lt;/code&gt;</source>
          <target state="translated">비교 - &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;asymp;&lt;/code&gt; ( &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;≉&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfbdf2ba206862934e1703fb9dabae9ccfe529b" translate="yes" xml:space="preserve">
          <source>Comparison with &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 과 비교</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="a1f782aa0dd22ca1d8ddd5007091a2531356eecb" translate="yes" xml:space="preserve">
          <source>Compile the given function &lt;code&gt;f&lt;/code&gt; for the argument tuple (of types) &lt;code&gt;args&lt;/code&gt;, but do not execute it.</source>
          <target state="translated">인수 tuple (유형) &lt;code&gt;args&lt;/code&gt; 에 대해 주어진 함수 &lt;code&gt;f&lt;/code&gt; 를 컴파일 하되 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d208cd655bc27c326dbf72e200351336cfc4e60e" translate="yes" xml:space="preserve">
          <source>Complement</source>
          <target state="translated">Complement</target>
        </trans-unit>
        <trans-unit id="05138c0edd56f7bbbd9cae9c6f481c62b93d161a" translate="yes" xml:space="preserve">
          <source>Completion of paths works for strings and julia's shell mode:</source>
          <target state="translated">경로 완성은 문자열과 julia의 쉘 모드에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="ff549706d081e3e60cc13e4b49b48c707d5b0c58" translate="yes" xml:space="preserve">
          <source>Complex Example</source>
          <target state="translated">복잡한 예</target>
        </trans-unit>
        <trans-unit id="c73def212afdc811169afd7e77aebfbeecb5facc" translate="yes" xml:space="preserve">
          <source>Complex Numbers</source>
          <target state="translated">복소수</target>
        </trans-unit>
        <trans-unit id="d92056b9511d12d7ca9a02729b4db7f33b444189" translate="yes" xml:space="preserve">
          <source>Complex and Rational Numbers</source>
          <target state="translated">복소수 및 유리수</target>
        </trans-unit>
        <trans-unit id="4bf180d1d0870c204edb37eb372ac0df5d17b6dd" translate="yes" xml:space="preserve">
          <source>Complex blocks:</source>
          <target state="translated">복잡한 블록 :</target>
        </trans-unit>
        <trans-unit id="0a73edd8fc9653ee436727fd08c0b9f3b06b1113" translate="yes" xml:space="preserve">
          <source>Complex method &quot;cascades&quot; with default arguments</source>
          <target state="translated">기본 인수가있는 복잡한 메소드 &quot;계단식&quot;</target>
        </trans-unit>
        <trans-unit id="f9ed4ba22fe6a41d861b48b53689d9f5e1620b3b" translate="yes" xml:space="preserve">
          <source>Complex number type with real and imaginary part of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 실수 부와 허수 부를 가진 복소수 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="b4dd6b3b31c6eea3e9660b73bc2f3101abdfba71" translate="yes" xml:space="preserve">
          <source>Compose functions: i.e. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; means &lt;code&gt;f(g(args...))&lt;/code&gt;. The &lt;code&gt;∘&lt;/code&gt; symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">작성 함수 : 즉 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 는 &lt;code&gt;f(g(args...))&lt;/code&gt; 합니다. &lt;code&gt;∘&lt;/code&gt; 기호 입력하여 (적절하게 구성된 대부분의 편집자) 줄리아 REPL에 입력 할 수 있습니다 &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">복합 유형</target>
        </trans-unit>
        <trans-unit id="df2490ae2d6c4446ef7afd32a3da2e5ee7b69ac4" translate="yes" xml:space="preserve">
          <source>Composite objects declared with &lt;code&gt;struct&lt;/code&gt; are &lt;em&gt;immutable&lt;/em&gt;; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 로 선언 된 복합 객체 는 &lt;em&gt;변경할 수 없습니다&lt;/em&gt; . 시공 후에는 수정할 수 없습니다. 처음에는 이상하게 보일 수 있지만 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e0dcd858e537fe0307f2358a312f03c6681c12" translate="yes" xml:space="preserve">
          <source>Composite types are introduced with the &lt;a href=&quot;../../base/base/index#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; keyword followed by a block of field names, optionally annotated with types using the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">복합 유형은 &lt;a href=&quot;../../base/base/index#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 키워드 와 함께 필드 이름 블록이 뒤 따르며, 선택적으로 &lt;code&gt;::&lt;/code&gt; 연산자를 사용하여 유형이 주석으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9189e65c24f2bdb8de9b12a05127190c54ae9a3c" translate="yes" xml:space="preserve">
          <source>Composite types such as &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5701f0731819052a01bc826ae56db27fca5211d9" translate="yes" xml:space="preserve">
          <source>Composite types, aka &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">복합 형 일명 &lt;code&gt;struct&lt;/code&gt; C 또는 &lt;code&gt;TYPE&lt;/code&gt; Fortran90에서 (또는 &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; 일부는 F77 변종은)와, 만들어 줄리아에 반영 될 수 &lt;code&gt;struct&lt;/code&gt; 동일한 필드 레이아웃을 정의한다.</target>
        </trans-unit>
        <trans-unit id="7544d508f3b0902a380eab3d1ae0e5d8d3c1b60c" translate="yes" xml:space="preserve">
          <source>CompositeException</source>
          <target state="translated">CompositeException</target>
        </trans-unit>
        <trans-unit id="79e03922c06b260c57343358b29b8c08b337403a" translate="yes" xml:space="preserve">
          <source>Composition of one function ∘(f) requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29eeb6459e95f17b9e773f8892492e90000d531" translate="yes" xml:space="preserve">
          <source>Compound Expressions</source>
          <target state="translated">복합 표현</target>
        </trans-unit>
        <trans-unit id="3c63c3a24b2a5e684ce3eb80765c227218a808f0" translate="yes" xml:space="preserve">
          <source>Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:</source>
          <target state="translated">여러 필드가 동시에 필요한 경우 효율성을 측정 할 수있는 복합 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="c10ef362f781785063bbb997cd5031a5191aade1" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e547d2519645c376aaf30ba92bb6080596e3ef5" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">둘러싸는 대괄호 없이도 이해를 작성하여 생성기라고하는 객체를 생성 할 수 있습니다. 이 목적은 대신 배열을 할당하고 (참조 사전에 저장의 수요에 값을 생성하기 위해 반복 될 수있는 &lt;a href=&quot;#Iteration-1&quot;&gt;반복&lt;/a&gt; ). 예를 들어, 다음 표현식은 메모리를 할당하지 않고 시리즈를 합칩니다.</target>
        </trans-unit>
        <trans-unit id="908bf8150b71b44066207c270126a10d2c63b84b" translate="yes" xml:space="preserve">
          <source>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</source>
          <target state="translated">이해는 배열을 구성하는 일반적이고 강력한 방법을 제공합니다. 이해 구문은 수학의 구성 표기법과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="41931e1bad3441e4fffdabe12a675d7a10ef5fe7" translate="yes" xml:space="preserve">
          <source>Compressed Sparse Column (CSC) Sparse Matrix Storage</source>
          <target state="translated">압축 스파 스 열 (CSC) 스파 스 매트릭스 스토리지</target>
        </trans-unit>
        <trans-unit id="df6e999370e627bd7fb17556cf85a2f9046d57dd" translate="yes" xml:space="preserve">
          <source>Compute $10^x$.</source>
          <target state="translated">$ 10 ^ x $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="3440d15eee03e7b747a1a78d06bc04de26352e6b" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$ if $x \neq 0$, and $0$ if $x = 0$. This is the derivative of &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">$ x \ neq 0 $ 인 경우 $ \ cos (\ pi x) / x-\ sin (\ pi x) / (\ pi x ^ 2) $를 계산하고 $ x = 0 $ 인 경우 $ 0 $를 계산합니다. 이것은 &lt;code&gt;sinc(x)&lt;/code&gt; 의 미분입니다 .</target>
        </trans-unit>
        <trans-unit id="641b97c82ee25690f10e6e7742dc51e5d15732ca" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x)$ more accurately than &lt;code&gt;cos(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보다 정확하게 $ \ cos (\ pi x) $ 계산 &lt;code&gt;cos(pi*x)&lt;/code&gt; 특히 큰 &lt;code&gt;x&lt;/code&gt; 의 경우 cos (pi * x) .</target>
        </trans-unit>
        <trans-unit id="1b6e2580104ead79696c9bd035d3ea44c420e327" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x) / (\pi x)$ if $x \neq 0$, and $1$ if $x = 0$.</source>
          <target state="translated">$ x \ neq 0 $이면 $ \ sin (\ pi x) / (\ pi x) $를 계산하고 $ x = 0 $이면 $ 1 $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5609ddf7e7650835bda46710354a43594cc254bb" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x)$ more accurately than &lt;code&gt;sin(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sin(pi*x)&lt;/code&gt; 보다 $ \ sin (\ pi x) $를 더 정확하게 계산 특히 큰 &lt;code&gt;x&lt;/code&gt; 의 경우) .</target>
        </trans-unit>
        <trans-unit id="929982bef54c338e6e35e28527b86375aafc50c8" translate="yes" xml:space="preserve">
          <source>Compute $x \times 2^n$.</source>
          <target state="translated">$ x \ times 2 ^ n $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="64de6f27384f256461bed9916267c818d5e5214a" translate="yes" xml:space="preserve">
          <source>Compute $x^p \pmod m$.</source>
          <target state="translated">$ x ^ p \ pmod m $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="19ceaddf89a47393966a49ad36ca860fe7e80321" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A / B&lt;/code&gt; in-place and overwriting &lt;code&gt;A&lt;/code&gt; to store the result.</source>
          <target state="translated">전체 &lt;code&gt;A / B&lt;/code&gt; 계산 및 &lt;code&gt;A&lt;/code&gt; 덮어 쓰기 를 하여 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7f0218a9f1bc487c2b5096445bf17474b3168d25" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and overwriting &lt;code&gt;B&lt;/code&gt; to store the result.</source>
          <target state="translated">내부 &lt;code&gt;A \ B&lt;/code&gt; 및 B 계산 및 &lt;code&gt;B&lt;/code&gt; 덮어 쓰기 를 하여 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="fec3a07dc37940dceabb5be53b362461307a4c1d" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and store the result in &lt;code&gt;Y&lt;/code&gt;, returning the result.</source>
          <target state="translated">&lt;code&gt;A \ B&lt;/code&gt; 를 내부 에서 계산 하고 결과를 &lt;code&gt;Y&lt;/code&gt; 에 저장 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98e6c5fec537a69040a39ae887c67e4d70213543" translate="yes" xml:space="preserve">
          <source>Compute a convenient factorization of &lt;code&gt;A&lt;/code&gt;, based upon the type of the input matrix. &lt;code&gt;factorize&lt;/code&gt; checks &lt;code&gt;A&lt;/code&gt; to see if it is symmetric/triangular/etc. if &lt;code&gt;A&lt;/code&gt; is passed as a generic matrix. &lt;code&gt;factorize&lt;/code&gt; checks every element of &lt;code&gt;A&lt;/code&gt; to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt;.</source>
          <target state="translated">입력 행렬의 유형에 따라 &lt;code&gt;A&lt;/code&gt; 의 편리한 인수 분해를 계산합니다 . &lt;code&gt;factorize&lt;/code&gt; 검사 &lt;code&gt;A&lt;/code&gt; 는 이 대칭 / 삼각 / 등의 경우에 볼 수 있습니다. &lt;code&gt;A&lt;/code&gt; 가 일반 행렬로 전달되는 경우 &lt;code&gt;factorize&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 모든 요소를 ​​검사 하여 각 속성을 확인 / 거부합니다. 대칭 / 삼각형 구조를 배제 할 수있는 즉시 단락됩니다. 여러 시스템을 효율적으로 해결하기 위해 반환 값을 재사용 할 수 있습니다. 예를 들면 : &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="081b8630c615f09be39d92a0115c25e75916aff0" translate="yes" xml:space="preserve">
          <source>Compute a type that contains the intersection of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;. Usually this will be the smallest such type or one close to it.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;S&lt;/code&gt; 의 교집합이 포함 된 유형을 계산합니다. . 일반적으로 이것은 가장 작은 유형이거나 가장 가까운 유형입니다.</target>
        </trans-unit>
        <trans-unit id="db62a7195b361bd27a6ab49b26fc5d995d7a85c5" translate="yes" xml:space="preserve">
          <source>Compute an &lt;code&gt;LDLt&lt;/code&gt; factorization of the real symmetric tridiagonal matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is a unit lower triangular matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;LDLt&lt;/code&gt; 실제의 인수를 대칭 삼중 대각 행렬 &lt;code&gt;S&lt;/code&gt; 되도록 &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; &lt;code&gt;L&lt;/code&gt; 은 단위 하 삼각 행렬이고 &lt;code&gt;d&lt;/code&gt; 벡터이다. 의 주 사용 &lt;code&gt;LDLt&lt;/code&gt; 인수 &lt;code&gt;F = ldlt(S)&lt;/code&gt; 선형 방정식들의 시스템을 해결하기 &lt;code&gt;Sx = b&lt;/code&gt; 와 &lt;code&gt;F\b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c1ac6c08b678223e4887392c381e9189c7ba93b" translate="yes" xml:space="preserve">
          <source>Compute an integer hash code such that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x)==hash(y)&lt;/code&gt;. The optional second argument &lt;code&gt;h&lt;/code&gt; is a hash code to be mixed with the result.</source>
          <target state="translated">&lt;code&gt;isequal(x,y)&lt;/code&gt; &lt;code&gt;hash(x)==hash(y)&lt;/code&gt; 암시 하는 정수 해시 코드를 계산하십시오 . 선택적 두 번째 인수 &lt;code&gt;h&lt;/code&gt; 는 결과와 혼합 될 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="79e6e6b92700158abe5cbe60e135ba2eff400933" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</source>
          <target state="translated">단일 패스에서 최소 및 최대 요소를 모두 계산하고 2- 튜플로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55674d923cbe36a00a2dcb12dc90008788433dbf" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in &lt;code&gt;itr&lt;/code&gt; and return them as a 2-tuple. Only one pass is made over &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 의 각 요소에 적용되는 최소 및 최대 &lt;code&gt;f&lt;/code&gt; 를 모두 계산 하여 2 튜플로 반환합니다. &lt;code&gt;itr&lt;/code&gt; 에는 한 번만 패스됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fc034d752a929a676df33e97329f28013afb4ac" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">의 계산 코사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="2812b6470b645598b89e13c27d80693c2571602e" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 코사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="ed29aab024d008c6bdfa953e7bd9ab905379d015" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ec21c723d13f003816fe96579a7df0d489520259" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ac3565a823d4a3efc52e74fc685ed86ae6db58a3" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c3738eef2209a39b21f53d71ed43b07f931e624c" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사인을 계산 합니다. 여기서 &lt;code&gt;x&lt;/code&gt; 는 도입니다.</target>
        </trans-unit>
        <trans-unit id="6cf01364af065ae849f27852465a3d3bfe52089d" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="c2d206b82e6db8e986bbbf98cbf0eb72129c224a" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">계산의 접선 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="202a93fa28b48e329210fdf808f2d1b87daa3ed4" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">계산의 접선 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="f664081b059842ba583be8e317e1608e46a53fd3" translate="yes" xml:space="preserve">
          <source>Compute the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbf493148049741c81504ff6b4e5ee8560f996f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="17538b08e9c154c3f5dd62072c8fa0ea05f963fc" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad780cc4431af9be511082a782160bff6da4c65" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f7a649b9c569a9a9a900055ad2e3e530ad769e9f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="73e05a032664ce6a5bb59d6231727896e0d85677" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5939dcb4cf796b127a8200b499f432e4d64b40" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="14220f2b6c0b60f7df0cde02fa4f1c544028c987" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 , &lt;code&gt;A = RQ&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="861e3be13c33c99b622d41916c8e070553b49f73" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 , &lt;code&gt;A = RQ&lt;/code&gt; 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수 이상이어야합니다 . .</target>
        </trans-unit>
        <trans-unit id="1941b58e1c7afe2d3c77d99152574462461df1db" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; factorization of a &lt;code&gt;Symmetric&lt;/code&gt; or &lt;code&gt;Hermitian&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; as $P'*U*D*U'*P$ or $P'*L*D*L'*P$, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;code&gt;BunchKaufman&lt;/code&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Symmetric&lt;/code&gt; 또는 &lt;code&gt;Hermitian&lt;/code&gt; 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; 인수 분해 를 어떤 삼각형 이냐에 따라 $ P '* U * D * U'* P $ 또는 $ P '* L * D * L'* P $로 계산합니다 &lt;code&gt;A&lt;/code&gt; 에 저장 하고 &lt;code&gt;BunchKaufman&lt;/code&gt; 객체를 반환 합니다. 경우 참고 &lt;code&gt;A&lt;/code&gt; 가 복잡 다음 대칭 &lt;code&gt;U'&lt;/code&gt; 와 &lt;code&gt;L'&lt;/code&gt; 접합되지 전치를 나타내는, 즉 &lt;code&gt;transpose(U)&lt;/code&gt; 및 &lt;code&gt;transpose(L)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24a7193e031893d923ed86bc5db45171f4b4182" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;sup&gt;&lt;a href=&quot;#footnote-Bunch1977&quot; id=&quot;citeref-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;&lt;/sup&gt; factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'*U*D*U'*P&lt;/code&gt; or &lt;code&gt;P'*L*D*L'*P&lt;/code&gt;, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;a href=&quot;#LinearAlgebra.BunchKaufman&quot;&gt;&lt;code&gt;BunchKaufman&lt;/code&gt;&lt;/a&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adc6e0822f31506444311768e4f6ded0f9f1c41" translate="yes" xml:space="preserve">
          <source>Compute the CRC-32c checksum of the given &lt;code&gt;data&lt;/code&gt;, which can be an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a contiguous subarray thereof, or a &lt;code&gt;String&lt;/code&gt;. Optionally, you can pass a starting &lt;code&gt;crc&lt;/code&gt; integer to be mixed in with the checksum. The &lt;code&gt;crc&lt;/code&gt; parameter can be used to compute a checksum on data divided into chunks: performing &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; is equivalent to the checksum of &lt;code&gt;[data1; data2]&lt;/code&gt;. (Technically, a little-endian checksum is computed.)</source>
          <target state="translated">주어진 &lt;code&gt;data&lt;/code&gt; 의 CRC-32c 체크섬을 계산합니다.이 데이터 는 &lt;code&gt;Array{UInt8}&lt;/code&gt; , 연속 된 하위 배열 또는 &lt;code&gt;String&lt;/code&gt; 일 수 있습니다. 선택적으로 시작 &lt;code&gt;crc&lt;/code&gt; 정수를 전달 하여 체크섬과 혼합 할 수 있습니다. &lt;code&gt;crc&lt;/code&gt; 파라미터 청크로 분할 된 데이터에 대한 체크섬을 계산하는데 이용 될 수있다 : 실시 &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; 의 체크섬 동등 &lt;code&gt;[data1; data2]&lt;/code&gt; . 기술적으로 리틀 엔디안 체크섬이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="451fab004d9b252be766b8c8da0ec9401bcb730d" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.Cholesky&quot;&gt;&lt;code&gt;Cholesky&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633c320407bd275302d618eed24d78f3e652466b" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Cholesky&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조밀 한 대칭 긍정적 인 확실한 매트릭스의 콜레 인수 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;Cholesky&lt;/code&gt; 인수 분해를. 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 또는 &lt;em&gt;완벽하게&lt;/em&gt; 대칭 또는 Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 일 수 있습니다. 삼각형 콜레 계수는 인수 분해에서 얻을 수 있습니다 &lt;code&gt;F&lt;/code&gt; :와 &lt;code&gt;F.L&lt;/code&gt; 과 &lt;code&gt;F.U&lt;/code&gt; . 다음과 같은 기능을 사용할 수 있습니다 &lt;code&gt;Cholesky&lt;/code&gt; 개체 : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;및&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb3253df25b3b67c97f210c72aa2a93261e457fb" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; (of type &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt;) and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt; (of type &lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt;&lt;code&gt;UpperHessenberg&lt;/code&gt;&lt;/a&gt;), either of which may be converted to a regular matrix with &lt;code&gt;Matrix(F.H)&lt;/code&gt; or &lt;code&gt;Matrix(F.Q)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b962efd94ea393def73078100fff01edd4aab9" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">의 하센 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;Hessenberg&lt;/code&gt; 개체를. 하면 &lt;code&gt;F&lt;/code&gt; 가 인수 분해의 목적은, 유니 터리 행렬에 접근 할 수 &lt;code&gt;F.Q&lt;/code&gt; 와 함께 하센 행렬 &lt;code&gt;F.H&lt;/code&gt; . &lt;code&gt;Q&lt;/code&gt; 가 추출 될 때 결과 유형은 &lt;code&gt;HessenbergQ&lt;/code&gt; 객체이며 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용하여 일반 행렬로 변환 될 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
