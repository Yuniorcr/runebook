<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="832c7202e91f697ee6939cc6a25570d7f86be4c5" translate="yes" xml:space="preserve">
          <source>Compute the LQ decomposition of &lt;code&gt;A&lt;/code&gt;. The decomposition's lower triangular component can be obtained from the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; object &lt;code&gt;S&lt;/code&gt; via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 LQ 분해를 계산합니다 . 분해의 하 삼각 성분으로부터 얻을 수있다 &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt; &lt;code&gt;LQ&lt;/code&gt; 의&lt;/a&gt; 오브젝트 &lt;code&gt;S&lt;/code&gt; 통해 &lt;code&gt;S.L&lt;/code&gt; 과 직교 통해 / 단일 성분 &lt;code&gt;S.Q&lt;/code&gt; ,되도록 &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d47c5b4fc5ee4331387245803c6326b23b1e354" translate="yes" xml:space="preserve">
          <source>Compute the LQ decomposition of &lt;code&gt;A&lt;/code&gt;. The decomposition's lower triangular component can be obtained from the &lt;code&gt;LQ&lt;/code&gt; object &lt;code&gt;S&lt;/code&gt; via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 LQ 분해를 계산합니다 . 분해의 하부 삼각 성분은 &lt;code&gt;S.L&lt;/code&gt; 통해 &lt;code&gt;LQ&lt;/code&gt; 객체 ( &lt;code&gt;S&lt;/code&gt; ) 로부터 그리고 A&amp;asymp;SL &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; 되도록 &lt;code&gt;S.Q&lt;/code&gt; 를 통해 직교 / 일체 성분 으로부터 얻어 질 수있다 .</target>
        </trans-unit>
        <trans-unit id="df93c4e3f01a5d5d8938330edf6e69bce8f5f23a" translate="yes" xml:space="preserve">
          <source>Compute the LQ factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 행렬을 작업 공간으로 사용하여 &lt;code&gt;A&lt;/code&gt; 의 LQ 인수 분해를 계산합니다 . &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt; &lt;code&gt;lq&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f143c0b1e17ec33b003d5d465ed585f1a6c5eeb5" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 LU 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f3d2a0b8ede301b8c788fe8d3b8a2900d96315da" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of a banded matrix &lt;code&gt;AB&lt;/code&gt;. &lt;code&gt;kl&lt;/code&gt; is the first subdiagonal containing a nonzero band, &lt;code&gt;ku&lt;/code&gt; is the last superdiagonal containing one, and &lt;code&gt;m&lt;/code&gt; is the first dimension of the matrix &lt;code&gt;AB&lt;/code&gt;. Returns the LU factorization in-place and &lt;code&gt;ipiv&lt;/code&gt;, the vector of pivots used.</source>
          <target state="translated">밴드 행렬 &lt;code&gt;AB&lt;/code&gt; 의 LU 인수 분해를 계산합니다 . &lt;code&gt;kl&lt;/code&gt; 은 0이 아닌 밴드를 포함하는 첫 번째 subdiagonal이고, &lt;code&gt;ku&lt;/code&gt; 는 1을 포함하는 마지막 superdiagonal이며, &lt;code&gt;m&lt;/code&gt; 은 행렬 &lt;code&gt;AB&lt;/code&gt; 의 첫 번째 차원입니다 . LU 인수 분해를 사용하고 사용 된 피벗의 벡터 인 &lt;code&gt;ipiv&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e85ab4b85e63bda3524cd40490290f9c652abef" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 Pearson 상관 관계를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="0c66f895734c2d381a6e7359b9abed2937fd17e4" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 벡터 또는 행렬 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 사이의 피어슨 상관 관계를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="74013bf59e1c48e3434f51156a8cd876c94ec658" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 행렬 &lt;code&gt;X&lt;/code&gt; 의 피어슨 상관 행렬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="eb5aaf9c337f0702d2fe48faff921d16afde5b19" translate="yes" xml:space="preserve">
          <source>Compute the QR factorization of the matrix &lt;code&gt;A&lt;/code&gt;: an orthogonal (or unitary if &lt;code&gt;A&lt;/code&gt; is complex-valued) matrix &lt;code&gt;Q&lt;/code&gt;, and an upper triangular matrix &lt;code&gt;R&lt;/code&gt; such that</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 QR 분해 : 직교 (또는 &lt;code&gt;A&lt;/code&gt; 가 복소수 인 경우 단일 ) 행렬 &lt;code&gt;Q&lt;/code&gt; 및 상위 삼각 행렬 &lt;code&gt;R&lt;/code&gt; 을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4fb449517dd4a253bcd016046b2c39cd6be49f" translate="yes" xml:space="preserve">
          <source>Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.</source>
          <target state="translated">인수에서 도달 할 수있는 모든 고유 한 오브젝트가 사용하는 메모리 양 (바이트)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ef14f4c033588439c9734666e7f662db33797d38" translate="yes" xml:space="preserve">
          <source>Compute the base 10 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $10^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 10 지수 , 즉 $ 10 ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5996a7911dbb75d459bb57880857b6c285fdb533" translate="yes" xml:space="preserve">
          <source>Compute the base 2 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $2^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 2 지수 , 즉 $ 2 ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="794534f25f9e8868116d7dccbee753ad76971472" translate="yes" xml:space="preserve">
          <source>Compute the base &lt;code&gt;b&lt;/code&gt; logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 &lt;code&gt;b&lt;/code&gt; 로그를 계산합니다 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 는&lt;/a&gt; 부정적인 위해 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="c05a16a74adde544da95df4e78617f63f96f27db" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of &lt;code&gt;T&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;. The second dimension of &lt;code&gt;T&lt;/code&gt; must equal the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 차단 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 . &lt;code&gt;T&lt;/code&gt; 는 인수 분해의 기본 반사기를 파라미터 화하는 상부 삼각 블록 반사기를 포함한다. &lt;code&gt;T&lt;/code&gt; 의 첫 번째 차원은 블록 크기를 설정하며 1과 &lt;code&gt;n&lt;/code&gt; 사이 여야합니다 . &lt;code&gt;T&lt;/code&gt; 의 두 번째 차원 은 &lt;code&gt;A&lt;/code&gt; 의 가장 작은 차원과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b0cbb0565d1b4a03a96f69b70d2c66787700aa8" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;nb&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;, the second dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 차단 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 . &lt;code&gt;nb&lt;/code&gt; 는 블록 크기를 설정하며 &lt;code&gt;A&lt;/code&gt; 의 두 번째 차원 인 1과 &lt;code&gt;n&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="64fc87785de1b25c447a6d57734a1583aa8fc760" translate="yes" xml:space="preserve">
          <source>Compute the complex conjugate of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 복소 공액을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d952ac0269ec6a898fc99a4c73f9f0fa2cddbcd5" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코시컨트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는도 단위입니다.</target>
        </trans-unit>
        <trans-unit id="cd18d2a4efe3c5ddd8da80eadb7eb93b647e38fb" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코시컨트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="7c34352434165644e17d3d3c3017b1efac79a034" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코탄젠트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 도입니다.</target>
        </trans-unit>
        <trans-unit id="51e33b4564608050a8442490630344d272d7cb6a" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 코탄젠트 &lt;code&gt;x&lt;/code&gt; 여기서, &lt;code&gt;x&lt;/code&gt; 는 라디안이다.</target>
        </trans-unit>
        <trans-unit id="ced199cab7b78dc4018b6d349c2fddeae611b20a" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), computes $\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$ where $*$ denotes the complex conjugate and &lt;code&gt;n = length(x) = length(y)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, computes $\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 공분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (기본), $ \ FRAC {1}를 연산한다 {N-1} \ sum_ {I = 1} ^ N (x_i- \ 바 X) (y_i- \ 바 Y) ^ * $ 여기서 $ * $는 켤레 복소수를 나타내고 &lt;code&gt;n = length(x) = length(y)&lt;/code&gt; 입니다. &lt;code&gt;corrected&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 $ \ frac {1} {n} \ sum_ {i = 1} ^ n (x_i- \ bar x) (y_i- \ bar y) ^ * $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c939998715a4bc32623fd5d4a50f59b83b9bf7e" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 벡터 또는 행렬 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 사이의 공분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 여기서 &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c149665bdfebe0f49b37ac0ad2f4069a8c615ef5" translate="yes" xml:space="preserve">
          <source>Compute the covariance matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims)&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 행렬 &lt;code&gt;X&lt;/code&gt; 의 공분산 행렬을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 여기서 &lt;code&gt;n = size(X, dims)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="410468f3561472f97b5b13876570709e80fe55b0" translate="yes" xml:space="preserve">
          <source>Compute the cross product of two 3-vectors.</source>
          <target state="translated">2 개의 3 개 벡터의 교차 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="50f5c17779b906283ea9fd2a34268ff40e2ded97" translate="yes" xml:space="preserve">
          <source>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.</source>
          <target state="translated">두 벡터 간의 내적을 계산합니다. 복소수 벡터의 경우 첫 번째 벡터가 공액됩니다.</target>
        </trans-unit>
        <trans-unit id="98027b7e04b6a89188be633c36e298c811c2a981" translate="yes" xml:space="preserve">
          <source>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling &lt;code&gt;dot&lt;/code&gt; is semantically equivalent to &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">두 벡터 사이의 내적을 계산합니다. 복소수 벡터의 경우, 첫 번째 벡터가 접합됩니다. 벡터의 길이가 동일한 경우 호출 &lt;code&gt;dot&lt;/code&gt; 은 의미 적 &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c700743247c39eb6f20b3363175a4f35bc60b4" translate="yes" xml:space="preserve">
          <source>Compute the element type &lt;code&gt;R&lt;/code&gt; of the result matrix as &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt;, where &lt;code&gt;argument_types&lt;/code&gt; is computed from &lt;code&gt;eltype&lt;/code&gt; applied to each input array.</source>
          <target state="translated">결과 행렬 의 요소 유형 &lt;code&gt;R&lt;/code&gt; 을 &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt; 로 계산합니다. 여기서 &lt;code&gt;argument_types&lt;/code&gt; 는 각 입력 배열에 적용된 &lt;code&gt;eltype&lt;/code&gt; 에서 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="a5e99cc7945246d96ba9d45a1ee951b06e431e6d" translate="yes" xml:space="preserve">
          <source>Compute the generalized SVD of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedSVD&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'&lt;/code&gt;</source>
          <target state="translated">일반화의 SVD 계산 및 &lt;code&gt;B&lt;/code&gt; 를 반환하는 &lt;code&gt;GeneralizedSVD&lt;/code&gt; 의 분해 오브젝트 &lt;code&gt;F&lt;/code&gt; 되도록 &lt;code&gt;[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'&lt;/code&gt; FV * F.D2] * F.R0 * F.Q ' &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eac1c8c9c47e0c367d8a880554c5ea2773fbaa1d" translate="yes" xml:space="preserve">
          <source>Compute the generalized SVD of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedSVD&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt;, such that &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; and &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; 및 &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt; 와 같이 &lt;code&gt;GeneralizedSVD&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환하여 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 SVD를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d2376ee0de00bcc15fd5a97c34b5145b4bf2e681" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9455f097ec080dbde6000f4b95c5aceb54405acc" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ee2c83b64cf586a8d935df80877c1c53e0f63b8" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡선 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c63e0fdffcada240fd739cc4ae974531cb4e6771" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{\sum x_i^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로 및 언더 플로를 피하면서 빗변 $ \ sqrt {\ sum x_i ^ 2} $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="064403ddc739fce0bb7520a4d1a9cfee6aa44aa6" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{\sum |x_i|^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로 및 언더 플로를 방지하는 빗변 $ \ sqrt {\ sum | x_i | ^ 2} $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a98476342e9a32121a3857c0c73120ddc38a7b27" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{x^2+y^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로 및 언더 플로를 피하면서 빗변 $ \ sqrt {x ^ 2 + y ^ 2} $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="6fa5e00480bf665715babd0683ebbea6a30f06ab" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{|x|^2+|y|^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로와 언더 플로를 피하면서 빗변 $ \ sqrt {| x | ^ 2 + | y ​​| ^ 2} $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="633ceda325459007865758a0c25ca9ff5d40d330" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="61c956ce405ed17444d2a843c6e0034449650e02" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b165af691a25cf7a4fe5189a3bdc95cf5605956a" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="624b23e348273fc6630a3591e94b2278279c23b8" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians</source>
          <target state="translated">출력이 라디안 인 &lt;code&gt;x&lt;/code&gt; 의 역 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6fc169a99667ef032612c7df05b276f67e73ab85" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cb2d41805a6658a7aa65e9db45a5f7a00e95b62d" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 인 &lt;code&gt;x&lt;/code&gt; 의 역 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="56d719cec6115d223ee7db48c9f3e019d2461e57" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="807f8ee5256662d4c4cbc7f7b897c32dc8916b59" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae3e0a4e6d92870c3f1d2c212c4b9c31c707de7" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="24d6944fdad3a15f1f900ff184e7c611309535a4" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 코사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4219876898544bb4f1d59746a8e545f1892d5a15" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_4&quot; id=&quot;citeref-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">정사각형 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡선 행렬 코사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_4&quot; id=&quot;citeref-AH16_4&quot;&gt;[AH16_4]를&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86cfc43a5a6c82e16a0bd6ad0cee64c1039344e2" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d69bf2784fba7079c9cbc6215616dcb27bb6831" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_5&quot; id=&quot;citeref-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">정사각형 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡선 행렬 사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_5&quot; id=&quot;citeref-AH16_5&quot;&gt;[AH16_5]를&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eaeedca65b3a8c87db844333fb8c7c021c9424a" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 탄젠트를 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac58e60f5d54bf8f91bdf125d9d491d07c8ca13f" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_6&quot; id=&quot;citeref-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">정사각형 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡선 행렬 탄젠트를 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_6&quot; id=&quot;citeref-AH16_6&quot;&gt;[AH16_6]을&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="139740116ef333d8f7864bd3d0441f3f0ed81cae" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e848138576f12626bbb3a4e1203f85a4ca3a1b" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="680c3b04c05aca283c4622eb58afd6457ddd9b27" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7c3a4c0cd5ecc1b9593ac0007373302db1fa6ec3" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c09cfcbaeb41a964e5eeda8044692db13c2de8" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="554fe6fb73f3b08cce5a611c6a50f4a680bb3671" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="0dd96c344ce6aeba2faf61b21fc85774face313f" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="13b94345110fabe0d3fb8e21298e94148893c47e" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="47dc0db5a1205ee0f8a515dc40cd98df08f88bcc" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡선 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b63a7a4eb8f986033eb32a665b6e261954bb34" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c87fce98f598dba189efeff4428b7d6efd962b" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82438e829448e338f5716124a7ced92061d94948" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f8fcadcd9398201528e6c6c31d135192b6517aa0" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3181cd6c2abdb611f89e0ecf6a62739daf49359f" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="40ba1792c624de0cb1dfc33c8587d7b068c312b3" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2c89d82e75f63a6879bfb124e5439e8f554c18b2" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="dea1f25c8cdb21558fa421f817fc4803838604fc" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;y/x&lt;/code&gt; 의 역 탄젠트를 각각 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="84e255dd37fccaa6c9024b56e1a156bcddadf711" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 또는 &lt;code&gt;y/x&lt;/code&gt; 의 역 탄젠트를 각각 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a437409e4208929c05cf3a26d531c19399ac90c7" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 10. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 로그 를 밑이 10 인 로그를 계산합니다 . 음의 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 대해서는 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="307aa19b57a1c93393b9992c4bb9222fbeb6d69a" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 2. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑을 밑이 2 인 로그를 계산합니다 . 음의 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 대해서는 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; 를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="357c0e09927961e89f5147d19aac01380699c99b" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosecant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8e5fa0eb0776b403f81e8ca8ffdd49ca084bc0cf" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4a3d2174cd407b931afd89c4da677e682e83eb75" translate="yes" xml:space="preserve">
          <source>Compute the matrix cotangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a0d7c646de45ee9b8c08cbdbcbbbe4ae72a7e16e" translate="yes" xml:space="preserve">
          <source>Compute the matrix exponential of &lt;code&gt;A&lt;/code&gt;, defined by</source>
          <target state="translated">에 의해 정의 된 &lt;code&gt;A&lt;/code&gt; 의 행렬 지수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1fd954e6ff4d674cda87b743aa2b1233b9a2eb54" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosecant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="38b827146b68bcb3a9319674be38c266cf7e7f83" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="110c3b9acb774724db674308a4bcde13d16b14d6" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cotangent of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0510bcda1371513244fd5ba762aa98507b53bb" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic secant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 secant를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="69f5be6dce72711b7e92f9794c37163a41bcaec9" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="68030614e2cc86a2f04214ee54bc242637c1d83e" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a49ce1d636974c76079f6e75f270fb5680236ccd" translate="yes" xml:space="preserve">
          <source>Compute the matrix secant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8537b2719b34f9b953a571d36d5cd503fc126fb6" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine and cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 사인과 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c790b1bd7335f67a22b7547277d010ba0a9f3b0b" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="778966213f7c95c7b1093b4b2daad349ac3b974d" translate="yes" xml:space="preserve">
          <source>Compute the matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9eb474e2115ce973af39e55c69108d56b7159747" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">싱글 톤 크기 &lt;code&gt;r&lt;/code&gt; 에 대해 &lt;code&gt;A&lt;/code&gt; 의 최대 값을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="812480b7cd3cf22547511e3adad6b33995a9beff" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.max&quot;&gt;&lt;code&gt;max(a,b)&lt;/code&gt;&lt;/a&gt; function to take the maximum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;max.(a,b)&lt;/code&gt;.</source>
          <target state="translated">주어진 차원에서 배열의 최대 값을 계산합니다. &lt;code&gt;max.(a,b)&lt;/code&gt; 를 통해 배열에 요소별로 적용 할 수있는 최대 두 개 이상의 인수를 가져 오려면 &lt;a href=&quot;../math/index#Base.max&quot;&gt; &lt;code&gt;max(a,b)&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9b9b399a0d3918c3f6e362f2833628ccc71a99" translate="yes" xml:space="preserve">
          <source>Compute the mean of &lt;code&gt;v&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 싱글 톤 차원에 대해 &lt;code&gt;v&lt;/code&gt; 의 평균을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="11000a28bead3ac6f75bf9a14466e14072624576" translate="yes" xml:space="preserve">
          <source>Compute the mean of all elements in a collection.</source>
          <target state="translated">컬렉션에있는 모든 요소의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="99f6794cd06dba199884516b785bda4fd78aa2a1" translate="yes" xml:space="preserve">
          <source>Compute the mean of an array over the given dimensions.</source>
          <target state="translated">주어진 차원에 대해 배열의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f41aac2dc5d7c7dc8f7a1f9ae372c9c476523577" translate="yes" xml:space="preserve">
          <source>Compute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</source>
          <target state="translated">컬렉션에있는 모든 요소의 중앙값을 계산합니다. 짝수의 요소의 경우 정확한 중간 요소가 없으므로 결과는 두 중간 요소의 평균을 계산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47aa9c53937737d70bd22425272809e6211e7bf6" translate="yes" xml:space="preserve">
          <source>Compute the median of an array along the given dimensions.</source>
          <target state="translated">주어진 차원을 따라 배열의 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c99652c33628269108c328437953d38055c5886" translate="yes" xml:space="preserve">
          <source>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</source>
          <target state="translated">극한의 평균을 계산하는 범위의 중간을 계산합니다. 범위가 정렬되므로 평균은 첫 번째 요소와 마지막 요소로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f52205089fbf6d58facb1bdb9b160b88b107a323" translate="yes" xml:space="preserve">
          <source>Compute the middle of a scalar value, which is equivalent to &lt;code&gt;x&lt;/code&gt; itself, but of the type of &lt;code&gt;middle(x, x)&lt;/code&gt; for consistency.</source>
          <target state="translated">스칼라 값의 중간을 계산합니다. 스칼라 값은 &lt;code&gt;x&lt;/code&gt; 자체 와 동일 하지만 일관성을 위해 &lt;code&gt;middle(x, x)&lt;/code&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="acf08f804a346435085af253987f1d511b1a7d4c" translate="yes" xml:space="preserve">
          <source>Compute the middle of an array &lt;code&gt;a&lt;/code&gt;, which consists of finding its extrema and then computing their mean.</source>
          <target state="translated">배열의 중간을 계산합니다. &lt;code&gt;a&lt;/code&gt; 는 극한값을 찾은 다음 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f0245cd1be7817ce631eac5c33e8ccdf05cebd05" translate="yes" xml:space="preserve">
          <source>Compute the middle of two reals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, which is equivalent in both value and type to computing their mean (&lt;code&gt;(x + y) / 2&lt;/code&gt;).</source>
          <target state="translated">두 개의 실수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 중간을 계산합니다 . 이는 값과 유형이 평균 ( &lt;code&gt;(x + y) / 2&lt;/code&gt; ) 을 계산하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="949e7136a76fe46a6048f43ad9bc9f806861c7ea" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum elements of an array over the given dimensions.</source>
          <target state="translated">주어진 차원에서 배열의 최소 및 최대 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0d93ec1caffd4ccc7c3361a7c270c2d973854682" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in the given dimensions of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;A&lt;/code&gt; 의 차원에서 각 요소에 적용된 최소값과 최대 값 &lt;code&gt;f&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82e7ee5156f49d8db2d03ced16867f73d00a142d" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">싱글 톤 차원 &lt;code&gt;r&lt;/code&gt; 에 대해 &lt;code&gt;A&lt;/code&gt; 의 최소값을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ed6b522c97de9bddde22add7ab86b59b7c15f878" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.min&quot;&gt;&lt;code&gt;min(a,b)&lt;/code&gt;&lt;/a&gt; function to take the minimum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;min.(a,b)&lt;/code&gt;.</source>
          <target state="translated">주어진 차원에서 배열의 최소값을 계산합니다. 최소 두 개 이상의 인수를 취 하려면 &lt;a href=&quot;../math/index#Base.min&quot;&gt; &lt;code&gt;min(a,b)&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오. &lt;code&gt;min.(a,b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7ac1e0e474d1b1a9d181c27f50c39ecd473625" translate="yes" xml:space="preserve">
          <source>Compute the natural base exponential of &lt;code&gt;x&lt;/code&gt;, in other words $e^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 자연 기본 지수를 계산합니다 , 즉 $ e ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ff348abb57d70ef01b2fee18c2e56b5e9c90ef5b" translate="yes" xml:space="preserve">
          <source>Compute the natural logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments. Use complex negative arguments to obtain complex results.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 자연 로그를 계산합니다 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 을&lt;/a&gt; 부정하기위한 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 인수입니다. 복소수 인수를 사용하여 복소수 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d39d60a66827c670830ca96a819f42207f21a2dd" translate="yes" xml:space="preserve">
          <source>Compute the number of digits in integer &lt;code&gt;n&lt;/code&gt; written in base &lt;code&gt;base&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; must not be in &lt;code&gt;[-1, 0, 1]&lt;/code&gt;), optionally padded with zeros to a specified size (the result will never be less than &lt;code&gt;pad&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;base&lt;/code&gt; 작성된 정수 &lt;code&gt;n&lt;/code&gt; 의 자릿수를 계산합니다 ( &lt;code&gt;base&lt;/code&gt; 은 &lt;code&gt;[-1, 0, 1]&lt;/code&gt; 이어야 함 ). 선택적으로 0으로 지정된 크기로 채워집니다 (결과는 &lt;code&gt;pad&lt;/code&gt; 보다 작을 수 없습니다) ).</target>
        </trans-unit>
        <trans-unit id="cdf0b4d7ddc06f4032604ad606ae2fa5da2f3e57" translate="yes" xml:space="preserve">
          <source>Compute the operator norm (or matrix norm) induced by the vector &lt;code&gt;p&lt;/code&gt;-norm, where valid values of &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;Inf&lt;/code&gt;. (Note that for sparse matrices, &lt;code&gt;p=2&lt;/code&gt; is currently not implemented.) Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the Frobenius norm.</source>
          <target state="translated">유효한 &lt;code&gt;p&lt;/code&gt; 값 이 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;Inf&lt;/code&gt; 인 벡터 &lt;code&gt;p&lt;/code&gt; - norm에 의해 유도 된 연산자 규범 (또는 행렬 규범)을 계산합니다 . 희소 행렬의 경우 &lt;code&gt;p=2&lt;/code&gt; 는 현재 구현되어 있지 않습니다. &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 사용 Frobenius 표준을 계산 을 .</target>
        </trans-unit>
        <trans-unit id="875c419b65242063b15574011e9a9ebe51310e17" translate="yes" xml:space="preserve">
          <source>Compute the phase angle in radians of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 라디안으로 위상 각 계산 .</target>
        </trans-unit>
        <trans-unit id="f2bfc336c71f0f166834e6af3305ab8164da5ce4" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LU&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LU&lt;/code&gt; 의 피벗 된 &lt;code&gt;LU&lt;/code&gt; 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d34ac6dfa1e6722e524c60e67afe891d8e958d" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f61896259e546ab5dfa4229a9ef0511c5d923d39" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;jpvt&lt;/code&gt; must have length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다. &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;jpvt&lt;/code&gt; 로 표시되는 피벗 행렬 입니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;(m x n)&lt;/code&gt; 행렬 인 경우 &lt;code&gt;jpvt&lt;/code&gt; 의 길이 는 &lt;code&gt;n&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="67444724cffb3267e5fd7af13f87a5b4b21f933f" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; stores the elementary reflectors. &lt;code&gt;jpvt&lt;/code&gt; must have length length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다. &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;jpvt&lt;/code&gt; 로 표시되는 피벗 행렬 입니다. &lt;code&gt;tau&lt;/code&gt; 는 기본 반사기를 저장합니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;(m x n)&lt;/code&gt; 행렬 인 경우 &lt;code&gt;jpvt&lt;/code&gt; 의 길이 는 &lt;code&gt;n&lt;/code&gt; 보다 크거나 같아야합니다 . &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="c597ab7f1b620fda0abef71fc126c9801e72086f" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; stores the elementary reflectors. The arguments &lt;code&gt;jpvt&lt;/code&gt; and &lt;code&gt;tau&lt;/code&gt; are optional and allow for passing preallocated arrays. When passed, &lt;code&gt;jpvt&lt;/code&gt; must have length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix and &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다. &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;jpvt&lt;/code&gt; 로 표시되는 피벗 행렬 입니다. &lt;code&gt;tau&lt;/code&gt; 는 기본 반사경을 저장합니다. 인수 &lt;code&gt;jpvt&lt;/code&gt; 및 &lt;code&gt;tau&lt;/code&gt; 는 선택 사항이며 사전 할당 된 배열을 전달할 수 있습니다. 전달 될 때 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;(m x n)&lt;/code&gt; 행렬 인 경우 &lt;code&gt;jpvt&lt;/code&gt; 는 길이가 &lt;code&gt;n&lt;/code&gt; 이상이어야 하고 &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 가장 작은 차원보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3be9574f6c1b531ee6e117bea8e3a59d235a7898" translate="yes" xml:space="preserve">
          <source>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.CholeskyPivoted&quot;&gt;&lt;code&gt;CholeskyPivoted&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;CholeskyPivoted&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.rank&quot;&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/a&gt;. The argument &lt;code&gt;tol&lt;/code&gt; determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</source>
          <target state="translated">조밀 한 대칭 긍정적 인 반 명확한 매트릭스의 선회 콜레 인수 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;a href=&quot;#LinearAlgebra.CholeskyPivoted&quot;&gt; &lt;code&gt;CholeskyPivoted&lt;/code&gt; 의&lt;/a&gt; 인수 분해를. 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt; 또는 &lt;em&gt;완전&lt;/em&gt; 대칭 또는 Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 일 수 있습니다. 삼각형 콜레 계수는 인수 분해에서 얻을 수 있습니다 &lt;code&gt;F&lt;/code&gt; :와 &lt;code&gt;F.L&lt;/code&gt; 과 &lt;code&gt;F.U&lt;/code&gt; . 다음 함수는 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 객체에 사용할 수 있습니다. &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#LinearAlgebra.rank&quot;&gt; &lt;code&gt;rank&lt;/code&gt; &lt;/a&gt; . 인수 &lt;code&gt;tol&lt;/code&gt; 은 순위 결정에 대한 허용 오차를 결정합니다. 음수 값의 경우 공차는 기계 정밀도입니다.</target>
        </trans-unit>
        <trans-unit id="9ff2d7fc77ed33a91ba59f92eb332d8bf62ed2de" translate="yes" xml:space="preserve">
          <source>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;CholeskyPivoted&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;CholeskyPivoted&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.rank&quot;&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/a&gt;. The argument &lt;code&gt;tol&lt;/code&gt; determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</source>
          <target state="translated">조밀 한 대칭 긍정적 인 반 명확한 매트릭스의 선회 콜레 인수 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 의 인수 분해를. 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 또는 &lt;em&gt;완벽하게&lt;/em&gt; 대칭 또는 Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 일 수 있습니다. 삼각형 콜레 계수는 인수 분해에서 얻을 수 있습니다 &lt;code&gt;F&lt;/code&gt; :와 &lt;code&gt;F.L&lt;/code&gt; 과 &lt;code&gt;F.U&lt;/code&gt; . 다음과 같은 기능을 사용할 수 있습니다 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 의 개체 : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#LinearAlgebra.rank&quot;&gt; &lt;code&gt;rank&lt;/code&gt; &lt;/a&gt; . 인수 &lt;code&gt;tol&lt;/code&gt; 은 순위를 결정하기위한 허용 오차를 결정합니다. 음수 값의 경우 공차는 기계 정밀도입니다.</target>
        </trans-unit>
        <trans-unit id="b64ceade01dfafb5bfec886e80d298d8030e7599" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a collection &lt;code&gt;itr&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;itr&lt;/code&gt; can be assumed to be sorted.</source>
          <target state="translated">간격 [0,1] 에서 지정된 확률 또는 벡터 또는 확률의 튜플 &lt;code&gt;p&lt;/code&gt; 에서 컬렉션 &lt;code&gt;itr&lt;/code&gt; 의 Quantile을 계산합니다 . 키워드 인수 &lt;code&gt;sorted&lt;/code&gt; 있는지 여부를 나타냅니다 &lt;code&gt;itr&lt;/code&gt; 정렬 할 가정 할 수있다.</target>
        </trans-unit>
        <trans-unit id="eb2c3240f4729969dc3c9a6a7351fdcf66f680d9" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a vector &lt;code&gt;v&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. If &lt;code&gt;p&lt;/code&gt; is a vector, an optional output array &lt;code&gt;q&lt;/code&gt; may also be specified. (If not provided, a new output array is created.) The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;v&lt;/code&gt; can be assumed to be sorted; if &lt;code&gt;false&lt;/code&gt; (the default), then the elements of &lt;code&gt;v&lt;/code&gt; will be partially sorted in-place.</source>
          <target state="translated">구간 [0,1] 에서 지정된 확률 또는 벡터 또는 확률의 튜플 &lt;code&gt;p&lt;/code&gt; 에서 벡터 &lt;code&gt;v&lt;/code&gt; 의 Quantile (s)을 계산합니다 . 경우 &lt;code&gt;p&lt;/code&gt; 는 벡터이며, 선택 어레이의 출력 &lt;code&gt;q&lt;/code&gt; 또한 지정 될 수있다. (제공되지 않은 경우 새 출력 배열이 작성됩니다.) &lt;code&gt;sorted&lt;/code&gt; 키워드 인수 는 &lt;code&gt;v&lt;/code&gt; 를 정렬한다고 가정 할 수 있는지 여부를 나타냅니다 . &lt;code&gt;false&lt;/code&gt; 인 경우 (기본값) &lt;code&gt;v&lt;/code&gt; 의 요소 부분적으로 적절한 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb368cffdd0709c3136c6eb4be4a7856720c163" translate="yes" xml:space="preserve">
          <source>Compute the rank of a matrix by counting how many singular values of &lt;code&gt;A&lt;/code&gt; have magnitude greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;A&lt;/code&gt;'s largest singular value. &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; are the absolute and relative tolerances, respectively. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 특이 값 이 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 보다 큰 수 를 계산하여 행렬의 순위를 계산합니다. 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 가장 큰 특이 값입니다. &lt;code&gt;atol&lt;/code&gt; 및 &lt;code&gt;rtol&lt;/code&gt; 은 각각 절대 및 상대 공차입니다. 기본 상대 공차는 &lt;code&gt;n*ϵ&lt;/code&gt; 이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 가장 작은 치수의 크기 이고 &lt;code&gt;ϵ&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 요소 유형의 &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="dc3f685504afbf8552c15cce21aef6fd26ceffd0" translate="yes" xml:space="preserve">
          <source>Compute the remainder of &lt;code&gt;x&lt;/code&gt; after integer division by &lt;code&gt;2&amp;pi;&lt;/code&gt;, with the quotient rounded according to the rounding mode &lt;code&gt;r&lt;/code&gt;. In other words, the quantity</source>
          <target state="translated">정수를 &lt;code&gt;2&amp;pi;&lt;/code&gt; 후 나머지 &lt;code&gt;x&lt;/code&gt; 를 2&amp;pi;로 계산하고 , 몫은 반올림 모드 &lt;code&gt;r&lt;/code&gt; 에 따라 반올림됩니다 . 즉, 수량</target>
        </trans-unit>
        <trans-unit id="95bc53629637126df14c31c62a968cf7ac84be97" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">알려진 평균 &lt;code&gt;m&lt;/code&gt; 으로 수집 &lt;code&gt;itr&lt;/code&gt; 의 표본 표준 편차를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="fa7acbca757d81bef6a91c9c0935f098eab6b4f2" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="translated">컬렉션의 샘플 표준 편차 계산 &lt;code&gt;itr&lt;/code&gt; 공지 평균 (S)와, &lt;code&gt;mean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2013d0ec88dc549aea8806964d8579f321782fa9" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">collection &lt;code&gt;itr&lt;/code&gt; 의 표본 표준 편차를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2e6293fe931efad035e3dce11f90fbf4d514cf36" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">알려진 평균 &lt;code&gt;m&lt;/code&gt; 을 사용 하여 콜렉션 &lt;code&gt;itr&lt;/code&gt; 의 표본 분산을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="80514eb7c2c8ed67bdfdc0c57c67b78f896d8aff" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="translated">알려진 mean (s) &lt;code&gt;mean&lt;/code&gt; 을 사용 하여 수집 &lt;code&gt;itr&lt;/code&gt; 의 표본 분산을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ad72bb7d52a6f023ffd8fa5902e661aa205b2ef" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">콜렉션 &lt;code&gt;itr&lt;/code&gt; 의 표본 분산을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d52f9b298abf8ef3482717a4fb7d6eb7739d6697" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">계산의 할선 &lt;code&gt;x&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="56e3ce8cc803e620031d7e7d69e643ba6f727c31" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">계산의 할선 &lt;code&gt;x&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 는 라디안이다.</target>
        </trans-unit>
        <trans-unit id="2d6fc0ea82100c7979c18fab715864258d67fcaf" translate="yes" xml:space="preserve">
          <source>Compute the singular value decomposition (SVD) of &lt;code&gt;A&lt;/code&gt; and return an &lt;code&gt;SVD&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 특이 값 분해 (SVD)를 계산하고 &lt;code&gt;SVD&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="18a494aebbe2cd9c9cce0054d7ab6b3d0c0ca78c" translate="yes" xml:space="preserve">
          <source>Compute the variance of the vector &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = length(x)&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 의 분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;n = length(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76f4235dabe6a4763d3b8a0de229f70ac1e52a88" translate="yes" xml:space="preserve">
          <source>Compute-bound, non-memory-allocating tasks can prevent garbage collection from running in other threads that are allocating memory. In these cases it may be necessary to insert a manual call to &lt;code&gt;GC.safepoint()&lt;/code&gt; to allow GC to run. This limitation will be removed in the future.</source>
          <target state="translated">컴퓨팅 바운드, 비 메모리 할당 작업은 메모리를 할당하는 다른 스레드에서 가비지 수집이 실행되는 것을 방지 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이러한 경우 GC가 실행될 수 있도록 &lt;code&gt;GC.safepoint()&lt;/code&gt; 에 대한 수동 호출을 삽입해야 할 수 있습니다 . 이 제한은 향후 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="196dea2d8876d4f497fbf30018e3df07bf112e07" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;gelqf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="330b5ac4ec8258723cd692371fc2e6df49989d5c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqlf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 분해에서 . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="23c10a1f9dd38caaf076a8b1a4a078298190e02c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqrf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 분해에서 . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="c1e711025c5d1686044686723b7e4084534f7793" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrt!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqrt!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="3eae30893a76f76ba0b80fe1f33ca60ccd4a1a80" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;gerqf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="15574eb06b260c277bf93ed3b4e329832dc2d2b0" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;x*y+z&lt;/code&gt; without rounding the intermediate result &lt;code&gt;x*y&lt;/code&gt;. On some systems this is significantly more expensive than &lt;code&gt;x*y+z&lt;/code&gt;. &lt;code&gt;fma&lt;/code&gt; is used to improve accuracy in certain algorithms. See &lt;a href=&quot;#Base.muladd&quot;&gt;&lt;code&gt;muladd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">중간 결과 &lt;code&gt;x*y&lt;/code&gt; 를 반올림하지 않고 &lt;code&gt;x*y+z&lt;/code&gt; 를 계산 합니다. 일부 시스템에서는 &lt;code&gt;x*y+z&lt;/code&gt; 보다 훨씬 비쌉니다 . &lt;code&gt;fma&lt;/code&gt; 는 특정 알고리즘에서 정확도를 향상시키는 데 사용됩니다. &lt;a href=&quot;#Base.muladd&quot;&gt; &lt;code&gt;muladd&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d85408fc3f46bcd68209a106a2a685b34165a916" translate="yes" xml:space="preserve">
          <source>Computes a basis for the nullspace of &lt;code&gt;M&lt;/code&gt; by including the singular vectors of &lt;code&gt;M&lt;/code&gt; whose singular values have magnitudes greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt;, where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;M&lt;/code&gt;'s largest singular value.</source>
          <target state="translated">특이 값이 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 보다 큰 크기를 갖는 &lt;code&gt;M&lt;/code&gt; 의 특이 벡터를 포함하여 &lt;code&gt;M&lt;/code&gt; 의 영 공간에 대한 기저를 계산합니다 . 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 의 가장 큰 특이 값입니다.</target>
        </trans-unit>
        <trans-unit id="f8d2bf90fe337bc19a74db83f3cf8ee951ffa605" translate="yes" xml:space="preserve">
          <source>Computes a basis for the nullspace of &lt;code&gt;M&lt;/code&gt; by including the singular vectors of A whose singular have magnitude are greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt;, where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;M&lt;/code&gt;'s largest singularvalue.</source>
          <target state="translated">특이 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 크기가 max (atol, rtol * &amp;sigma;₁) 보다 큰 A의 특이 벡터를 포함하여 &lt;code&gt;M&lt;/code&gt; 의 영 공간에 대한 기초를 계산합니다 . 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 최대 특이 값입니다.</target>
        </trans-unit>
        <trans-unit id="d36744afe997ffcda5697a0694557892f6eb5206" translate="yes" xml:space="preserve">
          <source>Computes the (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) pivoted Cholesky decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt; with a user-set tolerance &lt;code&gt;tol&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition.</source>
          <target state="translated">사용자 설정 허용 오차 &lt;code&gt;tol&lt;/code&gt; 을 사용하여 양의 유한 행렬 &lt;code&gt;A&lt;/code&gt; 의 Cholesky 분해를 계산 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;uplo = L&lt;/code&gt; , uplo = L 인 경우 하단)을 계산합니다 . Cholesky 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fd36c39296e253cc9d8a070bacaf4f4bf9b57780" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">에르 미트 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman 인수 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다.</target>
        </trans-unit>
        <trans-unit id="22428da5be587cdee5b6c05cffa201cf9861cc3c" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman 인수 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다.</target>
        </trans-unit>
        <trans-unit id="f19c7e8b3174b328131e9e17030c6148cf8f127e" translate="yes" xml:space="preserve">
          <source>Computes the Cholesky (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten and returned with an info code.</source>
          <target state="translated">양의 유한 행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;uplo = U&lt;/code&gt; 스키 ( uplo = U 인 경우 상위 , &lt;code&gt;uplo = L&lt;/code&gt; 경우 하위 분해)를 계산합니다 . &lt;code&gt;A&lt;/code&gt; 를 덮어 쓰고 정보 코드로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cafabd44437dbd8e485ca59504c069c025da1ad" translate="yes" xml:space="preserve">
          <source>Computes the Generalized Schur (or QZ) factorization of the matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The (quasi) triangular Schur factors can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt; and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 Schur (또는 QZ) 인수 분해를 계산합니다 . &lt;code&gt;F.S&lt;/code&gt; 및 &lt;code&gt;F.T&lt;/code&gt; 갖는 &lt;code&gt;Schur&lt;/code&gt; 객체 &lt;code&gt;F&lt;/code&gt; 로부터 (quasi) 삼각 슈어 팩터가 얻어 질 수 있고 , 좌측 유니 터리 / 직교 슈어 벡터는 &lt;code&gt;F.left&lt;/code&gt; 또는 &lt;code&gt;F.Q&lt;/code&gt; 로 얻어 질 수 있고 우측 유니 터리 / 직교 슈어 벡터는 &lt;code&gt;F.right&lt;/code&gt; 로 얻어 질 수있다 . 오른쪽 또는 &lt;code&gt;F.Z&lt;/code&gt; 되도록 &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; 및 &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값은 로 구할 수 있습니다 . &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3efb8aa207d5af77f49688b04559bb67415cf85e" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that for any vector &lt;code&gt;x&lt;/code&gt; where</source>
          <target state="translated">Givens 회전 &lt;code&gt;G&lt;/code&gt; 와 스칼라 &lt;code&gt;r&lt;/code&gt; 을 계산하여 모든 벡터 &lt;code&gt;x&lt;/code&gt; 에 대해 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3b7b86c4db1c49294f9afcc1c05c3a761727f9b0" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that the result of the multiplication</source>
          <target state="translated">곱셈의 결과가 되도록 기븐스 회전 &lt;code&gt;G&lt;/code&gt; 와 스칼라 &lt;code&gt;r&lt;/code&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="db4721bd00c3c65fe61a8b0bdb9fd8f8985ae6ed" translate="yes" xml:space="preserve">
          <source>Computes the LDLt factorization of a positive-definite tridiagonal matrix with &lt;code&gt;D&lt;/code&gt; as diagonal and &lt;code&gt;E&lt;/code&gt; as off-diagonal. &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are overwritten and returned.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; 를 대각선으로, &lt;code&gt;E&lt;/code&gt; 를 비 대각선 으로 사용하여 양의 유한 삼각 행렬의 LDLt 인수 분해를 계산합니다 . &lt;code&gt;D&lt;/code&gt; 와 &lt;code&gt;E&lt;/code&gt; 를 덮어 쓰고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="915ececcc0f410ce7a63643c0b6e374861bcd250" translate="yes" xml:space="preserve">
          <source>Computes the Moore-Penrose pseudoinverse.</source>
          <target state="translated">무어-펜로즈 유사 역사를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6055e64119c4c7498a33b99f97eb16c43da95186" translate="yes" xml:space="preserve">
          <source>Computes the Schur factorization of the matrix &lt;code&gt;A&lt;/code&gt;. The (quasi) triangular Schur factor can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors can be obtained with &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 Schur 인수 분해를 계산합니다 . 로부터 수득 될 수있는 삼각 슈어 배율이 (준) &lt;code&gt;Schur&lt;/code&gt; 오브젝트 &lt;code&gt;F&lt;/code&gt; 중 어느 하나에 &lt;code&gt;F.Schur&lt;/code&gt; 또는 &lt;code&gt;F.T&lt;/code&gt; 및 직교 / 슈어 단위 벡터를 얻을 수있다 &lt;code&gt;F.vectors&lt;/code&gt; 이나 &lt;code&gt;F.Z&lt;/code&gt; 되도록 &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt; 입니다. &lt;code&gt;A&lt;/code&gt; 의 고유 값은 &lt;code&gt;F.values&lt;/code&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be77495485da8e82a774262ef640c248f097d559" translate="yes" xml:space="preserve">
          <source>Computes the eigensystem for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;job = N&lt;/code&gt; only the eigenvalues are found and returned in &lt;code&gt;dv&lt;/code&gt;. If &lt;code&gt;job = V&lt;/code&gt; then the eigenvectors are also found and returned in &lt;code&gt;Zmat&lt;/code&gt;.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 삼각대 각 행렬에 대한 고유 시스템을 계산합니다 . 경우 &lt;code&gt;job = N&lt;/code&gt; 에만 고유 값을 찾아 반환되는 &lt;code&gt;dv&lt;/code&gt; . 경우 &lt;code&gt;job = V&lt;/code&gt; 그 고유 벡터는 발견에 반환됩니다 &lt;code&gt;Zmat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d55bd3d8ada3bc88d1bea445d75e91aceef15776" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt;, returning an &lt;a href=&quot;#LinearAlgebra.Eigen&quot;&gt;&lt;code&gt;Eigen&lt;/code&gt;&lt;/a&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 의 열에있는 고유 벡터 를 포함 하는 &lt;a href=&quot;#LinearAlgebra.Eigen&quot;&gt; &lt;code&gt;Eigen&lt;/code&gt; &lt;/a&gt; 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="c0c2d756bd2ee3d8520442f71f1acb8461142c55" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt;, returning an &lt;code&gt;Eigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 열의 고유 벡터 를 포함 하는 &lt;code&gt;Eigen&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="56ef3f44145e5cbb1d7b50f00f2bd9fcc16d97eb" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobvs = N&lt;/code&gt;) or the eigenvalues and Schur vectors (&lt;code&gt;jobvs = V&lt;/code&gt;) of matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Schur form.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobvs = N&lt;/code&gt; ) 또는 고유 값과 Schur 벡터 ( &lt;code&gt;jobvs = V&lt;/code&gt; )를 계산 합니다. &lt;code&gt;A&lt;/code&gt; 는 Schur 양식으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a3a0443d72fdbb0792684407d1da11dd17bf077" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. The eigenvalues are returned in &lt;code&gt;w&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 3 &lt;code&gt;jobz = V&lt;/code&gt; 행렬에 대한 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( jobz = V )를 계산합니다 . 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 만약 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 발견된다. 경우 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. 고유 값이 반환된다 &lt;code&gt;w&lt;/code&gt; 및 고유 벡터의 &lt;code&gt;Z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702fe6d75fff16642d7459ba596ae090bfec93a0" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. If &lt;code&gt;order = B&lt;/code&gt;, eigvalues are ordered within a block. If &lt;code&gt;order = E&lt;/code&gt;, they are ordered across all the blocks. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 삼각대 각 행렬의 고유 값을 계산합니다 . 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 경우 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 발견된다. 경우 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. 경우 &lt;code&gt;order = B&lt;/code&gt; , eigvalues가 블록 내에서 정렬된다. 만약 &lt;code&gt;order = E&lt;/code&gt; 이면 모든 블록에 걸쳐 정렬되며 &lt;code&gt;abstol&lt;/code&gt; 은 수렴에 대한 공차로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2774f3063f2166a20accf4c30f58fa05930aee13" translate="yes" xml:space="preserve">
          <source>Computes the eigenvectors for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev_in&lt;/code&gt; as off-diagonal. &lt;code&gt;w_in&lt;/code&gt; specifies the input eigenvalues for which to find corresponding eigenvectors. &lt;code&gt;iblock_in&lt;/code&gt; specifies the submatrices corresponding to the eigenvalues in &lt;code&gt;w_in&lt;/code&gt;. &lt;code&gt;isplit_in&lt;/code&gt; specifies the splitting points between the submatrix blocks.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev_in&lt;/code&gt; 인 대칭 삼각대 각 행렬에 대한 고유 벡터를 계산합니다 . &lt;code&gt;w_in&lt;/code&gt; 은 해당 고유 벡터를 찾을 입력 고유 값을 지정합니다. &lt;code&gt;iblock_in&lt;/code&gt; 은 &lt;code&gt;w_in&lt;/code&gt; 의 고유 값에 해당하는 하위 행렬을 지정합니다 . &lt;code&gt;isplit_in&lt;/code&gt; 은 서브 매트릭스 블록 사이의 분할 지점을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9279d5825ee8c8627fd1fe8e8ebf71ef81d80096" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;a href=&quot;#LinearAlgebra.GeneralizedEigen&quot;&gt;&lt;code&gt;GeneralizedEigen&lt;/code&gt;&lt;/a&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the generalized eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the generalized eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th generalized eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 일반화 된 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 의 열에있는 일반화 된 고유 벡터 를 포함 하는 &lt;a href=&quot;#LinearAlgebra.GeneralizedEigen&quot;&gt; &lt;code&gt;GeneralizedEigen&lt;/code&gt; &lt;/a&gt; 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 일반화 된 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="22cb9800f1213961f1d9d7750f55ad1f1358c888" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedEigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the generalized eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the generalized eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th generalized eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 일반 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 의 열에 일반 고유 벡터 가 포함 &lt;code&gt;GeneralizedEigen&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 일반화 된 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="02b33b45277ccf1798c5db9f681b4fbc2af0b721" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="30705de9147ff967461851722fa377560561d2ce" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (&lt;code&gt;jobsvl = V&lt;/code&gt;), or right Schur vectors (&lt;code&gt;jobvsr = V&lt;/code&gt;) of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값, 일반 Schur 양식, 왼쪽 Schur 벡터 ( &lt;code&gt;jobsvl = V&lt;/code&gt; ) 또는 오른쪽 Schur 벡터 ( &lt;code&gt;jobvsr = V&lt;/code&gt; )를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="7d9d5c41f59e436c6611c2108f610d3d4369c1d3" translate="yes" xml:space="preserve">
          <source>Computes the greatest common (positive) divisor of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and their B&amp;eacute;zout coefficients, i.e. the integer coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; that satisfy $ux+vy = d = gcd(x,y)$. $gcdx(x,y)$ returns $(d,u,v)$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 최대 공약 (긍정) 제수 와 B&amp;eacute;zout 계수, 즉 $ ux + vy = d = gcd (x, y) $를 만족 하는 정수 계수 &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 를 계산 합니다. $ gcdx (x, y) $는 $ (d, u, v) $를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d356d77cd7680b87bc3b49a0e273970ad7f27896" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;code&gt;A&lt;/code&gt;, using its &lt;code&gt;LU&lt;/code&gt; factorization found by &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;ipiv&lt;/code&gt; is the pivot information output and &lt;code&gt;A&lt;/code&gt; contains the &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">&lt;code&gt;getrf!&lt;/code&gt; 찾은 &lt;code&gt;LU&lt;/code&gt; 인수 분해를 사용하여 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 . . &lt;code&gt;ipiv&lt;/code&gt; 는 피벗 정보 출력이고 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;getrf!&lt;/code&gt; 의 &lt;code&gt;LU&lt;/code&gt; 분해를 포함합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="cb2e1de5980a4a4f0fbdf482a5ea64f2c959a899" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a Hermitian matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">&lt;code&gt;sytrf!&lt;/code&gt; 의 결과를 사용하여 에르 미트 행렬 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 ! . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="39d4577d522bd768286b7114ac09a7dc67a68d58" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a symmetric matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">&lt;code&gt;sytrf!&lt;/code&gt; 의 결과를 사용하여 대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 . . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="aa616fdc7bbc88179bfd3ddbbcdba42b387701e0" translate="yes" xml:space="preserve">
          <source>Computes the inverse of positive-definite matrix &lt;code&gt;A&lt;/code&gt; after calling &lt;code&gt;potrf!&lt;/code&gt; to find its (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) Cholesky decomposition.</source>
          <target state="translated">&lt;code&gt;potrf!&lt;/code&gt; 를 호출 &lt;code&gt;A&lt;/code&gt; 후 양의 유한 행렬 A 의 역을 계산합니다 ! Cholesky 분해 를 찾기 위해 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;uplo = L&lt;/code&gt; , uplo = L 인 경우 낮추십시오 ).</target>
        </trans-unit>
        <trans-unit id="d0e374af8acff15741567ccb37ae6e22ca3d3352" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the &lt;code&gt;SVD&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">최소한의 표준 용액 계산 &lt;code&gt;A * X = B&lt;/code&gt; 발견하여 &lt;code&gt;SVD&lt;/code&gt; 에 의 인수 &lt;code&gt;A&lt;/code&gt; 다음 분할 및 정복 문제. &lt;code&gt;B&lt;/code&gt; 솔루션 &lt;code&gt;X&lt;/code&gt; 로 를 덮어 씁니다 . &lt;code&gt;rcond&lt;/code&gt; 아래의 특이 값 은 0으로 처리됩니다. 에서 솔루션 반환 &lt;code&gt;B&lt;/code&gt; 와의 효과적인 순위 에 &lt;code&gt;rnk&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9772f2cb554e6714e2d0249e5923646b5c83167" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the full &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">최소한의 표준 용액 계산 &lt;code&gt;A * X = B&lt;/code&gt; 전체 찾아 &lt;code&gt;QR&lt;/code&gt; 에 의 인수 &lt;code&gt;A&lt;/code&gt; 다음 분할 및 정복 문제. 솔루션으로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;X&lt;/code&gt; 로 . &lt;code&gt;rcond&lt;/code&gt; 아래의 특이 값 은 0으로 처리됩니다. 에서 솔루션 반환 &lt;code&gt;B&lt;/code&gt; 와의 효과적인 순위 에 &lt;code&gt;rnk&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce03bad87638dae01e4efdac4ef134e0c01c10b0" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal using a divide and conqueq method. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. If &lt;code&gt;compq = N&lt;/code&gt;, only the singular values are found. If &lt;code&gt;compq = I&lt;/code&gt;, the singular values and vectors are found. If &lt;code&gt;compq = P&lt;/code&gt;, the singular values and vectors are found in compact form. Only works for real types.</source>
          <target state="translated">나누기 및 conqueq 방법을 사용하여 대각선의 &lt;code&gt;d&lt;/code&gt; 와 대각선의 &lt;code&gt;e_&lt;/code&gt; 를 사용하여 양각 행렬의 특이 값 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; superdiagonal입니다. &lt;code&gt;uplo = L&lt;/code&gt; 경우 , &lt;code&gt;e_&lt;/code&gt; subdiagonal이다. 경우 &lt;code&gt;compq = N&lt;/code&gt; 만을 특이 값이 발견된다. 경우 &lt;code&gt;compq = I&lt;/code&gt; , 단수 가치와 벡터 발견된다. 경우 &lt;code&gt;compq = P&lt;/code&gt; , 특이 값 벡터는 콤팩트 형태로 발견된다. 실제 유형에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ec9c09340ab1167b34372c3c45f1effd39014b33" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. Can optionally also compute the product &lt;code&gt;Q' * C&lt;/code&gt;.</source>
          <target state="translated">2 각 행렬의 특이 값 분해를 대각선에 &lt;code&gt;d&lt;/code&gt; , 대각선 이외에 &lt;code&gt;e_&lt;/code&gt; 를 사용하여 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; superdiagonal입니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; subdiagonal이다. 선택적으로 곱 &lt;code&gt;Q' * C&lt;/code&gt; 계산할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f21ee8aaad12edc3062dd893487ac52ed7206a6" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the Sylvester equation &lt;code&gt;AX + XB + C = 0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have compatible dimensions and &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; have no eigenvalues with equal real part.</source>
          <target state="translated">솔루션 &lt;code&gt;X&lt;/code&gt; 를 실베스터 방정식 &lt;code&gt;AX + XB + C = 0&lt;/code&gt; 계산합니다 . 여기서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 는 호환되는 차원을 갖고 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 동일한 실제 부분을 가진 고유 값을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaf728832835285f8685228605bcbec78d5e39bc" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the continuous Lyapunov equation &lt;code&gt;AX + XA' + C = 0&lt;/code&gt;, where no eigenvalue of &lt;code&gt;A&lt;/code&gt; has a zero real part and no two eigenvalues are negative complex conjugates of each other.</source>
          <target state="translated">솔루션 &lt;code&gt;X&lt;/code&gt; 를 연속 리아 푸 노프 방정식 &lt;code&gt;AX + XA' + C = 0&lt;/code&gt; 으로 계산합니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 의 고유 값은 0이 아니며 두 고유 값은 음의 복합 복소수입니다.</target>
        </trans-unit>
        <trans-unit id="b754a424f062565c184ac8efa998e5bfaa6f23dc" translate="yes" xml:space="preserve">
          <source>Computing cluster</source>
          <target state="translated">컴퓨팅 클러스터</target>
        </trans-unit>
        <trans-unit id="2c4004422e3488a7fb54c4996a6f7cb083bc8c9e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 1.</source>
          <target state="translated">차원 1을 따라 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="4629919e0ba100f50a2a2e401ed196f708cfd82e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 2.</source>
          <target state="translated">차원 2를 따라 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="4d2f3e92e73a292cd5fe025535fd3fdcc9177e92" translate="yes" xml:space="preserve">
          <source>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</source>
          <target state="translated">행렬을 블록 대각선으로 연결합니다. 현재 희소 행렬에 대해서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6633f51709c6fbebf8bdadf15bf67930efc876" translate="yes" xml:space="preserve">
          <source>Concatenate strings and/or characters, producing a &lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. This is equivalent to calling the &lt;a href=&quot;#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; function on the arguments. Concatenation of built-in string types always produces a value of type &lt;code&gt;String&lt;/code&gt; but other string types may choose to return a string of a different type as appropriate.</source>
          <target state="translated">문자열 및 / 또는 문자를 연결하여 &lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;String&lt;/code&gt; 을&lt;/a&gt; 생성합니다 . 이것은 &lt;a href=&quot;#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다. 인수 함수 . 내장 문자열 유형의 연결은 항상 타입의 값을 생성하는 &lt;code&gt;String&lt;/code&gt; 적절한 다른 유형의 문자열을 반환하도록 선택할 수 있지만, 다른 문자열 유형을.</target>
        </trans-unit>
        <trans-unit id="ce48b2ddcd6d1f0f5ea8babe3eb4d74d6a5100eb" translate="yes" xml:space="preserve">
          <source>Concatenate the input arrays along the specified dimensions in the iterable &lt;code&gt;dims&lt;/code&gt;. For dimensions not in &lt;code&gt;dims&lt;/code&gt;, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in &lt;code&gt;dims&lt;/code&gt;, the size of the output array is the sum of the sizes of the input arrays along that dimension. If &lt;code&gt;dims&lt;/code&gt; is a single number, the different arrays are tightly stacked along that dimension. If &lt;code&gt;dims&lt;/code&gt; is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; builds a block diagonal matrix, i.e. a block matrix with &lt;code&gt;matrices[1]&lt;/code&gt;, &lt;code&gt;matrices[2]&lt;/code&gt;, ... as diagonal blocks and matching zero blocks away from the diagonal.</source>
          <target state="translated">iterable &lt;code&gt;dims&lt;/code&gt; 에서 지정된 차원을 따라 입력 배열을 연결하십시오 . 하지의 치수는 &lt;code&gt;dims&lt;/code&gt; 모든 입력 배열도 그 치수를 따라 출력 배열의 크기 가능할 동일한 크기를 가져야한다. 치수가 &lt;code&gt;dims&lt;/code&gt; 인 경우 출력 배열의 크기는 해당 차원을 따라 입력 배열의 크기의 합입니다. 경우 &lt;code&gt;dims&lt;/code&gt; 하나의 숫자이며, 다른 배열은 엄격하게 그 크기에 따라 적층되어있다. &lt;code&gt;dims&lt;/code&gt; 가 여러 차원을 포함하는 iterable 인 경우 , 모든 새로운 입력 배열에 대해 여러 차원을 동시에 증가시키고 다른 곳에 0 개의 블록을 두어 블록 대각선 행렬과 더 높은 차원의 아날로그를 구성 할 수 있습니다. 예를 들어 &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; 는 블록 대각선 행렬, 즉 &lt;code&gt;matrices[1]&lt;/code&gt; , &lt;code&gt;matrices[2]&lt;/code&gt; , ...를 대각선 블록으로하고 대각선에서 0 블록을 일치 시키는 블록 행렬을 만듭니다. .</target>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="e57bdd9a9f868f0fe536fc4a82988aa7ab5eb4ce" translate="yes" xml:space="preserve">
          <source>Concatenation and permutation</source>
          <target state="translated">연결과 순열</target>
        </trans-unit>
        <trans-unit id="410d5f3b6433c7572682965906a75036cfaaf8dc" translate="yes" xml:space="preserve">
          <source>Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.</source>
          <target state="translated">연결 구문에는 결과의 요소 유형을 지정하는 유형이 접두어로 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a0a67dece6f1d14e99beeba39e9ccd30856c117" translate="yes" xml:space="preserve">
          <source>Conceptually, a string is a &lt;em&gt;partial function&lt;/em&gt; from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.</source>
          <target state="translated">개념적으로 문자열은 인덱스에서 문자까지 &lt;em&gt;부분 함수&lt;/em&gt; 입니다. 일부 인덱스 값의 경우 문자 값이 반환되지 않고 예외가 발생합니다. 따라서 문자 인덱스가 아닌 인코딩 된 표현의 바이트 인덱스를 사용하여 문자열을 효율적으로 인덱싱 할 수 있습니다. 이는 유니 코드 문자열의 가변 너비 인코딩을 효율적이고 간단하게 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbea4d31c59c78035ac57d6aea6a10af5718acc3" translate="yes" xml:space="preserve">
          <source>Concerning 1), a &lt;code&gt;rand&lt;/code&gt; method may happen to work automatically, but it's not officially supported and may break without warnings in a subsequent release.</source>
          <target state="translated">1) &lt;code&gt;rand&lt;/code&gt; 방법은 자동으로 작동하지만 공식적으로 지원되지 않으며 후속 릴리스에서 경고없이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="28d538a9ac44a88ceec5d9363eb9b5a0f1c92100" translate="yes" xml:space="preserve">
          <source>Concrete &lt;code&gt;Point&lt;/code&gt; types with different values of &lt;code&gt;T&lt;/code&gt; are never subtypes of each other:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 값이 다른 콘크리트 &lt;code&gt;Point&lt;/code&gt; 유형은 서로의 하위 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ac02f0743c4d1b96a2deef06f8e3cd49006763ce" translate="yes" xml:space="preserve">
          <source>Concrete number types</source>
          <target state="translated">콘크리트 숫자 유형</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="cf7bc3804abc264beaaad97d32ab5bc9d2653568" translate="yes" xml:space="preserve">
          <source>Condition number of the matrix &lt;code&gt;M&lt;/code&gt;, computed using the operator &lt;code&gt;p&lt;/code&gt;-norm. Valid values for &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; (default), or &lt;code&gt;Inf&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;p&lt;/code&gt; -norm을 사용하여 계산 된 행렬 &lt;code&gt;M&lt;/code&gt; 의 조건 번호입니다 . &lt;code&gt;p&lt;/code&gt; 의 유효한 값 은 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; (기본값) 또는 &lt;code&gt;Inf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d01a0100c352f7c2f05bca55a82a8a86c8c531a6" translate="yes" xml:space="preserve">
          <source>Conditional Evaluation</source>
          <target state="translated">조건부 평가</target>
        </trans-unit>
        <trans-unit id="6b7fdfcad9d0149a68420bc1fb6ae6bcfa3f3e5a" translate="yes" xml:space="preserve">
          <source>Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">조건부 평가를 사용하면 부울 식의 값에 따라 코드 부분을 평가하거나 평가하지 않을 수 있습니다. 여기의 해부학 인 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 조건 구문 :</target>
        </trans-unit>
        <trans-unit id="e69f11134ba674beba00ec75d3e8520e70308ab6" translate="yes" xml:space="preserve">
          <source>Confetti Ball</source>
          <target state="translated">색종이 공</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="94f090695baa8f06a3ff8b47aa0ba0fa159cbae9" translate="yes" xml:space="preserve">
          <source>Configure a private writable depot using &lt;code&gt;pushfirst!(DEPOT_PATH, private_path)&lt;/code&gt; where &lt;code&gt;private_path&lt;/code&gt; is a path unique to this &lt;code&gt;julia&lt;/code&gt; process. This can also be done by setting environment variable &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; to &lt;code&gt;$private_path:$HOME/.julia&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pushfirst!(DEPOT_PATH, private_path)&lt;/code&gt; 사용하여 쓰기 가능한 개인 저장소를 구성합니다 . 여기서 &lt;code&gt;private_path&lt;/code&gt; 는이 &lt;code&gt;julia&lt;/code&gt; 프로세스에 고유 한 경로 입니다. 환경 변수 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 를 &lt;code&gt;$private_path:$HOME/.julia&lt;/code&gt; 로 설정하여 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f11771dca2097f06e32650070e9cd19a4232960b" translate="yes" xml:space="preserve">
          <source>Configure the &lt;code&gt;delay&lt;/code&gt; between backtraces (measured in seconds), and the number &lt;code&gt;n&lt;/code&gt; of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order &lt;code&gt;(n, delay)&lt;/code&gt;.</source>
          <target state="translated">백 트레이스 (초 단위로 측정)와 &lt;code&gt;delay&lt;/code&gt; 될 수있는 명령 포인터 수 &lt;code&gt;n&lt;/code&gt; 사이 의 지연을 구성합니다 . 각 명령어 포인터는 한 줄의 코드에 해당합니다. 역 추적은 일반적으로 명령 포인터의 긴 목록으로 구성됩니다. 기본 설정은 인수없이이 함수를 호출하여 얻을 수 있으며 키워드를 사용하거나 순서대로 &lt;code&gt;(n, delay)&lt;/code&gt; 각각 독립적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="673a17c8ab08ef073f65d1d78eccb52e6d24ac72" translate="yes" xml:space="preserve">
          <source>Confounded Face</source>
          <target state="translated">혼란스러운 얼굴</target>
        </trans-unit>
        <trans-unit id="dd9a3041d63a9bbabd149d1fe0496e16f5dc48c5" translate="yes" xml:space="preserve">
          <source>Confused Face</source>
          <target state="translated">혼란스러운 얼굴</target>
        </trans-unit>
        <trans-unit id="eef1f855d92024dcbe93e39074e6eedcb5b887b2" translate="yes" xml:space="preserve">
          <source>Congruent With Dot Above</source>
          <target state="translated">위의 점과 일치</target>
        </trans-unit>
        <trans-unit id="8d07e70d148195b15a902e326b6c8a5a632e9d80" translate="yes" xml:space="preserve">
          <source>Conical Taper</source>
          <target state="translated">원뿔 테이퍼</target>
        </trans-unit>
        <trans-unit id="53cbbaf8dc8947fbf7f4e2c26b471f06d61fc371" translate="yes" xml:space="preserve">
          <source>Conjugate transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">배열 &lt;code&gt;src&lt;/code&gt; 를 결합 하고 결과를 미리 할당 된 배열 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다.이 배열 은 &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; 해당하는 크기를 가져야합니다 . 내부 전치가 지원되지 않으며 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 에 겹치는 메모리 영역 이 있으면 예기치 않은 결과가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a876d1109ed8e346f72690afb5f2db1f614132b6" translate="yes" xml:space="preserve">
          <source>Connect to the host &lt;code&gt;host&lt;/code&gt; on port &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">포트 &lt;code&gt;port&lt;/code&gt; 의 호스트 &lt;code&gt;host&lt;/code&gt; 에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="9004fa442291bfc2131d993b2837ea1204a6abf6" translate="yes" xml:space="preserve">
          <source>Connect to the named pipe / UNIX domain socket at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 명명 된 파이프 / UNIX 도메인 소켓에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a431044d47389f7d8d41344d53c0bcbadc8fbb0" translate="yes" xml:space="preserve">
          <source>Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</source>
          <target state="translated">작업자 간의 연결 (내장 TCP / IP 전송 사용)은 다음과 같은 방식으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e713951b7382d19065c79a76c4ed128f1bd12fce" translate="yes" xml:space="preserve">
          <source>Consequently these can be useful for writing algorithms that work in arbitrary dimensions.</source>
          <target state="translated">따라서 임의의 차원에서 작동하는 알고리즘을 작성하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6047fa413edddcfaf57a7f9b7f453ad4dba512df" translate="yes" xml:space="preserve">
          <source>Consequently, this child function gets 3 counts, even though the parent only gets one. The &quot;tree&quot; representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.</source>
          <target state="translated">결과적으로이 자식 함수는 부모가 하나만 가져도 3 카운트를 얻습니다. &quot;트리&quot;표현은이를 훨씬 더 명확하게하며, 이러한 이유로 (다른 이유로) 결과를 보는 가장 유용한 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="3eea8fbc0a3e336128fa5eb5ae85da5b38074305" translate="yes" xml:space="preserve">
          <source>Consequently, you are more likely to need to modify &lt;code&gt;delay&lt;/code&gt;, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is &lt;code&gt;delay = 0.001&lt;/code&gt;. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds on the author's laptop).</source>
          <target state="translated">결과적으로 요청 된 계산을 수행하기 위해 Julia가 스냅 샷간에 가져 오는 시간을 설정하는 &lt;code&gt;delay&lt;/code&gt; 를 초 단위 로 수정해야 할 가능성이 높습니다 . 매우 오래 실행되는 작업에는 빈번한 역 추적이 필요하지 않을 수 있습니다. 기본 설정은 &lt;code&gt;delay = 0.001&lt;/code&gt; 입니다. 물론 지연을 줄이고 증가시킬 수 있습니다. 그러나 지연이 역 추적 (필자의 랩톱에서 ~ 30 마이크로 초)에 걸리는 시간과 비슷 해지면 프로파일 링의 오버 헤드가 커집니다.</target>
        </trans-unit>
        <trans-unit id="0d0b9ea156f51f38c626060e2a890817b373f8db" translate="yes" xml:space="preserve">
          <source>Consider a discrete distribution, where numbers &lt;code&gt;1:n&lt;/code&gt; are drawn with given probabilities that sum to one. When many values are needed from this distribution, the fastest method is using an &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;alias table&lt;/a&gt;. We don't provide the algorithm for building such a table here, but suppose it is available in &lt;code&gt;make_alias_table(probabilities)&lt;/code&gt; instead, and &lt;code&gt;draw_number(rng, alias_table)&lt;/code&gt; can be used to draw a random number from it.</source>
          <target state="translated">&lt;code&gt;1:n&lt;/code&gt; 되는 확률로 1 : n 이 그려지 는 이산 분포를 고려하십시오 . 이 분포에서 많은 값이 필요한 경우 가장 빠른 방법은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;별칭 테이블을&lt;/a&gt; 사용하는 것 입니다. 여기에서는 이러한 테이블을 만드는 알고리즘을 제공하지 않지만 대신 &lt;code&gt;make_alias_table(probabilities)&lt;/code&gt; 에서 사용할 수 있고 &lt;code&gt;draw_number(rng, alias_table)&lt;/code&gt; 를 사용하여 임의의 숫자를 그릴 수 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="ad2b5b66bbff4ce303aefd6b3469a1ca820858f7" translate="yes" xml:space="preserve">
          <source>Consider a function which logs a warning, and several debug messages:</source>
          <target state="translated">경고를 기록하는 기능과 여러 디버그 메시지를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b41c44bc4a6bcb6e5de4d96d38a9a8675a1f8d16" translate="yes" xml:space="preserve">
          <source>Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single &lt;code&gt;jobs&lt;/code&gt; channel. Jobs, identified by an id (&lt;code&gt;job_id&lt;/code&gt;), are written to the channel. Each task in this simulation reads a &lt;code&gt;job_id&lt;/code&gt;, waits for a random amount of time and writes back a tuple of &lt;code&gt;job_id&lt;/code&gt; and the simulated time to the results channel. Finally all the &lt;code&gt;results&lt;/code&gt; are printed out.</source>
          <target state="translated">작업 간 통신에 채널을 사용하는 간단한 예를 고려하십시오. 단일 &lt;code&gt;jobs&lt;/code&gt; 채널 에서 데이터를 처리하기 위해 4 가지 작업을 시작합니다 . ID ( &lt;code&gt;job_id&lt;/code&gt; )로 식별 된 작업 은 채널에 작성됩니다. 이 시뮬레이션에서 각 작업은 읽기 &lt;code&gt;job_id&lt;/code&gt; 시간과 쓰기의 임의의 금액에 대한 대기의 튜플 백업, &lt;code&gt;job_id&lt;/code&gt; 결과 채널과 시뮬레이션 시간을. 마지막으로 모든 &lt;code&gt;results&lt;/code&gt; 가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7131848d45ace01b38d4617e6d98b8e79ccee7" translate="yes" xml:space="preserve">
          <source>Consider the following contrived example. Imagine we wanted to write a function that accepts a &lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; and returns a square &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/a&gt; with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">다음과 같은 고려 된 예를 고려하십시오. &lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 를 받아들이고 입력 벡터의 복사본으로 채워진 행이나 열이 있는 정사각 &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;/a&gt; 을 반환 하는 함수를 작성하려고한다고 상상해보십시오 . 행 또는 열이 이러한 사본으로 채워지는지 여부가 중요하지 않다고 가정하십시오 (아마도 나머지 코드는 그에 따라 쉽게 조정할 수 있음). 우리는 이것을 최소한 네 가지 방법으로 (내장 &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 에 대한 권장 호출 외에도 ) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea7505a758167e8e584f36010a94eb7238c397b" translate="yes" xml:space="preserve">
          <source>Consider the following example that defines an inner function:</source>
          <target state="translated">내부 함수를 정의하는 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf37589ccf59f2442553bb8984c73cb434ce446" translate="yes" xml:space="preserve">
          <source>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</source>
          <target state="translated">다음 두 가지 예를 고려하십시오. 첫 번째는 예외 객체를 인라인으로 반환하고 두 번째는 예외 대신 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="0c895d2fdc1a30ac558dfcb63c363445e0e645e1" translate="yes" xml:space="preserve">
          <source>Consider the printed output from the following:</source>
          <target state="translated">다음의 인쇄 결과를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b8e04b708ae9ae6b8c54714632e7d8df9880585c" translate="yes" xml:space="preserve">
          <source>Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks' sum</source>
          <target state="translated">단순히 각 하위 프로세스를 호출하고 순위를 인스턴스화하고 마스터 프로세스에 도달하면 순위 합계를 수행하는이 장난감 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="da61269d791580f869cabd4bd9de4046eac9f72f" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;!ismutable(v)&lt;/code&gt; instead, as &lt;code&gt;isimmutable(v)&lt;/code&gt; will be replaced by &lt;code&gt;!ismutable(v)&lt;/code&gt; in a future release. (Since Julia 1.5)</source>
          <target state="translated">사용을 고려 &lt;code&gt;!ismutable(v)&lt;/code&gt; 대신으로 &lt;code&gt;isimmutable(v)&lt;/code&gt; 로 대체됩니다 &lt;code&gt;!ismutable(v)&lt;/code&gt; 미래의 릴리스에서. (Julia 1.5 이후)</target>
        </trans-unit>
        <trans-unit id="85eb0a345158a422b527393dc1bc1495a2bd3a98" translate="yes" xml:space="preserve">
          <source>Consider using views for slices</source>
          <target state="translated">슬라이스에 뷰 사용 고려</target>
        </trans-unit>
        <trans-unit id="14ed4bf7ae010ff51a59d1ab1db2ea68d0dd0dd0" translate="yes" xml:space="preserve">
          <source>Considered alone, this may seem relatively trivial; &lt;code&gt;CartesianIndex&lt;/code&gt; simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield &lt;code&gt;CartesianIndex&lt;/code&gt;es, however, this can produce very elegant and efficient code. See &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt; below, and for some more advanced examples, see &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;this blog post on multidimensional algorithms and iteration&lt;/a&gt;.</source>
          <target state="translated">혼자 고려할 때 이것은 비교적 사소한 것처럼 보일 수 있습니다. &lt;code&gt;CartesianIndex&lt;/code&gt; 는 단순히 여러 정수를 하나의 다차원 인덱스를 나타내는 하나의 객체로 모 읍니다. 그러나 &lt;code&gt;CartesianIndex&lt;/code&gt; es 를 생성하는 다른 인덱싱 양식 및 반복기와 결합하면 매우 우아하고 효율적인 코드를 생성 할 수 있습니다. 아래의 &lt;a href=&quot;#Iteration&quot;&gt;반복을&lt;/a&gt; 참조하고 몇 가지 고급 예제를 보려면 &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;다차원 알고리즘 및 반복에&lt;/a&gt; 대한 이 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec4162d71dc6c558c88cb225144c9bcd26084f48" translate="yes" xml:space="preserve">
          <source>Considered alone, this may seem relatively trivial; &lt;code&gt;CartesianIndex&lt;/code&gt; simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield &lt;code&gt;CartesianIndex&lt;/code&gt;es, however, this can produce very elegant and efficient code. See &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt; below, and for some more advanced examples, see &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;this blog post on multidimensional algorithms and iteration&lt;/a&gt;.</source>
          <target state="translated">혼자 생각하면, 이것은 비교적 사소한 것처럼 보일 수 있습니다. &lt;code&gt;CartesianIndex&lt;/code&gt; 는 단순히 단일 다차원 인덱스를 나타내는 하나의 객체에 여러 정수를 모은 것입니다. 그러나 &lt;code&gt;CartesianIndex&lt;/code&gt; es 를 생성하는 다른 색인 양식 및 반복자와 결합하면 매우 우아하고 효율적인 코드를 생성 할 수 있습니다. 아래 &lt;a href=&quot;#Iteration-1&quot;&gt;반복을&lt;/a&gt; 참조하십시오. 고급 예제 &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;는 다차원 알고리즘 및 반복에&lt;/a&gt; 대한 이 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90dc44bf4503df06cc88bdeed11978534d89fa68" translate="yes" xml:space="preserve">
          <source>Consistent serialization:</source>
          <target state="translated">일관된 직렬화 :</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="f20797a3b29239e673a22d9f965a161574684bb4" translate="yes" xml:space="preserve">
          <source>Constants involving most Julia objects that are not produced by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; do not need to be placed in &lt;code&gt;__init__&lt;/code&gt;: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects will turn into null pointers unless they are hidden inside an &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; object). This includes the return values of the Julia functions &lt;code&gt;cfunction&lt;/code&gt; and &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 의해 생성되지 않은 대부분의 Julia 객체와 관련된 상수 는 &lt;code&gt;__init__&lt;/code&gt; 에 배치 할 필요가 없습니다 . 정의는 캐시 된 모듈 이미지에서 사전 컴파일되어로드 될 수 있습니다. 여기에는 배열과 같은 복잡한 힙 할당 객체가 포함됩니다. 그러나 사전 컴파일이 작동하려면 원시 포인터 값을 리턴하는 루틴을 런타임에 호출해야합니다 ( &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; 오브젝트는 &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt; 오브젝트 안에 숨겨져 있지 않으면 널 포인터로 바 turn ). 여기에는 Julia 함수 &lt;code&gt;cfunction&lt;/code&gt; 및 &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt; 의 반환 값이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3dbbafc2bcd268f72cf3af03b54be6b51a2334b" translate="yes" xml:space="preserve">
          <source>Construct</source>
          <target state="translated">Construct</target>
        </trans-unit>
        <trans-unit id="f97e2d9c4b65aa73bfe3ea4abacc7c7c96df97c2" translate="yes" xml:space="preserve">
          <source>Construct &lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; from two &lt;code&gt;CartesianIndex&lt;/code&gt;.</source>
          <target state="translated">구조의 &lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; 두에서 &lt;code&gt;CartesianIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="193781393b9a991b412b9666ff3363d59256fb37" translate="yes" xml:space="preserve">
          <source>Construct a 1-d array of the specified type. This is usually called with the syntax &lt;code&gt;Type[]&lt;/code&gt;. Element values can be specified using &lt;code&gt;Type[a,b,c,...]&lt;/code&gt;.</source>
          <target state="translated">지정된 타입의 1 차원 배열을 구성합니다. 일반적으로 &lt;code&gt;Type[]&lt;/code&gt; 구문으로 호출됩니다 . 요소 값은 &lt;code&gt;Type[a,b,c,...]&lt;/code&gt; 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="822ae5747d235413c4d6b4787626679a1b185a0e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; generated by the given iterable object. The shape is inferred from the &lt;code&gt;itr&lt;/code&gt; object.</source>
          <target state="translated">컨스 &lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 주어진 반복 가능 객체에 의해 발생한다. 모양은 &lt;code&gt;itr&lt;/code&gt; 객체 에서 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8d781f22b5f31f1ad3ff32a6a5b759f677769b6" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목으로 초기화 된 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 크기 의 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c66efe8a7c37a7a479116847647815fc94a32d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 된 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 크기 의 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="271b0e3ba477679c21eb060d4bf61dcf1916b610" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; of the values generated by the given iterable object, or an empty set. Should be used instead of &lt;a href=&quot;#Base.BitSet&quot;&gt;&lt;code&gt;BitSet&lt;/code&gt;&lt;/a&gt; for sparse integer sets, or for sets of arbitrary objects.</source>
          <target state="translated">주어진 반복 가능한 객체에 의해 생성 된 값 의 &lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 또는 빈 세트를 구성합니다. 희소 정수 세트 또는 임의의 오브젝트 세트에 &lt;a href=&quot;#Base.BitSet&quot;&gt; &lt;code&gt;BitSet&lt;/code&gt; &lt;/a&gt; 대신 사용되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6ed69370b1f85dc30500cbd3df9bf2409de8527b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 길이의 &lt;code&gt;m&lt;/code&gt; 로 초기화, &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목을. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfe5534e0cb4dceb12e8df87c966d7782ee710b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">길이가 &lt;code&gt;m&lt;/code&gt; 인 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 를 구성하고 항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 합니다. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc422a0b0965db4d8a6477be563e87c89e3c1e29" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Bidiagonal&lt;/code&gt; matrix from the main diagonal of &lt;code&gt;A&lt;/code&gt; and its first super- (if &lt;code&gt;uplo=:U&lt;/code&gt;) or sub-diagonal (if &lt;code&gt;uplo=:L&lt;/code&gt;).</source>
          <target state="translated">컨스 &lt;code&gt;Bidiagonal&lt;/code&gt; 의 주요 대각 행렬로부터 및 제 슈퍼 (있는 경우 &lt;code&gt;uplo=:U&lt;/code&gt; ) 또는 하위 대각선 (만약 &lt;code&gt;uplo=:L&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b2e58bf227bdb08afbbc5fd16b8dde5aee9225c" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundPeriod&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Period&lt;/code&gt;s. All &lt;code&gt;Period&lt;/code&gt;s of the same type will be added together.</source>
          <target state="translated">구성체 &lt;code&gt;CompoundPeriod&lt;/code&gt; 를 A로부터 &lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Period&lt;/code&gt; 의. 동일한 유형의 모든 &lt;code&gt;Period&lt;/code&gt; 함께 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4b09b541e4ed1f0aba3333bcba37da80754811dc" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; by parsing the &lt;code&gt;d&lt;/code&gt; date string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">컨스 &lt;code&gt;Date&lt;/code&gt; 파싱하여 &lt;code&gt;d&lt;/code&gt; 에 주어진 패턴 다음 날짜 문자열 &lt;code&gt;format&lt;/code&gt; 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="af2403a6b54b9170043e5f46c873bd44e2c86e65" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Date&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 유형 부분 으로 &lt;code&gt;Date&lt;/code&gt; 유형을 구성하십시오. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 &lt;code&gt;Date&lt;/code&gt; 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f444be57b1a99cc75b882799b5ad5c2d4dfae5e1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Date&lt;/code&gt; 부품에 의한 유형입니다. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c67c8fc150a64df871383e42ca74e3f64cce0b21" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created &lt;code&gt;DateFormat&lt;/code&gt; object.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 파싱하여 &lt;code&gt;dt&lt;/code&gt; 에 주어진 패턴 다음 날짜 시간 문자열 &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 객체를. 유사 &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; 만 반복적으로 미리 만들어진와 유사한 형식의 날짜 시간 문자열을 구문 분석 할 때보다 효율적 &lt;code&gt;DateFormat&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="aea78ff467ecef7879256770936c29566865c81d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 파싱하여 &lt;code&gt;dt&lt;/code&gt; 에 주어진 패턴 다음 날짜 시간 문자열 &lt;code&gt;format&lt;/code&gt; 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e93eb9f3900c323d0aafcfa89df6646124b6b543" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. DateTime parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 으로 입력 &lt;code&gt;Period&lt;/code&gt; 형 부품. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 DateTime 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="383850982e161143cb3f8464b59c38e89b3a5646" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 부분으로 유형을. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="775f3a88f10d84f3621ead39c164700c56bb2844" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Day&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Day&lt;/code&gt; 객체를 구성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="40609c2c820790d0a3c1eb68f785ce1c82714463" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;GitBlame&lt;/code&gt; object for the file at &lt;code&gt;path&lt;/code&gt;, using change information gleaned from the history of &lt;code&gt;repo&lt;/code&gt;. The &lt;code&gt;GitBlame&lt;/code&gt; object records who changed which chunks of the file when, and how. &lt;code&gt;options&lt;/code&gt; controls how to separate the contents of the file and which commits to probe - see &lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt;&lt;code&gt;BlameOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">컨스 &lt;code&gt;GitBlame&lt;/code&gt; 의 에서 파일에 대한 객체를 &lt;code&gt;path&lt;/code&gt; 의 역사에서 수집 변경 정보 사용 &lt;code&gt;repo&lt;/code&gt; . &lt;code&gt;GitBlame&lt;/code&gt; 의 파일 때, 어떻게 덩어리하는 변경 객체 기록합니다. &lt;code&gt;options&lt;/code&gt; 은 파일의 내용을 분리하는 방법과 검사 할 커밋을 제어합니다 . 자세한 내용 은 &lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt; &lt;code&gt;BlameOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfac8ee20a7a93b71932d5ea24ca6e9446304d80" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Hermitian&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Hermitian&lt;/code&gt; (만약 위쪽의 뷰를 &lt;code&gt;uplo = :U&lt;/code&gt; ) 이하 (경우 &lt;code&gt;uplo = :L&lt;/code&gt; ) 행렬의 삼각형 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53aa9b9ef1c879e549044ea23efdf5498813a414" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;LowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LowerTriangular&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a2be7157682b3e7c1d399140f4ed110f2601b93e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Month&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Month&lt;/code&gt; 객체를 생성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e17e322b24ea8482c083700759e1a4aa7fc99ff" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Pair&lt;/code&gt; object with type &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt;. The elements are stored in the fields &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They can also be accessed via iteration (but a &lt;code&gt;Pair&lt;/code&gt; is treated as a single &quot;scalar&quot; for broadcasting operations).</source>
          <target state="translated">&lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt; 유형 으로 &lt;code&gt;Pair&lt;/code&gt; 객체를 생성합니다 . 요소는 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;second&lt;/code&gt; 필드에 저장됩니다 . 반복을 통해 액세스 할 수도 있습니다 (단, &lt;code&gt;Pair&lt;/code&gt; 은 브로드 캐스팅 작업을위한 단일 &quot;스칼라&quot;로 처리됨).</target>
        </trans-unit>
        <trans-unit id="5ee95a95477044367d4547393ce2e04832e8eaee" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Pair&lt;/code&gt; object with type &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt;. The elements are stored in the fields &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They can also be accessed via iteration.</source>
          <target state="translated">&lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt; 유형 으로 &lt;code&gt;Pair&lt;/code&gt; 객체를 생성합니다 . 요소는 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 필드에 저장됩니다 . 또한 반복을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e945148a5d12b75c7c3ce9201b6e5d5ca81cafce" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Period&lt;/code&gt; type with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Period&lt;/code&gt; 유형을 구성하십시오 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="36f2454002107f0f60d937848f0e4956684fd113" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; backed by the file &lt;code&gt;filename&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt; (must be a bits type) and size &lt;code&gt;dims&lt;/code&gt;, across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:</source>
          <target state="translated">컨스 &lt;code&gt;SharedArray&lt;/code&gt; 이 파일에 의해 백업 &lt;code&gt;filename&lt;/code&gt; 요소 형, &lt;code&gt;T&lt;/code&gt; 및 크기 (a 비트 유형이어야 함) &lt;code&gt;dims&lt;/code&gt; 로 지정된 프로세스에 걸쳐, &lt;code&gt;pids&lt;/code&gt; 동일한 호스트에 있어야 모두를 -. 이 파일은 다음 결과로 호스트 메모리에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="30559885baa00f426d3195c8bac3dc6b30de76a2" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; of a bits type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;dims&lt;/code&gt; across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. If &lt;code&gt;N&lt;/code&gt; is specified by calling &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt;, then &lt;code&gt;N&lt;/code&gt; must match the length of &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;SharedArray&lt;/code&gt; 비트 입력 &lt;code&gt;T&lt;/code&gt; 및 크기 &lt;code&gt;dims&lt;/code&gt; 의해 지정된 프로세스간에 &lt;code&gt;pids&lt;/code&gt; 동일한 호스트에 있어야 모두 -. 경우 &lt;code&gt;N&lt;/code&gt; 이 호출에 의해 지정됩니다 &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt; , 다음 &lt;code&gt;N&lt;/code&gt; 은 의 길이와 일치해야합니다 &lt;code&gt;dims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad6ab2e9afc35f90c2261027da0cbb9fa911828" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Symmetric&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;uplo = :L&lt;/code&gt; 삼각형 ( &lt;code&gt;uplo = :U&lt;/code&gt; ) 또는 아래쪽 삼각형 ( uplo = : L ) 의 &lt;code&gt;Symmetric&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="512b84d9393d18f32c44b67c1ceac4788e65f773" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Time&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 유형 부분 으로 &lt;code&gt;Time&lt;/code&gt; 유형을 구성하십시오. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 &lt;code&gt;Time&lt;/code&gt; 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="57a83629f577977e6138536698bfa2b11168ae04" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Time&lt;/code&gt; 부분으로 유형을. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1fa0f5c37012652505e3cdf521c5117c6215fe1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;UnitLowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UnitLowerTriangular&lt;/code&gt; 뷰를 구성합니다 . 이러한 뷰는 보유 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 그 대각선에있다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbf534772f21c312ceb366d56988564faadc9083" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Week&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Week&lt;/code&gt; 객체를 구성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5bdc0f4ba0074541be92fccdc87cc517c888054" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Year&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Year&lt;/code&gt; 객체를 생성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="be0daf784d16844ae921191b30baa069213224e7" translate="yes" xml:space="preserve">
          <source>Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the &lt;code&gt;format&lt;/code&gt; string:</source>
          <target state="translated">날짜 문자열을 구문 분석하거나 날짜 오브젝트를 문자열로 형식화하는 데 사용할 수있는 날짜 형식화 오브젝트를 구성하십시오. 다음 문자열 코드를 사용하여 &lt;code&gt;format&lt;/code&gt; 문자열 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cd437ecc9656e44160fa4c4fc658708ac1ef9c1" translate="yes" xml:space="preserve">
          <source>Construct a git hash object from the given string, returning a &lt;code&gt;GitShortHash&lt;/code&gt; if the string is shorter than 40 hexadecimal digits, otherwise a &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">주어진 문자열에서 git hash 객체를 생성 하고 문자열이 16 진수 40 자리보다 짧은 경우 &lt;code&gt;GitShortHash&lt;/code&gt; 를 반환하고 , 그렇지 않으면 &lt;code&gt;GitHash&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="95915c31d29fdf119affd21fc1204ab467ac45da" translate="yes" xml:space="preserve">
          <source>Construct a matrix from &lt;code&gt;Pair&lt;/code&gt;s of diagonals and vectors. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. By default the matrix is square and its size is inferred from &lt;code&gt;kv&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; (padded with zeros as needed) can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">&lt;code&gt;Pair&lt;/code&gt; s의 대각선과 벡터 에서 행렬을 생성 합니다. 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 . 기본적으로 행렬은 정사각형이고 크기는 &lt;code&gt;kv&lt;/code&gt; 에서 유추 되지만 , 첫 번째 인수로 &lt;code&gt;m,n&lt;/code&gt; 을 전달하여 정사각형이 아닌 크기 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; (필요에 따라 0으로 채워짐)을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea8e23701feccd63e17e0b0029ede99044fa274d" translate="yes" xml:space="preserve">
          <source>Construct a matrix from the diagonal of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 대각선에서 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="90f773e3d113876b6deb8a09e0f5de33ba790fb7" translate="yes" xml:space="preserve">
          <source>Construct a matrix with &lt;code&gt;V&lt;/code&gt; as its diagonal.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 를 대각선으로 하여 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="25f4b3c401d1f835673ca7161bdff8b451269e90" translate="yes" xml:space="preserve">
          <source>Construct a matrix with elements of the vector as diagonal elements. By default (if &lt;code&gt;size=nothing&lt;/code&gt;), the matrix is square and its size is given by &lt;code&gt;length(v)&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">벡터의 요소를 대각선 요소로 사용하여 행렬을 생성합니다. 기본적으로 ( &lt;code&gt;size=nothing&lt;/code&gt; 인 경우 ) 행렬은 정사각형이고 크기는 &lt;code&gt;length(v)&lt;/code&gt; 로 지정되지만 &lt;code&gt;m,n&lt;/code&gt; 을 첫 번째 인수로 전달하여 정사각형이 아닌 크기 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f217bb0e7b35012b29fdda1729b0fa09e13438ab" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</source>
          <target state="translated">주어진 컬렉션에서 병합 된 컬렉션을 구성합니다. 필요한 경우 병합 된 컬렉션의 유형을 수용하도록 결과 컬렉션의 유형이 승격됩니다. 다른 컬렉션에 동일한 키가있는 경우 해당 키의 값은 나열된 마지막 컬렉션에있는 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="f1617b1cc87aa299b6833917b0e46a1a4940ff17" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</source>
          <target state="translated">주어진 컬렉션에서 병합 된 컬렉션을 구성합니다. 필요한 경우 병합 된 컬렉션의 유형을 수용하도록 결과 컬렉션의 유형이 승격됩니다. 동일한 키를 가진 값은 결합기 기능을 사용하여 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="f2de24e56968962e72117fcb0066f859df18b8a7" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function. The curried form &lt;code&gt;mergewith(combine)&lt;/code&gt; returns the function &lt;code&gt;(args...) -&amp;gt; mergewith(combine, args...)&lt;/code&gt;.</source>
          <target state="translated">주어진 컬렉션에서 병합 된 컬렉션을 생성합니다. 필요한 경우 병합 된 컬렉션의 유형을 수용하기 위해 결과 컬렉션의 유형이 승격됩니다. 동일한 키를 가진 값은 결합기 기능을 사용하여 결합됩니다. &lt;code&gt;mergewith(combine)&lt;/code&gt; 형식 mergewith (combine) 은 &lt;code&gt;(args...) -&amp;gt; mergewith(combine, args...)&lt;/code&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="60ada712a6bba4831ea5117dcc593947b90a8eea" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;Cmd&lt;/code&gt; object, representing an external program and arguments, from &lt;code&gt;cmd&lt;/code&gt;, while changing the settings of the optional keyword arguments:</source>
          <target state="translated">선택적 키워드 인수의 설정을 변경하면서 &lt;code&gt;cmd&lt;/code&gt; 에서 외부 프로그램 및 인수를 나타내는 새 &lt;code&gt;Cmd&lt;/code&gt; 오브젝트 를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="921bc3f38441b69eaebf923e14b05b0ead5fb49a" translate="yes" xml:space="preserve">
          <source>Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt;.</source>
          <target state="translated">왼쪽 연관 방식으로 두 개 이상의 기존 항목을 병합하여 새 이름의 튜플을 구성하십시오. 병합은 명명 된 튜플 쌍 사이에서 왼쪽에서 오른쪽으로 진행되므로 가장 왼쪽에있는 튜플과 가장 오른쪽에있는 튜플 모두에있는 필드의 순서는 가장 왼쪽에있는 튜플에서 발견되는 것과 동일한 위치를 갖습니다. 그러나 값은 해당 필드를 포함하는 가장 오른쪽으로 명명 된 튜플에서 일치하는 필드에서 가져옵니다. 맨 오른쪽에 이름이 지정된 튜플에만있는 필드가 끝에 추가됩니다. 서명 &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt; 과 함께 이름이 지정된 단일 튜플 만 제공되는 경우 폴 백이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f725dfe7fd6faac9e03009cc2d94bc9428b364fc" translate="yes" xml:space="preserve">
          <source>Construct a random cyclic permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;. The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 무작위 순환 순열을 생성합니다 . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; . 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="773ddde3a7d5f56b43450f9427ef414e19220724" translate="yes" xml:space="preserve">
          <source>Construct a random cyclic permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;. The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 랜덤 순환 순열을 만듭니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; . 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="31d98d8e00b2cfb014e115f27e9ff8e8b2a46deb" translate="yes" xml:space="preserve">
          <source>Construct a random permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;). The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 무작위 순열을 생성합니다 . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; ). 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ed600dca9287d8a479f0f2758806c12b876aecb6" translate="yes" xml:space="preserve">
          <source>Construct a random permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 랜덤 순열을 구성합니다 . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; ). 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="077c36b5cddb72a8d1da7fef475e2f40e5395bad" translate="yes" xml:space="preserve">
          <source>Construct a regex, such as &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt;, without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</source>
          <target state="translated">보간 및 이스케이프 처리 없이 &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt; 와 같은 정규 표현식을 작성하십시오 ( 여전히 이스케이프 해야하는 인용 부호 &lt;code&gt;&quot;&lt;/code&gt; 는 제외 ). 정규 표현식은 끝 인용 부호 뒤에 나열된 하나 이상의 플래그를 허용합니다. 행동을 바꾸십시오 :</target>
        </trans-unit>
        <trans-unit id="33aad8a62d61bbba4ad329f651211ce2a482be36" translate="yes" xml:space="preserve">
          <source>Construct a sorted set of &lt;code&gt;Int&lt;/code&gt;s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">주어진 반복 가능한 객체 또는 빈 세트로 생성 된 정렬 된 &lt;code&gt;Int&lt;/code&gt; 세트를 구성합니다. 비트 열로 구현되어 고밀도 정수 세트 용으로 설계되었습니다. 집합이 희소 한 경우 (예 : 매우 큰 정수를 보유하는 경우) 대신 &lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb009dfa7962bbabb609c96c629280a0c8d96255" translate="yes" xml:space="preserve">
          <source>Construct a sparse diagonal matrix from &lt;code&gt;Pair&lt;/code&gt;s of vectors and diagonals. Each vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. By default (if &lt;code&gt;size=nothing&lt;/code&gt;), the matrix is square and its size is inferred from &lt;code&gt;kv&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; (padded with zeros as needed) can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">벡터와 대각선의 &lt;code&gt;Pair&lt;/code&gt; s 에서 희소 대각 행렬을 생성 합니다. 각 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 . 기본적으로 ( &lt;code&gt;size=nothing&lt;/code&gt; 인 경우 ) 행렬은 정사각형이고 크기는 &lt;code&gt;kv&lt;/code&gt; 에서 유추 되지만 , 첫 번째 인수로 &lt;code&gt;m,n&lt;/code&gt; 을 전달하여 정사각형이 아닌 크기 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; (필요에 따라 0으로 채워짐)을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45a1f7d88f46e1a876aecb1dc4b732278ee01769" translate="yes" xml:space="preserve">
          <source>Construct a square matrix from &lt;code&gt;Pair&lt;/code&gt;s of diagonals and vectors. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. &lt;code&gt;diagm&lt;/code&gt; constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt;&lt;code&gt;Bidiagonal&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대각선과 벡터의 &lt;code&gt;Pair&lt;/code&gt; 으로 정사각 행렬을 만듭니다. 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 . &lt;code&gt;diagm&lt;/code&gt; 은 전체 행렬을 구성합니다. 빠른 산술을 사용하는 스토리지 효율적인 버전을 원하면 &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt; &lt;code&gt;Bidiagonal&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="105188658b5054b3326fe1e162af42e4805232a3" translate="yes" xml:space="preserve">
          <source>Construct a square matrix with elements of the vector as diagonal elements.</source>
          <target state="translated">벡터 요소를 대각선 요소로 사용하여 정사각 행렬을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e83aca212f69ccb433491a23b4580555779709aa" translate="yes" xml:space="preserve">
          <source>Construct a square sparse diagonal matrix from &lt;code&gt;Pair&lt;/code&gt;s of vectors and diagonals. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal.</source>
          <target state="translated">&lt;code&gt;Pair&lt;/code&gt; 의 벡터와 대각선 으로 정사각형 희소 대각선 행렬을 만듭니다. 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="21bfe811706d6b39e27bb5e54824e3f9c00060be" translate="yes" xml:space="preserve">
          <source>Construct a string by using a &lt;code&gt;TimeType&lt;/code&gt; object and applying the provided &lt;code&gt;format&lt;/code&gt;. The following character codes can be used to construct the &lt;code&gt;format&lt;/code&gt; string:</source>
          <target state="translated">&lt;code&gt;TimeType&lt;/code&gt; 객체 를 사용 하고 제공된 &lt;code&gt;format&lt;/code&gt; 적용 하여 문자열을 생성 합니다 . 다음 문자 코드를 사용하여 &lt;code&gt;format&lt;/code&gt; 문자열 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e78af3110399316b26ade3d45b60e10fc708bcd9" translate="yes" xml:space="preserve">
          <source>Construct a substitution string, used for regular expression substitutions. Within the string, sequences of the form &lt;code&gt;\N&lt;/code&gt; refer to the Nth capture group in the regex, and &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; refers to a named capture group with name &lt;code&gt;groupname&lt;/code&gt;.</source>
          <target state="translated">정규식 대체에 사용되는 대체 문자열을 구성하십시오. 문자열 내에서 &lt;code&gt;\N&lt;/code&gt; 형식의 시퀀스 는 정규식의 N 번째 캡처 그룹을 참조하고 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 은 이름이 &lt;code&gt;groupname&lt;/code&gt; 인 명명 된 캡처 그룹을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7001fcde7ea51c36ac1824a5a8b0eedf713beed4" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal (&lt;code&gt;dv&lt;/code&gt;) and first sub/super-diagonal (&lt;code&gt;ev&lt;/code&gt;), respectively. The result is of type &lt;code&gt;SymTridiagonal&lt;/code&gt; and provides efficient specialized eigensolvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">대각선 ( &lt;code&gt;dv&lt;/code&gt; )과 첫 번째 sub / super-diagonal ( &lt;code&gt;ev&lt;/code&gt; )에서 각각 대칭 3 각형 행렬을 구성합니다 . 결과는 &lt;code&gt;SymTridiagonal&lt;/code&gt; 유형 이며 효율적인 특수 고유 솔버 를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8d5353fe58ad31b1de6c2b618a70ed090651651" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 대각선 및 첫 번째 하위 / 수퍼 대각선에서 대칭 3 각형 행렬을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a36cd1d4860652164376c75ff58e72c65814cf23" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal and first superdiagonal of the symmetric matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 대각선과 첫 번째 대 대각선에서 대칭 삼중 대각 행렬을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5e812abbcd333112ef665b3c50ab166d997a74f3" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 첫 번째 대각선, 대각선 및 첫 번째 대각선에서 삼각 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="747e5433f9793862323a449007017950fdbe1544" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type &lt;code&gt;Tridiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The lengths of &lt;code&gt;dl&lt;/code&gt; and &lt;code&gt;du&lt;/code&gt; must be one less than the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">첫 번째 대각선, 대각선 및 첫 번째 대각선에서 각각 3 각형 행렬을 만듭니다. 결과는 &lt;code&gt;Tridiagonal&lt;/code&gt; 유형 이며 효율적인 특수 선형 솔버를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 . 길이의 &lt;code&gt;dl&lt;/code&gt; 과 &lt;code&gt;du&lt;/code&gt; 의 길이보다 작아야 하나 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a45735b554554297a7fc87a9bba1a725ba384be" translate="yes" xml:space="preserve">
          <source>Construct a tuple of the given objects.</source>
          <target state="translated">주어진 객체의 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7fdc191ace6e9b509ad7d0b0a2b4eead7c650e5d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목으로 초기화 된 &lt;code&gt;T&lt;/code&gt; 유형의 요소를 포함 하는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8ff556a297608632796b72ff2cb3c8e84dd2779" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 된 &lt;code&gt;T&lt;/code&gt; 유형의 요소를 포함 하는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성 합니다. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae459e01fcce313d45a189e6a321f000a9d4614d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UnitUpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UnitUpperTriangular&lt;/code&gt; 뷰를 구성합니다 . 이러한 뷰는 보유 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 그 대각선에있다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a808b8435d8d2d16766a046ee8b6a2eb6d7ebc5" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UpperHessenberg&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Entries of &lt;code&gt;A&lt;/code&gt; below the first subdiagonal are ignored.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UpperHessenberg&lt;/code&gt; 뷰를 생성합니다 . 첫 번째 부 대각선 아래 의 &lt;code&gt;A&lt;/code&gt; 항목 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e5eea89cf2afaf3f4aa193305385c8f999189b8" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UpperTriangular&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="efa7a80292bce29eaa41f35b63dbae9f5d8943a7" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating array &lt;code&gt;A&lt;/code&gt; a given number of times in each dimension, specified by &lt;code&gt;counts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;counts&lt;/code&gt; 로 지정된 각 차원에서 지정된 횟수만큼 배열 &lt;code&gt;A&lt;/code&gt; 를 반복하여 배열 을 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="dabd5c0da772665da5c4fb23a09786030dae44d8" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating the entries of &lt;code&gt;A&lt;/code&gt;. The i-th element of &lt;code&gt;inner&lt;/code&gt; specifies the number of times that the individual entries of the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. The i-th element of &lt;code&gt;outer&lt;/code&gt; specifies the number of times that a slice along the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. If &lt;code&gt;inner&lt;/code&gt; or &lt;code&gt;outer&lt;/code&gt; are omitted, no repetition is performed.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 항목을 반복하여 배열을 구성하십시오 . 의 i 번째 요소 &lt;code&gt;inner&lt;/code&gt; 지정의 i 번째 차원의 개별 항목 횟수 &lt;code&gt;A&lt;/code&gt; 를 반복한다. 의 i 번째 요소 &lt;code&gt;outer&lt;/code&gt; 지정의 i 번째 슬라이스 사이즈에 따른 횟수 &lt;code&gt;A&lt;/code&gt; 를 반복한다. 경우 &lt;code&gt;inner&lt;/code&gt; 또는 &lt;code&gt;outer&lt;/code&gt; 생략하고, 더 반복은 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="35fd888bce1ff7aeaee21a4d838a36c377edec0b" translate="yes" xml:space="preserve">
          <source>Construct an undef &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; with the given dimensions. Behaves identically to the &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; constructor. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 치수로 &lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 를 구축 합니다. &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 생성자와 동일하게 동작합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54d87d0575b0e006fe5cc260cc0529044e72ab09" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">크기가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 인 초기화되지 않은 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eb6c96e45dddc926f98114383bd79e946048ede" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 초기화되지 않은 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 를 생성합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3ce437cb47785e9c47fa7a6dc465bfd8ef0ecab" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;N&lt;/code&gt; can either be supplied explicitly, as in &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt;, or be determined by the length or number of &lt;code&gt;dims&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank &lt;code&gt;N&lt;/code&gt; is supplied explicitly, then it must match the length or number of &lt;code&gt;dims&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 형의 요소를 포함 하는 초기화되지 않은 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성 합니다. &lt;code&gt;N&lt;/code&gt; 은 어느 하나에서와 같이 명시 적으로 제공 될 수 &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt; 또는 길이 또는 개수에 의해 결정될 수 &lt;code&gt;dims&lt;/code&gt; . &lt;code&gt;dims&lt;/code&gt; 는 각 차원의 길이에 해당하는 튜플 또는 일련의 정수 인수 일 수 있습니다. 순위 &lt;code&gt;N&lt;/code&gt; 이 명시 적으로 제공된 경우 길이 또는 &lt;code&gt;dims&lt;/code&gt; 수와 일치해야합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d99909abef5299b1e1b4f2472e34b18cf81e05f" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random cyclic permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 랜덤 순환 전치 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c5739db91a2916a6de2ec1c1497c1a0a7b92373" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random cyclic permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 랜덤 순환 전치 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7616bf15a3d66aa07b787d846cfe0bf2fc90fcbe" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;). To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 임의의 순열 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; ). 임의의 벡터를 무작위로 치환하려면 &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt; 참조하십시오 ! . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29fed1fdd69043bc2d52edc1a30a547c01f5cae5" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 임의의 순열 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; ). 임의의 벡터를 무작위로 치환하려면 &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt; 참조하십시오 ! . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b38dc6a46091930691f0979c241388b85fc088b0" translate="yes" xml:space="preserve">
          <source>Construct the intersection of sets. Maintain order with arrays.</source>
          <target state="translated">집합의 교집합을 만듭니다. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b5eeb48c87138f172c83ab82669efe34174ef13f" translate="yes" xml:space="preserve">
          <source>Construct the set of elements in &lt;code&gt;s&lt;/code&gt; but not in any of the iterables in &lt;code&gt;itrs&lt;/code&gt;. Maintain order with arrays.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; 의 iterables가 아닌 &lt;code&gt;s&lt;/code&gt; 로 요소 세트를 구성 하십시오 . 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2a22645f8ad348047eb67f511f7fff20c9a8a19d" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of elements in the passed in sets. When &lt;code&gt;s&lt;/code&gt; is not an &lt;code&gt;AbstractSet&lt;/code&gt;, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">전달 된 세트에서 요소의 대칭 적 차이를 구성하십시오. 경우 &lt;code&gt;s&lt;/code&gt; 아니 어서 &lt;code&gt;AbstractSet&lt;/code&gt; 순서가 유지된다. 이 경우 여러 요소가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0478a19afdbd482d3c0fcafa5d1ed46e5ac1b005" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of the passed in sets, and overwrite &lt;code&gt;s&lt;/code&gt; with the result. When &lt;code&gt;s&lt;/code&gt; is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">전달 된 세트의 대칭 차이 를 구성하고 결과로 &lt;code&gt;s&lt;/code&gt; 를 덮어 씁니다 . 경우 &lt;code&gt;s&lt;/code&gt; 배열되면, 순서는 유지된다. 이 경우 여러 요소가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4a79ebc653ff986cbb15a5ea08e6559fdafc9723" translate="yes" xml:space="preserve">
          <source>Construct the union of passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">세트 전달 및 덮어 쓰기의 조합 구축 &lt;code&gt;s&lt;/code&gt; 결과로. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8e4f2bd81d4e0c5eb2e81850ab74130f1b05c10b" translate="yes" xml:space="preserve">
          <source>Construct the union of sets. Maintain order with arrays.</source>
          <target state="translated">집합의 합집합을 구성하십시오. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e97901b09af90ecffd455fb1a47763d279bd2eaf" translate="yes" xml:space="preserve">
          <source>Constructing an object with &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; converts to the object's declared field types.</source>
          <target state="translated">와 객체 구축 &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 개체의 선언 필드 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4a770f4b726b7e17438de4d4705a42cdcff41d27" translate="yes" xml:space="preserve">
          <source>Constructing infinite rational values is acceptable:</source>
          <target state="translated">무한 합리적인 값을 구성하는 것은 허용됩니다 :</target>
        </trans-unit>
        <trans-unit id="7fac2273dfc18f832b908b46cc19ab6756b7533f" translate="yes" xml:space="preserve">
          <source>Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; or repeated multiplications, Julia allows interpolation into string literals using &lt;code&gt;$&lt;/code&gt;, as in Perl:</source>
          <target state="translated">그러나 연결을 사용하여 문자열을 구성하면 약간 번거로울 수 있습니다. 이러한 자세한 통화의 필요성 줄이기 위해 &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 또는 반복 곱셈, 줄리아는 문자열 리터럴로 보간 사용하실 수 있습니다 &lt;code&gt;$&lt;/code&gt; 를 펄과 같이 :</target>
        </trans-unit>
        <trans-unit id="1b21aefcdf98b76a2cdb3d34b924ca3a51ce9f3c" translate="yes" xml:space="preserve">
          <source>Construction Sign</source>
          <target state="translated">건설 사인</target>
        </trans-unit>
        <trans-unit id="e1fc1d68d6545bbe2eb454e9442edb86e725d413" translate="yes" xml:space="preserve">
          <source>Construction Worker</source>
          <target state="translated">건설 노동자</target>
        </trans-unit>
        <trans-unit id="e2a4ac16668ac3dfb92c81ed57d43e62fd409a66" translate="yes" xml:space="preserve">
          <source>Construction and Initialization</source>
          <target state="translated">건설 및 초기화</target>
        </trans-unit>
        <trans-unit id="21fac0a207cd61b900dd9c8aab0249aa29234d1a" translate="yes" xml:space="preserve">
          <source>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">이러한 혼합 된 경우를 적절하게 처리하는 생성자 메서드를 정의 할 수 있지만 나중에 &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;생성자&lt;/a&gt; 에서 논의하지 않을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d1de0471cc72ee7ecb3e7d438567f5775ca5ab6d" translate="yes" xml:space="preserve">
          <source>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">이러한 혼합 사례를 적절히 처리하기위한 생성자 메소드를 정의 할 수 있지만 나중에 &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 에서 논의 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="7b15c99cccb175b7231d573558f6e442c98078f7" translate="yes" xml:space="preserve">
          <source>Constructors &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; are functions that create new objects &amp;ndash; specifically, instances of &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt;. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</source>
          <target state="translated">생성자 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; 는 새로운 객체, 특히 &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; 인스턴스를 생성하는 함수입니다 . Julia에서 타입 객체는 생성자 함수로도 사용됩니다. 인수 튜플에 함수로 적용될 때 새로운 인스턴스를 생성합니다. 복합 유형이 소개 될 때이 부분은 이미 간략하게 언급되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="097ecd4b84dcf95c9a0dae551e3a08be98b8a0a4" translate="yes" xml:space="preserve">
          <source>Constructors &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; are functions that create new objects &amp;ndash; specifically, instances of &lt;a href=&quot;../types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt;. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</source>
          <target state="translated">생성자 &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 은 새로운 객체, 특히 &lt;a href=&quot;../types/index#Composite-Types&quot;&gt;Composite Type의&lt;/a&gt; 인스턴스를 생성하는 함수입니다 . Julia에서 유형 객체는 생성자 함수로도 사용됩니다. 인자 튜플에 함수로 적용될 때 자신의 새 인스턴스를 만듭니다. 이 정도는 복합 유형이 도입되었을 때 이미 간략하게 언급되었습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="96c5e9bf4fffd0020a62904e36d49838adcd0526" translate="yes" xml:space="preserve">
          <source>Constructors and Types</source>
          <target state="translated">생성자와 타입</target>
        </trans-unit>
        <trans-unit id="0335c1fc2e9e86f516636bf75a62df36bf31b328" translate="yes" xml:space="preserve">
          <source>Constructors exist to create these types from primitive numerical types, and &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; can be used to construct them from &lt;code&gt;AbstractString&lt;/code&gt;s. Once created, they participate in arithmetic with all other numeric types thanks to Julia's &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion and conversion mechanism&lt;/a&gt;:</source>
          <target state="translated">프리미티브 숫자 유형에서 이러한 유형을 작성하기 위해 생성자가 존재하며 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;code&gt;AbstractString&lt;/code&gt; 에서 유형 을 구성 할 수 있습니다 . 일단 생성되면 Julia의 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;유형 승격 및 변환 메커니즘&lt;/a&gt; 덕분에 다른 모든 숫자 유형과의 산술에 참여합니다 .</target>
        </trans-unit>
        <trans-unit id="342f876065464f411e3accfff34ace98a77223c0" translate="yes" xml:space="preserve">
          <source>Constructors exist to create these types from primitive numerical types, and the &lt;a href=&quot;../strings/index#non-standard-string-literals&quot;&gt;string literal&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.@big_str&quot;&gt;&lt;code&gt;@big_str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; can be used to construct them from &lt;code&gt;AbstractString&lt;/code&gt;s. Once created, they participate in arithmetic with all other numeric types thanks to Julia's &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type promotion and conversion mechanism&lt;/a&gt;:</source>
          <target state="translated">생성자는 원시 숫자 유형에서 이러한 유형을 생성하기 위해 존재하며 &lt;a href=&quot;../strings/index#non-standard-string-literals&quot;&gt;문자열 리터럴 &lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.@big_str&quot;&gt; &lt;code&gt;@big_str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;code&gt;AbstractString&lt;/code&gt; 에서 생성 할 수 있습니다 . 일단 생성되면 Julia의 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;유형 승격 및 변환 메커니즘&lt;/a&gt; 덕분에 다른 모든 숫자 유형과 함께 산술에 참여합니다 .</target>
        </trans-unit>
        <trans-unit id="f53def390cea96c19f58854f6ab25c6fcd002f64" translate="yes" xml:space="preserve">
          <source>Constructors for types unrelated to their arguments</source>
          <target state="translated">인수와 관련이없는 유형의 생성자</target>
        </trans-unit>
        <trans-unit id="f9c0c3b4014f45dbe2772c6f91e5e70044c87424" translate="yes" xml:space="preserve">
          <source>Constructors that don't return instances of their own type</source>
          <target state="translated">자체 유형의 인스턴스를 반환하지 않는 생성자</target>
        </trans-unit>
        <trans-unit id="2241b504fd0fc9cdfe7adafcdccaaf1a06355ec8" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Channel&lt;/code&gt; with an internal buffer that can hold a maximum of &lt;code&gt;size&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; calls on a full channel block until an object is removed with &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 형 의 최대 &lt;code&gt;size&lt;/code&gt; 객체를 보유 할 수있는 내부 버퍼가 있는 &lt;code&gt;Channel&lt;/code&gt; 을 구성합니다 . &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;take!&lt;/code&gt; 로 개체가 제거 될 때까지 전체 채널 블록을 호출합니다 . .</target>
        </trans-unit>
        <trans-unit id="cf8786bb19baaa35e14eeb1b40975a00c375a3b2" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Channel&lt;/code&gt; with an internal buffer that can hold a maximum of &lt;code&gt;sz&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; calls on a full channel block until an object is removed with &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부 버퍼로 &lt;code&gt;T&lt;/code&gt; 형 의 최대 &lt;code&gt;sz&lt;/code&gt; 객체를 보관할 수 있는 &lt;code&gt;Channel&lt;/code&gt; 을 구축합니다 . &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt; 하여 객체를 제거 할 때까지 전체 채널 블록에서 호출합니다 ! .</target>
        </trans-unit>
        <trans-unit id="d4f2020b38d81687704d5f3eafd379e31ccefbd8" translate="yes" xml:space="preserve">
          <source>Constructs an upper (&lt;code&gt;uplo=:U&lt;/code&gt;) or lower (&lt;code&gt;uplo=:L&lt;/code&gt;) bidiagonal matrix using the given diagonal (&lt;code&gt;dv&lt;/code&gt;) and off-diagonal (&lt;code&gt;ev&lt;/code&gt;) vectors. The result is of type &lt;code&gt;Bidiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The length of &lt;code&gt;ev&lt;/code&gt; must be one less than the length of &lt;code&gt;dv&lt;/code&gt;.</source>
          <target state="translated">주어진 대각선 ( &lt;code&gt;dv&lt;/code&gt; ) 및 비 대각선 ( &lt;code&gt;ev&lt;/code&gt; ) 벡터를 사용하여 위 ( &lt;code&gt;uplo=:U&lt;/code&gt; ) 또는 하 ( &lt;code&gt;uplo=:L&lt;/code&gt; ) 쌍각 행렬을 구성합니다 . 결과는 &lt;code&gt;Bidiagonal&lt;/code&gt; 유형 이며 효율적인 특수 선형 솔버를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 . 의 길이 &lt;code&gt;ev&lt;/code&gt; 의 길이보다 하나 작아야합니다 &lt;code&gt;dv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6ef0e63fc68a8523f73ef7005740900302c3bf1" translate="yes" xml:space="preserve">
          <source>Container types generally implement 3-argument &lt;code&gt;show&lt;/code&gt; by calling &lt;code&gt;show(io, MIME&quot;text/plain&quot;(), x)&lt;/code&gt; for elements &lt;code&gt;x&lt;/code&gt;, with &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; set in an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; passed as the first argument.</source>
          <target state="translated">컨테이너 유형은 일반적으로 3 인수 구현 &lt;code&gt;show&lt;/code&gt; 호출하여 &lt;code&gt;show(io, MIME&quot;text/plain&quot;(), x)&lt;/code&gt; 요소에 대한 &lt;code&gt;x&lt;/code&gt; 와 함께 &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; 세트를에 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; 는&lt;/a&gt; 첫 번째 인수로 전달.</target>
        </trans-unit>
        <trans-unit id="31855f42648a53f0f883864dfbb8c76728ada032" translate="yes" xml:space="preserve">
          <source>Contains As Member</source>
          <target state="translated">회원으로 포함</target>
        </trans-unit>
        <trans-unit id="6374949f24934c8f59af915f665fe9ad04edf8fb" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup</source>
          <target state="translated">일반 하위 그룹으로 포함</target>
        </trans-unit>
        <trans-unit id="c6255fd2009d9e2b6c2d76d570b84317f3968045" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup Or Equal To</source>
          <target state="translated">일반 하위 그룹으로 포함 또는</target>
        </trans-unit>
        <trans-unit id="bddb6860083f671133b8edfd2c54cc768d4aa9a9" translate="yes" xml:space="preserve">
          <source>Contains With Long Horizontal Stroke</source>
          <target state="translated">긴 수평 스트로크 포함</target>
        </trans-unit>
        <trans-unit id="8b7cbaa37f45d1b7957bf24d5d47157af046982a" translate="yes" xml:space="preserve">
          <source>Contains With Overbar</source>
          <target state="translated">오버 바와 함께 포함</target>
        </trans-unit>
        <trans-unit id="7c34feec9ab0b7359b089f798a1fbac1a7ebc48f" translate="yes" xml:space="preserve">
          <source>Contains With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">수평 스트로크 끝에 수직 막대 포함</target>
        </trans-unit>
        <trans-unit id="c3a18764e13219b073d5d7052ee1c75c3fd0245e" translate="yes" xml:space="preserve">
          <source>Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.</source>
          <target state="translated">페치 된 브랜치의 이름 및 URL, HEAD의 OID 및 페치 된 HEAD가 로컬로 병합되었는지 여부를 포함하여 페치 중 HEAD에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7606203ccba192fbac54fde902d8586ac81effb6" translate="yes" xml:space="preserve">
          <source>Contour Integral</source>
          <target state="translated">윤곽 적분</target>
        </trans-unit>
        <trans-unit id="4722c5ea64f5bf604117b9b25da5ac1ab2753262" translate="yes" xml:space="preserve">
          <source>Control Flow</source>
          <target state="translated">제어 흐름</target>
        </trans-unit>
        <trans-unit id="e7d0119a994fc38f14a5d2d52d98f6d567da9857" translate="yes" xml:space="preserve">
          <source>Control Flow and Short-Circuiting Operators</source>
          <target state="translated">제어 흐름 및 단락 연산자</target>
        </trans-unit>
        <trans-unit id="ac3c5834f77ae59c902947ccef1074dc7ca1801a" translate="yes" xml:space="preserve">
          <source>Control flow</source>
          <target state="translated">제어 흐름</target>
        </trans-unit>
        <trans-unit id="4683dd6403ab370d23d6560a4e21f414bfac0f26" translate="yes" xml:space="preserve">
          <source>Control flow operators including &lt;a href=&quot;../../base/base/index#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;ternary operator&lt;/a&gt;&lt;code&gt;x ? y : z&lt;/code&gt; do not allow for missing values. This is because of the uncertainty about whether the actual value would be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if we could observe it, which implies that we do not know how the program should behave. A &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown as soon as a &lt;code&gt;missing&lt;/code&gt; value is encountered in this context</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;삼항 연산자 &lt;/a&gt; &lt;code&gt;x ? y : z&lt;/code&gt; 포함한 제어 흐름 연산자 ? y : z 는 결 측값을 허용하지 않습니다. 이것은 우리가 관찰 할 수 있다면 실제 값이 &lt;code&gt;true&lt;/code&gt; 인지 &lt;code&gt;false&lt;/code&gt; 인지에 대한 불확실성 때문이며 , 이는 프로그램이 어떻게 작동해야하는지 알지 못한다는 것을 의미합니다. &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; A와 자마자 발생합니다 &lt;code&gt;missing&lt;/code&gt; 값이 맥락에서 발생</target>
        </trans-unit>
        <trans-unit id="72f9c97f5741988f58f0cfe9c25d834ba26762be" translate="yes" xml:space="preserve">
          <source>Control flow operators including &lt;a href=&quot;../../base/base/index#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;ternary operator&lt;/a&gt;&lt;code&gt;x ? y : z&lt;/code&gt; do not allow for missing values. This is because of the uncertainty about whether the actual value would be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if we could observe it, which implies that we do not know how the program should behave. A &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown as soon as a &lt;code&gt;missing&lt;/code&gt; value is encountered in this context</source>
          <target state="translated">를 포함한 제어 흐름 사업자 &lt;a href=&quot;../../base/base/index#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;삼항 연산자의 &lt;/a&gt; &lt;code&gt;x ? y : z&lt;/code&gt; 는 결 측값을 허용하지 않습니다. 관찰 할 수 있는 실제 값이 &lt;code&gt;true&lt;/code&gt; 인지 &lt;code&gt;false&lt;/code&gt; 인지에 대한 불확실성 때문입니다. 이는 프로그램의 작동 방식을 알 수 없음을 의미합니다. &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; A와 자마자 발생합니다 &lt;code&gt;missing&lt;/code&gt; 값이 맥락에서 발생</target>
        </trans-unit>
        <trans-unit id="14b7866ef465dde33929d7924f93fff8b8dbc0b9" translate="yes" xml:space="preserve">
          <source>Control whether garbage collection is enabled using a boolean argument (&lt;code&gt;true&lt;/code&gt; for enabled, &lt;code&gt;false&lt;/code&gt; for disabled). Return previous GC state.</source>
          <target state="translated">가비지 수집 (부울 인수하여 사용할 수 있는지 여부를 제어 &lt;code&gt;true&lt;/code&gt; 활성화를위한, &lt;code&gt;false&lt;/code&gt; 장애인을). 이전 GC 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14f8f8ee865f088942c342818dc4e3bbb1536995" translate="yes" xml:space="preserve">
          <source>Control whether inlining is permitted, including overriding &lt;code&gt;@inline&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;@inline&lt;/code&gt; 선언 재정의를 포함하여 인라인 허용 여부 제어</target>
        </trans-unit>
        <trans-unit id="cacef9e904c125c2f7ac4e42d389c8844e172ac2" translate="yes" xml:space="preserve">
          <source>Convenience Store</source>
          <target state="translated">편의점</target>
        </trans-unit>
        <trans-unit id="e97a673f9a9eebff3f10ed71f5a88d461090a8ca" translate="yes" xml:space="preserve">
          <source>Convenience functions for metaprogramming.</source>
          <target state="translated">메타 프로그래밍을위한 편의 기능.</target>
        </trans-unit>
        <trans-unit id="fd9b14a00b20c7a8276bd5748c3165fb1ca289f8" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; returns an uninitialized &lt;code&gt;BitVector&lt;/code&gt; with two elements since &lt;code&gt;BitArray&lt;/code&gt;s are both mutable and can support 1-dimensional arrays:</source>
          <target state="translated">반대로, &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; 는 &lt;code&gt;BitArray&lt;/code&gt; 가 둘 다 변경 가능하고 1 차원 배열을 지원할 수 있으므로 두 개의 요소 가있는 초기화되지 않은 &lt;code&gt;BitVector&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4234a78959811f144edc9c62e989cabf24ee370a" translate="yes" xml:space="preserve">
          <source>Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:</source>
          <target state="translated">반대로, 문자열 벡터를 LibGit2에 전달할 때 일반적으로 암시 적 변환에 의존하는 것이 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="8cc29d077456587b44d9a48d75801504d22c31b2" translate="yes" xml:space="preserve">
          <source>Conversion Functions</source>
          <target state="translated">변환 함수</target>
        </trans-unit>
        <trans-unit id="04666b33ed1c43f23bbe0e99877e7f10b6a933fa" translate="yes" xml:space="preserve">
          <source>Conversion and Promotion</source>
          <target state="translated">전환 및 프로모션</target>
        </trans-unit>
        <trans-unit id="8d86d2ec0c7b6756fe66cc1bf719bbb241833abb" translate="yes" xml:space="preserve">
          <source>Conversion from rational to floating-point respects the following identity for any integral values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, with the exception of the case &lt;code&gt;a == 0&lt;/code&gt; and &lt;code&gt;b == 0&lt;/code&gt;:</source>
          <target state="translated">유리수의 부동 점 중 정수 값에 대해 다음 신원 변환 및 &lt;code&gt;b&lt;/code&gt; 의 경우를 제외하고, &lt;code&gt;a == 0&lt;/code&gt; 및 &lt;code&gt;b == 0&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3d18830aded7a67b783185496d43f80b4d4144" translate="yes" xml:space="preserve">
          <source>Conversion isn't always possible, in which case a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is thrown indicating that &lt;code&gt;convert&lt;/code&gt; doesn't know how to perform the requested conversion:</source>
          <target state="translated">변환이 항상 가능한 것은 아닙니다.이 경우 &lt;code&gt;convert&lt;/code&gt; 이 요청 된 변환을 수행하는 방법을 모른다는 것을 나타내는 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="3ee457d7a754e6e789e5e9067e307640598d5fdf" translate="yes" xml:space="preserve">
          <source>Conversion isn't always possible, in which case a no method error is thrown indicating that &lt;code&gt;convert&lt;/code&gt; doesn't know how to perform the requested conversion:</source>
          <target state="translated">변환이 항상 가능한 것은 아니며,이 경우 &lt;code&gt;convert&lt;/code&gt; 이 요청 된 변환을 수행하는 방법을 모른다는 것을 나타내는 메소드 오류가 발생 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c85fbb802a404d058a90790ec033af382ae6bcd" translate="yes" xml:space="preserve">
          <source>Conversion vs. Construction</source>
          <target state="translated">전환 대 건설</target>
        </trans-unit>
        <trans-unit id="156f3c8386685fd957672db82cc983d0b1768fc0" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를도에서 라디안으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="930fbd712c9569bcac9a41934f09fb34d835188c" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 라디안에서도 단위로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="aaf4386c273bdc11f6c707ae019613ac6e236b92" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a C argument of type &lt;code&gt;T&lt;/code&gt; where the input &lt;code&gt;x&lt;/code&gt; must be the return value of &lt;code&gt;cconvert(T, ...)&lt;/code&gt;.</source>
          <target state="translated">변환 &lt;code&gt;x&lt;/code&gt; 형의 인수 C로 &lt;code&gt;T&lt;/code&gt; 입력 &lt;code&gt;x&lt;/code&gt; 는 반환 값이어야 &lt;code&gt;cconvert(T, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4acb077b4d119d3ed00eeba6aa056446504f49a" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 유형의 값으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="91ec563506a54debc59cdb744c1c00d2ff1a3c35" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value to be passed to C code as type &lt;code&gt;T&lt;/code&gt;, typically by calling &lt;code&gt;convert(T, x)&lt;/code&gt;.</source>
          <target state="translated">변환 &lt;code&gt;x&lt;/code&gt; 의 값으로 입력으로서 C 코드에 전달할 &lt;code&gt;T&lt;/code&gt; 전형적으로 호출함으로써, &lt;code&gt;convert(T, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3cb248dc70e1ee69a390558f82f6e2af4dac4b" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to an object that has &lt;code&gt;axes&lt;/code&gt; and supports indexing</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;axes&lt;/code&gt; 있고 색인을 지원 하는 객체로 변환</target>
        </trans-unit>
        <trans-unit id="def5bf1795c56c2c61188495ac929f9d40e5f863" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;y&lt;/code&gt; to the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;convert(typeof(x), y)&lt;/code&gt;).</source>
          <target state="translated">변환 &lt;code&gt;y&lt;/code&gt; 유형에 &lt;code&gt;x&lt;/code&gt; ( &lt;code&gt;convert(typeof(x), y)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad4bb4dbf97061448cd4f6b22cbb5a0e5289b08e" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Date&lt;/code&gt; to a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the new &lt;code&gt;DateTime&lt;/code&gt; are assumed to be zero.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 를 &lt;code&gt;DateTime&lt;/code&gt; 으로 변환하십시오 . 새 &lt;code&gt;DateTime&lt;/code&gt; 의시 , 분, 초 및 밀리 초 부분은 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="031081832af367cd87e42057b3adc69a323b88c8" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Date&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are truncated, so only the year, month and day parts are used in construction.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 을 &lt;code&gt;Date&lt;/code&gt; 로 변환하십시오 . &lt;code&gt;DateTime&lt;/code&gt; 의 시간, 분, 초 및 밀리 초 부분 이 잘 리므로 년, 월 및 일 부분 만 구성에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="987898a3319e41bac5f9dbe1956b4e7e2b290ba4" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Time&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are used to create the new &lt;code&gt;Time&lt;/code&gt;. Microsecond and nanoseconds are zero by default.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 을 &lt;code&gt;Time&lt;/code&gt; 변환하십시오 . &lt;code&gt;DateTime&lt;/code&gt; 의시 , 분, 초 및 밀리 초 부분은 새 &lt;code&gt;Time&lt;/code&gt; 을 만드는 데 사용됩니다 . 마이크로 초 및 나노초는 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="697f574b741b0307339ff2b81d5ecba120fae99d" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Ptr&lt;/code&gt; to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &quot;unsafe&quot; and should be used with care.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 을 객체 참조로 변환합니다 . 포인터가 유효한 힙 할당 Julia 객체를 참조한다고 가정합니다. 그렇지 않은 경우 정의되지 않은 동작이 발생하므로이 기능은 &quot;안전하지 않은&quot;것으로 간주되므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dd17d692e3047c02ceced8797177e51afe3b937" translate="yes" xml:space="preserve">
          <source>Convert a Win32 system call error code to a descriptive string [only available on Windows].</source>
          <target state="translated">Win32 시스템 호출 오류 코드를 설명 문자열 (Windows에서만 사용 가능)로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd6dfa20fba21ea7113b5c7cbcac03d4ed64703" translate="yes" xml:space="preserve">
          <source>Convert a number of seconds since the epoch to broken-down format, with fields &lt;code&gt;sec&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;mday&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;wday&lt;/code&gt;, &lt;code&gt;yday&lt;/code&gt;, and &lt;code&gt;isdst&lt;/code&gt;.</source>
          <target state="translated">epoch 이후의 초 수를 &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;mday&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;wday&lt;/code&gt; , &lt;code&gt;yday&lt;/code&gt; 및 &lt;code&gt;isdst&lt;/code&gt; 필드를 사용하여 분류 형식으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bacdc75b4f7b34973b32c316e9223e93efc1358" translate="yes" xml:space="preserve">
          <source>Convert a number or array to a floating point data type.</source>
          <target state="translated">숫자 나 배열을 부동 소수점 데이터 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e2fe46f6de6c971f0ac0667455bdde8ca5b1ddfa" translate="yes" xml:space="preserve">
          <source>Convert a number to a maximum precision representation (typically &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;BigFloat&lt;/code&gt;). See &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; for information about some pitfalls with floating-point numbers.</source>
          <target state="translated">숫자를 최대 정밀도 표현 (일반적으로 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;BigFloat&lt;/code&gt; ) 으로 변환하십시오 . 부동 소수점 숫자가있는 함정에 대한 정보는 &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66f60301033862b1a2c3227918f5dcb7ad2365b4" translate="yes" xml:space="preserve">
          <source>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</source>
          <target state="translated">숫자를 부호있는 정수로 변환하십시오. 인수가 서명되지 않은 경우 오버플로를 확인하지 않고 서명 된 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a09c50d7cce1fe8a525fcca2fb263328178ae3" translate="yes" xml:space="preserve">
          <source>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</source>
          <target state="translated">숫자를 부호없는 정수로 변환합니다. 인수가 서명 된 경우 음수 값을 확인하지 않고 부호없는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fadb2f4e5a02f95b1f6e83b26d6f82c505453eb8" translate="yes" xml:space="preserve">
          <source>Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in &lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt;&lt;code&gt;normpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필요한 경우 현재 디렉토리를 추가하여 경로를 절대 경로로 변환하십시오. 또한 &lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt; &lt;code&gt;normpath&lt;/code&gt; &lt;/a&gt; 에서와 같이 경로를 정규화합니다 .</target>
        </trans-unit>
        <trans-unit id="c64e3ac7b8c2c5fca5fadcf3e79dd14dcfa93264" translate="yes" xml:space="preserve">
          <source>Convert a set of paths to a normalized path by joining them together and removing &quot;.&quot; and &quot;..&quot; entries. Equivalent to &lt;code&gt;normpath(joinpath(path, paths...))&lt;/code&gt;.</source>
          <target state="translated">경로 세트를 함께 결합하고 &quot;.&quot;를 제거하여 정규화 된 경로로 변환합니다. 및 &quot;..&quot;항목. 상당 &lt;code&gt;normpath(joinpath(path, paths...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99b4eb18032a744b83dd1a3438570db3228d17cf" translate="yes" xml:space="preserve">
          <source>Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt;.</source>
          <target state="translated">경로를 결합하고 필요한 경우 현재 디렉토리를 추가하여 경로 세트를 절대 경로로 변환하십시오. 상당 &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9696c8728ca32245943263f7e7949895d8e5a6e" translate="yes" xml:space="preserve">
          <source>Convert a string to &lt;code&gt;String&lt;/code&gt; type and check that it contains only ASCII data, otherwise throwing an &lt;code&gt;ArgumentError&lt;/code&gt; indicating the position of the first non-ASCII byte.</source>
          <target state="translated">문자열을 &lt;code&gt;String&lt;/code&gt; 유형으로 변환하고 ASCII 데이터 만 포함하는지 확인하십시오. 그렇지 않으면 첫 번째 비 ASCII 바이트의 위치를 ​​나타내는 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6034bf2e7e922ec416e6749722dfe4bed51455b" translate="yes" xml:space="preserve">
          <source>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</source>
          <target state="translated">문자열을 UTF-8 바이트로 인코딩 된 연속 바이트 배열 표현으로 변환하십시오. 이 표현은 종종 문자열을 C로 전달하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bdb2e7f4ffa842fe969c9313fede05ab9811deb6" translate="yes" xml:space="preserve">
          <source>Convert a system call error code to a descriptive string</source>
          <target state="translated">시스템 호출 오류 코드를 설명 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="df69e31a6e1a10ddfb886835ab258a4b8daa2d29" translate="yes" xml:space="preserve">
          <source>Convert a vector &lt;code&gt;A&lt;/code&gt; into a sparse vector of length &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;A&lt;/code&gt; 를 길이가 &lt;code&gt;m&lt;/code&gt; 인 희소 벡터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc282b0433c1cbf1adcdf19666900f8ea0803139" translate="yes" xml:space="preserve">
          <source>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</source>
          <target state="translated">모든 인수를 공통 유형으로 변환하고 모두 반환합니다 (튜플). 인수를 변환 할 수 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="852c15744182eeb7c79c535ea0a2080ac574b6a1" translate="yes" xml:space="preserve">
          <source>Convert an AbstractMatrix &lt;code&gt;A&lt;/code&gt; into a sparse matrix.</source>
          <target state="translated">AbstractMatrix &lt;code&gt;A&lt;/code&gt; 를 희소 행렬로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd1965142740f5cf0ae1e7c6f35ada62fa5be03b" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;a&lt;/code&gt; of bytes to its hexadecimal string representation, either returning a &lt;code&gt;String&lt;/code&gt; via &lt;code&gt;bytes2hex(a)&lt;/code&gt; or writing the string to an &lt;code&gt;io&lt;/code&gt; stream via &lt;code&gt;bytes2hex(io, a)&lt;/code&gt;. The hexadecimal characters are all lowercase.</source>
          <target state="translated">배열 변환 복귀하거나, 16 진수 문자열 표현 바이트를 &lt;code&gt;String&lt;/code&gt; 통해 &lt;code&gt;bytes2hex(a)&lt;/code&gt; 또는 상기 문자열을 기록 &lt;code&gt;io&lt;/code&gt; 통해 스트림 &lt;code&gt;bytes2hex(io, a)&lt;/code&gt; . 16 진 문자는 모두 소문자입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a38bb337cc64d1083f1c5c3e38c9c4ed1f44e10" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;s&lt;/code&gt; of bytes representing a hexadecimal string to its binary representation, similar to &lt;a href=&quot;#Base.hex2bytes&quot;&gt;&lt;code&gt;hex2bytes&lt;/code&gt;&lt;/a&gt; except that the output is written in-place in &lt;code&gt;d&lt;/code&gt;. The length of &lt;code&gt;s&lt;/code&gt; must be exactly twice the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">배열 변환 &lt;code&gt;s&lt;/code&gt; 유사한 바이너리 표기로 16 진수 문자열 나타내는 바이트 &lt;a href=&quot;#Base.hex2bytes&quot;&gt; &lt;code&gt;hex2bytes&lt;/code&gt; &lt;/a&gt; 출력의 현재 위치에서 기록되는 것을 제외 &lt;code&gt;d&lt;/code&gt; . 의 길이 &lt;code&gt;s&lt;/code&gt; 정확히 두 배의 길이가 같아야합니다 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab9684db5f30d74a1280d752f440f84eeb49090d" translate="yes" xml:space="preserve">
          <source>Convert an integer &lt;code&gt;n&lt;/code&gt; to a string in the given &lt;code&gt;base&lt;/code&gt;, optionally specifying a number of digits to pad to.</source>
          <target state="translated">정수 &lt;code&gt;n&lt;/code&gt; 을 주어진 &lt;code&gt;base&lt;/code&gt; 의 문자열로 변환하고 , 선택적으로 채울 자릿수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fb901c455490a134851d84ef564c097e7214f635" translate="yes" xml:space="preserve">
          <source>Convert an integer bitstype to the signed type of the same size.</source>
          <target state="translated">정수 비트 유형을 동일한 크기의 부호있는 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3a99ef55f693cc997a2d2a862cf2e9207340000d" translate="yes" xml:space="preserve">
          <source>Convert an integer bitstype to the unsigned type of the same size.</source>
          <target state="translated">정수 비트 유형을 동일한 크기의 부호없는 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1cc0fdb51bb3f7b06edff8342aa122caf1731c55" translate="yes" xml:space="preserve">
          <source>Convert every array-slicing operation in the given expression (which may be a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; calls (as opposed to &lt;code&gt;array[...]&lt;/code&gt;) are unaffected.</source>
          <target state="translated">주어진 표현식 ( &lt;code&gt;begin&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록, 루프, 함수 등일 수 있음)의 모든 배열 분할 작업을 변환 하여 뷰를 반환합니다. 스칼라 인덱스, 비 배열 유형 및 명시 적 &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 호출 ( &lt;code&gt;array[...]&lt;/code&gt; 과 반대 )은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bb7b84b2270454fbcbf5570fc65757f1e6cebfc" translate="yes" xml:space="preserve">
          <source>Convert every array-slicing operation in the given expression (which may be a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit &lt;code&gt;getindex&lt;/code&gt; calls (as opposed to &lt;code&gt;array[...]&lt;/code&gt;) are unaffected.</source>
          <target state="translated">주어진 표현식 ( &lt;code&gt;begin&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록, 루프, 함수 등) 에서 모든 배열 슬라이스 연산을 변환 하여 뷰를 반환합니다. 스칼라 인덱스, 비 배열 유형 및 명시 적 &lt;code&gt;getindex&lt;/code&gt; 호출 ( &lt;code&gt;array[...]&lt;/code&gt; 과 반대 )은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7ef92f4671416f4ce071adc16fbedc518d6e5a" translate="yes" xml:space="preserve">
          <source>Convert every function call or operator in &lt;code&gt;expr&lt;/code&gt; into a &quot;dot call&quot; (e.g. convert &lt;code&gt;f(x)&lt;/code&gt; to &lt;code&gt;f.(x)&lt;/code&gt;), and convert every assignment in &lt;code&gt;expr&lt;/code&gt; to a &quot;dot assignment&quot; (e.g. convert &lt;code&gt;+=&lt;/code&gt; to &lt;code&gt;.+=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 모든 함수 호출 또는 연산자를 &quot;도트 호출&quot;로 변환하고 (예 : &lt;code&gt;f(x)&lt;/code&gt; 를 &lt;code&gt;f.(x)&lt;/code&gt; 로 변환) &lt;code&gt;expr&lt;/code&gt; 의 모든 할당을 &quot;도트 할당&quot;으로 변환하십시오 (예 : &lt;code&gt;+=&lt;/code&gt; 를 &lt;code&gt;.+=&lt;/code&gt; 로 변환) . ).</target>
        </trans-unit>
        <trans-unit id="6f641f897c98f470a3a4f4e71179b8ae693f515e" translate="yes" xml:space="preserve">
          <source>Convert real numbers or arrays to complex. &lt;code&gt;i&lt;/code&gt; defaults to zero.</source>
          <target state="translated">실수 나 배열을 복소수로 변환합니다. &lt;code&gt;i&lt;/code&gt; 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="ea87e33fbea9c0120e69dc6eed464787821a1d70" translate="yes" xml:space="preserve">
          <source>Convert string data between Unicode encodings. &lt;code&gt;src&lt;/code&gt; is either a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-XX code units, where &lt;code&gt;XX&lt;/code&gt; is 8, 16, or 32. &lt;code&gt;T&lt;/code&gt; indicates the encoding of the return value: &lt;code&gt;String&lt;/code&gt; to return a (UTF-8 encoded) &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;UIntXX&lt;/code&gt; to return a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-&lt;code&gt;XX&lt;/code&gt; data. (The alias &lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt; can also be used as the integer type, for converting &lt;code&gt;wchar_t*&lt;/code&gt; strings used by external C libraries.)</source>
          <target state="translated">유니 코드 인코딩간에 문자열 데이터를 변환하십시오. &lt;code&gt;src&lt;/code&gt; 중 하나 인 &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; UTF-XX 코드 유닛, &lt;code&gt;XX&lt;/code&gt; 는 8, 16 또는 32 &lt;code&gt;T&lt;/code&gt; 는 반환 값의 부호화를 나타낸다 : &lt;code&gt;String&lt;/code&gt; 리턴하는 (UTF-8 인코딩 된) &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;UIntXX&lt;/code&gt; UTF- &lt;code&gt;XX&lt;/code&gt; 데이터 의 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; 를 반환합니다 . (별칭 &lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; 는 외부 C 라이브러리에서 사용되는 &lt;code&gt;wchar_t*&lt;/code&gt; 문자열 을 변환하기 위해 정수 유형으로 사용될 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="1172d0b4f4da770ba5d6e3b4b74228cbdea8c23f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Little-endian to that used by the Host.</source>
          <target state="translated">값의 엔디안을 리틀 엔디안에서 호스트가 사용한 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c18794ff42dbcbf70c7fa0958060c571a3feef1f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.</source>
          <target state="translated">값의 엔디안을 네트워크 바이트 순서 (빅 엔디안)에서 호스트가 사용하는 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ee8fe2deb202452db007076df4772a7e3e60b91d" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Little-endian.</source>
          <target state="translated">호스트가 사용하는 값의 엔디안을 리틀 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b7d61d4fb701d27d4ecda27bcc686224302e3849" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Network byte order (big-endian).</source>
          <target state="translated">호스트가 사용하는 값의 엔디안을 네트워크 바이트 순서 (빅 엔디안)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="565d86b9efdcc54de17ee229897b1971efcc1d5c" translate="yes" xml:space="preserve">
          <source>Convert the tuple &lt;code&gt;I&lt;/code&gt; to a tuple of indices for use in indexing into array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 로 인덱싱하는 데 사용하기 위해 튜플 &lt;code&gt;I&lt;/code&gt; 을 인덱스 튜플로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="52c9208e095da06dd48451e1db0c0aee98a6ff21" translate="yes" xml:space="preserve">
          <source>Convert time, given as a number of seconds since the epoch or a &lt;code&gt;TmStruct&lt;/code&gt;, to a formatted string using the given format. Supported formats are the same as those in the standard C library.</source>
          <target state="translated">epoch 또는 &lt;code&gt;TmStruct&lt;/code&gt; 이후의 시간 (초)을 주어진 형식을 사용하여 형식화 된 문자열로 변환하십시오. 지원되는 형식은 표준 C 라이브러리의 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="360e237e67baf5581a5d0115e51882b0bb64ba9d" translate="yes" xml:space="preserve">
          <source>Converting Types</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="117dbbf5f7e13aaaf56b35238348c17bd82dc1bc" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;TmStruct&lt;/code&gt; struct to a number of seconds since the epoch.</source>
          <target state="translated">에포크 이후 &lt;code&gt;TmStruct&lt;/code&gt; 구조체를 몇 초로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5866856f7d0f1c179b640e313eb7bf260c150d0d" translate="yes" xml:space="preserve">
          <source>Converts a matrix &lt;code&gt;A&lt;/code&gt; to Hessenberg form. If &lt;code&gt;A&lt;/code&gt; is balanced with &lt;code&gt;gebal!&lt;/code&gt; then &lt;code&gt;ilo&lt;/code&gt; and &lt;code&gt;ihi&lt;/code&gt; are the outputs of &lt;code&gt;gebal!&lt;/code&gt;. Otherwise they should be &lt;code&gt;ilo = 1&lt;/code&gt; and &lt;code&gt;ihi = size(A,2)&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains the elementary reflectors of the factorization.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 를 Hessenberg 형식으로 변환합니다 . 경우 &lt;code&gt;A&lt;/code&gt; 를 함께 균형 &lt;code&gt;gebal!&lt;/code&gt; 다음 &lt;code&gt;ilo&lt;/code&gt; 와 &lt;code&gt;ihi&lt;/code&gt; 의 출력이다 &lt;code&gt;gebal!&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;ilo = 1&lt;/code&gt; 이고 &lt;code&gt;ihi = size(A,2)&lt;/code&gt; 이어야합니다 . &lt;code&gt;tau&lt;/code&gt; 에는 인수 분해의 기본 반사기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1711b47dad4f073679f712d5d8503b9e8e2c5d54" translate="yes" xml:space="preserve">
          <source>Converts a symmetric matrix &lt;code&gt;A&lt;/code&gt; (which has been factorized into a triangular matrix) into two matrices &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, it is lower triangular. &lt;code&gt;ipiv&lt;/code&gt; is the pivot vector from the triangular factorization. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; (삼각 행렬로 인수 분해 된)를 두 행렬 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;D&lt;/code&gt; 로 변환 합니다. 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 위 삼각형이다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 그것은 낮은 삼각형이다. &lt;code&gt;ipiv&lt;/code&gt; 는 삼각 인수 분해의 피벗 벡터입니다. &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;D&lt;/code&gt; 로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d8c7fb874a17720b78d3d32ee54b7667d9caa6f0" translate="yes" xml:space="preserve">
          <source>Cooked Rice</source>
          <target state="translated">밥</target>
        </trans-unit>
        <trans-unit id="e4f81994fed009c24d31efd799e2d47a74a60f1f" translate="yes" xml:space="preserve">
          <source>Cookie</source>
          <target state="translated">Cookie</target>
        </trans-unit>
        <trans-unit id="adc0752adbfda6b3ef82749db7442cd223b6747a" translate="yes" xml:space="preserve">
          <source>Cooking</source>
          <target state="translated">Cooking</target>
        </trans-unit>
        <trans-unit id="c9e99b6e36ab0f9069dac6df2dcc61a6537dc4c2" translate="yes" xml:space="preserve">
          <source>Copies a &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; onto a matrix.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; 을 행렬에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="418fd7d86083eefae2bf5a47108856be4e4e9db0" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source array to a destination, starting at offset &lt;code&gt;so&lt;/code&gt; in the source and &lt;code&gt;do&lt;/code&gt; in the destination (1-indexed).</source>
          <target state="translated">복사 &lt;code&gt;N&lt;/code&gt; 의 오프셋부터 목적지까지의 소스 어레이의 요소 &lt;code&gt;so&lt;/code&gt; 소스와 &lt;code&gt;do&lt;/code&gt; 대상으로는 (1 인덱스).</target>
        </trans-unit>
        <trans-unit id="7086ba74676f7b4baf8153047650ee206892eea8" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</source>
          <target state="translated">확인하지 않고 소스 포인터에서 대상으로 &lt;code&gt;N&lt;/code&gt; 개의 요소를 복사 합니다. 요소의 크기는 포인터의 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7118082371777be2d61109ed4a6ec97a39e710bf" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from collection &lt;code&gt;src&lt;/code&gt; starting at offset &lt;code&gt;so&lt;/code&gt;, to array &lt;code&gt;dest&lt;/code&gt; starting at offset &lt;code&gt;do&lt;/code&gt;. Return &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">복사 &lt;code&gt;N&lt;/code&gt; 은 컬렉션에서 요소 &lt;code&gt;src&lt;/code&gt; 오프셋에서 시작 &lt;code&gt;so&lt;/code&gt; 배열, &lt;code&gt;dest&lt;/code&gt; 오프셋에서 시작 &lt;code&gt;do&lt;/code&gt; . &lt;code&gt;dest&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="616082f2612838a8057d0aa6612b818ee3ba8c7c" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; to array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;. Returns &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">복사 &lt;code&gt;n&lt;/code&gt; 어레이의 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드 &lt;code&gt;incx&lt;/code&gt; 배열 &lt;code&gt;Y&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; . &lt;code&gt;Y&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="253b3d8af9e09ae697807ccdabe6d0a1942c068a" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from &lt;code&gt;ref&lt;/code&gt; (converted to a pointer) into the &lt;code&gt;IO&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; (포인터로 변환) 에서 &lt;code&gt;nbytes&lt;/code&gt; 를 &lt;code&gt;IO&lt;/code&gt; 객체 로 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="ea9498c0d16fa0098a8db0d0c7d3b47780674f69" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from the &lt;code&gt;IO&lt;/code&gt; stream object into &lt;code&gt;ref&lt;/code&gt; (converted to a pointer).</source>
          <target state="translated">복사 &lt;code&gt;nbytes&lt;/code&gt; 를 으로부터 &lt;code&gt;IO&lt;/code&gt; 에 스트림 개체 &lt;code&gt;ref&lt;/code&gt; (포인터로 변환).</target>
        </trans-unit>
        <trans-unit id="cecc4cc050ce4f8f91b18f5c82de61727aae33fa" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;src&lt;/code&gt; into &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">복사 &lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08e257c9c4d564810a26439e40c66e18e83ae663" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;, indexing each dimension modulo its length. &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap &lt;code&gt;dest&lt;/code&gt; agrees with &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 를 &lt;code&gt;dest&lt;/code&gt; 로 복사 하여 각 치수의 길이를 색인화합니다. &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 의 크기는 같아야하지만 색인에서 오프셋 될 수 있습니다. 오프셋은 (원형) 랩 어라운드가됩니다. 배열에 겹치는 인덱스가있는 경우 겹치는 &lt;code&gt;dest&lt;/code&gt; 도메인에서 &lt;code&gt;src&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9b33b198b9b8b92a3f9f121307b7a03e6e7ec92b" translate="yes" xml:space="preserve">
          <source>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If &lt;code&gt;length&lt;/code&gt; is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</source>
          <target state="translated">UTF-8로 인코딩 된 C 스타일 (NUL 종료) 문자열의 주소에서 문자열을 복사하십시오. (포인터는 나중에 안전하게 해제 할 수 있습니다.) &lt;code&gt;length&lt;/code&gt; 가 지정 되면 (데이터 길이 (바이트)) 문자열을 NUL로 종료하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="f8307ea4c313c8f99116fbe12b7c396813b3593b" translate="yes" xml:space="preserve">
          <source>Copy all elements from collection &lt;code&gt;src&lt;/code&gt; to array &lt;code&gt;dest&lt;/code&gt;, whose length must be greater than or equal to the length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;src&lt;/code&gt;. The first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;dest&lt;/code&gt; are overwritten, the other elements are left untouched.</source>
          <target state="translated">컬렉션 &lt;code&gt;src&lt;/code&gt; 에서 배열 &lt;code&gt;dest&lt;/code&gt; 로 모든 요소를 ​​복사하십시오 . 길이 는 &lt;code&gt;src&lt;/code&gt; 의 길이 &lt;code&gt;n&lt;/code&gt; 이상이어야합니다 . &lt;code&gt;dest&lt;/code&gt; 의 처음 &lt;code&gt;n&lt;/code&gt; 개 요소를 덮어 쓰고 다른 요소는 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6b49bda32e0b471d6ea10bd5d65c62d773295ea5" translate="yes" xml:space="preserve">
          <source>Copy the block of &lt;code&gt;src&lt;/code&gt; in the range of &lt;code&gt;Rsrc&lt;/code&gt; to the block of &lt;code&gt;dest&lt;/code&gt; in the range of &lt;code&gt;Rdest&lt;/code&gt;. The sizes of the two regions must match.</source>
          <target state="translated">블록 복사 &lt;code&gt;src&lt;/code&gt; 의 범위 &lt;code&gt;Rsrc&lt;/code&gt; 의 블록에 &lt;code&gt;dest&lt;/code&gt; 의 범위 &lt;code&gt;Rdest&lt;/code&gt; . 두 지역의 크기가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bdeec364785727145bf632b0f9eaad5598f487d" translate="yes" xml:space="preserve">
          <source>Copy the current region in the kill ring</source>
          <target state="translated">킬 링에서 현재 영역 복사</target>
        </trans-unit>
        <trans-unit id="494b84244d7a79e3d342146f96d197a9b13df1d4" translate="yes" xml:space="preserve">
          <source>Copy the file, link, or directory from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;. &lt;code&gt;force=true&lt;/code&gt; will first remove an existing &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">파일, 링크 또는 디렉토리를 &lt;code&gt;src&lt;/code&gt; 에서 &lt;code&gt;dst&lt;/code&gt; 로 복사하십시오 . &lt;code&gt;force=true&lt;/code&gt; 는 먼저 기존 &lt;code&gt;dst&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ee05611b1d41b30e8e6d979b4a8c4ff7e600adce" translate="yes" xml:space="preserve">
          <source>Copying data is not always bad</source>
          <target state="translated">데이터 복사가 항상 나쁜 것은 아닙니다</target>
        </trans-unit>
        <trans-unit id="6eab3f0cb190b20918906dcc82257ab7baf2ba9e" translate="yes" xml:space="preserve">
          <source>Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even with the cost of the copying operation.</source>
          <target state="translated">액세스하기 전에 불규칙적으로 액세스 한 데이터를 연속 배열로 복사하면 아래 예와 같이 속도가 크게 향상 될 수 있습니다. 여기서, 행렬과 벡터는 곱하기 전에 무작위로 섞인 인덱스의 80 만에서 액세스됩니다. 뷰를 일반 배열로 복사하면 복사 작업 비용이 들더라도 곱셈 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="d0c22df05117339fafe1fd329c21b24a26965dec" translate="yes" xml:space="preserve">
          <source>Copyright Sign</source>
          <target state="translated">저작권 표시</target>
        </trans-unit>
        <trans-unit id="68836c550ee20fae0e06b2994e76a40348d2fc30" translate="yes" xml:space="preserve">
          <source>Core</source>
          <target state="translated">Core</target>
        </trans-unit>
        <trans-unit id="fdb7dcf725d9ff74eadf1406976c3bbf0d70d15b" translate="yes" xml:space="preserve">
          <source>Core task operations</source>
          <target state="translated">핵심 업무 운영</target>
        </trans-unit>
        <trans-unit id="68435718cfd9186e13509c3cd4f4f701746b7939" translate="yes" xml:space="preserve">
          <source>Core.&amp;lt;:()</source>
          <target state="translated">Core.&amp;lt;:()</target>
        </trans-unit>
        <trans-unit id="bfa0a59bcde017b3bf44267b3b277a7fdf03f8bf" translate="yes" xml:space="preserve">
          <source>Core.===()</source>
          <target state="translated">Core.===()</target>
        </trans-unit>
        <trans-unit id="fcb0332d7a6b80924b0dfc6c123f03da619ce8d4" translate="yes" xml:space="preserve">
          <source>Core.@big_str</source>
          <target state="translated">Core.@big_str</target>
        </trans-unit>
        <trans-unit id="bd9ec38dd953eaa5a860fec42fa6768a8786b8d0" translate="yes" xml:space="preserve">
          <source>Core.@int128_str</source>
          <target state="translated">Core.@int128_str</target>
        </trans-unit>
        <trans-unit id="0b9fd6658d00a8f0d4ddba1c694762831760c04c" translate="yes" xml:space="preserve">
          <source>Core.@uint128_str</source>
          <target state="translated">Core.@uint128_str</target>
        </trans-unit>
        <trans-unit id="296ea7eb4542328f4efed568f4ac64a33cf2409c" translate="yes" xml:space="preserve">
          <source>Core.AbstractArray</source>
          <target state="translated">Core.AbstractArray</target>
        </trans-unit>
        <trans-unit id="8745757e6d6f0de944cab467602f5200bce73b7e" translate="yes" xml:space="preserve">
          <source>Core.AbstractChar</source>
          <target state="translated">Core.AbstractChar</target>
        </trans-unit>
        <trans-unit id="f9281ac1584aba88d1656863173c6f811866e39f" translate="yes" xml:space="preserve">
          <source>Core.AbstractFloat</source>
          <target state="translated">Core.AbstractFloat</target>
        </trans-unit>
        <trans-unit id="0da6ad13678bdbb6acf562fb31b0b9f43ba7eeae" translate="yes" xml:space="preserve">
          <source>Core.Any</source>
          <target state="translated">Core.Any</target>
        </trans-unit>
        <trans-unit id="b3072e9fbde249b0b11582e28eb5a550b752fb88" translate="yes" xml:space="preserve">
          <source>Core.ArgumentError</source>
          <target state="translated">Core.ArgumentError</target>
        </trans-unit>
        <trans-unit id="22888907eae68bd24b045af66a40d0a8f87acdd9" translate="yes" xml:space="preserve">
          <source>Core.Array</source>
          <target state="translated">Core.Array</target>
        </trans-unit>
        <trans-unit id="5c05caf0af207ca1fc8ad944b0c939c40b9cce04" translate="yes" xml:space="preserve">
          <source>Core.Array()</source>
          <target state="translated">Core.Array()</target>
        </trans-unit>
        <trans-unit id="ef890d110df62768b77f96641bef0d688692fae8" translate="yes" xml:space="preserve">
          <source>Core.AssertionError</source>
          <target state="translated">Core.AssertionError</target>
        </trans-unit>
        <trans-unit id="cda39cf69fda9fce4d0c1778474bccee844768ee" translate="yes" xml:space="preserve">
          <source>Core.Bool</source>
          <target state="translated">Core.Bool</target>
        </trans-unit>
        <trans-unit id="4e265496d9deac0745814371223730156f90e897" translate="yes" xml:space="preserve">
          <source>Core.BoundsError</source>
          <target state="translated">Core.BoundsError</target>
        </trans-unit>
        <trans-unit id="7697e231c0791c99d5656377ad1d693d3f25f083" translate="yes" xml:space="preserve">
          <source>Core.Char</source>
          <target state="translated">Core.Char</target>
        </trans-unit>
        <trans-unit id="872d7172ca50deb1dbfd90eb8902b8b30803b5d4" translate="yes" xml:space="preserve">
          <source>Core.DenseArray</source>
          <target state="translated">Core.DenseArray</target>
        </trans-unit>
        <trans-unit id="db1a4814a9b53a7950c8ccd92b6dbe4af18418aa" translate="yes" xml:space="preserve">
          <source>Core.DivideError</source>
          <target state="translated">Core.DivideError</target>
        </trans-unit>
        <trans-unit id="b63a322de4037bae4a418bcf83078c60409fa5e3" translate="yes" xml:space="preserve">
          <source>Core.DomainError</source>
          <target state="translated">Core.DomainError</target>
        </trans-unit>
        <trans-unit id="2c8038f41e046ff62ed186b6d660cf4350c07ccf" translate="yes" xml:space="preserve">
          <source>Core.ErrorException</source>
          <target state="translated">Core.ErrorException</target>
        </trans-unit>
        <trans-unit id="85a946975d5b2c6fa108054a69ce79f2b5fc2652" translate="yes" xml:space="preserve">
          <source>Core.Expr</source>
          <target state="translated">Core.Expr</target>
        </trans-unit>
        <trans-unit id="adf8a4356b24273f499a98d68588a98afee415cd" translate="yes" xml:space="preserve">
          <source>Core.Float16</source>
          <target state="translated">Core.Float16</target>
        </trans-unit>
        <trans-unit id="ade26249e3759ff4627e030863adb88ab7ffd435" translate="yes" xml:space="preserve">
          <source>Core.Float32</source>
          <target state="translated">Core.Float32</target>
        </trans-unit>
        <trans-unit id="75be2bd2d217782dee5803d78dab051f0a7e3b93" translate="yes" xml:space="preserve">
          <source>Core.Float32()</source>
          <target state="translated">Core.Float32()</target>
        </trans-unit>
        <trans-unit id="574a2ac03f1d4269225e9a7ca962ddc1f5bd6e0d" translate="yes" xml:space="preserve">
          <source>Core.Float64</source>
          <target state="translated">Core.Float64</target>
        </trans-unit>
        <trans-unit id="03b78b265bb8a851f590786360777f4cd4b19a4b" translate="yes" xml:space="preserve">
          <source>Core.Float64()</source>
          <target state="translated">Core.Float64()</target>
        </trans-unit>
        <trans-unit id="7933daacfc58b32ea3800c70c574573e5458dcb7" translate="yes" xml:space="preserve">
          <source>Core.Function</source>
          <target state="translated">Core.Function</target>
        </trans-unit>
        <trans-unit id="038ca03580088ce3d37623c61fcfb6b6d38b3b70" translate="yes" xml:space="preserve">
          <source>Core.InexactError</source>
          <target state="translated">Core.InexactError</target>
        </trans-unit>
        <trans-unit id="d515ef0a8a3fc2e74d7ee3db5592a37ef66cc882" translate="yes" xml:space="preserve">
          <source>Core.InitError</source>
          <target state="translated">Core.InitError</target>
        </trans-unit>
        <trans-unit id="2f346bbcdb1733a15da2deaa4cf7a101a054f984" translate="yes" xml:space="preserve">
          <source>Core.Int128</source>
          <target state="translated">Core.Int128</target>
        </trans-unit>
        <trans-unit id="c76244f8ec1bd146db47ff63ece7126c5ecce326" translate="yes" xml:space="preserve">
          <source>Core.Int16</source>
          <target state="translated">Core.Int16</target>
        </trans-unit>
        <trans-unit id="c07ac7ba49337c002f8438bdc4d76f2c6a794a5c" translate="yes" xml:space="preserve">
          <source>Core.Int32</source>
          <target state="translated">Core.Int32</target>
        </trans-unit>
        <trans-unit id="b1e8c71c0fb7e8eab7fd15e32e3ee02f915bff32" translate="yes" xml:space="preserve">
          <source>Core.Int64</source>
          <target state="translated">Core.Int64</target>
        </trans-unit>
        <trans-unit id="5adeeb593c47c8434e007cc9d7ad654b1432f11e" translate="yes" xml:space="preserve">
          <source>Core.Int8</source>
          <target state="translated">Core.Int8</target>
        </trans-unit>
        <trans-unit id="206ab216f9946898d4ee569a813c97775ab8ffcf" translate="yes" xml:space="preserve">
          <source>Core.Integer</source>
          <target state="translated">Core.Integer</target>
        </trans-unit>
        <trans-unit id="1343f4493cbdfd067dd4f726c3b29faa6c47842a" translate="yes" xml:space="preserve">
          <source>Core.InterruptException</source>
          <target state="translated">Core.InterruptException</target>
        </trans-unit>
        <trans-unit id="fdb7594617144c898358d6c191b858273e707e23" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.cglobal()</source>
          <target state="translated">Core.Intrinsics.cglobal()</target>
        </trans-unit>
        <trans-unit id="20a6f90cce155a7d96ef21eba9e005decf144663" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.llvmcall()</source>
          <target state="translated">Core.Intrinsics.llvmcall()</target>
        </trans-unit>
        <trans-unit id="9d1e0921e79d54209b004fcd22a42096752ac75f" translate="yes" xml:space="preserve">
          <source>Core.LoadError</source>
          <target state="translated">Core.LoadError</target>
        </trans-unit>
        <trans-unit id="49c38522ed9ed9a6b135598c807c7b66b22c7d0f" translate="yes" xml:space="preserve">
          <source>Core.MethodError</source>
          <target state="translated">Core.MethodError</target>
        </trans-unit>
        <trans-unit id="08214c47346ff58b29a097b06211a25218897dce" translate="yes" xml:space="preserve">
          <source>Core.Module</source>
          <target state="translated">Core.Module</target>
        </trans-unit>
        <trans-unit id="996b2ba514d97834bc0ceb8962906ba1e309c7be" translate="yes" xml:space="preserve">
          <source>Core.NamedTuple</source>
          <target state="translated">Core.NamedTuple</target>
        </trans-unit>
        <trans-unit id="ddc807b05bcc708dae9f3daa7882c6fde768500d" translate="yes" xml:space="preserve">
          <source>Core.Nothing</source>
          <target state="translated">Core.Nothing</target>
        </trans-unit>
        <trans-unit id="a1605b3e5d4af33eb1d784995584944805da8837" translate="yes" xml:space="preserve">
          <source>Core.Number</source>
          <target state="translated">Core.Number</target>
        </trans-unit>
        <trans-unit id="cffb759d0acecb70b71e451b128264827b26a45a" translate="yes" xml:space="preserve">
          <source>Core.OutOfMemoryError</source>
          <target state="translated">Core.OutOfMemoryError</target>
        </trans-unit>
        <trans-unit id="50247e38ef244b0ab195213eedbe440a9527a25b" translate="yes" xml:space="preserve">
          <source>Core.OverflowError</source>
          <target state="translated">Core.OverflowError</target>
        </trans-unit>
        <trans-unit id="605ce58fd15cef2081e72fcb473a964295017b72" translate="yes" xml:space="preserve">
          <source>Core.Ptr</source>
          <target state="translated">Core.Ptr</target>
        </trans-unit>
        <trans-unit id="4aa22b1ac5767c7ece2ff37b7ab6f5d66aba74b8" translate="yes" xml:space="preserve">
          <source>Core.ReadOnlyMemoryError</source>
          <target state="translated">Core.ReadOnlyMemoryError</target>
        </trans-unit>
        <trans-unit id="9992b8232ed5a4608d8e3e1f57264bdc1498a162" translate="yes" xml:space="preserve">
          <source>Core.Real</source>
          <target state="translated">Core.Real</target>
        </trans-unit>
        <trans-unit id="c4bb8bde829e5b0177d93f78e5c4c26bedd45ec7" translate="yes" xml:space="preserve">
          <source>Core.Ref</source>
          <target state="translated">Core.Ref</target>
        </trans-unit>
        <trans-unit id="1e88502e1b0fca449b8c177759df82c8249fabfb" translate="yes" xml:space="preserve">
          <source>Core.Signed</source>
          <target state="translated">Core.Signed</target>
        </trans-unit>
        <trans-unit id="7de85a1c4301bd314784c9e532d83c75b1188e9d" translate="yes" xml:space="preserve">
          <source>Core.StackOverflowError</source>
          <target state="translated">Core.StackOverflowError</target>
        </trans-unit>
        <trans-unit id="ebfcbc7bb941162c317f7df668e55edccfa18ac5" translate="yes" xml:space="preserve">
          <source>Core.String()</source>
          <target state="translated">Core.String()</target>
        </trans-unit>
        <trans-unit id="c6b2ff713285f8a3d3545ee703798b5068fbc8b6" translate="yes" xml:space="preserve">
          <source>Core.Symbol</source>
          <target state="translated">Core.Symbol</target>
        </trans-unit>
        <trans-unit id="719ea15b5ef608e4f9b483e46d27867d7856adfe" translate="yes" xml:space="preserve">
          <source>Core.Symbol()</source>
          <target state="translated">Core.Symbol()</target>
        </trans-unit>
        <trans-unit id="b6bc78ec3881f86a73e0838ab877c6f01e947ac2" translate="yes" xml:space="preserve">
          <source>Core.Task</source>
          <target state="translated">Core.Task</target>
        </trans-unit>
        <trans-unit id="d4b3751dcc1da5e0797ccacfd253215eabafb483" translate="yes" xml:space="preserve">
          <source>Core.Tuple</source>
          <target state="translated">Core.Tuple</target>
        </trans-unit>
        <trans-unit id="2e5f4d43cf5b759a7ebd1cd5bb3d3b2c243df101" translate="yes" xml:space="preserve">
          <source>Core.TypeError</source>
          <target state="translated">Core.TypeError</target>
        </trans-unit>
        <trans-unit id="724ead70ae6bd23978147c8c986a4fbdc8583ca6" translate="yes" xml:space="preserve">
          <source>Core.UInt128</source>
          <target state="translated">Core.UInt128</target>
        </trans-unit>
        <trans-unit id="bb4c71b5a350b8c4fa05237a29f1315b1c8b4c65" translate="yes" xml:space="preserve">
          <source>Core.UInt16</source>
          <target state="translated">Core.UInt16</target>
        </trans-unit>
        <trans-unit id="6b5bd5abfa77e3c13b1d6819cdf8ff6ea9e64cad" translate="yes" xml:space="preserve">
          <source>Core.UInt32</source>
          <target state="translated">Core.UInt32</target>
        </trans-unit>
        <trans-unit id="3b2afa5595b029a3c3dc735df40952b6a6b196db" translate="yes" xml:space="preserve">
          <source>Core.UInt64</source>
          <target state="translated">Core.UInt64</target>
        </trans-unit>
        <trans-unit id="8c423ad2856bb21a956fcd2f4b4af48877d7fb9e" translate="yes" xml:space="preserve">
          <source>Core.UInt8</source>
          <target state="translated">Core.UInt8</target>
        </trans-unit>
        <trans-unit id="f94b6de69ba6173c6644374bcc0b67c77c478ae9" translate="yes" xml:space="preserve">
          <source>Core.UndefInitializer</source>
          <target state="translated">Core.UndefInitializer</target>
        </trans-unit>
        <trans-unit id="07b2f6fdbd7c59ad9163de0145ef16bf9bb28382" translate="yes" xml:space="preserve">
          <source>Core.UndefKeywordError</source>
          <target state="translated">Core.UndefKeywordError</target>
        </trans-unit>
        <trans-unit id="33d1c00d40609a506a1c35270754761d90c0643e" translate="yes" xml:space="preserve">
          <source>Core.UndefRefError</source>
          <target state="translated">Core.UndefRefError</target>
        </trans-unit>
        <trans-unit id="bdca7f953b36d0f03db4bc9fd8e6e861149fef33" translate="yes" xml:space="preserve">
          <source>Core.UndefVarError</source>
          <target state="translated">Core.UndefVarError</target>
        </trans-unit>
        <trans-unit id="be58e03a069d35a51db9fb4c724606c99abcd8b9" translate="yes" xml:space="preserve">
          <source>Core.Union</source>
          <target state="translated">Core.Union</target>
        </trans-unit>
        <trans-unit id="e8113afc597f4a15b3f06158979a5211244f841e" translate="yes" xml:space="preserve">
          <source>Core.UnionAll</source>
          <target state="translated">Core.UnionAll</target>
        </trans-unit>
        <trans-unit id="d886f4e20b6cb8b062e068aba58a5987a8c7d2da" translate="yes" xml:space="preserve">
          <source>Core.Unsigned</source>
          <target state="translated">Core.Unsigned</target>
        </trans-unit>
        <trans-unit id="33fe88c7ffcf0538e076168da43cd25b19b4de0a" translate="yes" xml:space="preserve">
          <source>Core.Vararg</source>
          <target state="translated">Core.Vararg</target>
        </trans-unit>
        <trans-unit id="4dcab8b27937c697ace2bf0c7ab731d9d437bdeb" translate="yes" xml:space="preserve">
          <source>Core.applicable()</source>
          <target state="translated">Core.applicable()</target>
        </trans-unit>
        <trans-unit id="643b383aa84c34ae8992b0cb054491c81b1dc047" translate="yes" xml:space="preserve">
          <source>Core.eval()</source>
          <target state="translated">Core.eval()</target>
        </trans-unit>
        <trans-unit id="8b059cdc2fd7f4f078d1167b0f81e44ea9df09d6" translate="yes" xml:space="preserve">
          <source>Core.fieldtype()</source>
          <target state="translated">Core.fieldtype()</target>
        </trans-unit>
        <trans-unit id="3ae90d79ffdde7d1fe93c0138223ea72cb2bc8cf" translate="yes" xml:space="preserve">
          <source>Core.getfield()</source>
          <target state="translated">Core.getfield()</target>
        </trans-unit>
        <trans-unit id="2cb5d2a4c6e112f5caca0b950aafc402728e9c5c" translate="yes" xml:space="preserve">
          <source>Core.ifelse()</source>
          <target state="translated">Core.ifelse()</target>
        </trans-unit>
        <trans-unit id="c29e94ae444083d76a880a241f6c75f3ddc68a35" translate="yes" xml:space="preserve">
          <source>Core.invoke()</source>
          <target state="translated">Core.invoke()</target>
        </trans-unit>
        <trans-unit id="76b4f8fbfbbabba6e83b3468fcf7b96015579ea3" translate="yes" xml:space="preserve">
          <source>Core.isa()</source>
          <target state="translated">Core.isa()</target>
        </trans-unit>
        <trans-unit id="36f7c8e658b3370440e7f26e5b0e4965b949fa9d" translate="yes" xml:space="preserve">
          <source>Core.isdefined()</source>
          <target state="translated">Core.isdefined()</target>
        </trans-unit>
        <trans-unit id="9b23ab990d5c62c2a078014be7c66a0c3e4e1394" translate="yes" xml:space="preserve">
          <source>Core.nfields()</source>
          <target state="translated">Core.nfields()</target>
        </trans-unit>
        <trans-unit id="4bfdc3e9e44bf9286116897901c1386226161cb5" translate="yes" xml:space="preserve">
          <source>Core.nothing</source>
          <target state="translated">Core.nothing</target>
        </trans-unit>
        <trans-unit id="6acb02115e779813d9385b137998287991df61da" translate="yes" xml:space="preserve">
          <source>Core.setfield!()</source>
          <target state="translated">Core.setfield!()</target>
        </trans-unit>
        <trans-unit id="bc2b402dd92c1cb92209691d06c9c374342c53a9" translate="yes" xml:space="preserve">
          <source>Core.throw()</source>
          <target state="translated">Core.throw()</target>
        </trans-unit>
        <trans-unit id="12b149e509e75748d21363920cd40e30cf380071" translate="yes" xml:space="preserve">
          <source>Core.tuple()</source>
          <target state="translated">Core.tuple()</target>
        </trans-unit>
        <trans-unit id="00cee46b6d3520d8c9c0c302e4b9730ef4385bad" translate="yes" xml:space="preserve">
          <source>Core.typeassert()</source>
          <target state="translated">Core.typeassert()</target>
        </trans-unit>
        <trans-unit id="7344a7481965a908a1f63b50bbb06366f78822b8" translate="yes" xml:space="preserve">
          <source>Core.typeof()</source>
          <target state="translated">Core.typeof()</target>
        </trans-unit>
        <trans-unit id="4cb44a3ac4df4587e83db94499b7bd7b15a3a955" translate="yes" xml:space="preserve">
          <source>Core.undef</source>
          <target state="translated">Core.undef</target>
        </trans-unit>
        <trans-unit id="2a3a3a3048165677aa2036a7e01c3f31a8bbfbb9" translate="yes" xml:space="preserve">
          <source>CoreLogging.@logmsg</source>
          <target state="translated">CoreLogging.@logmsg</target>
        </trans-unit>
        <trans-unit id="083ef9f048bb882c300a709aa3193ebca0066017" translate="yes" xml:space="preserve">
          <source>CoreLogging.AbstractLogger</source>
          <target state="translated">CoreLogging.AbstractLogger</target>
        </trans-unit>
        <trans-unit id="7c45671f3a729162c6b794ce5d37c65b5cbd80e7" translate="yes" xml:space="preserve">
          <source>CoreLogging.LogLevel</source>
          <target state="translated">CoreLogging.LogLevel</target>
        </trans-unit>
        <trans-unit id="3b0cd222c6d045285b8ee0e92684b83aa993eb4f" translate="yes" xml:space="preserve">
          <source>CoreLogging.NullLogger</source>
          <target state="translated">CoreLogging.NullLogger</target>
        </trans-unit>
        <trans-unit id="75c612241d78e232d7df16e944c5688b6ecbdfbf" translate="yes" xml:space="preserve">
          <source>CoreLogging.SimpleLogger</source>
          <target state="translated">CoreLogging.SimpleLogger</target>
        </trans-unit>
        <trans-unit id="2fdcbae49ec42113338fc354b312540a678eb99e" translate="yes" xml:space="preserve">
          <source>CoreLogging.catch_exceptions()</source>
          <target state="translated">CoreLogging.catch_exceptions()</target>
        </trans-unit>
        <trans-unit id="e26bf5e0d56d658332efbdc5621c8d5d99db9b89" translate="yes" xml:space="preserve">
          <source>CoreLogging.current_logger()</source>
          <target state="translated">CoreLogging.current_logger()</target>
        </trans-unit>
        <trans-unit id="32150b661acfb793c5deeae4288c6191c29a1026" translate="yes" xml:space="preserve">
          <source>CoreLogging.disable_logging()</source>
          <target state="translated">CoreLogging.disable_logging()</target>
        </trans-unit>
        <trans-unit id="1712227ca3e5fec340a2b54bce74f24c7c5894a1" translate="yes" xml:space="preserve">
          <source>CoreLogging.global_logger()</source>
          <target state="translated">CoreLogging.global_logger()</target>
        </trans-unit>
        <trans-unit id="fc77ba9c031aea4b788610634d6c81e058c01fc8" translate="yes" xml:space="preserve">
          <source>CoreLogging.handle_message()</source>
          <target state="translated">CoreLogging.handle_message()</target>
        </trans-unit>
        <trans-unit id="21ade7f50b5f2b77fdf90e85ff21a4ceaddd4938" translate="yes" xml:space="preserve">
          <source>CoreLogging.min_enabled_level()</source>
          <target state="translated">CoreLogging.min_enabled_level()</target>
        </trans-unit>
        <trans-unit id="30f3427e9053621f7d5d000fa501744a3a42e204" translate="yes" xml:space="preserve">
          <source>CoreLogging.shouldlog()</source>
          <target state="translated">CoreLogging.shouldlog()</target>
        </trans-unit>
        <trans-unit id="78d98592599bcbbc6ff9697d2764ea3f8b09a44d" translate="yes" xml:space="preserve">
          <source>CoreLogging.with_logger()</source>
          <target state="translated">CoreLogging.with_logger()</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="e604caf78b008bde3ccc386c0b84af93d1674441" translate="yes" xml:space="preserve">
          <source>Correspondence of dense and sparse methods</source>
          <target state="translated">밀도가 높고 드문 드문 한 방법의 대응</target>
        </trans-unit>
        <trans-unit id="2ec7eef5d591077c31b1059b29fd9a3796d5e738" translate="yes" xml:space="preserve">
          <source>Corresponding &lt;code&gt;jl_box_...&lt;/code&gt; functions are used to convert the other way:</source>
          <target state="translated">해당하는 &lt;code&gt;jl_box_...&lt;/code&gt; 함수는 다른 방법으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8bdb62815e350c629536da5f5a35ffb4c857a8f" translate="yes" xml:space="preserve">
          <source>Corresponds To</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="a5e3b3a59299174adc5ed55ffbac2813ee3c97b7" translate="yes" xml:space="preserve">
          <source>Count bytes allocated by each source line</source>
          <target state="translated">각 소스 라인에 의해 할당 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="a935e1d9fca63f3ad42808a862be5e14dcaefbac" translate="yes" xml:space="preserve">
          <source>Count executions of source lines</source>
          <target state="translated">소스 라인의 실행 횟수</target>
        </trans-unit>
        <trans-unit id="f43f1defbbf16380629ae2bbaba07b0d193c0c34" translate="yes" xml:space="preserve">
          <source>Count the number of elements in &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; over the given dimensions.</source>
          <target state="translated">주어진 차원에서 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 &lt;code&gt;A&lt;/code&gt; 의 요소 수를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="864fe9b91cbdb4ea474b1e34b2b240291fdf1186" translate="yes" xml:space="preserve">
          <source>Count the number of elements in &lt;code&gt;itr&lt;/code&gt; for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is omitted, counts the number of &lt;code&gt;true&lt;/code&gt; elements in &lt;code&gt;itr&lt;/code&gt; (which should be a collection of boolean values).</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 &lt;code&gt;itr&lt;/code&gt; 의 요소 수를 계산하십시오 . 경우 &lt;code&gt;p&lt;/code&gt; 생략되어, 수 계산 &lt;code&gt;true&lt;/code&gt; 요소 &lt;code&gt;itr&lt;/code&gt; (부울 값 모음이어야 함).</target>
        </trans-unit>
        <trans-unit id="5495a2d2b7b75f22e845e609a82f0800b95ac639" translate="yes" xml:space="preserve">
          <source>Couple With Heart</source>
          <target state="translated">마음으로 커플</target>
        </trans-unit>
        <trans-unit id="33935f03e2050408f5414a4ce0ae315ea392ec16" translate="yes" xml:space="preserve">
          <source>Cow</source>
          <target state="translated">Cow</target>
        </trans-unit>
        <trans-unit id="19ec818c8eeccac36c9d30bc148eee4f5bc6c6c2" translate="yes" xml:space="preserve">
          <source>Cow Face</source>
          <target state="translated">암소 얼굴</target>
        </trans-unit>
        <trans-unit id="f45bf4b76973272a188e74b1e822bd5271792064" translate="yes" xml:space="preserve">
          <source>Cptrdiff_t</source>
          <target state="translated">Cptrdiff_t</target>
        </trans-unit>
        <trans-unit id="2052ca757ec7aad7cca2aa68837fc9d25c6aad32" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; with element type computed from the &lt;code&gt;promote_typeof&lt;/code&gt; of the argument, containing the argument list.</source>
          <target state="translated">인수 목록을 포함하여 인수 의 &lt;code&gt;promote_typeof&lt;/code&gt; 에서 계산 된 요소 유형 으로 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a1cfccbb74fce45e29fc62bfbbfd863c0eaf829c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; by concatenating the string representations of the arguments together.</source>
          <target state="translated">인수의 문자열 표현을 함께 연결하여 &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b997497f9c1617594d62b35a7977d7c080fb335c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; but creates the DateFormat object once during macro expansion.</source>
          <target state="translated">&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 . 유사 &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; 일단 매크로 확장시하지만 DateFormat의 객체를 생성한다.</target>
        </trans-unit>
        <trans-unit id="7953a760e50891a5121aa77eb1103656235936e1" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;&lt;/a&gt;, but the byte representation is different.</source>
          <target state="translated">메모리 매핑을 사용하여 값이 파일에 연결된 &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . &lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;mmap&lt;/code&gt; &lt;/a&gt; 과 동일한 목적을 가지고 동일한 방식으로 작동하며 동일한 인수를 갖지만 바이트 표현은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dea696a46021d9a2728a369e17215130e20d146d" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모든 값을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1d8ab7188df37f14f18fd7682b800d25bb1bf583" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">모든 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9a7ea5ce4e6122fb26aa843dbb31c11f3eca6ba2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Date&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;Date&lt;/code&gt; 를 작성하십시오 . 시작점은 제공된 &lt;code&gt;y, m, d&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 가 충족되지 않는 경우).</target>
        </trans-unit>
        <trans-unit id="f6735235a65d9c71ac1be9b11a48f9584b5d2fbf" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;DateTime&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d...&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;DateTime&lt;/code&gt; 을 작성하십시오 . 시작점은 제공된 &lt;code&gt;y, m, d...&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 이 충족되지 않는 경우 ).</target>
        </trans-unit>
        <trans-unit id="8f4f3e071879154940403d1e8565c4123c50feeb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float32&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;Float32&lt;/code&gt; 를 만듭니다 . &lt;code&gt;x&lt;/code&gt; 를 정확하게 표현할 수없는 경우 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 반올림 방법을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb6cec94ec1ca41eee89abd6d594b2b0d7efa1c2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float64&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;Float64&lt;/code&gt; 를 만듭니다 . &lt;code&gt;x&lt;/code&gt; 를 정확하게 표현할 수없는 경우 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 반올림 방법을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b2de9107e787e44816ea2763bde3a0b81e7b6a" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Future&lt;/code&gt; on process &lt;code&gt;pid&lt;/code&gt;. The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 프로세스 에서 &lt;code&gt;Future&lt;/code&gt; 를 만듭니다 . 기본 &lt;code&gt;pid&lt;/code&gt; 는 현재 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="93754c4cc4d2cf6371ad6458eaa46263dd773ceb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;MersenneTwister&lt;/code&gt; RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The &lt;code&gt;seed&lt;/code&gt; may be a non-negative integer or a vector of &lt;code&gt;UInt32&lt;/code&gt; integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the &lt;a href=&quot;#Random.seed!&quot;&gt;&lt;code&gt;seed!&lt;/code&gt;&lt;/a&gt; function for reseeding an already existing &lt;code&gt;MersenneTwister&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; RNG 객체를 만듭니다 . 다른 RNG 객체는 자체 시드를 가질 수 있으며, 이는 다른 난수 스트림을 생성하는 데 유용 할 수 있습니다. &lt;code&gt;seed&lt;/code&gt; 음수가 아닌 정수 또는 벡터 수 있습니다 &lt;code&gt;UInt32&lt;/code&gt; 정수. 시드가 제공되지 않으면 임의로 생성 된 시드가 생성됩니다 (시스템의 엔트로피 사용). 참고 항목 &lt;a href=&quot;#Random.seed!&quot;&gt; &lt;code&gt;seed!&lt;/code&gt; &lt;/a&gt;이미 존재하는 &lt;code&gt;MersenneTwister&lt;/code&gt; 객체 를 다시 시드하는 기능 .</target>
        </trans-unit>
        <trans-unit id="a3e12d3c226dfe774941f86975e7c21147d9a449" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;RandomDevice&lt;/code&gt; RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.</source>
          <target state="translated">&lt;code&gt;RandomDevice&lt;/code&gt; RNG 객체를 만듭니다 . 이러한 두 객체는 ​​항상 다른 난수 스트림을 생성합니다. 엔트로피는 운영 체제에서 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e8fd6ad24887f0f7617a75f378c73e4ba123e3c8" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TCPServer&lt;/code&gt; on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.</source>
          <target state="translated">힌트를 시작점으로 사용하여 모든 포트에서 &lt;code&gt;TCPServer&lt;/code&gt; 를 작성하십시오 . 서버가 작성된 실제 포트와 서버 자체의 튜플을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e6c48c71c33deba3dc37dfcd9d80b03a98023e0" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Task&lt;/code&gt; (i.e. coroutine) to execute the given function &lt;code&gt;func&lt;/code&gt; (which must be callable with no arguments). The task exits when this function returns.</source>
          <target state="translated">주어진 함수 &lt;code&gt;func&lt;/code&gt; (인수없이 호출 가능해야 함 )를 실행 하는 &lt;code&gt;Task&lt;/code&gt; (예 : 코 루틴)을 만듭니다 . 이 함수가 반환되면 작업이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="33aebc23f268facb98b68a3291c3e0f31f10f201" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Text&lt;/code&gt; object from a literal string.</source>
          <target state="translated">리터럴 문자열에서 &lt;code&gt;Text&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9acff786cd532c004e7fc905975913a4901883b1" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Time&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be &lt;code&gt;Millisecond(1)&lt;/code&gt; instead of &lt;code&gt;Second(1)&lt;/code&gt;.</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;Time&lt;/code&gt; 을 작성하십시오 . 시작점은 제공된 &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 이 충족되지 않는 경우 ). 기본 단계는 주어진 인수에 대해 더 높은 정밀도를 허용하도록 조정됩니다. 즉,시, 분 및 초 인수가 제공되는 경우 기본 단계는 &lt;code&gt;Millisecond(1)&lt;/code&gt; 대신 &lt;code&gt;Second(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c627f9ad41e59c07607d6bd4b21b09b55e3881e7" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;WorkerPool&lt;/code&gt; from a vector of worker ids.</source>
          <target state="translated">작업자 ID로 구성된 벡터에서 &lt;code&gt;WorkerPool&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f12caa09152736ae8bfc5bb08f6c10223240aec7" translate="yes" xml:space="preserve">
          <source>Create a async condition that calls the given &lt;code&gt;callback&lt;/code&gt; function. The &lt;code&gt;callback&lt;/code&gt; is passed one argument, the async condition object itself.</source>
          <target state="translated">주어진 &lt;code&gt;callback&lt;/code&gt; 함수 를 호출하는 비동기 조건을 만듭니다 . &lt;code&gt;callback&lt;/code&gt; 하나 개의 인수, 비동기 상태 객체 자체를 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a7b2716d759210ecda9bce2dfa1f57b9170956" translate="yes" xml:space="preserve">
          <source>Create a async condition that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the object) when notified from C by a call to &lt;code&gt;uv_async_send&lt;/code&gt;. Waiting tasks are woken with an error when the object is closed (by &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt;&lt;code&gt;isopen&lt;/code&gt;&lt;/a&gt; to check whether it is still active.</source>
          <target state="translated">C에서 &lt;code&gt;uv_async_send&lt;/code&gt; 에 대한 호출로 알림을받을 때 오브젝트에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 태스크를 깨우는 비동기 조건을 작성하십시오 . 대기중인 작업은 개체가 닫힐 때 오류와 함께 깨어납니다 ( &lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt; &lt;code&gt;isopen&lt;/code&gt; &lt;/a&gt; 을 사용 하여 여전히 활성 상태인지 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="090a3944a91674778ee0a002d6a90d0bc41ff5ca" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run it on an automatically-chosen process, returning a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result.</source>
          <target state="translated">표현식 주위에 클로저를 만들고 자동으로 선택된 프로세스에서 실행하여 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 결과 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="893f51793311a49b3b24a2293576ed62237ed0ec" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run the closure asynchronously on process &lt;code&gt;p&lt;/code&gt;. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result. Accepts two arguments, &lt;code&gt;p&lt;/code&gt; and an expression.</source>
          <target state="translated">표현식 주위에 클로저를 작성하고 프로세스 &lt;code&gt;p&lt;/code&gt; 에서 비동기 적으로 클로저를 실행하십시오 . 결과에 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 돌려 줍니다. 두 개의 인수 인 &lt;code&gt;p&lt;/code&gt; 와 표현식을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="85036d818cc4d94ce8946366f07822d8fe6c3c69" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run the closure asynchronously on process &lt;code&gt;p&lt;/code&gt;. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result. If &lt;code&gt;p&lt;/code&gt; is the quoted literal symbol &lt;code&gt;:any&lt;/code&gt;, then the system will pick a processor to use automatically.</source>
          <target state="translated">표현식 주위에 클로저를 만들고 프로세스 &lt;code&gt;p&lt;/code&gt; 에서 비동기 적으로 클로저를 실행합니다 . 결과에 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 반환합니다 . 경우 &lt;code&gt;p&lt;/code&gt; 는 인용 된 문자 상징이다 &lt;code&gt;:any&lt;/code&gt; , 시스템이 자동으로 사용하는 프로세서를 선택할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c74b846dbbbc1ae3b521fb938c06a70c93c0aa1c" translate="yes" xml:space="preserve">
          <source>Create a counting semaphore that allows at most &lt;code&gt;sem_size&lt;/code&gt; acquires to be in use at any time. Each acquire must be matched with a release.</source>
          <target state="translated">최대 &lt;code&gt;sem_size&lt;/code&gt; 획득을 언제든지 사용할 수있는 카운팅 세마포어를 만듭니다 . 각 획득은 릴리스와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c2f227958f5b5ddf7f1444e043ef8a63ac36641" translate="yes" xml:space="preserve">
          <source>Create a deep copy of &lt;code&gt;x&lt;/code&gt;: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling &lt;code&gt;deepcopy&lt;/code&gt; on an object should generally have the same effect as serializing and then deserializing it.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 깊은 사본을 만듭니다 . 모든 것이 재귀 적으로 복사되어 완전히 독립적 인 객체가됩니다. 예를 들어, 배열을 딥 카피하면 요소가 원래 요소의 딥 카피 인 새 배열이 생성됩니다. 개체에 대해 &lt;code&gt;deepcopy&lt;/code&gt; 를 호출 하면 일반적으로 개체를 serialize 한 다음 deserialize하는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="06de478930a8bc99659c25d8415dcac3d4dfaee0" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument contains &lt;code&gt;needle&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;haystack -&amp;gt; contains(haystack, needle)&lt;/code&gt;.</source>
          <target state="translated">인수에 &lt;code&gt;needle&lt;/code&gt; 이 포함되어 있는지 확인하는 함수를 만듭니다. 즉, &lt;code&gt;haystack -&amp;gt; contains(haystack, needle)&lt;/code&gt; 과 동일한 함수를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="839327adadbf1969796937dbbf4b3400e310dc29" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument ends with &lt;code&gt;suffix&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; endswith(y, suffix)&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;suffix&lt;/code&gt; 로 끝나는 지 확인하는 함수 , 즉 &lt;code&gt;y -&amp;gt; endswith(y, suffix)&lt;/code&gt; 와 동일한 함수를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="96755a5423f27566ec27c9cf388800b6e09c90bc" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument starts with &lt;code&gt;prefix&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; startswith(y, prefix)&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;prefix&lt;/code&gt; 로 시작하는지 확인하는 함수 , 즉 &lt;code&gt;y -&amp;gt; startswith(y, prefix)&lt;/code&gt; 해당하는 함수를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fa9e6555c025221820dc540d8f7a0e05f0b656fe" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:!=&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:!=&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af72c3093498da482669882ee76ee4892ac8f823" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수를 &lt;code&gt;x&lt;/code&gt; 와 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt; 해당하는 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99645591e772ccfbb35aa20a63f502286477bdca" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b397904853b03daedf092cc5a494f6b012bca332" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수를 &lt;code&gt;x&lt;/code&gt; 와 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt; 와 동등한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48667c6a66ce4f649d12d09795f7243f057de17" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc3766565df9d8df73c197f4db993c361226594" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt; 와 동일한 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="39a67963f2c04e3b7585aacebf07d65a32e22eec" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; 을&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt; 와 동일한 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="43bfb5caaef93e97947e222246c6c4ab15ae49d9" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;&amp;asymp;&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;asymp; x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;asymp;&lt;/code&gt; , 즉 &lt;code&gt;y -&amp;gt; y &amp;asymp; x&lt;/code&gt; 해당하는 함수를 사용하여 인수를 &lt;code&gt;x&lt;/code&gt; 와 비교하는 함수를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3df28caac8a888672e501e021dd972bc1bf923af" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over dimensions &lt;code&gt;dims&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt;, returning views that select all the data from the other dimensions in &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">발전기를 만드는 것이 치수로 반복 &lt;code&gt;dims&lt;/code&gt; 의 에 다른 치수의 모든 데이터 선택 복귀 뷰 &lt;code&gt;A&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bbed9d6a52b2907a10c83ce50cbadca820735e6" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over the first dimension of vector or matrix &lt;code&gt;A&lt;/code&gt;, returning the rows as &lt;code&gt;AbstractVector&lt;/code&gt; views.</source>
          <target state="translated">벡터 또는 행렬 &lt;code&gt;A&lt;/code&gt; 의 첫 번째 차원을 반복 하여 행을 &lt;code&gt;AbstractVector&lt;/code&gt; 뷰로 반환 하는 생성기를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6bf92532f071031f3b73100cad4957bc6f24a44a" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over the second dimension of matrix &lt;code&gt;A&lt;/code&gt;, returning the columns as &lt;code&gt;AbstractVector&lt;/code&gt; views.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 두 번째 차원을 반복 하여 열을 &lt;code&gt;AbstractVector&lt;/code&gt; 뷰로 반환 하는 생성기를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c4897ffc204435872d3aa27261454e300b1e8498" translate="yes" xml:space="preserve">
          <source>Create a level-triggered event source. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on an &lt;code&gt;Event&lt;/code&gt; are suspended and queued until &lt;code&gt;notify&lt;/code&gt; is called on the &lt;code&gt;Event&lt;/code&gt;. After &lt;code&gt;notify&lt;/code&gt; is called, the &lt;code&gt;Event&lt;/code&gt; remains in a signaled state and tasks will no longer block when waiting for it.</source>
          <target state="translated">레벨 트리거 이벤트 소스를 작성하십시오. 콜 것을 작업 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 온 &lt;code&gt;Event&lt;/code&gt; 중단 때까지 대기열에 &lt;code&gt;notify&lt;/code&gt; 온라고 &lt;code&gt;Event&lt;/code&gt; . &lt;code&gt;notify&lt;/code&gt; 이 호출 된 후에도 &lt;code&gt;Event&lt;/code&gt; 는 신호 상태로 유지되며 작업을 기다릴 때 더 이상 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe9984ac6bdc01807145947503bc5f82261b9154" translate="yes" xml:space="preserve">
          <source>Create a level-triggered event source. Tasks that call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on an &lt;code&gt;Event&lt;/code&gt; are suspended and queued until &lt;code&gt;notify&lt;/code&gt; is called on the &lt;code&gt;Event&lt;/code&gt;. After &lt;code&gt;notify&lt;/code&gt; is called, the &lt;code&gt;Event&lt;/code&gt; remains in a signaled state and tasks will no longer block when waiting for it.</source>
          <target state="translated">레벨 트리거 이벤트 소스를 만듭니다. 콜 것을 작업 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 온 &lt;code&gt;Event&lt;/code&gt; 중단 때까지 대기열에 &lt;code&gt;notify&lt;/code&gt; 온라고 &lt;code&gt;Event&lt;/code&gt; . &lt;code&gt;notify&lt;/code&gt; 이 호출 된 후 &lt;code&gt;Event&lt;/code&gt; 는 신호 상태로 유지되며 대기 할 때 작업이 더 이상 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b28ca2340f5d2245f4bb80af46a6a182e72737e" translate="yes" xml:space="preserve">
          <source>Create a log record with an informational &lt;code&gt;message&lt;/code&gt;. For convenience, four logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; are defined which log at the standard severity levels &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Warn&lt;/code&gt; and &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;@logmsg&lt;/code&gt; allows &lt;code&gt;level&lt;/code&gt; to be set programmatically to any &lt;code&gt;LogLevel&lt;/code&gt; or custom log level types.</source>
          <target state="translated">정보 &lt;code&gt;message&lt;/code&gt; 와 함께 로그 레코드를 작성하십시오 . 편의상 표준 심각도 수준 &lt;code&gt;Debug&lt;/code&gt; , &lt;code&gt;Info&lt;/code&gt; , &lt;code&gt;Warn&lt;/code&gt; 및 &lt;code&gt;Error&lt;/code&gt; 로 기록하는 네 개의 로깅 매크로 &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; 및 &lt;code&gt;@error&lt;/code&gt; 가 정의됩니다 . &lt;code&gt;@logmsg&lt;/code&gt; 를 사용하면 &lt;code&gt;level&lt;/code&gt; 을 프로그래밍 방식으로 모든 &lt;code&gt;LogLevel&lt;/code&gt; 또는 사용자 지정 로그 수준 유형 으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ffd2c5ff267c519e387826ecf2e1a0e8741d44" translate="yes" xml:space="preserve">
          <source>Create a multidimensional index &lt;code&gt;I&lt;/code&gt;, which can be used for indexing a multidimensional array &lt;code&gt;A&lt;/code&gt;. In particular, &lt;code&gt;A[I]&lt;/code&gt; is equivalent to &lt;code&gt;A[i,j,k...]&lt;/code&gt;. One can freely mix integer and &lt;code&gt;CartesianIndex&lt;/code&gt; indices; for example, &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; (where &lt;code&gt;Ipre&lt;/code&gt; and &lt;code&gt;Ipost&lt;/code&gt; are &lt;code&gt;CartesianIndex&lt;/code&gt; indices and &lt;code&gt;i&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.</source>
          <target state="translated">다차원 배열 &lt;code&gt;A&lt;/code&gt; 를 인덱싱하는 데 사용할 수 있는 다차원 인덱스 &lt;code&gt;I&lt;/code&gt; 을 만듭니다 . 특히, &lt;code&gt;A[I]&lt;/code&gt; 는 &lt;code&gt;A[i,j,k...]&lt;/code&gt; . 정수와 &lt;code&gt;CartesianIndex&lt;/code&gt; 인덱스를 자유롭게 혼합 할 수 있습니다 . 예를 들어, &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; (단 &lt;code&gt;Ipre&lt;/code&gt; 및 &lt;code&gt;Ipost&lt;/code&gt; 가 있다 &lt;code&gt;CartesianIndex&lt;/code&gt; 의 인덱스와 &lt;code&gt;i&lt;/code&gt; 인 &lt;code&gt;Int&lt;/code&gt; 알고리즘을 작성할 때) 유용한 발현 될 수있는 임의의 차원의 어레이의 하나의 차원에 따른 일 것이다.</target>
        </trans-unit>
        <trans-unit id="ae96087e76a9ce107c6e36702cbdc6f8e4f2b8bf" translate="yes" xml:space="preserve">
          <source>Create a new branch in the repository &lt;code&gt;repo&lt;/code&gt; with name &lt;code&gt;bname&lt;/code&gt;, which points to commit &lt;code&gt;commit_obj&lt;/code&gt; (which has to be part of &lt;code&gt;repo&lt;/code&gt;). If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, overwrite an existing branch named &lt;code&gt;bname&lt;/code&gt; if it exists. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and a branch already exists named &lt;code&gt;bname&lt;/code&gt;, this function will throw an error.</source>
          <target state="translated">저장소에 새로운 지점을 만들기 &lt;code&gt;repo&lt;/code&gt; 이름으로 &lt;code&gt;bname&lt;/code&gt; 커밋 점, &lt;code&gt;commit_obj&lt;/code&gt; (의 일부가되고있다 &lt;code&gt;repo&lt;/code&gt; ). &lt;code&gt;force&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;bname&lt;/code&gt; 이라는 기존 분기 가 있으면 덮어 씁니다 . 경우 &lt;code&gt;force&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; 과 지점이 이미 이름이 존재 &lt;code&gt;bname&lt;/code&gt; ,이 기능은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e28bd414b679935ce0ac5b71eed117e81cfc03a3" translate="yes" xml:space="preserve">
          <source>Create a new entry in the &lt;code&gt;ImmutableDict&lt;/code&gt; for a &lt;code&gt;key =&amp;gt; value&lt;/code&gt; pair</source>
          <target state="translated">&lt;code&gt;key =&amp;gt; value&lt;/code&gt; 쌍 에 대해 &lt;code&gt;ImmutableDict&lt;/code&gt; 에 새 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="542fd8a0f22e252853b2fa3a6c97502feebfa45d" translate="yes" xml:space="preserve">
          <source>Create a new entry in the Immutable Dictionary for the key =&amp;gt; value pair</source>
          <target state="translated">키 =&amp;gt; 값 쌍의 불변 사전에 새 항목을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="018e91396b89ddf1c7a72876b6df9778e135f2b3" translate="yes" xml:space="preserve">
          <source>Create a new git tag &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;) in the repository &lt;code&gt;repo&lt;/code&gt;, at the commit &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">새로운 자식 태그 만들기 &lt;code&gt;tag&lt;/code&gt; (예 : &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; 저장소에) &lt;code&gt;repo&lt;/code&gt; 커밋에서 &lt;code&gt;commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4ff3854097fc8c2ce65e16277d31c3dea329e8" translate="yes" xml:space="preserve">
          <source>Create a new task from &lt;code&gt;func&lt;/code&gt;, bind it to a new channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;size&lt;/code&gt;, and schedule the task, all in a single call.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 에서 새 작업을 만들고 &lt;code&gt;T&lt;/code&gt; 유형 및 size &lt;code&gt;size&lt;/code&gt; 의 새 채널에 바인딩 하고 작업을 예약하는 모든 작업을 한 번의 호출로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5a3af261697fbecd6e1e61df8aa7ec1dc50fe659" translate="yes" xml:space="preserve">
          <source>Create a non-reentrant lock. Recursive use will result in a deadlock. Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">재진입 할 ​​수없는 잠금을 만듭니다. 재귀를 사용하면 교착 상태가 발생합니다. 각 &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0f71c0a6b91caaf69c1ff056efc8f9f76af7879" translate="yes" xml:space="preserve">
          <source>Create a non-reentrant, test-and-test-and-set spin lock. Recursive use will result in a deadlock. This kind of lock should only be used around code that takes little time to execute and does not block (e.g. perform I/O). In general, &lt;a href=&quot;../parallel/index#Base.ReentrantLock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">재진입이 아닌 테스트 및 테스트 및 설정 스핀 잠금을 만듭니다. 재귀를 사용하면 교착 상태가 발생합니다. 이러한 종류의 잠금은 실행하는 데 시간이 거의 걸리지 않고 차단하지 않는 (예 : I / O 수행) 코드에서만 사용해야합니다. 일반적으로 &lt;a href=&quot;../parallel/index#Base.ReentrantLock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7e10405fa9ae28a15fde6de2cc04f54c5e19a78" translate="yes" xml:space="preserve">
          <source>Create a pipe to which all C and Julia level &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output will be redirected. Returns a tuple &lt;code&gt;(rd, wr)&lt;/code&gt; representing the pipe ends. Data written to &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; may now be read from the &lt;code&gt;rd&lt;/code&gt; end of the pipe. The &lt;code&gt;wr&lt;/code&gt; end is given for convenience in case the old &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; object was cached by the user and needs to be replaced elsewhere.</source>
          <target state="translated">모든 C 및 Julia 레벨 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 출력이 경로 재 지정 될 파이프를 작성하십시오 . 파이프 끝을 나타내는 튜플 &lt;code&gt;(rd, wr)&lt;/code&gt; 반환합니다 . &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 에&lt;/a&gt; 기록 된 데이터 는 이제 파이프 의 &lt;code&gt;rd&lt;/code&gt; end 에서 읽을 수 있습니다 . &lt;code&gt;wr&lt;/code&gt; 끝은 오래된 경우에는 편의를 위해 제공되는 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 객체는 사용자가 캐시 된 다른 곳에서 교체해야했다.</target>
        </trans-unit>
        <trans-unit id="d5609ae0d62a4b854bf2c4375ca4d215cbf7c0df" translate="yes" xml:space="preserve">
          <source>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other &lt;code&gt;pipeline&lt;/code&gt; calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; is equivalent to &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt;. This provides a more concise way to specify multi-stage pipelines.</source>
          <target state="translated">데이터 소스에서 대상으로 파이프 라인을 작성하십시오. 소스 및 대상은 명령, I / O 스트림, 문자열 또는 다른 &lt;code&gt;pipeline&lt;/code&gt; 호출의 결과 일 수 있습니다 . 적어도 하나의 인수는 명령이어야합니다. 문자열은 파일 이름을 나타냅니다. 두 개 이상의 인수로 호출하면 왼쪽에서 오른쪽으로 연결됩니다. 예를 들어 &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; 는 &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt; . 이를 통해 다단계 파이프 라인을보다 간결하게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab961019ed0d9e981963c118aa8d4bde8ecc5ebd" translate="yes" xml:space="preserve">
          <source>Create a random length &lt;code&gt;m&lt;/code&gt; sparse vector or &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; sparse matrix, in which the probability of any element being nonzero is independently given by &lt;code&gt;p&lt;/code&gt; (and hence the mean density of nonzeros is also exactly &lt;code&gt;p&lt;/code&gt;). Nonzero values are sampled from the distribution specified by &lt;code&gt;rfn&lt;/code&gt; and have the type &lt;code&gt;type&lt;/code&gt;. The uniform distribution is used in case &lt;code&gt;rfn&lt;/code&gt; is not specified. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">임의 길이의 &lt;code&gt;m&lt;/code&gt; 희소 벡터 또는 &lt;code&gt;m&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 희소 행렬을 생성합니다. 여기서 임의의 요소가 0이 아닐 확률은 독립적으로 &lt;code&gt;p&lt;/code&gt; 로 주어집니다 (따라서 0이 아닌 평균 밀도도 정확히 &lt;code&gt;p&lt;/code&gt; 입니다 ). 0이 아닌 값은 &lt;code&gt;rfn&lt;/code&gt; 으로 지정된 분포에서 샘플링되며 유형은 &lt;code&gt;type&lt;/code&gt; 입니다. &lt;code&gt;rfn&lt;/code&gt; 이 지정되지 않은 경우 균등 분포가 사용 됩니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24adb62e84b71340c3f621decef5a321f7e84b6a" translate="yes" xml:space="preserve">
          <source>Create a random length &lt;code&gt;m&lt;/code&gt; sparse vector or &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; sparse matrix, in which the probability of any element being nonzero is independently given by &lt;code&gt;p&lt;/code&gt; (and hence the mean density of nonzeros is also exactly &lt;code&gt;p&lt;/code&gt;). Nonzero values are sampled from the distribution specified by &lt;code&gt;rfn&lt;/code&gt; and have the type &lt;code&gt;type&lt;/code&gt;. The uniform distribution is used in case &lt;code&gt;rfn&lt;/code&gt; is not specified. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">임의의 길이 &lt;code&gt;m&lt;/code&gt; 스파 스 벡터 또는 &lt;code&gt;m&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 스파 스 행렬을 생성합니다. 여기서 0이 아닌 요소의 확률은 &lt;code&gt;p&lt;/code&gt; 에 의해 독립적으로 주어집니다 (따라서 0이 아닌 평균 밀도도 정확히 &lt;code&gt;p&lt;/code&gt; 입니다 ). &lt;code&gt;rfn&lt;/code&gt; 에 의해 지정된 분포에서 0이 아닌 값이 샘플링되며 type &lt;code&gt;type&lt;/code&gt; 있습니다. &lt;code&gt;rfn&lt;/code&gt; 이 지정되지 않은 경우 균일 분포가 사용 됩니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3770a87ac752a36ec36d9d03972bd765749af3ed" translate="yes" xml:space="preserve">
          <source>Create a random sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; with the specified (independent) probability &lt;code&gt;p&lt;/code&gt; of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">길이의 랜덤 스파 스 벡터 생성 &lt;code&gt;m&lt;/code&gt; 또는 크기의 희소 행렬 &lt;code&gt;m&lt;/code&gt; 을 하여 &lt;code&gt;n&lt;/code&gt; 특정 (독립) 확률과 &lt;code&gt;p&lt;/code&gt; 제로 값들이 정규 분포로부터 샘플링 된 모든 항목 인 제로의. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61e09af9437fe2c45b77d2e9ddd5c2a0aea13bdf" translate="yes" xml:space="preserve">
          <source>Create a random sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; with the specified (independent) probability &lt;code&gt;p&lt;/code&gt; of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">길이의 랜덤 스파 스 벡터 생성 &lt;code&gt;m&lt;/code&gt; 또는 크기의 희소 행렬 &lt;code&gt;m&lt;/code&gt; 을 하여 &lt;code&gt;n&lt;/code&gt; 특정 (독립) 확률과 &lt;code&gt;p&lt;/code&gt; 제로 값들이 정규 분포로부터 샘플링 된 모든 항목 인 제로의. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f80f6c84937a0616b960c68c36a1821e1d127b5a" translate="yes" xml:space="preserve">
          <source>Create a random string of length &lt;code&gt;len&lt;/code&gt;, consisting of characters from &lt;code&gt;chars&lt;/code&gt;, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 의 문자로 구성된 &lt;code&gt;len&lt;/code&gt; 길이의 임의의 문자열을 만듭니다. 기본값은 대문자 및 소문자와 숫자 0-9로 설정됩니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a73a876cebbc3a0c143465473af20e5a925c98" translate="yes" xml:space="preserve">
          <source>Create a random string of length &lt;code&gt;len&lt;/code&gt;, consisting of characters from &lt;code&gt;chars&lt;/code&gt;, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 의 문자로 구성된 길이가 &lt;code&gt;len&lt;/code&gt; 인 임의의 문자열을 만듭니다. 기본값은 대문자 및 소문자 및 숫자 0-9입니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee28ecbd285880a7cd740fd7798c9c1727d428f" translate="yes" xml:space="preserve">
          <source>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</source>
          <target state="translated">보간 및 이스케이프 처리없이 원시 문자열을 작성하십시오. 단, 인용 부호는 여전히 이스케이프되어야합니다. 백 슬래시는 따옴표와 다른 백 슬래시를 모두 이스케이프하지만 일련의 백 슬래시가 따옴표 문자 앞에 오는 경우에만 이스케이프합니다. 따라서 2n 백 슬래시 다음에 따옴표는 n 백 슬래시와 리터럴의 끝을 인코딩하고 2n + 1 백 슬래시 뒤에 따옴표는 n 백 슬래시 다음에 따옴표 문자를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8da7a06794cadd72caef89925cfd7c17951f6bfa" translate="yes" xml:space="preserve">
          <source>Create a read-only &lt;code&gt;IOBuffer&lt;/code&gt; on the data underlying the given string.</source>
          <target state="translated">주어진 문자열의 기초가되는 데이터에 대해 읽기 전용 &lt;code&gt;IOBuffer&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="19bb0229940b270a1479eaf9165f097e216ed768" translate="yes" xml:space="preserve">
          <source>Create a sampler that just wraps the given value &lt;code&gt;x&lt;/code&gt;. This is the default fall-back for values. The &lt;code&gt;eltype&lt;/code&gt; of this sampler is equal to &lt;code&gt;eltype(x)&lt;/code&gt;.</source>
          <target state="translated">주어진 값 &lt;code&gt;x&lt;/code&gt; 를 감싸는 샘플러를 만듭니다 . 이것은 값에 대한 기본 폴백입니다. 이 샘플러 의 &lt;code&gt;eltype&lt;/code&gt; 은 &lt;code&gt;eltype(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9f224e016b84200f01ecc706676d9881b66d41f" translate="yes" xml:space="preserve">
          <source>Create a sampler that wraps the given value &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt;. The &lt;code&gt;eltype&lt;/code&gt; of this sampler is equal to &lt;code&gt;eltype(x)&lt;/code&gt;.</source>
          <target state="translated">주어진 값 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 를 래핑하는 샘플러를 만듭니다 . 이 샘플러 의 &lt;code&gt;eltype&lt;/code&gt; 은 &lt;code&gt;eltype(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f83dbfbf518114552573b6e6abae3e4139b31cb9" translate="yes" xml:space="preserve">
          <source>Create a shallow copy of &lt;code&gt;x&lt;/code&gt;: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 얕은 사본을 만듭니다 . 외부 구조는 복사되지만 모든 내부 값은 아닙니다. 예를 들어 배열을 복사하면 원본과 동일한 요소를 가진 새 배열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb3be6cb095ffdb386198e5a53c66758791ab37" translate="yes" xml:space="preserve">
          <source>Create a sparse matrix &lt;code&gt;S&lt;/code&gt; of dimensions &lt;code&gt;m x n&lt;/code&gt; such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The &lt;code&gt;combine&lt;/code&gt; function is used to combine duplicates. If &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are not specified, they are set to &lt;code&gt;maximum(I)&lt;/code&gt; and &lt;code&gt;maximum(J)&lt;/code&gt; respectively. If the &lt;code&gt;combine&lt;/code&gt; function is not supplied, &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;+&lt;/code&gt; unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;. All elements of &lt;code&gt;I&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt;, and all elements of &lt;code&gt;J&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt;. Numerical zeros in (&lt;code&gt;I&lt;/code&gt;, &lt;code&gt;J&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;) are retained as structural nonzeros; to drop numerical zeros, use &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; 되도록 &lt;code&gt;m x n&lt;/code&gt; 크기 의 희소 행렬 &lt;code&gt;S&lt;/code&gt; 를 만듭니다 . &lt;code&gt;combine&lt;/code&gt; 기능은 중복을 결합하는 데 사용됩니다. 경우에 &lt;code&gt;m&lt;/code&gt; 과 &lt;code&gt;n&lt;/code&gt; 을 지정하지 이들은에 설정된 &lt;code&gt;maximum(I)&lt;/code&gt; 및 &lt;code&gt;maximum(J)&lt;/code&gt; 각각. (가) 경우 &lt;code&gt;combine&lt;/code&gt; 기능이 제공되지 않습니다, &lt;code&gt;combine&lt;/code&gt; 에 기본값 &lt;code&gt;+&lt;/code&gt; 의 요소를 제외 &lt;code&gt;V&lt;/code&gt; 는 부울이 경우에 &lt;code&gt;combine&lt;/code&gt; 에 기본값을 &lt;code&gt;|&lt;/code&gt; . 모든 요소 &lt;code&gt;I&lt;/code&gt; 는 만족해야 &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt; , 그리고 모든 요소 &lt;code&gt;J&lt;/code&gt; 는 &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt; 충족해야합니다 . ( &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;J&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; )의 숫자 0은 구조적 0이 아닌 값으로 유지됩니다. 숫자 0을 삭제하려면 &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; 사용 하십시오! .</target>
        </trans-unit>
        <trans-unit id="c5011b871e48d58f4cd3d39dc5cf861693b7b3f0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector &lt;code&gt;S&lt;/code&gt; of length &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;S[I[k]] = V[k]&lt;/code&gt;. Duplicates are combined using the &lt;code&gt;combine&lt;/code&gt; function, which defaults to &lt;code&gt;+&lt;/code&gt; if no &lt;code&gt;combine&lt;/code&gt; argument is provided, unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S[I[k]] = V[k]&lt;/code&gt; 되도록 길이 &lt;code&gt;m&lt;/code&gt; 의 희소 벡터 &lt;code&gt;S&lt;/code&gt; 를 만듭니다 . 중복이 (가) 사용하여 결합하는 &lt;code&gt;combine&lt;/code&gt; 디폴트 기능, &lt;code&gt;+&lt;/code&gt; 어떤이 경우 &lt;code&gt;combine&lt;/code&gt; 의 요소하지 않는 한, 제공되는 인수를 &lt;code&gt;V&lt;/code&gt; 는 부울이 경우에 &lt;code&gt;combine&lt;/code&gt; 에 기본값을 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af6da27ae9944a05eb6bb91e99e94212274e3cb" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m x n&lt;/code&gt;. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; if not specified.</source>
          <target state="translated">길이가 &lt;code&gt;m&lt;/code&gt; 인 희소 벡터 또는 &lt;code&gt;m x n&lt;/code&gt; 크기의 희소 행렬을 만듭니다 . 이 희소 배열에는 0이 아닌 값이 포함되지 않습니다. 구성하는 동안 0이 아닌 값에 스토리지가 할당되지 않습니다. 지정되지 않은 경우 유형은 기본적으로 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58a5aeb67ce63929f99f3293ccf57387db820ad0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</source>
          <target state="translated">0이 아닌 인덱스가 사전의 키이고 0이 아닌 값이 사전의 값인 길이 &lt;code&gt;m&lt;/code&gt; 의 희소 벡터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8f503d60ac5dd0352ae777a0e19093ba170f05ca" translate="yes" xml:space="preserve">
          <source>Create a string based upon the URL components provided. When the &lt;code&gt;scheme&lt;/code&gt; keyword is not provided the URL produced will use the alternative &lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;scp-like syntax&lt;/a&gt;.</source>
          <target state="translated">제공된 URL 구성 요소를 기반으로 문자열을 작성하십시오. 때 &lt;code&gt;scheme&lt;/code&gt; 대체 사용 생성되는 URL이 제공되지 않는 키워드 &lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;SCP-같은 구문을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa7fda98b7d8855e2b4e7e053b01d032e7a1841" translate="yes" xml:space="preserve">
          <source>Create a string from any value using the &lt;code&gt;show&lt;/code&gt; function. You should not add methods to &lt;code&gt;repr&lt;/code&gt;; define a &lt;code&gt;show&lt;/code&gt; method instead.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 함수를 사용하여 모든 값에서 문자열을 만듭니다 . &lt;code&gt;repr&lt;/code&gt; 에 메소드를 추가해서는 안됩니다 . 대신 &lt;code&gt;show&lt;/code&gt; 메소드를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="e66181553ea669848b336edb8190dd3795b76e53" translate="yes" xml:space="preserve">
          <source>Create a string from any values, except &lt;code&gt;nothing&lt;/code&gt;, using the &lt;a href=&quot;../io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">를 제외하고, 모든 값에서 문자열을 만들기 &lt;code&gt;nothing&lt;/code&gt; 사용하여 &lt;a href=&quot;../io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="e032c39f889cf31d16beb9d571f3e05c8c5832b5" translate="yes" xml:space="preserve">
          <source>Create a symlink from &lt;code&gt;~/.julia/compiled&lt;/code&gt; to a directory in a scratch space.</source>
          <target state="translated">&lt;code&gt;~/.julia/compiled&lt;/code&gt; 에서 스크래치 공간의 디렉토리로 심볼릭 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6b407e62c50b7579a1b48390737d3d9d521a089c" translate="yes" xml:space="preserve">
          <source>Create a temporary directory in the &lt;code&gt;parent&lt;/code&gt; directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing &lt;code&gt;X&lt;/code&gt; characters may be replaced with random characters. If &lt;code&gt;parent&lt;/code&gt; does not exist, throw an error.</source>
          <target state="translated">주어진 접두사와 임의 접미사로 구성된 이름으로 &lt;code&gt;parent&lt;/code&gt; 디렉토리에 임시 디렉토리를 작성하고 해당 경로를 리턴하십시오. 또한 후행 &lt;code&gt;X&lt;/code&gt; 문자는 임의의 문자로 대체 될 수 있습니다. 경우 &lt;code&gt;parent&lt;/code&gt; 존재하지 않는 오류가 발생.</target>
        </trans-unit>
        <trans-unit id="1160dbc1e96a164b7ce4fa9acf2aa50398bea6c6" translate="yes" xml:space="preserve">
          <source>Create a temporary directory in the &lt;code&gt;parent&lt;/code&gt; directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing &lt;code&gt;X&lt;/code&gt; characters may be replaced with random characters. If &lt;code&gt;parent&lt;/code&gt; does not exist, throw an error. The &lt;code&gt;cleanup&lt;/code&gt; option controls whether the temporary directory is automatically deleted when the process exits.</source>
          <target state="translated">주어진 접두사와 임의의 접미사로 구성된 이름으로 &lt;code&gt;parent&lt;/code&gt; 디렉터리에 임시 디렉터리를 만들고 해당 경로를 반환합니다. 또한 후행 &lt;code&gt;X&lt;/code&gt; 문자는 임의의 문자로 대체 될 수 있습니다. 경우 &lt;code&gt;parent&lt;/code&gt; 존재하지 않는 오류가 발생. &lt;code&gt;cleanup&lt;/code&gt; 옵션 컨트롤은 임시 디렉토리는 자동으로 할 때 프로세스가 종료 삭제되어 있는지 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="74d681100427f7076ed67273bc216adc2864cfb4" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object) and calls the function &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">타이머 객체에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 작업을 깨우고 &lt;code&gt;callback&lt;/code&gt; 함수를 호출하는 타이머를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9b6c236b317e2feae409a047b5bb9690d7eaa0be" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object).</source>
          <target state="translated">타이머 객체에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 작업을 깨우는 타이머를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fe6838aa6e3e621f355c9b1295ab3768c3010eb0" translate="yes" xml:space="preserve">
          <source>Create a tuple of length &lt;code&gt;n&lt;/code&gt;, computing each element as &lt;code&gt;f(i)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index of the element.</source>
          <target state="translated">각 요소를 &lt;code&gt;f(i)&lt;/code&gt; 로 계산 하는 길이 &lt;code&gt;n&lt;/code&gt; 의 튜플을 작성합니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="6c21b2eac39c09ea54cf9d183a22560ba8078519" translate="yes" xml:space="preserve">
          <source>Create all directories in the given &lt;code&gt;path&lt;/code&gt;, with permissions &lt;code&gt;mode&lt;/code&gt;. &lt;code&gt;mode&lt;/code&gt; defaults to &lt;code&gt;0o777&lt;/code&gt;, modified by the current file creation mask. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">권한 &lt;code&gt;mode&lt;/code&gt; 를 사용 하여 지정된 &lt;code&gt;path&lt;/code&gt; 에 모든 디렉토리를 작성하십시오 . &lt;code&gt;mode&lt;/code&gt; 기본값 &lt;code&gt;0o777&lt;/code&gt; 현재 파일 생성 마스크에 의해 수정. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf162de3c9c9ee881cac0dcb3cd170c29ebef959" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object from an integer file descriptor. If &lt;code&gt;own&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, closing this object will close the underlying descriptor. By default, an &lt;code&gt;IOStream&lt;/code&gt; is closed when it is garbage collected. &lt;code&gt;name&lt;/code&gt; allows you to associate the descriptor with a named file.</source>
          <target state="translated">정수 파일 설명자에서 &lt;a href=&quot;#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 . 경우 &lt;code&gt;own&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; ,이 객체를 폐쇄하는 것은 기본 설명을 닫습니다. 기본적으로 &lt;code&gt;IOStream&lt;/code&gt; 은 가비지 수집시 닫힙니다. &lt;code&gt;name&lt;/code&gt; 을 사용하면 설명자를 명명 된 파일과 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d27efa244291014a3b2adaa305d7bd4d5b64350" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt; whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.</source>
          <target state="translated">메모리 매핑을 사용하여 값이 파일에 연결된 &lt;code&gt;Array&lt;/code&gt; 를 만듭니다 . 이렇게하면 컴퓨터 메모리에 맞지 않는 너무 큰 데이터로 작업하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8bb86166b97c93700925b2b59c6f26d354e7671" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all ones with size specified by &lt;code&gt;dims&lt;/code&gt;. See also: &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 유형이 &lt;code&gt;T&lt;/code&gt; 이고, 크기가 &lt;code&gt;dims&lt;/code&gt; 인 모든 &lt;code&gt;Array&lt;/code&gt; 만듭니다 . &lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c843cf6b2431abf5229a8828a3d5be9c5597803a" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all zeros with size specified by &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.ones&quot;&gt;&lt;code&gt;ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 유형이 &lt;code&gt;T&lt;/code&gt; 이고, 크기가 &lt;code&gt;dims&lt;/code&gt; 로 지정된 모든 0 의 &lt;code&gt;Array&lt;/code&gt; 작성하십시오 . 참조 &lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.ones&quot;&gt; &lt;code&gt;ones&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e18437c6870b3441a198a29488dbaad1e36b6c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Enum{BaseType}&lt;/code&gt; subtype with name &lt;code&gt;EnumName&lt;/code&gt; and enum member values of &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; with optional assigned values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. &lt;code&gt;EnumName&lt;/code&gt; can be used just like other types and enum member values as regular values, such as</source>
          <target state="translated">이름이 &lt;code&gt;EnumName&lt;/code&gt; 이고 열거 형 멤버 값이 &lt;code&gt;value1&lt;/code&gt; 과 &lt;code&gt;value2&lt;/code&gt; 인 &lt;code&gt;Enum{BaseType}&lt;/code&gt; 하위 유형을 각각 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 선택적 할당 값으로 작성하십시오 . &lt;code&gt;EnumName&lt;/code&gt; 은 다른 유형과 마찬가지로 열거 형 멤버 값과 같은 일반 값으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1988e010ef2dfb8cfcde7da8bec73bf1cf0c049c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;HTML&lt;/code&gt; object from a literal string.</source>
          <target state="translated">리터럴 문자열에서 &lt;code&gt;HTML&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b7f0dc80f42f1aad71a14562fb4f32c0b79e2ba4" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IO&lt;/code&gt;-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;Mmap.mmap&lt;/code&gt;&lt;/a&gt;. Used by &lt;code&gt;SharedArray&lt;/code&gt; for creating shared memory arrays.</source>
          <target state="translated">&lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;Mmap.mmap&lt;/code&gt; &lt;/a&gt; 에서 사용하기 위해 파일에 묶이지 않은 0으로 채워진 mmapped 메모리를 작성하기위한 &lt;code&gt;IO&lt;/code&gt; 유사 오브젝트를 작성 하십시오 . &lt;code&gt;SharedArray&lt;/code&gt; 에서 공유 메모리 어레이를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4050068afe0146f56219f374e0ff6e6eb7e3429" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps a given stream, adding the specified &lt;code&gt;key=&amp;gt;value&lt;/code&gt; pairs to the properties of that stream (note that &lt;code&gt;io&lt;/code&gt; can itself be an &lt;code&gt;IOContext&lt;/code&gt;).</source>
          <target state="translated">지정된 &lt;code&gt;key=&amp;gt;value&lt;/code&gt; 쌍을 해당 스트림의 속성에 추가하여 지정된 스트림을 래핑 하는 &lt;code&gt;IOContext&lt;/code&gt; 를 만듭니다 ( &lt;code&gt;io&lt;/code&gt; 자체는 &lt;code&gt;IOContext&lt;/code&gt; 일 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c37df1886c75da4684010c132d283b587ed7e2fa" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps an alternate &lt;code&gt;IO&lt;/code&gt; but inherits the properties of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">대체 &lt;code&gt;IO&lt;/code&gt; 를 래핑 하지만 &lt;code&gt;context&lt;/code&gt; 속성을 상속 하는 &lt;code&gt;IOContext&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="895f46bbf3cda62374e24ffe50376b92dadf2c8f" translate="yes" xml:space="preserve">
          <source>Create an anonymous function and pass it as the first argument to a function call. For example:</source>
          <target state="translated">익명 함수를 작성하여 함수 호출의 첫 번째 인수로 전달하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182df2225052f7994222327e4b5a296aa23d4ff3" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision floating point number from &lt;code&gt;x&lt;/code&gt;, with precision &lt;code&gt;precision&lt;/code&gt;. The &lt;code&gt;rounding&lt;/code&gt; argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.</source>
          <target state="translated">정밀도 &lt;code&gt;precision&lt;/code&gt; 하여 &lt;code&gt;x&lt;/code&gt; 에서 임의의 정밀도 부동 소수점 숫자를 만듭니다 . &lt;code&gt;rounding&lt;/code&gt; 인수는 변환이 정확히 수행 할 수없는 경우 결과가 반올림해야하는 방향을 지정합니다. 제공되지 않은 경우 현재 전역 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="171f32afa59f09b1061417cecc3c2a183be4d108" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision integer. &lt;code&gt;x&lt;/code&gt; may be an &lt;code&gt;Int&lt;/code&gt; (or anything that can be converted to an &lt;code&gt;Int&lt;/code&gt;). The usual mathematical operators are defined for this type, and results are promoted to a &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임의의 정밀도 정수를 만듭니다. &lt;code&gt;x&lt;/code&gt; 수있다 &lt;code&gt;Int&lt;/code&gt; (AN으로 변환 될 수 있거나 아무것도 &lt;code&gt;Int&lt;/code&gt; ). 이 유형에 대해 일반적인 수학 연산자가 정의되고 결과가 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 로 승격됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfce70679587984abb0464685e1cceade3a5bbd1" translate="yes" xml:space="preserve">
          <source>Create an array filled with the value &lt;code&gt;x&lt;/code&gt;. For example, &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; returns a 5&amp;times;5 array of floats, with each element initialized to &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값으로 채워진 배열을 만듭니다 . 예를 들어 &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; 는 각 요소가 &lt;code&gt;1.0&lt;/code&gt; 으로 초기화 된 5x5 부동 소수점 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="efff1664d300afbe16f9f536bbbebcb903f65216" translate="yes" xml:space="preserve">
          <source>Create an edge-triggered event source that tasks can wait for. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Condition&lt;/code&gt; are suspended and queued. Tasks are woken up when &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is later called on the &lt;code&gt;Condition&lt;/code&gt;. Edge triggering means that only tasks waiting at the time &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.Event&quot;&gt;&lt;code&gt;Threads.Event&lt;/code&gt;&lt;/a&gt; types do this, and can be used for level-triggered events.</source>
          <target state="translated">작업이 기다릴 수있는 에지 트리거 이벤트 소스를 작성하십시오. 콜 것을 작업 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; A의 &lt;code&gt;Condition&lt;/code&gt; 일시 중단하고 대기합니다. 나중에 &lt;code&gt;Condition&lt;/code&gt; 에서 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 이 호출 되면 작업이 시작됩니다 . Edge 트리거링은 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 할 때 대기중인 작업 만 깨울 수 있음을 의미합니다. 레벨 트리거 알림의 경우 알림 발생 여부를 추적하기 위해 추가 상태를 유지해야합니다. &lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.Event&quot;&gt; &lt;code&gt;Threads.Event&lt;/code&gt; &lt;/a&gt; 유형이 작업을 수행, 레벨 트리거 이벤트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73332ad1149d51e06da63f19c60ae5d380d61978" translate="yes" xml:space="preserve">
          <source>Create an edge-triggered event source that tasks can wait for. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Condition&lt;/code&gt; are suspended and queued. Tasks are woken up when &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is later called on the &lt;code&gt;Condition&lt;/code&gt;. Edge triggering means that only tasks waiting at the time &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../multi-threading/index#Base.Event&quot;&gt;&lt;code&gt;Threads.Event&lt;/code&gt;&lt;/a&gt; types do this, and can be used for level-triggered events.</source>
          <target state="translated">작업이 기다릴 수있는 에지 트리거 이벤트 소스를 만듭니다. 콜 것을 작업 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; A의 &lt;code&gt;Condition&lt;/code&gt; 일시 중단하고 대기합니다. &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 이 나중에 &lt;code&gt;Condition&lt;/code&gt; 에서 호출 되면 작업이 깨어납니다 . 에지 트리거링은 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 대기중인 작업 만 깨울 수 있음을 의미합니다. 레벨 트리거 알림의 경우 알림 발생 여부를 추적하기 위해 추가 상태를 유지해야합니다. &lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../multi-threading/index#Base.Event&quot;&gt; &lt;code&gt;Threads.Event&lt;/code&gt; &lt;/a&gt; 유형이 작업을 수행, 레벨 트리거 이벤트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520078b92dd7a16aee09f78e8b0db867f75cb94e" translate="yes" xml:space="preserve">
          <source>Create an immutable byte (&lt;code&gt;UInt8&lt;/code&gt;) vector using string syntax.</source>
          <target state="translated">문자열 구문을 사용하여 불변 바이트 ( &lt;code&gt;UInt8&lt;/code&gt; ) 벡터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="da84c283b9346ebc02fd11c8e5c614ee585502d6" translate="yes" xml:space="preserve">
          <source>Create an in-memory I/O stream, which may optionally operate on a pre-existing array.</source>
          <target state="translated">선택적으로 기존 어레이에서 작동 할 수있는 메모리 내 I / O 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cb24bf3cac592f5cbadebc13dc99bd00232cae06" translate="yes" xml:space="preserve">
          <source>Create an initialized &lt;code&gt;MersenneTwister&lt;/code&gt; object, whose state is moved forward (without generating numbers) from &lt;code&gt;r&lt;/code&gt; by &lt;code&gt;steps&lt;/code&gt; steps. One such step corresponds to the generation of two &lt;code&gt;Float64&lt;/code&gt; numbers. For each different value of &lt;code&gt;steps&lt;/code&gt;, a large polynomial has to be generated internally. One is already pre-computed for &lt;code&gt;steps=big(10)^20&lt;/code&gt;.</source>
          <target state="translated">초기화 된 생성 &lt;code&gt;MersenneTwister&lt;/code&gt; 가진 상태에서 (발생 수)없이 전진 물체 &lt;code&gt;r&lt;/code&gt; 에 의해 &lt;code&gt;steps&lt;/code&gt; 단계. 이러한 단계 중 하나는 두 개의 &lt;code&gt;Float64&lt;/code&gt; 번호 생성에 해당 합니다. &lt;code&gt;steps&lt;/code&gt; 각기 다른 값에 대해 내부적으로 큰 다항식을 생성해야합니다. 하나는 이미 &lt;code&gt;steps=big(10)^20&lt;/code&gt; 대해 미리 계산되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea93e0af90bf05567f22a1eb39a67d625d70a2a" translate="yes" xml:space="preserve">
          <source>Create an iterable &lt;code&gt;EachLine&lt;/code&gt; object that will yield each line from an I/O stream or a file. Iteration calls &lt;a href=&quot;#Base.readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; on the stream argument repeatedly with &lt;code&gt;keep&lt;/code&gt; passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the &lt;code&gt;EachLine&lt;/code&gt; object is garbage collected.</source>
          <target state="translated">반복 가능한 &lt;code&gt;EachLine&lt;/code&gt; 오브젝트를 작성하여 I / O 스트림 또는 파일에서 각 행을 생성하십시오. 반복 은 스트림 통과 에 대해 &lt;a href=&quot;#Base.readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; -line을 반복적으로 &lt;code&gt;keep&lt;/code&gt; 하면서 후행 줄 끝 문자를 유지할지 여부를 판별합니다. 파일 이름으로 호출되면 파일은 반복 시작시 한 번 열리고 끝에서 닫힙니다. 반복이 중단되면 &lt;code&gt;EachLine&lt;/code&gt; 객체가 가비지 수집 될 때 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="ef0e28d10352752c6450ce2dfc986b9c25b31c66" translate="yes" xml:space="preserve">
          <source>Create an iterable object for visiting each index of an &lt;code&gt;AbstractArray&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; in an efficient manner. For array types that have opted into fast linear indexing (like &lt;code&gt;Array&lt;/code&gt;), this is simply the range &lt;code&gt;1:length(A)&lt;/code&gt;. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</source>
          <target state="translated">효율적인 방법으로 &lt;code&gt;AbstractArray&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 의 각 인덱스를 방문하기위한 반복 가능한 객체를 만듭니다 . 빠른 선형 인덱싱 (예 : &lt;code&gt;Array&lt;/code&gt; ) 을 선택한 배열 유형의 경우 이는 단순히 &lt;code&gt;1:length(A)&lt;/code&gt; 범위 입니다. 다른 배열 유형의 경우, 특수한 데카르트 범위를 반환하여 모든 차원에 대해 지정된 인덱스를 사용하여 배열에 효율적으로 인덱스합니다. 문자열 및 사전을 포함한 다른 반복 가능한 경우 임의의 인덱스 유형을 지원하는 반복자 객체 (예 : 불균일 한 간격 또는 정수가 아닌 인덱스)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37a114db40a5b561df4c6998b980d11f164be66f" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array analogous to that specified by &lt;code&gt;storagetype&lt;/code&gt;, but with &lt;code&gt;axes&lt;/code&gt; specified by the last argument. &lt;code&gt;storagetype&lt;/code&gt; might be a type or a function.</source>
          <target state="translated">&lt;code&gt;storagetype&lt;/code&gt; 에 의해 지정된 것과 유사 하지만 마지막 인수에 의해 지정된 &lt;code&gt;axes&lt;/code&gt; 으로 초기화되지 않은 변경 가능한 배열을 만듭니다 . &lt;code&gt;storagetype&lt;/code&gt; 은 유형 또는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8ea45663459513f743906566fff438525d9ff0" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's &lt;code&gt;eltype&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</source>
          <target state="translated">주어진 소스 배열을 기반으로 주어진 요소 유형 및 크기로 초기화되지 않은 가변 배열을 만듭니다. 두 번째와 세 번째 인수는 모두 선택 사항이며, 기본적으로 지정된 배열의 &lt;code&gt;eltype&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 입니다. 차원은 단일 튜플 인수 또는 일련의 정수 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79911f08e573f962982b247d6e1b479293a78b80" translate="yes" xml:space="preserve">
          <source>Create and listen on a named pipe / UNIX domain socket.</source>
          <target state="translated">명명 된 파이프 / UNIX 도메인 소켓에서 작성하고 청취하십시오.</target>
        </trans-unit>
        <trans-unit id="b3e62302ce3bda257e6680d1de93fd94d29afc80" translate="yes" xml:space="preserve">
          <source>Create and run a &lt;a href=&quot;../parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; on any available thread. To wait for the task to finish, call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the result of this macro, or call &lt;code&gt;fetch&lt;/code&gt; to wait and then obtain its return value.</source>
          <target state="translated">사용 가능한 스레드 에서 &lt;a href=&quot;../parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 만들고 실행합니다 . 작업이 완료 될 때까지 기다리려면 이 매크로의 결과에 대해 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;fetch&lt;/code&gt; 를 호출 하여 대기 한 다음 반환 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1b543386b4baf8de98d8473a008082cdc29f6cba" translate="yes" xml:space="preserve">
          <source>Create references to remote channels of a specific size and type. &lt;code&gt;f&lt;/code&gt; is a function that when executed on &lt;code&gt;pid&lt;/code&gt; must return an implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">특정 크기 및 유형의 원격 채널에 대한 참조를 작성하십시오. &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;pid&lt;/code&gt; 에서 실행될 때 &lt;code&gt;AbstractChannel&lt;/code&gt; 의 구현을 반환해야하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="946b30e9c53338d66c71fd7a6dcea51240337a53" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;SubArray&lt;/code&gt; from an indexing expression. This can only be applied directly to a reference expression (e.g. &lt;code&gt;@view A[1,2:end]&lt;/code&gt;), and should &lt;em&gt;not&lt;/em&gt; be used as the target of an assignment (e.g. &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt;). See also &lt;a href=&quot;#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; to switch an entire block of code to use views for slicing.</source>
          <target state="translated">작성 &lt;code&gt;SubArray&lt;/code&gt; 인덱싱 식에서합니다. 이것은 참조 표현식 (예 : &lt;code&gt;@view A[1,2:end]&lt;/code&gt; ) 에만 직접 적용 할 수 있으며 할당의 대상으로 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; (예 : &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt; ). 슬라이싱에 뷰를 사용하도록 전체 코드 블록을 전환하려면 &lt;a href=&quot;#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7df04f96de18b903f8a03412ba0a608ddf39df4" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; matrix of zeros. (&lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros(m,n)&lt;/code&gt;&lt;/a&gt; is empty.)</source>
          <target state="translated">작성 &lt;em&gt;m&lt;/em&gt; -by- &lt;em&gt;N 개의&lt;/em&gt; 제로의 매트릭스. ( &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros(m,n)&lt;/code&gt; &lt;/a&gt; 은 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="89e81042f6427ed532f001aa21eed74e1277eedc" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the &lt;em&gt;X&lt;/em&gt; distribution. (Requires the &lt;code&gt;Distributions&lt;/code&gt; package.)</source>
          <target state="translated">&lt;em&gt;X&lt;/em&gt; 분포 에 따라 0이 아닌 iid 요소가 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 . ( &lt;code&gt;Distributions&lt;/code&gt; 패키지가 필요합니다 .)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dcdc6aa977d12b3464dea6213b384f8502692b5" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</source>
          <target state="translated">표준 정규 (가우시안) 분포에 따라 0이 아닌 iid 요소가 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f8b69c62af1974d81f87c4f3b0ecd8ee59170f8d" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed uniformly on the half-open interval $[0, 1)$.</source>
          <target state="translated">반 개방 간격 $ [0, 1) $에 0이 아닌 iid 요소가 균일하게 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1e3f3a174293168e940c3aa7395700341e6b3d68" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements generated with the &lt;code&gt;rng&lt;/code&gt; random number generator</source>
          <target state="translated">작성 &lt;em&gt;m&lt;/em&gt; -by- &lt;em&gt;N&lt;/em&gt; (밀도의 랜덤 행렬 &lt;em&gt;D&lt;/em&gt; 생성 IID 영이 아닌 요소) &lt;code&gt;rng&lt;/code&gt; 난수 생성기</target>
        </trans-unit>
        <trans-unit id="14a84275cae03e282157d756507c417c693cca8f" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; identity matrix.</source>
          <target state="translated">작성 &lt;em&gt;N&lt;/em&gt; -by- &lt;em&gt;n 개의&lt;/em&gt; 단위 행렬.</target>
        </trans-unit>
        <trans-unit id="7f97f983311aae9228c52a6abb46e64693cf2246" translate="yes" xml:space="preserve">
          <source>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt;. See &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation&quot;&gt;Module initialization and precompilation&lt;/a&gt; for important notes.</source>
          <target state="translated">모듈 및 모든 종속성에 대해 미리 컴파일 된 캐시 파일을 만듭니다. 이는 패키지로드 시간을 줄이는 데 사용할 수 있습니다. 캐시 파일은 &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt; 저장됩니다 . 중요한 참고 사항 은 &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation&quot;&gt;모듈 초기화 및 사전 컴파일&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d1606830bc807d0705cb0cd68427ce107b28412" translate="yes" xml:space="preserve">
          <source>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt;. See &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;Module initialization and precompilation&lt;/a&gt; for important notes.</source>
          <target state="translated">모듈 및 모든 해당 종속성에 대해 사전 컴파일 된 캐시 파일을 작성합니다. 패키지로드 시간을 줄이는 데 사용할 수 있습니다. 캐시 파일은 &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt; 저장됩니다 . 중요한 참고 사항 은 &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;모듈 초기화 및 사전 컴파일&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb9535802e7b206a931b1bd5dd7001d10e59c1c3" translate="yes" xml:space="preserve">
          <source>Creates a re-entrant lock for synchronizing &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s. The same task can acquire the lock as many times as required. Each &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 동기화를위한 재진입 잠금을 만듭니다 . 동일한 태스크가 필요한만큼 잠금을 획득 할 수 있습니다. 각 &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acabfae1e2f1fc10302e24c287378e2416376616" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link to &lt;code&gt;target&lt;/code&gt; with the name &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;link&lt;/code&gt; 인 &lt;code&gt;target&lt;/code&gt; 대한 심볼릭 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a73f7647123bfc2728187c9560131d8d50116f46" translate="yes" xml:space="preserve">
          <source>Creating C-Compatible Julia Function Pointers</source>
          <target state="translated">C 호환 Julia 함수 포인터 만들기</target>
        </trans-unit>
        <trans-unit id="3383e56fce9b7a3ece327ee47bf1ef8a6d2cba06" translate="yes" xml:space="preserve">
          <source>Creating Custom &lt;code&gt;AbstractTestSet&lt;/code&gt; Types</source>
          <target state="translated">커스텀 &lt;code&gt;AbstractTestSet&lt;/code&gt; 타입 생성</target>
        </trans-unit>
        <trans-unit id="7cd4ab56a79487eec69d5f21bd101f982fbcd5a4" translate="yes" xml:space="preserve">
          <source>Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see &lt;a href=&quot;#Dates.@dateformat_str&quot;&gt;&lt;code&gt;@dateformat_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DateFormat 객체를 만드는 데 많은 비용이 듭니다. 가능하면 한 번 작성하여 여러 번 사용하거나 &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; 문자열 매크로를 사용해보십시오 . 이 매크로를 사용하면 매크로 확장 시간에 DateFormat 객체를 한 번 만들고 나중에 재사용합니다. &lt;a href=&quot;#Dates.@dateformat_str&quot;&gt; &lt;code&gt;@dateformat_str&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee7646078f40a52ecc8cd5d5abbf897cedcf3493" translate="yes" xml:space="preserve">
          <source>Creating accidental &quot;copies&quot; of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</source>
          <target state="translated">조회 경로 대신 직접 참조하여 다른 모듈에서 실수로 전역 상태의 &quot;복사본&quot;을 만듭니다. 예를 들어 (전역 범위에서) :</target>
        </trans-unit>
        <trans-unit id="be1f31994e9b5f386872c25814ba699f9d95f309" translate="yes" xml:space="preserve">
          <source>Creating events</source>
          <target state="translated">이벤트 만들기</target>
        </trans-unit>
        <trans-unit id="dfc1e3935e5f561b9a3fdb1b5f2655135605e4b0" translate="yes" xml:space="preserve">
          <source>Creating new generators</source>
          <target state="translated">새로운 발전기 생성</target>
        </trans-unit>
        <trans-unit id="6051151a12d03a26f4a70b65c2b0ad21b81b82d7" translate="yes" xml:space="preserve">
          <source>Creation of a &lt;code&gt;Ref&lt;/code&gt; to a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; is usually written &lt;code&gt;Ref(x)&lt;/code&gt;. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written &lt;code&gt;Ref(a, i)&lt;/code&gt; for creating a reference to the &lt;code&gt;i&lt;/code&gt;-th element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 &lt;code&gt;x&lt;/code&gt; 값 에 대한 &lt;code&gt;Ref&lt;/code&gt; 생성 은 일반적으로 &lt;code&gt;Ref(x)&lt;/code&gt; 작성 됩니다. 또한 컨테이너 (예 : Array 또는 Ptr)에 대한 내부 포인터를 만들기 위해의 &lt;code&gt;i&lt;/code&gt; 번째 요소에 &lt;code&gt;a&lt;/code&gt; 참조를 만들기 위해 &lt;code&gt;Ref(a, i)&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dc5259164d5812ceebcb04307a85959962c480d" translate="yes" xml:space="preserve">
          <source>Credential authentication is done in the following order (if supported):</source>
          <target state="translated">자격 증명 인증은 다음 순서로 수행됩니다 (지원되는 경우).</target>
        </trans-unit>
        <trans-unit id="d2942a33f8d919c5d366f7a8dd1e21bb97daf1e5" translate="yes" xml:space="preserve">
          <source>Credential that support only &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 매개 변수 만 지원하는 신임 정보</target>
        </trans-unit>
        <trans-unit id="69ed5aaf168648107a82ebf81dcad59625ab3893" translate="yes" xml:space="preserve">
          <source>Credit Card</source>
          <target state="translated">신용 카드</target>
        </trans-unit>
        <trans-unit id="746fdeaa0f4b76ffba7f25f558ab182a154045eb" translate="yes" xml:space="preserve">
          <source>Crescent Moon</source>
          <target state="translated">초승달</target>
        </trans-unit>
        <trans-unit id="9550e2815afbb248fddb5160d9632f01d171be80" translate="yes" xml:space="preserve">
          <source>Crocodile</source>
          <target state="translated">Crocodile</target>
        </trans-unit>
        <trans-unit id="1b84d42ee29ecbd7da313dc3edd661620b90adac" translate="yes" xml:space="preserve">
          <source>Cross Mark</source>
          <target state="translated">크로스 마크</target>
        </trans-unit>
        <trans-unit id="6439d5abed8064d49532208f798b24bad4eeaedb" translate="yes" xml:space="preserve">
          <source>Crossed Flags</source>
          <target state="translated">교차 플래그</target>
        </trans-unit>
        <trans-unit id="410494f2cf468cb98b4655657880ea42f72183c0" translate="yes" xml:space="preserve">
          <source>Crown</source>
          <target state="translated">Crown</target>
        </trans-unit>
        <trans-unit id="72f9cdf37b21797f93e24173fe1674094d502584" translate="yes" xml:space="preserve">
          <source>Crying Cat Face</source>
          <target state="translated">우는 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="aa2d3386215f67207e9681df8287caf675bf59f2" translate="yes" xml:space="preserve">
          <source>Crying Face</source>
          <target state="translated">우는 얼굴</target>
        </trans-unit>
        <trans-unit id="69723d1a814546ee7350009a712142c1bb170c13" translate="yes" xml:space="preserve">
          <source>Crystal Ball</source>
          <target state="translated">수정 구슬</target>
        </trans-unit>
        <trans-unit id="f6aabde44a92ffc82d2ba7b1190b078fefc14c2b" translate="yes" xml:space="preserve">
          <source>Cshort</source>
          <target state="translated">Cshort</target>
        </trans-unit>
        <trans-unit id="cad2cc015431eb8277af58253306038c83981e1b" translate="yes" xml:space="preserve">
          <source>Csize_t</source>
          <target state="translated">Csize_t</target>
        </trans-unit>
        <trans-unit id="4022d2757281621dd4126003c4abfb786032fbcf" translate="yes" xml:space="preserve">
          <source>Cssize_t</source>
          <target state="translated">Cssize_t</target>
        </trans-unit>
        <trans-unit id="dfe331758ccf94f376b9ef5ba3fc63195b90e80d" translate="yes" xml:space="preserve">
          <source>Cstring</source>
          <target state="translated">Cstring</target>
        </trans-unit>
        <trans-unit id="6b5a31718a4c0850b761d24de3b5aa88f92f5166" translate="yes" xml:space="preserve">
          <source>Cube Root</source>
          <target state="translated">큐브 루트</target>
        </trans-unit>
        <trans-unit id="e17b700fe47780159b8cf1ee414cd605ea55478e" translate="yes" xml:space="preserve">
          <source>Cuchar</source>
          <target state="translated">Cuchar</target>
        </trans-unit>
        <trans-unit id="19b94831c1a53e707deeb78349f682ad817cafbc" translate="yes" xml:space="preserve">
          <source>Cuint</source>
          <target state="translated">Cuint</target>
        </trans-unit>
        <trans-unit id="bfaf7a56354eba13b1561f6000228821b55aedb8" translate="yes" xml:space="preserve">
          <source>Cuintmax_t</source>
          <target state="translated">Cuintmax_t</target>
        </trans-unit>
        <trans-unit id="91908ced92ffd6336c39db3012de651ae9fc627b" translate="yes" xml:space="preserve">
          <source>Culong</source>
          <target state="translated">Culong</target>
        </trans-unit>
        <trans-unit id="9163538589351903cc7d613710b25bb603d2126c" translate="yes" xml:space="preserve">
          <source>Culonglong</source>
          <target state="translated">Culonglong</target>
        </trans-unit>
        <trans-unit id="6d8929c0661d5c816e4bd42ef00122216903020f" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; (providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors). An initial value &lt;code&gt;init&lt;/code&gt; may optionally be provided by a keyword argument. See also &lt;a href=&quot;#Base.accumulate!&quot;&gt;&lt;code&gt;accumulate!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of &lt;code&gt;accumulate&lt;/code&gt;, see: &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">누적 연산 &lt;code&gt;op&lt;/code&gt; 차원 따라 &lt;code&gt;dims&lt;/code&gt; 의 (제공 &lt;code&gt;dims&lt;/code&gt; 벡터에 대해 선택적이다). 초기 값 &lt;code&gt;init&lt;/code&gt; 는 선택적으로 키워드 인수에 의해 제공 될 수 있습니다. &lt;a href=&quot;#Base.accumulate!&quot;&gt; &lt;code&gt;accumulate!&lt;/code&gt; &lt;/a&gt; 참조 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지). 일반적인 연산의 경우 &lt;code&gt;accumulate&lt;/code&gt; 특수 변형이 있습니다 ( &lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 참조). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9c0cc6e2cab956c3eeff9bdbdc51bf164e4d2a3" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. Providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors. If the keyword argument &lt;code&gt;init&lt;/code&gt; is given, its value is used to instantiate the accumulation. See also &lt;a href=&quot;#Base.accumulate&quot;&gt;&lt;code&gt;accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 연산 &lt;code&gt;op&lt;/code&gt; 가 &lt;code&gt;dims&lt;/code&gt; 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. 제공 &lt;code&gt;dims&lt;/code&gt; 벡터에 대한 선택 사항입니다. 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 제공되면 해당 값이 누적을 인스턴스화하는 데 사용됩니다. 또한 &lt;a href=&quot;#Base.accumulate&quot;&gt; &lt;code&gt;accumulate&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cc6a3d14a831428f91a6d92cb0ac7ceb0d411e1" translate="yes" xml:space="preserve">
          <source>Cumulative product along the dimension &lt;code&gt;dim&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">치수가 &lt;code&gt;dim&lt;/code&gt; 누적 제품 . &lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="c7379162addda6658acdc3f9dd25f46656740bb5" translate="yes" xml:space="preserve">
          <source>Cumulative product of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 곱이 &lt;code&gt;dims&lt;/code&gt; 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="544dc176e0d81f953753079e21fc05f7a65a0a2b" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector &lt;code&gt;x&lt;/code&gt;, storing the result in &lt;code&gt;y&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 의 누적 곱으로 결과를 &lt;code&gt;y&lt;/code&gt; 에 저장합니다 . &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a7848eb8353d1872494fd8d4b74c519af24ce82" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">벡터의 누적 곱. &lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="4542c8440eaef546cac126acfab13b989fe9f95e" translate="yes" xml:space="preserve">
          <source>Cumulative product of an iterator. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">반복자의 누적 곱입니다. &lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 성능 및 출력 정밀도 제어 (예 : 오버플로 방지)를 위해 사전 할당 된 출력 배열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e5d34284af8b1cd8280022818b948ecd056e9f9" translate="yes" xml:space="preserve">
          <source>Cumulative sum a vector. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">누적 합계 벡터 &lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="7ac42a41a170524b37f027a79ba758b538544698" translate="yes" xml:space="preserve">
          <source>Cumulative sum along the dimension &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">차원을 따라 누적 된 합계가 &lt;code&gt;dims&lt;/code&gt; 됩니다. &lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="28c0c9f82b9df1b46e1d92dc89a14b12f71a0eea" translate="yes" xml:space="preserve">
          <source>Cumulative sum an iterator. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">반복자의 누적 합계입니다. &lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 성능 및 출력 정밀도 제어 (예 : 오버플로 방지)를 위해 사전 할당 된 출력 배열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bff05572bc3057d02ece9df07eb6cbd41f496fa0" translate="yes" xml:space="preserve">
          <source>Cumulative sum of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 합계가 &lt;code&gt;dims&lt;/code&gt; 되고 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. &lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99912e940e13479c415ea623b516e8ffb7fa26f1" translate="yes" xml:space="preserve">
          <source>Curly Logical And</source>
          <target state="translated">곱슬 논리와</target>
        </trans-unit>
        <trans-unit id="be512ff433c9dff6b74aeeea37b129ec63571384" translate="yes" xml:space="preserve">
          <source>Curly Logical Or</source>
          <target state="translated">꼬부라 진 논리 또는</target>
        </trans-unit>
        <trans-unit id="e60553c7a9a9cdb72bb36b2a44dd16e0bda76d87" translate="yes" xml:space="preserve">
          <source>Curly Loop</source>
          <target state="translated">곱슬 루프</target>
        </trans-unit>
        <trans-unit id="bfaceaf351e410dbe378f231dc87232a28180ee2" translate="yes" xml:space="preserve">
          <source>Currency Exchange</source>
          <target state="translated">환전소</target>
        </trans-unit>
        <trans-unit id="fa21c13b708840eecec79752cb17fc8c7197e8b1" translate="yes" xml:space="preserve">
          <source>Currently Julia supports &lt;code&gt;Intel VTune&lt;/code&gt;, &lt;code&gt;OProfile&lt;/code&gt; and &lt;code&gt;perf&lt;/code&gt; as external profiling tools.</source>
          <target state="translated">현재 Julia는 &lt;code&gt;Intel VTune&lt;/code&gt; , &lt;code&gt;OProfile&lt;/code&gt; 및 &lt;code&gt;perf&lt;/code&gt; 를 외부 프로파일 링 도구로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5520b828a027b38a2df58c016c8a9e33a20b2c8f" translate="yes" xml:space="preserve">
          <source>Currently running, or able to run</source>
          <target state="translated">현재 실행 중이거나 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1cfdd1bbbc6e0ec95ba54ab86c4ed8984999f41c" translate="yes" xml:space="preserve">
          <source>Currently supported rounding modes are:</source>
          <target state="translated">현재 지원되는 반올림 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b6fb5cf9ba1d3a630cca350c13b1d2ae5247dd" translate="yes" xml:space="preserve">
          <source>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, &lt;code&gt;asyncmap&lt;/code&gt; is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</source>
          <target state="translated">현재 Julia의 모든 작업은 단일 OS 스레드에서 협력 적으로 실행됩니다. 결과적으로 &lt;code&gt;asyncmap&lt;/code&gt; 은 매핑 기능에 디스크, 네트워크, 원격 작업자 호출 등의 I / O가 포함 된 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2b6dbadabdc5ac18fd3d193d17d49f9b69abe7e2" translate="yes" xml:space="preserve">
          <source>Currently, dynamically linking with the &lt;code&gt;libjulia&lt;/code&gt; shared library requires passing the &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; option. In Python, this looks like:</source>
          <target state="translated">현재 &lt;code&gt;libjulia&lt;/code&gt; 공유 라이브러리 와 동적으로 연결 하려면 &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; 옵션을 전달해야합니다 . 파이썬에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b58fc7e8f3abd23e8c9cb124443e19466f0c18f" translate="yes" xml:space="preserve">
          <source>Currently, only the platform-default C calling convention is supported. This means that &lt;code&gt;@cfunction&lt;/code&gt;-generated pointers cannot be used in calls where WINAPI expects &lt;code&gt;stdcall&lt;/code&gt; function on 32-bit windows, but can be used on WIN64 (where &lt;code&gt;stdcall&lt;/code&gt; is unified with the C calling convention).</source>
          <target state="translated">현재 플랫폼 기본 C 호출 규칙 만 지원됩니다. 이것은 &lt;code&gt;@cfunction&lt;/code&gt; 생성 포인터는 WINAPI 가 32 비트 윈도우에서 &lt;code&gt;stdcall&lt;/code&gt; 함수를 기대하는 호출에는 사용할 수 없지만 WIN64에서는 사용할 수 있습니다 ( &lt;code&gt;stdcall&lt;/code&gt; 은 C 호출 규칙 으로 통합됨 ).</target>
        </trans-unit>
        <trans-unit id="1c0ed0fbc55fd384be8ba62427107654c612d24c" translate="yes" xml:space="preserve">
          <source>Currently, only the platform-default C calling convention is supported. This means that &lt;code&gt;@cfunction&lt;/code&gt;-generated pointers cannot be used in calls where WINAPI expects a &lt;code&gt;stdcall&lt;/code&gt; function on 32-bit Windows, but can be used on WIN64 (where &lt;code&gt;stdcall&lt;/code&gt; is unified with the C calling convention).</source>
          <target state="translated">현재 플랫폼 기본 C 호출 규칙 만 지원됩니다. 즉 , WINAPI 가 32 비트 Windows에서 &lt;code&gt;stdcall&lt;/code&gt; 함수를 예상하는 호출에서는 &lt;code&gt;@cfunction&lt;/code&gt; 생성 포인터를 사용할 수 없지만 WIN64에서는 사용할 수 있습니다 ( &lt;code&gt;stdcall&lt;/code&gt; 이 C 호출 규칙 으로 통합됨 ).</target>
        </trans-unit>
        <trans-unit id="f6c1e688c50876a4531f9d7cabb03fb248e6bfc9" translate="yes" xml:space="preserve">
          <source>Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.</source>
          <target state="translated">현재 연결되지 않은 작업자간에 메시지를 보내면 오류가 발생합니다. 기능 및 인터페이스와 마찬가지로이 동작은 실험적으로 간주되어야하며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1fc8148f1ad416a0c1c4d0cd037e79c49a7d381" translate="yes" xml:space="preserve">
          <source>Curry And Rice</source>
          <target state="translated">카레라이스</target>
        </trans-unit>
        <trans-unit id="b85bdac6301eb2112a6814938a4d9e9df8648b71" translate="yes" xml:space="preserve">
          <source>Cushort</source>
          <target state="translated">Cushort</target>
        </trans-unit>
        <trans-unit id="8c54a5c7812a0f093c8cd0f91e33751d5c09251e" translate="yes" xml:space="preserve">
          <source>Custard</source>
          <target state="translated">Custard</target>
        </trans-unit>
        <trans-unit id="6f38ef54fa59e818dab5a77f3d2bbd3220e2cdca" translate="yes" xml:space="preserve">
          <source>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 AbstractArray 하위 유형은 주어진 요소 유형 및 차원에 대해 가장 적합한 특정 배열 유형을 선택할 수 있습니다. 이 메소드를 특수화하지 않은 경우 기본값은 &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cc23a6161705d9edec42bd9037fd1426e4ee526" translate="yes" xml:space="preserve">
          <source>Custom error hints are available as of Julia 1.5.</source>
          <target state="translated">사용자 지정 오류 힌트는 Julia 1.5부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="097b8517391234e3c538e3449a9973ab8c13bc85" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestStyle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast!&lt;/code&gt; 맞춤형 구현 ! , &lt;code&gt;DestStyle&lt;/code&gt; 전문</target>
        </trans-unit>
        <trans-unit id="06904021bd513a29837f2a6d605afdc08f9d837c" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast!&lt;/code&gt; 맞춤형 구현 ! , &lt;code&gt;DestType&lt;/code&gt; 전문</target>
        </trans-unit>
        <trans-unit id="5b22d816549f3f00985f636630289bedbe251e80" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast&lt;/code&gt; 맞춤형 구현</target>
        </trans-unit>
        <trans-unit id="ea84a2c763f893aebf33f5fbf487cce49443ce61" translate="yes" xml:space="preserve">
          <source>Custom loggers should come with overloads for the functions described in the &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;reference section&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 로거는 &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;참조 섹션에&lt;/a&gt; 설명 된 기능에 대한 오버로드와 함께 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9da5ea657bda58f10cb83ead3ab61bfbc054ab56" translate="yes" xml:space="preserve">
          <source>Custom loggers should come with overloads for the functions described in the &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;reference section&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 로거에는 &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;참조 섹션에&lt;/a&gt; 설명 된 기능에 대한 과부하가 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f5be3cf33c9dad979d2a47c098609bed1e79588" translate="yes" xml:space="preserve">
          <source>Custom pretty-printing</source>
          <target state="translated">맞춤형 인쇄</target>
        </trans-unit>
        <trans-unit id="240986e918ac3d8fdf4ca20934614f2b94d7e71f" translate="yes" xml:space="preserve">
          <source>Custom sampler types</source>
          <target state="translated">커스텀 샘플러 유형</target>
        </trans-unit>
        <trans-unit id="f521cfc6a5585c09da5d9bc813b838a1bd8a6e43" translate="yes" xml:space="preserve">
          <source>Customizable binary operators</source>
          <target state="translated">사용자 정의 가능한 이항 연산자</target>
        </trans-unit>
        <trans-unit id="5750ccbb9a21360352689ce8553c6205a82553f4" translate="yes" xml:space="preserve">
          <source>Customization / Configuration</source>
          <target state="translated">주 문화 / 구성</target>
        </trans-unit>
        <trans-unit id="7081c24bd2fc87db9d99bce55e22acb378d5b91a" translate="yes" xml:space="preserve">
          <source>Customizing Colors</source>
          <target state="translated">색상 사용자 정의</target>
        </trans-unit>
        <trans-unit id="34880a9b35cda4c00b118d47d483351c6cc5ea2a" translate="yes" xml:space="preserve">
          <source>Customizing broadcasting</source>
          <target state="translated">방송 사용자 정의</target>
        </trans-unit>
        <trans-unit id="f9dfc91c94f0af58add748a7278bdfc60588cf5c" translate="yes" xml:space="preserve">
          <source>Customizing keybindings</source>
          <target state="translated">키 바인딩 사용자 정의</target>
        </trans-unit>
        <trans-unit id="22c43c80b6acba6c8e988834746cb3dad10dc13a" translate="yes" xml:space="preserve">
          <source>Customs</source>
          <target state="translated">Customs</target>
        </trans-unit>
        <trans-unit id="9cfe6bc8642611e40313cf0cc79620f14dffbbc6" translate="yes" xml:space="preserve">
          <source>Cwchar_t</source>
          <target state="translated">Cwchar_t</target>
        </trans-unit>
        <trans-unit id="d3862adb8c043e056018bc4b8a261f178c58e987" translate="yes" xml:space="preserve">
          <source>Cwstring</source>
          <target state="translated">Cwstring</target>
        </trans-unit>
        <trans-unit id="33ec23db96b16085821b404cc8c2b54fbfda44f5" translate="yes" xml:space="preserve">
          <source>Cyclone</source>
          <target state="translated">Cyclone</target>
        </trans-unit>
        <trans-unit id="216ff17303fbb44375e7a618a8708d4627fec28a" translate="yes" xml:space="preserve">
          <source>DEPOT_PATH</source>
          <target state="translated">DEPOT_PATH</target>
        </trans-unit>
        <trans-unit id="83dc75e20dcbf622a6cf33144a983d98f677b3aa" translate="yes" xml:space="preserve">
          <source>DI</source>
          <target state="translated">DI</target>
        </trans-unit>
        <trans-unit id="50fb8228b3b9fa5b2166d5730e6bbd9d4de9cae6" translate="yes" xml:space="preserve">
          <source>DL_LOAD_PATH</source>
          <target state="translated">DL_LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="8e0e5961c9dc8c314c3d9bec3aebc5d5dceab1d6" translate="yes" xml:space="preserve">
          <source>Dagger</source>
          <target state="translated">Dagger</target>
        </trans-unit>
        <trans-unit id="d588da27f7b558f43e86a7f0556da786a0f5702f" translate="yes" xml:space="preserve">
          <source>Dalet Symbol / Fourth Transfinite Cardinal</source>
          <target state="translated">대리 기호 / 네 번째 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="bbd3fe91db28cc6eaba879d637ff2415c19eaed3" translate="yes" xml:space="preserve">
          <source>Dancer</source>
          <target state="translated">Dancer</target>
        </trans-unit>
        <trans-unit id="4e457c357290fffb26efe10315ee86c05aa550ed" translate="yes" xml:space="preserve">
          <source>Dango</source>
          <target state="translated">Dango</target>
        </trans-unit>
        <trans-unit id="3f48fb7aab68e6aa82c811a8bdd3137296109c01" translate="yes" xml:space="preserve">
          <source>Dark Shade</source>
          <target state="translated">어두운 그늘</target>
        </trans-unit>
        <trans-unit id="ec3e5d3b5f51290af48556e1a22232b6c075e886" translate="yes" xml:space="preserve">
          <source>Dash Symbol</source>
          <target state="translated">대시 기호</target>
        </trans-unit>
        <trans-unit id="d1ee13b5a357f064705d5d2ee301ca24cec2d711" translate="yes" xml:space="preserve">
          <source>Data Formats</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="b9a20ab226cf235e7e270845c1fed39a764c870e" translate="yes" xml:space="preserve">
          <source>Data Movement</source>
          <target state="translated">데이터 이동</target>
        </trans-unit>
        <trans-unit id="e5669bbf5a381f1b45f515386259ddfc4dd6e523" translate="yes" xml:space="preserve">
          <source>Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and when data is stored to a&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; on a different node. As expected, this results in a copy of the serialized objects on the remote node. However, when the destination node is the local node, i.e. the calling process id is the same as the remote node id, it is executed as a local call. It is usually(not always) executed in a different task - but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed - no copies are created. This behavior is highlighted below:</source>
          <target state="translated">데이터는 실행을 위해 반드시 원격 노드로 복사됩니다. 이것은 원격 호출과 데이터가 다른 노드 의 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에 저장된 경우 모두에 해당됩니다 . 예상 한대로 원격 노드에서 직렬화 된 오브젝트의 사본이 생성됩니다. 그러나 대상 노드가 로컬 노드 인 경우, 즉 호출 프로세스 ID가 원격 노드 ID와 동일하면 로컬 호출로 실행됩니다. 일반적으로 다른 작업에서 항상 실행되는 것은 아니지만 데이터의 직렬화 / 직렬화는 없습니다. 결과적으로, 호출은 전달 된 것과 동일한 오브젝트 인스턴스를 참조하며 사본이 작성되지 않습니다. 이 동작은 아래에 강조 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="968eebea0b7cae13cfdef325216bc706131315d1" translate="yes" xml:space="preserve">
          <source>Data-race freedom</source>
          <target state="translated">데이터 레이스의 자유</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="36896b6958dbc42b827d9983351001153fb900f9" translate="yes" xml:space="preserve">
          <source>Dates Functions</source>
          <target state="translated">날짜 기능</target>
        </trans-unit>
        <trans-unit id="87a830783aa282885319d8bb8573974c6e9ce862" translate="yes" xml:space="preserve">
          <source>Dates and Time Types</source>
          <target state="translated">날짜 및 시간 유형</target>
        </trans-unit>
        <trans-unit id="1c3699dfa0f90796e26bab33925787fed0c43f91" translate="yes" xml:space="preserve">
          <source>Dates.Date</source>
          <target state="translated">Dates.Date</target>
        </trans-unit>
        <trans-unit id="32f52acc781735072821be18d470cd0e9e957322" translate="yes" xml:space="preserve">
          <source>Dates.Time</source>
          <target state="translated">Dates.Time</target>
        </trans-unit>
        <trans-unit id="fdec256842a6d05072d851ee7ef615cfbd56e9d8" translate="yes" xml:space="preserve">
          <source>Day of the month with a minimum width</source>
          <target state="translated">최소 너비의 날짜</target>
        </trans-unit>
        <trans-unit id="cfc71f3899e9e62bb3cb32d518c2500090d68e5a" translate="yes" xml:space="preserve">
          <source>Days of the Week:</source>
          <target state="translated">요일 :</target>
        </trans-unit>
        <trans-unit id="75abb16100a8a64fe67d2b115039ae07750abe57" translate="yes" xml:space="preserve">
          <source>De-activate the region (i.e. make it not highlighted)</source>
          <target state="translated">영역을 비활성화합니다 (예 : 강조 표시하지 않음)</target>
        </trans-unit>
        <trans-unit id="cf4ca495e016d85d54e9e0c6c172007a72b770a7" translate="yes" xml:space="preserve">
          <source>Debugging and profiling</source>
          <target state="translated">디버깅 및 프로파일 링</target>
        </trans-unit>
        <trans-unit id="86110bf8d0223821e4a3030b465ecd127fd05ca4" translate="yes" xml:space="preserve">
          <source>Decide whether the concept in question will be written as &lt;code&gt;MyType&lt;/code&gt; or &lt;code&gt;MyType()&lt;/code&gt;, and stick to it.</source>
          <target state="translated">해당 개념이 &lt;code&gt;MyType&lt;/code&gt; 또는 &lt;code&gt;MyType()&lt;/code&gt; 로 작성 될지 결정하고이를 준수 하십시오.</target>
        </trans-unit>
        <trans-unit id="f2225e92be396a4c31e9028b01af2d8105bf4719" translate="yes" xml:space="preserve">
          <source>Decides which &lt;code&gt;BroadcastStyle&lt;/code&gt; to use for any number of value arguments. Uses &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; to get the style for each argument, and uses &lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt;&lt;code&gt;result_style&lt;/code&gt;&lt;/a&gt; to combine styles.</source>
          <target state="translated">여러 값 인수에 사용할 &lt;code&gt;BroadcastStyle&lt;/code&gt; 을 결정 합니다. &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; 을 사용 하여 각 인수의 스타일을 가져 &lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt; &lt;code&gt;result_style&lt;/code&gt; &lt;/a&gt; 을 사용하여 스타일을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="56705d4190361578370161ee548e7b8b5b6f2df3" translate="yes" xml:space="preserve">
          <source>Deciduous Tree</source>
          <target state="translated">낙엽수</target>
        </trans-unit>
        <trans-unit id="187bdf507820ae854f975416a37658ae06b738ce" translate="yes" xml:space="preserve">
          <source>Declaration of the indices of &lt;code&gt;x&lt;/code&gt;, as per &lt;code&gt;axes(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axes(x)&lt;/code&gt; 따라 &lt;code&gt;x&lt;/code&gt; 의 인덱스 선언 .</target>
        </trans-unit>
        <trans-unit id="c678ba8568226163ef571fe8bacb3339af3cbb35" translate="yes" xml:space="preserve">
          <source>Declarations can also be attached to function definitions:</source>
          <target state="translated">함수 정의에 선언을 첨부 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a398a40b1491048874f131c113c16e7ddf1ebf5" translate="yes" xml:space="preserve">
          <source>Declare the type of &lt;code&gt;x&lt;/code&gt; explicitly as &lt;code&gt;x::Float64 = 1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 유형을 &lt;code&gt;x::Float64 = 1&lt;/code&gt; 로 명시 적으로 선언합니다.</target>
        </trans-unit>
        <trans-unit id="e2c99269d5b17a5b20dd25e68e9877e78c5ffa82" translate="yes" xml:space="preserve">
          <source>Declare the type of &lt;code&gt;x&lt;/code&gt;: &lt;code&gt;x::Float64 = 1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : &lt;code&gt;x::Float64 = 1&lt;/code&gt; 의 유형을 선언하십시오</target>
        </trans-unit>
        <trans-unit id="eb67cf4c6f0459524901230203e023a095836c6e" translate="yes" xml:space="preserve">
          <source>Declared Types</source>
          <target state="translated">선언 된 유형</target>
        </trans-unit>
        <trans-unit id="2c66e9dea182f1b50d49414e9afb7bd032249fee" translate="yes" xml:space="preserve">
          <source>Declared structure</source>
          <target state="translated">선언 된 구조</target>
        </trans-unit>
        <trans-unit id="88befac5b75ff9c9169815848fea3c4891d14f29" translate="yes" xml:space="preserve">
          <source>Decode the base64-encoded &lt;code&gt;string&lt;/code&gt; and returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of the decoded bytes.</source>
          <target state="translated">base64로 인코딩 된 &lt;code&gt;string&lt;/code&gt; 디코딩하고 디코딩 된 바이트의 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="46f09cf010188cfcdb80ed5e20b17e0855505297" translate="yes" xml:space="preserve">
          <source>Decoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume that &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:</source>
          <target state="translated">실제로 값을 생성하는 것과 사전 계산을 분리하는 것은 API의 일부이며 사용자도 사용할 수 있습니다. 예를 들어, &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; 이 루프에서 반복적으로 호출되어야 한다고 가정합니다 .이 디커플링을 활용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6f5642c9108dbd07942cf967b8a2867aca7eec1" translate="yes" xml:space="preserve">
          <source>Def. 4: &lt;code&gt;alpha=0&lt;/code&gt;, &lt;code&gt;beta=1&lt;/code&gt;</source>
          <target state="translated">데프. 4 : &lt;code&gt;alpha=0&lt;/code&gt; , &lt;code&gt;beta=1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9595afd3ae45456faaf9d1b3bc37c042164ebce0" translate="yes" xml:space="preserve">
          <source>Def. 5: &lt;code&gt;alpha=0.5&lt;/code&gt;, &lt;code&gt;beta=0.5&lt;/code&gt;</source>
          <target state="translated">데프. 5 : &lt;code&gt;alpha=0.5&lt;/code&gt; , &lt;code&gt;beta=0.5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="077d65f8ac7ab40c5438963ab6b21a85d99f9894" translate="yes" xml:space="preserve">
          <source>Def. 6: &lt;code&gt;alpha=0&lt;/code&gt;, &lt;code&gt;beta=0&lt;/code&gt; (Excel &lt;code&gt;PERCENTILE.EXC&lt;/code&gt;, Python default, Stata &lt;code&gt;altdef&lt;/code&gt;)</source>
          <target state="translated">데프. 6 : &lt;code&gt;alpha=0&lt;/code&gt; , &lt;code&gt;beta=0&lt;/code&gt; (Excel &lt;code&gt;PERCENTILE.EXC&lt;/code&gt; , Python 기본값, Stata &lt;code&gt;altdef&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95183fa1581b054fcf1747b0515a86da5f944d84" translate="yes" xml:space="preserve">
          <source>Def. 7: &lt;code&gt;alpha=1&lt;/code&gt;, &lt;code&gt;beta=1&lt;/code&gt; (Julia, R and NumPy default, Excel &lt;code&gt;PERCENTILE&lt;/code&gt; and &lt;code&gt;PERCENTILE.INC&lt;/code&gt;, Python &lt;code&gt;'inclusive'&lt;/code&gt;)</source>
          <target state="translated">데프. 7 : &lt;code&gt;alpha=1&lt;/code&gt; , &lt;code&gt;beta=1&lt;/code&gt; (Julia, R 및 NumPy 기본값, Excel &lt;code&gt;PERCENTILE&lt;/code&gt; 및 &lt;code&gt;PERCENTILE.INC&lt;/code&gt; , Python &lt;code&gt;'inclusive'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="27146b4be1d656958e4e3b272c15be6fa645045e" translate="yes" xml:space="preserve">
          <source>Def. 8: &lt;code&gt;alpha=1/3&lt;/code&gt;, &lt;code&gt;beta=1/3&lt;/code&gt;</source>
          <target state="translated">데프. 8 : &lt;code&gt;alpha=1/3&lt;/code&gt; , &lt;code&gt;beta=1/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2e5ce22259b1d20b2c1d71acc7e59d337175474" translate="yes" xml:space="preserve">
          <source>Def. 9: &lt;code&gt;alpha=3/8&lt;/code&gt;, &lt;code&gt;beta=3/8&lt;/code&gt;</source>
          <target state="translated">데프. 9 : &lt;code&gt;alpha=3/8&lt;/code&gt; , &lt;code&gt;beta=3/8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="15ac2aa0f274814677f21a2664636a6e0c15f7c8" translate="yes" xml:space="preserve">
          <source>Default is to auto-detect the proxy type.</source>
          <target state="translated">기본값은 프록시 유형을 자동 감지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79c7b4e844bd36e0f1c0ccc6518eefeba8042556" translate="yes" xml:space="preserve">
          <source>Default top-level definitions and bare modules</source>
          <target state="translated">기본 최상위 정의 및 베어 모듈</target>
        </trans-unit>
        <trans-unit id="5e8200e5de4b40f2a761e04f2a21d530f62ac24a" translate="yes" xml:space="preserve">
          <source>Define a new editor matching &lt;code&gt;pattern&lt;/code&gt; that can be used to open a file (possibly at a given line number) using &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 을 사용하여 파일을 여는 데 사용할 수 있는 새 편집기 일치 &lt;code&gt;pattern&lt;/code&gt; 을 정의 합니다 (주어진 줄 번호에서 가능) .</target>
        </trans-unit>
        <trans-unit id="dcdff78b360ed6cd29323d1507c31f96970d8e0b" translate="yes" xml:space="preserve">
          <source>Define a region &lt;code&gt;R&lt;/code&gt; spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where &lt;code&gt;for I in R ... end&lt;/code&gt; will return &lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt;&lt;code&gt;CartesianIndex&lt;/code&gt;&lt;/a&gt; indices &lt;code&gt;I&lt;/code&gt; equivalent to the nested loops</source>
          <target state="translated">정수 인덱스의 다차원 직사각형 범위에 걸쳐 있는 영역 &lt;code&gt;R&lt;/code&gt; 을 정의하십시오 . 이들은 가장 일반적으로 반복의 맥락에서 발생하는 &lt;code&gt;for I in R ... end&lt;/code&gt; 반환됩니다 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt; &lt;code&gt;CartesianIndex&lt;/code&gt; 의&lt;/a&gt; 인덱스를 &lt;code&gt;I&lt;/code&gt; 중첩 된 루프에 해당</target>
        </trans-unit>
        <trans-unit id="a0e4dd75ee5019eb13db03c029c41e75b3aaa5e3" translate="yes" xml:space="preserve">
          <source>Define an &lt;code&gt;AbstractUnitRange&lt;/code&gt; that behaves like &lt;code&gt;1:n&lt;/code&gt;, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</source>
          <target state="translated">(타입 시스템에 의해) 하한이 1로 보장된다는 구별이 추가되어 &lt;code&gt;1:n&lt;/code&gt; 과 같이 동작 하는 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="588b3c159cb4712c0152a8a53daf119df81aa7ba" translate="yes" xml:space="preserve">
          <source>Define other operations that use &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 를 사용하는 다른 연산을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2947f0706fff8e7126e6357ddb46ba0dbd29fa6" translate="yes" xml:space="preserve">
          <source>Defining Methods</source>
          <target state="translated">정의 방법</target>
        </trans-unit>
        <trans-unit id="0c22d4ea82e4f1b312acd9a3994522966c35371b" translate="yes" xml:space="preserve">
          <source>Defining New Conversions</source>
          <target state="translated">새로운 전환 정의</target>
        </trans-unit>
        <trans-unit id="4e6963b3110a46628b4c6d35d33fe7d6e7bd71d0" translate="yes" xml:space="preserve">
          <source>Defining Promotion Rules</source>
          <target state="translated">프로모션 규칙 정의</target>
        </trans-unit>
        <trans-unit id="ecece75a8f8a880522732b9cd0177884625f667e" translate="yes" xml:space="preserve">
          <source>Defining a basic &lt;code&gt;AbstractTestSet&lt;/code&gt; subtype might look like:</source>
          <target state="translated">기본 &lt;code&gt;AbstractTestSet&lt;/code&gt; 하위 유형을 정의하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="38721ea3df19d3ffaf5150dd675b640530a0546d" translate="yes" xml:space="preserve">
          <source>Degree Sign</source>
          <target state="translated">학위 표시</target>
        </trans-unit>
        <trans-unit id="1a4e3b4bb8e1094eb26bfa7cb8783cdea32dfe30" translate="yes" xml:space="preserve">
          <source>Delete and return the mapping for &lt;code&gt;key&lt;/code&gt; if it exists in &lt;code&gt;collection&lt;/code&gt;, otherwise return &lt;code&gt;default&lt;/code&gt;, or throw an error if &lt;code&gt;default&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 대한 맵핑 이 &lt;code&gt;collection&lt;/code&gt; 에 있으면 삭제하고 리턴하십시오 . 그렇지 않으면 &lt;code&gt;default&lt;/code&gt; 를 리턴 하거나 &lt;code&gt;default&lt;/code&gt; 가 지정되지 않은 경우 오류를 발생 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d98877669570739f73775c66eb9704f2ba71ab77" translate="yes" xml:space="preserve">
          <source>Delete previous text up to the nearest whitespace</source>
          <target state="translated">가장 가까운 공백까지 이전 텍스트 삭제</target>
        </trans-unit>
        <trans-unit id="80e6b34017de84d227a51e468428b830d3abce81" translate="yes" xml:space="preserve">
          <source>Delete the branch pointed to by &lt;code&gt;branch&lt;/code&gt;.</source>
          <target state="translated">가리키는 분기 삭제 &lt;code&gt;branch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e26e2e065a1fcbeb86d9a12f9c736cd9f6b54e6" translate="yes" xml:space="preserve">
          <source>Delete the file, link, or empty directory at the given path. If &lt;code&gt;force=true&lt;/code&gt; is passed, a non-existing path is not treated as error. If &lt;code&gt;recursive=true&lt;/code&gt; is passed and the path is a directory, then all contents are removed recursively.</source>
          <target state="translated">주어진 경로에서 파일, 링크 또는 빈 디렉토리를 삭제하십시오. 경우 &lt;code&gt;force=true&lt;/code&gt; 전달, 존재하지 않는 경로 오류로 간주되지 않습니다. 경우 &lt;code&gt;recursive=true&lt;/code&gt; 통과 경로가 디렉토리입니다, 모든 내용이 재귀 적으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e988febce46cb76c97d9a9f098a2791248f65170" translate="yes" xml:space="preserve">
          <source>Delete the mapping for the given key in a collection, and return the collection.</source>
          <target state="translated">컬렉션에서 주어진 키에 대한 매핑을 삭제하고 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44ce9985e153ff02b6235d95732bd1b056146857" translate="yes" xml:space="preserve">
          <source>Delete the mapping for the given key in a collection, if any, and return the collection.</source>
          <target state="translated">컬렉션에서 지정된 키에 대한 매핑 (있는 경우)을 삭제하고 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48c4aef19d86e28665c31c2a1fdfed6ed55b27f0" translate="yes" xml:space="preserve">
          <source>Delete the previous character, or the whole region when it's active</source>
          <target state="translated">이전 캐릭터 또는 활성화 된 전체 지역을 삭제합니다</target>
        </trans-unit>
        <trans-unit id="3cff3520dd83f96bd232342b44e0add55d0baab6" translate="yes" xml:space="preserve">
          <source>Delete the previous word</source>
          <target state="translated">이전 단어를 삭제</target>
        </trans-unit>
        <trans-unit id="91ffc8de7f40ffc066d84c7f26109c9e03c6f805" translate="yes" xml:space="preserve">
          <source>Delete, &lt;code&gt;^D&lt;/code&gt;</source>
          <target state="translated">삭제, &lt;code&gt;^D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53e4d82d4995bf30ba309b0818053aa7081c7519" translate="yes" xml:space="preserve">
          <source>Delimited Files</source>
          <target state="translated">구분 된 파일</target>
        </trans-unit>
        <trans-unit id="cec2c59e089d9f58238ee95327e2b286e786faed" translate="yes" xml:space="preserve">
          <source>Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; lets the parser know that between the first and second slots in a date string like &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt;, it should find the &lt;code&gt;-&lt;/code&gt; character. The &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt; characters let the parser know which periods to parse in each slot.</source>
          <target state="translated">구분 된 슬롯은 파서가 두 개의 후속 기간 사이에 예상 할 구분자를 지정하여 표시됩니다. 따라서 &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; 는 파서가 &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt; 과 같은 날짜 문자열의 첫 번째 슬롯과 두 번째 슬롯 사이 에서 &lt;code&gt;-&lt;/code&gt; 문자를 찾아야 함을 알려 줍니다. &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , 및 &lt;code&gt;d&lt;/code&gt; 문자 기간은 각 슬롯에서 파싱하는 파서 알고하자.</target>
        </trans-unit>
        <trans-unit id="51d69934332b769741cf61b5b730a2cdba3eed7c" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.readdlm()</source>
          <target state="translated">DelimitedFiles.readdlm()</target>
        </trans-unit>
        <trans-unit id="480a3033b9d53578f2568ffa94ff98e43e3f7ea6" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.writedlm()</source>
          <target state="translated">DelimitedFiles.writedlm()</target>
        </trans-unit>
        <trans-unit id="895b5ccc82a877146bc08599ac54b9af5f081f65" translate="yes" xml:space="preserve">
          <source>Delivery Truck</source>
          <target state="translated">배달 트럭</target>
        </trans-unit>
        <trans-unit id="fdff1d4ceb07d550335cfb224cd4c93c1413a0fa" translate="yes" xml:space="preserve">
          <source>Delta Equal To</source>
          <target state="translated">델타 같음</target>
        </trans-unit>
        <trans-unit id="d876cbfe74b813ac207d0e9f78546f7688d9b032" translate="yes" xml:space="preserve">
          <source>Denominator of the rational representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 합리적인 표현의 분모입니다 .</target>
        </trans-unit>
        <trans-unit id="e9501853c3d6adc0961aff7ed40ae9c83e53f278" translate="yes" xml:space="preserve">
          <source>Dense</source>
          <target state="translated">Dense</target>
        </trans-unit>
        <trans-unit id="bff84cd5bdedc08353d7da69b84b0ab8978ba47b" translate="yes" xml:space="preserve">
          <source>Dense Symmetric/Hermitian</source>
          <target state="translated">고밀도 대칭 / 허 르미 티안</target>
        </trans-unit>
        <trans-unit id="36f2b0b5e58f351883eb10f69aec3caeecfa3d2e" translate="yes" xml:space="preserve">
          <source>DenseMatrix</source>
          <target state="translated">DenseMatrix</target>
        </trans-unit>
        <trans-unit id="eccc3b309862b32e23f021b5f67ce45d957d12b0" translate="yes" xml:space="preserve">
          <source>DenseVecOrMat</source>
          <target state="translated">DenseVecOrMat</target>
        </trans-unit>
        <trans-unit id="0359b22dae8b7e9c2a1f55727a94cf7163a84465" translate="yes" xml:space="preserve">
          <source>DenseVector</source>
          <target state="translated">DenseVector</target>
        </trans-unit>
        <trans-unit id="642cae737f8e008435129e4bb7c0bf0176fb92da" translate="yes" xml:space="preserve">
          <source>Department Store</source>
          <target state="translated">백화점</target>
        </trans-unit>
        <trans-unit id="b943c9c136349bfa294ef95babe063e21021459d" translate="yes" xml:space="preserve">
          <source>Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</source>
          <target state="translated">로드 타임을 통해 지속되는 컴파일 타임 부작용에 따라. 다른 Julia 모듈에서 배열 또는 기타 변수 수정; 파일 또는 장치를 열기위한 핸들 유지; 다른 시스템 리소스 (메모리 포함)에 대한 포인터를 저장하는 단계;</target>
        </trans-unit>
        <trans-unit id="5ddfb542597e43f83234973f5482c146195f9e43" translate="yes" xml:space="preserve">
          <source>Depending on the format of the input value, the closest representable value to 2&amp;pi; may be less than 2&amp;pi;. For example, the expression &lt;code&gt;mod2pi(2&amp;pi;)&lt;/code&gt; will not return &lt;code&gt;0&lt;/code&gt;, because the intermediate value of &lt;code&gt;2*&amp;pi;&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;2*Float64(&amp;pi;) &amp;lt; 2*big(&amp;pi;)&lt;/code&gt;. See &lt;a href=&quot;#Base.Math.rem2pi&quot;&gt;&lt;code&gt;rem2pi&lt;/code&gt;&lt;/a&gt; for more refined control of this behavior.</source>
          <target state="translated">입력 값의 형식에 따라 표현 가능한 2&amp;pi;에 가장 가까운 값은 2&amp;pi;보다 작을 수 있습니다. 예를 들어, 발현 &lt;code&gt;mod2pi(2&amp;pi;)&lt;/code&gt; 반환하지 &lt;code&gt;0&lt;/code&gt; 의 중간 값 때문에, &lt;code&gt;2*&amp;pi;&lt;/code&gt; A는 &lt;code&gt;Float64&lt;/code&gt; 및 &lt;code&gt;2*Float64(&amp;pi;) &amp;lt; 2*big(&amp;pi;)&lt;/code&gt; . 이 동작을보다 세밀하게 제어 &lt;a href=&quot;#Base.Math.rem2pi&quot;&gt; &lt;code&gt;rem2pi&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d379477708d634a0aa71159aab76fc85b03d4ea8" translate="yes" xml:space="preserve">
          <source>Depending on the tool you choose, compile with &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt;, &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; and &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; set to 1 in &lt;code&gt;Make.user&lt;/code&gt;. Multiple flags are supported.</source>
          <target state="translated">선택한 도구에 따라 컴파일 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; , &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; 및 &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; 1로 설정 &lt;code&gt;Make.user&lt;/code&gt; . 여러 플래그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1d3a551db738fe045d83ee6293d4963fb1dfe11c" translate="yes" xml:space="preserve">
          <source>Deprecate method &lt;code&gt;old&lt;/code&gt; and specify the replacement call &lt;code&gt;new&lt;/code&gt;. Prevent &lt;code&gt;@deprecate&lt;/code&gt; from exporting &lt;code&gt;old&lt;/code&gt; by setting &lt;code&gt;ex&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;@deprecate&lt;/code&gt; defines a new method with the same signature as &lt;code&gt;old&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old&lt;/code&gt; 메소드 를 사용하지 않고 대체 호출 &lt;code&gt;new&lt;/code&gt; 를 지정하십시오 . &lt;code&gt;ex&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 &lt;code&gt;@deprecate&lt;/code&gt; 가 &lt;code&gt;old&lt;/code&gt; 을 내 보내지 않도록 합니다. &lt;code&gt;@deprecate&lt;/code&gt; 는 &lt;code&gt;old&lt;/code&gt; 와 동일한 서명을 가진 새 메서드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="242a5524acc8713087f708386c9c794f5f3931bd" translate="yes" xml:space="preserve">
          <source>Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.</source>
          <target state="translated">더 이상 사용되지 않는 기능은 후속 릴리스 후에 제거됩니다. 예를 들어, 0.1 릴리스에서 더 이상 사용되지 않는 것으로 표시된 기능은 0.2 릴리스부터 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06a4e84adec4fa6378a8c2435f1ea8fcbef66398" translate="yes" xml:space="preserve">
          <source>Dequeues</source>
          <target state="translated">Dequeues</target>
        </trans-unit>
        <trans-unit id="c65645dadaf75772aa2463e4bea5df65e0668b6a" translate="yes" xml:space="preserve">
          <source>Describes a single instruction/operation to be performed during the rebase. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt;&lt;code&gt;git_rebase_operation&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">리베이스 중에 수행 할 단일 명령 / 작업을 설명합니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt; &lt;code&gt;git_rebase_operation&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="ee984d55c69fd75c93dd767a8b9c6db89c37f979" translate="yes" xml:space="preserve">
          <source>Describing Julia in the lingo of &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;type systems&lt;/a&gt;, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are &lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;explicitly declared&lt;/a&gt;, rather than &lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;implied by compatible structure&lt;/a&gt;. One particularly distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia's type system that should be mentioned up front are:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;유형 시스템&lt;/a&gt; 의 용어로 Julia를 설명하면 동적, 명목 및 매개 변수입니다. 제네릭 형식을 매개 변수화 할 수 있으며 형식 간의 계층 관계는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;호환 가능한 구조가&lt;/a&gt; 아니라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;명시 적으로 선언 &lt;/a&gt;됩니다.. Julia의 유형 시스템에서 특히 두드러진 특징 중 하나는 콘크리트 유형이 서로 하위 유형을 지정할 수 없다는 것입니다. 모든 콘크리트 유형은 최종 유형이며 수퍼 유형으로 추상 유형 만 가질 수 있습니다. 처음에는 이것이 지나치게 제한적으로 보일 수 있지만 놀랍게도 몇 가지 단점이 있지만 많은 이점이 있습니다. 구조를 물려받는 것보다 행동을 물려받을 수있는 것이 훨씬 중요하며, 두 가지를 물려받는 것은 전통적인 객체 지향 언어에서 큰 어려움을 초래합니다. 미리 언급해야 할 Julia 유형 시스템의 다른 높은 수준의 측면은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e39db8493c1fda362ba77503fa8b88b4e7237b8d" translate="yes" xml:space="preserve">
          <source>Description of changes to one entry. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt;&lt;code&gt;git_diff_delta&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">한 항목의 변경 사항에 대한 설명. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt; &lt;code&gt;git_diff_delta&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="988fedca2d77cb7c769954515d3380c033f9d5e4" translate="yes" xml:space="preserve">
          <source>Description of one side of a delta. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt;&lt;code&gt;git_diff_file&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">델타의 한쪽에 대한 설명입니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt; &lt;code&gt;git_diff_file&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="be730a71419945587f16a616135a86d24c6b00df" translate="yes" xml:space="preserve">
          <source>Design Patterns with Parametric Methods</source>
          <target state="translated">파라 메트릭 방법을 사용한 디자인 패턴</target>
        </trans-unit>
        <trans-unit id="3c0874aa1f2c5e541e93555aa18c23a58e93cf08" translate="yes" xml:space="preserve">
          <source>Designed for parallelism and distributed computation</source>
          <target state="translated">병렬 처리 및 분산 계산을 위해 설계</target>
        </trans-unit>
        <trans-unit id="3c1ac6acb43140e473d6bbf32a76f1a42622c490" translate="yes" xml:space="preserve">
          <source>Despite these limitations, sampling profilers have substantial strengths:</source>
          <target state="translated">이러한 제한에도 불구하고 샘플링 프로파일 러는 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7fed4399dc2366cfa2c6427b5726d3747fbb7a6" translate="yes" xml:space="preserve">
          <source>Details can be found in the &lt;a href=&quot;#stdlib-sparse-arrays&quot;&gt;Sparse Vectors and Matrices&lt;/a&gt; section of the standard library reference.</source>
          <target state="translated">자세한 내용은 표준 라이브러리 참조 의 &lt;a href=&quot;#stdlib-sparse-arrays&quot;&gt;희소 벡터 및 행렬&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cff394bb90e68ac928062ab33d7e95c09551667" translate="yes" xml:space="preserve">
          <source>Details can be found in the &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;Sparse Vectors and Matrices&lt;/a&gt; section of the standard library reference.</source>
          <target state="translated">자세한 내용은 표준 라이브러리 참조 의 &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;스파 스 벡터 및 행렬&lt;/a&gt; 섹션 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9abaafa688cd076cbfe0ab170aa5929c003cedc" translate="yes" xml:space="preserve">
          <source>Determine if the branch containing &lt;code&gt;ref&lt;/code&gt; has a specified upstream branch.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 를 포함하는 브랜치 에 지정된 업스트림 브랜치가 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcf969dbd3b4cd23f5e44c248c8256fc35e9a78a" translate="yes" xml:space="preserve">
          <source>Determine if the branch specified by &lt;code&gt;branch_name&lt;/code&gt; exists in the repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;remote&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.</source>
          <target state="translated">&lt;code&gt;branch_name&lt;/code&gt; 으로 지정된 브랜치 가 저장소 &lt;code&gt;repo&lt;/code&gt; 에 존재 하는지 판별하십시오 . 경우 &lt;code&gt;remote&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;repo&lt;/code&gt; 원격 자식 저장소로 간주됩니다. 그렇지 않으면 로컬 파일 시스템의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="34ac1a921df971b54418bdc7fa30b45ba64aa009" translate="yes" xml:space="preserve">
          <source>Determine the declared type of a field (specified by name or index) in a composite DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">복합 DataType &lt;code&gt;T&lt;/code&gt; 에서 필드의 선언 된 유형 (이름 또는 색인으로 지정)을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e74d71e6265c1a4d5bccc1bce9622cb2d709544" translate="yes" xml:space="preserve">
          <source>Determine the module containing a given definition of a generic function.</source>
          <target state="translated">주어진 일반 함수 정의가 포함 된 모듈을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="38ae7ce3fa55379d3288d064511593e9779d54ab" translate="yes" xml:space="preserve">
          <source>Determine the module containing the (first) definition of a generic function.</source>
          <target state="translated">일반 함수의 (첫 번째) 정의를 포함하는 모듈을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6f8abc3832bcad08cf551e8f3ae7259442f202" translate="yes" xml:space="preserve">
          <source>Determine the module containing the definition of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">(잠재적으로 &lt;code&gt;UnionAll&lt;/code&gt; - wrapped) &lt;code&gt;DataType&lt;/code&gt; 의 정의를 포함하는 모듈을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb142e504214629cb5fc814202b65406eb9c20c0" translate="yes" xml:space="preserve">
          <source>Determine the result axes for broadcasting across all values in &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;As&lt;/code&gt; 의 모든 값에서 브로드 캐스팅 할 결과 축을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="410d903111782ec28acaf29cfa71423107052d65" translate="yes" xml:space="preserve">
          <source>Determine the type of the elements generated by iterating a collection of the given &lt;code&gt;type&lt;/code&gt;. For dictionary types, this will be a &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt;. The definition &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</source>
          <target state="translated">주어진 &lt;code&gt;type&lt;/code&gt; 의 컬렉션을 반복하여 생성 된 요소의 형식을 결정합니다 . 사전 유형의 경우 이것은 &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt; 입니다. 정의 &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; 그 인스턴스의 유형 대신 전달 될 수 있도록 편의를 제공한다. 그러나 형식 인수를 허용하는 형식은 새 형식에 대해 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="31e69d279349192cad6ed6fe456ca3b89eeef551" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same elements. Equivalent to &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; but more efficient when possible.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소가 동일한 지 확인합니다 . &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; 와 동일 하지만 가능하면 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="aaf34e07d4b25cba011c9553650f31cccd21dfff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same elements. Equivalent to &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소가 같은지 확인하십시오 . &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe224096ee6d271d8650ef5a85d12ddaf29a9aa" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical, in the sense that no program could distinguish them. First the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a &lt;code&gt;Bool&lt;/code&gt; value.</source>
          <target state="translated">어떤 프로그램도 구별 할 수 없다는 점에서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 지 판별하십시오 . 먼저 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 유형을 비교합니다. 이들이 동일한 경우, 가변 객체는 메모리의 주소로 비교되고 불변 객체 (예 : 숫자)는 비트 레벨의 내용으로 비교됩니다. 이 기능을 때때로 &quot;egal&quot;이라고합니다. 항상 &lt;code&gt;Bool&lt;/code&gt; 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c01841b1d19ebebbfd42e2a4519e9eeb23a21ff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; is of the given &lt;code&gt;type&lt;/code&gt;. Can also be used as an infix operator, e.g. &lt;code&gt;x isa type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 주어진 &lt;code&gt;type&lt;/code&gt; 인지 확인합니다 . &lt;code&gt;x isa type&lt;/code&gt; 과 같은 접두사 연산자로 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3861d13a45d2603781ce381027b447191258c3b4" translate="yes" xml:space="preserve">
          <source>Determine whether Julia is running an interactive session.</source>
          <target state="translated">Julia가 대화식 세션을 실행 중인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="43e65f5a402fa1bae924db49a2a1b4604ea303b3" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Returns immediately, does not block.</source>
          <target state="translated">&lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 에 값이 저장되어 있는지 확인 하십시오. 즉시 반환하고 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="280a7018baf400207d8ed62c131e85ed27290be5" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; has a value stored to it.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에 가치가 저장되어 있는지 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3324d1290d116032871a2bc5a94e10fb519e78" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; since they are assigned only once.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에 값이 저장되어 있는지 확인 하십시오. 이 함수는 결과를 수신 할 때 더 이상 사실이 아니므로 경쟁 조건을 유발할 수 있습니다. 그러나 한 번만 할당되므로 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 안전하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0458f050932959c86f90b6c0643dab4bcd9d1c" translate="yes" xml:space="preserve">
          <source>Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).</source>
          <target state="translated">MIME 유형이 텍스트 데이터인지 판별하십시오. MIME 형식은 텍스트 데이터 (유니 코드)로 알려진 형식 집합을 제외하고 이진 데이터로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc3770027bb1af30a8b4ee8ea80a29e494f0909" translate="yes" xml:space="preserve">
          <source>Determine whether a collection has a mapping for a given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">컬렉션에 지정된 &lt;code&gt;key&lt;/code&gt; 대한 매핑이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c5ba1a2324fb337b282efe50cd8040bf37d77c27" translate="yes" xml:space="preserve">
          <source>Determine whether a collection is empty (has no elements).</source>
          <target state="translated">컬렉션이 비어 있는지 확인합니다 (요소가 없음).</target>
        </trans-unit>
        <trans-unit id="5ec1cb97856793fb5db0068de1e319eab60e77f5" translate="yes" xml:space="preserve">
          <source>Determine whether a global is declared &lt;code&gt;const&lt;/code&gt; in a given &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Module&lt;/code&gt; 에서 전역이 &lt;code&gt;const&lt;/code&gt; 로 선언되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="38e06eb740836bfe1cee92d1e7507081c868e8a5" translate="yes" xml:space="preserve">
          <source>Determine whether a path is absolute (begins at the root directory).</source>
          <target state="translated">경로가 절대인지 판별하십시오 (루트 디렉토리에서 시작).</target>
        </trans-unit>
        <trans-unit id="75728de62cc30cf84c05834c62b8d893a844140e" translate="yes" xml:space="preserve">
          <source>Determine whether a path refers to a directory (for example, ends with a path separator).</source>
          <target state="translated">경로가 디렉토리를 참조하는지 여부를 결정하십시오 (예 : 경로 구분 기호로 끝남).</target>
        </trans-unit>
        <trans-unit id="8b477691984cbcbed81870b45fc48859b3d53183" translate="yes" xml:space="preserve">
          <source>Determine whether a process has exited.</source>
          <target state="translated">프로세스가 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c99d868d531dfe2e187331de7c9920869268ba47" translate="yes" xml:space="preserve">
          <source>Determine whether a process is currently running.</source>
          <target state="translated">프로세스가 현재 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="99d55d3a5192933572c51fc97adc04872c6e44fb" translate="yes" xml:space="preserve">
          <source>Determine whether a stream is read-only.</source>
          <target state="translated">스트림이 읽기 전용인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3bfcd347f5d65568dc838197e09ecfe4405770" translate="yes" xml:space="preserve">
          <source>Determine whether a task has exited because an exception was thrown.</source>
          <target state="translated">예외가 발생하여 작업이 종료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1e9c8b3c9b00278b97a8c0d5b0fc7fce932e91f2" translate="yes" xml:space="preserve">
          <source>Determine whether a task has exited.</source>
          <target state="translated">작업이 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ee4f20f770f5b5e7e4b7c777d2abc2362e36eec7" translate="yes" xml:space="preserve">
          <source>Determine whether a task has started executing.</source>
          <target state="translated">작업이 시작되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dbdbed66108e712ca570ca19802dded33371c86c" translate="yes" xml:space="preserve">
          <source>Determine whether all hexadecimal digits of the given &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; are zero.</source>
          <target state="translated">주어진 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 의 모든 16 진수 가 0 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="0dfd98a60f425f1bd73d9aa1e23986ceb9637766" translate="yes" xml:space="preserve">
          <source>Determine whether an item is in the given collection, in the sense that it is &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; to one of the values generated by iterating over the collection. Returns a &lt;code&gt;Bool&lt;/code&gt; value, except if &lt;code&gt;item&lt;/code&gt; is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;collection&lt;/code&gt; contains &lt;code&gt;missing&lt;/code&gt; but not &lt;code&gt;item&lt;/code&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, matching the behavior of &lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">컬렉션 을 반복하여 생성 된 값 중 하나에 대해 &lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 라는 의미에서 항목이 지정된 컬렉션에 있는지 여부를 판별하십시오 . 반환 &lt;code&gt;Bool&lt;/code&gt; 경우를 제외하고, 값을 &lt;code&gt;item&lt;/code&gt; 됩니다 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;collection&lt;/code&gt; 포함 &lt;code&gt;missing&lt;/code&gt; 이 아닌 &lt;code&gt;item&lt;/code&gt; ,있는 경우 &lt;code&gt;missing&lt;/code&gt; 반환 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리를&lt;/a&gt; ,의 행동 일치하는 &lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; 를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6d70bfc36332f33986741370b3658ad50a9e6d2" translate="yes" xml:space="preserve">
          <source>Determine whether an object - such as a stream or timer &amp;ndash; is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use &lt;a href=&quot;#Base.eof&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; to check for the ability to read data. Use the &lt;code&gt;FileWatching&lt;/code&gt; package to be notified when a stream might be writable or readable.</source>
          <target state="translated">스트림 또는 타이머와 같은 개체가 아직 닫히지 않았는지 확인합니다. 객체가 닫히면 새로운 이벤트가 생성되지 않습니다. 그러나 닫힌 스트림에는 여전히 버퍼에서 읽을 데이터가있을 수 있으므로 &lt;a href=&quot;#Base.eof&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 를 사용하여 데이터를 읽을 수 있는지 확인하십시오. 스트림을 쓸 수 있거나 읽을 수있을 때 알림을 &lt;code&gt;FileWatching&lt;/code&gt; 패키지를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1c47e9d804e0d7ec711f5a7dc45b0f9649cfc5c" translate="yes" xml:space="preserve">
          <source>Determine whether every element of &lt;code&gt;a&lt;/code&gt; is also in &lt;code&gt;b&lt;/code&gt;, using &lt;a href=&quot;#Base.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 요소의 여부를 결정 &lt;code&gt;a&lt;/code&gt; 또한 인 &lt;code&gt;b&lt;/code&gt; 사용 &lt;a href=&quot;#Base.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d0d549fe24528bf78c84130cee192a01bb9ecc1" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;false&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">결정 술어 여부 &lt;code&gt;p&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 의 모든 요소에 대한 &lt;code&gt;itr&lt;/code&gt; , 반환 &lt;code&gt;false&lt;/code&gt; 첫 번째 항목으로 빨리으로 &lt;code&gt;itr&lt;/code&gt; 있는 &lt;code&gt;p&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; 발생 (단락).</target>
        </trans-unit>
        <trans-unit id="289250da1a3e0fba909534e3d914f76f0a83beed" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for any elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;true&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">술어 여부를 확인 &lt;code&gt;p&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 의 요소에 대한 &lt;code&gt;itr&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; 의 첫 번째 항목으로 빨리으로 &lt;code&gt;itr&lt;/code&gt; 있는 &lt;code&gt;p&lt;/code&gt; 를 반환 &lt;code&gt;true&lt;/code&gt; 발생 (단락).</target>
        </trans-unit>
        <trans-unit id="4e07dd9d2d99ac05e19db056ad10a6038f6ab62f" translate="yes" xml:space="preserve">
          <source>Determine whether the first argument is a substring of the second. If &lt;code&gt;needle&lt;/code&gt; is a regular expression, checks whether &lt;code&gt;haystack&lt;/code&gt; contains a match.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수의 하위 문자열인지 확인하십시오. &lt;code&gt;needle&lt;/code&gt; 이 정규식 인 경우 &lt;code&gt;haystack&lt;/code&gt; 에 일치 항목이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="403cb69fbefe8bf1c1819ec0d30c5d58c5b0c9c0" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method applicable to the given arguments.</source>
          <target state="translated">주어진 일반 함수에 주어진 인수에 적용 할 수있는 메소드가 있는지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="0ecef99ec060f64932d509baf07fae2312bff5c4" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method matching the given &lt;code&gt;Tuple&lt;/code&gt; of argument types with the upper bound of world age given by &lt;code&gt;world&lt;/code&gt;.</source>
          <target state="translated">주어진 일반적인 기능은 주어진 일치하는 방법이 있는지 여부를 확인 &lt;code&gt;Tuple&lt;/code&gt; 위쪽에 의해 주어진 세계 나이의 경계와 인수 유형을 &lt;code&gt;world&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f095f8302e33c7d6757828961774c336ec1955" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; has exactly one possible instance; for example, a struct type with no fields.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 에 정확히 하나의 가능한 인스턴스가 있는지 확인하십시오 . 예를 들어 필드가없는 구조체 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c941aa3f3fab8b12bb7a8d06c55662ccc88bd232" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a concrete type, meaning it could have direct instances (values &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;typeof(x) === T&lt;/code&gt;).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 구체적 유형 인지 여부를 판별하십시오 . 이는 직접적인 인스턴스를 가질 수 있음을 의미합니다 ( &lt;code&gt;typeof(x) === T&lt;/code&gt; 와 같은 값 &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="889b4cea5aec1b8d20d423a69b232b4fd8819ea1" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a tuple &quot;leaf type&quot;, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 튜플 &quot;리프 유형&quot; 인지 여부를 판별하십시오 . 이는 디스패치에서 유형 시그니처로 표시 될 수 있고 호출에 나타날 수있는 하위 유형 (또는 수퍼 유형)이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fa3f743073996b313a25298a5751df1facc9b8ca" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a primitive type (i.e. using the &lt;code&gt;primitive&lt;/code&gt; keyword).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 기본 유형으로 선언 되었는지 여부를 판별하십시오 (예 : &lt;code&gt;primitive&lt;/code&gt; 키워드 사용).</target>
        </trans-unit>
        <trans-unit id="6ee927617e47ab19a9ab3eb7c45e5b0d181e4bde" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a struct type (i.e. using the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;mutable struct&lt;/code&gt; keyword).</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 가 구조체 타입으로 선언 되었는지 ( &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;mutable struct&lt;/code&gt; 키워드 사용) 결정합니다.</target>
        </trans-unit>
        <trans-unit id="def23a2949c492af43c949112c644220edb792b0" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as an abstract type (i.e. using the &lt;code&gt;abstract&lt;/code&gt; keyword).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 추상 유형으로 선언 되었는지 여부를 판별하십시오 (예 : &lt;code&gt;abstract&lt;/code&gt; 키워드 사용).</target>
        </trans-unit>
        <trans-unit id="c539db0242f115c7ed3b7d7b88baedfee34884e5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;a&lt;/code&gt; is a subset of, but not equal to, &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 의 하위 집합 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d032dc0874cd5aa654968e088fbfba6befcfba64" translate="yes" xml:space="preserve">
          <source>Develop your package</source>
          <target state="translated">패키지 개발</target>
        </trans-unit>
        <trans-unit id="a5ecd286faa5677726aa083151af6be4709cf28e" translate="yes" xml:space="preserve">
          <source>Diagonal</source>
          <target state="translated">Diagonal</target>
        </trans-unit>
        <trans-unit id="c8ddb8ebd7c9ec0a8a6949cc24c26e5db1b28da8" translate="yes" xml:space="preserve">
          <source>Diagonal matrix</source>
          <target state="translated">대각선 행렬</target>
        </trans-unit>
        <trans-unit id="fb2b46a0ed907e0e3db008e1bf7296f2fa0ee640" translate="yes" xml:space="preserve">
          <source>Diameter Sign</source>
          <target state="translated">직경 표시</target>
        </trans-unit>
        <trans-unit id="4e77b4c7440f9011313e26852abc6646e08bbb9b" translate="yes" xml:space="preserve">
          <source>Diamond Operator</source>
          <target state="translated">다이아몬드 연산자</target>
        </trans-unit>
        <trans-unit id="cd59a157c959e21a5d8e33ac498a1543408b829b" translate="yes" xml:space="preserve">
          <source>Diamond Shape With A Dot Inside</source>
          <target state="translated">안에 점이있는 다이아몬드 모양</target>
        </trans-unit>
        <trans-unit id="c979f35c2213ac9ce29d392a08f0cd02319be0a8" translate="yes" xml:space="preserve">
          <source>Diamond With Bottom Half Black</source>
          <target state="translated">하단 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="ea9affe495abd6a6b0faedd90651c9dfc7405bbb" translate="yes" xml:space="preserve">
          <source>Diamond With Left Half Black</source>
          <target state="translated">왼쪽 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="d5a38a7e34ff056cfbb328f94dd973e13e1b0f13" translate="yes" xml:space="preserve">
          <source>Diamond With Right Half Black</source>
          <target state="translated">오른쪽 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="17906bab8d1dd54d5285d04d3ccda2d66fc279ee" translate="yes" xml:space="preserve">
          <source>Diamond With Top Half Black</source>
          <target state="translated">상반신 다이아몬드</target>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="51b0613ac049d8459b061ee15aa8ba7ae5794479" translate="yes" xml:space="preserve">
          <source>Dictionaries</source>
          <target state="translated">Dictionaries</target>
        </trans-unit>
        <trans-unit id="226686711adc28abd6b28df88e06bd40f70ef31c" translate="yes" xml:space="preserve">
          <source>Dictionaries may also be created with generators. For example, &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt;.</source>
          <target state="translated">생성기를 사용하여 사전을 만들 수도 있습니다. 예를 들어, &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c2228958df07965c5237ec0fac371cc94b97788" translate="yes" xml:space="preserve">
          <source>Dictionary and set types, or in general anything that depends on the output of a &lt;code&gt;hash(key)&lt;/code&gt; method, are a trickier case. In the common case where the keys are numbers, strings, symbols, ranges, &lt;code&gt;Expr&lt;/code&gt;, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile. However, for a few other key types, such as &lt;code&gt;Function&lt;/code&gt; or &lt;code&gt;DataType&lt;/code&gt; and generic user-defined types where you haven't defined a &lt;code&gt;hash&lt;/code&gt; method, the fallback &lt;code&gt;hash&lt;/code&gt; method depends on the memory address of the object (via its &lt;code&gt;objectid&lt;/code&gt;) and hence may change from run to run. If you have one of these key types, or if you aren't sure, to be safe you can initialize this dictionary from within your &lt;code&gt;__init__&lt;/code&gt; function. Alternatively, you can use the &lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt;&lt;code&gt;IdDict&lt;/code&gt;&lt;/a&gt; dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.</source>
          <target state="translated">사전 및 세트 유형 또는 일반적으로 &lt;code&gt;hash(key)&lt;/code&gt; 메소드 의 출력에 의존 하는 것은 까다로운 경우입니다. 키가 숫자, 문자열, 기호, 범위, &lt;code&gt;Expr&lt;/code&gt; 또는 이러한 유형의 구성 (배열, 튜플, 세트, ​​쌍 등) 인 일반적인 경우에는 사전 컴파일해도 안전합니다. 그러나 &lt;code&gt;Function&lt;/code&gt; 또는 &lt;code&gt;DataType&lt;/code&gt; 과 같은 일부 다른 키 유형 및 &lt;code&gt;hash&lt;/code&gt; 방법을 정의하지 않은 일반 사용자 정의 유형의 경우 대체 &lt;code&gt;hash&lt;/code&gt; 방법은 객체의 메모리 주소 ( &lt;code&gt;objectid&lt;/code&gt; 를 통해)에 따라 다릅니다.) 따라서 달리기마다 바뀔 수 있습니다. 이러한 키 유형 중 하나가 있거나 확실하지 않은 경우 안전을 위해 &lt;code&gt;__init__&lt;/code&gt; 함수 내에서이 사전을 초기화 할 수 있습니다 . 또는 컴파일 타임에 안전하게 초기화 할 수 있도록 사전 컴파일에 의해 특별히 처리되는 &lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt; &lt;code&gt;IdDict&lt;/code&gt; &lt;/a&gt; 사전 유형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dacf1b614fb594526af821a4a2be88604306ed44" translate="yes" xml:space="preserve">
          <source>Dictionary keys can also be tab completed:</source>
          <target state="translated">사전 키도 탭 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="292578b4b7085196841d56350bbddafbc7e6d0bb" translate="yes" xml:space="preserve">
          <source>Die Face-1</source>
          <target state="translated">다이 페이스 -1</target>
        </trans-unit>
        <trans-unit id="cdbec4e00ebdd8c20f5ee4b56ba58057d7e2ec05" translate="yes" xml:space="preserve">
          <source>Die Face-2</source>
          <target state="translated">다이 페이스 -2</target>
        </trans-unit>
        <trans-unit id="d78fd4a1c34901a2159f7a6e530555949f39daa7" translate="yes" xml:space="preserve">
          <source>Die Face-3</source>
          <target state="translated">다이 페이스 -3</target>
        </trans-unit>
        <trans-unit id="1e5a67accc5d5c25093b0a623f892e361241ae52" translate="yes" xml:space="preserve">
          <source>Die Face-4</source>
          <target state="translated">다이 페이스 -4</target>
        </trans-unit>
        <trans-unit id="e4d4e7bdf84edf508b41bc9d8e314d7651a257a0" translate="yes" xml:space="preserve">
          <source>Die Face-5</source>
          <target state="translated">다이 페이스 -5</target>
        </trans-unit>
        <trans-unit id="14e325af88a46d7bc2d653104317a2958dfaba04" translate="yes" xml:space="preserve">
          <source>Die Face-6</source>
          <target state="translated">다이 스페이스 -6</target>
        </trans-unit>
        <trans-unit id="795ba7a0ce5c58cba555b57bd85cef8a4746539c" translate="yes" xml:space="preserve">
          <source>Difference Between</source>
          <target state="translated">차이점</target>
        </trans-unit>
        <trans-unit id="633fcadd9a7c828edcf878f9058272e3b3e9a1b6" translate="yes" xml:space="preserve">
          <source>Difference Between + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Long Solidus 오버레이 결합 / 비 간격 Long 슬래시 오버레이의 차이점</target>
        </trans-unit>
        <trans-unit id="ffeb2f798ecd4de58b7035483cdc6373fe3233be" translate="yes" xml:space="preserve">
          <source>DimensionMismatch</source>
          <target state="translated">DimensionMismatch</target>
        </trans-unit>
        <trans-unit id="2321ae657c8e83f68d4d7ddbffafe794a2164af3" translate="yes" xml:space="preserve">
          <source>Dims</source>
          <target state="translated">Dims</target>
        </trans-unit>
        <trans-unit id="4fb82b30b311a8f2f43ae3e857d3584f2edb16f3" translate="yes" xml:space="preserve">
          <source>Direct Hit</source>
          <target state="translated">직접 명중</target>
        </trans-unit>
        <trans-unit id="7a610c61d6e2df53d7f7028820759b68c9cdf43a" translate="yes" xml:space="preserve">
          <source>Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:</source>
          <target state="translated">표준 산술 및 비교 연산이 합리적인 값에 대해 정의되므로 분자와 분모를 직접 비교할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="39702e75a6cf1386c6592825cf3db26e55cb9c65" translate="yes" xml:space="preserve">
          <source>Direct construction of &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects with value arguments is powerful, but &lt;code&gt;Expr&lt;/code&gt; constructors can be tedious compared to &quot;normal&quot; Julia syntax. As an alternative, Julia allows &lt;em&gt;interpolation&lt;/em&gt; of literals or expressions into quoted expressions. Interpolation is indicated by a prefix &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">값 인수를 사용하여 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 객체를 직접 구성하는 것은 강력하지만 &lt;code&gt;Expr&lt;/code&gt; 생성자는 &quot;일반&quot;Julia 구문에 비해 지루할 수 있습니다. 대안으로 Julia는 리터럴 또는 표현식을 인용 된 표현식으로 &lt;em&gt;보간&lt;/em&gt; 할 수 있습니다 . 보간은 접두사 &lt;code&gt;$&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e859576baf1df468abfbf6259c6df055e40c3865" translate="yes" xml:space="preserve">
          <source>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax as follows:</source>
          <target state="translated">현재 작업에서 함수를 실행하는 동안 Ctrl-C 처리기를 비활성화하여 안전하지 않은 julia 코드를 호출 할 수있는 외부 코드를 호출합니다. 다음과 같이 &lt;code&gt;do&lt;/code&gt; 블록 구문을 사용하여 호출 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee5dfa8ba600cccab503575e49577656d5630d4b" translate="yes" xml:space="preserve">
          <source>Disable all log messages at log levels equal to or less than &lt;code&gt;level&lt;/code&gt;. This is a &lt;em&gt;global&lt;/em&gt; setting, intended to make debug logging extremely cheap when disabled.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 이하의 로그 수준에서 모든 로그 메시지를 비활성화합니다 . 이것은 &lt;em&gt;전역&lt;/em&gt; 설정으로, 비활성화 된 경우 디버그 로깅을 매우 저렴하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f365e08d11c88067711c3e53ea5deda45baac76" translate="yes" xml:space="preserve">
          <source>Disable the GC, return previous state as int</source>
          <target state="translated">GC를 비활성화하고 이전 상태를 int로 반환</target>
        </trans-unit>
        <trans-unit id="3978fd69ff9f5062319ab42f51b05b0aaac345ec" translate="yes" xml:space="preserve">
          <source>Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.</source>
          <target state="translated">가비지 수집을 사용하지 않으면 메모리 사용이 제한없이 커질 수 있으므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="876921bd8b5ab79222657dd5d0af64f5515603c3" translate="yes" xml:space="preserve">
          <source>Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)</source>
          <target state="translated">안전하지 않은 부동 소수점 최적화를 허용하지 않거나 활성화합니다 (@fastmath 선언을 무시 함)</target>
        </trans-unit>
        <trans-unit id="07015f11ed3e9662a9e3d218f4e32dd41d124545" translate="yes" xml:space="preserve">
          <source>Disappointed But Relieved Face</source>
          <target state="translated">실망했지만 안심할 수있는 얼굴</target>
        </trans-unit>
        <trans-unit id="5bd8d20ec17f66810be7ac160730554259c2f393" translate="yes" xml:space="preserve">
          <source>Disappointed Face</source>
          <target state="translated">실망한 얼굴</target>
        </trans-unit>
        <trans-unit id="4818d3085918b897bb5940cbb6aa6b457b2f50f0" translate="yes" xml:space="preserve">
          <source>Discard the &lt;code&gt;payload&lt;/code&gt; credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.</source>
          <target state="translated">향후 인증에 재사용 되는 &lt;code&gt;payload&lt;/code&gt; 자격 증명을 폐기하십시오 . 인증에 실패한 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ebed03f3d4a5ea390c18a91bde6105d1ff3fe5" translate="yes" xml:space="preserve">
          <source>Dispatch on one argument at a time</source>
          <target state="translated">한 번에 하나의 인수 만 전달</target>
        </trans-unit>
        <trans-unit id="8960408fead9aa75ceb4aee4e800ae4451c96002" translate="yes" xml:space="preserve">
          <source>Display equations</source>
          <target state="translated">방정식 표시</target>
        </trans-unit>
        <trans-unit id="1df9a6dc2c17a0ba7bdb95b8c1b94c8fdab3317c" translate="yes" xml:space="preserve">
          <source>Display version information</source>
          <target state="translated">버전 정보 표시</target>
        </trans-unit>
        <trans-unit id="1b44f5625aa08ea5a916469ddb5a30b0fa48b533" translate="yes" xml:space="preserve">
          <source>Distributed Computing</source>
          <target state="translated">분산 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="f252c2edb60c7c9bd29fb3437997c2ebdcdd803a" translate="yes" xml:space="preserve">
          <source>Distributed computing</source>
          <target state="translated">분산 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="75f5d856b9b1768edecb8d197541ee2cc802dc7e" translate="yes" xml:space="preserve">
          <source>Distributed programming in Julia is built on two primitives: &lt;em&gt;remote references&lt;/em&gt; and &lt;em&gt;remote calls&lt;/em&gt;. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.</source>
          <target state="translated">Julia의 분산 프로그래밍은 두 가지 기본 요소 인 &lt;em&gt;원격 참조&lt;/em&gt; 및 &lt;em&gt;원격 호출을 기반으로합니다&lt;/em&gt; . 원격 참조는 모든 프로세스에서 특정 프로세스에 저장된 개체를 참조하는 데 사용할 수있는 개체입니다. 원격 호출은 한 프로세스가 다른 인수 (아마도 동일한) 프로세스의 특정 인수에 대해 특정 함수를 호출하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="96434486b44e8b445920f8cfba7cc682d4dfc2db" translate="yes" xml:space="preserve">
          <source>Distributed.@distributed</source>
          <target state="translated">Distributed.@distributed</target>
        </trans-unit>
        <trans-unit id="1a098ddbdf75655cc9180cdc7b6440448f09568d" translate="yes" xml:space="preserve">
          <source>Distributed.@everywhere</source>
          <target state="translated">Distributed.@everywhere</target>
        </trans-unit>
        <trans-unit id="efbc6617cb7c0815e2ea5d73b544497289152b89" translate="yes" xml:space="preserve">
          <source>Distributed.@fetch</source>
          <target state="translated">Distributed.@fetch</target>
        </trans-unit>
        <trans-unit id="59e5edc22d0bcf1af2630d1052c482cdb408f391" translate="yes" xml:space="preserve">
          <source>Distributed.@fetchfrom</source>
          <target state="translated">Distributed.@fetchfrom</target>
        </trans-unit>
        <trans-unit id="af80c7ed9530f2c7e180576f660e05a18aca79bb" translate="yes" xml:space="preserve">
          <source>Distributed.@spawn</source>
          <target state="translated">Distributed.@spawn</target>
        </trans-unit>
        <trans-unit id="da346ed14fde6d1e8361fba9d749980594b148e9" translate="yes" xml:space="preserve">
          <source>Distributed.@spawnat</source>
          <target state="translated">Distributed.@spawnat</target>
        </trans-unit>
        <trans-unit id="cd85ed1cfd9557c350600fd95dc13b777ce3fe85" translate="yes" xml:space="preserve">
          <source>Distributed.AbstractWorkerPool</source>
          <target state="translated">Distributed.AbstractWorkerPool</target>
        </trans-unit>
        <trans-unit id="36af7ae728088acd59fb1d45bca438f98c665d8c" translate="yes" xml:space="preserve">
          <source>Distributed.CachingPool</source>
          <target state="translated">Distributed.CachingPool</target>
        </trans-unit>
        <trans-unit id="22d34851a0eba645399be62bb28846b66823289e" translate="yes" xml:space="preserve">
          <source>Distributed.ClusterManager</source>
          <target state="translated">Distributed.ClusterManager</target>
        </trans-unit>
        <trans-unit id="b0cd727f1d03d744fc280a981fa5b9190b5153e2" translate="yes" xml:space="preserve">
          <source>Distributed.Future</source>
          <target state="translated">Distributed.Future</target>
        </trans-unit>
        <trans-unit id="ea257e0490c136ba7d3090abaaf36e4a0ca8d1a7" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteChannel</source>
          <target state="translated">Distributed.RemoteChannel</target>
        </trans-unit>
        <trans-unit id="4d0b601e8fedd7c09e5642c005570fc3a0473253" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteException</source>
          <target state="translated">Distributed.RemoteException</target>
        </trans-unit>
        <trans-unit id="c33f096540905e1e5959bf9b4378500ff82ca6f7" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerConfig</source>
          <target state="translated">Distributed.WorkerConfig</target>
        </trans-unit>
        <trans-unit id="8ce81814c48804e7f821d092b3e46ed846c5880d" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerPool</source>
          <target state="translated">Distributed.WorkerPool</target>
        </trans-unit>
        <trans-unit id="164200aa0d1a016ac5f4b6fd50cd6698574608fa" translate="yes" xml:space="preserve">
          <source>Distributed.addprocs()</source>
          <target state="translated">Distributed.addprocs()</target>
        </trans-unit>
        <trans-unit id="173fea4d9a9f7c07219a7da8c1a00ac502393d87" translate="yes" xml:space="preserve">
          <source>Distributed.channel_from_id()</source>
          <target state="translated">Distributed.channel_from_id()</target>
        </trans-unit>
        <trans-unit id="226386f83311a76a8211104c4edb61bcf3c75680" translate="yes" xml:space="preserve">
          <source>Distributed.clear!()</source>
          <target state="translated">Distributed.clear!()</target>
        </trans-unit>
        <trans-unit id="a5baf4d266ab8829135539799e42c9d4c0ead21b" translate="yes" xml:space="preserve">
          <source>Distributed.cluster_cookie()</source>
          <target state="translated">Distributed.cluster_cookie()</target>
        </trans-unit>
        <trans-unit id="dc2fa5e71cd9d9b639010b97b4740edbdbb81f56" translate="yes" xml:space="preserve">
          <source>Distributed.default_worker_pool()</source>
          <target state="translated">Distributed.default_worker_pool()</target>
        </trans-unit>
        <trans-unit id="41cdeb4d12b400fba432add756ae6ef656d520c6" translate="yes" xml:space="preserve">
          <source>Distributed.init_worker()</source>
          <target state="translated">Distributed.init_worker()</target>
        </trans-unit>
        <trans-unit id="869d052c4a2a06e70c0d44a1851f76e2f966103b" translate="yes" xml:space="preserve">
          <source>Distributed.interrupt()</source>
          <target state="translated">Distributed.interrupt()</target>
        </trans-unit>
        <trans-unit id="3ea59996280ad714503bd21db89af3ed0ddb5c84" translate="yes" xml:space="preserve">
          <source>Distributed.launch()</source>
          <target state="translated">Distributed.launch()</target>
        </trans-unit>
        <trans-unit id="e48c1d69b737782cf0cea89c2b07847840fe9c44" translate="yes" xml:space="preserve">
          <source>Distributed.manage()</source>
          <target state="translated">Distributed.manage()</target>
        </trans-unit>
        <trans-unit id="05a5ebfc426c1bd80394e5bf665a5fda064e34c4" translate="yes" xml:space="preserve">
          <source>Distributed.myid()</source>
          <target state="translated">Distributed.myid()</target>
        </trans-unit>
        <trans-unit id="1fdb70cf3ecb7a0aa097a69946d096f32726c49e" translate="yes" xml:space="preserve">
          <source>Distributed.nprocs()</source>
          <target state="translated">Distributed.nprocs()</target>
        </trans-unit>
        <trans-unit id="394af0754f2238a05c08dd8f6b6874db18b285c7" translate="yes" xml:space="preserve">
          <source>Distributed.nworkers()</source>
          <target state="translated">Distributed.nworkers()</target>
        </trans-unit>
        <trans-unit id="b85b64151cf4f4ae19fb8cf053b4d77736d64609" translate="yes" xml:space="preserve">
          <source>Distributed.pmap()</source>
          <target state="translated">Distributed.pmap()</target>
        </trans-unit>
        <trans-unit id="f379e8118bd0a8163fb093113934cf152437fe6b" translate="yes" xml:space="preserve">
          <source>Distributed.process_messages()</source>
          <target state="translated">Distributed.process_messages()</target>
        </trans-unit>
        <trans-unit id="c462fb87629ce04f2ef477ae483ec589605d65cb" translate="yes" xml:space="preserve">
          <source>Distributed.procs()</source>
          <target state="translated">Distributed.procs()</target>
        </trans-unit>
        <trans-unit id="328c4408c15f7286da8f5406178cc12a69c58b5c" translate="yes" xml:space="preserve">
          <source>Distributed.remote()</source>
          <target state="translated">Distributed.remote()</target>
        </trans-unit>
        <trans-unit id="7dd1a0dd0aaef1f1d7ae03091ad26ce2253cd598" translate="yes" xml:space="preserve">
          <source>Distributed.remote_do()</source>
          <target state="translated">Distributed.remote_do()</target>
        </trans-unit>
        <trans-unit id="9fb42670c69fd280316f8b2f0ea16afea4c810c9" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall()</source>
          <target state="translated">Distributed.remotecall()</target>
        </trans-unit>
        <trans-unit id="a67cc8bf59dc3c96f9aef1e9811c3479c8b46371" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_fetch()</source>
          <target state="translated">Distributed.remotecall_fetch()</target>
        </trans-unit>
        <trans-unit id="4dc4a66df6faa8cff424bd89060037bf46df26cd" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_wait()</source>
          <target state="translated">Distributed.remotecall_wait()</target>
        </trans-unit>
        <trans-unit id="eba77344fe6aa6904b303120e58ddda491f4bb1a" translate="yes" xml:space="preserve">
          <source>Distributed.remoteref_id()</source>
          <target state="translated">Distributed.remoteref_id()</target>
        </trans-unit>
        <trans-unit id="6313c54bbc81e913c52e3ed8676831966128d19d" translate="yes" xml:space="preserve">
          <source>Distributed.rmprocs()</source>
          <target state="translated">Distributed.rmprocs()</target>
        </trans-unit>
        <trans-unit id="a4a167c1c83070eb12b10d5a804750df20f010d6" translate="yes" xml:space="preserve">
          <source>Distributed.start_worker()</source>
          <target state="translated">Distributed.start_worker()</target>
        </trans-unit>
        <trans-unit id="2c121b43490b3f755d6bc8ec22e6e6d7a5a177c3" translate="yes" xml:space="preserve">
          <source>Distributed.worker_id_from_socket()</source>
          <target state="translated">Distributed.worker_id_from_socket()</target>
        </trans-unit>
        <trans-unit id="b65a1ff0a0efeb8eb1c566e4e444c8fdab89ba3a" translate="yes" xml:space="preserve">
          <source>Distributed.workers()</source>
          <target state="translated">Distributed.workers()</target>
        </trans-unit>
        <trans-unit id="01f3300548243049d963e19250b86a197066f883" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;A&lt;/code&gt; by a scalar &lt;code&gt;b&lt;/code&gt; overwriting &lt;code&gt;A&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt;&lt;code&gt;ldiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from left.</source>
          <target state="translated">어레이의 각 엔트리 나눈다 스칼라 &lt;code&gt;b&lt;/code&gt; 덮어 &lt;code&gt;A&lt;/code&gt; 현재 위치에서를. &lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt; &lt;code&gt;ldiv!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 스칼라를 왼쪽에서 나누려면 &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c5227a4411a33c2b0a2917ac123771fc4d90473" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;B&lt;/code&gt; by a scalar &lt;code&gt;a&lt;/code&gt; overwriting &lt;code&gt;B&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt;&lt;code&gt;rdiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from right.</source>
          <target state="translated">어레이의 각 엔트리 나눈다 &lt;code&gt;B&lt;/code&gt; 스칼라 덮어 &lt;code&gt;B&lt;/code&gt; 인 곳. &lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt; &lt;code&gt;rdiv!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 스칼라를 오른쪽에서 나누기 위해. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="161ea982f22680e7ef2021310dae639abf1326db" translate="yes" xml:space="preserve">
          <source>Divide two integers or rational numbers, giving a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; result.</source>
          <target state="translated">주고, 두 개의 정수 나 유리수를 분할 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7ad94500626afb00127de3b189a93eaca8744de4" translate="yes" xml:space="preserve">
          <source>Divides</source>
          <target state="translated">Divides</target>
        </trans-unit>
        <trans-unit id="e2b8ca950fd114a793b53e8c5e48ea524b845d7d" translate="yes" xml:space="preserve">
          <source>Division Sign</source>
          <target state="translated">구분 표시</target>
        </trans-unit>
        <trans-unit id="361a7f8376269b5b650c0bf43907fe05e5712a64" translate="yes" xml:space="preserve">
          <source>Division Times</source>
          <target state="translated">디비전 타임즈</target>
        </trans-unit>
        <trans-unit id="5b52981f5797afbc7daabde2522293d6f287e47f" translate="yes" xml:space="preserve">
          <source>Division errors</source>
          <target state="translated">사단 오류</target>
        </trans-unit>
        <trans-unit id="036fd78d0d2fb9786e807e79b9ec1fe9b9f0ab1d" translate="yes" xml:space="preserve">
          <source>Division functions</source>
          <target state="translated">구분 기능</target>
        </trans-unit>
        <trans-unit id="71beaa328c19038dd8d3afa0450399489fcfa5bb" translate="yes" xml:space="preserve">
          <source>Dizzy Face</source>
          <target state="translated">현기증 얼굴</target>
        </trans-unit>
        <trans-unit id="271c431f3d459dae90731776142efcc9efba3a41" translate="yes" xml:space="preserve">
          <source>Dizzy Symbol</source>
          <target state="translated">현기증</target>
        </trans-unit>
        <trans-unit id="a72324023e9231ddd2559ff9084345bc66092df6" translate="yes" xml:space="preserve">
          <source>Do I want to use a release, beta, or nightly version of Julia?</source>
          <target state="translated">Julia의 릴리스, 베타 또는 야간 버전을 사용하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="177063caa465e3c01afe5bd0f45d14afb04f44d4" translate="yes" xml:space="preserve">
          <source>Do I want to use the Stable, LTS, or nightly version of Julia?</source>
          <target state="translated">Stable, LTS 또는 야간 버전의 Julia를 사용하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="3db8faa5c93df04fc1f4cad1a3ef3da7ae3d5746" translate="yes" xml:space="preserve">
          <source>Do Not Litter Symbol</source>
          <target state="translated">쓰레기를 버리지 마십시오</target>
        </trans-unit>
        <trans-unit id="89ad2cd843ab0ac775fb58a33130e35a9ebce093" translate="yes" xml:space="preserve">
          <source>Do any final processing necessary for the given testset. This is called by the &lt;code&gt;@testset&lt;/code&gt; infrastructure after a test block executes. One common use for this function is to record the testset to the parent's results list, using &lt;code&gt;get_testset&lt;/code&gt;.</source>
          <target state="translated">주어진 테스트 세트에 필요한 최종 처리를 수행하십시오. 이것은 테스트 블록이 실행 된 후 &lt;code&gt;@testset&lt;/code&gt; 인프라에 의해 호출됩니다 . 이 함수의 일반적인 용도 중 하나는 get_testset을 사용하여 &lt;code&gt;get_testset&lt;/code&gt; 세트를 부모의 결과 목록에 기록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="97fbb621c645ddfec0a076ad4bcef012b8a293b3" translate="yes" xml:space="preserve">
          <source>Do not call this on a handle that's already owned by some other part of the system.</source>
          <target state="translated">시스템의 다른 부분에서 이미 소유 한 핸들에서는 이것을 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5c71b02f0c824517c5e8eef286d8968d841fb69a" translate="yes" xml:space="preserve">
          <source>Do not repeat yourself.</source>
          <target state="translated">반복하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d599d6549afb353871b063d385c2f5bb866c837d" translate="yes" xml:space="preserve">
          <source>Do not write &lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt; 쓰지 마십시오</target>
        </trans-unit>
        <trans-unit id="92d896974fd993f8e2ce0773bf383e98442586f1" translate="yes" xml:space="preserve">
          <source>Do you see that &lt;code&gt;global&lt;/code&gt; annotation in there? Hideous. Obviously this situation could not be tolerated. But seriously, there are two main issues with requiring &lt;code&gt;global&lt;/code&gt; for this kind of top-level code:</source>
          <target state="translated">당신은 볼 수 있습니까 &lt;code&gt;global&lt;/code&gt; 거기에 주석을? 끔찍하다. 분명히이 상황은 용납 될 수 없습니다. 그러나 진지하게, 이러한 종류의 최상위 코드에 대해 &lt;code&gt;global&lt;/code&gt; 을 요구하는 데는 두 가지 주요 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93ac681d8ce5c9e419103f5e01e286f7a37841c" translate="yes" xml:space="preserve">
          <source>Do-Block Syntax for Function Arguments</source>
          <target state="translated">함수 인수를위한 Do-Block 구문</target>
        </trans-unit>
        <trans-unit id="68a4194227be4ab74bc3d32363417c0fc1f30055" translate="yes" xml:space="preserve">
          <source>Docs</source>
          <target state="translated">Docs</target>
        </trans-unit>
        <trans-unit id="951ee5040959da5427656e41d49e8acd4aff75ee" translate="yes" xml:space="preserve">
          <source>Docs.@html_str</source>
          <target state="translated">Docs.@html_str</target>
        </trans-unit>
        <trans-unit id="94211649e4d7dde7192ce3db00bbee03bb4c3e61" translate="yes" xml:space="preserve">
          <source>Docs.@text_str</source>
          <target state="translated">Docs.@text_str</target>
        </trans-unit>
        <trans-unit id="f065f6fa6c71fdad19f0dcd2a0e82257bad77265" translate="yes" xml:space="preserve">
          <source>Docs.apropos()</source>
          <target state="translated">Docs.apropos()</target>
        </trans-unit>
        <trans-unit id="723c13f6eed0956ec36bf5aa24f80dc095fc1a62" translate="yes" xml:space="preserve">
          <source>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is advised to add line breaks after 92 characters.</source>
          <target state="translated">문서 문자열은 코드와 동일한 도구를 사용하여 편집됩니다. 따라서 동일한 규칙이 적용되어야합니다. 92 자 뒤에 줄 바꿈을 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e776eddce7eaaeece43c53e417a63fdb2d0645c4" translate="yes" xml:space="preserve">
          <source>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is recommended that lines are at most 92 characters wide.</source>
          <target state="translated">독 스트링은 코드와 동일한 도구를 사용하여 편집됩니다. 따라서 동일한 규칙이 적용되어야합니다. 줄 너비는 최대 92자인 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e741da5c63f67a2059af6310cbefc21c3af104c4" translate="yes" xml:space="preserve">
          <source>Doctests are enabled by &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;&lt;code&gt;Documenter.jl&lt;/code&gt;&lt;/a&gt;. For more detailed documentation see Documenter's &lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Doctest는 &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt; &lt;code&gt;Documenter.jl&lt;/code&gt; 에&lt;/a&gt; 의해 활성화됩니다 . 자세한 내용은 Documenter 's &lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;manual을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="1e2dea0c3337740d3f32a466769f4f1557f19738" translate="yes" xml:space="preserve">
          <source>Documentation can be accessed at the REPL or in &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; by typing &lt;code&gt;?&lt;/code&gt; followed by the name of a function or macro, and pressing &lt;code&gt;Enter&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 입력하여 REPL 또는 &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; 에서 문서에 액세스 할 수 있습니다 . 함수 또는 매크로 이름 다음에 &lt;code&gt;Enter&lt;/code&gt; 키 를 누릅니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="82b208253644825d49a694f47eb50e7748d27ea9" translate="yes" xml:space="preserve">
          <source>Documentation is interpreted as &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the &lt;code&gt;@doc&lt;/code&gt; macro just as well.</source>
          <target state="translated">문서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt; 으로 해석 되므로 들여 쓰기 및 코드 펜스를 사용하여 코드 예제를 텍스트에서 구분할 수 있습니다. 기술적으로 모든 객체는 메타 데이터로 다른 객체와 연관 될 수 있습니다. Markdown이 기본값이지만 다른 문자열 매크로를 구성하여 &lt;code&gt;@doc&lt;/code&gt; 매크로에도 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29764eb22ce628960d24b7b3d44fcb0f2a8006f" translate="yes" xml:space="preserve">
          <source>Documentation written in non-toplevel blocks, such as &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt;, is added to the documentation system as blocks are evaluated. For example:</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 과 같은 최상위가 아닌 블록으로 작성된 문서는 블록이 평가 될 때 문서 시스템에 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09a6ee5d426664cb977432c68132607a67141e74" translate="yes" xml:space="preserve">
          <source>Documenting a &lt;code&gt;baremodule&lt;/code&gt; by placing a docstring above the expression automatically imports &lt;code&gt;@doc&lt;/code&gt; into the module. These imports must be done manually when the module expression is not documented. Empty &lt;code&gt;baremodule&lt;/code&gt;s cannot be documented.</source>
          <target state="translated">문서화 &lt;code&gt;baremodule&lt;/code&gt; 을 발현 참조 문 위에 배치함으로써 자동으로 가져 &lt;code&gt;@doc&lt;/code&gt; 를 모듈로. 이러한 가져 오기는 모듈 표현식이 문서화되지 않은 경우 수동으로 수행해야합니다. 비어있는 &lt;code&gt;baremodule&lt;/code&gt; 문서화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1c8feebb8a44bc5cc0f0c846a0cafe1673c9da0" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Member</source>
          <target state="translated">회원으로 포함되지 않음</target>
        </trans-unit>
        <trans-unit id="74e9b7a7bc4ad3a9d5021e1c8ba39f60a57b9c8c" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup</source>
          <target state="translated">일반 하위 그룹으로 포함되지 않음</target>
        </trans-unit>
        <trans-unit id="0df9d21ab128eedeaeee897e18031c8a630062be" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup Or Equal</source>
          <target state="translated">정상적인 하위 그룹으로 포함되지 않거나 동일하지 않음</target>
        </trans-unit>
        <trans-unit id="721845ae9c87c5bd1e7a959be4a879539ccf8539" translate="yes" xml:space="preserve">
          <source>Does Not Divide</source>
          <target state="translated">나누지 않는다</target>
        </trans-unit>
        <trans-unit id="c17ae6741920f232f1c4dcd981a0894fd4701fd6" translate="yes" xml:space="preserve">
          <source>Does Not Force</source>
          <target state="translated">강제하지 않습니다</target>
        </trans-unit>
        <trans-unit id="dc76e22dd1ef5959f4590996c3e850e4ccf3c6d5" translate="yes" xml:space="preserve">
          <source>Does Not Precede</source>
          <target state="translated">선행하지 않는다</target>
        </trans-unit>
        <trans-unit id="4431ed14e25542ca1903fbe4b11f8f7bc472370c" translate="yes" xml:space="preserve">
          <source>Does Not Precede Or Equal</source>
          <target state="translated">선행하거나 같지 않음</target>
        </trans-unit>
        <trans-unit id="91186e108fed6b3b33f14387bc2f31c57be5dd04" translate="yes" xml:space="preserve">
          <source>Does Not Prove</source>
          <target state="translated">증명하지 않는다</target>
        </trans-unit>
        <trans-unit id="55e9fb335c67326e83c89cc57e089d55541e089b" translate="yes" xml:space="preserve">
          <source>Does Not Succeed</source>
          <target state="translated">성공하지 못함</target>
        </trans-unit>
        <trans-unit id="864c65788d1e762c167b1c1749d733189def96f8" translate="yes" xml:space="preserve">
          <source>Does Not Succeed Or Equal</source>
          <target state="translated">성공하거나 같지 않다</target>
        </trans-unit>
        <trans-unit id="b866865be01a47a38a8b8e70d9eeb4d216a5889b" translate="yes" xml:space="preserve">
          <source>Dog</source>
          <target state="translated">Dog</target>
        </trans-unit>
        <trans-unit id="822ff2e44dfcb5851a482f2660f9271d7240e881" translate="yes" xml:space="preserve">
          <source>Dog Face</source>
          <target state="translated">강아지 얼굴</target>
        </trans-unit>
        <trans-unit id="b352a36f62c29eefc7c223c1e54b444dc8e064a4" translate="yes" xml:space="preserve">
          <source>Dolphin</source>
          <target state="translated">Dolphin</target>
        </trans-unit>
        <trans-unit id="dc77173b84d82a0765230e0c6ba75588bedb585c" translate="yes" xml:space="preserve">
          <source>Don't expose unsafe operations at the interface level</source>
          <target state="translated">인터페이스 수준에서 안전하지 않은 작업을 노출하지 마십시오</target>
        </trans-unit>
        <trans-unit id="c4688105e50f89983dad6151436e12d874f53866" translate="yes" xml:space="preserve">
          <source>Don't overload methods of base container types</source>
          <target state="translated">기본 컨테이너 유형의 메소드를 오버로드하지 마십시오</target>
        </trans-unit>
        <trans-unit id="62d0b49edcf8320dfc997b5ca5fb5ff7268edc1a" translate="yes" xml:space="preserve">
          <source>Don't overuse &lt;code&gt;...&lt;/code&gt;</source>
          <target state="translated">남용하지 마십시오 &lt;code&gt;...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1789c363ea41e44595afb63415ed7c18193fd84" translate="yes" xml:space="preserve">
          <source>Don't overuse macros</source>
          <target state="translated">매크로를 과도하게 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="a3e15a90504e4d80a1ded72545703d3f5a6fc9a2" translate="yes" xml:space="preserve">
          <source>Don't overuse try-catch</source>
          <target state="translated">try-catch를 과도하게 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="215b5f92cd2b36c13430ff90f6606631f634f2bc" translate="yes" xml:space="preserve">
          <source>Don't parenthesize conditions</source>
          <target state="translated">조건을 괄호로 묶지 마십시오</target>
        </trans-unit>
        <trans-unit id="2036ef4184745cfc73dab730959249e97cb41653" translate="yes" xml:space="preserve">
          <source>Don't use unnecessary static parameters</source>
          <target state="translated">불필요한 정적 매개 변수를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="478d47b06dda44ac540199c073ea7b055bb29d18" translate="yes" xml:space="preserve">
          <source>Door</source>
          <target state="translated">Door</target>
        </trans-unit>
        <trans-unit id="ddd653c95e261e24af6fe24fd7e994e1b732c61e" translate="yes" xml:space="preserve">
          <source>Dot Minus</source>
          <target state="translated">도트 마이너스</target>
        </trans-unit>
        <trans-unit id="da4c9b7a4607f6acdefd66aa7034f05ebdd357f8" translate="yes" xml:space="preserve">
          <source>Dot Operator</source>
          <target state="translated">도트 연산자</target>
        </trans-unit>
        <trans-unit id="e46bcabadc79a669ff9fab524e27e4536bcce723" translate="yes" xml:space="preserve">
          <source>Dot Plus</source>
          <target state="translated">도트 플러스</target>
        </trans-unit>
        <trans-unit id="1e0712c9faa91162cb0a7e3519494eabc42057de" translate="yes" xml:space="preserve">
          <source>Dot Syntax for Vectorizing Functions</source>
          <target state="translated">벡터화 함수를위한 도트 구문</target>
        </trans-unit>
        <trans-unit id="8ec4c1c9e271c057f7f2ceb82454ca0b4248d7e0" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;.</source>
          <target state="translated">이루어진 개의 복소 벡터의 도트 함수 &lt;code&gt;n&lt;/code&gt; 어레이의 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드와 &lt;code&gt;incx&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;Y&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6408bc206b479d599e65eaa3c639906fa5347eee" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors, consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;U&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;, conjugating the first vector.</source>
          <target state="translated">두 개의 복소 벡터의 도트 함수로 이루어진 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드와 &lt;code&gt;incx&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;U&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; 상기 제 1 벡터 공역.</target>
        </trans-unit>
        <trans-unit id="822ddf4ed45b75296e27e23d4dd969f4b0e252cc" translate="yes" xml:space="preserve">
          <source>Dot product of two vectors consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;.</source>
          <target state="translated">이루어진 두 벡터의 내적 &lt;code&gt;n&lt;/code&gt; 배열의 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드와 &lt;code&gt;incx&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;Y&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae687eeec34004bd7083ef738bcbb2dfd35f355d" translate="yes" xml:space="preserve">
          <source>Dotted Circle</source>
          <target state="translated">점선 원</target>
        </trans-unit>
        <trans-unit id="9214357a4af6ad858e4d42896c3023c43dce64c9" translate="yes" xml:space="preserve">
          <source>Dotted Fence</source>
          <target state="translated">점선 울타리</target>
        </trans-unit>
        <trans-unit id="b81c82773994373a1d09d7aae50399f0672d3ba9" translate="yes" xml:space="preserve">
          <source>Dotted Square</source>
          <target state="translated">점선 사각형</target>
        </trans-unit>
        <trans-unit id="90b6dc25270ca8eeeb19a2a120979959174221d5" translate="yes" xml:space="preserve">
          <source>Double Colon Equal</source>
          <target state="translated">더블 콜론</target>
        </trans-unit>
        <trans-unit id="a97175043bff5b5c88676e311e52a67c0ae1d95b" translate="yes" xml:space="preserve">
          <source>Double Curly Loop</source>
          <target state="translated">더블 컬리 루프</target>
        </trans-unit>
        <trans-unit id="ce6ed1da949d6a90c7025acd0315d2ec7e76fdf2" translate="yes" xml:space="preserve">
          <source>Double Dagger</source>
          <target state="translated">더블 단검</target>
        </trans-unit>
        <trans-unit id="3ebfb9a6d6fb0aa10351fcdd8ebc9f2ad2e8e0b0" translate="yes" xml:space="preserve">
          <source>Double Exclamation Mark</source>
          <target state="translated">느낌표</target>
        </trans-unit>
        <trans-unit id="7206e7e84b3ec15528c9043d5518fb76c3d3b663" translate="yes" xml:space="preserve">
          <source>Double Integral</source>
          <target state="translated">이중 적분</target>
        </trans-unit>
        <trans-unit id="2f4ad5067d03e83537e91298699b3a861f6334a3" translate="yes" xml:space="preserve">
          <source>Double Intersection</source>
          <target state="translated">이중 교차점</target>
        </trans-unit>
        <trans-unit id="f63efa914d18f07e57920324f154194f8b80e71d" translate="yes" xml:space="preserve">
          <source>Double Logical And</source>
          <target state="translated">이중 논리 및</target>
        </trans-unit>
        <trans-unit id="31d51825a917859490089a0f53f017ee347ae47e" translate="yes" xml:space="preserve">
          <source>Double Logical Or</source>
          <target state="translated">이중 논리 또는</target>
        </trans-unit>
        <trans-unit id="54ca4b3ab79a1f77836fc85afeeb3989b5791f4d" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than</source>
          <target state="translated">이중 중첩 큰 탄</target>
        </trans-unit>
        <trans-unit id="2dc2bf0b85cbb2ea7223a1949ab5e752de1aa1c3" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">이중 중첩 큰 탄 + 긴 고 상선 오버레이 / 비 간격 긴 슬래시 ​​오버레이</target>
        </trans-unit>
        <trans-unit id="aacb83632e682c3968d8b1ac37c74e451e5d43cb" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than</source>
          <target state="translated">이중 중첩 미만</target>
        </trans-unit>
        <trans-unit id="f99a04065879ed38c5083c8327002d7fd1bdcc2e" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">더블 네스트리스 타인 + 긴 고형 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
