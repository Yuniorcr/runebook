<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">더블 라인 이상보다 큼</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">위의 것보다 위의 것</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">비슷하거나 동등 이상</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">경사 이상 동일 이상 경사 이상 동일 이상</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">크거나 같지 않음</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">보다 크고 단선이 같지 않음</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">적은 것보다 큰 것</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음 + 변형 선택기 -1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">곡선으로 닫힌 것보다</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">경사가 같을 때 곡선으로 닫힌 것보다 큼</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">크거나 같거나 작거나 같거나 크거나 같음</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">더 크거나 대략</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">보다 크거나 같거나보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">보다 크거나 같거나보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">보다 크거나 작거나 / 크거나 작음</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">더 길거나 기울어 짐 같음 + 긴 고 상선 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">위의 점과 같거나 크게 기울어 짐</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">왼쪽 위의 점과 같거나 더 크거나 기울어 짐</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">점 내부와 같거나 더 크거나 기울어 짐</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">같거나보다 큼 /보다 같음</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">겹치는 것보다 큼 겹치는 것</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">안에 동그라미와 큰</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">도트보다 큼 / 도트보다 큼</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">위의 물음표와 함께</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">비교 연산자보다 큼 로 하강 백 &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">같거나 큰 비교 연산자 폴스에 다시 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">가장 큰 공통 (양수) 제수 (또는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 0 인 경우 0)</target>
        </trans-unit>
        <trans-unit id="b3c118d12ee713605454a73fa83e73fd62da99f2" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero). The arguments may be integer and rational numbers.</source>
          <target state="translated">최대 공약수 (양수) (또는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 0 인 경우 0). 인수는 정수 및 유리수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">그리스 베타 기호 / 그리스 소문자 웅크 리고 베타</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">그리스 대문자 알파</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">그리스 대문자 베타</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">그리스어 대문자 Chi</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">그리스 대문자 델타</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">그리스 대문자 엡실론</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">그리스 대문자 Eta</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">그리스 대문자 감마</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">그리스 대문자 Iota</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">그리스 대문자 Kappa</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">그리스 대문자 람다 / 그리스 대문자 람다</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">그리스 대문자 Mu</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">그리스 대문자 Nu</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">그리스 대문자 오메가</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">그리스 대문자 Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">그리스 대문자 Phi</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">그리스 대문자 Pi</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">그리스 대문자 Psi</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">그리스 대문자 Rho</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">그리스 대문자 Sigma</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">그리스 대문자 타우</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">그리스 대문자 Theta</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">그리스 대문자 Upsilon</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">그리스 대문자 Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">그리스 대문자 Zeta</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">그리스 수도 세타 기호</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">그리스 카파 기호 / 그리스 소문자 스크립트 카파</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">그리스 문자 고풍 코파</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">그리스 문자 디 감마 / 그리스 대문자 Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">그리스 문자 Koppa / 그리스 대문자 Koppa</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">그리스 문자 삼피 / 그리스 대문자 삼피</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">그리스 문자 낙인 / 그리스 문자 낙인</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">그리스 Lunate Epsilon 기호</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">그리스어 파이 기호 / 그리스어 소문자 스크립트 피</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">그리스어 파이 기호 / 그리스어 소문자 오메가 파이</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">그리스어 반전 된 Lunate Epsilon 기호</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">그리스 Rho 기호 / 그리스 소문자 꼬리 Rho</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">그리스어 소문자 알파</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">그리스어 소문자 고풍 코파</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">그리스어 소문자 베타</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">그리스어 소문자 Chi</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">그리스어 소문자 델타</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">그리스어 소문자 디 감마</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">그리스어 소문자 엡실론</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">그리스어 소문자 Eta</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">그리스어 소문자 최종 시그마</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">그리스어 소문자 감마</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">그리스어 소문자 이오타</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">그리스어 소문자 카파</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">그리스어 소문자 코파</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">그리스어 소문자 람다 / 그리스어 소문자 람다</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">그리스어 소문자 Mu</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">그리스어 소문자 Nu</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">그리스어 소문자 오메가</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">그리스어 소문자 오 미크론</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">그리스어 소문자 피</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">그리스어 소문자 Pi</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">그리스어 소문자 Psi</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">그리스어 소문자 Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">그리스어 소문자 삼피</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">그리스어 소문자 시그마</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">그리스어 소문자 오명</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">그리스어 소문자 타우</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">그리스어 소문자 세타</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">그리스어 소문자 Upsilon</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">그리스어 소문자 Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">그리스어 소문자 제타</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">그리스 첨자 소문자 베타</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">그리스 첨자 소문자 치</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">그리스 첨자 소문자 감마</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">그리스 첨자 소문자 피</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">그리스 첨자 소문자 Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">그리스어 세타 기호 / 그리스어 소문자 스크립트 세타</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">그린 애플</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">그린 북</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">그린 하트</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">찡그린 얼굴</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">웃는 눈으로 웃기만 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">웃기는 얼굴</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">웃는 눈으로 웃는 얼굴</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">성장하는 마음</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">원자 태그없이 추가를 시도한 경우 경쟁 조건으로 인해 잘못된 답변을 얻었을 수 있습니다. 우리가 경주를 피하지 않으면 어떻게 될지에 대한 예 :</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">헤어 스페이스</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">반 정밀도 부동 소수점 숫자도 지원 되지만 ( &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; ), 소프트웨어로 구현되며 계산에 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">햄스터 얼굴</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">로그 이벤트 처리</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">발신자의 과도한 인수 다양성 처리</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">운영 체제 변형 처리</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">한 손을 올리는 행복한 사람</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">부화 병아리</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">들리지 않는 원숭이</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">하트 장식</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">화살표와 하트</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">리본 하트</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">헤비 블랙 하트</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">무거운 확인 표시</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">무거운 사단 표시</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">무거운 달러 기호</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">느낌표 기호</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">헤비 라지 서클</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">빼기 기호</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">곱셈 곱셈 X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">더하기 부호</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">눈물 방울로 찌른 별표</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">도움말 모드</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">줄 시작 부분에서 백 스페이스 키를 누르면 도움말 모드를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">여기서 &quot;인라인&quot;은 텍스트 블록, 즉 단락에서 찾을 수있는 요소를 나타냅니다. 여기에는 다음 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">Julia가 줄 바꿈을 읽을 수 있도록 Enter 키를 다시 누릅니다. 이제이 예제에서 볼 수 있듯이 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 는 두 번째 인수로 쓸 데이터를 가져 오는 반면 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 는 두 번째 인수로 읽을 데이터 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">다음은 어떤 유형의 배열이 연결되어 있고 그렇지 않은지를 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">비트 연산자를 사용한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">다음은 산술 연산자를 사용하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">Julia와 효율적으로 작업하기위한 몇 가지 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">여기에서 각 반복 은 모든 프로세스 &lt;code&gt;a&lt;/code&gt; 공유 하는 벡터에서 무작위로 선택된 샘플에 &lt;code&gt;f&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">다음은 사전으로 표시되는 해당 루트 구조입니다.</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">다음은 여전히 ​​Markdown을 사용하는 더 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">여기에 예상되는 동작이 반드시 명확하지 않다하는 관련 사례는 다음과 같습니다 어떤 일이 발생하면 우리 라운드 근처에 &lt;code&gt;P(2)&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 A는 &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 유형은? 경우에 따라 (특히 &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ) 대답은 명확합니다.</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">다음은 로컬 파일 시스템을 검색 한 후 종속성 그래프에 대해 위에서 제공된 Manifest에 제공된 예제 &lt;code&gt;App&lt;/code&gt; 프로젝트 환경에 대한 가능한 경로 맵을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">다음은 해당 소멸자를 감싸는 두 번째 예입니다.</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">다음은 &lt;code&gt;Ptr&lt;/code&gt; 유형 을 반환하는 C 래퍼의 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">다음은 Julia의 &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt; 매크로에 대한 간단한 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="ac903f23df192b2cec33704052829cedd04df512" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named &quot;libc&quot;. In practice, this function is usually part of the C standard library, and so the &quot;libc&quot; portion should be omitted, but we wish to show here the usage of this syntax.</source>
          <target state="translated">다음은 로컬 머신의 호스트 이름을 발견하는 약간 더 복잡한 예입니다. 이 예에서 네트워킹 라이브러리 코드는 &quot;libc&quot;라는 공유 라이브러리에 있다고 가정합니다. 실제로이 함수는 일반적으로 C 표준 라이브러리의 일부이므로 &quot;libc&quot;부분은 생략해야하지만 여기서는이 구문의 사용법을 보여 드리고자합니다.</target>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">다음은 로컬 머신의 호스트 이름을 발견하는 약간 더 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">다음은 Julia 배열을 전달하는 세 번째 예입니다.</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">보다 복잡한 다단계 생산자-소비자 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">다음은 실제로 여러 정의로 작성해야하는 &quot;복합 함수&quot;의 예입니다.</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">다음은 세 종류의 마크 업이 모두 포함 된 예입니다. 이 프로그램은 먼저 1 차원 배열의 유한 차이를 계산 한 다음 결과의 L2- 노름을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">&lt;code&gt;@inbounds&lt;/code&gt; 와 &lt;code&gt;@simd&lt;/code&gt; 마크 업 이 모두 포함 된 예는 다음과 같습니다 (여기서 &lt;code&gt;@noinline&lt;/code&gt; 을 사용하여 옵티마이 저가 너무 영리 해 벤치 마크를 해제하지 못하도록 방지합니다).</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">다음은 매우 간단한 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;AbstractArray&lt;/code&gt; 의 임의 하위 유형의 요소 유형 &lt;code&gt;T&lt;/code&gt; 를 리턴하기위한 올바른 코드 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">사전으로 표시되는 해당 그래프 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">여기서 &lt;code&gt;Parent&lt;/code&gt; 모듈 에는 &lt;code&gt;Utils&lt;/code&gt; 하위 모듈이 포함되어 있으며 &lt;code&gt;Parent&lt;/code&gt; 코드 는 &lt;code&gt;Utils&lt;/code&gt; 의 내용을 표시 하려고합니다 . 마침표로 &lt;code&gt;using&lt;/code&gt; 경로를 시작하면 됩니다 . 선행 기간을 더 추가하면 모듈 계층에서 추가 레벨이 올라갑니다. 예를 들어 &lt;code&gt;using ..Utils&lt;/code&gt; 를 사용하면 &lt;code&gt;Parent&lt;/code&gt; 자체가 아닌 &lt;code&gt;Parent&lt;/code&gt; 의 엔 클로징 모듈 에서 &lt;code&gt;Utils&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">여기서 &lt;code&gt;1:5&lt;/code&gt; 는 숫자 1, 2, 3, 4, 5의 시퀀스를 나타내는 범위 객체입니다. &lt;code&gt;for&lt;/code&gt; 루프는 이러한 값을 반복하여 각 값을 차례로 변수 &lt;code&gt;i&lt;/code&gt; 에 할당합니다 . 이전 &lt;code&gt;while&lt;/code&gt; 루프 양식과 &lt;code&gt;for&lt;/code&gt; 루프 양식 사이의 중요한 차이점 중 하나 는 변수가 표시되는 범위입니다. 가변 경우 &lt;code&gt;i&lt;/code&gt; 에 다른 범위에서 도입되지 않은 &lt;code&gt;for&lt;/code&gt; 루프 형태로, 단지 내부의 볼 &lt;code&gt;for&lt;/code&gt; 루프가 아닌 외부 / 후. 이를 테스트하려면 새로운 대화식 세션 인스턴스 또는 다른 변수 이름이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">여기서 &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; 호출 은 &lt;code&gt;g(Float64, Any)&lt;/code&gt; 또는 &lt;code&gt;g(Any, Float64)&lt;/code&gt; 방법 으로 처리 할 수 ​​있으며 다른 방법보다 더 구체적이지 않습니다. 이러한 경우 Julia 는 임의로 메소드를 선택하지 않고 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 교차 사례에 적절한 방법을 지정하여 방법 모호성을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">여기서 첫 번째 숫자는 2 초 후에 인쇄 된 후 다음 숫자는 빠르게 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">여기서 사용자 표현식 &lt;code&gt;ex&lt;/code&gt; 는 call to &lt;code&gt;time&lt;/code&gt; 이지만 매크로가 사용 하는 것과 동일한 &lt;code&gt;time&lt;/code&gt; 함수는 아닙니다 . &lt;code&gt;MyModule.time&lt;/code&gt; 을 명확하게 나타냅니다 . 따라서 매크로 호출 환경 에서 &lt;code&gt;ex&lt;/code&gt; 의 코드 가 해결 되도록 정렬해야 합니다. &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; 로&lt;/a&gt; 표현식을 &quot;이스케이프 처리&quot;하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">여기서 제로 인수 생성자 메소드는 단일 인수 생성자 메소드를 호출하며, 자동으로 제공된 2 인수 생성자 메소드를 호출합니다. 머지 않아 명백해질 이유 때문에 이와 같은 일반 메소드로 선언 된 추가 생성자 메소드를 &lt;em&gt;외부&lt;/em&gt; 생성자 메소드 라고 합니다. 외부 생성자 메소드는 자동으로 제공되는 기본 메소드와 같은 다른 생성자 메소드를 호출하여 새 인스턴스 만 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">여기서 변수 &lt;code&gt;i&lt;/code&gt; 를 반환하는 두 개의 클로저를 만들고 저장 합니다. 그러나 항상 같은 변수 &lt;code&gt;i&lt;/code&gt; 이므로 두 클로저는 동일하게 동작합니다. &lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; 에 대한 새 바인딩을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">여기에서 &lt;code&gt;change_array!&lt;/code&gt; 함수를 만들었습니다 ! , 전달 된 배열의 첫 번째 요소에 &lt;code&gt;5&lt;/code&gt; 를 할당합니다 ( 호출 사이트에서 &lt;code&gt;x&lt;/code&gt; 에 바인딩되고 함수 내에서 &lt;code&gt;A&lt;/code&gt; 에 바인딩 됨 ). 함수 호출 후에도 &lt;code&gt;x&lt;/code&gt; 는 여전히 동일한 배열에 바인딩되지만 해당 배열의 내용은 변경되었습니다. 변수 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 는 동일한 가변 &lt;code&gt;Array&lt;/code&gt; 객체를 참조하는 고유 한 바인딩 입니다.</target>
        </trans-unit>
        <trans-unit id="36a8f92884e992830034696fb443df46cbb7f016" translate="yes" xml:space="preserve">
          <source>Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a &lt;code&gt;SamplerTrivial&lt;/code&gt; sampler, which is in fact the &lt;em&gt;default fallback for values&lt;/em&gt;.</source>
          <target state="translated">여기서는 컬렉션에 대한 샘플러를 정의합니다. 미리 계산 된 데이터가 필요하지 않은 경우 실제로 &lt;em&gt;values&lt;/em&gt; 의 &lt;em&gt;기본 &lt;/em&gt; &lt;code&gt;SamplerTrivial&lt;/code&gt; 샘플러 로 구현할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">여기서 우리는 매개 변수가없는 &lt;code&gt;BitVector&lt;/code&gt; 유형을 만들었지 만 요소 유형이 여전히 완전히 지정되어 있고 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Bool&lt;/code&gt; 입니다 !</target>
        </trans-unit>
        <trans-unit id="5afb8d5acf60ecdcd4dfe5d3e5a47e7bac7660ac" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt;&lt;code&gt;include_string&lt;/code&gt;&lt;/a&gt;, to evaluate &lt;code&gt;code&lt;/code&gt; as though it were the contents of a file. We could also save &lt;code&gt;code&lt;/code&gt; to a file and then call &lt;code&gt;include&lt;/code&gt; on that file&amp;mdash;the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</source>
          <target state="translated">여기에서는 &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt; &lt;code&gt;include_string&lt;/code&gt; &lt;/a&gt; 을 사용 하여 마치 파일의 내용 인 것처럼 &lt;code&gt;code&lt;/code&gt; 를 평가 합니다. &lt;code&gt;code&lt;/code&gt; 를 파일에 저장 한 다음 해당 파일에 대해 &lt;code&gt;include&lt;/code&gt; 를 호출 할 수도 있습니다. 결과는 동일합니다. 보시다시피 이것은 REPL에서 동일한 코드를 평가하는 것과는 상당히 다르게 작동합니다. 여기서 무슨 일이 일어나고 있는지 분석해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">다음은 외부 프로그램을 실행하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="1cdb1c514a8c4179306e34bfddd814358210098d" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">여기서 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; 은&lt;/a&gt; 먼저 쓰기 위해 파일을 연 다음 결과 출력 스트림을 &lt;code&gt;do ... end&lt;/code&gt; 블록 에서 정의한 익명 함수로 전달합니다 . 함수가 종료 된 후 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 은 함수가 정상적으로 종료되었는지 또는 예외가 발생했는지에 관계없이 스트림이 제대로 닫혔는지 확인합니다. ( &lt;code&gt;try/finally&lt;/code&gt; 구성은 &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;제어 흐름에&lt;/a&gt; 설명되어 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">여기서, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; 은&lt;/a&gt; 먼저 쓰기 위해 파일을 연 다음 결과 출력 스트림을 &lt;code&gt;do ... end&lt;/code&gt; 블록에 정의한 익명 함수로 전달합니다 . 함수가 종료되면 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 은 함수가 정상적으로 종료되었는지 또는 예외를 던 졌는지에 관계없이 스트림이 올바르게 닫혔는지 확인합니다. 합니다 ( &lt;code&gt;try/finally&lt;/code&gt; 구조는 설명한다 &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;제어 흐름&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b6b3a9234aa3e202da30078d8340c4a596ef7790" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; and the first argument &amp;mdash; the element type &amp;mdash; is optional, defaulting to &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;(2, 3)&lt;/code&gt; 은 &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 이고 첫 번째 인수 인 요소 유형은 선택 사항이며 기본값은 &lt;code&gt;Float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;(2, 3)&lt;/code&gt; 은 &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;count&lt;/code&gt; 는 특정 &lt;code&gt;GitHash&lt;/code&gt; 와 함께 걷기를 따라 커밋 수를 찾습니다 . &lt;code&gt;GitHash&lt;/code&gt; 는 커밋에 고유 하므로 &lt;code&gt;cnt&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">여기에, &lt;code&gt;map&lt;/code&gt; 방문은 각 사용하여 커밋 &lt;code&gt;GitRevWalker&lt;/code&gt; 을 하고 발견 &lt;code&gt;GitHash&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">여기서, &lt;code&gt;sp.data&lt;/code&gt; 을 받는 콜의 두 번째 파라미터 지칭 &lt;code&gt;SamplerSimple&lt;/code&gt; 의 생성자 (이 경우는 동일 &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; )에있는 동안, &lt;code&gt;Die&lt;/code&gt; 객체를 통해 액세스 할 수있는 &lt;code&gt;sp[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">여기서 Julia는 &lt;code&gt;B&lt;/code&gt; 가 실제로 대칭 임을 감지 하고보다 적절한 인수 분해를 사용했습니다. 대칭 또는 삼각형과 같은 특정 속성을 갖는 것으로 알려진 매트릭스에 대해보다 효율적인 코드를 작성하는 것이 종종 가능합니다. Julia는 특수한 유형을 제공하므로 행렬에 이러한 속성이있는 것으로 &quot;태그&quot;할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기서 식 객체의 평가로 인해 전역 변수 &lt;code&gt;x&lt;/code&gt; 에 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="6153340adbaa08a931cc654aec620e3452eb7b03" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore</source>
          <target state="translated">여기서 입력 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 유형으로 선언됩니다 . 즉, &lt;code&gt;p&lt;/code&gt; 가 가리키는 메모리는 Julia 또는 C에 의해 관리 될 수 있습니다. C가 할당 한 메모리에 대한 포인터는 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 유형이어야 하지만 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 를&lt;/a&gt; 사용하여 변환 할 수 있으므로</target>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">여기서 입력 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 유형으로 선언되는데 , 이는 &lt;code&gt;p&lt;/code&gt; 가 가리키는 메모리가 Julia 또는 C에 의해 관리 될 수 있음을 의미합니다 . C에 의해 할당 된 메모리에 대한 포인터는 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 유형이어야 하지만 그것은 사용 컨버터블 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 을&lt;/a&gt; 따라서 (A)에 입력 된 인수와 동일한 (공변) 용어로도 사용될 수있다 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Julia가 할당 한 메모리에 대한 포인터는 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 유형이어야하며 , 지정된 메모리 주소가 유효하고 Julia의 가비지 콜렉터가 올바르게 지정된 메모리 청크를 관리하도록해야합니다. 따라서 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 선언은 C 또는 Julia가 관리하는 포인터를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">여기서 &lt;code&gt;--math-mode=ieee&lt;/code&gt; 옵션 은 &lt;code&gt;@fastmath&lt;/code&gt; 매크로를 비활성화하여 결과를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">여기에서 합계에 의해 생성 된 &lt;code&gt;sum&lt;/code&gt; 는 &lt;code&gt;sqrt&lt;/code&gt; 함수로 전달됩니다 . 동등한 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e8ac284e43281c0f4a614327786f479a4ecc8c6" translate="yes" xml:space="preserve">
          <source>Here, though, we'll use the text-based display that comes with the standard library:</source>
          <target state="translated">그러나 여기서는 표준 라이브러리와 함께 제공되는 텍스트 기반 디스플레이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">여기, 우리의 첫 번째 요소 알고 있었 &lt;code&gt;a&lt;/code&gt; 것 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . 이와 같이 주석을 작성하면 값이 예상 유형이 아닌 경우 런타임 오류가 발생하여 잠재적으로 특정 버그를 조기에 발견 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">여기서는 &lt;code&gt;t0&lt;/code&gt; , &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;val&lt;/code&gt; 이 개인 임시 변수가되기를 원 하며 사용자가 가질 수 있는 &lt;code&gt;time&lt;/code&gt; 변수가 아닌 Julia Base 의 &lt;code&gt;time&lt;/code&gt; 함수 를 참조하는 &lt;code&gt;time&lt;/code&gt; 을 원합니다 ( &lt;code&gt;println&lt;/code&gt; 에 동일하게 적용됨 ). 사용자 표현식 &lt;code&gt;ex&lt;/code&gt; 에 &lt;code&gt;t0&lt;/code&gt; 이라는 변수에 대한 할당이 포함되어 있거나 자체 &lt;code&gt;time&lt;/code&gt; 변수를 정의한 경우 발생할 수있는 문제를 상상해보십시오 . 우리는 오류나 신비하게 잘못된 행동을하게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9694586c6d84150f32d012165fb51d66a0071dfd" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">여기에 사용자 정의 생성자 함수를 추가하여 다른 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 유형의 인수를 가져와 공통 유형으로 승격 할 수 있습니다 ( &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;생성자&lt;/a&gt; 및 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;변환 및 승격 참조&lt;/a&gt; ). (물론, 우리는 그것이처럼 행동하기 위해, 너무, 다른 방법을 많이 정의해야 할 것이다 &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 예를 들어, &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , 승진 규칙 등등.) 기본적으로이 유형 표시의 경우 단순히 , 유형 이름 및 필드 값에 대한 정보 (예 : &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">여기에 다른 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 형식의 인수를 가져 와서 공통 형식으로 승격시킬 수 있도록 사용자 지정 생성자 함수를 추가했습니다 ( &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 및 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;변환 및 승격 참조&lt;/a&gt; ). (물론, 우리는 다른 방법들도 정의해야합니다 . 예를 들어 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , 승격 규칙 등과 같이 &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 처럼 작동 하도록해야합니다.) 기본적으로이 유형의 인스턴스는 단순하게 표시됩니다. , 유형 이름 및 필드 값에 대한 정보를 포함합니다 (예 : &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">여기서 동일한 문제를 다시 한번 만들었습니다. 컴파일러는 &lt;code&gt;n&lt;/code&gt; 이 무엇인지 짐작할 수 없으므로 &lt;code&gt;Val(n)&lt;/code&gt; &lt;em&gt;유형&lt;/em&gt; 을 알 수 없습니다 . &lt;code&gt;Val&lt;/code&gt; 을 사용하려고 하지만 잘못 사용하면 여러 상황에서 성능이 쉽게 저하 &lt;em&gt;될&lt;/em&gt; 수 있습니다 . ( &lt;code&gt;Val&lt;/code&gt; 을 함수 장벽 트릭과 효과적으로 결합하는 상황에서만 커널 기능을보다 효율적으로 만들기 위해 위와 같은 코드를 사용해야합니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">은자 공액 행렬</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">에르 미트 행렬</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">헤센 버그 분해</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">16 진 바이트 ( 1-2 개의 후행 16 진 숫자가있는 &lt;code&gt;\x&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">16 진 부동 소수점 리터럴도 유효하지만 &lt;code&gt;p&lt;/code&gt; 는 밑이 2 인 지수 앞에 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 값으로 만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">고휘도 기호</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">고전압 표시</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">굽 ​​높은 구두</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">고급 임베딩</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Visual Studio를 사용하여 Windows에 고급 임베딩</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">고속 열차</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">총알 코를 가진 고속 열차</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt; 과 같은 고급 라이브러리</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt; 과 같은 고급 공급 업체별 추상화</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">잠깐만 : 왜 매크로?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 형의 객체에 대한 참조를 유지하여 원자 적으로 만, 즉 스레드 안전 방식으로 액세스되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">집, &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">꿀단지</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; API에 연결</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">수평 검은 육각형</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">수평 줄임표</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">수평 신호등</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">한 번의 통화에서 수평 및 수직 연결. 이 함수는 블록 매트릭스 구문을 위해 호출됩니다. 첫 번째 인수는 각 블록 행에서 연결할 인수 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">수평 규칙</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">말 얼굴</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">경마</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">뜨거운 음료</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">온천</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="c29e8e28d3952318903de2fb6079804d2ed9d9e6" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) with a minimum width</source>
          <target state="translated">최소 너비의 시간 (24 시간제)</target>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">흐르는 모래와 모래 시계</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">집 건물</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">정원이있는 집</target>
        </trans-unit>
        <trans-unit id="75af347bffc8062b7ea5afa0a699184af65b1a37" translate="yes" xml:space="preserve">
          <source>How can I constrain or compute type parameters?</source>
          <target state="translated">유형 매개 변수를 제한하거나 계산하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">세션에서 유형 선언을 수정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">파일 이름은 어떻게 인용 되었습니까? Julia는 &lt;code&gt;file&lt;/code&gt; 이 단일 인수로 보간되어야 함을 알고 있으므로 단어를 인용합니다. 실제로 이것은 정확하지 않습니다. &lt;code&gt;file&lt;/code&gt; 의 값은 쉘에 의해 해석되지 않으므로 실제 인용은 필요하지 않습니다. 인용 부호는 사용자에게 표시하기 위해서만 삽입됩니다. 쉘 단어의 일부로 값을 보간하는 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">스크립트에서 CTRL-C를 어떻게 잡을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">현재 파일이 기본 스크립트로 실행되고 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">메모리에서 객체를 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="07788c6091915f1a67274d44211a41dbc53e6935" translate="yes" xml:space="preserve">
          <source>How do I manage precompilation caches in distributed file systems?</source>
          <target state="translated">분산 파일 시스템에서 사전 컴파일 캐시를 어떻게 관리합니까?</target>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;#!/usr/bin/env&lt;/code&gt; 을 사용하여 &lt;code&gt;julia&lt;/code&gt; 에 옵션을 전달하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">Julia에서 &quot;null&quot;, &quot;nothingness&quot;또는 &quot;missingness&quot;는 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="b5188f1df50966f544cd1288a28b80d8b68a2b7f" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; 객체를 어떻게 구성 합니까? 복합 유형에 대한 사용자 정의 생성자를 정의 할 수 있습니다. 이는 &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; 에서 자세히 설명 할 것입니다 . 그러나 특수 생성자 선언이없는 경우 새 복합 객체를 만드는 두 가지 기본 방법이 있습니다. 하나는 유형 매개 변수가 명시 적으로 제공됩니다. 다른 하나는 객체 생성자에 대한 인수에 의해 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; 객체 는 어떻게 구성 합니까? 합성 자 유형에 대한 사용자 정의 생성자를 정의 할 수 있습니다. &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 에서 자세히 설명 하지만 특별한 생성자 선언이없는 경우, 새로운 복합 객체를 작성하는 두 가지 기본 방법이 있습니다. 하나는 유형 매개 변수가 명시 적으로 제공됩니다. 그리고 다른 하나는 객체 생성자에 대한 인수에 의해 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">이러한 인수가 초기화되는 방법은 &quot;외부&quot;기능에 따라 다릅니다. 여기서 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 은 구문 &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; 에서와 같이 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 로 순차적으로 설정 하여 각각 익명 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">이 정보를 사용하는 방법은 귀하에게 달려 있습니다. 분명히, &lt;code&gt;pos&lt;/code&gt; 를 타입 안정적 으로 수정 하는 것이 가장 좋습니다 . 그렇다면 &lt;code&gt;f&lt;/code&gt; 의 모든 변수는 구체적이고 성능은 최적입니다. 그러나 이런 종류의 &lt;em&gt;임시&lt;/em&gt; 유형 불안정성이 그다지 중요하지 않은 상황이 있습니다. 예를 들어, &lt;code&gt;pos&lt;/code&gt; 를 단독으로 사용하지 않는 경우 &lt;code&gt;f&lt;/code&gt; 의 출력이 유형 안정성 이라는 사실이 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;입력)은 나중에 불안정한 유형의 전파 효과로부터 코드를 보호합니다. 유형 불안정성을 수정하는 것이 어렵거나 불가능한 경우에 특히 관련이 있습니다. 이러한 경우 위의 팁 (예 : 유형 주석 추가 및 / 또는 기능 분해)은 유형 불안정으로 인한 &quot;손상&quot;을 포함하는 가장 좋은 도구입니다. 또한 Julia Base도 불안정한 유형의 기능을 가지고 있습니다. 예를 들어 &lt;code&gt;findfirst&lt;/code&gt; 함수는 인덱스를 키가 발견 된 배열로 반환하거나 찾지 &lt;code&gt;nothing&lt;/code&gt; 경우 명확한 유형 불안정성을 반환합니다. 중요한 유형 불안정성을 쉽게 찾을 수 있도록 &lt;code&gt;Union&lt;/code&gt; 은 &lt;code&gt;missing&lt;/code&gt; 되거나 &lt;code&gt;nothing&lt;/code&gt; 포함 하지 않습니다. 빨간색 대신 노란색으로 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">그러나 매크로 디스패치는 AST가 런타임에 평가하는 유형이 아니라 매크로에 전달 된 AST 유형을 기반으로한다는 점을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">그러나 루프에 필요한 모든 정보는 인수의 유형 정보에 포함됩니다. 따라서 생성 된 함수를 사용하여 반복을 컴파일 타임으로 이동할 수 있습니다. 컴파일러 용어에서는 생성 된 함수를 사용하여 루프를 수동으로 언 롤링합니다. 본문은 거의 동일하지만 선형 색인을 계산하는 대신 색인 을 계산 하는 &lt;em&gt;표현식&lt;/em&gt; 을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">그러나이 작업을 수행하면 메모리가 매우 느리고 누수가 발생하므로 일반적으로이를 피하고 계속 읽으십시오. 다음 섹션에서는 간접 호출을 사용하여 유사한 효과를 효율적으로 달성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d98a9aa4753704d7124f1d48bec32b6c3a7df644" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</source>
          <target state="translated">그러나 이렇게하면 매우 느리고 메모리가 누출되므로 일반적으로이를 피하고 대신 계속 읽어야합니다. 다음 섹션에서는 간접 호출을 사용하여 유사한 효과를 효율적으로 얻는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">그러나 변경 가능한 객체의 경우 경고가 예상대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">그러나 향후 통화 &lt;code&gt;tryeval&lt;/code&gt; 는 의 정의가 계속됩니다 &lt;code&gt;newfun&lt;/code&gt; 을 그것이로 &lt;em&gt;REPL에서 이전 문에&lt;/em&gt; , 따라서 해당 호출 전에 &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2749cf17a2b4294f113fe7c480d466ff1081a71" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you &lt;em&gt;can&lt;/em&gt; change its content. For example:</source>
          <target state="translated">그러나 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Array&lt;/code&gt; 유형 (또는 다른 &lt;em&gt;변경 가능한&lt;/em&gt; 유형) 의 객체에 바인딩 된 경우 . 함수 내 에서이 배열에서 &lt;code&gt;x&lt;/code&gt; 를 &quot;바인딩 해제&quot; 할 &lt;em&gt;수&lt;/em&gt; 없지만 그 내용 &lt;em&gt;은&lt;/em&gt; 변경할 &lt;em&gt;수&lt;/em&gt; 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">그러나 필요한 경우 이러한 인수 중 일부 또는 전부를 전문화 할 수 있습니다. 마지막 인수 &lt;code&gt;bc&lt;/code&gt; 는 (잠재적으로 융합 된) 브로드 캐스트 작업 인 &lt;code&gt;Broadcasted&lt;/code&gt; 개체 의 게으른 표현입니다 . 이러한 목적으로 래퍼의 가장 중요한 필드는 각각 함수와 인수 목록을 설명하는 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;args&lt;/code&gt; 입니다. 인수 목록은 다른 중첩 된 &lt;code&gt;Broadcasted&lt;/code&gt; 래퍼를 포함 할 수 있으며 종종 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">그러나 이미 사용중인 내장 상수 또는 함수를 재정의하려고하면 Julia에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">그러나 이것이 실패하는 경우를 구성하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">그러나 기존 로컬 변수를 반복 변수로 재사용하는 것이 유용한 경우가 있습니다. 키워드 &lt;code&gt;outer&lt;/code&gt; 를 추가하면 편리하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">그러나 예를 들어 &lt;code&gt;DummyModule&lt;/code&gt; 이 범위 내에 있지 않더라도 &lt;code&gt;MyType&lt;/code&gt; 을 프로세스에로드하는 것은 여전히 ​​가능합니다 .</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">그러나 이러한 기술을 사용하는 것은 놀랍게도 미묘 할 수 있습니다. 예를 들어 다음 과 같은 함수에서 &lt;code&gt;array3&lt;/code&gt; 을 호출하면 도움이되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">그러나 다른 유사한 통화는 여전히 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">그러나 자동 벡터화에 의존 할 수 없으므로 향후 사용은 주로 &lt;code&gt;llvmcall&lt;/code&gt; 을 사용하는 라이브러리를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">그러나 이것은 약간 성가 시므로 몇 가지 편리한 방법이 제공됩니다. 예를 들어, 위와 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">그러나 일부 모듈에는 하위 모듈이 포함되어 있으므로 때때로 최상위가 아닌 모듈에 액세스해야합니다. 이를 수행하는 두 가지 방법이 있습니다. 첫 번째는 절대 경로를 사용하는 것입니다 (예 : &lt;code&gt;using Base.Sort&lt;/code&gt; . 두 번째는 상대 경로를 사용하여 현재 모듈의 하위 모듈이나 주변 모듈을 쉽게 가져올 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f8e9c86265d52a44715f5ea3dcba697bb6fdada" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:</source>
          <target state="translated">그러나, 예를 들어 함수에 대한 인수가 대문자 인 경우와 같이 첫 번째 대문자를 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">그러나 함수에 대한 인수가 대문자 인 경우와 같이 대문자를 첫 글자로 유지해야하는 경우가 있습니다. &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">그러나 외부 &lt;code&gt;quote&lt;/code&gt; 표현식은 내부 인용에서 &lt;code&gt;$&lt;/code&gt; 내부의 값을 보간 할 수 있습니다. 이것은 여러 &lt;code&gt;$&lt;/code&gt; s로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">그러나 다른 요소 유형 또는 유형에 대한 외부 기능의 다른 버전 선언 할 필요가 있습니다 경우가 있습니다 &lt;code&gt;AbstractVector&lt;/code&gt; 필드의 에 &lt;code&gt;MySimpleContainer&lt;/code&gt; 은 . 다음과 같이 할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">그러나 세 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">그러나 이것은 권장 &lt;em&gt;되지&lt;/em&gt; 않습니다. 대신,보다 효율적인 &lt;code&gt;complex&lt;/code&gt; 함수를 사용하여 실수 부와 허수 부에서 직접 복잡한 값을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">그러나 위의 기본 유형과 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 간의 유형 승격은 자동이 아니며 명시 적으로 명시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">그러나 &lt;code&gt;expr&lt;/code&gt; 을 새로운 스코프 블록 (익명 함수)으로 래핑 하면 표현식의 의미 (변수의 범위)도 약간 변경 &lt;code&gt;@time&lt;/code&gt; 은 랩핑 된 코드에 미치는 영향을 최소화하면서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">그러나 의도 한 C ABI를 계산하려면 형식 레이아웃을 정적으로 알고 있어야하지만 함수의 정적 매개 변수는이 정적 환경의 일부로 간주됩니다. 함수의 정적 매개 변수는 유형의 레이아웃에 영향을 미치지 않는 한 호출 서명에서 유형 매개 변수로 사용될 수 있습니다. 예를 들어, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; 있기 때문에, 유효 &lt;code&gt;Ptr&lt;/code&gt; 항상 워드 크기 프리미티브 타입이다. 단, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; 유형 배치되기 때문에, 유효하지 않은 &lt;code&gt;T&lt;/code&gt; 가 정적으로 알려져 있지 않다.</target>
        </trans-unit>
        <trans-unit id="08e25fd1d8072dc28d6c1dfa6f07c1fbd4ffc288" translate="yes" xml:space="preserve">
          <source>However, you can get access to &lt;code&gt;PowerShell&lt;/code&gt; like this:</source>
          <target state="translated">그러나 다음 과 같이 &lt;code&gt;PowerShell&lt;/code&gt; 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">백점 기호</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">숨은 얼굴</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman, RJ and Fan, Y. (1996) &quot;통계 패키지의 표본 Quantiles&quot;, &lt;em&gt;The American Statistician&lt;/em&gt; , Vol. 50 권 4 호 361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">나 (간격)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">인수 &lt;code&gt;x&lt;/code&gt; 를 함수에 전달하고 해당 함수 내에서 수정했지만 외부에서 변수 &lt;code&gt;x&lt;/code&gt; 는 여전히 변경되지 않았습니다. 왜?</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;codeunit(s, i)&lt;/code&gt; 의해 리턴 된 값 은 &lt;code&gt;codeunit(s)&lt;/code&gt; 의해 리턴 된 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I / O 및 네트워크</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">파일이 포함 된 장치의 ID</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">IO 출력 상황 별 속성</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">키워드 인수 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 을 &lt;code&gt;pipeline&lt;/code&gt; 함수 에 전달하여 IO 리디렉션을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">아이스크림</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">동일</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">동일하고 기울어 진 평행</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">위의 점과 동일</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">$ n $가 음수이면, 신원의 관점에서 정의됩니다</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">$ n $가 음수가 아닌 경우 &lt;code&gt;n&lt;/code&gt; 개의 항목 중 &lt;code&gt;k&lt;/code&gt; 개 를 선택하는 방법의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 부정적인 실제 고유을주지의 주요 행렬 대수 계산 &lt;code&gt;A&lt;/code&gt; , 즉 고유 행렬 $의 X는 $ 그 $ E ^ X = A $ 및 $ - \ PI &amp;lt;임 (\ 람다) 모두를위한 &amp;lt;\ 파이 $ 고유 값 $ \ lambda $ of $ X $. &lt;code&gt;A&lt;/code&gt; 에 양수가 아닌 고유 값이 있으면 가능할 때마다 주체가 아닌 행렬 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 부정적인 실제 고유 값을주지의 주요 행렬 제곱근 계산 고유치가 양의 실수 부분이 같은 $ X ^ 2 = A $을 갖는 고유 행렬의 $ X $입니다. 그렇지 않으면 비원시 제곱근이 반환됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="390ecc8380adb6dd4fff37f515d8dc55040ad6a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt; or real-&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt;, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and &lt;code&gt;F.H&lt;/code&gt; is of type &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 것입니다 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; 또는 실시간 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; , 다음 하센 분해는 실제 대칭 삼중 대각 행렬을 생산하고 &lt;code&gt;F.H&lt;/code&gt; 타입이다 &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e08a2a0f6796f08007ab9fdda2c45c43480624f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 A는 &lt;code&gt;StridedArray&lt;/code&gt; 다음 요소는 크기에 따라 다를뿐만 차원 내의 일정 수의 오프셋과 함께 메모리에 저장된다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 는 차원 1에서 보폭 2를, 차원 2에서 보폭 3을 가질 수 있습니다. 차원 &lt;code&gt;d&lt;/code&gt; 를 따라 &lt;code&gt;A&lt;/code&gt; 를 증가 &lt;code&gt;strides(A, d)&lt;/code&gt; [ strides (A, d) ] 슬롯 만큼 메모리에서 점프 합니다. Strided 배열은 때때로 BLAS와 같은 외국어 라이브러리에 대한 포인터로 직접 전달 될 수 있기 때문에 특히 중요하고 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d9d3df34d4b0d8669771d98ccd80e4361eb22b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is real-symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. For such matrices, eigenvalues &amp;lambda; that appear to be slightly negative due to roundoff errors are treated as if they were zero More precisely, matrices with all eigenvalues &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. &lt;code&gt;rtol&lt;/code&gt; is a keyword argument to &lt;code&gt;sqrt&lt;/code&gt; (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by &lt;code&gt;size(A,1)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 실제 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 제곱근을 계산하는 데 사용됩니다. 이러한 행렬의 경우 반올림 오류로 인해 약간 음수로 나타나는 고유 값 &amp;lambda;는 마치 0 인 것처럼 처리됩니다.보다 정확하게는 모든 고유 값이 &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; 인 행렬이 반 정확하게 처리됩니다 (에르 미트 제곱근 산출 ), 음의 고유 값은 0으로 간주됩니다. &lt;code&gt;rtol&lt;/code&gt; 은 &lt;code&gt;sqrt&lt;/code&gt; (Hermitian / 실제 대칭의 경우에만 해당)에 대한 키워드 인수로 , 기본값은 &lt;code&gt;size(A,1)&lt;/code&gt; 조정 된 기계 정밀도 입니다.</target>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 코사인을 계산하는 데 사용됩니다. 그렇지 않으면 코사인은 &lt;code&gt;exp&lt;/code&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 코사인 변환을 계산하기 위해 사용된다. 그렇지 않으면, 역 코사인은 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="656a2e02dd9901a5d5d038f1484c6e9a0c0da179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 코사인 변환을 계산하기 위해 사용된다. 그렇지 않으면 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 역 코사인을 결정합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]을&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 사인을 계산하는 데 사용된다. 그렇지 않으면, 역 사인은 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c57d54383c6569d422099f76dc516cae4a4a6b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 사인을 계산하는 데 사용된다. 그렇지 않으면 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 역 사인을 결정합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]를&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 역 탄젠트를 계산하는 데 사용됩니다. 그렇지 않으면 역 탄젠트는 &lt;code&gt;log&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88a24bd15ac5a68c08c00b78778d22ccaac3c21f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 탄젠트를 계산하기 위해 사용된다. 그렇지 않으면 역 탄젠트는 &lt;code&gt;log&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]을&lt;/a&gt;&lt;/sup&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 사인을 계산하는 데 사용됩니다. 그렇지 않으면, 사인은 호출에 의해 결정된다 &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 제곱근을 계산하는 데 사용됩니다. 그렇지 않으면, 제곱근은 &lt;a href=&quot;#footnote-BH83&quot;&gt;Bj&amp;ouml;rck&lt;/a&gt; -Hammarling 방법 [BH83]에 의해 결정되는데 ,이 방법 은 복소수 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; )과 삼각 계수의 복소수 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 탄젠트를 계산하기 위해 사용된다. 그렇지 않으면 접선은 &lt;code&gt;exp&lt;/code&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 경우) 사용되는 &lt;code&gt;A&lt;/code&gt; 상기 역 스케일링의 개선 된 버전이 삼각형이고 제곱 법이 이용된다 ( &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; 및 &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt; ). 일반 행렬의 경우 복잡한 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; )이 계산되고 삼각 알고리즘이 삼각 요인에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7cd81f11c1d70424b51ccffe350316108e01c22e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; and &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 경우) 사용되는 &lt;code&gt;A&lt;/code&gt; 상기 역 스케일링의 개선 된 버전이 삼각형이고 제곱 법이 이용된다 ( &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; 및 &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt; ). 일반 행렬의 경우 복잡한 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; )이 계산되고 삼각형 알고리즘이 삼각 인자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">경우 &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 특정 크기가없는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="65a78265c4f32be6b8f80e6ff2b5005fabff1e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Eigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">경우 &lt;code&gt;F::Eigen&lt;/code&gt; 인수 분해의 목적은, 고유 값을 통해 획득 될 수 &lt;code&gt;F.values&lt;/code&gt; 상기 행렬의 고유 벡터 열과 &lt;code&gt;F.vectors&lt;/code&gt; . ( &lt;code&gt;k&lt;/code&gt; 번째 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="15c71436c7107833fddd5b4b5c6ae6ac2cda922a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">경우 &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; 인수 분해의 목적은, 고유 값을 통해 획득 될 수 &lt;code&gt;F.values&lt;/code&gt; 상기 행렬의 고유 벡터 열과 &lt;code&gt;F.vectors&lt;/code&gt; . ( &lt;code&gt;k&lt;/code&gt; 번째 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="f01e4881f70ca748aeb84922a14f5f7db186c9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factors can be obtained via &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors via &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt;, and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; 슈어 인자를 통해 얻을 수있다 삼각 분해 오브젝트의 (준)은 &lt;code&gt;F.S&lt;/code&gt; 및 &lt;code&gt;F.T&lt;/code&gt; 왼쪽 단위 / 직교 통해 슈어 벡터, &lt;code&gt;F.left&lt;/code&gt; 또는 &lt;code&gt;F.Q&lt;/code&gt; 와 권리 / 직교 슈어 벡터를 얻을 수있다 단위는 함께 &lt;code&gt;F.right&lt;/code&gt; 이나 &lt;code&gt;F.Z&lt;/code&gt; 되도록 &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; 및 &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 고유 값은 &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab48030073624eeb674b91b0955f920e2a071342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Hessenberg&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">경우 &lt;code&gt;F::Hessenberg&lt;/code&gt; 인수 분해의 목적은, 유니 터리 행렬에 접근 할 수 &lt;code&gt;F.Q&lt;/code&gt; 와 함께 하센 행렬 &lt;code&gt;F.H&lt;/code&gt; . 때 &lt;code&gt;Q&lt;/code&gt; 가 추출하고, 생성 된 타입이있다 &lt;code&gt;HessenbergQ&lt;/code&gt; 의 객체와 함께 정규 행렬로 변환 할 수있다 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;Array(_)&lt;/code&gt; 짧게).</target>
        </trans-unit>
        <trans-unit id="7b4e73df12d848cb37ff07b3e198fc0482a106ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::SVD&lt;/code&gt; is the factorization object, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; can be obtained via &lt;code&gt;F.U&lt;/code&gt;, &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.V&lt;/code&gt; and &lt;code&gt;F.Vt&lt;/code&gt;, such that &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt;. The singular values in &lt;code&gt;S&lt;/code&gt; are sorted in descending order.</source>
          <target state="translated">경우 &lt;code&gt;F::SVD&lt;/code&gt; 인수 분해의 목적은, &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; 및 &lt;code&gt;Vt&lt;/code&gt; 통해 얻을 수있다 &lt;code&gt;F.U&lt;/code&gt; , &lt;code&gt;F.S&lt;/code&gt; , &lt;code&gt;F.V&lt;/code&gt; 와 &lt;code&gt;F.Vt&lt;/code&gt; ,되도록 &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt; . &lt;code&gt;S&lt;/code&gt; 의 특이 값은 내림차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f171f3d3fce677fec26e12b57715e21774c193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Schur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factor can be obtained via either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors via &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;F::Schur&lt;/code&gt; 하나를 통해 획득 될 수 삼각형 슈어 인자 인수 분해 오브젝트의 (준)이다 &lt;code&gt;F.Schur&lt;/code&gt; 또는 &lt;code&gt;F.T&lt;/code&gt; 및 직교 / 단일 비아 슈어 벡터 &lt;code&gt;F.vectors&lt;/code&gt; 이나 &lt;code&gt;F.Z&lt;/code&gt; 되도록는 &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 의 고유 값은 &lt;code&gt;F.values&lt;/code&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">경우 &lt;code&gt;I_1&lt;/code&gt; 가 이차원 행렬로 변경 한 다음 &lt;code&gt;X&lt;/code&gt; 는 하게 &lt;code&gt;n+1&lt;/code&gt; 형상 차원 어레이 &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; . 행렬이 차원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2337775037e3e4a6505e42024632bd3eb4bbd6dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::BunchKaufman&lt;/code&gt; is the factorization object, the components can be obtained via &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;S::BunchKaufman&lt;/code&gt; 인수 분해의 목적은 성분들을 통해 획득 될 수 &lt;code&gt;S.D&lt;/code&gt; , &lt;code&gt;S.U&lt;/code&gt; 또는 &lt;code&gt;S.L&lt;/code&gt; 적절한 주어진 &lt;code&gt;S.uplo&lt;/code&gt; 및 &lt;code&gt;S.p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c942e11644bfa14cfe833c922c7cc44bc3db5861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::LQ&lt;/code&gt; is the factorization object, the lower triangular component can be obtained via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;S::LQ&lt;/code&gt; 인수 분해의 목적은, 하부 삼각 성분을 통해 얻을 수있다 &lt;code&gt;S.L&lt;/code&gt; 과 직교 통해 / 단일 성분 &lt;code&gt;S.Q&lt;/code&gt; ,되도록 &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;Any&lt;/code&gt; 후 메모리는 줄리아 객체 (참조 포함하는 것으로한다 &lt;code&gt;jl_value_t*&lt;/code&gt; , 그 결과가이 객체에 대한 참조가있을 것이다), 그리고 물체가 복사되지 않을 것이다. 이 경우 메모리가 조기에 해제되지 않도록 오브젝트가 가비지 콜렉터 (포인터는 계산하지 않지만 새 참조는 참조)에 항상 표시되도록주의해야합니다. Julia가 객체를 원래 할당하지 않은 경우 Julia의 가비지 수집기가 새 객체를 완성하지 않습니다. 상기 중간 &lt;code&gt;Ptr&lt;/code&gt; 자체가 실제로 &lt;code&gt;jl_value_t*&lt;/code&gt; , 그것이 의해 줄리아 객체 참조로 변환 돌아올 수 &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt; . (줄리아 값 &lt;code&gt;v&lt;/code&gt; &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt; 호출 하여 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 로 &lt;code&gt;jl_value_t*&lt;/code&gt; 포인터 로 변환 될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 유형, 그것은 가장 가까운 값을 반환합니다 &lt;code&gt;x&lt;/code&gt; 의해 표현할 수를 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 컬렉션 타입과 &lt;code&gt;x&lt;/code&gt; 모음의 결과 &lt;code&gt;convert(T, x)&lt;/code&gt; 수있는 모든 별칭 또는 일부 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 부동 소수점 타입이고, 결과는 양 또는 음의 무한대가 될 수있는 가장 가까운 값을 표현할 수있다.</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 숫자 입력이되면, 그 결과는 숫자가 아닌 요소 유형의 배열이다 &lt;code&gt;NaN&lt;/code&gt; 이 부동 소수점 형식, 또는 제로 대. 다른 유용한 &lt;code&gt;T&lt;/code&gt; 값으로 는 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;AbstractString&lt;/code&gt; 및 &lt;code&gt;Any&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5708e9143fa5c221a25e2fd582d17441adb4aff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union of types containing &lt;code&gt;Missing&lt;/code&gt;, return a new type with &lt;code&gt;Missing&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Missing&lt;/code&gt; 을 포함하는 유형의 공용체 이면 &lt;code&gt;Missing&lt;/code&gt; 이 제거 된 새 유형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 인 &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 타입 &lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 는&lt;/a&gt; 경우 발생한다 &lt;code&gt;x&lt;/code&gt; 로 표현할 수없는 &lt;code&gt;T&lt;/code&gt; 경우, 예를 들어, &lt;code&gt;x&lt;/code&gt; 없는 정수 값이거나 외부에서 지원하는 범위 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 정수 타입, &lt;code&gt;InexactError&lt;/code&gt; 는 경우 발생 &lt;code&gt;x&lt;/code&gt; 는 로 표현할 수없는 것입니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;X/Project.toml&lt;/code&gt; 가 존재하지만 않습니다 &lt;em&gt;하지&lt;/em&gt; 최상위 UUID 항목이, &lt;code&gt;uuid&lt;/code&gt; 하는 더미 UUID에 정식 (실제) 경로 해시에 의해 생성 된 &lt;code&gt;X/Project.toml&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">경우 &lt;code&gt;X/Project.toml&lt;/code&gt; 가 존재하고있다 &lt;code&gt;uuid&lt;/code&gt; 항목을 다음 &lt;code&gt;uuid&lt;/code&gt; 그 값입니다.</target>
        </trans-unit>
        <trans-unit id="b0ad6875ad056062a02a932f0ca014f6680202e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is &lt;code&gt;alg = QRIteration()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; 이면 분할 및 정복 알고리즘이 SVD를 계산하는 데 사용됩니다. 또 다른 (일반적으로 더 느리지 만 더 정확한) 옵션은 &lt;code&gt;alg = QRIteration()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">경우 &lt;code&gt;all&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; (기본값) 오류 또는 파일의 끝이 발생할 때까지,이 기능은, 요청 된 모든 바이트를 읽으려고 반복적으로 차단합니다. &lt;code&gt;all&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 최대 하나의 &lt;code&gt;read&lt;/code&gt; 호출이 수행되고 반환되는 데이터의 양은 장치에 따라 다릅니다. 모든 스트림 유형이 &lt;code&gt;all&lt;/code&gt; 옵션을 지원하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 가 2 또는 10의 거듭 제곱 이면 일반적으로 더 빠르고 정확하므로 &lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">경우 &lt;code&gt;batch_size&lt;/code&gt; 지정되면, 수집 배치 모드로 처리된다. &lt;code&gt;f&lt;/code&gt; 는 인수 튜플 의 &lt;code&gt;Vector&lt;/code&gt; 를 허용하고 결과 벡터를 반환 해야하는 함수 여야합니다 . 입력 벡터의 길이는 &lt;code&gt;batch_size&lt;/code&gt; 이하입니다.</target>
        </trans-unit>
        <trans-unit id="9a514f5181b462b5cf60570457a733a924782944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;collection&lt;/code&gt; is ordered, use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to it. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;. For &lt;code&gt;AbstractSet&lt;/code&gt; objects, &lt;a href=&quot;#Base.union!&quot;&gt;&lt;code&gt;union!&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">경우 &lt;code&gt;collection&lt;/code&gt; 주문한 사용 &lt;a href=&quot;#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;다른 컬렉션의 모든 요소를 ​​추가합니다. 이전 예제의 결과는 &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt; 합니다. 대한 &lt;code&gt;AbstractSet&lt;/code&gt; 의 객체, &lt;a href=&quot;#Base.union!&quot;&gt; &lt;code&gt;union!&lt;/code&gt; &lt;/a&gt;대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">경우에 &lt;code&gt;dims&lt;/code&gt; 튜플이다의 크기의 순서 &lt;code&gt;dims&lt;/code&gt; 관련성 및 슬라이스 선형 순서를 지정한다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 3 차원이고 &lt;code&gt;dims&lt;/code&gt; 이 &lt;code&gt;(1, 2)&lt;/code&gt; 이면, 나머지 2 차원의 슬라이스가 정렬되도록 처음 2 차원의 순서가 재 배열됩니다. 경우에 &lt;code&gt;dims&lt;/code&gt; 인 &lt;code&gt;(2, 1)&lt;/code&gt; 대신에, 동일한 슬라이스 촬영되지만 결과 순서 대신 행 중요한 것이다.</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;dlm&lt;/code&gt; , 디폴트 생략합니다 &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; 와&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">경우 &lt;code&gt;factorize&lt;/code&gt; 에르 미트 정부 호 행렬에라고, 예를 들어, 다음 &lt;code&gt;factorize&lt;/code&gt; 촐레 인수 분해를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;follow_symlinks=false&lt;/code&gt; , 그리고 &lt;code&gt;src&lt;/code&gt; 심볼릭 링크이며, &lt;code&gt;dst&lt;/code&gt; 심볼릭 링크로 생성됩니다. 경우 &lt;code&gt;follow_symlinks=true&lt;/code&gt; 과 &lt;code&gt;src&lt;/code&gt; 심볼릭 링크이며, &lt;code&gt;dst&lt;/code&gt; 파일이나 디렉토리의 사본이 될 것 &lt;code&gt;src&lt;/code&gt; 를 말합니다. &lt;code&gt;dst&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">경우 &lt;code&gt;full = false&lt;/code&gt; (기본)는 &quot;얇은&quot;SVD가 반환됩니다. US $ M \ 시간 N $ 매트릭스 들어 전체 분해에 &lt;code&gt;U&lt;/code&gt; 가 있다 &lt;code&gt;M \times M&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 인 &lt;code&gt;N \times N&lt;/code&gt; 얇은 인수에있는 동안, &lt;code&gt;U&lt;/code&gt; 가 있다 &lt;code&gt;M \times K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 인 &lt;code&gt;N \times K&lt;/code&gt; , 여기서 &lt;code&gt;K = \min(M,N)&lt;/code&gt; 은 특이 값의 개수입니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">만약 &lt;code&gt;fussy_sqrt&lt;/code&gt; 는 대신 호출 기능, 그것은 대화 형 세션에서 오류 메시지를 표시, 즉시 반환의 실행을 계속하기 위해 노력하는, 다른 함수에서 음의 값으로 호출됩니다</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">경우 &lt;code&gt;generated&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , 반환 &lt;code&gt;CodeInfo&lt;/code&gt; 의 인스턴스 구현을 폴백 (fallback)에 해당됩니다. 폴백 구현이 없으면 오류가 발생합니다. 경우 &lt;code&gt;generated&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 이러한 &lt;code&gt;CodeInfo&lt;/code&gt; 의 인스턴스는 발전기를 확장하여 산출 방법 기관에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;header&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 데이터의 첫 번째 행은 헤더와 튜플로 읽을 수 있습니다 &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; 대신 단지의 반환 &lt;code&gt;data_cells&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 안에있는 경우 인코딩 코드 단위 &lt;code&gt;i&lt;/code&gt; 가 포함 된 문자의 시작 색인을 반환합니다 . 경우 즉, &lt;code&gt;i&lt;/code&gt; 문자의 시작이다, 반환 &lt;code&gt;i&lt;/code&gt; ; &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 되 감고 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 가 0과 동일 &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; 복귀 &lt;code&gt;i&lt;/code&gt; . 다른 모든 경우에는 &lt;code&gt;BoundsError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 의 범위 안에 있으면 인덱스 &lt;code&gt;i&lt;/code&gt; 다음에 인코딩이 시작되는 문자의 시작 인덱스를 반환합니다 . 즉, &lt;code&gt;i&lt;/code&gt; 가 문자의 시작 인 경우 다음 문자의 시작을 반환합니다. &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 앞으로 이동하여 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;0&lt;/code&gt; 복귀 &lt;code&gt;1&lt;/code&gt; . 경우 &lt;code&gt;i&lt;/code&gt; 범위에 있지만 크거나 같 &lt;code&gt;lastindex(str)&lt;/code&gt; 복귀 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;BoundsError&lt;/code&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 의 범위 안에 있으면 인덱스 &lt;code&gt;i&lt;/code&gt; 보다 먼저 인코딩이 시작되는 문자의 시작 인덱스를 반환합니다 . 즉, &lt;code&gt;i&lt;/code&gt; 가 문자의 시작 인 경우 이전 문자의 시작을 반환합니다. &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 되 감고 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;1&lt;/code&gt; 명 복귀 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 복귀 &lt;code&gt;lastindex(str)&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;BoundsError&lt;/code&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="9ebe5e40c213fd1e7b9dc945437a4e812c30e543" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), then &lt;code&gt;ix&lt;/code&gt; is initialized to contain the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;initialized&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; (기본), 다음 &lt;code&gt;ix&lt;/code&gt; 의 인덱스 포함하도록 초기화 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fcfeccc007b268d4af436c2f9443a9d036bba79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;ix&lt;/code&gt; does not contain (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;, the behavior of &lt;code&gt;partialsortperm!&lt;/code&gt; is undefined.</source>
          <target state="translated">경우 &lt;code&gt;initialized&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; ,하지만 &lt;code&gt;ix&lt;/code&gt; (의 순열)의 인덱스가 포함되어 있지 않습니다 &lt;code&gt;v&lt;/code&gt; 의 동작 &lt;code&gt;partialsortperm!&lt;/code&gt; 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">경우 &lt;code&gt;io&lt;/code&gt; 지정되지 않은, &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">경우 &lt;code&gt;io&lt;/code&gt; 지정되어, 호스트 / 포트 정보를 읽는 데 사용됩니다. Julia 작업자는 시작시 바인드 주소와 포트를 인쇄합니다. 이를 통해 Julia 작업자는 작업자 포트를 수동으로 구성 할 필요없이 사용 가능한 모든 포트에서 청취 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">&lt;code&gt;irange&lt;/code&gt; 가 &lt;code&gt;1:n&lt;/code&gt; 이 아닌 경우 , 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 차원 인 경우 반환 된 인수 분해는 &lt;em&gt;잘린&lt;/em&gt; 인수 분해입니다.</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;isless(x, y)&lt;/code&gt; 정의하고 그렇다 &lt;code&gt;isless(y, x)&lt;/code&gt; 과 &lt;code&gt;isequal(x, y)&lt;/code&gt; 및 그 세 수율 정확히 한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 결과도 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; 경우에 우선한다 &lt;code&gt;itr&lt;/code&gt; 모두 포함). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 중앙값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 결과도 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; 어레이 모두를 포함하는 경우 우선). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 평균을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상의 표준 편차를 계산하기 위해 제공 될 수 있고, &lt;code&gt;m&lt;/code&gt; 은 각 측정하기위한 수단을 포함 할 수있다 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상의 표준 편차를 계산하기 위해 제공 될 수 있고, &lt;code&gt;means&lt;/code&gt; 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a062a8f0de1a26806b03ecc36f3c075df17d6625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 이 &lt;code&gt;AbstractArray&lt;/code&gt; 인 경우 차원에 대한 표준 편차를 계산하기 위해 &lt;code&gt;dims&lt;/code&gt; 를 제공 할 수 있습니다. 이 경우 &lt;code&gt;mean&lt;/code&gt; 은 &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; 과 모양이 같은 배열이어야합니다 (추가 후행 단일 차원이 허용됨).</target>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상 분산을 계산하기 위해 제공 될 수 있고, &lt;code&gt;m&lt;/code&gt; 은 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상 분산을 산출하고 제공 할 수 &lt;code&gt;mean&lt;/code&gt; 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990c04cdd5ec49c07722688547969ed041fe0726" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions.</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 이 &lt;code&gt;AbstractArray&lt;/code&gt; 인 경우 차원에 대한 분산을 계산하기 위해 &lt;code&gt;dims&lt;/code&gt; 를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c42d84f4d44608418a9c06e641987a8cc6e81e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 이 &lt;code&gt;AbstractArray&lt;/code&gt; 인 경우 차원에 대한 분산을 계산하기 위해 &lt;code&gt;dims&lt;/code&gt; 를 제공 할 수 있습니다. 이 경우 &lt;code&gt;mean&lt;/code&gt; 은 &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; 과 모양이 같은 배열이어야합니다 (추가 후행 단일 차원이 허용됨).</target>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되고 &lt;code&gt;step&lt;/code&gt; 없고, 스텝 사이즈가 있다는 것을 자동적으로 계산한다 &lt;code&gt;length&lt;/code&gt; 선형 범위 (a에서 이격 요소 &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a704a76b38109c4ddf6a00329dc6ebcf8c7f4fac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range.</source>
          <target state="translated">경우 &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되고 &lt;code&gt;step&lt;/code&gt; 없고, 스텝 사이즈가 있다는 것을 자동적으로 계산한다 &lt;code&gt;length&lt;/code&gt; 선형 영역에서 이격 요소.</target>
        </trans-unit>
        <trans-unit id="51d6d1b8a88beec41cb040befac543132aff1625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;overlap=true&lt;/code&gt;, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</source>
          <target state="translated">경우 &lt;code&gt;overlap=true&lt;/code&gt; , 대조 서열은 그렇지 않으면 이산 문자 범위에서이어야 일본어 캐릭터의 중첩 인덱스를 허용한다.</target>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">경우 &lt;code&gt;pids&lt;/code&gt; 지정되지 않은 남아, 공유 배열은 마스터를 포함하여 현재 호스트의 모든 과정에 걸쳐 매핑됩니다. 그러나 &lt;code&gt;localindices&lt;/code&gt; 및 &lt;code&gt;indexpids&lt;/code&gt; 는 작업자 프로세스 만 참조합니다. 이를 통해 작업 분배 코드를 사용하여 작업자 역할을하는 마스터 프로세스로 실제 계산에 작업자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">경우 &lt;code&gt;quotes&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 열은 큰 따옴표로 묶여 ( &quot;) 문자가 새로운 라인과 열 구분 기호를 포함 할 수 있습니다. 따옴표 문자를 인용 필드 내에서 다른 따옴표로 이스케이프해야합니다. 지정 &lt;code&gt;dims&lt;/code&gt; 예상의 튜플로 행과 열 (있는 경우 헤더 포함)은 큰 파일을 빠르게 읽을 수 있습니다. &lt;code&gt;comments&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;comment_char&lt;/code&gt; 로 시작 하는 행과 모든 행에서 &lt;code&gt;comment_char&lt;/code&gt; 다음에 오는 텍스트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">경우 &lt;code&gt;reuseaddr=true&lt;/code&gt; , 다중 스레드 또는 프로세스가 오류없이 동일한 주소에 바인딩 할 수 있습니다 그들은 모두 설정된 경우 &lt;code&gt;reuseaddr=true&lt;/code&gt; 있지만 바인딩에 마지막으로 트래픽을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="88b9f6afde6b8b83ebdb2719c69ddd36ee622e38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rng&lt;/code&gt; is not specified, it defaults to seeding the state of the shared thread-local generator.</source>
          <target state="translated">경우 &lt;code&gt;rng&lt;/code&gt; 공유 스레드 로컬 발전기의 상태를 뿌리기로, 기본값을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">경우 &lt;code&gt;rook&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 루크의 회전이 사용됩니다. 경우 &lt;code&gt;rook&lt;/code&gt; 거짓, 루크의 회전이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;skipblanks&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 입력 빈 행은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="01862aa97c770501d33a4692799d52e5b5e3dee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spawn = true&lt;/code&gt;, the Task created for &lt;code&gt;func&lt;/code&gt; may be scheduled on another thread in parallel, equivalent to creating a task via &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt;&lt;code&gt;Threads.@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;spawn = true&lt;/code&gt; , 작업이 생성 &lt;code&gt;func&lt;/code&gt; 통해 작업을 생성하는 것과 병행하여 다른 스레드에 예약 할 수 &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt; &lt;code&gt;Threads.@spawn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;step&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되는 &lt;code&gt;length&lt;/code&gt; 없고, 전체 길이 범위 요소임을 자동적으로 계산 될 것이다 &lt;code&gt;step&lt;/code&gt; 이격 (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a062e99e636224da62916657b0080cc837347ab0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced.</source>
          <target state="translated">경우 &lt;code&gt;step&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되는 &lt;code&gt;length&lt;/code&gt; 없고, 전체 길이 범위 요소임을 자동적으로 계산 될 것이다 &lt;code&gt;step&lt;/code&gt; 이격.</target>
        </trans-unit>
        <trans-unit id="4a505616ea56a3e3c587fbb37c2a52b74909df91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by Ctrl-C. Running code upon such event requires &lt;a href=&quot;../base/index#Base.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;. This is the default behavior in Julia script run without &lt;code&gt;-i&lt;/code&gt; option.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;InterruptException&lt;/code&gt; 는 Ctrl-C를에 의해 throw되지 않습니다. 이러한 이벤트에서 코드를 실행하려면 &lt;a href=&quot;../base/index#Base.atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; 이&lt;/a&gt; 필요합니다 . 이것은 &lt;code&gt;-i&lt;/code&gt; 옵션 없이 실행되는 Julia 스크립트의 기본 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;types&lt;/code&gt; 추상적 인 유형, 다음에 의해 호출 될 메서드 &lt;code&gt;invoke&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99dfe42909a3f5fda34b5da4dc246c9c5fb25583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, return an array of methods whose types match. If &lt;code&gt;module&lt;/code&gt; is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; 이 지정된 경우 유형 이 일치하는 메서드의 배열을 반환합니다. 경우에 &lt;code&gt;module&lt;/code&gt; 지정되면 해당 모듈에서 정의 된 방법의 배열을 반환한다. 모듈 목록을 배열로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; 이 지정 되면 유형 이 일치하는 메소드 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">경우 &lt;code&gt;use_mmap&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 에 의해 지정된 파일 &lt;code&gt;source&lt;/code&gt; 잠재적 인 속도 향상을위한 매핑 된 메모리입니다. Windows를 제외하고 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. Windows 에서 파일이 크고 한 번만 읽고 쓰지 않으면 &lt;code&gt;true&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">경우 &lt;code&gt;wait&lt;/code&gt; 거짓, 프로세스는 비동기 적으로 실행됩니다. 나중에 리턴 된 프로세스 오브젝트에서 &lt;code&gt;success&lt;/code&gt; 을 호출하여 대기하고 종료 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 숫자이고, 이는 본질적으로 동일하다 &lt;code&gt;one(x)/x&lt;/code&gt; , 그러나 어떤 유형에 대한 &lt;code&gt;inv(x)&lt;/code&gt; 이 약간 더 효율적일 수있다.</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 유형 인 경우 , 산술 연산 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 가 보유 할 수있는 모든 값 조합에 대해 오버플로나 정밀도 손실을 보장하지 않도록 정의 된 &quot;더 큰&quot;유형을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 값이며, 이는 변환된다 &lt;code&gt;widen(typeof(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 개체 참조하고, 모든 요소가 동일한 객체를 참조한다. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; 는 &lt;code&gt;Foo()&lt;/code&gt; 평가 결과로 채워진 배열을 한 번 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c793973e3f101c15348a8c798bb0a96d340155d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object:</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 개체 참조하고, 모든 요소가 동일한 객체를 참조한다 :</target>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 하지 &lt;code&gt;AbstractArray&lt;/code&gt; 하지만 지원 &lt;code&gt;axes&lt;/code&gt; , 색인, 그 유형 지원의 &lt;code&gt;ndims&lt;/code&gt; 을 다음 &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; 단지 자체를 반환하도록 구현 될 수 있습니다. 또한 &lt;code&gt;x&lt;/code&gt; 가 자체 &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; 을&lt;/a&gt; 정의하는 경우 사용자 정의 스타일에 영향을 미치기 위해 자체 &lt;code&gt;broadcastable&lt;/code&gt; 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 반복을 지원하는 경우 반환 된 값은 &lt;code&gt;collect(x)&lt;/code&gt; 와 동일한 &lt;code&gt;axes&lt;/code&gt; 및 인덱싱 동작을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이고 &lt;code&gt;Int&lt;/code&gt; 문자 (예 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;x^2&lt;/code&gt; 또는 &lt;code&gt;-3&lt;/code&gt; 에서 &lt;code&gt;x^-3&lt;/code&gt; ) 줄리아 코드 &lt;code&gt;x^y&lt;/code&gt; 컴파일러로 변환 &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; 에 지수 값에 대해 컴파일 타임 전문화를 활성화합니다. (기본 폴백으로 &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; . 여기서 &lt;code&gt;^&lt;/code&gt; 는 호출 네임 스페이스에 정의 되지 않은 경우 일반적으로 &lt;code&gt;^ == Base.^&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">경우 &lt;code&gt;yes&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; , 이후의 부동 소수점 연산이 정상 이하의 값에 대한 IEEE 연산 ( &quot;비정규&quot;)에 대한 규칙을 따릅니다. 그렇지 않은 경우 부동 소수점 연산은 비정규 입력 또는 출력을 0으로 변환하도록 허용되지만 필수는 아닙니다. &lt;code&gt;yes==true&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 가 아니면 하드웨어가 비정규 수의 0을 지원하지 않으면 true를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">줄리아는 ASCII 문자의 자유주의 사용을 만든 언어 인 경우는 소리내어 연산자로 작성되었을 수 있습니다 &lt;code&gt;&amp;lt;-...&lt;/code&gt; 대신 &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Julia가 ASCII 문자를보다 자유롭게 사용하는 언어 인 경우 splatting 연산자 는 &lt;code&gt;...&lt;/code&gt; 대신 &lt;code&gt;...-&amp;gt;&lt;/code&gt; 로 작성되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">[ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vu&lt;/code&gt; ]에 &lt;code&gt;A&lt;/code&gt; 의 고유 값이 모두 포함되어 있지 않으면 반환 된 인수 분해는 &lt;em&gt;잘린&lt;/em&gt; 인수 분해가됩니다.</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">경우 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 비어 (A에 독자 &lt;code&gt;take!&lt;/code&gt; 데이터를 사용할 수있을 때까지 호출) 차단합니다.</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 이 가득 찬 경우 공간이 확보 될 때까지 기록기 ( &lt;code&gt;put!&lt;/code&gt; 호출시)가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">C / C ++ 루틴에 기본 SIMD 유형 인 인수 또는 리턴 값이있는 경우 해당 Julia 유형은 &lt;code&gt;VecElement&lt;/code&gt; 의 동종 튜플이며 SIMD 유형에 자연스럽게 맵핑됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Julia 함수가 배열을 리턴하면 &lt;code&gt;jl_eval_string&lt;/code&gt; 및 &lt;code&gt;jl_call&lt;/code&gt; 의 리턴 값을 &lt;code&gt;jl_array_t*&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">복합 형이 선언되면 &lt;code&gt;mutable struct&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; , 그것의 다음 인스턴스를 수정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">함수 이름에 여러 단어가 필요한 경우 하나 이상의 개념을 나타낼 수 있고 조각으로 나눌 수 있는지 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">메소드 정의에서 키워드 인수에 기본값이 지정되지 않은 경우 키워드 인수가 &lt;em&gt;필요합니다&lt;/em&gt; . 호출자가 값을 지정하지 않으면 &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">이름이 정규화 된 경우 (예 : &lt;code&gt;Base.sin&lt;/code&gt; ) 내 보내지 않아도 액세스 할 수 있습니다. 이것은 디버깅 할 때 종종 유용합니다. 규정 된 이름을 함수 이름으로 사용하여 메소드를 추가 할 수도 있습니다. 그러나 구문 상 모호성으로 인해 이름에 연산자, &lt;code&gt;Base.+&lt;/code&gt; 와 같은 기호 만 포함 된 다른 모듈의 함수에 메소드를 추가하려는 경우 이를 참조 하려면 &lt;code&gt;Base.:+&lt;/code&gt; 를 사용해야 합니다. . 연산자의 길이가 둘 이상의 문자 인 경우 &lt;code&gt;Base.:(==)&lt;/code&gt; 와 같이 대괄호로 묶어야합니다 .</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">숫자에 정확한 부동 소수점 표현이 없으면 적절한 표현 가능한 값으로 반올림해야합니다. 그러나이 반올림이 수행되는 방식은 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준에&lt;/a&gt; 제시된 반올림 모드에 따라 필요한 경우 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">패키지 서브 디렉토리에 프로젝트 파일이있는 경우 UUID에 대한 그래프 항목은 프로젝트 파일의 &lt;code&gt;[deps]&lt;/code&gt; 맵이며 섹션이 없으면 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">패키지 서브 디렉토리에 프로젝트 파일이 없으면 그래프에서 생략되고 코드의 import 문은 기본 프로젝트 및 REPL과 동일하게 최상위 레벨로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">정규식이 일치하면 &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 가 반환하는 값 은 &lt;code&gt;RegexMatch&lt;/code&gt; 개체입니다. 이러한 객체는 패턴이 일치하는 하위 문자열과 캡처 된 하위 문자열 (있는 경우)을 포함하여 표현식이 어떻게 일치하는지 기록합니다. 이 예제는 일치하는 부분 문자열의 일부만 캡처하지만 주석 문자 다음에 공백이 아닌 텍스트를 캡처하려고합니다. 우리는 다음을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;val&lt;/code&gt; 이 제공되면 다시 실행될 때 &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; return to return value of yieldto ) 를 통해 태스크에 전달 됩니다. 경우 &lt;code&gt;error&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 값은 깨어 작업에서 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="731b72f6b2ff317794a532fdec183702202f0468" translate="yes" xml:space="preserve">
          <source>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents &lt;code&gt;&amp;radic;n&lt;/code&gt; for integers &lt;code&gt;n&lt;/code&gt; will give a rational result when &lt;code&gt;n&lt;/code&gt; is a perfect square), then it should also implement &lt;code&gt;isinteger&lt;/code&gt;, &lt;code&gt;iszero&lt;/code&gt;, &lt;code&gt;isone&lt;/code&gt;, and &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; values (since all of these default to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;AbstractIrrational&lt;/code&gt; types), as well as defining &lt;a href=&quot;../base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; to equal that of the corresponding &lt;code&gt;Rational&lt;/code&gt;.</source>
          <target state="translated">경우에 따라 합리적 일 수있는 값을 나타내는 데 하위 유형이 사용되는 경우 (예 : 정수 &lt;code&gt;n&lt;/code&gt; 에 대해 &lt;code&gt;&amp;radic;n&lt;/code&gt; 을 나타내는 제곱근 유형은 &lt;code&gt;n&lt;/code&gt; 이 완전 제곱 일 때 합리적인 결과를 제공합니다 ), &lt;code&gt;isinteger&lt;/code&gt; , &lt;code&gt;iszero&lt;/code&gt; , &lt;code&gt;isone&lt;/code&gt; 도 구현해야합니다. , 및 &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; 값 (이 모든 것이 &lt;code&gt;AbstractIrrational&lt;/code&gt; 유형에 대해 기본값이 &lt;code&gt;false&lt;/code&gt; 이므로)뿐만 아니라 해당 &lt;code&gt;Rational&lt;/code&gt; 과 동일하도록 &lt;a href=&quot;../base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">테스트가 지속적으로 실패하면 &lt;code&gt;@test_broken&lt;/code&gt; 매크로 를 사용하도록 변경할 수 있습니다 . 이것은 테스트를 의미합니다 &lt;code&gt;Broken&lt;/code&gt; 테스트가 계속 실패하고를 통해 사용자에게 경고하는 경우 &lt;code&gt;Error&lt;/code&gt; 테스트가 성공하면.</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">키워드 인자 이름의 튜플 경우 &lt;code&gt;kwnames&lt;/code&gt; 가 제공되는데,이 또한, 검사에있어서의 여부 &lt;code&gt;f&lt;/code&gt; 정합 &lt;code&gt;t&lt;/code&gt; 는 키워드 인자 이름을 부여하고있다. 일치하는 메소드가 변수 개수의 키워드 인수를 허용하는 경우 (예 : &lt;code&gt;kwargs...&lt;/code&gt; ) &lt;code&gt;kwnames&lt;/code&gt; 에 지정된 이름 은 유효한 것으로 간주됩니다. 그렇지 않으면 제공된 이름은 메소드 키워드 인수의 서브 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="abfdad8cad5f7ab5488ad45c94b34a153640fd97" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">유형이 &lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형으로 정의 된 경우 단일 요소 액세스 위에 구축 된 반복 및 다차원 인덱싱을 포함하여 매우 많은 풍부한 동작 집합을 상속합니다. 더 많은 지원 방법 은 &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;어레이 매뉴얼 페이지&lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">유형이 &lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형으로 정의 된 경우 단일 요소 액세스 위에 빌드 된 반복 및 다차원 색인 작성을 포함하여 매우 다양한 리치 동작 세트를 상속합니다. 지원되는 방법에 대해서는 &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;어레이 매뉴얼 페이지&lt;/a&gt; 와 &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">유형이 효과적으로 열거 형이면 열거 형 값이 인스턴스 인 단일 (이상적으로 변경 불가능한 구조체 또는 기본) 유형으로 정의해야합니다. 생성자와 변환은 값이 유효한지 확인할 수 있습니다. 이 디자인은 열거 형을 추상 유형으로 만드는 것보다 &quot;값&quot;을 하위 유형으로하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">사용자에게 자격 증명 프롬프트가 표시되면 &lt;code&gt;^D&lt;/code&gt; 를 입력하여 프롬프트를 중단 할 수 있습니다 ( &lt;code&gt;d&lt;/code&gt; 키 와 함께 제어 키를 누름 ).</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">작업자 풀을 지정하지 않으면 사용 가능한 모든 작업자, 즉 기본 작업자 풀이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">모든 데이터가 숫자이면 결과는 숫자 배열이됩니다. 일부 요소를 숫자로 구문 분석 할 수없는 경우 이기종 배열의 숫자와 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">모든 인덱스 경우 &lt;code&gt;I_k&lt;/code&gt; 는 정수, 위치에 다음 값이 &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 의 값으로 덮어 쓰기 &lt;code&gt;X&lt;/code&gt; , &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 받는 보내고 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 필요한 경우. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">모든 인덱스 경우 &lt;code&gt;I_k&lt;/code&gt; 는 벡터, 예를 들면, 다음의 형태 &lt;code&gt;X&lt;/code&gt; 는 것 &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; 의 위치와, &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; 의 &lt;code&gt;X&lt;/code&gt; 는 값 함유 &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">모든 인수가 스칼라 또는 0 차원 배열이면 래핑되지 않은 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">모든 인덱스가 스칼라이면 결과 &lt;code&gt;X&lt;/code&gt; 는 배열 &lt;code&gt;A&lt;/code&gt; 의 단일 요소입니다 . 그렇지 않으면 &lt;code&gt;X&lt;/code&gt; 는 모든 인덱스의 차원의 합과 동일한 차원 수를 가진 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">이러한 모든 검사가 통과되면 메시지와 키-값 쌍이 모두 평가되어 &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; 함수 를 통해 현재 로거로 전달됩니다 . &lt;code&gt;handle_message()&lt;/code&gt; 는 필요에 따라 추가 필터링을 수행하고 이벤트를 화면에 표시하거나 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80169baf9571e6bf174d6f8272d7aa9246651030" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Logging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">이러한 모든 검사가 통과되면 메시지 및 키-값 쌍이 전체적으로 평가되고 &lt;a href=&quot;#Logging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; 함수 를 통해 현재 로거에 전달됩니다 . &lt;code&gt;handle_message()&lt;/code&gt; 는 필요에 따라 추가 필터링을 수행하고 이벤트를 화면에 표시하고 파일에 저장하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">&lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 유형 의 &lt;code&gt;init&lt;/code&gt; 함수 가 지정되면 모든 참여 작업자에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">서명 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 함수 가 지정된 경우 모든 참여 작업자에서 호출됩니다. 각 작업자가 배열의 다른 부분 에서 &lt;code&gt;init&lt;/code&gt; 함수를 실행하여 초기화 를 병렬 처리하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">eltype 배열하는 경우 &lt;code&gt;Ptr{T}&lt;/code&gt; A와 통과 &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; 인수 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 는&lt;/a&gt; 그 대신 각 요소와 제 만들기 위해 어레이의 널 종료 복사를 시도한다 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 의&lt;/a&gt; 버전. 예를 들어 &lt;code&gt;Vector{String}&lt;/code&gt; 유형 의 &lt;code&gt;argv&lt;/code&gt; 포인터 배열을 &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; 유형의 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">자동으로 해결할 수없는 충돌이 발생하면 리베이스가 중단되고 리포지토리와 작업 트리가 원래 상태로 유지되며 함수는 &lt;code&gt;GitError&lt;/code&gt; 를 발생시킵니다 . 이것은 다음 명령 행 명령문과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb2726b6f11cf6d744cc2e0de08cc88e0caae92f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">인덱스 &lt;code&gt;I_k&lt;/code&gt; 가 둘 이상의 위치를 ​​선택하는 경우 오른쪽 &lt;code&gt;X&lt;/code&gt; 는 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; 을 인덱싱 한 결과와 모양이 같은 배열 이거나 요소 수가 같은 벡터 여야 합니다. . 위치의 값 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 값으로 덮어 &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , 필요한 경우 변환. 요소 별 할당 연산자 &lt;code&gt;.=&lt;/code&gt; 를 사용 하여 선택한 위치에서 &lt;code&gt;X&lt;/code&gt; 를 &lt;a href=&quot;#Broadcasting&quot;&gt;브로드 캐스트&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">인덱스 &lt;code&gt;I_k&lt;/code&gt; 가 둘 이상의 위치를 ​​선택하는 경우 오른쪽 &lt;code&gt;X&lt;/code&gt; 는 인덱스 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; 의 결과와 동일한 모양의 배열 이거나 요소 수가 동일한 벡터 여야 합니다. . 위치의 값 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 값으로 덮어 &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , 필요한 경우 변환. 요소 별 할당 연산자 &lt;code&gt;.=&lt;/code&gt; 를 사용 하여 선택한 위치에서 &lt;code&gt;X&lt;/code&gt; 를 &lt;a href=&quot;#Broadcasting-1&quot;&gt;브로드 캐스트&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">내부 생성자 메서드가 정의되어 있으면 기본 생성자 메서드가 제공되지 않습니다. 필요한 모든 내부 생성자를 제공 한 것으로 가정합니다. 기본 생성자는 객체의 모든 필드를 매개 변수로 사용하고 (해당 필드에 유형이있는 경우 올바른 유형으로 제한됨) 결과 객체를 반환하는 &lt;code&gt;new&lt;/code&gt; 내부 생성자 메서드를 작성하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">이들 중 하나라도 성공하면 소스 코드 진입 점에 대한 경로는 해당 결과에 대한 상대 경로에 &lt;code&gt;src/X.jl&lt;/code&gt; 을 더한 결과입니다 . 그렇지 않으면 &lt;code&gt;uuid&lt;/code&gt; 에 대한 경로 매핑이 없습니다 . &lt;code&gt;X&lt;/code&gt; 를 로드 할 때 소스 코드 경로가 없으면 조회가 실패하고 사용자에게 적절한 패키지 버전을 설치하거나 다른 수정 조치를 취하라는 메시지가 표시 될 수 있습니다 (예 : &lt;code&gt;X&lt;/code&gt; 를 종속성으로 선언 ).</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">배열에 &lt;code&gt;NaN&lt;/code&gt; 또는 결 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 포함 된 경우 결과도 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;missing&lt;/code&gt; ( 배열에 둘 다 포함 된 경우 &lt;code&gt;missing&lt;/code&gt; 이 우선 함). &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 &lt;code&gt;missing&lt;/code&gt; 항목 을 생략 하고 비결 측값 의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">배열에 &lt;code&gt;NaN&lt;/code&gt; 또는 결 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 포함 된 경우 결과도 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;missing&lt;/code&gt; ( 배열에 둘 다 포함 된 경우 &lt;code&gt;missing&lt;/code&gt; 이 우선 함). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 분산을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">적어도 하나의 인수가 튜플이고 다른 모든 인수가 스칼라 또는 0 차원 배열이면 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">선택적 &lt;code&gt;stream&lt;/code&gt; 인수 와 함께 호출되면 &lt;code&gt;stream&lt;/code&gt; 자체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">캡처 된 변수가 코드의 성능 핵심 섹션에서 사용되는 경우 다음 팁은 해당 기능이 제대로 작동하는지 확인하는 데 도움이됩니다. 먼저, 캡처 된 변수가 그 유형을 변경하지 않는 것으로 알려진 경우, 변수 주석 (오른쪽이 아닌 변수)을 사용하여 명시 적으로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">필드 유형이 지정되면 인수가 변환됩니다. 그렇지 않으면 인수 유형이 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">당신이 대상 유형에 전문하려는 대신하는 경우 &lt;code&gt;DestType&lt;/code&gt; 에 전문없이 &lt;code&gt;DestStyle&lt;/code&gt; , 당신은 다음과 같은 서명을하는 방법을 정의해야합니다 :</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">프로젝트 파일이없는 경우 최상위 레벨 패키지, 즉 &lt;code&gt;Main&lt;/code&gt; 또는 REPL에 로드 할 수있는 동일한 패키지를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">그것은이있는 경우 &lt;code&gt;git-tree-sha1&lt;/code&gt; 항목의 결정 해시 함수 계산 &lt;code&gt;uuid&lt;/code&gt; 와 &lt;code&gt;git-tree-sha1&lt;/code&gt; 그 울어 &lt;code&gt;slug&lt;/code&gt; 라는 이름의 디렉토리 - 그리고 모양 &lt;code&gt;packages/X/$slug&lt;/code&gt; 줄리아의 각 디렉토리에 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 전역 배열 . 존재하는 첫 번째 디렉토리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 항목 이 있으면 해당 경로를 사용하십시오 (매니페스트 파일이 포함 된 디렉토리에 상대적).</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">프로젝트 파일이있는 경우 프로젝트 파일의 &lt;code&gt;[deps]&lt;/code&gt; 섹션 에서 식별 된 패키지 만 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">함수 (또는 블록 범위) 사이의 변수에 대한 포인터를 보유 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 경우 JL_GC_PUSH * 를 사용할 수 없습니다 . 이 경우 Julia 글로벌 범위에서 변수에 대한 참조를 작성하고 유지해야합니다. 이를 달성하는 간단한 방법 중 하나 는 GC에 의한 할당 해제를 피하면서 참조를 보유 하는 전역 &lt;code&gt;IdDict&lt;/code&gt; 를 사용하는 것입니다. 그러나이 방법은 가변 유형에서만 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 번째 시간 &lt;code&gt;jl_gc_collect()&lt;/code&gt; 호출 된, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시 산술 순서에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; , 다음 호출의 수에 대한 카운트 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; 와 &lt;code&gt;maybe_collect()&lt;/code&gt; 인쇄되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 회째 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; 호출되었는지, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시되는 연산 시퀀스에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; 후, 가비지 콜렉션 강제된다.</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 회째 &lt;code&gt;maybe_collect()&lt;/code&gt; 호출되었는지, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시되는 연산 시퀀스에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; 후, 가비지 콜렉션 강제된다.</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;supertypes&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;Any&lt;/code&gt; 유형을 제외하고 부모 유형이 &lt;code&gt;typ&lt;/code&gt; 인 인수도 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">메모리 사용이 염려되는 경우 항상 적은 메모리를 사용하는 객체로 객체를 교체 할 수 있습니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 더 이상 필요하지 않은 기가 바이트 크기의 배열 인 경우 &lt;code&gt;A = nothing&lt;/code&gt; 메모리를 해제 할 수 있습니다 . 다음에 가비지 수집기가 실행될 때 메모리가 해제됩니다. &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt; 이것을 강제로 수행 할 수 있습니다 . 또한 대부분의 메소드가 &lt;code&gt;Nothing&lt;/code&gt; 유형에 정의되어 있지 않기 때문에 &lt;code&gt;A&lt;/code&gt; 를 사용하려고 하면 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">많은 실행 시간이 특정 코드 줄을 실행하는 데 소비되는 경우이 줄은 모든 역 추적 집합에 자주 나타납니다. 다시 말해, 주어진 라인의 &quot;비용&quot;즉, 실제로는이 라인까지의 함수 호출 시퀀스 비용은 모든 백 트레이스 세트에 나타나는 빈도에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">필요한 경우 정렬 알고리즘을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인수가 지정 되지 않은 경우 기본값은 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 전달되지 않으면 작업이 정의되지 않은 기간 동안 차단됩니다. &lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 에 대한 명시 적 호출을 통해서만 작업을 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">사용자 정의 테스트 세트 유형이 제공되지 않으면 기본값은 &lt;code&gt;DefaultTestSet&lt;/code&gt; 작성 입니다. &lt;code&gt;DefaultTestSet&lt;/code&gt; 는 모든 결과를 기록하고 &lt;code&gt;Fail&lt;/code&gt; 또는 &lt;code&gt;Error&lt;/code&gt; 가있는 경우 테스트 결과 요약과 함께 최상위 (비 중첩) 테스트 세트의 끝에서 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9b7b804c01f85b077652b971d063a65bcf5b1f8e" translate="yes" xml:space="preserve">
          <source>If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:</source>
          <target state="translated">편집기 환경 변수 중 하나가 설정되었지만 일치하는 편집기 항목이 없으면 기본 편집기 항목이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가능하다면, &lt;code&gt;one(x)&lt;/code&gt; 동일한 유형의 반환 값 &lt;code&gt;x&lt;/code&gt; , 그리고 &lt;code&gt;one(T)&lt;/code&gt; 입력 값 반환 &lt;code&gt;T&lt;/code&gt; 를 . 그러나 곱하기 동일성에는 차원이 없어야하기 때문에 차원 수량 (예 : 일 단위 시간)을 나타내는 유형의 경우에는 해당되지 않을 수 있습니다. 이 경우, &lt;code&gt;one(x)&lt;/code&gt; 등 (매트릭스 및 모양) 식별 동일한 정밀도의 값으로 리턴한다 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">대소 문자를 구분하지 않는 하위 문자열 &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; 로 시작하는 문자열로 설정하면 회전 스레드가 절대 절전 모드로 전환되지 않습니다. 그렇지 않으면 &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; 는 부호없는 64 비트 정수 ( &lt;code&gt;uint64_t&lt;/code&gt; ) 로 해석되며 회전 스레드가 휴면해야하는 시간을 나노초 단위로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정된 경우 Julia의 스레드 정책은 전용 시스템에서 실행되는 것과 일치합니다. 마스터 스레드는 proc 0에 있고 스레드는 선호됩니다. 그렇지 않으면 Julia는 운영 체제가 스레드 정책을 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 Julia 가비지 수집기는 메모리의 &quot;빠른 청소&quot;를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 Julia 가비지 수집기는 심각한 오류가 발생할 때마다 중단되지 않고 디버거가 연결되기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 컴파일러는 JIT (Just-In-Time) 프로파일 링을위한 이벤트 리스너를 작성하고 등록합니다.</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">설정된 경우 Julia는 &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt; 의로드 프로세스에서 캐시에 대한 자세한 정보를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">설정된 경우 이러한 환경 변수는 선택적으로 문자 &lt;code&gt;'r'&lt;/code&gt; 로 시작하는 문자열을 사용하고 그 뒤에 3 개의 부호있는 64 비트 정수 ( &lt;code&gt;int64_t&lt;/code&gt; ) 의 콜론으로 구분 된 목록의 문자열 보간이 이어집니다 . 이 3 배의 정수 &lt;code&gt;a:b:c&lt;/code&gt; 는 산술 시퀀스 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a + b&lt;/code&gt; , &lt;code&gt;a + 2*b&lt;/code&gt; , ... &lt;code&gt;c&lt;/code&gt; 를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 의 환경 변수가 이미 설정되어, 옛 값으로 붙을 &lt;code&gt;/foo/bar&lt;/code&gt; . 반면에 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;/foo/bar:&lt;/code&gt; 로 설정되어 &lt;code&gt;/foo/bar&lt;/code&gt; 를 기본 저장소 경로 앞에 추가하는 효과가 있습니다 . 경우 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 이 빈 문자열로 설정, 그것은 빈으로 확장 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 정렬. 즉, 빈 문자열은 빈 문자열의 한 요소 배열이 아닌 0 요소 배열로 해석됩니다. 이 동작은 환경 변수를 통해 빈 저장소 경로를 설정할 수 있도록 선택되었습니다. 기본 저장소 경로를 원하는 경우,이 값이 있어야 하나 환경 변수 설정되지 않은 경우, 또는 문자열로 설정 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">&lt;code&gt;JULIA_DIR&lt;/code&gt; 환경 변수가 설정되지 않은 경우 Visual Studio를 시작하기 전에 시스템 패널을 사용하여 추가하십시오. JULIA_DIR 아래 의 &lt;code&gt;bin&lt;/code&gt; 폴더는 시스템 PATH에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 의 환경 변수가 이미 설정되어, 옛 값으로 붙을 &lt;code&gt;/foo/bar&lt;/code&gt; . 반면에 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;/foo/bar:&lt;/code&gt; 로 설정 됩니다. &lt;code&gt;LOAD_PATH&lt;/code&gt; 값이 &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . 경우 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 이 빈 문자열로 설정, 그것은 빈으로 확장 &lt;code&gt;LOAD_PATH&lt;/code&gt; 정렬. 즉, 빈 문자열은 빈 문자열의 한 요소 배열이 아닌 0 요소 배열로 해석됩니다. 이 동작은 환경 변수를 통해 빈로드 경로를 설정할 수 있도록 선택되었습니다. 기본로드 경로를 원하는 경우,이 값이 있어야 하나 환경 변수 설정되지 않은 경우, 또는 문자열로 설정 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;digits&lt;/code&gt; 키워드 인수가 제공되고, 그것은 기본에, 소수의 장소 (또는 경우 이전에 부정적인) 후 지정된 자릿수로 반올림 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 키워드가 설정되어 있지 않으면 코드가 LLVM 최적화 전에 표시됩니다. 인쇄 된 비트 코드에서 모든 메타 데이터 및 dbg. * 호출이 제거됩니다. 전체 IR의 경우 &lt;code&gt;raw&lt;/code&gt; 키워드를 true로 설정하십시오 . 함수를 캡슐화하는 전체 모듈 (선언)을 덤프하려면 &lt;code&gt;dump_module&lt;/code&gt; 키워드를 true로 설정하십시오 . 키워드 인수 &lt;code&gt;debuginfo&lt;/code&gt; 는 소스 코드 중 하나 (기본값)이거나 코드 주석의 상세 정보를 지정하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;sigdigits&lt;/code&gt; 키워드 인수가 제공되고, 그것은 기본에, 유효 숫자의 지정된 번호로 반올림 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">C 랩퍼가 사용자가 Julia가 관리하는 메모리에 포인터를 전달할 것으로 예상하지 않으면 랩퍼 의 메소드 서명에 &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; 을 사용하고 마찬가지로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">위 예제 소스가 &lt;code&gt;embed_example.c&lt;/code&gt; 파일에 저장된 경우 다음 명령은 Linux 및 Windows (MSYS2 환경)에서 실행중인 프로그램으로 컴파일하거나 OS / X에서 &lt;code&gt;clang&lt;/code&gt; 을 &lt;code&gt;gcc&lt;/code&gt; 로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">위의 경우가 아니며 프로젝트 파일에 해당 매니페스트 파일이 있고 매니페스트에 &lt;code&gt;uuid&lt;/code&gt; 와 일치하는 스탠자가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">별명이 문서화되고 실제 정의가 아닌 경우, 문서 시스템 ( &lt;code&gt;?&lt;/code&gt; 모드)은 실제 정의를 검색 할 때 별명에 첨부 된 docstring을 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">인수하면 &lt;code&gt;Future&lt;/code&gt; 다른 노드가 소유하고,이 호출은 대답을 기다리는 차단합니다. 대신 별도의 작업에서 &lt;code&gt;rr&lt;/code&gt; 을 기다리 거나 로컬 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 을 프록시로 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a730ef6e1a231827c433cc4447592ea8e3ba9efc" translate="yes" xml:space="preserve">
          <source>If the arguments inside the square brackets are separated by semicolons (&lt;code&gt;;&lt;/code&gt;) or newlines instead of commas, then their contents are &lt;em&gt;vertically concatenated&lt;/em&gt; together instead of the arguments being used as elements themselves.</source>
          <target state="translated">대괄호 안의 인수 가 쉼표 대신 세미콜론 ( &lt;code&gt;;&lt;/code&gt; ) 또는 줄 바꿈으로 구분되면 요소 자체로 사용되는 인수 대신 내용이 &lt;em&gt;세로로&lt;/em&gt; 함께 &lt;em&gt;연결&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">예외가 발생하여 조건을 평가할 수없는 경우 (이 경우 심볼에 &lt;code&gt;length&lt;/code&gt; 가 정의되지 않아 발생) &lt;code&gt;Error&lt;/code&gt; 오브젝트가 리턴되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">조건식 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 해당 블록이 평가됩니다. 그렇지 않으면 조건 표현식 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 평가되고, &lt;code&gt;true&lt;/code&gt; 이면 해당 블록이 평가됩니다. 어느 표현식도 참이 &lt;code&gt;else&lt;/code&gt; 블록이 평가됩니다. 여기 실제로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">조건식 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 true이면 해당 블록이 평가됩니다. 그렇지 않으면 조건식 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 평가되고, 참이면 해당 블록이 평가됩니다. 어느 표현식도 참이 &lt;code&gt;else&lt;/code&gt; 블록이 평가됩니다. &lt;code&gt;elseif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록은 선택 사항이며, 많은으로 &lt;code&gt;elseif&lt;/code&gt; 원하는대로 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">조건이 false이면 &lt;code&gt;Fail&lt;/code&gt; 가 리턴되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">조건이 true이면 &lt;code&gt;Pass&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">발현이 경우 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 사실, 문자열 전체 원 연산자 식 평가하여 &lt;code&gt;&quot;less than&quot;&lt;/code&gt; 과 그렇지 문자열로 평가 &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; . 원래의 3 방향 예제는 3 진 연산자를 여러 번 사용하여 체인을 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="07cadc79598faa1c956be711a85436f8d736e63e" translate="yes" xml:space="preserve">
          <source>If the file does not exist a new file is created.</source>
          <target state="translated">파일이 존재하지 않으면 새 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">첫 번째 인수가 단일 정수 &lt;code&gt;n&lt;/code&gt; 이면 모든 블록 행에 &lt;code&gt;n&lt;/code&gt; 개의 블록 열 이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="87ae95240cbc769b0a9964dbc95f1267c9ef783f" translate="yes" xml:space="preserve">
          <source>If the index vector &lt;code&gt;ix&lt;/code&gt; is initialized with the indices of &lt;code&gt;v&lt;/code&gt; (or a permutation thereof), &lt;code&gt;initialized&lt;/code&gt; should be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱스 벡터 &lt;code&gt;ix&lt;/code&gt; 가 &lt;code&gt;v&lt;/code&gt; 인덱스 (또는 순열)로 &lt;code&gt;initialized&lt;/code&gt; 되면 initialized 를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;false&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;true&lt;/code&gt; 가치를) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;true&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;false&lt;/code&gt; 값) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;false&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;true&lt;/code&gt; 가치를) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;true&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;false&lt;/code&gt; 값) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">julia 프로그램이 기본 실행 파일에서 심볼에 액세스해야하는 경우 &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; 아래 설명 된 &lt;code&gt;julia-config.jl&lt;/code&gt; 에 의해 생성 된 것 외에도 Linux에서 컴파일 타임에 -Wl, --export-dynamic 링커 플래그 를 추가해야 할 수도 있습니다 . 공유 라이브러리를 컴파일 할 때는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">키워드 인수하면 &lt;code&gt;parallel&lt;/code&gt; 설정되어 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;peakflops&lt;/code&gt; 는 모든 작업자 프로세서에서 병렬로 실행됩니다. 전체 병렬 컴퓨터의 플롭 속도가 반환됩니다. 병렬로 실행할 때는 1 개의 BLAS 스레드 만 사용됩니다. 인수 &lt;code&gt;n&lt;/code&gt; 은 여전히 각 프로세서에서 해결되는 문제의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">패스의 마지막 구성 요소에 점이 포함 된 경우 경로를 점 앞의 모든 점과 점 포함 및 뒤의 모든 부분으로 분할합니다. 그렇지 않으면, 수정되지 않은 인수와 빈 문자열의 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">라이브러리를 찾을 수없는 경우 키워드 인수 &lt;code&gt;throw_error&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있지 않으면이 메소드는 오류를 발생 시킵니다 . 이 경우이 메소드는 &lt;code&gt;nothing&lt;/code&gt; 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">마스터 프로세스가 60.0 초 내에 새로 시작된 작업자와 연결을 설정하지 못하면 작업자는이를 치명적인 상황으로 처리하고 종료합니다. 이 시간 초과는 환경 변수 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 을 통해 제어 할 수 있습니다 . 마스터 프로세스 에서 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 값은 새로 시작된 작업자가 연결 설정을 기다리는 시간 (초)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">메모리가 이미 Julia가 소유하고 있거나 &lt;code&gt;isbits&lt;/code&gt; 유형이고 널이 아닌 것으로 알려진 경우 :</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">C가 메모리를 소유 한 경우 :</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">유리수의 분자와 분모가 공약수를 가지면 분모가 음이 아닌 가장 낮은 항으로 감소됩니다.</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">고유 값 &lt;code&gt;eigvals&lt;/code&gt; 의 선택적 벡터 가 지정된 경우 &lt;code&gt;eigvecs&lt;/code&gt; 는 특정 고유 고유 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">관심있는 포인터가 일반 데이터 배열 (원시 유형 또는 변경 불가능한 구조체) 인 경우 &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; 함수 가 더 유용 할 수 있습니다. Julia가 기본 버퍼의 &quot;소유권을 가져와&quot; 반환 된 &lt;code&gt;Array&lt;/code&gt; 객체가 종료 될 때 &lt;code&gt;free(ptr)&lt;/code&gt; 호출해야하는 경우 최종 매개 변수는 true 여야합니다 . 경우 &lt;code&gt;own&lt;/code&gt; 매개 변수를 생략 또는 false 모든 액세스가 완료 될 때까지, 호출자는 존재 버퍼 유해를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">디렉토리의 프로젝트 파일이 &lt;code&gt;uuid&lt;/code&gt; 및 이름 &lt;code&gt;X&lt;/code&gt; 와 일치 하면 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">유형이 &lt;code&gt;mutable&lt;/code&gt; 하다고 선언 된 경우이 불변 값을 위반하도록 필드 값을 직접 입력하여 필드 값을 변경할 수 있습니다. 물론, 초대받지 않은 객체의 내부를 어지럽히는 것은 나쁜 습관입니다. 당신 (또는 다른 사람)은 나중에 추가 외부 생성자 메서드를 제공 할 수 있지만 유형이 선언되면 더 많은 내부 생성자 메서드를 추가 할 수있는 방법이 없습니다. 외부 생성자 메소드는 다른 생성자 메소드를 호출하여 오브젝트를 작성할 수 있으므로 궁극적으로 오브젝트를 작성하려면 일부 내부 생성자를 호출해야합니다. 이렇게하면 선언 된 형식의 모든 개체가 형식과 함께 제공된 내부 생성자 메서드 중 하나를 호출하여 존재해야하므로 형식의 불변 값을 어느 정도 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">환경 변수의 값이 문자 &lt;code&gt;'r'&lt;/code&gt; 로 시작하면 가비지 콜렉션 이벤트 간격이 무작위입니다.</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">변수가 변경 불가능한 경우 변수는 동등한 변경 가능 컨테이너 또는 바람직하게는 &lt;code&gt;RefValue{Any}&lt;/code&gt; 에 &lt;code&gt;IdDict&lt;/code&gt; 되어 IdDict 로 푸시되어야 합니다 . 이 접근법에서 컨테이너는 예를 들어 &lt;code&gt;jl_new_struct&lt;/code&gt; 함수를 사용하여 C 코드를 통해 작성되거나 채워 져야 합니다. 컨테이너가 &lt;code&gt;jl_call*&lt;/code&gt; 의해 작성되면 C 코드에서 사용할 포인터를 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">이러한 기본 정의를 원하지 않으면 키워드 &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; 을&lt;/a&gt; 사용하여 모듈을 정의 할 수 있습니다 (참고 : 위와 같이 &lt;code&gt;Core&lt;/code&gt; 를 계속 가져 옵니다 ). 측면에서 &lt;code&gt;baremodule&lt;/code&gt; , 표준 &lt;code&gt;module&lt;/code&gt; 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 예제가 각 변수에 &lt;code&gt;for&lt;/code&gt; 키워드 를 사용하도록 다시 작성된 경우 출력이 달라집니다. 두 번째 및 네 번째 값에는 &lt;code&gt;0&lt;/code&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">이 파일이 장치를 참조하면 해당 장치의 ID</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">이전에 획득 한 재귀 잠금 인 경우 내부 카운터를 줄이고 즉시 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">이것이 매우 혼란스러운 경우, &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;절대적으로 모든 소프트웨어 개발자가 절대적으로 유니 코드 및 문자 집합에 대해 알아야 함&quot;을&lt;/a&gt; 읽어보십시오 . 이것은 유니 코드 및 UTF-8에 대한 훌륭한 소개이며, 문제와 관련된 약간의 혼란을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">지정하지 않으면 &lt;code&gt;rmprocs&lt;/code&gt; 는 요청 된 모든 &lt;code&gt;pids&lt;/code&gt; 가 제거 될 때까지 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">디버그 메시지도 테스트하려면 &lt;code&gt;min_level&lt;/code&gt; 키워드를 사용하여 활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;SharedArray&lt;/code&gt; 를 작성 하고 이러한 함수의 시간을 정하면 다음과 같은 결과가 나타납니다 ( &lt;code&gt;julia -p 4&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">표현식을 평가할 때 예외가 발생 &lt;em&gt;해야한다고&lt;/em&gt; 생각하면 &lt;code&gt;@test_throws&lt;/code&gt; 를 사용 하여 이러한 상황이 발생하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">대신 &lt;code&gt;x&lt;/code&gt; 를 함수에 인수로 전달 하면 더 이상 메모리를 할당하지 않으며 (아래에보고 된 할당 은 전역 범위에서 &lt;code&gt;@time&lt;/code&gt; 매크로 를 실행하기 때문에 발생합니다 ) 첫 번째 호출 후에 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f2aae1a0bcfd34dce76c0f68b8969fc76cde279d" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">대신 &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; 로 표시되도록 하려면 다음 메서드를 정의하여 지정된 출력 객체 &lt;code&gt;io&lt;/code&gt; (파일, 터미널, 버퍼 등을 나타냄, &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;네트워킹 및 스트림&lt;/a&gt; 참조)에 객체를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">우리가로 대신 표시 할 경우 &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; , 우리는 주어진 출력 오브젝트의 오브젝트를 인쇄하기 방법을 정의 할 &lt;code&gt;io&lt;/code&gt; (등등 파일을 나타내는 단말 버퍼; 참조 &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;네트워킹 스트림&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">다른 유형의 객체 (또는 유형이 아닌 객체)에 &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; 을 적용 하면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">기본값을 제공하는 &quot;계단식&quot;메소드를 정의하는 경우 잠재적 인 기본값에 해당하는 인수를 삭제하지 않도록주의하십시오. 예를 들어 디지털 필터링 알고리즘을 작성하고 패딩을 적용하여 신호의 가장자리를 처리하는 방법이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">비 전통적인 인덱싱 (1 이외의 것으로 시작하는 인덱스)을 허용하는 배열 유형을 정의하는 경우 &lt;code&gt;axes&lt;/code&gt; 를 특수화해야합니다 . 또한 전문한다 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 너무 &lt;code&gt;dims&lt;/code&gt; 인수 (통상 &lt;code&gt;Dims&lt;/code&gt; 크기 튜플) 받아 들일 수 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 는 아마도 객체 범위 - 유형 &lt;code&gt;Ind&lt;/code&gt; 자신의 디자인을. 자세한 내용 &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;은 사용자 정의 인덱스가있는 배열을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24ace472fa970e0efc7d5e99433a90005d823df2" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">비 전통적인 인덱싱 (1이 아닌 것으로 시작하는 인덱스)을 허용하는 배열 유형을 정의하는 경우 &lt;code&gt;axes&lt;/code&gt; 를 특수화해야합니다 . 또한 &lt;code&gt;dims&lt;/code&gt; 인수 (일반적으로 &lt;code&gt;Dims&lt;/code&gt; 크기 튜플)가 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 객체, 아마도 자체 디자인의 범위 유형 &lt;code&gt;Ind&lt;/code&gt; 를 수용 할 수 있도록 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 하게 전문화해야합니다 . 자세한 내용 &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;은 사용자 지정 인덱스가있는 배열을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">갇혀 있다면 &lt;code&gt;Pkg&lt;/code&gt; 에 도움을 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">예외를 지원하는 언어 (예 : Python, C #, C ++)에서 Julia C API를 사용하는 경우 예외가 발생했는지 확인한 함수를 사용하여 각 호출을 &lt;code&gt;libjulia&lt;/code&gt; 로 랩핑 한 다음 예외를 다시 throw하는 것이 좋습니다 . 호스트 언어.</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">어디서나 리턴 값을 지정하지 않고 대화식 세션에서 호출하면 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 에 대해 두 가지 색인 스타일을 모두 정의하면 이 특성을 사용하여 가장 성능이 우수한 색인 스타일을 선택할 수 있습니다. 일부 방법은 입력에서이 특성을 확인하고 가장 효율적인 액세스 패턴에 따라 다른 알고리즘으로 디스패치합니다. 특히, 각 &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; 는이 특성의 설정에 따라 유형이 반복자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9ff95da549c7d7e30f1529ab4e07584cdcd87231" translate="yes" xml:space="preserve">
          <source>If you define custom exception types, your &lt;code&gt;showerror&lt;/code&gt; method can support hints by calling &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt;&lt;code&gt;Experimental.show_error_hints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커스텀 예외 유형을 정의하는 경우 &lt;code&gt;showerror&lt;/code&gt; 메소드는 &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt; &lt;code&gt;Experimental.show_error_hints&lt;/code&gt; &lt;/a&gt; 를 호출하여 힌트를 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">이 시점에서 &lt;code&gt;hello.txt&lt;/code&gt; 의 내용을 살펴보면 내용 이 비어 있음을 알 수 있습니다. 실제로 디스크에는 아직 기록 된 것이 없습니다. 쓰기가 실제로 디스크로 플러시되기 전에 &lt;code&gt;IOStream&lt;/code&gt; 을 닫아야하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="61d643164ec2351bd9d6fcf481fa957527066f53" translate="yes" xml:space="preserve">
          <source>If you have a matrix &lt;code&gt;A&lt;/code&gt; that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in &lt;code&gt;Hermitian(A)&lt;/code&gt; before passing it to &lt;code&gt;cholesky&lt;/code&gt; in order to treat it as perfectly Hermitian.</source>
          <target state="translated">구성의 반올림 오류로 인해 약간 Hermitian이 아닌 행렬 &lt;code&gt;A&lt;/code&gt; 가있는 경우 완벽하게 Hermitian으로 처리하기 위해 &lt;code&gt;cholesky&lt;/code&gt; 에 전달하기 전에 &lt;code&gt;Hermitian(A)&lt;/code&gt; 래핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">기본 포인터를 사용하는 유형이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Julia가 실행될 때마다 실행할 코드가 있으면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">다른 응용 프로그램 또는 라이브러리의 CSC 형식의 데이터가 있고 Julia에서 가져 오려면 1 기반 색인 작성을 사용해야합니다. 모든 열의 행 인덱스를 정렬해야합니다. &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 객체에 정렬되지 않은 행 인덱스가 포함되어 있으면이를 빠르게 정렬하는 방법은 이중 전치를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">쉘 단어의 일부로 배열을 보간하는 경우 Julia는 쉘의 &lt;code&gt;{a,b,c}&lt;/code&gt; 인수 생성을 에뮬레이트합니다 .</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">모듈이 프리 컴파일하기에 안전 &lt;em&gt;하지 않다는&lt;/em&gt; 것을 알고 있다면 (예를 들어, 아래에 설명 된 이유 중 하나), &lt;code&gt;__precompile__(false)&lt;/code&gt; 를 모듈 파일 (일반적으로 맨 위에 배치 ) 에 두어야합니다 . 이로 인해 &lt;code&gt;Base.compilecache&lt;/code&gt; 에서 오류가 발생 &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 를 사용 하여 현재 프로세스로 직접로드하고 사전 컴파일 및 캐싱을 건너 뜁니다. 따라서 다른 사전 컴파일 된 모듈에서 모듈을 가져 오지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="8e09fd6adcf3b546269be2b7ff41cc7243507fad" translate="yes" xml:space="preserve">
          <source>If you need a reference to the created task, pass a &lt;code&gt;Ref{Task}&lt;/code&gt; object via the keyword argument &lt;code&gt;taskref&lt;/code&gt;.</source>
          <target state="translated">생성 된 작업에 대한 참조가 필요한 경우 키워드 인수 &lt;code&gt;taskref&lt;/code&gt; 를 통해 &lt;code&gt;Ref{Task}&lt;/code&gt; 개체를 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">여러 인수를 디스패치해야하고 가능한 모든 변형을 정의하기에 너무 많은 조합으로 대체 된 폴 백이있는 경우, 예를 들어 첫 번째 인수에서 디스패치 한 다음 &quot;name cascade&quot;를 도입하는 것이 좋습니다. 내부 방법 :</target>
        </trans-unit>
        <trans-unit id="5c6a0fa6b882b862c349ff5b92d17fa1f5f4c109" translate="yes" xml:space="preserve">
          <source>If you need to guarantee exact reproducibility of random data, it is advisable to simply &lt;em&gt;save the data&lt;/em&gt; (e.g. as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)</source>
          <target state="translated">임의 데이터의 정확한 재현성을 보장해야하는 경우 데이터를 간단히 &lt;em&gt;저장하는&lt;/em&gt; 것이 좋습니다 (예 : 과학 간행물의 추가 첨부 파일로). (물론 특히 비트 재현성이 필요한 경우 특정 Julia 버전 및 패키지 매니페스트를 지정할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">문자열에 유효한 인덱스를 가져와야 할 경우, &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 위에서 언급 한대로 다음 / 이전 유효한 인덱스로 증가 / 감소 할 수 있습니다 . &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 유효한 문자 인덱스를 반복 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffe59bec712e7149856d034145a9690621f691b0" translate="yes" xml:space="preserve">
          <source>If you need to solve many systems of the form &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; for the same &lt;code&gt;A&lt;/code&gt; and different &lt;code&gt;&amp;mu;&lt;/code&gt;, it might be beneficial to first compute the Hessenberg factorization &lt;code&gt;F&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; via the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function. Given &lt;code&gt;F&lt;/code&gt;, Julia employs an efficient algorithm for &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; (equivalent to &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt;) and related operations like determinants.</source>
          <target state="translated">동일한 &lt;code&gt;A&lt;/code&gt; 및 다른 &lt;code&gt;&amp;mu;&lt;/code&gt; 에 대해 &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; 형식의 많은 시스템을 풀어야하는 경우 먼저 &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt; 함수 를 통해 &lt;code&gt;A&lt;/code&gt; 의 Hessenberg 분해 &lt;code&gt;F&lt;/code&gt; 를 계산하는 것이 유용 할 수 있습니다 . &lt;code&gt;F&lt;/code&gt; 가 주어지면 Julia는 &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; ( &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt; 와 동일) 및 행렬식과 같은 관련 연산에 대해 효율적인 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="37c200e4c125ec6f24cad360d6dae92d524d5333" translate="yes" xml:space="preserve">
          <source>If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):</source>
          <target state="translated">환경 변수를 사용하려면 Bash (Linux / macOS)에서 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e449fc3b5ae85ea55ddb2c14a81e3b450b101b1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;multiplex=true&lt;/code&gt; as an option to &lt;code&gt;addprocs&lt;/code&gt;, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of &lt;code&gt;multiplex&lt;/code&gt; option. If multiplexing is enabled, forwarding is set by using the existing connection (&lt;code&gt;-O forward&lt;/code&gt; option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of &lt;code&gt;addprocs&lt;/code&gt;. The control socket will be located at &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</source>
          <target state="translated">&lt;code&gt;addprocs&lt;/code&gt; 에 대한 옵션으로 &lt;code&gt;multiplex=true&lt;/code&gt; 를 지정 하면 SSH 멀티플렉싱이 마스터와 작업자 사이에 터널을 만드는 데 사용됩니다. SSH 멀티플렉싱을 직접 구성하고 연결이 이미 설정된 경우 &lt;code&gt;multiplex&lt;/code&gt; 옵션에 관계없이 SSH 멀티플렉싱이 사용됩니다 . 멀티플렉싱이 활성화 된 경우 기존 연결 ( ssh의 &lt;code&gt;-O forward&lt;/code&gt; 옵션) 을 사용하여 전달이 설정됩니다 . 서버에 암호 인증이 필요한 경우 유용합니다. &lt;code&gt;addprocs&lt;/code&gt; 보다 먼저 서버에 로그인하여 Julia에서 인증을 피할 수 있습니다 . 제어 소켓은 &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; 기존 멀티플렉싱 연결을 사용하지 않는 한 세션 동안. 노드에 여러 프로세스를 만들고 멀티플렉싱을 활성화하면 대역폭이 제한 될 수 있습니다.이 경우 프로세스는 단일 멀티플렉싱 TCP 연결을 공유하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; 를 지정 하면 문자열이 &lt;code&gt;GitReference&lt;/code&gt; 로 변환되므로 참조 형식으로 수행해야합니다 . 예를 들어 &lt;code&gt;branch_a&lt;/code&gt; 분기를 병합 하려면 &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">둘 이상의 &lt;code&gt;AbstractArray&lt;/code&gt; 인수를 제공하면 각 &lt;code&gt;eachindex&lt;/code&gt; 는 모든 인수에 대해 빠른 반복 가능한 객체를 만듭니다 ( 모든 입력에 빠른 선형 색인이 있으면 &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; , 그렇지 않으면 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ). 배열의 크기 및 / 또는 차원이 다른 경우 각 &lt;code&gt;eachindex&lt;/code&gt; 는 각 차원을 따라 가장 큰 범위에 걸쳐있는 이터 러블 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f56a6f95645242ddef63028fd0be36ad60f0ec75" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</source>
          <target state="translated">하나 이상의 &lt;code&gt;AbstractArray&lt;/code&gt; 인수를 제공하면 각 &lt;code&gt;eachindex&lt;/code&gt; 는 모든 인수에 대해 빠른 반복 가능한 객체를 생성합니다 ( 모든 입력에 빠른 선형 인덱싱이있는 경우 &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; , 그렇지 않은 경우 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ). 배열의 크기 및 / 또는 차원이 다른 경우 DimensionMismatch 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad751359c9250bca5bb370e9aaa6dde27fda5aad" translate="yes" xml:space="preserve">
          <source>If you try this in the REPL, you will see that &lt;code&gt;schedule&lt;/code&gt; returns immediately. That is because it simply adds &lt;code&gt;t&lt;/code&gt; to an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting for keyboard input provides an opportunity for other tasks to run, so at that point &lt;code&gt;t&lt;/code&gt; will start. &lt;code&gt;t&lt;/code&gt; calls &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt;, which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five seconds, the timer fires and restarts &lt;code&gt;t&lt;/code&gt;, and you will see &lt;code&gt;done&lt;/code&gt; printed. &lt;code&gt;t&lt;/code&gt; is then finished.</source>
          <target state="translated">REPL에서 이것을 시도하면 &lt;code&gt;schedule&lt;/code&gt; 이 즉시 반환 되는 것을 볼 수 있습니다. 이는 단순히 실행할 작업의 내부 대기열에 &lt;code&gt;t&lt;/code&gt; 를 추가하기 때문 입니다. 그런 다음 REPL은 다음 프롬프트를 인쇄하고 추가 입력을 기다립니다. 키보드 입력을 기다리면 다른 작업을 실행할 수있는 기회가 제공되므로 그 시점에서 &lt;code&gt;t&lt;/code&gt; 가 시작됩니다. &lt;code&gt;t&lt;/code&gt; 는 타이머를 설정하고 실행을 중지하는 &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt; &lt;code&gt;sleep&lt;/code&gt; 을&lt;/a&gt; 호출합니다 . 다른 작업이 예약 된 경우 실행할 수 있습니다. 5 초 후에 타이머가 실행되고 &lt;code&gt;t&lt;/code&gt; 가 다시 시작 되고 &lt;code&gt;done&lt;/code&gt; 인쇄 된 것을 볼 수 있습니다. 그런 다음 &lt;code&gt;t&lt;/code&gt; 가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 동일한 유형 또는 &lt;code&gt;T&lt;/code&gt; 유형의 수량을 원할 경우 &lt;code&gt;x&lt;/code&gt; 가 차원이 있더라도 하나의 &lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 선택된 함수 호출에 점을 추가 &lt;em&gt;하지 않으&lt;/em&gt; 려면 해당 함수 호출을 &lt;code&gt;$&lt;/code&gt; 로 결합하십시오 . 예를 들어 &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; sqrt (abs ($ sort (x))) 는 &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; ( &lt;code&gt;sort&lt;/code&gt; 대한 점 없음 ).</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">문자열에서 문자를 추출하려면 색인을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">외부 명령의 출력을 읽으려면 대신 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee9527d2c41ad82a10f035e6e19f07b44c36b95" translate="yes" xml:space="preserve">
          <source>If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword &lt;code&gt;match_mode=:any&lt;/code&gt;:</source>
          <target state="translated">나머지는 무시하고 특정 메시지가 생성 &lt;code&gt;match_mode=:any&lt;/code&gt; 하려면 match_mode = : any 키워드를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">감사 추적으로 로깅을 사용하려면 로거 유형에 대해이를 사용 안함으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">파일에 쓰려면 write ( &lt;code&gt;&quot;w&quot;&lt;/code&gt; ) 플래그 로 파일을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">&lt;code&gt;dumbsum3&lt;/code&gt; 을 프로파일 링 하고 &lt;code&gt;dumbsum(1)&lt;/code&gt; 실행하는 동안 역 추적을 수행 한 경우 역 추적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">특정 스타일 &lt;code&gt;DestStyle&lt;/code&gt; 을 전문화하려면에 대한 메소드를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="9416eec2408335a70a9403f87954e9d92bc5beb6" translate="yes" xml:space="preserve">
          <source>If you would like to define your own block, for example a &lt;code&gt;terminology&lt;/code&gt; block used like so:</source>
          <target state="translated">예를 들어 다음 과 같이 사용되는 &lt;code&gt;terminology&lt;/code&gt; 블록과 같이 자신의 블록을 정의하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 유형 을 작성하는 경우 다음을 사용하여 빠른 선형 색인 작성을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">숫자를 처리하고 많은 다른 숫자 유형 인수로 실행될 수있는 일반 코드를 작성하는 경우 승격을 통해 인수에 거의 영향을 미치지 않는 숫자 유형의 리터럴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">배열 유형에 고정 차원 요구 사항이있는 경우 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 하위 유형을 지정해야합니다 . 예를 들어, 희소 배열 코드는 다음과 같은 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">코드에 재귀가있는 경우 혼동 될 수있는 한 가지 점은 &quot;자식&quot;함수의 한 줄이 전체 역 추적보다 많은 수를 누적 할 수 있다는 것입니다. 다음 함수 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">함수가 &lt;code&gt;Array&lt;/code&gt; 또는 다른 복합 유형을 반환하면 메모리를 할당해야 할 수 있습니다. 불행하게도, 종종 할당과 그 반대로 가비지 콜렉션은 상당한 병목 현상입니다.</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">반면에 Julia가 &lt;em&gt;다른 &lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; 패키지 (UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; 가 있는 패키지)를 로드하는 경우 매니페스트에서 스탠자를 찾은 경우 &lt;code&gt;path&lt;/code&gt; 항목 이 &lt;em&gt;없지만&lt;/em&gt; 참조하십시오. 가 않습니다 &lt;code&gt;git-tree-sha1&lt;/code&gt; 항목을. 그런 다음 이 UUID / SHA-1 쌍 의 &lt;code&gt;slug&lt;/code&gt; ( &lt;code&gt;HDkrT&lt;/code&gt; )를 계산합니다 (이 계산의 정확한 세부 사항은 중요하지 않지만 일관되고 결정적입니다). 이것은이 &lt;code&gt;Priv&lt;/code&gt; 패키지 의 경로가 패키지 저장소 중 &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; 있는 packages / Priv / HDkrT / src / Priv.jl임을 의미 합니다. 의 내용을 가정 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 가 있다 &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; 이면 Julia는 다음 경로를보고 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">이미지</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">대략 또는 동등한 이미지</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">객체 &lt;code&gt;x&lt;/code&gt; 에 등록 된 종료자를 즉시 ​​실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">필드가없는 불변 합성 유형은 싱글 톤입니다. 이러한 유형의 인스턴스는 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict는 많은 개별 삽입으로 구성된 작은 사전에 최적 인 불변 링크 목록으로 구현 된 사전입니다. 같은 키</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">사용자 지정 전송을 사용하여 클러스터 관리자가 구현합니다. &lt;code&gt;config&lt;/code&gt; 에 의해 지정된 id가 &lt;code&gt;pid&lt;/code&gt; 인 worker에 대한 논리적 연결을 설정 하고 한 쌍의 &lt;code&gt;IO&lt;/code&gt; 객체를 반환해야 합니다. &lt;code&gt;pid&lt;/code&gt; 에서 현재 프로세스 까지의 메시지는 &lt;code&gt;instrm&lt;/code&gt; 에서 읽히고 &lt;code&gt;pid&lt;/code&gt; 로 보내지는 메시지 는 &lt;code&gt;outstrm&lt;/code&gt; 에 작성됩니다 . 사용자 정의 전송 구현은 메시지가 완전히 순서대로 전달 및 수신되도록해야합니다. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; 는 작업자간에 TCP / IP 소켓 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 이 기능에 의해 시작 모든 줄리아 노동자의 경우, 그것은 추가해야 &lt;code&gt;WorkerConfig&lt;/code&gt; 의 입장 &lt;code&gt;launched&lt;/code&gt; 하고 통지 &lt;code&gt;launch_ntfy&lt;/code&gt; . &lt;code&gt;manager&lt;/code&gt; 가 요청한 모든 작업자 가 시작 되면이 기능을 종료해야 합니다. &lt;code&gt;params&lt;/code&gt; 는 &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; 가 호출 된 모든 키워드 인수의 사전입니다 .</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 마스터 프로세스에서 &lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; 에 의해 호출 됩니다. &lt;code&gt;pid&lt;/code&gt; 로 지정된 원격 작업자 가 종료되도록해야합니다. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; &lt;code&gt;exit()&lt;/code&gt; 는 &lt;code&gt;pid&lt;/code&gt; 에서 원격 exit () 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 작업자의 수명 동안 적절한 &lt;code&gt;op&lt;/code&gt; 값 을 사용하여 마스터 프로세스에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d46cc8d098f423748bfcc369918df042e230bb1" translate="yes" xml:space="preserve">
          <source>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</source>
          <target state="translated">식별자 및 점 식의 암시 적 이름은 Julia 1.5부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">가져 오기 명령</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">위의 &lt;code&gt;MyModule&lt;/code&gt; 에서 표준 &lt;code&gt;show&lt;/code&gt; 함수에 메소드를 추가하려고 했기 때문에 &lt;code&gt;import Base.show&lt;/code&gt; 를 작성해야했습니다 . &lt;code&gt;using&lt;/code&gt; 통해서만 이름이 보이는 기능은 확장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;em&gt;매우 드문&lt;/em&gt; 경우는 생성자에 대한 의미 만들 수도 &lt;code&gt;T(x)&lt;/code&gt; 유형의 객체를하지 반환 &lt;code&gt;T&lt;/code&gt; . 래퍼 유형이 자체 역수 (예 : &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; )이거나 라이브러리가 재구성 될 때 이전 버전과의 호환성을 위해 이전 호출 구문을 지원하는 경우 이런 일이 발생할 수 있습니다. 그러나 &lt;code&gt;convert(T, x)&lt;/code&gt; 는 항상 &lt;code&gt;T&lt;/code&gt; 유형의 값을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">C ++ 또는 Java에서, 예를 들어 &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; 와 같은 메소드 호출 에서 오브젝트 obj는 메소드 호출을 &quot;수신&quot;하고 명시 적 메소드 인수가 아닌 &lt;code&gt;this&lt;/code&gt; 키워드 를 통해 내재적 으로 메소드에 전달됩니다. . 전류가되면 &lt;code&gt;this&lt;/code&gt; 객체 메소드 호출의 수신자가, 단지 기록 아예 생략 될 수 &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; 가진 &lt;code&gt;this&lt;/code&gt; 수신 객체로서 묵시적.</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">C ++에서는 기본적으로 정적 디스패치가 있습니다. 즉, 동적 디스패치를 ​​수행하려면 함수를 가상으로 주석 처리해야합니다. 반면에 Julia에서는 모든 메소드가 &quot;가상&quot;(가장 일반적인 선언 규칙을 사용하여 &lt;code&gt;this&lt;/code&gt; 뿐만 아니라 모든 인수 유형에서 메소드가 전달되므로 메소드가 더 일반적 임 )입니다.</target>
        </trans-unit>
        <trans-unit id="848c2eb8261286f9fd639a07ac24e094cd08249a" translate="yes" xml:space="preserve">
          <source>In Julia &amp;le; 0.6, all global scopes did work like the current REPL: when &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurred in a loop (or &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;struct&lt;/code&gt; body) but outside of a function body (or &lt;code&gt;let&lt;/code&gt; block or comprehension), it was decided based on whether a global named &lt;code&gt;x&lt;/code&gt; was defined or not whether &lt;code&gt;x&lt;/code&gt; should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it's quite clear what's going on:</source>
          <target state="translated">Julia &amp;le; 0.6에서 모든 전역 범위는 현재 REPL처럼 작동 했습니다. &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; 가 루프 (또는 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; body)에서 발생했지만 함수 본문 (또는 &lt;code&gt;let&lt;/code&gt; block 또는 comprehension) 외부에서 발생하면 글로벌라는 이름의 여부에 따라 결정되었다 &lt;code&gt;x&lt;/code&gt; 정의 여부 된 &lt;code&gt;x&lt;/code&gt; 루프에 로컬이어야합니다. 이 동작은 함수 본문 내부의 동작에 최대한 가깝게 접근하므로 직관적이고 편리하다는 장점이 있습니다. 특히 함수의 동작을 디버그하려고 할 때 함수 본문과 REPL 사이에서 코드를 쉽게 앞뒤로 이동할 수 있습니다. 그러나 몇 가지 단점이 있습니다. 첫째, 이것은 매우 복잡한 행동입니다. 수년에 걸쳐 많은 사람들이이 행동에 대해 혼란스러워했고 설명하고 이해하는 것이 복잡하고 어렵다고 불평했습니다. 공정한 포인트. 두 번째로 더 나쁜 것은 &quot;대규모&quot;로 프로그래밍하는 데 좋지 않다는 것입니다. 이와 같은 한곳에서 작은 코드 조각을 보면 무슨 일이 일어나고 있는지 매우 분명합니다.</target>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">Julia의 경우 (많은 과학적 계산에서와 같이) 밀도가 높은 선형 대수 연산은 &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK 라이브러리를&lt;/a&gt; 기반 으로하며 &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; 라는 기본 선형 대수 빌딩 블록 위에 구축됩니다 . 모든 컴퓨터 아키텍처에 사용할 수있는 최적화 된 BLAS 구현이 있으며 때로는 고성능 선형 대수 루틴에서 BLAS 함수를 직접 호출하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">Julia 1.0에서이 방법은 정사각 목적지 행렬 만 지원했습니다. 줄리아 1.1. 직사각형 매트릭스에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">Julia 1.0에서 기본값은 &lt;code&gt;--project=@.&lt;/code&gt; 옵션은 &lt;code&gt;Project.toml&lt;/code&gt; 파일에 대한 Git 저장소의 루트 디렉토리에서 검색하지 않았습니다 . Julia 1.1부터는 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1에서는 &lt;code&gt;randcycle&lt;/code&gt; 이 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 벡터 &lt;code&gt;v&lt;/code&gt; 를 반환 하지만 Julia 1.0에서는 &lt;code&gt;eltype(v) == Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1에서는 &lt;code&gt;randperm&lt;/code&gt; 이 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 벡터 &lt;code&gt;v&lt;/code&gt; 를 반환 하지만 Julia 1.0에서는 &lt;code&gt;eltype(v) == Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f25573f2ef6b2638e0373e20cdd6eceb2e703331" translate="yes" xml:space="preserve">
          <source>In Julia 1.5 and above the number of threads can also be specified on startup using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument.</source>
          <target state="translated">Julia 1.5 이상에서는 시작시 &lt;code&gt;-t&lt;/code&gt; / &lt;code&gt;--threads&lt;/code&gt; 명령 줄 인수를 사용하여 스레드 수를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">Julia에서는 &lt;code&gt;%&lt;/code&gt; 가 나머지 연산자 인 반면 Python에서는 모듈러스입니다.</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">외부 C 루틴에 대한 호출을 랩핑하는 Julia 코드에서 일반 (비 포인터) 데이터는 값이 전달 될 때 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 내부에서 &lt;code&gt;T&lt;/code&gt; 유형으로 선언되어야합니다 . C 코드 수용성 포인터를 들어, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; 일반적으로 내재적 호출을 통해 줄리아 또는 C 중 하나에 의해 관리되는 메모리에 대한 포인터의 사용을 허용하는, 입력 인자의 유형 표기 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 를&lt;/a&gt; . 반대로, 호출 된 C 함수에 의해 리턴 된 포인터는 지시 된 메모리가 C에 의해서만 관리됨을 반영 하여 출력 유형 &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt; 으로 선언되어야합니다 . C 구조체에 포함 된 포인터는 &lt;code&gt;Ptr{T}&lt;/code&gt; 유형의 필드로 표시되어야합니다. 해당 Julia 구조체 유형 내에서 해당 C 구조체의 내부 구조를 모방하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">외부 포트란 루틴에 대한 호출을 랩핑하는 Julia 코드에서는 포트란이 모든 변수를 메모리 위치에 대한 포인터로 전달하므로 모든 입력 인수는 &lt;code&gt;Ref{T}&lt;/code&gt; 유형으로 선언되어야합니다 . 리턴 유형은 포트란 서브 루틴의 경우 &lt;code&gt;Cvoid&lt;/code&gt; 이거나 유형 &lt;code&gt;T&lt;/code&gt; 를 리턴하는 포트란 함수의 경우 &lt;code&gt;T&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">Julia에서는 각 모듈마다 고유 한 전역 범위 / 네임 스페이스가 있지만 MATLAB에는 하나의 전역 범위 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d6aa810b7eb985858c7d4e38c552636ecace4b" translate="yes" xml:space="preserve">
          <source>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</source>
          <target state="translated">Julia 루프는 빠르기 때문에 성능상의 이유로 &quot;벡터화 된&quot;코드를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">Julia 모드에서 REPL은 &lt;em&gt;프롬프트 붙여 넣기&lt;/em&gt; 라는 것을 지원합니다 . &lt;code&gt;julia&amp;gt;&lt;/code&gt; 로 시작하는 텍스트를 REPL에 붙여 넣을 때 활성화됩니다 . 이 경우 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 로 시작하는 표현식 만 구문 분석되고 다른 표현식 은 제거됩니다. 따라서 프롬프트와 출력을 제거하지 않고도 REPL 세션에서 복사 된 코드를 붙여 넣을 수 있습니다. 이 기능은 기본적으로 활성화되어 있지만 원하는대로 &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; 활성화하거나 비활성화 할 수 있습니다 . 활성화 된 경우이 단락 위에있는 코드 블록을 REPL에 바로 붙여 넣어 사용해 볼 수 있습니다. 이 기능은 붙여 넣기 발생시기를 감지하는 데 한계가 있기 때문에 표준 Windows 명령 프롬프트에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7129a6b15edfb73c2cd4cd30d7a70ed28691edca" translate="yes" xml:space="preserve">
          <source>In Julia the &lt;code&gt;@&lt;/code&gt; symbol refers to a macro, whereas in Python it refers to a decorator.</source>
          <target state="translated">Julia에서 &lt;code&gt;@&lt;/code&gt; 기호는 매크로를 나타내는 반면 Python에서는 데코레이터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">Julia에서 &lt;code&gt;&amp;lt;-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;&lt;/code&gt; 는 대입 연산자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">Julia에서는 &lt;code&gt;...&lt;/code&gt; 코드 행을 계속하는 데 사용되지 않습니다. 대신 불완전한 표현식이 다음 줄로 자동 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;Ref&lt;/code&gt; 객체는 &lt;code&gt;[]&lt;/code&gt; 로 역 참조 (로드 또는 저장)됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; 는 &lt;code&gt;[1, 3]&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; 는 &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[x,y,z]&lt;/code&gt; 는 항상 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 를 포함하는 3 요소 배열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">Julia에서는 &lt;code&gt;a:b&lt;/code&gt; 와 &lt;code&gt;a:b:c&lt;/code&gt; 가 &lt;code&gt;AbstractRange&lt;/code&gt; 객체를 생성 합니다. MATLAB에서와 같이 전체 벡터를 구성하려면 &lt;code&gt;collect(a:b)&lt;/code&gt; . 일반적으로 &lt;code&gt;collect&lt;/code&gt; 를 호출 할 필요는 없습니다 . &lt;code&gt;AbstractRange&lt;/code&gt; 의 목적은 대부분의 경우에 보통 배열처럼 행동하지만 느리게 그 값을 계산하기 때문에보다 효율적이다 것이다. 전체 배열 대신 특수 객체를 생성하는이 패턴은 자주 사용되며 &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 와 같은 함수 또는 &lt;code&gt;enumerate&lt;/code&gt; 및 &lt;code&gt;zip&lt;/code&gt; 과 같은 반복자와 함께 사용됩니다 . 특수 객체는 대부분 마치 일반 배열 인 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">Julia에서는 &lt;code&gt;return&lt;/code&gt; 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">Julia에서 &lt;code&gt;x += y&lt;/code&gt; 는 &lt;code&gt;x = x + y&lt;/code&gt; 구문 분석하는 동안 바뀝니다 . 배열의 경우 결과는 &lt;code&gt;x&lt;/code&gt; 와 동일한 위치에 결과를 저장하는 대신 결과를 저장하기 위해 새 배열을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="40831d3e8b132da3257b046df4af0d9dab5df46c" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia에서 함수는 인수 값의 튜플을 반환 값에 매핑하는 객체입니다. 줄리아 함수는 프로그램의 전역 상태를 변경하고 영향을받을 수 있기 때문에 순수한 수학적 함수가 아닙니다. Julia에서 함수를 정의하는 기본 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia에서 함수는 인수 값의 튜플을 반환 값에 매핑하는 객체입니다. Julia 함수는 함수가 프로그램의 전역 상태에 의해 변경되고 영향을받을 수 있다는 점에서 순수한 수학 함수가 아닙니다. Julia에서 함수를 정의하는 기본 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c8982a95e255a5e2cc9c0e2345b6061fd0be88f" translate="yes" xml:space="preserve">
          <source>In Julia, a function may contain multiple concrete implementations (called &lt;em&gt;Methods&lt;/em&gt;), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</source>
          <target state="translated">Julia에서 함수는 다중 디스패치를 ​​통해 선택된 여러 구체적인 구현 ( &lt;em&gt;Methods&lt;/em&gt; 라고 함 )을 포함 할 수 있지만 Python의 함수에는 단일 구현 (다형성 없음)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f670eb9f52ba71aa8ad7654d94717d406c50aa0" translate="yes" xml:space="preserve">
          <source>In Julia, a new local scope is introduced by most code blocks, including loops and &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas &lt;code&gt;if&lt;/code&gt; blocks do not introduce a new local scope in both languages.</source>
          <target state="translated">Julia에서는 루프 및 &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt; 를 포함한 대부분의 코드 블록에 의해 새로운 로컬 범위가 도입되었습니다 . 이해 (목록, 생성기 등)는 Python과 Julia 모두에서 새로운 로컬 범위를 도입하는 반면 &lt;code&gt;if&lt;/code&gt; 블록은 두 언어 모두에서 새로운 로컬 범위를 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">Julia에서 a &lt;code&gt;a:b&lt;/code&gt; 와 같은 범위 는 R에서와 같은 벡터를 줄인 것이 아니라 높은 메모리 오버 헤드없이 반복에 사용되는 특수화 된 &lt;code&gt;AbstractRange&lt;/code&gt; 객체입니다. 범위를 벡터로 변환하려면 &lt;code&gt;collect(a:b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">Julia에서 함수에 대한 모든 인수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;공유&lt;/a&gt; (예 : 포인터)를 통해 전달됩니다 . 일부 기술 컴퓨팅 언어는 값별로 배열을 전달하므로 호출자의 값을 수신자가 실수로 수정하는 것을 방지하지만 원하지 않는 배열의 복사를 피하는 것이 어렵습니다. 관례 적으로 함수 이름은 &lt;code&gt;!&lt;/code&gt; 로 끝납니다 . 는 하나 이상의 인수 값을 변경하거나 제거함을 나타냅니다 (예 : &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; 비교&lt;/a&gt; ). 수신자는 변경하지 않을 입력을 수정하지 않도록 명시적인 사본을 작성해야합니다. &lt;code&gt;!&lt;/code&gt; 와 같은 이름을 가진 함수를 추가하여 많은 비 돌연변이 함수가 구현됩니다 . 입력의 명시 적 사본이 끝날 때 해당 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">Julia에서 &lt;code&gt;array[1:5, :]&lt;/code&gt; 와 같은 배열 &quot;슬라이스&quot;식은 해당 데이터의 복사본을 만듭니다 (할당의 왼쪽을 제외하고 &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns &lt;code&gt;array&lt;/code&gt; 해당 부분 대신 ). 슬라이스에서 많은 작업을 수행하는 경우 원래 배열로 인덱싱하는 것보다 작은 연속 복사본으로 작업하는 것이 더 효율적이므로 성능에 좋습니다. 반면에 슬라이스에서 몇 가지 간단한 작업을 수행하는 경우 할당 및 복사 작업 비용이 상당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">Julia에서 지정된 유형의 최대 표현 가능 값을 초과하면 랩 어라운드 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 배열이면 &lt;code&gt;A == B&lt;/code&gt; 와 같은 논리 비교 연산 은 부울 배열을 반환하지 않습니다. 대신 &lt;code&gt;A .== B&lt;/code&gt; 를 사용하고 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같은 다른 부울 연산자에도 유사하게 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d1570d580f73be0193694bd4c3eb228fc48008c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing a matrix with arrays like &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a vector that contains the values of cell &lt;code&gt;[1,1]&lt;/code&gt; and &lt;code&gt;[2,3]&lt;/code&gt; in the matrix. &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; in Julia is equivalent with &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; in Python. &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; in Python is equivalent with &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; in Julia.</source>
          <target state="translated">Julia에서 &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; 과 같은 배열로 행렬을 인덱싱하는 것은 첫 번째 및 두 번째 행과 첫 번째 및 세 번째 열이 교차하는 부분을 포함하는 부분 행렬을 나타냅니다. Python에서 &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; 은 행렬의 &lt;code&gt;[1,1]&lt;/code&gt; 및 &lt;code&gt;[2,3]&lt;/code&gt; 셀 값을 포함하는 벡터를 나타냅니다 . Julia의 &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; 은 &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; 와 동일합니다. Python의 &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; 는 Julia의 X [[CartesianIndex (1,1), CartesianIndex (2,3)]] 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">Julia에서 배열, 문자열 등의 인덱싱은 0 기반이 아닌 1 기반입니다.</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">Julia에서는 Python과 같지만 R과 달리 Julia는 삼중 따옴표 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; 문자열을 작성할 수 있습니다 . 이 구문은 줄 바꿈이 포함 된 문자열을 구성하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="6ff09f4efca3c4661d730a90a1c75212c7df44ad" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Julia에서 소수점이없는 리터럴 숫자 (예 : &lt;code&gt;42&lt;/code&gt; )는 부동 소수점 숫자 대신 정수를 만듭니다. 결과적으로 일부 작업은 부동을 예상하는 경우 도메인 오류를 발생시킬 수 있습니다. 예를 들어, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; 는 결과가 정수가 아니기 때문에 &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;도메인 오류&lt;/a&gt; 를 발생시킵니다 ( 자세한 내용 은 도메인 오류에 대한 FAQ 항목 참조).</target>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Julia에서 소수점이없는 리터럴 숫자 (예 : &lt;code&gt;42&lt;/code&gt; )는 부동 소수점 숫자 대신 정수를 만듭니다. 결과적으로 일부 작업은 실수를 예상하면 도메인 오류를 발생시킬 수 있습니다. 예를 들어, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; 결과가 정수가 아니므로 2 ^ a &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;에서 도메인 오류가 발생&lt;/a&gt; 합니다 (자세한 내용 은 도메인 오류에 대한 FAQ 항목 참조).</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">Julia에서 소수점이없는 리터럴 숫자 (예 : &lt;code&gt;42&lt;/code&gt; )는 &lt;code&gt;Int&lt;/code&gt; 유형의 부호있는 정수를 작성 하지만 기계 단어 크기에 맞지 않는 리터럴은 자동으로 &lt;code&gt;Int64&lt;/code&gt; 와 같은 더 큰 크기 유형으로 승격됩니다 ( &lt;code&gt;Int&lt;/code&gt; 가 &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int128&lt;/code&gt; 또는 임의로 큰 &lt;code&gt;BigInt&lt;/code&gt; 유형입니다. 부호없는 및 / 또는 부호있는 대 부호없는 것을 나타내는 &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;LL&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , &lt;code&gt;ULL&lt;/code&gt; 과 같은 숫자 리터럴 접미사는 없습니다 . 십진 리터럴은 항상 부호가 있고 16 진 리터럴 ( &lt;code&gt;0x&lt;/code&gt; 로 시작)C / C ++와 같이) 서명되지 않습니다. C / C ++ / Java와 달리 16 진 리터럴은 Julia의 10 진 리터럴과 달리 선행 0을 포함하여 리터럴 의 &lt;em&gt;길이&lt;/em&gt; 에 따라 유형이 있습니다. 예를 들어, &lt;code&gt;0x0&lt;/code&gt; 및 &lt;code&gt;0x00&lt;/code&gt; 으로는 입력이 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0x000&lt;/code&gt; 및 &lt;code&gt;0x0000&lt;/code&gt; 입력이 &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; 입력 한 5~8 16 진수로 다음 리터럴 &lt;code&gt;UInt32&lt;/code&gt; , 9, 16 진수 숫자 입력 &lt;code&gt;UInt64&lt;/code&gt; 17 내지 32 진수 숫자 입력 &lt;code&gt;UInt128&lt;/code&gt; 를 . 16 진 마스크를 정의 할 때이를 고려해야합니다. 예를 들어 &lt;code&gt;~0xf == 0xf0&lt;/code&gt; 은 &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; 과 매우 다릅니다 . 64 비트 &lt;code&gt;Float64&lt;/code&gt; 및 32 비트 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 비트 리터럴은 각각 &lt;code&gt;1.0&lt;/code&gt; 및 &lt;code&gt;1.0f0&lt;/code&gt; 으로 표시 됩니다. 부동 소수점 리터럴은 정확하게 표현할 수없는 경우 반올림됩니다 ( &lt;code&gt;BigFloat&lt;/code&gt; 유형으로 승격되지 않음 ). 부동 소수점 리터럴은 C / C ++에 가까운 동작입니다. 진수 (접두사 &lt;code&gt;0o&lt;/code&gt; 에서 (접두사) 및 이진 &lt;code&gt;0b&lt;/code&gt; 리터럴)도 부호로 처리된다.</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">Julia에서 결 측값은 &lt;code&gt;NA&lt;/code&gt; 가 아닌 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 객체 로 표시됩니다 . 사용 &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;ismissing.(x)&lt;/code&gt; 는 벡터의 요소 와이즈 동작) 대신 &lt;code&gt;is.na(x)&lt;/code&gt; . &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; 의&lt;/a&gt; 기능은 일반적으로 사용되는 대신 &lt;code&gt;na.rm=TRUE&lt;/code&gt; (일부 경우에 특히 기능은 가지고 있지만 &lt;code&gt;skipmissing&lt;/code&gt; 의 인수).</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">Julia에서 계수는 &lt;code&gt;a %% b&lt;/code&gt; 아닌 &lt;code&gt;mod(a, b)&lt;/code&gt; 입니다. Julia의 &lt;code&gt;%&lt;/code&gt; 는 나머지 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="d79893a1ef0fe5a790c5d1bb686e33bb258470f4" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Julia에서 대부분의 연산자는 특수 구문을 지원하는 함수일뿐입니다. (예외는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 특수한 평가 의미를 가진 연산자입니다 . &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; 에서는 연산자를 평가하기 전에 피연산자를 평가 하지 않아야하므로 이러한 연산자는 함수가 될 수 없습니다 .) 따라서 괄호로 묶인 인수 목록을 사용하여 적용 할 수도 있습니다. , 다른 기능과 마찬가지로 :</target>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Julia에서 대부분의 연산자는 특수 구문을 지원하는 함수일뿐입니다. 단, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 특수 평가 의미론을 가진 연산자는 예외 입니다. &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;단락&lt;/a&gt; 연산자 평가에서는 연산자를 평가하기 전에 피연산자를 평가하지 않기 때문에이 연산자는 함수가 될 수 없습니다 . 따라서 괄호로 묶은 인수 목록을 사용하여이를 적용 할 수도 있습니다. 다른 기능과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">Julia에서는 여러 값이 반환되어 튜플로 지정됩니다 &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; 예 : (a, b) = (1, 2) 또는 &lt;code&gt;a, b = 1, 2&lt;/code&gt; . MATLAB에서 반환되는 값의 수에 따라 선택적 작업을 수행하는 데 종종 사용되는 MATLAB의 &lt;code&gt;nargout&lt;/code&gt; 은 Julia에 없습니다. 대신 사용자는 선택적 및 키워드 인수를 사용하여 유사한 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">Julia에서는 모든 데이터 구조가 논리적 인덱싱을 지원하지는 않습니다. 또한 Julia의 논리적 인덱싱은 인덱싱되는 객체와 동일한 길이의 벡터 만 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">Julia에서는 여러 값 반환을 시뮬레이션하기 위해 튜플 값을 반환합니다. 그러나 괄호없이 튜플을 생성하고 구조를 해제 할 수 있으므로 단일 튜플 값이 아닌 여러 값이 반환된다는 착시를 제공합니다. 예를 들어 다음 함수는 값 쌍을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia에서는 &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; 와 같이 인수가없는 함수를 호출하려면 괄호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">줄리아에서 같은 감소 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 하나의 인자로 호출 할 때와 같이, 어레이의 모든 요소를 통해 수행되는 &lt;code&gt;sum(A)&lt;/code&gt; 경우에도, &lt;code&gt;A&lt;/code&gt; 는 하나 이상의 치수를 갖는다.</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">Julia에서는 스파 스 행렬이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;CSC (Compressed Sparse Column) 형식으로&lt;/a&gt; 저장 됩니다 . Julia 스파 스 행렬의 유형은 &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt; . 여기서 &lt;code&gt;Tv&lt;/code&gt; 는 저장된 값의 유형이고 &lt;code&gt;Ti&lt;/code&gt; 는 열 포인터 및 행 인덱스를 저장하기위한 정수 유형입니다. &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 의 내부 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5c3c759720c16030d42ce9ed7346415b8cda62d" translate="yes" xml:space="preserve">
          <source>In Julia, the &lt;code&gt;adjoint&lt;/code&gt; function performs conjugate transposition; in MATLAB, &lt;code&gt;adjoint&lt;/code&gt; provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</source>
          <target state="translated">Julia에서 &lt;code&gt;adjoint&lt;/code&gt; 함수는 켤레 전치를 수행합니다. MATLAB에서 &lt;code&gt;adjoint&lt;/code&gt; 는 보조 인자 행렬의 전치 인 &quot;adjugate&quot;또는 클래식 adjoint를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">Julia에서는 &lt;code&gt;x&lt;/code&gt; 를 함수에 인수로 전달 하여 변수 &lt;code&gt;x&lt;/code&gt; 의 바인딩을 변경할 수 없습니다 . 위 예제에서 &lt;code&gt;change_value!(x)&lt;/code&gt; 를 호출 할 때 &lt;code&gt;y&lt;/code&gt; 는 새로 생성 된 변수이며 처음에는 &lt;code&gt;x&lt;/code&gt; 값에 바인딩됩니다 . 즉 &lt;code&gt;10&lt;/code&gt; ; 그러면 &lt;code&gt;y&lt;/code&gt; 는 상수 &lt;code&gt;17&lt;/code&gt; 로 리바운드 되지만 외부 스코프 의 변수 &lt;code&gt;x&lt;/code&gt; 는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e2d42d83a28f2989051e64390c6b07102af77a3d" translate="yes" xml:space="preserve">
          <source>In Julia, the commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;), unlike in Python, where &lt;code&gt;int&lt;/code&gt; is an arbitrary length integer. This means in Julia the &lt;code&gt;Int&lt;/code&gt; type will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">Julia에서 일반적으로 사용되는 &lt;code&gt;Int&lt;/code&gt; 유형 은 &lt;code&gt;int&lt;/code&gt; 가 임의의 길이 정수인 Python과 달리 기계 정수 유형 ( &lt;code&gt;Int32&lt;/code&gt; 또는 &lt;code&gt;Int64&lt;/code&gt; )에 해당 합니다. 이것은 Julia에서 &lt;code&gt;Int&lt;/code&gt; 유형이 오버플로되어 &lt;code&gt;2^64 == 0&lt;/code&gt; 이라는 것을 의미 합니다. 더 큰 값이 필요한 경우 &lt;code&gt;Int128&lt;/code&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;Float64&lt;/code&gt; 와 같은 부동 소수점 유형과 같은 다른 적절한 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">줄리아에서 컬렉션의 요소 플랫 연산자를 사용하는 함수의 인수로서 전달 될 수있다 &lt;code&gt;...&lt;/code&gt; , 마찬가지로 &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d494edc49792467615a5bbbdd57215d8dd338e99" translate="yes" xml:space="preserve">
          <source>In Julia, the exponentiation operator is &lt;code&gt;^&lt;/code&gt;, not &lt;code&gt;**&lt;/code&gt; as in Python.</source>
          <target state="translated">줄리아에서 지수 연산자입니다 &lt;code&gt;^&lt;/code&gt; 하지, &lt;code&gt;**&lt;/code&gt; 파이썬으로.</target>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">Julia에서 연산자 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; )는 비트 XOR 연산을 수행합니다 ( 예 : C / C ++에서 &lt;code&gt;^&lt;/code&gt; ) . 또한 비트 연산자는 C / ++와 우선 순위가 같지 않으므로 괄호가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">Julia에서 연산자 &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;|&lt;/code&gt; , 및 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) 는 MATLAB에서 각각 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , 및 &lt;code&gt;xor&lt;/code&gt; 에 해당 하는 비트 단위 연산을 수행 하며 , C와 달리 Python의 비트 연산자와 유사한 우선 순위를 갖습니다. 이들은 어레이에 스칼라 또는 요소 와이즈에 작동 가능 논리 어레이를 결합하는 데 사용될 수 있지만, 동작들의 순서의 차이에 주목 : 괄호 등의 요소를 선택하기 위해 (필요 수 &lt;code&gt;A&lt;/code&gt; 는 1 또는 2를 사용 동일 &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e2a4d55a36175a20161ae921b2cf660cd6f7ede" translate="yes" xml:space="preserve">
          <source>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, &lt;code&gt;A * B&lt;/code&gt; in Julia performs matrix multiplication, not element-wise multiplication as in Python. &lt;code&gt;A * B&lt;/code&gt; in Julia is equivalent with &lt;code&gt;A @ B&lt;/code&gt; in Python, whereas &lt;code&gt;A * B&lt;/code&gt; in Python is equivalent with &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Julia에서 행렬 유형에 대한 표준 연산자는 행렬 연산 인 반면 Python에서는 표준 연산자가 요소 별 연산입니다. 두 경우 와 &lt;code&gt;B&lt;/code&gt; 는 행렬이며, &lt;code&gt;A * B&lt;/code&gt; 줄리아 수행에 파이썬과 승산하지 소자 현명한 행렬 곱셈. &lt;code&gt;A * B&lt;/code&gt; 줄리아의은과 동일하다 &lt;code&gt;A @ B&lt;/code&gt; 반면 파이썬 &lt;code&gt;A * B&lt;/code&gt; 파이썬가 함께 동등 &lt;code&gt;A .* B&lt;/code&gt; 줄리아있다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">Julia에서는 함수에 할당되거나 함수에 전달 될 때 값이 복사되지 않습니다. 함수가 배열을 수정하면 변경 사항이 호출자에게 표시됩니다. 이것은 R과 매우 다르며 새로운 함수가 큰 데이터 구조에서 훨씬 더 효율적으로 작동 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">줄리아에서, 변수 인수는 플랫 연산자 사용하여 지정됩니다 &lt;code&gt;...&lt;/code&gt; R 달리 항상 특정 변수의 이름을 다음과,,,하는 &lt;code&gt;...&lt;/code&gt; 고립에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">Julia에서 벡터와 행렬은 R &lt;code&gt;cbind&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;rbind&lt;/code&gt; 및 cbind가 아니라 &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; 를&lt;/a&gt; 사용하여 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">Julia에서는 부품에 독립적으로 액세스하여 해당 문자열을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">Julia에서는 공백이 C / C ++와 달리 중요하므로 Julia 프로그램에서 공백을 추가 / 제거 할 때주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Julia에서는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 와 같은 &lt;em&gt;값을&lt;/em&gt; 전달할 수 없습니다 . 그러나 파라 메트릭 유형을 디스패치 할 수 있으며 Julia를 사용하면 &quot;일반 비트&quot;값 (유형, 기호, 정수, 부동 소수점 숫자, 튜플 등)을 유형 매개 변수로 포함 할 수 있습니다. 일반적인 예는 &lt;code&gt;Array{T,N}&lt;/code&gt; 의 차원 매개 변수입니다 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 (예 : &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; )이지만 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">MATLAB에서 원하지 않는 값을 제거하는 관용적 방법은 식 &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; 또는 명령문 &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; 에서와 같이 논리적 인덱싱을 사용 하여 &lt;code&gt;x&lt;/code&gt; 를 제자리에서 수정하는 것입니다. 대조적으로 Julia는 고차 함수 &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 제공합니다 ! 사용자가 해당 음역 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 및 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 에 대한 대안으로 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 및 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 를 작성할 수 있습니다 . 3] . &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 사용 ! 임시 배열 사용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="af1c31248c4802059b749cc923a13d7acffd80c9" translate="yes" xml:space="preserve">
          <source>In Python, the majority of values can be used in logical contexts (e.g. &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; means the following block is executed, and &lt;code&gt;if &quot;&quot;:&lt;/code&gt; means it is not). In Julia, you need explicit conversion to &lt;code&gt;Bool&lt;/code&gt; (e.g. &lt;code&gt;if &quot;a&quot;&lt;/code&gt; throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Python에서 대부분의 값은 논리적 컨텍스트에서 사용할 수 있습니다 (예 : &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; 다음 블록이 실행 됨을 의미하고 &lt;code&gt;if &quot;&quot;:&lt;/code&gt; 실행 되지 않음을 의미 함). Julia에서는 &lt;code&gt;Bool&lt;/code&gt; 로 명시 적으로 변환해야합니다 (예 : &lt;code&gt;if &quot;a&quot;&lt;/code&gt; 가 예외를 throw하는 경우). Julia에서 비어 있지 않은 문자열을 테스트하려면 명시 적으로 &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">R에서 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; 는 &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">R에서 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; 는 &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">R에서 원하지 않는 값을 제거하는 관용적 방법은 식 &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; 또는 명령문 &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; 과 같이 논리적 인덱싱을 사용 하여 &lt;code&gt;x&lt;/code&gt; 를 제자리에서 수정하는 것입니다. 대조적으로 Julia는 고차 함수 &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 제공합니다 ! 사용자가 해당 음역 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 및 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 에 대한 대안으로 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 및 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 를 작성할 수 있습니다 . 3] . &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 사용 ! 임시 배열 사용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">R에서 성능은 벡터화가 필요합니다. Julia에서는 거의 반대가 사실입니다. 가장 성능이 좋은 코드는 종종 벡터화되지 않은 루프를 사용하여 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">선형 대수 문맥에서 이는 &lt;code&gt;vector + vector&lt;/code&gt; 및 &lt;code&gt;vector * scalar&lt;/code&gt; 와 같은 연산 이 정의되어 있어도 결과 루프가 주변 계산과 융합 될 수 있기 때문에 &lt;code&gt;vector .* scalar&lt;/code&gt; &lt;code&gt;vector .+ vector&lt;/code&gt; 및 벡터. * 스칼라 를 대신 사용하는 것이 유리할 수 있음을 의미합니다 . . 예를 들어 두 가지 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">로컬 범위에서 다음과 같은 경우를 제외하고 모든 변수는 상위 전역 범위 블록에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">모듈에서 &lt;code&gt;path&lt;/code&gt; (상대 또는 절대) 로 지정된 파일 이 사전 컴파일에 대한 종속성 임을 선언하십시오 . 즉,이 파일이 변경되면 모듈을 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">어떤 의미에서 Julia는 &quot;자동 승격 없음&quot;범주에 속합니다. 수학 연산자는 특별한 구문을 가진 함수일 뿐이며 함수의 인수는 자동으로 변환되지 않습니다. 그러나 수학 연산을 다양한 혼합 인수 유형에 적용하는 것은 다형성 다중 디스패치의 극단적 인 경우입니다. Julia의 디스패치 및 유형 시스템이 특히 처리하기에 적합합니다. 수학 피연산자의 &quot;자동&quot;승격은 단순히 특수 응용 프로그램으로 나타납니다. Julia에는 피연산자 유형의 조합에 대한 특정 구현이 없을 때 호출되는 수학 연산자에 대해 미리 정의 된 catch-all 디스패치 규칙이 제공됩니다. 이 포괄 규칙은 먼저 사용자 정의 승격 규칙을 사용하여 모든 피연산자를 공통 유형으로 승격합니다.그런 다음 결과 값이 동일한 유형의 해당 연산자의 특수 구현을 호출하십시오. 사용자 정의 유형은 다른 유형과의 변환 방법을 정의하고 다른 유형과 혼합 될 때 승격해야하는 유형을 정의하는 소수의 승격 규칙을 제공하여이 승격 시스템에 쉽게 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a6dfe6183c6c2d1bbad1fc9762d95e2e3097dd" translate="yes" xml:space="preserve">
          <source>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</source>
          <target state="translated">프로그래밍 방식으로 키워드 인수를 정의하는 방법과 유사한 방식으로, &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; 쌍 값을 제공 하거나 튜플 리터럴 내부의 세미콜론 뒤에 이러한 쌍을 생성하는 반복자를 스플래 팅하여 명명 된 튜플을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Julia는 다차원 배열에 대한 지원 &lt;code&gt;using LinearAlgebra&lt;/code&gt; 를 사용하여 로드 할 수있는 많은 일반적이고 유용한 선형 대수 연산의 기본 구현을 제공합니다 . &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;inv&lt;/code&gt; 와 같은 기본 조작 이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 외에도 작업을 효과적으로 사용하려면 몇 가지 다른 기본 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">&lt;code&gt;using Base&lt;/code&gt; 를 사용하는 것 외에도 모듈은 자동으로 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 정의를 포함 하고 해당 모듈의 전체 범위 내에서 표현식 / 파일을 평가하는 함수를 &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">위의 반복 가능하고 색인 가능한 모든 메소드 외에도 이러한 유형은 서로 상호 작용할 수 있으며 Julia Array에 &lt;code&gt;AbstractArrays&lt;/code&gt; 에 정의 된 대부분의 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">선형 인덱싱 외에, 특정 상황에서 &lt;code&gt;N&lt;/code&gt; 차원 배열은 &lt;code&gt;N&lt;/code&gt; 개보다 적거나 많은 인덱스로 인덱싱 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">Julia 포워드는 기본적으로 멀티 스레딩을 지원합니다. 이 섹션은 실험용이며 향후 인터페이스가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">주어진 인수 목록 외에도 모든 매크로에는 &lt;code&gt;__source__&lt;/code&gt; 및 &lt;code&gt;__module__&lt;/code&gt; 이라는 추가 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="f681189a6c7a87dd61774b09673a55a0c0fa70a2" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">또한 Julia는 (성능 또는 메모리상의 이유로) 문제에 더 적합한 형태로 행렬을 사전 인수 분해하여 선형 풀이 또는 행렬 지수화와 같은 문제의 속도를 높이는 데 사용할 수있는 많은 &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;인수 분해&lt;/a&gt; 를 제공합니다 . 자세한 내용은 &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; 에&lt;/a&gt; 대한 문서 를 참조하십시오. 예로서:</target>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">또한 Julia는 매트릭스를 문제에보다 적합한 형태 (예 : 성능 또는 메모리 이유로)로 사전 인수 화하여 선형 해상 또는 행렬 지수와 같은 문제를 가속화하는 데 사용할 수있는 많은 &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;인수 분해&lt;/a&gt; 를 제공합니다 . 자세한 내용은 &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; 에&lt;/a&gt; 대한 설명서 를 참조하십시오. 예로서:</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">모든 경우에 모호성은 숫자 리터럴로 해석하기 위해 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">위의 모든 모드에서 실행 된 행은 내역 파일에 저장되어 검색 할 수 있습니다. 이전 기록을 통해 증분 검색을 시작하려면 &lt;code&gt;^R&lt;/code&gt; 키 &amp;ndash; &lt;code&gt;r&lt;/code&gt; 키 와 함께 제어 키를 입력하십시오 . 프롬프트가 &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; 바뀌고 입력하면 검색어가 따옴표로 나타납니다. 쿼리와 일치하는 가장 최근 결과는 더 많이 입력 될 때 콜론 오른쪽으로 동적으로 업데이트됩니다. 동일한 쿼리를 사용하여 이전 결과를 찾으려면 &lt;code&gt;^R&lt;/code&gt; 다시 입력하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">이러한 모든 경우에 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 궁극적으로 작업을 대기 및 다시 시작 하는 &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 개체에서 작동 합니다. 작업이 &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하면 작업이 실행할 수 없는 것으로 표시되고 조건 대기열에 추가 된 후 스케줄러로 전환됩니다. 그런 다음 스케줄러는 실행할 다른 작업을 선택하거나 외부 이벤트 대기를 차단합니다. 모든 것이 잘 진행되면 이벤트 핸들러는 조건에 대해 &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 조건을 기다리는 태스크를 다시 실행할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">이 모든 경우에 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;bar&lt;/code&gt; 에 전달 된 후행 값의 튜플에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">종합 토폴로지 (기본값)에서 모든 작업자는 일반 TCP 소켓을 통해 서로 연결됩니다. 따라서 클러스터 노드의 보안 정책은 임시 포트 범위 (OS에 따라 다름)의 작업자간에 자유로운 연결을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">Julia와 MATLAB에서 변수 &lt;code&gt;ans&lt;/code&gt; 는 대화식 세션에서 발행 된 마지막 표현식의 값으로 설정됩니다. Julia에서는 MATLAB과 달리 Julia 코드가 비 대화식 모드에서 실행될 때 &lt;code&gt;ans&lt;/code&gt; 가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">REPL의 Julian 및 help 모드에서 함수 또는 유형의 처음 몇 문자를 입력 한 다음 tab 키를 눌러 모든 일치하는 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">원격 참조의 경우 로컬 참조 객체의 크기는 매우 작지만 원격 노드에 저장된 값은 상당히 클 수 있습니다. 로컬 객체는 즉시 수집되지 않을 수 있으므로 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 의 로컬 인스턴스 또는 페치되지 않은 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 호출하는 것이 좋습니다 . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;fetch&lt;/code&gt; 를 호출 하면 원격 저장소에서 해당 참조가 제거되므로 가져온 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서는 필요하지 않습니다 . 명시 적으로 &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 를 호출 하면 원격 노드에 즉시 메시지가 전송되어 값에 대한 참조를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">경우에 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 줄리아 객체를 취하여으로 바꿀 필요가 &lt;code&gt;Ptr&lt;/code&gt; ,이 기능을 정의하고 변환을 수행하는 데 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 안전하게 변환 할 수 없습니다 &lt;code&gt;T&lt;/code&gt; , 달리 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;cconvert&lt;/code&gt; 는 에서 종류의 서로 다른의 객체 반환 할 수 있습니다 &lt;code&gt;T&lt;/code&gt; 그러나 적합, &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 핸들을. &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 의 결과가 더 이상 필요하지 않을 때까지이 함수의 결과는 유효합니다 (GC에 대해) . 이것은 &lt;code&gt;ccall&lt;/code&gt; 이 액세스 할 메모리를 할당하는 데 사용될 수 있습니다 . 여러 객체를 할당해야하는 경우 해당 객체의 튜플을 반환 값으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">여러 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 을 혼합 하고 차원을 추적 하려는 경우 스타일은 &lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt; 생성자 를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">상태 변경을 수행하거나 파일과 같은 리소스를 사용하는 코드에는 일반적으로 코드가 완료 될 때 수행해야하는 정리 작업 (예 : 파일 닫기)이 있습니다. 예외로 인해이 작업이 복잡해질 수 있습니다. 정상적인 종료에 도달하기 전에 코드 블록이 종료 될 수 있기 때문입니다. &lt;code&gt;finally&lt;/code&gt; 키워드는 몇 가지 코드를 실행할 수있는 방법을 제공 할 때 코드가 종료 주어진 블록에 관계없이 종료 방법.</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">함수를 정의 할 때 많은 다른 인수를 하나의 인수로 슬러 핑하는 것을 나타내는 &lt;code&gt;...&lt;/code&gt; 연산자를 사용하는 것과는 달리 &lt;code&gt;...&lt;/code&gt; 연산자는 단일 함수 인수를 여러 인수로 분리 할 때도 사용됩니다. 함수 호출의 컨텍스트 이 사용은 &lt;code&gt;...&lt;/code&gt; 스플래라고합니다 :</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">대조적으로 &lt;code&gt;for i = 1:length(A)&lt;/code&gt; 가진 반복 &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; 하는&lt;/a&gt; 임의의 어레이 형 반복하는 효율적인 방법을 제공한다.</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">반대로, 일단 &lt;code&gt;m&lt;/code&gt; 이 구성되면 &lt;code&gt;m.a&lt;/code&gt; 의 유형을 변경할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">일반적으로 깊게 중첩 된 루프 나 조건부 등을 포함하여 함수 본문 내 어디에서나 &lt;code&gt;return&lt;/code&gt; 문을 배치 할 수 있지만 &lt;code&gt;do&lt;/code&gt; 블록에 주의하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">일반적으로 브로드 캐스트 작업은 인수와 함께 적용 할 함수를 보유 하는 지연된 &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너로 표시됩니다 . 이러한 인수 자체는 더 중첩 된 &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너 일 수 있으며, 평가할 큰 표현식 트리를 형성합니다. &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너 의 중첩 트리는 암시 적 점 구문으로 직접 구성됩니다. &lt;code&gt;5 .+ 2.*x&lt;/code&gt; 는 &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; 로 일시적으로 표현됩니다 . &lt;code&gt;copy&lt;/code&gt; 요청을 통해 즉시 실현되므로 사용자에게 보이지 않습니다. 이지만이 컨테이너는 사용자 정의 유형의 작성자에게 브로드 캐스트의 확장 성을위한 기초를 제공합니다. 내장 된 브로드 캐스트 메커니즘은 인수를 기반으로 결과 유형과 크기를 결정하고 할당 한 다음 최종적으로 &lt;code&gt;Broadcasted&lt;/code&gt; 객체 의 구현을 기본값 으로 복사합니다. &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; 메서드입니다. 대체 폴백 &lt;code&gt;broadcast&lt;/code&gt; 및 &lt;code&gt;broadcast!&lt;/code&gt; 메소드 는 작업 의 일시적인 &lt;code&gt;Broadcasted&lt;/code&gt; 표현을 유사하게 구성 하여 동일한 코드 경로를 따를 수 있습니다. 이것은 커스텀 배열 구현이 그들 만의 &lt;code&gt;copyto!&lt;/code&gt; 를 제공 할 수있게합니다 !방송을 사용자 정의하고 최적화하는 전문화. 이것은 다시 계산 된 방송 스타일에 의해 결정됩니다. 이것은 &lt;code&gt;Broadcasted&lt;/code&gt; 유형 의 첫 번째 유형 매개 변수로 저장되어 디스패치 및 전문화가 가능하도록 하는 작업의 중요한 부분 입니다.</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">일반적으로 한 줄에 &lt;code&gt;N&lt;/code&gt; 개의 샘플이 수집 된 경우 &lt;code&gt;sqrt(N)&lt;/code&gt; 순서로 불확실성을 기대할 수 있습니다 (컴퓨터가 다른 작업으로 얼마나 바빠지는지 등 다른 소음원 제외). 이 규칙의 주요 예외는 가비지 수집으로, 드물게 실행되지만 비용이 많이 드는 경향이 있습니다. Julia의 가비지 수집기는 C로 작성되므로 아래에 설명 된 &lt;code&gt;C=true&lt;/code&gt; 출력 모드를 사용하거나 &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt; 을 사용하여 이러한 이벤트를 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 구문은 모든 컨테이너를 반복 할 수 있습니다. 이 경우 대체 키워드 &lt;code&gt;in&lt;/code&gt; 또는 완전히 동등한 키워드 ) 또는 &lt;code&gt;&amp;isin;&lt;/code&gt; 가 일반적으로 &lt;code&gt;=&lt;/code&gt; 대신에 사용됩니다 . 코드를보다 명확하게 읽을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">일반적으로 Julia backtick 구문은 백틱과 마찬가지로 쉘 명령을 잘라서 붙여 넣기 만하면 작동합니다. 이스케이프, 인용 및 보간 동작은 쉘과 동일합니다. 유일한 차이점은 보간이 통합되어 있고 단일 문자열 값이 무엇인지에 대한 Julia의 개념과 여러 값을위한 컨테이너가 무엇인지 알고 있다는 것입니다. Julia에서 위의 두 가지 예를 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">일반적으로 다른 많은 기술 컴퓨팅 언어와 달리 Julia는 프로그램이 벡터화 된 스타일로 작성되어 성능을 기대하지 않습니다. Julia의 컴파일러는 형식 유추를 사용하고 스칼라 배열 인덱싱에 최적화 된 코드를 생성하여 성능을 저하시키지 않고 때때로 적은 메모리를 사용하지 않고도 편리하고 읽기 쉬운 스타일로 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;display&lt;/code&gt; 출력이 &lt;code&gt;stdout&lt;/code&gt; 이라고 가정 할 수 없습니다 . 예를 들어, &lt;code&gt;display(x)&lt;/code&gt; 는 이미지가있는 별도의 창을 열 수 있습니다. &lt;code&gt;display(x)&lt;/code&gt; 는 &quot; 현재 출력 장치에 대해 최상의 방법으로 &lt;code&gt;x&lt;/code&gt; 를 표시합니다&quot;를 의미 합니다. 당신이 원하는 경우 REPL 같은 이동 보장 텍스트 출력 &lt;code&gt;stdout&lt;/code&gt; , 사용 &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="7ec09f4dcceb1c007da785592e4c12f3a7b2638d" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">일반적으로 &lt;code&gt;display&lt;/code&gt; 출력이 &lt;code&gt;stdout&lt;/code&gt; 으로 이동 한다고 가정 할 수 없습니다 ( &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 와 달리 ). 예를 들어, &lt;code&gt;display(x)&lt;/code&gt; 는 이미지가있는 별도의 창을 열 수 있습니다. &lt;code&gt;display(x)&lt;/code&gt; 는 &quot; 현재 출력 장치에 대해 가능한 가장 좋은 방법으로 &lt;code&gt;x&lt;/code&gt; 를 표시 합니다.&quot;를 의미합니다. 당신이 원하는 경우 REPL 같은 이동 보장 텍스트 출력 &lt;code&gt;stdout&lt;/code&gt; , 사용 &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">결과를 해석 할 때 몇 가지 중요한 세부 사항이 있습니다. 언더 &lt;code&gt;user&lt;/code&gt; 설정, 직접 REPL에서 호출하는 함수의 첫 번째 줄 인해 REPL 코드 자체에서 일어나는 이벤트에 할당을 전시 할 예정이다. 더 중요한 것은 Julia의 컴파일러가 Julia로 작성되기 때문에 JIT 컴파일도 할당 횟수에 추가됩니다 (일반적으로 메모리 할당이 필요함). 권장되는 절차는 분석하려는 모든 명령을 실행하여 컴파일을 강제 한 다음 &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 모든 할당 카운터를 재설정하는 것입니다. 마지막으로 원하는 명령을 실행하고 Julia를 종료하여 &lt;code&gt;.mem&lt;/code&gt; 파일 생성을 트리거 합니다.</target>
        </trans-unit>
        <trans-unit id="dfcc306e80c7cf321f53ff98ff95ac030d502bfd" translate="yes" xml:space="preserve">
          <source>In loops and &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt;, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block, as demonstrated by this example:</source>
          <target state="translated">loops 및 &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt; 에서 본문 범위에 도입 된 새 변수는 다음 예제에서 설명하는 것처럼 루프 본문이 &lt;code&gt;let&lt;/code&gt; 블록 으로 둘러싸인 것처럼 각 루프 반복에 대해 새로 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b38f63219b850b33b9abc3b16ad8edd611a5f30" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++, Java, Python 및 Ruby와 같은 주류 객체 지향 언어에서 복합 유형에는 이름이 지정된 함수도 연관되어 있으며 그 조합을 &quot;객체&quot;라고합니다. Ruby 또는 Smalltalk와 같은 순수한 객체 지향 언어에서는 합성 여부에 관계없이 모든 값이 객체입니다. C ++ 및 Java를 포함한 덜 순수한 객체 지향 언어에서 정수 및 부동 소수점 값과 같은 일부 값은 객체가 아닌 반면 사용자 정의 복합 유형의 인스턴스는 연관된 메소드가있는 실제 객체입니다. Julia에서 모든 값은 객체이지만 함수는 작동하는 객체와 함께 제공되지 않습니다. 이는 Julia가 다중 디스패치에서 사용할 함수 방법을 선택하기 때문에 필요합니다. 즉, &lt;em&gt;모든&lt;/em&gt; 유형이&lt;em&gt;&lt;/em&gt;함수의 인수 중 첫 번째 인수가 아닌 메서드를 선택할 때 고려됩니다 ( 메소드 및 디스패치에 대한 자세한 내용 은 &lt;a href=&quot;../methods/index#Methods&quot;&gt;메서드&lt;/a&gt; 참조 ). 따라서 함수가 첫 번째 인수에만 &quot;속하는&quot;것은 부적절합니다. 각 객체 &quot;내부에&quot;메소드의 명명 된 백을 갖지 않고 메소드를 함수 객체로 구성하는 것은 결국 언어 설계의 매우 유익한 측면이됩니다.</target>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++, Java, Python 및 Ruby와 같은 주류 객체 지향 언어에서 복합 유형에도 이와 관련된 기능이 명명되어 있으며이 조합을 &quot;객체&quot;라고합니다. Ruby 또는 Smalltalk와 같은보다 순수한 객체 지향 언어에서 모든 값은 합성이든 아니든 객체입니다. C ++ 및 Java를 포함하여 덜 순수한 객체 지향 언어에서 정수 및 부동 소수점 값과 같은 일부 값은 객체가 아닌 반면 사용자 정의 복합 유형의 인스턴스는 연관된 메소드가있는 실제 객체입니다. Julia에서 모든 값은 객체이지만 함수는 작동하는 객체와 함께 제공되지 않습니다. Julia는 여러 디스패치에서 사용할 함수의 메소드를 선택하기 때문에 필요합니다.&lt;em&gt; 합니다.&lt;/em&gt;오히려 단지 처음보다는 방법을 선택하는 경우, 함수의 인수가 고려된다 (참조 : &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;메서드&lt;/a&gt; 방법 및 디스패치에 대한 추가 정보를). 따라서 함수가 첫 번째 인수에만 &quot;포함&quot;하는 것은 부적절합니다. 각 개체를 &quot;내부&quot;로 명명 된 메서드 모음을 사용하지 않고 함수를 함수 개체로 구성하면 결국 언어 디자인에서 매우 유용한 측면이됩니다.</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">대부분의 경우 사전 할당 된 출력 벡터 또는 행렬을 제공 할 수있는 적절한 버전의 행렬 연산이 있습니다. 이는 반복 할당의 오버 헤드를 피하기 위해 중요 코드를 최적화 할 때 유용합니다. 이 내부 작업에는 &lt;code&gt;!&lt;/code&gt; 가 붙습니다 . 일반적인 Julia 규칙에 따라 아래 (예 : &lt;code&gt;mul!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">대부분의 경우 Julia는 &lt;code&gt;@simd&lt;/code&gt; 를 사용하지 않고 inner for 루프를 자동으로 벡터화 할 수 있습니다 . &lt;code&gt;@simd&lt;/code&gt; 를 사용하면 더 많은 상황에서 가능하도록 컴파일러에 약간의 여유가 생깁니다 . 두 경우 모두 내부 루프에 벡터화를 허용하는 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">대부분의 경우 함수 인수는 적절한 기본값을 가지므로 모든 호출에서 명시 적으로 전달할 필요는 없습니다. 예를 들어, 함수 &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt; 로부터 &lt;code&gt;Dates&lt;/code&gt; 모듈은 구축 &lt;code&gt;Date&lt;/code&gt; 소정 년 대 형 &lt;code&gt;y&lt;/code&gt; , 달 &lt;code&gt;m&lt;/code&gt; 및 일 &lt;code&gt;d&lt;/code&gt; . 그러나 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 인수는 선택 사항이며 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 이 동작은 다음과 같이 간결하게 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">많은 경우, 생성자 호출에 대한 인수 유형이 이미 암시 적으로 유형 정보를 제공하므로 구성하려는 &lt;code&gt;Point&lt;/code&gt; 객체 유형을 제공하는 것이 중복됩니다 . 따라서 매개 변수 유형 &lt;code&gt;T&lt;/code&gt; 의 내재 된 값 이 모호하지 않은 경우 &lt;code&gt;Point&lt;/code&gt; 자체를 생성자로 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">대부분의 경우 반올림에 지정된 해상도 (예 : &lt;code&gt;Dates.Second(30)&lt;/code&gt; )는 다음으로 큰 기간 (이 경우 &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ) 으로 균등하게 나뉩니다 . 그러나 이것이 사실이 아닌 경우 반올림 동작은 혼란을 초래할 수 있습니다. &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 가장 가까운 10 시간 으로 반올림 한 결과는 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">선택적 유형 선언이있는 많은 언어에서 선언을 추가하면 코드를 더 빠르게 실행할 수 있습니다. 입니다 &lt;em&gt;하지&lt;/em&gt; 줄리아의 경우. Julia에서 컴파일러는 일반적으로 모든 함수 인수, 로컬 변수 및 표현식의 유형을 알고 있습니다. 그러나 선언이 도움이되는 몇 가지 특정 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">수학에서, &lt;code&gt;+&lt;/code&gt; 보통이다 &lt;em&gt;가환&lt;/em&gt; 피연산자의 순서는 중요하지 않는 동작. 이것의 예는 행렬 덧셈입니다. 여기서 모양이 같은 행렬 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 경우 &lt;code&gt;A + B == B + A&lt;/code&gt; 입니다 . 반대로 &lt;code&gt;*&lt;/code&gt; 는 일반적으로 피연산자의 순서 &lt;em&gt;가&lt;/em&gt; 중요한 &lt;em&gt;비계산&lt;/em&gt; 연산을 나타냅니다 . 이것의 예는 일반적으로 &lt;code&gt;A * B != B * A&lt;/code&gt; 행렬 곱셈 입니다. 행렬 곱셈에서와 같이 문자열 연결은 비순환 적입니다. &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; . 따라서 &lt;code&gt;*&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; 일반적인 수학적 사용과 일치하는 접두사 문자열 연결 연산자에 대한보다 자연스러운 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d668367cdfd665ad4130e8623549b132951b0865" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">더 복잡한 경우 방법의 모호성을 해결하려면 특정 설계 요소가 필요합니다. 이 주제는 &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;아래에서&lt;/a&gt; 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">더 복잡한 경우, 방법 모호성을 해결하기 위해서는 특정 디자인 요소가 필요합니다. 이 주제는 &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;아래에서&lt;/a&gt; 더 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="79e9987996de7a2336075063e303687b6133cecc" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 를 지원 하는 요소 유형 &lt;code&gt;T&lt;/code&gt; 가있는 &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; 의 하위 유형 &lt;code&gt;S&lt;/code&gt; 인 경우 반환 유형은 &lt;code&gt;LU{T,S{T}}&lt;/code&gt; 입니다. 피벗이 선택되면 (기본값) 요소 유형은 &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 도 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 를 지원 하는 요소 유형 &lt;code&gt;T&lt;/code&gt; 를 가진 &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; 의 하위 유형 &lt;code&gt;S&lt;/code&gt; 인 경우 리턴 유형은 &lt;code&gt;LU{T,S{T}}&lt;/code&gt; 입니다. 피벗을 선택하면 (기본값) 요소 유형도 &lt;code&gt;abs&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b67b5f42c4b6dbeb6aa0f0d5f6894ea2c19994e" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;#catch-ctrl-c&quot;&gt;catch CTRL-C&lt;/a&gt; in the script you can use</source>
          <target state="translated">스크립트에서 &lt;a href=&quot;#catch-ctrl-c&quot;&gt;CTRL-C&lt;/a&gt; 를 잡으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">x의 데이터에 접근하기 위해 &lt;code&gt;jl_array_data&lt;/code&gt; 를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">이 프로그램을 빌드하려면 Julia 헤더의 경로를 포함 경로에 &lt;code&gt;libjulia&lt;/code&gt; 에 대한 링크를 넣어야 합니다. 예를 들어 Julia가 &lt;code&gt;$JULIA_DIR&lt;/code&gt; 설치되면 다음 을 사용하여 위의 테스트 프로그램 &lt;code&gt;test.c&lt;/code&gt; 를 &lt;code&gt;gcc&lt;/code&gt; 로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">&lt;code&gt;ret&lt;/code&gt; 이 특정 Julia 유형 인지 확인하기 위해 &lt;code&gt;jl_isa&lt;/code&gt; , &lt;code&gt;jl_typeis&lt;/code&gt; 또는 &lt;code&gt;jl_is_...&lt;/code&gt; 함수를 사용할 수 있습니다 . 타이핑에 의해 &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; 줄리아에 우리는 반환 형식이 있음을 알 수 쉘 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;double&lt;/code&gt; C에서). 박스형 Julia 값을 C 배로 변환하기 위해 &lt;code&gt;jl_unbox_float64&lt;/code&gt; 함수가 위의 코드 스 니펫에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">라디안 대신 각도를 사용하여 삼각 함수를 계산하려면 &lt;code&gt;d&lt;/code&gt; 로 함수를 접미사로 사용하십시오 . 예를 들어, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt; 의 사인 계산 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 각도로 지정된다. 학위 변형이 포함 된 삼각 함수의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">새로운 디스플레이 백엔드를 정의하려면 먼저 추상 클래스 &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; 의 하위 유형 &lt;code&gt;D&lt;/code&gt; 를 작성해야합니다 . 그런 다음 &lt;code&gt;D&lt;/code&gt; 에 표시 할 수있는 각 MIME 유형 ( &lt;code&gt;mime&lt;/code&gt; 문자열)에 대해 &lt;code&gt;x&lt;/code&gt; 를 해당 MIME 유형으로 표시 하는 함수 &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; 해야합니다 . 일반적으로 호출하여 &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; 나 &lt;code&gt;repr(io, mime, x)&lt;/code&gt; . &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 는&lt;/a&gt; 경우에 발생한다 &lt;code&gt;x&lt;/code&gt; 는 그 MIME 타입으로 표시 할 수 없습니다; 하나의 호출이 &lt;code&gt;show&lt;/code&gt; 또는 &lt;code&gt;repr&lt;/code&gt; 인 경우 자동 입니다. 마지막으로 함수 &lt;code&gt;display(d::D, x)&lt;/code&gt; 정의해야합니다 (d :: D, x) 쿼리 를 합니다&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;D&lt;/code&gt; 가 지원하는 &lt;code&gt;mime&lt;/code&gt; 유형에대해 showable (mime, x) 이며&quot;최고의&quot;유형을표시합니다. &lt;code&gt;MethodError&lt;/code&gt; 는 지원되는 MIME 유형을 위해 찾을 수없는 경우 발생한다 &lt;code&gt;x&lt;/code&gt; . 마찬가지로 일부 하위 유형은&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; 를 재정의하려고 할 수 있습니다. (다시 말해새로운 메소드를 추가하기 위해 &lt;code&gt;import Base.display&lt;/code&gt; 를 가져와야 &lt;code&gt;display&lt;/code&gt; .) 이러한 함수의 반환 값은 구현에 달려 있습니다 (일부 경우 일부 유형의 디스플레이 &quot;핸들&quot;을 반환하는 것이 유용 할 수 있기 때문에). 그런 다음 &lt;code&gt;D&lt;/code&gt; 에 대한 표시 기능을직접 호출 할 수 있지만 자동으로 호출 할 수도 있습니다.&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; 다음을 사용하여 새 디스플레이를 디스플레이 백엔드 스택에 푸시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="704ebdff29ebf61fba245cec0a90e4a3393b7079" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt;&lt;code&gt;repr(io, mime, x)&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">새로운 디스플레이 백엔드를 정의하려면 먼저 &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; 추상 클래스 의 하위 유형 &lt;code&gt;D&lt;/code&gt; 를 만들어야합니다 . 그런 다음 &lt;code&gt;D&lt;/code&gt; 에 표시 할 수있는 각 MIME 유형 ( &lt;code&gt;mime&lt;/code&gt; 문자열)에 대해 &lt;code&gt;x&lt;/code&gt; 를 해당 MIME 유형으로 표시 하는 &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; 함수를 정의해야합니다. 일반적으로 &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt; &lt;code&gt;repr(io, mime, x)&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 는&lt;/a&gt; 경우에 발생한다 &lt;code&gt;x&lt;/code&gt; 는 그 MIME 타입으로 표시 할 수 없습니다; 한 번의 호출이 &lt;code&gt;show&lt;/code&gt; 되거나 &lt;code&gt;repr&lt;/code&gt; 되면 자동으로 수행됩니다 . 마지막으로 &lt;code&gt;display(d::D, x)&lt;/code&gt; 함수를 정의해야합니다. &lt;code&gt;D&lt;/code&gt; 에서 지원 하는 &lt;code&gt;mime&lt;/code&gt; 유형에 대해 &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; 을 쿼리 하고 &quot;최상의&quot; 유형을 표시합니다. &lt;code&gt;MethodError&lt;/code&gt; 는 지원되는 MIME 유형을 위해 찾을 수없는 경우 발생한다 &lt;code&gt;x&lt;/code&gt; . 마찬가지로 일부 하위 유형은 &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; 를 재정의 할 수 있습니다 . (다시 말하지만, &lt;code&gt;import Base.display&lt;/code&gt; 에 새로운 메소드를 추가하려면 Base.display 를 가져와야 &lt;code&gt;display&lt;/code&gt; .) 이러한 함수의 반환 값은 구현에 달려 있습니다 (어떤 경우에는 특정 유형의 디스플레이 &quot;핸들&quot;을 반환하는 것이 유용 할 수 있기 때문입니다). 그런 다음 &lt;code&gt;D&lt;/code&gt; 의 표시 함수를 직접 호출 할 수 있지만 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; 에서 자동으로 호출 할 수도 있습니다. 다음을 사용하여 새 디스플레이를 디스플레이 백엔드 스택에 밀어 넣기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fc544618a386ab5d58649ad21c68fc6a33673b83" translate="yes" xml:space="preserve">
          <source>In order to define automatically the values of this dictionary at startup time, one can use the &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; function in the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, for example:</source>
          <target state="translated">시작 &lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt; 사전의 값을 자동으로 정의 하려면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 파일 에서 atreplinit 함수를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78c036b6a91aa7223777701c5e046f12ec492ccc" translate="yes" xml:space="preserve">
          <source>In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method should be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 유형의 객체에서 임의 생성을 정의하려면 &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; 메서드를 정의해야합니다 . 여기서 &lt;code&gt;sp&lt;/code&gt; 는 &lt;code&gt;sp[]&lt;/code&gt; 를 통해 액세스 할 수있는 &lt;code&gt;S&lt;/code&gt; 유형의 객체를 단순히 래핑합니다 . &lt;code&gt;Die&lt;/code&gt; 예제를 계속해서 이제 &lt;code&gt;rand(d::Die)&lt;/code&gt; 를 정의 하여 &lt;code&gt;d&lt;/code&gt; 의 변 중 하나에 해당 하는 &lt;code&gt;Int&lt;/code&gt; 를 생성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">다단계 매개 변수 인수 목록을 발송하려면 각 발송 레벨을 개별 함수로 분리하는 것이 가장 좋습니다. 단일 디스패치와 비슷한 방식으로 들릴 수 있지만 아래에서 볼 수 있듯이 여전히 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">그러한 &lt;code&gt;copy&lt;/code&gt; 또는 &lt;code&gt;copyto!&lt;/code&gt; 를 구현하기 위해 ! 물론, 메소드, 각 요소를 계산 하려면 &lt;code&gt;Broadcasted&lt;/code&gt; 랩퍼로 작업해야합니다 . 그렇게하는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">무손실 임의의 바이트를 표현하기 위해 저장된 스트림 &lt;code&gt;String&lt;/code&gt; 하는 &lt;code&gt;Char&lt;/code&gt; 이러한 변환 - 값은 유니 코드 코드 포인트로 변환 할 수없는 정보를 저장할 수있다 &lt;code&gt;Char&lt;/code&gt; 에 &lt;code&gt;UInt32&lt;/code&gt; 오류가 발생 것이다. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt; 인지 기능은 쿼리에 사용할 수 있습니다 &lt;code&gt;c&lt;/code&gt; 유효한 유니 코드 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">이 함수를 C로 전달하기 위해 매크로 &lt;code&gt;@cfunction&lt;/code&gt; 을 사용하여 주소를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">모든 프로세스에서 &lt;code&gt;MyType&lt;/code&gt; 을 참조하려면 모든 프로세스에 &lt;code&gt;DummyModule.jl&lt;/code&gt; 을로드해야합니다. &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; 를 호출 하면 단일 프로세스에서만로드됩니다. 모든 프로세스에로드하려면 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt; 매크로를 사용하십시오 ( &lt;code&gt;julia -p 2&lt;/code&gt; Julia -p 2로 시작 ).</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">돌연변이를 지원하기 위해 이러한 객체는 일반적으로 힙에 할당되며 안정적인 메모리 주소를 갖습니다. 변경 가능한 개체는 시간이 지남에 따라 다른 값을 보유 할 수있는 작은 컨테이너와 같으므로 해당 주소로만 확실하게 식별 할 수 있습니다. 반대로, 불변 유형의 인스턴스는 특정 필드 값과 연관되어 있습니다.-필드 값만으로도 개체에 대한 모든 정보가 표시됩니다. 유형을 변경할 수 있는지 여부를 결정할 때 동일한 필드 값을 가진 두 인스턴스가 동일한 것으로 간주되는지 또는 시간이 지남에 따라 독립적으로 변경해야하는지 묻습니다. 그것들이 동일하다고 생각되면, 타입은 불변 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">다른 상황에서는 반복을 중지하고 즉시 다음 반복으로 넘어가는 것이 편리합니다. 는 &lt;code&gt;continue&lt;/code&gt; 키워드 수행이 :</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">다시 말해, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 동일한 객체이고 해당 객체가 유형 인 경우에만 true 입니다. 매개 변수가 없으면 &lt;code&gt;Type&lt;/code&gt; 은 단순히 단일 유형을 포함하여 모든 유형 객체를 인스턴스로 갖는 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">다시 말해, 유형 이론의 용어에서 Julia의 유형 매개 변수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;공변량 (또는 공변량)이&lt;/a&gt; 아니라 &lt;em&gt;변하지 않습니다&lt;/em&gt; . 이는 실용적인 이유입니다. &lt;code&gt;Point{Float64}&lt;/code&gt; 의 인스턴스는 개념적으로 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스와 비슷할 수 있지만 두 유형은 메모리에서 서로 다른 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">특히 이것은 너무 길고 너무 높은 코드 단위 시퀀스와 그 접두어가 여러 개의 유효하지 않은 문자가 아닌 하나의 유효하지 않은 문자로 취급됨을 의미합니다. 이 규칙은 예제와 함께 가장 잘 설명 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">특히, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; 은 일반적으로 사람이 소비하도록 설계된 &lt;code&gt;x&lt;/code&gt; 의 &quot;꽤 인쇄 된&quot;버전입니다 . Julia에서 &lt;code&gt;x&lt;/code&gt; 값을 입력 하는 방법에 더 가까운 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 해당하는 문자열을 대신 반환하려면 &lt;code&gt;repr(x)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44f2256825b7ba89fb1041db2fbe0f7cb5785da9" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">특히, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; 는 일반적으로 사람이 소비하도록 설계된 &lt;code&gt;x&lt;/code&gt; 의 &quot;예쁘게 인쇄 된&quot;버전입니다 . 줄리아에서 &lt;code&gt;x&lt;/code&gt; 값을 입력 하는 방법에 더 가까운 &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 해당하는 문자열을 대신 반환하려면 &lt;code&gt;repr(x)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">당신이 정의하는 경우 특히, &lt;code&gt;function __init__()&lt;/code&gt; 모듈에 다음 줄리아 호출 &lt;code&gt;__init__()&lt;/code&gt; 즉시 &lt;em&gt;후&lt;/em&gt; 모듈이 (예를 들어,에 의해로드 &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; , 또는 &lt;code&gt;require&lt;/code&gt; 에 대한 런타임에서) &lt;em&gt;첫째&lt;/em&gt; , 즉 시간 ( &lt;code&gt;__init__&lt;/code&gt; 이 있습니다 한 번만 호출되며 모듈의 모든 명령문이 실행 된 후에 만 ​​호출됩니다. 모듈이 완전히 가져온 후 호출되기 때문에, 어떤 서브 모듈 또는 기타 수입 모듈은 자신이 &lt;code&gt;__init__&lt;/code&gt; 함수가 호출 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;__init__&lt;/code&gt; 둘러싸는 모듈의.</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">특히 &lt;code&gt;LibGit2.free&lt;/code&gt; 는 &lt;code&gt;Ref&lt;/code&gt; 객체 에서 나중에 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특히, 참고 &lt;code&gt;missing == missing&lt;/code&gt; 반환 &lt;code&gt;missing&lt;/code&gt; , 그래서 &lt;code&gt;==&lt;/code&gt; 값이 누락되어 있는지 여부를 테스트하는 데 사용할 수 없습니다. 여부를 테스트하려면 &lt;code&gt;x&lt;/code&gt; 가 되어 &lt;code&gt;missing&lt;/code&gt; , 사용 &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">특히, 이는 정수 및 부동 소수점과 같은 충분히 작은 불변 값이 일반적으로 레지스터의 함수 (또는 스택 할당)로 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">작성된 구문 대신 매크로 호출이 구문 분석시 리턴 된 결과로 확장됩니다. 이것은 다음과 같이 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">실제로, 특히 재사용 가능한 기능을 제공 할 때 일반적으로 인수를 설정하는 Julia 함수에서 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 사용을 래핑 한 다음 C 또는 Fortran 함수가 표시하는 방식에 따라 오류를 확인하여 Julia 호출자에게 예외로 전파합니다. 이는 C 및 Fortran API가 오류 조건을 나타내는 방법에 대해 불일치하기 때문에 특히 중요합니다. 예를 들어, &lt;code&gt;getenv&lt;/code&gt; C 라이브러리 함수는 다음 Julia 함수로 랩핑되어 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt; 의 실제 정의를 단순화 한 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="4ee03fd7f1bb01022cf62529b6c1e2c9383e98c5" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">실제로, 특히 재사용 가능한 기능을 제공 할 때 일반적으로 인수를 설정 한 다음 C 또는 Fortran 함수가 지정하는 방식으로 오류를 확인하는 Julia 함수에서 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 사용을 래핑 합니다. 그리고 오류가 발생하면 일반적인 Julia 예외로 throw됩니다. C 및 Fortran API는 오류 조건을 나타내는 방법에 대해 일관성이없는 것으로 악명이 높기 때문에 이는 특히 중요합니다. 예를 들어 &lt;code&gt;getenv&lt;/code&gt; C 라이브러리 함수는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt; 의 실제 정의를 단순화 한 다음 Julia 함수로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">원칙적으로 Markdown 파서 자체는 패키지에 의해 임의로 확장되거나 Markdown의 전적으로 사용자 정의 된 풍미가 사용될 수 있지만 일반적으로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">요컨대, 이것은 &lt;code&gt;IO&lt;/code&gt; 의 서브 클래스 인 불변의 사전입니다 . &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 와 같은 표준 사전 작업을 지원 하며 I / O 스트림으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">일부 응용에서, 비정규 수를 0으로 대체하는 대안은 약간의 노이즈를 주입하는 것입니다. 예를 들어, 0 으로 초기화 &lt;code&gt;a&lt;/code&gt; 대신 다음을 사용하여 초기화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">일부 응용 프로그램에서는 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 에 명시 적 0 값을 저장하는 것이 편리합니다 . 이것들 &lt;em&gt;은 &lt;/em&gt; &lt;code&gt;Base&lt;/code&gt; 의 기능에 의해 수용됩니다 (그러나 변이 연산에서 보존 될 것이라는 보장은 없습니다). 이러한 명시 적으로 저장된 0은 많은 루틴에 의해 구조적 0이 아닌 것으로 취급됩니다. &lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt; 함수는 0 구조를 포함하여 스파 스 데이터 구조에 명시 적으로 저장된 요소 수를 반환합니다. 숫자가 아닌 숫자가 아닌 정확한 수를 계산하려면 희소 행렬의 저장된 모든 요소를 ​​검사 하는 &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt; 및 제자리 &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; , 희소 행렬에서 저장된 0을 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">경우에 따라 &lt;code&gt;const&lt;/code&gt; 변수 의 값을 변경 하면 오류 대신 경고가 표시됩니다. 그러나 이로 인해 예기치 않은 동작이 발생하거나 프로그램 상태가 손상 될 수 있으므로 피해야합니다. 이 기능은 대화식 사용 중 편의를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">경우에 따라 &lt;code&gt;MyStyle&lt;/code&gt; 을 정의하지 않아도 편리 할 수 ​​있습니다 .이 경우 일반 브로드 캐스트 래퍼 중 하나를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">어떤 경우에는 축소 연산자가 필요하지 않으며 특정 범위의 모든 정수 (또는 일반적으로 일부 컬렉션의 모든 요소)에 함수를 적용하려고합니다. 이것은 또 다른 유용한 작업입니다&lt;em&gt;&lt;/em&gt; Julia에서 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; 함수 로 구현 된 &lt;em&gt;parallel map&lt;/em&gt; 입니다. 예를 들어, 다음과 같이 여러 개의 큰 랜덤 행렬의 특이 값을 병렬로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">어떤 경우에, 주어진 RNG 타입에 대해, 임의의 값의 어레이를 생성하는 것은 단지 이전에 설명 된 디커플링 기술을 이용하는 것보다 특수한 방법으로보다 효율적일 수있다. 예를 들어 &lt;code&gt;MersenneTwister&lt;/code&gt; 의 경우는 기본적으로 배열에 임의의 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">경우에 따라 상황에 따라 &lt;code&gt;show&lt;/code&gt; 메소드 의 동작을 조정하는 것이 유용합니다 . 이는 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 유형을 통해 달성 될 수 있으며 , 이는 랩핑 된 IO 스트림과 함께 컨텍스트 특성을 전달할 수있게합니다. 예를 들어, &lt;code&gt;:compact&lt;/code&gt; 속성이로 설정 되면 &lt;code&gt;show&lt;/code&gt; 메소드 에서 더 짧은 표현을 만들 수 있습니다 . &lt;code&gt;true&lt;/code&gt; 되면 속성이 &lt;code&gt;false&lt;/code&gt; 이거나없는 경우 긴 표현으로 돌아가서 .</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">경우에 따라 소수의 값만 생성할지 또는 많은 수의 값을 생성할지 여부는 알고리즘 선택에 영향을 미칩니다. 이것은 &lt;code&gt;Sampler&lt;/code&gt; 생성자 의 세 번째 매개 변수로 처리됩니다 . &lt;code&gt;Die&lt;/code&gt; 에 대해 두 가지 도우미 유형을 정의 했다고 가정 해 봅시다. &lt;code&gt;SamplerDie1&lt;/code&gt; 소수의 임의의 값만 생성하는 데 사용해야하는 &lt;code&gt;SamplerDieMany&lt;/code&gt; 과 많은 값의 경우 SamplerDieMany 와 같이 가정 합니다. 이러한 유형을 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e2e50c5e5c4d32f74208fde4cbb36b4d6312f3" translate="yes" xml:space="preserve">
          <source>In some languages, the empty tuple (&lt;code&gt;()&lt;/code&gt;) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</source>
          <target state="translated">일부 언어에서 빈 튜플 ( &lt;code&gt;()&lt;/code&gt; )은 무의 표준 형식으로 간주됩니다. 그러나 줄리아에서는 0 값을 포함하는 일반 튜플로 생각하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb5807b7c193c64d46f5bc3d42f551af1a206e90" translate="yes" xml:space="preserve">
          <source>In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">일부 문제에서는 필요한 작업의 다양한 부분이 함수 호출에 의해 자연스럽게 관련되지 않습니다. 수행해야 할 작업 중 명백한 &quot;호출자&quot;또는 &quot;조용한&quot;이 없습니다. 하나의 복잡한 프로 시저가 값을 생성하고 다른 복잡한 프로 시저가 값을 소비하는 생산자-소비자 문제가 그 예입니다. 소비자는 단순히 생산자 함수를 호출하여 값을 가져올 수 없습니다. 생산자는 생성 할 값이 더 많고 아직 반환 할 준비가되지 않았을 수 있기 때문입니다. 작업을 사용하면 생산자와 소비자 모두 필요한만큼 실행하여 필요에 따라 값을 앞뒤로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46bc7cae3ed284ebaa58a72dfb5ca4f122d19b91" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">일부 상황에서 함수는 작업의 일부로 메모리를 할당해야 할 수 있으며 이로 인해 위의 간단한 그림이 복잡해질 수 있습니다. 이러한 경우 아래 &lt;a href=&quot;#tools&quot;&gt;도구&lt;/a&gt; 중 하나를 사용하여 문제를 진단하거나 알고리즘 측면에서 할당을 분리하는 함수 버전을 작성하는 것이 좋습니다 ( &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;출력 사전 할당&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">경우에 따라 함수가 작업의 일부로 메모리를 할당해야 할 수도 있으며 이로 인해 위의 간단한 그림이 복잡해질 수 있습니다. 이러한 경우 아래 &lt;a href=&quot;#tools-1&quot;&gt;도구&lt;/a&gt; 중 하나를 사용하여 문제점을 진단하거나 알고리즘 측면과 할당을 분리하는 함수 버전을 작성하십시오 ( &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;사전 할당 출력&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">아래 2 단계에서 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 을 편집 하여 소스 코드를 변경하고 &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; 을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">아래 2 단계에서 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 을 편집 하여 소스 코드를 변경하고 원하는 테스트 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 경쟁 조건의 가능성을 피하거나 &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;동기화 프리미티브를&lt;/a&gt; 사용하도록 코드를 다시 설계해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">이러한 경우 결과는 항상 1-d입니다.</target>
        </trans-unit>
        <trans-unit id="de5de110f5af15ec4cd1a61e4b555c94b532b3cc" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">기술 컴퓨팅 언어에서는 함수의 &quot;벡터화 된&quot;버전을 갖는 것이 일반적입니다.이 함수는 주어진 함수 &lt;code&gt;f(x)&lt;/code&gt; 를 배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소에 간단히 적용하여 &lt;code&gt;f(A)&lt;/code&gt; 를 통해 새 배열을 생성합니다 . 이러한 종류의 구문은 데이터 처리에 편리하지만 다른 언어에서는 성능을 위해 종종 벡터화가 필요합니다. 루프가 느리면 함수의 &quot;벡터화 된&quot;버전이 저수준 언어로 작성된 빠른 라이브러리 코드를 호출 할 수 있습니다. Julia에서는 벡터화 된 함수가 성능에 필요 &lt;em&gt;하지 않으며&lt;/em&gt; 실제로 루프를 작성하는 것이 종종 유용 하지만 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;성능 팁&lt;/a&gt; 참조 ) 여전히 편리 할 수 ​​있습니다. 따라서 &lt;em&gt;모든&lt;/em&gt; Julia 함수 &lt;code&gt;f&lt;/code&gt; &lt;code&gt;f.(A)&lt;/code&gt; 구문을 사용하여 모든 배열 (또는 다른 컬렉션)에 요소별로 적용 할 수 있습니다 . 예를 들어 &lt;code&gt;sin&lt;/code&gt; 은 벡터 &lt;code&gt;A&lt;/code&gt; 의 모든 요소에 다음 과 같이 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">기술 컴퓨팅 언어에서는 &quot;벡터화 된&quot;버전의 함수를 사용하는 것이 일반적입니다.이 함수는 단순히 주어진 함수 &lt;code&gt;f(x)&lt;/code&gt; 를 배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소에 적용하여 &lt;code&gt;f(A)&lt;/code&gt; 를 통해 새 배열을 생성합니다 . 이런 종류의 구문은 데이터 처리에 편리하지만 다른 언어에서는 성능을 위해 벡터화가 종종 필요합니다. 루프가 느리면 &quot;벡터화 된&quot;버전의 함수는 저수준 언어로 작성된 빠른 라이브러리 코드를 호출 할 수 있습니다. Julia에서는 벡터화 함수가 성능에 필요 &lt;em&gt;하지 않으며&lt;/em&gt; 실제로 자체 루프를 작성하는 것이 유리 하지만 ( &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁&lt;/a&gt; 참조 ) 여전히 편리 할 수 ​​있습니다. 따라서 &lt;em&gt;모든&lt;/em&gt; Julia 함수 &lt;code&gt;f&lt;/code&gt; &lt;code&gt;f.(A)&lt;/code&gt; 구문을 사용하여 모든 배열 (또는 다른 컬렉션)에 요소별로 적용 할 수 있습니다 . 예를 들어 &lt;code&gt;sin&lt;/code&gt; 은 벡터 &lt;code&gt;A&lt;/code&gt; 의 모든 요소에 다음 과 같이 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">유닉스 배관과 관련하여 여기서 일어나는 일은 단일 유닉스 파이프 객체가 두 &lt;code&gt;echo&lt;/code&gt; 프로세스 에 의해 작성되고 기록되며 파이프의 다른 쪽 끝은 &lt;code&gt;sort&lt;/code&gt; 명령으로 읽히는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">Julia REPL 및 기타 여러 Julia 편집 환경에서 백 슬래시 LaTeX 기호 이름과 탭을 차례로 입력하여 많은 유니 코드 수학 기호를 입력 할 수 있습니다. 예를 들어, 변수 이름 &lt;code&gt;&amp;delta;&lt;/code&gt; 를 입력하여 입력 할 수 있습니다 &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;탭&lt;/em&gt; , 또는 &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; 에 의해 &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;탭&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;탭&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;탭&lt;/em&gt; . (예를 들어 다른 사람의 코드에서 입력 방법을 모르는 기호가있는 경우 REPL 도움말에 표시됩니다 : &lt;code&gt;?&lt;/code&gt; 를 입력 한 다음 붙여 넣기 만하면 됩니다.)</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@everywhere module Foo&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; 는 모든 노드에서 Foo를 정의했습니다 . 그러나 &lt;code&gt;Foo.foo()&lt;/code&gt; 호출 하면 로컬 노드에 새로운 전역 바인딩 &lt;code&gt;gvar&lt;/code&gt; 이 만들어 졌지만 노드 2에서는이 값을 &lt;code&gt;UndefVarError&lt;/code&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 를 사용한 형식 선언이없는 경우 기본적으로 메서드 매개 변수의 형식은 &lt;code&gt;Any&lt;/code&gt; 입니다 . 즉 Julia의 모든 값이 추상 형식 &lt;code&gt;Any&lt;/code&gt; 의 인스턴스이므로 제한되지 않습니다 . 따라서 &lt;code&gt;f&lt;/code&gt; 에 대한 catch-all 메소드를 다음 과 같이 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="804c2e460ca33d08a52c531b866706df762bfe07" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">할당 양식에서 함수의 본문은 복합 표현식 일 수 있지만 단일 표현식이어야합니다 ( &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;복합 표현식&lt;/a&gt; 참조 ). 줄리아에서는 짧고 간단한 함수 정의가 일반적입니다. 따라서 짧은 함수 구문은 상당히 관용적이어서 타이핑과 시각적 노이즈를 상당히 줄입니다.</target>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">대입 양식에서 함수 본문은 단일 표현식이어야하지만 복합 표현식 일 수 있습니다 ( &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;복합 표현식&lt;/a&gt; 참조). ). 줄리아에서는 짧고 간단한 함수 정의가 일반적입니다. 짧은 함수 구문은 따라서 관용적이며 타이핑과 시각적 노이즈를 상당히 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">생성 된 함수의 본문에서는 값이 아닌 인수 &lt;em&gt;유형&lt;/em&gt; 과 생성 된 함수의 정의 &lt;em&gt;전에&lt;/em&gt; 정의 된 함수 에만 액세스 할 수 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50c2c4d1cb9a5c5c26d9acf8cbb1ac2672dac8d1" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values.</source>
          <target state="translated">생성 된 함수의 본문에서 값이 아닌 인수 &lt;em&gt;유형&lt;/em&gt; 에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">의 경우 &lt;code&gt;Point&lt;/code&gt; 의 종류 &lt;code&gt;T&lt;/code&gt; 는 만에 두 인수하는 경우 경우 명확하게 암시 &lt;code&gt;Point&lt;/code&gt; 동일한 유형이있다. 그렇지 않으면 생성자가 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 와 함께 실패합니다 . .</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">&lt;code&gt;a[1]&lt;/code&gt; 의 유형을 정확하게 알 수 없는 경우 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; 를 통해 선언 될 수 있습니다 . 의 사용 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 함수 허용 &lt;code&gt;a[1]&lt;/code&gt; 내지 An 전환 개체로 &lt;code&gt;Int32&lt;/code&gt; (예 &lt;code&gt;UInt8&lt;/code&gt; 따라서 입력 요구를 풀어 코드들이 generic 증가). 공지 사항 &lt;code&gt;convert&lt;/code&gt; 자체는 타입 안정성을 달성하기 위해 이러한 맥락에서 유형 약어를 필요로한다. 이는 모든 함수의 인수 유형이 알려지지 않은 경우 컴파일러가 함수의 반환 값 유형을 추론 할 수없고 심지어 &lt;code&gt;convert&lt;/code&gt; 도 추론 할 수 없기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="7c1119f311ce545842278fe205e3f9855f274299" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">식의 맥락에서 기호는 변수에 대한 액세스를 나타내는 데 사용됩니다. 표현식이 평가 될 때 기호는 적절한 &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;범위&lt;/a&gt; 의 해당 기호에 바인딩 된 값으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">표현식과 관련하여 기호는 변수에 대한 액세스를 나타내는 데 사용됩니다. 식이 평가되면 기호가 해당 &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;범위&lt;/a&gt; 의 해당 기호에 바인딩 된 값으로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">함수 정의와 관련하여 &lt;code&gt;...&lt;/code&gt; 연산자는 다양한 인수를 단일 인수로 결합하는 데 사용됩니다. 여러 가지 다른 인수를 단일 인수로 결합하기위한 &lt;code&gt;...&lt;/code&gt; 의 사용을 slurping이라고합니다.</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">결국 분산 및 병렬 컴퓨팅에 대한 Julia의 접근 방식을 제시 할 것입니다. 과학적인 컴퓨팅을 염두에두고 Julia는 기본적으로 인터페이스를 구현하여 여러 코어 또는 시스템에 프로세스를 분산시킵니다. 또한 &lt;code&gt;MPI.jl&lt;/code&gt; 및 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 과 같은 분산 프로그래밍에 유용한 외부 패키지를 언급 ​​할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">중첩 된 테스트 세트에 오류가없는 경우 여기에서 발생한 것처럼 요약에 숨겨집니다. 테스트 실패가 발생한 경우 실패한 테스트 세트의 세부 사항 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">두 모듈이 동일한 이름의 비표준 문자열 또는 명령 리터럴을 제공하는 경우 모듈 이름으로 문자열 또는 명령 리터럴을 규정 할 수 있습니다. 예를 들어, &lt;code&gt;Foo&lt;/code&gt; 와 &lt;code&gt;Bar&lt;/code&gt; 가 비표준 문자열 리터럴 &lt;code&gt;@x_str&lt;/code&gt; 을 제공 하면 &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; 또는 &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; 을 작성하여 둘 사이를 명확하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">위의 예에서 &lt;code&gt;#=&lt;/code&gt; 와 &lt;code&gt;=#&lt;/code&gt; 사이의 코드 는 &lt;code&gt;bash&lt;/code&gt; 스크립트 로 실행됩니다 . Julia는이 부분이 Julia에 대한 여러 줄 주석이므로 무시합니다. &lt;code&gt;=#&lt;/code&gt; 뒤의 Julia 코드 는 &lt;code&gt;exec&lt;/code&gt; 문에 도달하면 파일 구문 분석을 중지하므로 &lt;code&gt;bash&lt;/code&gt; 에서 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">아래 예에서 성능을 향상시키기 위해 배열 &lt;code&gt;A&lt;/code&gt; 의 요소 &lt;code&gt;i&lt;/code&gt; 참조를위한 범위 내 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">위의 매니페스트 파일 예제에서 첫 번째 &lt;code&gt;Priv&lt;/code&gt; 의 경로를 찾습니다. 패키지 UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 가있는 패키지)를 찾으 려면 Jula는 매니페스트 파일에서 스탠자를 찾고 &lt;code&gt;path&lt;/code&gt; 항목 이 있는지 확인합니다. 에 &lt;code&gt;deps/Priv&lt;/code&gt; 받는 상대 &lt;code&gt;App&lt;/code&gt; 프로젝트 디렉토리하자가 가정 &lt;code&gt;App&lt;/code&gt; 코드 삶에 &lt;code&gt;/home/me/projects/App&lt;/code&gt; 그 -sees &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; 존재하기 때문에 부하 &lt;code&gt;Priv&lt;/code&gt; 거기에서.</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">표현식 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; 에서 각 &lt;code&gt;I_k&lt;/code&gt; 는 스칼라 인덱스, 스칼라 인덱스 배열 또는 스칼라 인덱스 배열을 나타내는 객체 일 수 있으며 &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; 로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">표현식 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 에서 하위 표현식 &lt;code&gt;b&lt;/code&gt; 는 a 가 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 평가되는 경우에만 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">표현 &lt;code&gt;a || b&lt;/code&gt; 는 하위 식 &lt;code&gt;b&lt;/code&gt; 경우에만 평가 가 평가 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">첫 번째 예에서 짝수 에 &lt;code&gt;test1&lt;/code&gt; 하자마자 test1 에서 리턴이 리턴 되므로 &lt;code&gt;test1([5,6,7])&lt;/code&gt; 은 &lt;code&gt;12&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">첫 번째 단계에서 Julia 함수 &lt;code&gt;sqrt&lt;/code&gt; 에 대한 핸들 은 &lt;code&gt;jl_get_function&lt;/code&gt; 을 호출하여 검색됩니다 . &lt;code&gt;jl_get_function&lt;/code&gt; 에 전달 된 첫 번째 인수는 &lt;code&gt;sqrt&lt;/code&gt; 가 정의 된 &lt;code&gt;Base&lt;/code&gt; 모듈에 대한 포인터 입니다. 그런 다음 &lt;code&gt;jl_box_float64&lt;/code&gt; 를 사용하여 double 값을 상자에 넣습니다. . 마지막으로 마지막 단계에서 &lt;code&gt;jl_call1&lt;/code&gt; 을 사용하여 함수를 호출 합니다. &lt;code&gt;jl_call0&lt;/code&gt; , &lt;code&gt;jl_call2&lt;/code&gt; 및 &lt;code&gt;jl_call3&lt;/code&gt; 함수도 존재 하므로 다른 수의 인수를 편리하게 처리 할 수 ​​있습니다. 더 많은 인수를 전달하려면 &lt;code&gt;jl_call&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">다음 REPL 세션에서 :</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 과 &lt;code&gt;CuArrays.jl&lt;/code&gt; 을 사용하여 여러 프로세스에 배열을 분산하고 일반 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 을 모두 사용합니다. 과 &lt;code&gt;CuArrays.jl&lt;/code&gt; 을 하여 먼저 &lt;code&gt;CuArray()&lt;/code&gt; 및 CuArray ()를 통해 배열을 여러 프로세스에 &lt;code&gt;distribute()&lt;/code&gt; 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">다음 예에서 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 은 임의의 docstring을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">다음 섹션에서는 Julia 코드를 가능한 빨리 실행하는 데 도움이되는 몇 가지 기술을 간략하게 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">전자의 경우, 정수는 시스템 워드 크기로 확장되므로 결과는 128입니다. 후자의 경우, 그러한 확장이 발생하지 않고 정수 오버 플로우는 -128이됩니다.</target>
        </trans-unit>
        <trans-unit id="96b938fab6579b9bca905e7cf7ff960b0076051e" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is &lt;code&gt;Int64[100, 128]&lt;/code&gt;. In the latter case, no such widening happens and integer overflow results in &lt;code&gt;Int8[100, -128]&lt;/code&gt;.</source>
          <target state="translated">전자의 경우 정수는 시스템 워드 크기로 확장되므로 결과는 &lt;code&gt;Int64[100, 128]&lt;/code&gt; 입니다. 후자의 경우 이러한 확대가 발생하지 않고 정수 오버플로가 &lt;code&gt;Int8[100, -128]&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">마지막 예에서 &lt;code&gt;Vector{Any}&lt;/code&gt; 가 생성됩니다. 그 이유는 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; 입니다. 해결책은 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; 를 정의하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">후자의 경우 결과 유형은 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 이므로 &lt;code&gt;BigInt&lt;/code&gt; 는 임의 정밀도 정수 산술을 위해 정수를 보유하기에 충분히 큰 유일한 유형 이므로 결과 유형은 BigInt 입니다. 또한 &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; 및 &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; 모두 정의 할 필요는 없습니다. . 대칭은 방법 &lt;code&gt;promote_rule&lt;/code&gt; 은 추진 과정에서 사용된다.</target>
        </trans-unit>
        <trans-unit id="53f7c1a582426e8808f0c1bf813e62ee2f97e7c7" translate="yes" xml:space="preserve">
          <source>In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">그 동안 &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt; 과 같은 외부 라이브러리를 사용하여 오버플로에 안전한 정수 연산을 수행 할 수 있습니다 . 앞서 언급했듯이 이러한 라이브러리를 사용하면 확인 된 정수 유형을 사용하는 코드의 실행 시간이 크게 늘어납니다. 그러나 제한된 사용의 경우 모든 정수 연산에 사용되는 경우보다 훨씬 덜 문제가됩니다. &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;여기&lt;/a&gt; 에서 토론 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">이러한 경우와 다른 경우에는 &lt;em&gt;입력 유형&lt;/em&gt; 을 선택하여 원하는 결과를 얻을 수 있습니다&lt;em&gt;&lt;/em&gt; 표현할 수 있는 &lt;em&gt;출력 유형&lt;/em&gt; 을 기꺼이 받아 들일 수 을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">이 예제에서 &lt;code&gt;a&lt;/code&gt; 는 두 개의 필드 가있는 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 입니다. &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;Int&lt;/code&gt; 이며, 필드가 전혀없는 프리미티브 비트 유형입니다. &lt;code&gt;ex&lt;/code&gt; 은&lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;하나의 필드 ErrorException 입니다.</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">이 예와 다음의 모든 예에서 최상위 레벨은 새로 시작된 REPL과 같이 작업 공간이 깨끗한 전역 범위 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">이 경우 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 은 원격 프로세스에서 정의되어야합니다. 참고 &lt;code&gt;A&lt;/code&gt; 는 로컬 작업 공간에 정의 된 전역 변수이다. 작업자 2에는 &lt;code&gt;Main&lt;/code&gt; 아래에 &lt;code&gt;A&lt;/code&gt; 라는 변수가 없습니다 . 클로저 &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; 를 작업자 2에게 전달하면 &lt;code&gt;Main.A&lt;/code&gt; 는 2 에 정의됩니다. &lt;code&gt;Main.A&lt;/code&gt; 는 &lt;code&gt;remotecall_fetch&lt;/code&gt; 호출이 리턴 된 후에도 작업자 2에 계속 존재 합니다. 내장 된 전역 참조가있는 원격 호출 ( &lt;code&gt;Main&lt;/code&gt; 모듈에서만)은 다음과 같이 전역을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">이 경우 &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; 가 더 좋습니다. 컴파일러가 특정 용도에 주석을 달 때 더 도움이됩니다 (예 : &lt;code&gt;a[i]::Int&lt;/code&gt; 많은 대안을 하나의 유형으로 것보다 ) .</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">이 경우 값의 튜플은 가변 개수의 인수가가는 곳에서 varargs 호출에 연결됩니다. 그러나 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">이 경우 닫는 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 앞의 마지막 (빈) 줄 은 들여 쓰기 수준을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">이 경우, 1 차원 인덱스를 사용하여 작업을 분할하려고하면 문제가 발생할 수 있습니다. &lt;code&gt;q[i,j,t]&lt;/code&gt; 가 한 작업자에게 할당 된 블록의 끝과 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 은 다른 블록에 할당 된 블록의 시작 부분에 가깝습니다. &lt;code&gt;q[i,j,t]&lt;/code&gt; 는 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 계산에 필요한 시점에 준비되지 않을 가능성이 높습니다 1] . 이러한 경우, 수동으로 어레이를 청킹하는 것이 좋습니다. 두 번째 차원을 따라 나눕시다. 이 워커에 할당 된 &lt;code&gt;(irange, jrange)&lt;/code&gt; 인덱스 를 반환하는 함수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">이 경우 문자 &lt;code&gt;&amp;forall;&lt;/code&gt; 는 3 바이트 문자이므로 색인 2와 3은 유효하지 않으며 다음 문자의 색인은 4입니다. 이 다음 유효한 인덱스는 &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt; 의해 계산 될 수 있고 그 다음에 오는 다음 인덱스는 &lt;code&gt;nextind(s,4)&lt;/code&gt; 의해 계산 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">이 경우 &lt;code&gt;@fastmath&lt;/code&gt; 로 인한 속도 향상 은 약 3.7 배입니다. 이는 비정상적으로 크며 일반적으로 속도가 느려집니다. (이 특정 예에서 벤치 마크의 작업 세트는 프로세서의 L1 캐시에 맞출만큼 작기 때문에 메모리 액세스 대기 시간이 중요한 역할을하지 않으며 컴퓨팅 시간은 CPU 사용량에 의해 좌우됩니다. 많은 실제 프로그램에서 또한이 경우이 최적화는 결과를 변경하지 않습니다. 일반적으로 결과는 약간 다릅니다. 경우에 따라 특히 수치 적으로 불안정한 알고리즘의 경우 결과가 매우 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">이와 관련하여 MPI는 MPI-1 표준을 나타냅니다. MPI-2부터 MPI 표준위원회는 RMA (Remote Memory Access)라고하는 새로운 통신 메커니즘을 도입했습니다. MPI 표준에 rma를 추가하려는 동기는 일방적 인 커뮤니케이션 패턴을 촉진하는 것이 었습니다. 최신 MPI 표준에 대한 자세한 내용은 &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; 를 정의하여 적절한 랩핑 된 배열을 만듭니다. (주 동안 그 &lt;code&gt;similar&lt;/code&gt; 만 3 인수 양식을 전문으로해야하는 대부분의 경우 지원 1과 2 인자 형태.)이 들어가 있다는 것이 중요 작동하는 &lt;code&gt;SparseArray&lt;/code&gt; 가 변경 가능한 (지원의 &lt;code&gt;setindex!&lt;/code&gt; ). 정의 &lt;code&gt;similar&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; 및 &lt;code&gt;setindex!&lt;/code&gt; 위한 &lt;code&gt;SparseArray&lt;/code&gt; 또한 가능하게 &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 배열 :</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">이 예에서는 근본 원인 예외 (A)가 스택에서 가장 먼저 나오고 그 뒤에는 예외 (B)가 있습니다. 두 catch 블록을 정상적으로 종료 한 후 (즉, 추가 예외를 발생시키지 않고) 모든 예외는 스택에서 제거되고 더 이상 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">이 예에서는, &lt;code&gt;A&lt;/code&gt; 가 설정 될 수있는 하나 개의 요소를 포함하는 가변 컨테이너 &lt;code&gt;A[] = 1.0&lt;/code&gt; 와 함께 검색 &lt;code&gt;A[]&lt;/code&gt; . 모든 0 차원 배열의 크기 ( &lt;code&gt;size(A) == ()&lt;/code&gt; )와 길이 ( &lt;code&gt;length(A) == 1&lt;/code&gt; )는 같습니다. 특히, 0 차원 배열은 비어 있지 않습니다. 직관적이지 않다면 Julia의 정의를 이해하는 데 도움이되는 몇 가지 아이디어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">이 예제에서 &lt;code&gt;N&lt;/code&gt; 은 매개 변수로 전달되므로 &quot;값&quot;이 컴파일러에 알려져 있습니다. 본질적으로 &lt;code&gt;Val(T)&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 가 하드 코딩 / 리터럴 ( &lt;code&gt;Val(3)&lt;/code&gt; )이거나 유형 도메인에 이미 지정된 경우에만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">이 예에서 &lt;code&gt;b&lt;/code&gt; 는 아직 시작되지 않은 실행 가능한 &lt;code&gt;Task&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">이 예에서 &lt;code&gt;newfun&lt;/code&gt; 에 대한 새 정의 가 작성되었지만 즉시 호출 할 수 없음을 관찰하십시오 . 새 전역은 &lt;code&gt;tryeval&lt;/code&gt; 함수에 즉시 표시 되므로 괄호없이 &lt;code&gt;return newfun&lt;/code&gt; 을 작성할 수 있습니다. 그러나 당신이나 당신의 호출자, 그들이 호출하는 함수 등은이 새로운 메소드 정의를 호출 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">이 예에서 인출되고있는 원격는 &lt;em&gt;않습니다&lt;/em&gt; 라는 파일이 &lt;code&gt;our_file&lt;/code&gt; 우리는 다시 설정해야하는 이유입니다 색인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">이 예에서 작업은 pid 1에서 호출 된 pid 2에서 실행되었습니다.</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">이 예제에서 튜플 &lt;code&gt;(1,2,3)&lt;/code&gt; 은 조건부 테스트에 대한 표현식으로 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">이 예에서 변수 &lt;code&gt;a&lt;/code&gt; 의 값 이 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">이 예제에서 호출 된 최상위 함수가 &lt;code&gt;event.jl&lt;/code&gt; 파일에 있음을 알 수 있습니다. Julia를 실행할 때 REPL을 실행하는 기능입니다. &lt;code&gt;REPL.jl&lt;/code&gt; 의 97 번째 줄을 살펴보면 &lt;code&gt;eval_user_input()&lt;/code&gt; 함수 가 호출 된 위치를 확인할 수 있습니다. 이것은 REPL에서 입력 한 내용을 평가하는 함수이며, 대화식으로 작업하기 때문에 &lt;code&gt;@profile myfunc()&lt;/code&gt; 입력했을 때 이러한 함수가 호출되었습니다 . 다음 행은 &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt; 매크로 에서 수행 된 작업을 반영합니다 .</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">이러한 방식으로 Julia는 자체 &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;전 처리기&lt;/a&gt; 역할을하며 언어 내부에서 코드를 생성 할 수 있습니다. 위의 코드는 &lt;code&gt;:&lt;/code&gt; 접두사 인용 양식을 사용하여 약간 더 간결하게 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">이 모듈에서는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 함수를 &lt;code&gt;export&lt;/code&gt; 키워드로 ) 내 보내지 않은 함수 &lt;code&gt;p&lt;/code&gt; 를 갖습니다 . 현재 작업 공간에 모듈 및 내부 기능을로드하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdbf4c0d317d8b968227eee1bb592e9cd8a0e88" translate="yes" xml:space="preserve">
          <source>In this particular case, the number of elements skipped &lt;em&gt;in memory&lt;/em&gt; matches the number of &lt;em&gt;linear indices&lt;/em&gt; skipped. This is only the case for contiguous arrays like &lt;code&gt;Array&lt;/code&gt; (and other &lt;code&gt;DenseArray&lt;/code&gt; subtypes) and is not true in general. Views with range indices are a good example of &lt;em&gt;non-contiguous&lt;/em&gt; strided arrays; consider &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt;. This view &lt;code&gt;V&lt;/code&gt; refers to the same memory as &lt;code&gt;A&lt;/code&gt; but is skipping and re-arranging some of its elements. The stride of the first dimension of &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; because we're only selecting every third row from our original array:</source>
          <target state="translated">이 특별한 경우, &lt;em&gt;메모리에서&lt;/em&gt; 건너 뛴 요소 의 수는 건너 뛴 &lt;em&gt;선형 인덱스&lt;/em&gt; 의 수와 일치합니다 . 이것은 &lt;code&gt;Array&lt;/code&gt; (및 기타 &lt;code&gt;DenseArray&lt;/code&gt; 하위 유형)와 같은 연속 배열의 경우에만 해당되며 일반적으로 사실이 아닙니다. 범위 인덱스가있는 뷰는 &lt;em&gt;연속되지 않은&lt;/em&gt; strided 배열 의 좋은 예입니다 . 고려 &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt; . 이 뷰 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 동일한 메모리를 참조 하지만 일부 요소를 건너 뛰고 다시 정렬합니다. 의 첫 번째 차원의 보폭 &lt;code&gt;V&lt;/code&gt; 는 이다 &lt;code&gt;3&lt;/code&gt; 우리가 우리의 원래의 배열에서 매 세 번째 행을 선택하고 있기 때문에 :</target>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">이 경우 건너 뛰기 기능을 사용하여 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 을 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">이러한 스타일의 정의에서 코드 생성 기능은 본질적으로 선택적 최적화입니다. 컴파일러는 편리하다면이를 사용하지만, 그렇지 않으면 대신 일반 구현을 사용하도록 선택할 수 있습니다. 이 스타일은 컴파일러가 더 많은 결정을 내리고 더 많은 방식으로 프로그램을 컴파일 할 수있게하고, 일반적인 코드는 코드 생성 코드보다 더 읽기 쉽기 때문에 선호됩니다. 그러나 사용되는 구현은 컴파일러 구현 세부 사항에 따라 다르므로 두 구현이 동일하게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">이 장난감 예제에서 두 가지 방법을 쉽게 구별하고 선택할 수 있습니다. 그러나 실제 프로그램에서 데이터 이동을 설계하려면 더 많은 생각과 측정이 필요할 수 있습니다. 예를 들어, 첫 번째 프로세스에 행렬 &lt;code&gt;A&lt;/code&gt; 가 필요한 경우 첫 번째 방법이 더 좋습니다. 또는 컴퓨팅 &lt;code&gt;A&lt;/code&gt; 가 비싸고 현재 프로세스에만있는 경우 다른 프로세스로 옮기는 것이 불가피 할 수 있습니다. 또는 현재 프로세스가 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;fetch(Bref)&lt;/code&gt; 사이에 할 일이 거의 없다면 병렬 처리를 완전히 제거하는 것이 좋습니다. 또는 &lt;code&gt;rand(1000,1000)&lt;/code&gt; 가 더 비싼 작업으로 교체 되었다고 상상해보십시오 . 그런 다음 이 단계에만 다른 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 문 을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4f15c62fbcd9523fb3f2a21376c6d6f2fb45889e" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">이 장난감 예제에서 두 가지 방법은 쉽게 구별하고 선택할 수 있습니다. 그러나 실제 프로그램에서 데이터 이동을 설계하려면 더 많은 생각과 측정이 필요할 수 있습니다. 예를 들어 첫 번째 프로세스에 행렬 &lt;code&gt;A&lt;/code&gt; 가 필요한 경우 첫 번째 방법이 더 좋을 수 있습니다. 또는 계산 &lt;code&gt;A&lt;/code&gt; 가 비싸고 현재 프로세스에만있는 경우 다른 프로세스로 이동하는 것이 불가피 할 수 있습니다. 또는 현재 프로세스가 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;fetch(Bref)&lt;/code&gt; 사이에 할 일이 거의 없다면 병렬 처리를 모두 제거하는 것이 좋습니다. 또는 &lt;code&gt;rand(1000,1000)&lt;/code&gt; 이 더 비싼 연산으로 대체 되었다고 상상해보십시오 . 그런 다음 다른 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 을 추가하는 것이 합리적 일 수 있습니다. 이 단계에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">이러한 방식으로, 모든 작업자가 다른 모든 작업자와 직접 연결되는 메시 네트워크가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">색인에서 파일 항목의 메모리 내 표현. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">적절한 &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; 방법 을 정의하여 전체 방송을 지원할 수 있습니다 . &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;bc&lt;/code&gt; 의 특정 하위 유형 을 전문화하고 싶을 수 있으므로 패키지 간의 모호성을 피하려면 다음 규칙을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b8eaa806ba1cb1b5e2ab868bf0bb847fbaf77f5" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의에 적절한 버전의 &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 위치 버전 : 임의의 &lt;code&gt;v&lt;/code&gt; 를 제자리에서 임의로 퍼뮤 테이션 하고 선택적으로 난수 생성기 &lt;code&gt;rng&lt;/code&gt; 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">전체 버전의 &lt;code&gt;reverse&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">받은 편지함 트레이</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">함수가 수행하는 작업 또는 단순화 된 서명 블록 다음에 객체가 나타내는 것을 설명하는 단일 한 줄 문장을 포함하십시오. 필요한 경우 빈 줄 뒤에 두 번째 단락에 자세한 내용을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;# Examples&lt;/code&gt; 섹션 에 코드 예제를 포함 하십시오.</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">다른 모듈에 동일한 코드를 포함하면 믹스 인과 유사한 동작을 제공합니다. 이것을 사용하여 다른 기본 정의로 동일한 코드를 실행할 수 있습니다 (예 : 일부 연산자의 &quot;안전한&quot;버전으로 코드를 실행하여 코드 테스트).</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">들어오는 봉투</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">불완전한 초기화</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">로 증가</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">위에서 설명한 증분 기록 검색</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">인덱서 블 컬렉션</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="translated">인덱싱 된 할당</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">인덱싱 및 할당</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">정렬 함수가 삽입 정렬 알고리즘을 사용해야 함을 나타냅니다. 삽입 정렬은 한 번에 한 요소 씩 컬렉션을 통과하여 각 요소를 출력 목록의 올바른 정렬 된 위치에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">정렬 함수가 병합 정렬 알고리즘을 사용해야 함을 나타냅니다. 병합 정렬은 전체 컬렉션이 정렬 된 형태로 다시 결합 될 때까지 컬렉션을 하위 컬렉션으로 나누고 반복적으로 병합하여 각 단계에서 각 하위 컬렉션을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정렬 기능이 부분 빠른 정렬 알고리즘을 사용해야 함을 나타냅니다. 부분 빠른 정렬은 가장 작은 &lt;code&gt;k&lt;/code&gt; 요소를 가장 작은 것에서 가장 큰 것까지 정렬하여 &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; 를&lt;/a&gt; 사용하여 정렬하고 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">정렬 기능이 빠른 정렬 알고리즘을 사용해야한다고 표시합니다 . 이 알고리즘은 안정적 &lt;em&gt;이지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여부를 표시 &lt;code&gt;x&lt;/code&gt; 가 됩니다 &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">통과해야하지만 현재 지속적으로 실패한 테스트를 나타냅니다. &lt;code&gt;ex&lt;/code&gt; 식이 &lt;code&gt;false&lt;/code&gt; 로 평가 되는지 또는 예외가 발생 하는지 테스트합니다 . &lt;code&gt;Broken&lt;/code&gt; 경우 &lt;code&gt;Result&lt;/code&gt; 리턴 하고 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가되면 &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">프로세스의 문제가있는 종료 상태를 나타냅니다. 명령 또는 파이프 라인을 실행할 때 0이 아닌 종료 코드가 리턴되었음을 나타냅니다 (즉, 호출 된 프로세스가 실패 함).</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인덱스는 &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; 반환 한 것과 같은 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">색인화되지 않은 후행 치수가 모두 길이 인 경우 인덱스를 생략 할 수 있습니다. 다시 말해, 후행 색인은 인바운드 인덱싱 표현식에 대해 생략 된 색인이 가능한 값이 하나만있는 경우에만 생략 할 수 있습니다. 예를 들어, 크기가 &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; 차원 배열 은 건너 뛴 차원 (4 차원)의 길이가 1이므로 인덱스가 3 개만으로 인덱스 될 수 있습니다. 선형 인덱싱이이 규칙보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인덱스 또는 키는 &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; 반환 한 것과 같은 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">간접 통화</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">에 의해 반환 된 개별 포인터를 &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 로 번역 될 수 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; 로 전달하여 S &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">필연적으로, 그렇게 간단하지 않은 명령을 작성하려고하므로 따옴표를 사용해야합니다. 다음은 쉘 프롬프트에서 Perl one-liner의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">부정확 한 동등 비교 : &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 기본 &lt;code&gt;atol&lt;/code&gt; 은 0이고 기본 &lt;code&gt;rtol&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 유형에 따라 다릅니다 . 키워드 인수 &lt;code&gt;nans&lt;/code&gt; 는 NaN 값이 동일한 것으로 간주되는지 여부를 결정합니다 (기본값은 false).</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">생성 된 함수에 대한 추론은 코드가이 상태를 관찰하거나 변경하려고 시도하는 동안을 포함하여 &lt;em&gt;언제든지&lt;/em&gt; 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">안내 데스크 사람</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">정보 출처</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">데이터 유형에 대한 정보</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">배열의 크기에 대한 정보</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">초기화는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;x = 1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">첫 번째 루프 반복으로 &lt;code&gt;x = 1 / rand()&lt;/code&gt; 초기화 한 다음 &lt;code&gt;for i = 2:10&lt;/code&gt; 루프 합니다.</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">처음에 &lt;code&gt;f(x)&lt;/code&gt; 에는 하나의 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">인라인 요소</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">내부 생성자 메소드</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">그러나 내부 로컬 범위는 상위 범위의 변수를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">라틴 대문자의 입력 기호</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">라틴 문자의 입력 기호</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">라틴어 소문자 입력 기호</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">숫자 입력 기호</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">기호 입력 기호</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">순차 일관성 메모리 펜스 삽입</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">삽입 &lt;code&gt;item&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 주어진에서 &lt;code&gt;index&lt;/code&gt; . &lt;code&gt;index&lt;/code&gt; 는 결과 &lt;code&gt;a&lt;/code&gt; 의 &lt;code&gt;item&lt;/code&gt; 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">실행하지 않고 새 줄 삽입</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; 시작 부분에 하나 이상의 &lt;code&gt;items&lt;/code&gt; 을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; 이 끝날 때 하나 이상의 &lt;code&gt;items&lt;/code&gt; 을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="6f3f950f8d7377ccffdca0b939ba6ac7684b1f51" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; in &lt;code&gt;collection&lt;/code&gt;. If &lt;code&gt;collection&lt;/code&gt; is an ordered container, the items are inserted at the end (in the given order).</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; 하나 이상의 &lt;code&gt;items&lt;/code&gt; 을 삽입합니다 . 경우 &lt;code&gt;collection&lt;/code&gt; 순서 컨테이너의 항목 (지정된 순서대로) 단부에 삽입된다.</target>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 요소를 삽입 &lt;code&gt;items&lt;/code&gt; 의 시작 부분에 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">순서가 일관된 순서 의미론으로 메모리 펜스를 삽입합니다. 이것이 필요한 곳에, 즉 획득 / 릴리스 순서가 불충분 한 알고리즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a79f039f9c26eb844e9abd4767d0e8224e23795" translate="yes" xml:space="preserve">
          <source>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</source>
          <target state="translated">프로그램에 가비지 수집이 실행될 수있는 지점을 삽입합니다. 이는 일부 스레드가 메모리를 할당하고 (따라서 GC를 실행해야 할 수도 있음) 다른 스레드가 단순한 작업 (할당, 작업 전환 또는 I / O 없음) 만 수행하는 다중 스레드 프로그램에서 드문 경우에 유용 할 수 있습니다. 비 할당 스레드에서이 함수를 주기적으로 호출하면 가비지 수집이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 내부 에서 &lt;code&gt;kwargs&lt;/code&gt; 는 명명 된 튜플에 대한 키-값 반복자입니다. 명명 된 튜플 (및 &lt;code&gt;Symbol&lt;/code&gt; 키가있는 사전 )은 호출에서 세미콜론을 사용하여 키워드 인수로 전달할 수 있습니다 &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; 예 : f (x, z = 1; kwargs ...)) .</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">함수 호출 내에서 &lt;code&gt;f(a=b)&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 를 키워드 인수 &lt;code&gt;a&lt;/code&gt; 의 값으로 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">로컬 범위 내부 전역 변수는 키워드를 사용하여 할당 할 수 있습니다 &lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">로컬 범위 내에서 &lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 변수를 새 로컬 변수로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d117997a7534c274cbe92ad615675971d22bedb" translate="yes" xml:space="preserve">
          <source>Inside of the &lt;code&gt;greet&lt;/code&gt; function, the assignment &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; causes &lt;code&gt;x&lt;/code&gt; to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local &lt;code&gt;x&lt;/code&gt; variable. Since &lt;code&gt;x&lt;/code&gt; is local, it doesn't matter if there is a global named &lt;code&gt;x&lt;/code&gt; or not. Here for example we define &lt;code&gt;x = 123&lt;/code&gt; before defining and calling &lt;code&gt;greet&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;greet&lt;/code&gt; 함수 내 에서 할당 &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 가 함수 범위의 새로운 지역 변수가되도록합니다. 두 가지 관련 사실이 있습니다. 할당이 로컬 범위에서 발생하고 기존 로컬 &lt;code&gt;x&lt;/code&gt; 변수 가 없습니다 . 이후 &lt;code&gt;x&lt;/code&gt; 는 로컬, 거기 글로벌라는 이름의 경우 중요하지 않습니다 &lt;code&gt;x&lt;/code&gt; 여부. 예를 들어 &lt;code&gt;greet&lt;/code&gt; 를 정의하고 호출하기 전에 &lt;code&gt;x = 123&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쉼표가있는 괄호 안에 &lt;code&gt;(a=1,)&lt;/code&gt; 은 &lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; 을&lt;/a&gt; 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">지정된 UUID를 검사하고 해당 버전을 반환합니다 ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">인스턴스는 &lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 를 통해 또는 &lt;code&gt;big&lt;/code&gt; 문자열 리터럴을 사용하여 문자열에서 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">무언가를 계산하거나 동작을 수행하는 대신 , 평가할 때 원하는 것을 수행하는 &lt;em&gt;인용 식&lt;/em&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">배열을 직접 정렬하는 대신 배열을 정렬 된 순서로 배열하는 배열 인덱스의 순열을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">백틱은 명령을 즉시 실행하는 대신 명령 을 나타내는 &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 개체를 만듭니다 . 이 객체를 사용하여 파이프를 통해 명령을 다른 사람에게 연결하고 &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt; 후 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 거나 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">Julia는 등록 된 버전의 &lt;code&gt;Example&lt;/code&gt; 을로드하는 대신 &lt;code&gt;tutorial/dev/Example&lt;/code&gt; 에 포함 된 소스 코드를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">생성 된 함수 선언은 계산 또는 동작을 수행하는 대신 인용 된 표현식을 반환하고 인수의 유형에 해당하는 메소드의 본문을 형성합니다. 생성 된 함수가 호출되면 리턴하는 표현식이 컴파일 된 후 실행됩니다. 이를 효율적으로 만들기 위해 결과는 일반적으로 캐시됩니다. 그리고 이것을 불가피하게 만들기 위해, 언어의 제한된 부분 집합 만 사용할 수 있습니다. 따라서 생성 된 함수는 허용 된 구성에 대한 더 큰 제한을 희생하면서 런타임에서 컴파일 시간으로 작업을 이동하는 유연한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">대신 &lt;code&gt;catch&lt;/code&gt; 후에 세미콜론을 사용하거나 줄 바꿈을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">정수 나누기 ( &lt;code&gt;div&lt;/code&gt; 함수)에는 두 가지 예외적 인 경우가 있습니다 : 0으로 나누기 및 가장 작은 음수 ( &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; )를 -1로 나누기 . 이 두 경우 모두 &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. 나머지 및 계수 함수 ( &lt;code&gt;rem&lt;/code&gt; 및 &lt;code&gt;mod&lt;/code&gt; ) 는 두 번째 인수가 0 일 때 &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">분모 값이 0 인 정수 나누기를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">제곱근 정수 : 최대 정수 &lt;code&gt;m&lt;/code&gt; 이되도록 &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">정수 값 N은 N 개의 추가 로컬 작업자 프로세스를 시작합니다. 로컬 CPU 스레드 수 (논리 코어)만큼 많은 작업자 &lt;code&gt;auto&lt;/code&gt; 시작</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">정수 및 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">정수 및 부동 소수점 값은 산술 및 계산의 기본 빌딩 블록입니다. 이러한 값의 내장 표현을 숫자 프리미티브라고하며, 코드에서 즉시 값으로 정수 및 부동 소수점 숫자를 표현하는 것을 숫자 리터럴이라고합니다. 예를 들어 &lt;code&gt;1&lt;/code&gt; 은 정수 리터럴이고 &lt;code&gt;1.0&lt;/code&gt; 은 부동 소수점 리터럴입니다. 객체로서의 이진 메모리 내 표현은 숫자 프리미티브입니다.</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">정수는 표준 방식으로 비트를 비교하여 비교됩니다. 부동 소수점 숫자는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 에 따라 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">포인트 연산자 주위의 적분</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">슬래시가 포함 된 적분 평균</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">더블 스트로크와 통합</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">교차로와 통합</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">오버 바와 통합</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">시간 표시와 통합</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">언더 바와 통합</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">연합과 통합</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">인텔의 &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune &amp;trade; 증폭기&lt;/a&gt; ( 빌드 구성에서 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 설정 됨) 또는</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">어떤 식 으로든 &lt;code&gt;Core.Compiler&lt;/code&gt; 의 내용 또는 방법과 상호 작용</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">대화식 유틸리티</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">대화식 모드; REPL이 실행되고 &lt;code&gt;isinteractive()&lt;/code&gt; 가 true</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">밀도가 높은 형식과 스파 스 형식을 상호 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">BLAS 서브 루틴에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">C 표준 라이브러리 인 libc에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">LAPACK 서브 루틴에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">인테리어 제품</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">내부적으로 &lt;code&gt;promote_type&lt;/code&gt; 은 promote 내부에서 사용되어 &lt;code&gt;promote&lt;/code&gt; 을 위해 변환 할 유형 인수 값을 결정합니다. 그러나 자체적으로 유용 할 수 있습니다. 호기심 많은 독자는 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; 의 코드를 읽을 수 있습니다.이 코드 는 약 35 줄의 완전한 프로모션 메커니즘을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">내부적으로 &lt;code&gt;AbstractChar&lt;/code&gt; 유형은 다양한 인코딩을 사용할 수 있습니다. &lt;code&gt;codepoint(char)&lt;/code&gt; 를 통한 변환 은 항상 문자의 유니 코드 값을 반환하므로이 인코딩을 나타내지 않습니다. &lt;code&gt;c::AbstractChar&lt;/code&gt; 의 &lt;code&gt;print(io, c)&lt;/code&gt; 는 필요한 경우 &lt;code&gt;Char&lt;/code&gt; 로 변환하여 &lt;code&gt;io&lt;/code&gt; (모든 내장 &lt;code&gt;IO&lt;/code&gt; 유형의 경우 UTF-8)에 의해 결정된 인코딩을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">내부적으로이 코드는 함수의 두 가지 구현을 생성 &lt;code&gt;if @generated&lt;/code&gt; 를 사용하는 경우 첫 번째 블록이 생성 되고 &lt;code&gt;else&lt;/code&gt; 블록이 사용되는 일반 블록이 생성됩니다. &lt;code&gt;if @generated&lt;/code&gt; 블록 의 &lt;code&gt;then&lt;/code&gt; 부분 에서 코드는 다른 생성 된 함수와 동일한 의미를 갖습니다. 인수 이름은 유형을 나타내며 코드는 표현식을 반환해야합니다. &lt;code&gt;if @generated&lt;/code&gt; 블록이 발생하는 경우 여러 개 ,이 경우 생성 된 구현은 모든 &lt;code&gt;then&lt;/code&gt; 블록을 사용하고 대체 구현은 &lt;code&gt;else&lt;/code&gt; 블록을 모두 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">따옴표없는 표현식으로 보간하는 것은 지원되지 않으며 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="213daae9f453b89afd1148247dfa9083fa51630b" translate="yes" xml:space="preserve">
          <source>Interpolating values via &lt;code&gt;$&lt;/code&gt; is available as of Julia 1.4.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 를 통한 보간 값 은 Julia 1.4부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">반복 가능한 키-값 쌍을 명명 된 튜플로 해석하고 병합을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">해석 : 형식이 잘못된 배열의 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">해석 : 불안정한 함수 &lt;code&gt;g&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">해석 : 불안정한 리턴 유형의 함수</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">해석 : 잎이 아닌 유형의 필드를 가져옵니다. 이 경우 &lt;code&gt;ArrayContainer&lt;/code&gt; 에는 field &lt;code&gt;data::Array{T}&lt;/code&gt; 있습니다. 그러나 &lt;code&gt;Array&lt;/code&gt; 도 치수 &lt;code&gt;N&lt;/code&gt; 이 콘크리트 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; 출력을 사촌 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; &lt;/a&gt; 의 출력과 같이 해석하는 것은 약간의 연습이 필요합니다. 코드는 컴파일 된 기계 코드를 생성하는 과정에서 크게 요약 된 형태로 제공됩니다. 대부분의 표현식은 &lt;code&gt;::T&lt;/code&gt; 로 표시되는 유형으로 주석이 달립니다 (예 : &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 일 수 있음 ). &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; 의 가장 중요한 특징은 비 콘크리트 유형이 빨간색으로 표시 된다는 것입니다. 위의 예에서 이러한 출력은 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b25ba536a0a42dea499d4fc2b8979e5924399239" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; 의 출력을 사촌 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; &lt;/a&gt; 의 출력과 같이 해석하려면 약간의 연습이 필요합니다. 귀하의 코드는 컴파일 된 기계어 코드를 생성하는 과정에서 많이 소화 된 형태로 제공됩니다. 대부분의 표현식은 &lt;code&gt;::T&lt;/code&gt; (예 : &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 일 수 있음)로 표시되는 유형으로 주석 처리됩니다 . &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; 의 가장 중요한 특징은 콘크리트가 아닌 유형이 빨간색으로 표시 된다는 것입니다. 이 문서는 색이없는 Markdown으로 작성 되었기 때문에이 문서에서 빨간색 텍스트는 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">중단 또는 취소</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">지정된 워커에서 현재 실행중인 작업을 중단합니다. 이것은 로컬 컴퓨터에서 Ctrl-C를 누르는 것과 같습니다. 인수가 없으면 모든 작업자가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">교차 모든 세트 및 덮어 쓰기 전달 &lt;code&gt;s&lt;/code&gt; 결과에. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">교차로 옆의 교차로</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">점이있는 교차점</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">논리적 교차</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">오버 바와의 교차점</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">직관적으로 이는 함수의 인수 유형이 함수 시그니처의 하위 유형 인 특성에 해당합니다 (서명이 일치하는 경우).</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">역 탄환</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">역 화이트 서클</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">느낌표</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">거꾸로 된 S</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">거꾸로 옴 기호 / Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">거꾸로 된 물음표</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">지정된 인수 &lt;code&gt;args&lt;/code&gt; 에 대해 지정된 유형 &lt;code&gt;argtypes&lt;/code&gt; 와 일치 하고 키워드 인수 &lt;code&gt;kwargs&lt;/code&gt; 를 전달하여 지정된 제네릭 함수 &lt;code&gt;f&lt;/code&gt; 에 대한 메소드를 호출하십시오 . 인수 &lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;argtypes&lt;/code&gt; 에 지정된 유형을 준수해야합니다 . 즉, 변환이 자동으로 수행되지 않습니다. 이 메소드를 사용하면 가장 구체적인 일치 메소드 이외의 메소드를 호출 할 수 있습니다. 이는보다 일반적인 정의의 동작이 명시 적으로 필요할 때 (종종 동일한 함수의보다 구체적인 메소드 구현의 일부로) 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f0c54c7c50c82bf234e4ed64cb3ce50f2fd86de8" translate="yes" xml:space="preserve">
          <source>Invoke all handlers from &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt;&lt;code&gt;Experimental.register_error_hint&lt;/code&gt;&lt;/a&gt; for the particular exception type &lt;code&gt;typeof(ex)&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; must contain any other arguments expected by the handler for that type.</source>
          <target state="translated">특정 예외 유형 &lt;code&gt;typeof(ex)&lt;/code&gt; 대해 &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt; &lt;code&gt;Experimental.register_error_hint&lt;/code&gt; &lt;/a&gt; 에서 모든 핸들러를 호출합니다 . &lt;code&gt;args&lt;/code&gt; 에는 해당 유형에 대한 처리기에서 예상하는 다른 모든 인수 가 포함되어야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="474a6d17a6faabac287216094db27839ef426282" translate="yes" xml:space="preserve">
          <source>Is Julia named after someone or something?</source>
          <target state="translated">Julia는 누군가 또는 무언가의 이름을 따서 명명 되었습니까?</target>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">문제 8859, &quot;최소 제곱 수정&quot;, https://github.com/JuliaLang/julia/pull/8859</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">또한 지수 함수 작성을보다 우아하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">더 효율적일 수 있습니다. 일부 구조체는 배열로 효율적으로 압축 될 수 있으며, 경우에 따라 컴파일러는 불변 개체를 완전히 할당하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">이 일이 발생할 수 있습니다 &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; 이미 정의되어 &lt;code&gt;Random&lt;/code&gt; 모듈. 그런 다음 실제로 (이 특정 RNG 유형의 생성을 전문화하려는 경우) 1 단계를 건너 뛸 수 있지만 해당 &lt;code&gt;SamplerS&lt;/code&gt; 유형은 내부 세부 사항으로 간주되며 경고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">Julia의 핵심 코드와 C 및 Fortran 라이브러리 (선택 사항)로 프로파일 링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c491763305aba9f2c8a952732183092d445bd3cb" translate="yes" xml:space="preserve">
          <source>It decomposes &lt;code&gt;[A; B]&lt;/code&gt; into &lt;code&gt;[UC; VS]H&lt;/code&gt;, where &lt;code&gt;[UC; VS]&lt;/code&gt; is a natural orthogonal basis for the column space of &lt;code&gt;[A; B]&lt;/code&gt;, and &lt;code&gt;H = RQ'&lt;/code&gt; is a natural non-orthogonal basis for the rowspace of &lt;code&gt;[A;B]&lt;/code&gt;, where the top rows are most closely attributed to the &lt;code&gt;A&lt;/code&gt; matrix, and the bottom to the &lt;code&gt;B&lt;/code&gt; matrix. The multi-cosine/sine matrices &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; provide a multi-measure of how much &lt;code&gt;A&lt;/code&gt; vs how much &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; provide directions in which these are measured.</source>
          <target state="translated">분해 &lt;code&gt;[A; B]&lt;/code&gt; 로 &lt;code&gt;[UC; VS]H&lt;/code&gt; , 여기서 &lt;code&gt;[UC; VS]&lt;/code&gt; 는 &lt;code&gt;[A; B]&lt;/code&gt; , &lt;code&gt;H = RQ'&lt;/code&gt; 는 &lt;code&gt;[A;B]&lt;/code&gt; 의 행 공간에 대한 자연스러운 비 직교 기저입니다 . 여기서 맨 위 행은 &lt;code&gt;A&lt;/code&gt; 행렬에 가장 가깝고 맨 아래는 &lt;code&gt;B&lt;/code&gt; 행렬에 가장 가깝습니다 . 다중 코사인 / 사인 행렬 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 양에 대한 다중 측정 값을 제공 하고 &lt;code&gt;U&lt;/code&gt; 와 &lt;code&gt;V&lt;/code&gt; 는 측정 방향을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">돌아 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">특수 컴파일 규칙이 있습니다. &lt;code&gt;VecElement{T}&lt;/code&gt; 의 동종 튜플은 &lt;code&gt;T&lt;/code&gt; 가 기본 비트 유형이고 튜플 길이가 {2-6,8-10,16} 세트 인 경우 LLVM &lt;code&gt;vector&lt;/code&gt; 유형에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="60e06d084730278b0af0749e7022e6e9535b9603" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type.</source>
          <target state="translated">특별한 컴파일 규칙이 있습니다. &lt;code&gt;VecElement{T}&lt;/code&gt; 의 동종 튜플은 &lt;code&gt;T&lt;/code&gt; 가 원시 비트 유형일 때 LLVM &lt;code&gt;vector&lt;/code&gt; 유형에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">최상위 &lt;code&gt;path&lt;/code&gt; 항목 이 있고 &lt;code&gt;uuid&lt;/code&gt; 는 해당 경로에 매핑되며 프로젝트 파일이 포함 된 디렉토리를 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">블록 유형의 객체를 생성하는 &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 라는 특수 로컬 존재 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e219a846f311411f285e81a3aae4c1e7bf0947a9" translate="yes" xml:space="preserve">
          <source>It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</source>
          <target state="translated">고유 한 기본 유형을 정의하는 것보다 새 복합 유형으로 기존 기본 유형을 래핑하는 것이 거의 항상 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">&lt;code&gt;@generated&lt;/code&gt; 함수가 메소드 재정의와 어떻게 상호 작용 하는지 확인하는 것도 중요합니다 . 올바른 &lt;code&gt;@generated&lt;/code&gt; 함수가 변경 가능한 상태를 관찰하거나 전역 상태의 돌연변이를 유발해서는 안된다는 원칙에 따라 다음과 같은 동작이 나타납니다. 생성 된 함수는 관찰 &lt;em&gt;할 수없는&lt;/em&gt; 이전에 정의되지 않은 임의의 방법 호출 &lt;em&gt;정의&lt;/em&gt; 생성 기능 자체를.</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">일반 스칼라와의 차이점을 이해하는 것도 중요합니다. 스칼라는 가변 컨테이너가 아닙니다 (반복 가능하고 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; , &lt;em&gt;예를 들어 &lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ). 특히, &lt;code&gt;x = 0.0&lt;/code&gt; 이 스칼라로 정의되면 &lt;code&gt;x[] = 1.0&lt;/code&gt; 통해 값을 변경하려고 시도하면 오류가 발생합니다 . 스칼라 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;fill(x)&lt;/code&gt; 를 통해이를 포함 하는 0 차원 배열 로 변환 될 수 있으며 , 반대로 0 차원 배열 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;a[]&lt;/code&gt; 를 통해 포함 된 스칼라로 변환 될 수 있습니다 . 또 다른 차이점은 스칼라가 &lt;code&gt;2 * rand(2,2)&lt;/code&gt; 와 같은 선형 대수 연산에 참여할 수 있다는 것입니다그러나 0 차원 배열 &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; 의 유사한 연산 은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">의 컬렉션을 반복 할 수 있도록 종종 유용 &lt;em&gt;역순으로&lt;/em&gt; 반복하여 &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; &lt;/a&gt; . 그러나 역순 반복을 실제로 지원하려면 반복자 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; 대한 &lt;code&gt;iterate&lt;/code&gt; 을 구현해야합니다 . ( &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; 를 제공하면 &lt;code&gt;T&lt;/code&gt; 유형의 밑줄 반복자 는 &lt;code&gt;r.itr&lt;/code&gt; 입니다.) &lt;code&gt;Squares&lt;/code&gt; 예제에서 &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; 메소드를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; 를 색상으로 사용하여 볼드체 형식을 적용 할 수도 있습니다 . 예를 들어, 굵은 글꼴로 답변을 인쇄하려면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 로 다음을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">브라우저에서 &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; 를 통해 Julia REPL과 상호 작용할 수도 있습니다 . 자세한 내용은 패키지 홈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="107b61cbdd6b182357e4837cba9afce4360112e7" translate="yes" xml:space="preserve">
          <source>It is also used to &lt;code&gt;show&lt;/code&gt; julia source code which has gone through macro hygiene or otherwise contains variable names which can't be parsed normally.</source>
          <target state="translated">또한 매크로 위생을 통과했거나 정상적으로 구문 분석 할 수없는 변수 이름이 포함 된 줄리아 소스 코드 를 &lt;code&gt;show&lt;/code&gt; 하는데도 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt; 와 같은 상수를 제외하고 전역 변수에서 직접 작동하는 대신 함수가 인수를 사용해야한다는 점을 강조 할 가치가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">오류를 잡는 것보다 오류를 피하는 것이 좋습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
