<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="224ffdcfcf894add89408ae517c7ef3d12b95041" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital T</source>
          <target state="translated">수학 산세 리프 캐피탈 T</target>
        </trans-unit>
        <trans-unit id="2c7b56ae20e1bd42a48cf6aa81701fccda860c69" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital U</source>
          <target state="translated">수학 산세 리프 수도 U</target>
        </trans-unit>
        <trans-unit id="c6d343e7cdd6e8bf0911fa13d73dacf4f22dea79" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital V</source>
          <target state="translated">수학 산세 리프 캐피탈 V</target>
        </trans-unit>
        <trans-unit id="91306c6e45ac8e9e2acaa1fab80a425a1b33da1b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital W</source>
          <target state="translated">수학 산세 리프 수도 W</target>
        </trans-unit>
        <trans-unit id="ebce32b2d0821c45a9a7308830c29b7d37dcdb54" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital X</source>
          <target state="translated">수학 산세 리프 수도 X</target>
        </trans-unit>
        <trans-unit id="d81dbe4e26a3ebaed62fd22eaa493ab748ec4680" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital Y</source>
          <target state="translated">수학 산세 리프 수도 Y</target>
        </trans-unit>
        <trans-unit id="869c27fb10e3d3dcf153b7c7b1638af395cc7125" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Capital Z</source>
          <target state="translated">수학 산세 리프 캐피탈 Z</target>
        </trans-unit>
        <trans-unit id="34ccfc2848d139933a3055d1d8f58fb8e1472fec" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Eight</source>
          <target state="translated">수학 산세 리프 숫자 8</target>
        </trans-unit>
        <trans-unit id="8d2508a4068c3fdbdafe2af5b2aafcac618bf0d2" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Five</source>
          <target state="translated">수학 산세 리프 숫자 5</target>
        </trans-unit>
        <trans-unit id="3822e65c8f0db884820d647392f6dfa130edf9b1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Four</source>
          <target state="translated">수학 산세 리프 숫자 4</target>
        </trans-unit>
        <trans-unit id="badc61e0b60a16ada07cdac85324f16cbc727b53" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Nine</source>
          <target state="translated">수학 산세 리프 숫자 9</target>
        </trans-unit>
        <trans-unit id="10d87a7149332b0809b1214d8bcdcf6e29a19663" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit One</source>
          <target state="translated">수학적 Sans-Serif Digit One</target>
        </trans-unit>
        <trans-unit id="e89064d8fb47e8828be124e56792789b305d76a0" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Seven</source>
          <target state="translated">수학 산세 리프 숫자 7</target>
        </trans-unit>
        <trans-unit id="99e28f68677ad323e0b98219df50f9510d3a871a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Six</source>
          <target state="translated">수학 산세 리프 숫자 6</target>
        </trans-unit>
        <trans-unit id="744fd833f6eb766ce62a65a6c97df45a8887d1ed" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Three</source>
          <target state="translated">수학 산세 리프 숫자 3</target>
        </trans-unit>
        <trans-unit id="b8a26ca79a1a69581e8cc61a81a8a3a79c07474f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Two</source>
          <target state="translated">수학 산세 리프 숫자 2</target>
        </trans-unit>
        <trans-unit id="3fae34a9a325d979b30cecaa17316be1866b376e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Digit Zero</source>
          <target state="translated">수학 산세 리프 숫자 0</target>
        </trans-unit>
        <trans-unit id="5d660d000eb9c072b6e0094a3c9dace62de92506" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital A</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 A</target>
        </trans-unit>
        <trans-unit id="0bb1d80b74c20328966d83f84493c44227aa52fa" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital B</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 B</target>
        </trans-unit>
        <trans-unit id="19dd38c3c7119eec64e3d83f2618980e9128de2c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital C</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 C</target>
        </trans-unit>
        <trans-unit id="edc2cb67c45511abe043b944d5d729ba54cb5bcd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital D</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 D</target>
        </trans-unit>
        <trans-unit id="917b9c41912eac3d5303b4766db2887ce628c8a5" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital E</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 E</target>
        </trans-unit>
        <trans-unit id="778bce7602ff2ccdc6ec50761e791acb740e0730" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital F</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 F</target>
        </trans-unit>
        <trans-unit id="68b8893e17388cda1a0a7a39c7a88b3ae6182fda" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital G</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 G</target>
        </trans-unit>
        <trans-unit id="16bde5679f463c8a8b1b043235f38de648ecfe07" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital H</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 H</target>
        </trans-unit>
        <trans-unit id="a4f8befcaaaac58ae41d69c88ed6752253254e17" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital I</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 I</target>
        </trans-unit>
        <trans-unit id="aa6ad2f00fb3a45176516043a1b8c0fc652e1a7f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital J</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 J</target>
        </trans-unit>
        <trans-unit id="553a6c8da6f75e3bb2ec4122a0ae3eaf2771cfee" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital K</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 K</target>
        </trans-unit>
        <trans-unit id="4431f70b6eb81b439344cc8a0d63a4bd03785114" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital L</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 L</target>
        </trans-unit>
        <trans-unit id="953c187d78d9c7c73c321255d0f71e989635456e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital M</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 M</target>
        </trans-unit>
        <trans-unit id="a9521bb0f6d0426eeaa8913eb1ecdaf4654a2add" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital N</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 N</target>
        </trans-unit>
        <trans-unit id="b6fe7eca3981704dfeab71fd77906d954cd3293a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital O</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 O</target>
        </trans-unit>
        <trans-unit id="afc81f59b7619e6d5ed1c1ef3d4d27fc46d07ef1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital P</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 P</target>
        </trans-unit>
        <trans-unit id="2eb4837364a43a559e6a9ae01e2cbc8579635ff9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Q</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 Q</target>
        </trans-unit>
        <trans-unit id="f4170f808f4a58e651e1f30ec1b38142b5368ac3" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital R</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 R</target>
        </trans-unit>
        <trans-unit id="6ed1e2f57c2908845f6dae446da116d706104106" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital S</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 S</target>
        </trans-unit>
        <trans-unit id="53b834dee864f51c89a23bab556bf05fc17b8728" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital T</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 T</target>
        </trans-unit>
        <trans-unit id="5e7b06b361978376850cc80049273df0d0c888a6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital U</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 U</target>
        </trans-unit>
        <trans-unit id="ab7105c21ff496b2a879408b719fd0ce05c60ae4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital V</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 V</target>
        </trans-unit>
        <trans-unit id="6d648302dff736caeade12457fe111ebc3ba2254" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital W</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 W</target>
        </trans-unit>
        <trans-unit id="738e60d25b20be185ad0950799ab230e188ffdb7" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital X</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 X</target>
        </trans-unit>
        <trans-unit id="e05beb3bd17be0f678f5a1719d237847eee058b4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Y</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 Y</target>
        </trans-unit>
        <trans-unit id="7955357da8dfd8893b4f5f39485063ede1be84fc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Capital Z</source>
          <target state="translated">수학 산세 리프 이탤릭 대문자 Z</target>
        </trans-unit>
        <trans-unit id="6a669f3f7096e1ffdb56e99437ebdbf11f88ef6a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small A</source>
          <target state="translated">수학 산세 리프 이탤릭체 A</target>
        </trans-unit>
        <trans-unit id="b109cd714b1c3c2dc450aa06407161da6a7f77f6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small B</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 B</target>
        </trans-unit>
        <trans-unit id="ed75177f5c5301440bae8a62bb75961ccb78625d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small C</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 C</target>
        </trans-unit>
        <trans-unit id="e94f02a8df0dd43a88623ac9f670b7fb9fbca152" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small D</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 D</target>
        </trans-unit>
        <trans-unit id="c313981bfe90ef3251ffc3cc688155b7a81a4eb4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small E</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 E</target>
        </trans-unit>
        <trans-unit id="20e78fbfed5c894b98e25c125e313bc5cf447f2d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small F</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 F</target>
        </trans-unit>
        <trans-unit id="3ffbb30da62564f9f06a970c553cc75516f84d64" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small G</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 G</target>
        </trans-unit>
        <trans-unit id="88d4569ec69a641f56e15c592b5420acb6756658" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small H</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 H</target>
        </trans-unit>
        <trans-unit id="527de882367bf730b743029d0e5fc34aef66d93a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small I</source>
          <target state="translated">수학 산세 리프 이탤릭체 I</target>
        </trans-unit>
        <trans-unit id="6413e31c10e5d328d5d85c5e9ca95a49c9e21ecf" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small J</source>
          <target state="translated">수학 산세 리프 이탤릭체 J</target>
        </trans-unit>
        <trans-unit id="a5db0df4c93acba75eed44c7743aac650ae6c34b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small K</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 K</target>
        </trans-unit>
        <trans-unit id="3585a33c469a7e9760e4b538bb3569524349f02f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small L</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 L</target>
        </trans-unit>
        <trans-unit id="8fcffc00a78081012de345221981ed18a237268d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small M</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 M</target>
        </trans-unit>
        <trans-unit id="b6871fdb2d163e57d612fcabde4992bc15dd003c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small N</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 N</target>
        </trans-unit>
        <trans-unit id="c937e27b7635715ec5cdbf76e0efa6b56929bc86" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small O</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 O</target>
        </trans-unit>
        <trans-unit id="358d27db8cbac6e138375174968cc6bda89cb8e6" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small P</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 P</target>
        </trans-unit>
        <trans-unit id="d649933b039af4cc6ccb198f879e87c5399cc89b" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Q</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 Q</target>
        </trans-unit>
        <trans-unit id="6c401dff1e67d9840b91932bda1ef0136fefd859" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small R</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 R</target>
        </trans-unit>
        <trans-unit id="ed0d0e511fd42f8efa03aa03701e48d27d07ee1c" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small S</source>
          <target state="translated">수학 산세 리프 이탤릭체 S</target>
        </trans-unit>
        <trans-unit id="665077d5b70b09d0da320a8ffa53c41d3f8524b7" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small T</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 T</target>
        </trans-unit>
        <trans-unit id="c6be34ab09505856e660411e974fd3a42221242a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small U</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 U</target>
        </trans-unit>
        <trans-unit id="61ee4fac986e65b9f9b38987e86c7d3086e71c29" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small V</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 V</target>
        </trans-unit>
        <trans-unit id="e8c99e3e0c38259d313acad69a434702e64037ac" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small W</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 W</target>
        </trans-unit>
        <trans-unit id="c3b2f3f86234974194e4e947f671cbd926553fcf" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small X</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 X</target>
        </trans-unit>
        <trans-unit id="e72addcb8fd9b49dbcb3722d324fca9afd248498" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Y</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 Y</target>
        </trans-unit>
        <trans-unit id="66fde99af41406a4cf856fc8adba34e31522e74a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Italic Small Z</source>
          <target state="translated">수학 산세 리프 이탤릭체 작은 Z</target>
        </trans-unit>
        <trans-unit id="77c328f6771fa8ddbab73684a774a7092a4b97e4" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small A</source>
          <target state="translated">수학 산세 리프 스몰 A</target>
        </trans-unit>
        <trans-unit id="c01bd01b4a0fcfea0ba202d6062b1e54eeb2dd91" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small B</source>
          <target state="translated">수학적 산세 리프 스몰 B</target>
        </trans-unit>
        <trans-unit id="8a865bf2832e62512c96769afb09d8f387d805dc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small C</source>
          <target state="translated">수학적 산세 리프 소형 C</target>
        </trans-unit>
        <trans-unit id="a5e473505a5d5c7b0468b20d83e0fb0a984c9ccc" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small D</source>
          <target state="translated">수학 산세 리프 스몰 D</target>
        </trans-unit>
        <trans-unit id="2dd2f6e391e11eb4e9d603594ea1956ef225f063" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small E</source>
          <target state="translated">수학적 산세 리프 소형 E</target>
        </trans-unit>
        <trans-unit id="6044db6f6f77fb35e8dd548bf74f758c8396e600" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small F</source>
          <target state="translated">수학적 산세 리프 소형 F</target>
        </trans-unit>
        <trans-unit id="b47402646c107a31f8ed4d8387b0b3d5cfaf96b5" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small G</source>
          <target state="translated">수학적 산세 리프 스몰 G</target>
        </trans-unit>
        <trans-unit id="f6f4b1a5e51ed52919fc443504c4948fbfa6a300" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small H</source>
          <target state="translated">수학적 산세 리프 소형 H</target>
        </trans-unit>
        <trans-unit id="26f43312416d72451957125c8b8a223b8bdab17e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small I</source>
          <target state="translated">수학 산세 리프 소형 I</target>
        </trans-unit>
        <trans-unit id="f8ad9b39197a0315952dbc6af33952d11c63742f" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small J</source>
          <target state="translated">수학 산세 리프 스몰 J</target>
        </trans-unit>
        <trans-unit id="13035b445ebd649d777f895052d0296d22cb3b25" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small K</source>
          <target state="translated">수학 산세 리프 스몰 K</target>
        </trans-unit>
        <trans-unit id="d07f8f7e568456c7898c9a51fabf220c7644359d" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small L</source>
          <target state="translated">수학 산세 리프 스몰 L</target>
        </trans-unit>
        <trans-unit id="9bb94d1d8a58d7274d3dd8781047baff099aa5d9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small M</source>
          <target state="translated">수학적 산세 리프 스몰 M</target>
        </trans-unit>
        <trans-unit id="fd8ec5dc12f206ba4aeda9b993990981407358d8" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small N</source>
          <target state="translated">수학 산세 리프 스몰 N</target>
        </trans-unit>
        <trans-unit id="54b27a0c278909de47f1ee1d25ba4a08ab3413fd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small O</source>
          <target state="translated">수학 산세 리프 스몰 O</target>
        </trans-unit>
        <trans-unit id="afe9ac3ff58ec88dbffcb57e6865734fff20ab14" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small P</source>
          <target state="translated">수학적 산세 리프 스몰 P</target>
        </trans-unit>
        <trans-unit id="1d4448fc451d2375a3f1cff51cf083164a229d55" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Q</source>
          <target state="translated">수학적 산세 리프 소형 Q</target>
        </trans-unit>
        <trans-unit id="3f782d20e8c19ef7ea890ed9f09494590f2f271e" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small R</source>
          <target state="translated">수학 산세 리프 스몰 R</target>
        </trans-unit>
        <trans-unit id="d75e3864e82bd62798c29ddf494890eeb20f8150" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small S</source>
          <target state="translated">수학 산세 리프 스몰 S</target>
        </trans-unit>
        <trans-unit id="5375a5057566851c55c7b5106b2ea5c8174c20bd" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small T</source>
          <target state="translated">수학적 산세 리프 소형 T</target>
        </trans-unit>
        <trans-unit id="d9191d78c85cd7c4e251a452f6e73569bf5f5777" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small U</source>
          <target state="translated">수학 산세 리프 소형 U</target>
        </trans-unit>
        <trans-unit id="ed40757c941d8a43afad6867391b120d2ecc00e9" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small V</source>
          <target state="translated">수학 산세 리프 소형 V</target>
        </trans-unit>
        <trans-unit id="7c0555c5968b11f230f8ecd85cf950dafa82a98a" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small W</source>
          <target state="translated">수학 산세 리프 소형 W</target>
        </trans-unit>
        <trans-unit id="c18f38cbbd42a240797d31dcafbd56e9e889bfb1" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small X</source>
          <target state="translated">수학 산세 리프 소형 X</target>
        </trans-unit>
        <trans-unit id="a0262cfe3582fc841b07ceabd801d3ad5563ecb3" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Y</source>
          <target state="translated">수학 산세 리프 소형 Y</target>
        </trans-unit>
        <trans-unit id="9df2eb71500e01948b6ae94956e34c3050a6c2da" translate="yes" xml:space="preserve">
          <source>Mathematical Sans-Serif Small Z</source>
          <target state="translated">수학 산세 리프 스몰 Z</target>
        </trans-unit>
        <trans-unit id="e781204cb8aa75c591f4f8c4e417898fc65c5578" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital A</source>
          <target state="translated">수학 스크립트 대문자 A</target>
        </trans-unit>
        <trans-unit id="87a5b78d3cc66c44dc0f7e55dbe220c0492cd843" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital C</source>
          <target state="translated">수학 스크립트 대문자 C</target>
        </trans-unit>
        <trans-unit id="df68ec98e92ee5f88a61b2936d6f1393a59622fa" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital D</source>
          <target state="translated">수학 스크립트 대문자 D</target>
        </trans-unit>
        <trans-unit id="5eaa653854dec24875818d1274419d0d1579b5ff" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital G</source>
          <target state="translated">수학 스크립트 대문자 G</target>
        </trans-unit>
        <trans-unit id="0b129c86714dfa5b69f78e54ec29708531e991cc" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital J</source>
          <target state="translated">수학 스크립트 대문자 J</target>
        </trans-unit>
        <trans-unit id="cceece1a02a7b18a7b2a25f72e451f18b78a0e9d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital K</source>
          <target state="translated">수학 스크립트 대문자 K</target>
        </trans-unit>
        <trans-unit id="2e190fcd0e74e49d79bf183058e429a33e67a14a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital N</source>
          <target state="translated">수학 스크립트 대문자 N</target>
        </trans-unit>
        <trans-unit id="a20c7fdd0045e55dd18385e4723cc7c9e9316662" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital O</source>
          <target state="translated">수학 스크립트 대문자 O</target>
        </trans-unit>
        <trans-unit id="9330e7fcb0ae4cc996d6da34414a0459a8ee82aa" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital P</source>
          <target state="translated">수학 스크립트 대문자 P</target>
        </trans-unit>
        <trans-unit id="af18cf1b8f17cee876055abf18963e4d7b6f4f6d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Q</source>
          <target state="translated">수학 스크립트 대문자 Q</target>
        </trans-unit>
        <trans-unit id="4bb9f4b44eca35819890344af676b337253a7b02" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital S</source>
          <target state="translated">수학적 스크립트 대문자 S</target>
        </trans-unit>
        <trans-unit id="b3d047bb0bdcfa36a10f27a4ba225cb84d7ce8a6" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital T</source>
          <target state="translated">수학적 스크립트 대문자 T</target>
        </trans-unit>
        <trans-unit id="6827599cd6e355eb8752adafbb8b32fb87dc337a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital U</source>
          <target state="translated">수학 스크립트 대문자 U</target>
        </trans-unit>
        <trans-unit id="c263a0559788ac9d3e77592e2829c6d114cc7d58" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital V</source>
          <target state="translated">수학 스크립트 대문자 V</target>
        </trans-unit>
        <trans-unit id="4ba8e4151a26e2953a89d684d69818b9b3c0db84" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital W</source>
          <target state="translated">수학 스크립트 대문자 W</target>
        </trans-unit>
        <trans-unit id="409719dea8db475534ad2211a316bc8456ff4274" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital X</source>
          <target state="translated">수학 스크립트 대문자 X</target>
        </trans-unit>
        <trans-unit id="3202429f1ca867375f3227d68c9bf684da8ac22c" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Y</source>
          <target state="translated">수학 스크립트 대문자 Y</target>
        </trans-unit>
        <trans-unit id="161d99918ad5b9b0229b3042834c7285d0ecfe64" translate="yes" xml:space="preserve">
          <source>Mathematical Script Capital Z</source>
          <target state="translated">수학 스크립트 대문자 Z</target>
        </trans-unit>
        <trans-unit id="88e5c65d846248c4c565a65cfc2e474605647be5" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small A</source>
          <target state="translated">수학 스크립트 작은 A</target>
        </trans-unit>
        <trans-unit id="8bfa40bbb4e6f1d8738ec741d9c445536b61501a" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small B</source>
          <target state="translated">수학 스크립트 작은 B</target>
        </trans-unit>
        <trans-unit id="acff05dfba64829fd4b17f980e8d9bf5a7267376" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small C</source>
          <target state="translated">수학 스크립트 작은 C</target>
        </trans-unit>
        <trans-unit id="48850c032f6a3a7d79a5286336903c473c781b4b" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small D</source>
          <target state="translated">수학 스크립트 작은 D</target>
        </trans-unit>
        <trans-unit id="fa82d93fd22632aa5f4c510b6aaf7f7ad8f24fe9" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small F</source>
          <target state="translated">수학 스크립트 Small F</target>
        </trans-unit>
        <trans-unit id="c1c173a156db5908e1c9cf16d53184b85ad4179d" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small H</source>
          <target state="translated">수학 스크립트 작은 H</target>
        </trans-unit>
        <trans-unit id="8d97b76d63cd562f090a430ab9522d2f1d4df9c6" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small I</source>
          <target state="translated">수학 스크립트 작은 나</target>
        </trans-unit>
        <trans-unit id="60b7e29c76188f307d6c423da68fa2dc8f11d0e7" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small J</source>
          <target state="translated">수학 스크립트 작은 J</target>
        </trans-unit>
        <trans-unit id="df5c1f55e99d3d61b3af1f8de891055be6401a72" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small K</source>
          <target state="translated">수학 스크립트 Small K</target>
        </trans-unit>
        <trans-unit id="1ccd7d2676d7ec8f9a260e02c77004b279c349b5" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small L</source>
          <target state="translated">수학 스크립트 작은 L</target>
        </trans-unit>
        <trans-unit id="9529218e212048395f0a5af50f6e560c0b20b6ed" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small M</source>
          <target state="translated">수학 스크립트 작은 M</target>
        </trans-unit>
        <trans-unit id="b6947301d6e7abb24efbdb6da1f711dce96aef10" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small N</source>
          <target state="translated">수학 스크립트 작은 N</target>
        </trans-unit>
        <trans-unit id="2cd12fce07554f3f68f4fa72dc3c9b8a2288e06b" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small P</source>
          <target state="translated">수학 스크립트 Small P</target>
        </trans-unit>
        <trans-unit id="38c682085a9ff93fd9e8c5ac33f6cb7f2ce12cca" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Q</source>
          <target state="translated">수학 스크립트 작은 Q</target>
        </trans-unit>
        <trans-unit id="75801a5ec6e75edd468ad75e6f4ef52a8e5c801e" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small R</source>
          <target state="translated">수학 스크립트 작은 R</target>
        </trans-unit>
        <trans-unit id="47e70e85a32518e50cff199a739e67c5d033b3df" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small S</source>
          <target state="translated">수학 스크립트 작은 S</target>
        </trans-unit>
        <trans-unit id="d11168475256d528b51adff5486ce3944c51fbf7" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small T</source>
          <target state="translated">수학 스크립트 작은 T</target>
        </trans-unit>
        <trans-unit id="502226569b5eb35c99fd0b79be6ecc923e71df8e" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small U</source>
          <target state="translated">수학 스크립트 작은 U</target>
        </trans-unit>
        <trans-unit id="0ac7a9a62e95370706905a88d8fc04443a48b2ba" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small V</source>
          <target state="translated">수학 스크립트 작은 V</target>
        </trans-unit>
        <trans-unit id="3d3e2481ffa93292df3a1e3d9be65e95415fb4df" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small W</source>
          <target state="translated">수학 스크립트 작은 W</target>
        </trans-unit>
        <trans-unit id="3179527cd0bf80d9e87fa6adb0b4f18e0ffb60ae" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small X</source>
          <target state="translated">수학 스크립트 작은 X</target>
        </trans-unit>
        <trans-unit id="591a1c0d4440ce0ae720ca4545a1dc72fbe0fa31" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Y</source>
          <target state="translated">수학 스크립트 작은 Y</target>
        </trans-unit>
        <trans-unit id="ff010d413406b76a23e9dcc5046e4f6aa0d567d8" translate="yes" xml:space="preserve">
          <source>Mathematical Script Small Z</source>
          <target state="translated">수학 스크립트 작은 Z</target>
        </trans-unit>
        <trans-unit id="77e774bacbdb4d919d66d929940fc5bdbe59d534" translate="yes" xml:space="preserve">
          <source>Mathematics</source>
          <target state="translated">Mathematics</target>
        </trans-unit>
        <trans-unit id="58947ebc8ff43456c10a258659e8fb435561a3ff" translate="yes" xml:space="preserve">
          <source>Matrix</source>
          <target state="translated">Matrix</target>
        </trans-unit>
        <trans-unit id="5a4970506ff97e891dcbb638ac6c10d9beeb948e" translate="yes" xml:space="preserve">
          <source>Matrix determinant.</source>
          <target state="translated">행렬 결정.</target>
        </trans-unit>
        <trans-unit id="763455038835785197036c60ba888ed8cd2abc12" translate="yes" xml:space="preserve">
          <source>Matrix division using a polyalgorithm. For input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, the result &lt;code&gt;X&lt;/code&gt; is such that &lt;code&gt;A*X == B&lt;/code&gt; when &lt;code&gt;A&lt;/code&gt; is square. The solver that is used depends upon the structure of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is upper or lower triangular (or diagonal), no factorization of &lt;code&gt;A&lt;/code&gt; is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</source>
          <target state="translated">폴리 알고리즘을 사용한 행렬 나누기. 입력 행렬 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 경우, 결과 &lt;code&gt;X&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 가 제곱 일 때 A &lt;code&gt;A*X == B&lt;/code&gt; 됩니다 . 사용되는 솔버는 &lt;code&gt;A&lt;/code&gt; 의 구조에 따라 다릅니다 . 경우 &lt;code&gt;A&lt;/code&gt; 는 상부 또는 하 삼각 (대각선)이고, 전혀 분해 &lt;code&gt;A&lt;/code&gt; 필요하지 않으므로 시스템은 하나 앞뒤로 교체로 해결된다. 삼각형이 아닌 정사각 행렬의 경우 LU 인수 분해가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c5da95a5ae0b4da596632b3b7cc1f9110f46b42" translate="yes" xml:space="preserve">
          <source>Matrix exponential, equivalent to $\exp(\log(b)A)$.</source>
          <target state="translated">행렬 지수는 $ \ exp (\ log (b) A) $와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5d345531891af4d5ff9cf449cb3b1e46b968471" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LDLt&lt;/code&gt; factorization of a real &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt; matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; is a &lt;a href=&quot;#LinearAlgebra.UnitLowerTriangular&quot;&gt;&lt;code&gt;UnitLowerTriangular&lt;/code&gt;&lt;/a&gt; matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">매트릭스의 인수 분해 형 &lt;code&gt;LDLt&lt;/code&gt; 실제의 인수 &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; &lt;/a&gt; 행렬 &lt;code&gt;S&lt;/code&gt; 되도록 &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; 은 A는 &lt;a href=&quot;#LinearAlgebra.UnitLowerTriangular&quot;&gt; &lt;code&gt;UnitLowerTriangular&lt;/code&gt; 된&lt;/a&gt; 행렬 &lt;code&gt;d&lt;/code&gt; 는 벡터이다. 의 주 사용 &lt;code&gt;LDLt&lt;/code&gt; 인수 &lt;code&gt;F = ldlt(S)&lt;/code&gt; 선형 방정식들의 시스템을 해결하기 &lt;code&gt;Sx = b&lt;/code&gt; 와 &lt;code&gt;F\b&lt;/code&gt; . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="924fcf97406b11f89e1528156edeb0bfc0067c6c" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LQ&lt;/code&gt; factorization of a matrix &lt;code&gt;A&lt;/code&gt;. The &lt;code&gt;LQ&lt;/code&gt; decomposition is the &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt; decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 분해에 대한 행렬 분해 유형입니다 . &lt;code&gt;LQ&lt;/code&gt; 의 분해는이다 &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; &lt;/a&gt; 분해 &lt;code&gt;transpose(A)&lt;/code&gt; . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt; &lt;code&gt;lq&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="a12aaced3881a71d1787cefcdb489f847f788675" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the &lt;code&gt;LU&lt;/code&gt; factorization of a square matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">정사각형 행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LU&lt;/code&gt; 분해에 대한 행렬 분해 유형입니다 . 이것은 해당 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="fe4a6e66ee7e3b3869496bc9841a6ad61c8628fc" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'UDU'P&lt;/code&gt; or &lt;code&gt;P'LDL'P&lt;/code&gt;, depending on whether the upper (the default) or the lower triangle is stored in &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;, respectively. This is the return type of &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">대칭 또는 에르 미트 행렬의 무리-카우프만 인수 분해 매트릭스의 인수 분해 형식 같은 &lt;code&gt;P'UDU'P&lt;/code&gt; 또는 &lt;code&gt;P'LDL'P&lt;/code&gt; , 위 (디폴트) 또는 하부 삼각형이 저장되었는지 여부에 따라 . 경우 &lt;code&gt;A&lt;/code&gt; 는 복잡한 다음 대칭 &lt;code&gt;U'&lt;/code&gt; 와 &lt;code&gt;L'&lt;/code&gt; 접합되지 전치, 즉 나타내는 &lt;code&gt;transpose(U)&lt;/code&gt; 및 &lt;code&gt;transpose(L)&lt;/code&gt; 각각. 이것은 해당 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3574ad0c400da103651eecdd956e3b062cdc35b0" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">조밀 한 대칭 / 헤르 미트 양의 정부 호 행렬 &lt;code&gt;A&lt;/code&gt; 의 촐레 스키 분해의 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c20447ccdfaf58f9ab4d1e53629b88a4e0a41324" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the Schur factorization of a matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur(_)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 Schur 분해에 대한 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur(_)&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="f5317626a88971c1522bbb978f1708a516baf677" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the eigenvalue/spectral decomposition of a square matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">정사각형 행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 / 스펙트럼 분해에 대한 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="6f1045ede9ec8762e91443cc3b20c1f1e3a81dab" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized Schur factorization of two matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur(_, _)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">두 행렬 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 Schur 분해의 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur(_, _)&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b2c855aa3fe59a37f74ffd7afa54a791b7ecba23" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized eigenvalue/spectral decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function, when called with two matrix arguments.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 고유 값 / 스펙트럼 분해의 행렬 분해 유형입니다 . 이것은 두 개의 행렬 인수와 함께 호출 될 때 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="0768172e7f95d1da41aa3f848b750d50d5ab6a85" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the generalized singular value decomposition (SVD) of two matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, such that &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; and &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd(_, _)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">일반화 된 특이 값 분해 매트릭스 인수 분해 형식 두 행렬 (SVD) 및 &lt;code&gt;B&lt;/code&gt; ,되도록 &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; 및 &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt; . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd(_, _)&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516873b3b274aab33fbfb7c63d4c6bc529f31889" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive semi-definite matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky(_, Val(true))&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">조밀 한 대칭 / 에르 미트 식 양의 반 정밀 행렬 &lt;code&gt;A&lt;/code&gt; 의 피벗 된 촐레 스키 분해의 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky(_, Val(true))&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="e534e67e08eb8c4983d753538af87a205b6c6282" translate="yes" xml:space="preserve">
          <source>Matrix factorization type of the singular value decomposition (SVD) of a matrix &lt;code&gt;A&lt;/code&gt;. This is the return type of &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd(_)&lt;/code&gt;&lt;/a&gt;, the corresponding matrix factorization function.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 특이 값 분해 (SVD)에 대한 행렬 분해 유형입니다 . 이것은 대응하는 행렬 분해 함수 인 &lt;a href=&quot;#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd(_)&lt;/code&gt; &lt;/a&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="363bb2b595e809cc54ad9681e48b4f445597455e" translate="yes" xml:space="preserve">
          <source>Matrix factorizations</source>
          <target state="translated">행렬 분해</target>
        </trans-unit>
        <trans-unit id="57db3d21b0671f1b99640ca19fb50219ae5719b1" translate="yes" xml:space="preserve">
          <source>Matrix inverse. Computes matrix &lt;code&gt;N&lt;/code&gt; such that &lt;code&gt;M * N = I&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the identity matrix. Computed by solving the left-division &lt;code&gt;N = M \ I&lt;/code&gt;.</source>
          <target state="translated">역행렬. &lt;code&gt;M * N = I&lt;/code&gt; 되도록 행렬 &lt;code&gt;N&lt;/code&gt; 을 계산합니다 . 여기서 &lt;code&gt;I&lt;/code&gt; 은 항등 행렬입니다. 왼쪽 나누기 &lt;code&gt;N = M \ I&lt;/code&gt; 를 해결하여 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="1e1606fb6bae143ac56fdb561605c843975256bf" translate="yes" xml:space="preserve">
          <source>Matrix multiplication.</source>
          <target state="translated">행렬 곱셈.</target>
        </trans-unit>
        <trans-unit id="7d6ad85bd5e8146c0b359115e69f993f07f46178" translate="yes" xml:space="preserve">
          <source>Matrix power, equivalent to $\exp(p\log(A))$</source>
          <target state="translated">매트릭스 파워, $ \ exp (p \ log (A)) $</target>
        </trans-unit>
        <trans-unit id="9a15627babff19100b77ee14c6a2d191c015168f" translate="yes" xml:space="preserve">
          <source>Matrix trace. Sums the diagonal elements of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">매트릭스 트레이스. &lt;code&gt;M&lt;/code&gt; 의 대각선 요소를 합산합니다 .</target>
        </trans-unit>
        <trans-unit id="47adefc07b1eaf2521a7bfa42bbff29f75e20cbc" translate="yes" xml:space="preserve">
          <source>Matrix type</source>
          <target state="translated">매트릭스 타입</target>
        </trans-unit>
        <trans-unit id="3fe8138da6605a25163c96dc2d486b42f5cfa3be" translate="yes" xml:space="preserve">
          <source>Matrix type for storing sparse matrices in the &lt;a href=&quot;#man-csc&quot;&gt;Compressed Sparse Column&lt;/a&gt; format. The standard way of constructing SparseMatrixCSC is through the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function. See also &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt;&lt;code&gt;spdiagm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sprand&quot;&gt;&lt;code&gt;sprand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#man-csc&quot;&gt;Compressed Sparse Column&lt;/a&gt; 형식으로 희소 행렬을 저장하기위한 행렬 유형입니다 . SparseMatrixCSC를 구성하는 표준 방법은 &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt; &lt;code&gt;spdiagm&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#SparseArrays.sprand&quot;&gt; &lt;code&gt;sprand&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dab92b63667beffc21eb02656bf328d9fd6e9f0f" translate="yes" xml:space="preserve">
          <source>Matrix type for storing sparse matrices in the &lt;a href=&quot;#man-csc-1&quot;&gt;Compressed Sparse Column&lt;/a&gt; format. The standard way of constructing SparseMatrixCSC is through the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function. See also &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt;&lt;code&gt;spdiagm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sprand&quot;&gt;&lt;code&gt;sprand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">희소 행렬을 &lt;a href=&quot;#man-csc-1&quot;&gt;압축 스파 스 열&lt;/a&gt; 형식으로 저장하기위한 행렬 유형입니다 . SparseMatrixCSC를 구성하는 표준 방법은 &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#SparseArrays.spdiagm&quot;&gt; &lt;code&gt;spdiagm&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#SparseArrays.sprand&quot;&gt; &lt;code&gt;sprand&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf1d39035482544215e965ec3f4bcf6e4f116f2" translate="yes" xml:space="preserve">
          <source>Matrix()</source>
          <target state="translated">Matrix()</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="d6c2803d69788d4452b8dc4ad969409843d18579" translate="yes" xml:space="preserve">
          <source>Measure performance with &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; and pay attention to memory allocation</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; 으로&lt;/a&gt; 성능 측정 및 메모리 할당에주의</target>
        </trans-unit>
        <trans-unit id="a1ad84abe6b3edf4c9e138a700204927dc427eeb" translate="yes" xml:space="preserve">
          <source>Measured Angle</source>
          <target state="translated">측정 각도</target>
        </trans-unit>
        <trans-unit id="548d26034f0ec59e4ba571d389aad1e24d2ff182" translate="yes" xml:space="preserve">
          <source>Measured Angle Opening Left</source>
          <target state="translated">왼쪽 측정 각도</target>
        </trans-unit>
        <trans-unit id="232225153f97b40ee5518de7eb39dc75d098d4dd" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Down And Left</source>
          <target state="translated">아래쪽 및 왼쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="da5a47ecf9d4ab9edb2b0388141f56d7f091db42" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Down And Right</source>
          <target state="translated">아래쪽 및 오른쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="f1f55bcc346fe9ea1e99c22cb917cc6c7d8c99c1" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Left And Down</source>
          <target state="translated">왼쪽 및 아래쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="e3db8a6b8e85a7c9e47e75c288f9e77c4d508a37" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Left And Up</source>
          <target state="translated">왼쪽에서 위쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="d59cc58d5c45d17b6ec4add32eecf32d2a5aca3e" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Right And Down</source>
          <target state="translated">오른쪽 아래로 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="ffb4558ac9229b540c5f26e65f51b285dc62320a" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Right And Up</source>
          <target state="translated">오른쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="90883044148da3d38ab4434d41e940637ea65bf1" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Up And Left</source>
          <target state="translated">위쪽 및 왼쪽을 가리키는 화살표로 열린 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="f35072267047ae73e8ae3d369f5f9330d4fa3f74" translate="yes" xml:space="preserve">
          <source>Measured Angle With Open Arm Ending In Arrow Pointing Up And Right</source>
          <target state="translated">위쪽 및 오른쪽 화살표가 열리는 팔 끝으로 측정 된 각도</target>
        </trans-unit>
        <trans-unit id="358d0fed23b749eaac11fb543b5a985d089a2cb3" translate="yes" xml:space="preserve">
          <source>Measured By</source>
          <target state="translated">에 의해 측정</target>
        </trans-unit>
        <trans-unit id="c8cc86a5dd97c91227baa73199d6011f203981fb" translate="yes" xml:space="preserve">
          <source>Measured Right Angle With Dot</source>
          <target state="translated">도트로 측정 된 직각</target>
        </trans-unit>
        <trans-unit id="8ed7f954e418ed1a12f72567b0854cca2382488e" translate="yes" xml:space="preserve">
          <source>Meat On Bone</source>
          <target state="translated">뼈에 고기</target>
        </trans-unit>
        <trans-unit id="b3d4ec4657cd52d15d0b2fa075de0da3c8fa5fb3" translate="yes" xml:space="preserve">
          <source>Medium Black Circle</source>
          <target state="translated">중간 검은 원</target>
        </trans-unit>
        <trans-unit id="80bc5f0c57c8c58b783aebf3f28eca1630bb79dc" translate="yes" xml:space="preserve">
          <source>Medium Shade</source>
          <target state="translated">중간 그늘</target>
        </trans-unit>
        <trans-unit id="ea37963b21d3852b8e65871e86083062b3635c36" translate="yes" xml:space="preserve">
          <source>Medium Small White Circle</source>
          <target state="translated">중간 작은 흰색 원</target>
        </trans-unit>
        <trans-unit id="669a889ac35ac91706ca35863f49a2df1fe69828" translate="yes" xml:space="preserve">
          <source>Medium White Circle</source>
          <target state="translated">중간 흰색 원</target>
        </trans-unit>
        <trans-unit id="26e65e893ae5535d32cd0105721177c58a22b962" translate="yes" xml:space="preserve">
          <source>Melon</source>
          <target state="translated">Melon</target>
        </trans-unit>
        <trans-unit id="1fd79b9555ddf59862d60aa0aa3bb74fb74aae78" translate="yes" xml:space="preserve">
          <source>Memo</source>
          <target state="translated">Memo</target>
        </trans-unit>
        <trans-unit id="89c8a2851d1755cf87365b4a7c55e5551cf878c6" translate="yes" xml:space="preserve">
          <source>Memory</source>
          <target state="translated">Memory</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="80a13013c630f5f1ec3aaad3aff8839307d7bf31" translate="yes" xml:space="preserve">
          <source>Memory Ownership</source>
          <target state="translated">메모리 소유권</target>
        </trans-unit>
        <trans-unit id="9f595228ed09ac531780d97b13ac4686afb7555d" translate="yes" xml:space="preserve">
          <source>Memory allocation analysis</source>
          <target state="translated">메모리 할당 분석</target>
        </trans-unit>
        <trans-unit id="3702db8927eec53d800914849f97d95c5310a2c2" translate="yes" xml:space="preserve">
          <source>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt;&lt;code&gt;Libc.free&lt;/code&gt;&lt;/a&gt; in Julia, as this may result in the &lt;code&gt;free&lt;/code&gt; function being called via the wrong &lt;code&gt;libc&lt;/code&gt; library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</source>
          <target state="translated">이러한 오브젝트의 메모리 할당 및 할당 해제는 C 프로그램에서와 같이 사용중인 라이브러리에서 적절한 정리 루틴을 호출하여 처리해야합니다. Julia에서 &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt; &lt;code&gt;Libc.free&lt;/code&gt; &lt;/a&gt; 를 사용하여 C 라이브러리에서 수신 한 객체를 해제하지 마십시오 . 잘못된 &lt;code&gt;libc&lt;/code&gt; 라이브러리 를 통해 &lt;code&gt;free&lt;/code&gt; 함수가 호출되어 Julia가 충돌 할 수 있습니다. 반대로 (Julia에서 할당 된 객체를 전달하여 외부 라이브러리에서 해제)는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca752bf22b395d153a231703b547f8f6637b3cdb" translate="yes" xml:space="preserve">
          <source>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt;&lt;code&gt;Libc.free&lt;/code&gt;&lt;/a&gt; in Julia, as this may result in the &lt;code&gt;free&lt;/code&gt; function being called via the wrong library and cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</source>
          <target state="translated">이러한 객체의 메모리 할당 및 할당 해제는 C 프로그램에서와 마찬가지로 사용중인 라이브러리에서 적절한 정리 루틴에 대한 호출로 처리되어야합니다. Julia의 &lt;a href=&quot;../../base/libc/index#Base.Libc.free&quot;&gt; &lt;code&gt;Libc.free&lt;/code&gt; &lt;/a&gt; 를 사용하여 C 라이브러리에서받은 개체를 해제하지 마십시오 . 잘못된 라이브러리를 통해 &lt;code&gt;free&lt;/code&gt; 함수가 호출되어 프로세스가 중단 될 수 있습니다. 그 반대 (외부 라이브러리에 의해 해제되도록 Julia에 할당 된 객체 전달)는 똑같이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d1e92f6ba02c20d5f0755cdf90826342a6825b7" translate="yes" xml:space="preserve">
          <source>Memory allocation minimum alignment for instances of this type. Can be called on any &lt;code&gt;isconcretetype&lt;/code&gt;.</source>
          <target state="translated">이 유형의 인스턴스에 대한 메모리 할당 최소 정렬. 모든 &lt;code&gt;isconcretetype&lt;/code&gt; 에서 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="475bc2651561a3c3ff5fe7691308be8b459d93e5" translate="yes" xml:space="preserve">
          <source>Memory layout</source>
          <target state="translated">메모리 레이아웃</target>
        </trans-unit>
        <trans-unit id="6350b7336b67c776ed6dad88b8f36942529d682b" translate="yes" xml:space="preserve">
          <source>Memory-mapped I/O</source>
          <target state="translated">메모리 매핑 된 I / O</target>
        </trans-unit>
        <trans-unit id="2794ee86f4e0460023fe30433be8584164633273" translate="yes" xml:space="preserve">
          <source>Mens Symbol</source>
          <target state="translated">망 기호</target>
        </trans-unit>
        <trans-unit id="606cb109e24d78205b205b9b6b7b2ac8d0838a63" translate="yes" xml:space="preserve">
          <source>Mercury</source>
          <target state="translated">Mercury</target>
        </trans-unit>
        <trans-unit id="4c5719d7c4f2064eda838f77bfedad9f94b74089" translate="yes" xml:space="preserve">
          <source>Merge changes from the annotated commits (captured as &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt;&lt;code&gt;GitAnnotated&lt;/code&gt;&lt;/a&gt; objects) &lt;code&gt;anns&lt;/code&gt; into the HEAD of the repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;em&gt;only&lt;/em&gt; a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if &lt;code&gt;fastforward&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the merge may produce a conflict file which the user will need to resolve.</source>
          <target state="translated">(으로 캡처 주석 커밋에서 병합 변경 &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt; &lt;code&gt;GitAnnotated&lt;/code&gt; &lt;/a&gt; 객체)는 &lt;code&gt;anns&lt;/code&gt; 저장소의 HEAD에 &lt;code&gt;repo&lt;/code&gt; . 경우 &lt;code&gt;fastforward&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , &lt;em&gt;단지&lt;/em&gt; FastForward의 병합이 허용됩니다. 이 경우 충돌이 발생하면 병합이 실패합니다. 그렇지 않으면 &lt;code&gt;fastforward&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 병합은 사용자가 해결해야하는 충돌 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d3cc5d3f4205143d0a97611bdaec4f401c0400d" translate="yes" xml:space="preserve">
          <source>Merge changes from the annotated commits (captured as &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt;&lt;code&gt;GitAnnotated&lt;/code&gt;&lt;/a&gt; objects) &lt;code&gt;anns&lt;/code&gt; into the HEAD of the repository &lt;code&gt;repo&lt;/code&gt;. The keyword arguments are:</source>
          <target state="translated">(으로 캡처 주석 커밋에서 병합 변경 &lt;a href=&quot;#LibGit2.GitAnnotated&quot;&gt; &lt;code&gt;GitAnnotated&lt;/code&gt; &lt;/a&gt; 객체)는 &lt;code&gt;anns&lt;/code&gt; 저장소의 HEAD에 &lt;code&gt;repo&lt;/code&gt; . 키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7ce51350f28e713c65619a1185c2251e4fffb1b" translate="yes" xml:space="preserve">
          <source>Merging 3 or more &lt;code&gt;NamedTuple&lt;/code&gt; requires at least Julia 1.1.</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; 을 3 개 이상 병합 하려면 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c65670ab4d7e518181387017cc3c5717a9a9ba92" translate="yes" xml:space="preserve">
          <source>Merging write calls:</source>
          <target state="translated">쓰기 호출 병합 :</target>
        </trans-unit>
        <trans-unit id="a23dc8e2c77e3a6452c8291f99396015eeb089f0" translate="yes" xml:space="preserve">
          <source>Message filtering can be influenced through the &lt;code&gt;JULIA_DEBUG&lt;/code&gt; environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with &lt;code&gt;JULIA_DEBUG=loading&lt;/code&gt; will activate &lt;code&gt;@debug&lt;/code&gt; log messages in &lt;code&gt;loading.jl&lt;/code&gt;:</source>
          <target state="translated">메시지 필터링은 &lt;code&gt;JULIA_DEBUG&lt;/code&gt; 환경 변수를 통해 영향을받을 수 있으며 파일 또는 모듈에 대한 디버그 로깅을 사용하는 쉬운 방법으로 사용됩니다. 예를 들어 &lt;code&gt;JULIA_DEBUG=loading&lt;/code&gt; loading으로 julia를 로드 하면 &lt;code&gt;loading.jl&lt;/code&gt; 에서 &lt;code&gt;@debug&lt;/code&gt; 로그 메시지를 활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="22044cc3e10ac89fed15c158bcf4c9dd9df53872" translate="yes" xml:space="preserve">
          <source>Message formatting can be controlled by setting keyword arguments:</source>
          <target state="translated">키워드 인수를 설정하여 메시지 형식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="222fdf66495fc331b8da7129d7c651c611e92684" translate="yes" xml:space="preserve">
          <source>Meta.@dump</source>
          <target state="translated">Meta.@dump</target>
        </trans-unit>
        <trans-unit id="85a319e78e27958b8ef35a197ddde64ea5769730" translate="yes" xml:space="preserve">
          <source>Meta.@lower</source>
          <target state="translated">Meta.@lower</target>
        </trans-unit>
        <trans-unit id="91f37afbc9d42ff2c695ddd44a635578eac293a4" translate="yes" xml:space="preserve">
          <source>Meta.ParseError</source>
          <target state="translated">Meta.ParseError</target>
        </trans-unit>
        <trans-unit id="ad24faf50729a9f9fa55e867adf30c04801050e3" translate="yes" xml:space="preserve">
          <source>Meta.lower()</source>
          <target state="translated">Meta.lower()</target>
        </trans-unit>
        <trans-unit id="be14fac5e46b300563c5bdc2b385a68630aa88ae" translate="yes" xml:space="preserve">
          <source>Meta.parse()</source>
          <target state="translated">Meta.parse()</target>
        </trans-unit>
        <trans-unit id="28cab2863ff5f2561f57d8cf91121b0008285f3e" translate="yes" xml:space="preserve">
          <source>Metaprogramming</source>
          <target state="translated">Metaprogramming</target>
        </trans-unit>
        <trans-unit id="ce061c8f0bff6c0d69b4ff339bf3343d178939e9" translate="yes" xml:space="preserve">
          <source>Method 1:</source>
          <target state="translated">방법 1 :</target>
        </trans-unit>
        <trans-unit id="1a6137e84cd28d78515d93851515bfcb8ef41c78" translate="yes" xml:space="preserve">
          <source>Method 2:</source>
          <target state="translated">방법 2 :</target>
        </trans-unit>
        <trans-unit id="638b1272755d57118313a429e75cc6d4fb6194fb" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;merge!(combine::Union{Function,Type}, args...)&lt;/code&gt; as an alias of &lt;code&gt;mergewith!(combine, args...)&lt;/code&gt; is still available for backward compatibility.</source>
          <target state="translated">방법 &lt;code&gt;merge!(combine::Union{Function,Type}, args...)&lt;/code&gt; 의 별칭으로 &lt;code&gt;mergewith!(combine, args...)&lt;/code&gt; 여전히 이전 버전과의 호환성을 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2751acf58f63b2b4f024bdf36f12f8f9082677db" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;merge(combine::Union{Function,Type}, args...)&lt;/code&gt; as an alias of &lt;code&gt;mergewith(combine, args...)&lt;/code&gt; is still available for backward compatibility.</source>
          <target state="translated">방법 &lt;code&gt;merge(combine::Union{Function,Type}, args...)&lt;/code&gt; 의 별칭으로 &lt;code&gt;mergewith(combine, args...)&lt;/code&gt; 여전히 이전 버전과의 호환성을 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221fbe033b132ab714e88f3065acadd17c36ca4b" translate="yes" xml:space="preserve">
          <source>Method Ambiguities</source>
          <target state="translated">방법 모호성</target>
        </trans-unit>
        <trans-unit id="333406c36ea643634128264fa62782e940988274" translate="yes" xml:space="preserve">
          <source>Method definitions can optionally have type parameters qualifying the signature:</source>
          <target state="translated">메소드 정의는 선택적으로 서명을 규정하는 유형 매개 변수를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ed8dfed2943ba3403b40ab7d40b3018af8b965" translate="yes" xml:space="preserve">
          <source>Method design and the avoidance of ambiguities</source>
          <target state="translated">분석법 설계 및 모호함 방지</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="7aed8ffa5a33f9bebcbfeed77cda3dcb44489be3" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;put!&lt;/code&gt;, &lt;code&gt;take!&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;isready&lt;/code&gt; and &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; are proxied onto the backing store on the remote process.</source>
          <target state="translated">방법을 &lt;code&gt;put!&lt;/code&gt; , &lt;code&gt;take!&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;isready&lt;/code&gt; 와 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; A의 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 는&lt;/a&gt; 원격 프로세스에서 배킹 스토어에 프락시된다.</target>
        </trans-unit>
        <trans-unit id="af99471f8043edf03013b29ba93261c8a6471c77" translate="yes" xml:space="preserve">
          <source>Methods are associated with types, so it is possible to make any arbitrary Julia object &quot;callable&quot; by adding methods to its type. (Such &quot;callable&quot; objects are sometimes called &quot;functors.&quot;)</source>
          <target state="translated">메소드는 유형과 연관되므로 유형에 메소드를 추가하여 임의의 Julia 오브젝트를 &quot;호출 가능&quot;하게 할 수 있습니다. (이러한 &quot;호출 가능한&quot;객체는 때때로 &quot;펑터&quot;라고합니다.)</target>
        </trans-unit>
        <trans-unit id="db723548b522ffbcc5a940d493198540527fdeeb" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-1 update of the Hermitian matrix &lt;code&gt;A&lt;/code&gt; with vector &lt;code&gt;x&lt;/code&gt; as &lt;code&gt;alpha*x*x' + A&lt;/code&gt;. &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; controls which triangle of &lt;code&gt;A&lt;/code&gt; is updated. Returns &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">복잡한 배열 전용 메서드입니다. 벡터 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;alpha*x*x' + A&lt;/code&gt; Hermitian 행렬 &lt;code&gt;A&lt;/code&gt; 의 Rank-1 업데이트 . &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 어떤 삼각형 이 업데이트 되는지 제어합니다 . &lt;code&gt;A&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bfcd7c3f933331c9493185e98f0d0d125e32c93f" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-1 update of the Hermitian matrix &lt;code&gt;A&lt;/code&gt; with vector &lt;code&gt;x&lt;/code&gt; as &lt;code&gt;alpha*x*x' + A&lt;/code&gt;. &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; controls which triangle of &lt;code&gt;A&lt;/code&gt; is updated. Returns &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">복잡한 배열에 대해서만 메소드. 벡터 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;alpha*x*x' + A&lt;/code&gt; Hermitian 행렬 &lt;code&gt;A&lt;/code&gt; 의 순위 1 업데이트 . &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 어느 삼각형 이 업데이트 되는지 제어합니다 . &lt;code&gt;A&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="adcacb77db29c56837bcd83292ba9c039d0b4aec" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-k update of the Hermitian matrix &lt;code&gt;C&lt;/code&gt; as &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; or &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; according to &lt;a href=&quot;#stdlib-blas-trans&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;. Only the &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;C&lt;/code&gt; is updated. Returns &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">복잡한 배열 전용 메서드입니다. &lt;a href=&quot;#stdlib-blas-trans&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; 에 따라 &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; 또는 &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; 로 Hermitian 행렬 &lt;code&gt;C&lt;/code&gt; 의 Rank-k 업데이트 . &lt;code&gt;C&lt;/code&gt; 의 &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 삼각형 만 업데이트됩니다. &lt;code&gt;C&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4465dbd291638c2e6d39be89b1495ed836d260fd" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Rank-k update of the Hermitian matrix &lt;code&gt;C&lt;/code&gt; as &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; or &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; according to &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;. Only the &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;C&lt;/code&gt; is updated. Returns &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">복잡한 배열에 대해서만 메소드. &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; 에 따라 Hermitian 행렬 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;alpha*A*A' + beta*C&lt;/code&gt; 또는 &lt;code&gt;alpha*A'*A + beta*C&lt;/code&gt; 순위 k 업데이트 . &lt;code&gt;C&lt;/code&gt; 의 &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 삼각형 만 업데이트됩니다. &lt;code&gt;C&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ddb20c7b85208cb61ca8f12e86f9eeabdbb2a780" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Returns the &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;alpha*A*A'&lt;/code&gt; or &lt;code&gt;alpha*A'*A&lt;/code&gt;, according to &lt;a href=&quot;#stdlib-blas-trans&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복잡한 배열 전용 메서드입니다. &lt;a href=&quot;#stdlib-blas-trans&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; 에 따라 &lt;code&gt;alpha*A*A'&lt;/code&gt; 또는 &lt;code&gt;alpha*A'*A&lt;/code&gt; 의 &lt;a href=&quot;#stdlib-blas-uplo&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 삼각형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0acde9ce1bc4e0bce92e875e5b980c000ea8f3e" translate="yes" xml:space="preserve">
          <source>Methods for complex arrays only. Returns the &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt;&lt;code&gt;uplo&lt;/code&gt;&lt;/a&gt; triangle of &lt;code&gt;alpha*A*A'&lt;/code&gt; or &lt;code&gt;alpha*A'*A&lt;/code&gt;, according to &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt;&lt;code&gt;trans&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복잡한 배열에 대해서만 메소드. &lt;a href=&quot;#stdlib-blas-trans-1&quot;&gt; &lt;code&gt;trans&lt;/code&gt; &lt;/a&gt; 에 따라 &lt;code&gt;alpha*A*A'&lt;/code&gt; 또는 &lt;code&gt;alpha*A'*A&lt;/code&gt; 의 &lt;a href=&quot;#stdlib-blas-uplo-1&quot;&gt; &lt;code&gt;uplo&lt;/code&gt; &lt;/a&gt; 삼각형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="31087378a8bbc77cc90dde57d0b24e402b04e866" translate="yes" xml:space="preserve">
          <source>Methods for working with Iterators.</source>
          <target state="translated">반복자와 작업하는 방법.</target>
        </trans-unit>
        <trans-unit id="b652fd8af9cd4414355894137d21ed352cdf7a08" translate="yes" xml:space="preserve">
          <source>Methods to implement</source>
          <target state="translated">구현 방법</target>
        </trans-unit>
        <trans-unit id="c083bff944879d9f528cf185eba0f496bc10a47d" translate="yes" xml:space="preserve">
          <source>Metro</source>
          <target state="translated">Metro</target>
        </trans-unit>
        <trans-unit id="242805378404a310345cf70839197bf474f74005" translate="yes" xml:space="preserve">
          <source>Microphone</source>
          <target state="translated">Microphone</target>
        </trans-unit>
        <trans-unit id="c0e7f4f223c04978a94419263b9e43e5ed355d3a" translate="yes" xml:space="preserve">
          <source>Microscope</source>
          <target state="translated">Microscope</target>
        </trans-unit>
        <trans-unit id="9b1285dbfa3f301ee305a18122073774afa9fefa" translate="yes" xml:space="preserve">
          <source>Middle Dot</source>
          <target state="translated">중간 점</target>
        </trans-unit>
        <trans-unit id="e408a463c8c8b04535936ec0388890fdb4eb6af4" translate="yes" xml:space="preserve">
          <source>Midline Horizontal Ellipsis</source>
          <target state="translated">중간 선 수평 줄임표</target>
        </trans-unit>
        <trans-unit id="fa3eb94a0a2b066b71bf209bbf87e72a3a0d9345" translate="yes" xml:space="preserve">
          <source>Milky Way</source>
          <target state="translated">은하수</target>
        </trans-unit>
        <trans-unit id="8fd89b05553b705a13699d7eda5f3995e28d70d1" translate="yes" xml:space="preserve">
          <source>Millisecond with a minimum width of 3</source>
          <target state="translated">최소 너비가 3 인 밀리 초</target>
        </trans-unit>
        <trans-unit id="e5493525f70ed44ae88e23154562cfe8abb0989f" translate="yes" xml:space="preserve">
          <source>Minibus</source>
          <target state="translated">Minibus</target>
        </trans-unit>
        <trans-unit id="dec22368362321945374f59262ecb815c9ca058d" translate="yes" xml:space="preserve">
          <source>Minidisc</source>
          <target state="translated">Minidisc</target>
        </trans-unit>
        <trans-unit id="f63cdf5a9fb88ddc55332d0332e0e9c814eca99c" translate="yes" xml:space="preserve">
          <source>Minus Sign</source>
          <target state="translated">빼기 기호</target>
        </trans-unit>
        <trans-unit id="aa58dd6ee65165aaa980990698cabc9c7f6af021" translate="yes" xml:space="preserve">
          <source>Minus Sign In Triangle</source>
          <target state="translated">빼기 기호 삼각형</target>
        </trans-unit>
        <trans-unit id="4ecfc39673921fa625e7c61530c0920fdc1d6211" translate="yes" xml:space="preserve">
          <source>Minus Sign With Comma Above</source>
          <target state="translated">위의 쉼표로 빼기 기호</target>
        </trans-unit>
        <trans-unit id="59ece43cec61f8aa8f09c373d63b6fda09eae8f1" translate="yes" xml:space="preserve">
          <source>Minus Sign With Dot Below</source>
          <target state="translated">아래 점이있는 빼기 기호</target>
        </trans-unit>
        <trans-unit id="aa51c42418d3ae6a07aefef69aa4b77d1056b220" translate="yes" xml:space="preserve">
          <source>Minus Sign With Falling Dots</source>
          <target state="translated">떨어지는 점 빼기 기호</target>
        </trans-unit>
        <trans-unit id="6783f03ccd844333eac42ccf91056e1122919617" translate="yes" xml:space="preserve">
          <source>Minus Sign With Rising Dots</source>
          <target state="translated">상승 점 빼기 기호</target>
        </trans-unit>
        <trans-unit id="86dc3e39a6aea834eb89a27cfa3557bba083ea09" translate="yes" xml:space="preserve">
          <source>Minus Tilde</source>
          <target state="translated">마이너스 틸드</target>
        </trans-unit>
        <trans-unit id="d3cded1fdd470c6cff7ce15251a9d83764ce60c5" translate="yes" xml:space="preserve">
          <source>Minus Tilde + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">마이너스 틸드 + 롱 솔리드 러스 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="64857cbc7d90e5ee4db91259927e9d694cb935aa" translate="yes" xml:space="preserve">
          <source>Minus-Or-Plus Sign</source>
          <target state="translated">빼기 또는 더하기 기호</target>
        </trans-unit>
        <trans-unit id="8b5948646931ab1583c24f6ce3e01373cd06fe81" translate="yes" xml:space="preserve">
          <source>Minute with a minimum width</source>
          <target state="translated">최소 너비의 분</target>
        </trans-unit>
        <trans-unit id="ba3a82cd6d42814797e7ed3d7e9faa0082c5d899" translate="yes" xml:space="preserve">
          <source>Mirror callback function</source>
          <target state="translated">미러 콜백 기능</target>
        </trans-unit>
        <trans-unit id="92185dc52f71ef75dafedf866a3c86e592962f6d" translate="yes" xml:space="preserve">
          <source>Missing</source>
          <target state="translated">Missing</target>
        </trans-unit>
        <trans-unit id="c3453e940833c50faba05ca307352e54c2797a6f" translate="yes" xml:space="preserve">
          <source>Missing Values</source>
          <target state="translated">결 측값</target>
        </trans-unit>
        <trans-unit id="eba901a61186cfbbb3bf7ee2deff1c264b66c04d" translate="yes" xml:space="preserve">
          <source>MissingException</source>
          <target state="translated">MissingException</target>
        </trans-unit>
        <trans-unit id="0eb7563cf925b3171d8413443294517880e52bf4" translate="yes" xml:space="preserve">
          <source>Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.</source>
          <target state="translated">부호있는 정수, 부호없는 정수 및 부동 소수점 사이의 혼합 유형 비교는 까다로울 수 있습니다. Julia가 올바르게 수행 할 수 있도록 상당한주의를 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="d2447ff507fee803f855bee558dbfc6d355b84f8" translate="yes" xml:space="preserve">
          <source>Mmap.Anonymous</source>
          <target state="translated">Mmap.Anonymous</target>
        </trans-unit>
        <trans-unit id="640194f4398e106565f53f62e3b4b08e399b4acd" translate="yes" xml:space="preserve">
          <source>Mmap.mmap()</source>
          <target state="translated">Mmap.mmap()</target>
        </trans-unit>
        <trans-unit id="9de550013f14e18d13217b11b5824a98b7e97a03" translate="yes" xml:space="preserve">
          <source>Mmap.sync!()</source>
          <target state="translated">Mmap.sync!()</target>
        </trans-unit>
        <trans-unit id="9d079c814c5c6e9525538ebe30bfd478a09629f6" translate="yes" xml:space="preserve">
          <source>Mobile Phone</source>
          <target state="translated">휴대 전화</target>
        </trans-unit>
        <trans-unit id="a64a4a32c023fbcae9315c83d229c56e147f1205" translate="yes" xml:space="preserve">
          <source>Mobile Phone Off</source>
          <target state="translated">휴대 전화 끄기</target>
        </trans-unit>
        <trans-unit id="53d833926ab4deb21fef2ca63517a86d8d13288f" translate="yes" xml:space="preserve">
          <source>Mobile Phone With Rightwards Arrow At Left</source>
          <target state="translated">왼쪽에 오른쪽 화살표가있는 휴대폰</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="f3798f81c7b6fecad2cbfec741314f8a66c0eca3" translate="yes" xml:space="preserve">
          <source>Models</source>
          <target state="translated">Models</target>
        </trans-unit>
        <trans-unit id="378c6a346dad4490cef343a9bacc66eea52f2d4f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Apostrophe</source>
          <target state="translated">수정 자 문자 아포스트로피</target>
        </trans-unit>
        <trans-unit id="2f3a9bf639cb1a05417daaf9f821e730d1f2702f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital A</source>
          <target state="translated">수정 자 문자 대문자 A</target>
        </trans-unit>
        <trans-unit id="f175b2d4ea0317119c9624b31973682c7c727deb" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital B</source>
          <target state="translated">수정 자 문자 대문자 B</target>
        </trans-unit>
        <trans-unit id="54dd7f09fef3cabc35ab4a6d249ebc1a38792897" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital D</source>
          <target state="translated">수정 자 문자 대문자 D</target>
        </trans-unit>
        <trans-unit id="2f393f158eede615c8f37ab6d03675f9222c0871" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital E</source>
          <target state="translated">수정 자 문자 대문자 E</target>
        </trans-unit>
        <trans-unit id="63eb7bc8a5531edaeecb5a5fcbca568ca4e4a2c7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital G</source>
          <target state="translated">수정 자 문자 대문자 G</target>
        </trans-unit>
        <trans-unit id="6d7c9981939a9073e10475c6d0b8f61192d6c799" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital H</source>
          <target state="translated">수정 자 문자 대문자 H</target>
        </trans-unit>
        <trans-unit id="4413731a9bd52ab5447235f32b2b0de333c8ef4c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital I</source>
          <target state="translated">수정 자 문자 대문자 I</target>
        </trans-unit>
        <trans-unit id="6c4ba7affffc374ec628373cf18e2899f5a87362" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital J</source>
          <target state="translated">수정 자 문자 대문자 J</target>
        </trans-unit>
        <trans-unit id="bd16cf51093e88927626338771cd09c92fdc329a" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital K</source>
          <target state="translated">수정 자 문자 대문자 K</target>
        </trans-unit>
        <trans-unit id="8f79c14762e8c7851d80fadde368877df85d6b23" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital L</source>
          <target state="translated">수정 자 문자 대문자 L</target>
        </trans-unit>
        <trans-unit id="016c375485a48852c92c9754957d713deeefdf8d" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital M</source>
          <target state="translated">수정 자 문자 대문자 M</target>
        </trans-unit>
        <trans-unit id="10b6de66c6f3547ae2b2d7b053ff032b096b93de" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital N</source>
          <target state="translated">수정 자 문자 대문자 N</target>
        </trans-unit>
        <trans-unit id="19807e73c0ff4a0127747353ad7be9d70d95a697" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital O</source>
          <target state="translated">수정 자 문자 대문자 O</target>
        </trans-unit>
        <trans-unit id="3a9fa96695c83b6b5b6c060ec7b05141390f4803" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital P</source>
          <target state="translated">수정 자 문자 대문자 P</target>
        </trans-unit>
        <trans-unit id="4378d0c864dc7449a10443763855ea4a59baa102" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital R</source>
          <target state="translated">수정 자 문자 대문자 R</target>
        </trans-unit>
        <trans-unit id="a14533e9d3db66725bdefb9187de7134df849aa8" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital T</source>
          <target state="translated">수정 자 문자 대문자 T</target>
        </trans-unit>
        <trans-unit id="35ea6bcbac7185ab278072e6b19b25634e428e15" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital U</source>
          <target state="translated">수정 자 문자 대문자 U</target>
        </trans-unit>
        <trans-unit id="67aa6839a8f6f282dad5b4931bd1883b098fbdcf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital V</source>
          <target state="translated">수정 자 문자 대문자 V</target>
        </trans-unit>
        <trans-unit id="4ecfbd95ed7aef4b0c5960f7276af7528f3e1013" translate="yes" xml:space="preserve">
          <source>Modifier Letter Capital W</source>
          <target state="translated">수정 자 문자 대문자 W</target>
        </trans-unit>
        <trans-unit id="b949c25ddb1024b6b34775063c8ed4ff05dc6741" translate="yes" xml:space="preserve">
          <source>Modifier Letter Centred Left Half Ring / Modifier Letter Centered Left Half Ring</source>
          <target state="translated">수정 자 문자 중심의 왼쪽 반 반지 / 수정 자 문자 중심의 왼쪽 반 반지</target>
        </trans-unit>
        <trans-unit id="291ae0195a86f866993f9ce88979909a79117fd7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Centred Right Half Ring / Modifier Letter Centered Right Half Ring</source>
          <target state="translated">수정 자 문자 중심 오른쪽 반지 / 수정 자 문자 중심 오른쪽 반지</target>
        </trans-unit>
        <trans-unit id="76e59ea12945ed8b3bae8d350d3c977ff6c9c661" translate="yes" xml:space="preserve">
          <source>Modifier Letter Down Tack</source>
          <target state="translated">수정 자 편지 다운 압정</target>
        </trans-unit>
        <trans-unit id="34a5b4d80c8920b6836b60ae0b5dafe0f60ff41e" translate="yes" xml:space="preserve">
          <source>Modifier Letter Half Triangular Colon</source>
          <target state="translated">수정 자 문자 반 삼각 콜론</target>
        </trans-unit>
        <trans-unit id="6fce62d6e4239964c4599dd5d2dced43471e2efa" translate="yes" xml:space="preserve">
          <source>Modifier Letter Low Vertical Line</source>
          <target state="translated">수정 자 문자 낮은 세로줄</target>
        </trans-unit>
        <trans-unit id="b004982c20df1b8fbc334c55f8f0b60cd06099cf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small A</source>
          <target state="translated">수정 자 문자 작은 A</target>
        </trans-unit>
        <trans-unit id="deb88425b7f46b631fd02a62bce97481cd4f4f0f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Alpha</source>
          <target state="translated">수정 자 문자 작은 알파</target>
        </trans-unit>
        <trans-unit id="d2330a25644460fc348b0869a4f3ad148752432b" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small B</source>
          <target state="translated">수정 자 문자 작은 B</target>
        </trans-unit>
        <trans-unit id="8722138c1c68f848bb508699377ff45207b606f9" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Beta</source>
          <target state="translated">수정 자 문자 작은 베타</target>
        </trans-unit>
        <trans-unit id="e11743c39b0189ca08862d802023884f6ff509de" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small C</source>
          <target state="translated">수정 자 문자 작은 C</target>
        </trans-unit>
        <trans-unit id="ac514cd599f9a3a6730adac579cb5403479d24e7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Chi</source>
          <target state="translated">수정 자 문자 작은 치</target>
        </trans-unit>
        <trans-unit id="25b12af6e54cc3a3e907f64218555b40070c42c1" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small D</source>
          <target state="translated">수정 자 문자 작은 D</target>
        </trans-unit>
        <trans-unit id="646926770eecb21814bebc00456d822dd902b2aa" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Delta</source>
          <target state="translated">수정 자 문자 작은 델타</target>
        </trans-unit>
        <trans-unit id="b4ba7d679d1ff0f323efb3db18337cffb058215e" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small E</source>
          <target state="translated">수정 자 문자 작은 E</target>
        </trans-unit>
        <trans-unit id="23d05b8e8e47a8cc1fe82c0c873feb6eb937c1a0" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small F</source>
          <target state="translated">수정 자 문자 작은 F</target>
        </trans-unit>
        <trans-unit id="e8a3e647a87341c929cd000bd0eedbc0b417f747" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small G</source>
          <target state="translated">수정 자 문자 작은 G</target>
        </trans-unit>
        <trans-unit id="3685b9034b19a696b05b0209aff45ac1353acabb" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Greek Gamma</source>
          <target state="translated">수정 자 문자 작은 그리스 감마</target>
        </trans-unit>
        <trans-unit id="29c1c2e647f0e8f126ec82339b9456bd1ebf7261" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Greek Phi</source>
          <target state="translated">수정 자 문자 작은 그리스어 피</target>
        </trans-unit>
        <trans-unit id="d9c30e3a448db04ac018a8bd5442daf3475c7ba8" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small H</source>
          <target state="translated">수정 자 문자 작은 H</target>
        </trans-unit>
        <trans-unit id="6e57ce9744f101dbce99ecdf29c1d13b26269999" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Iota</source>
          <target state="translated">수정 자 문자 작은 Iota</target>
        </trans-unit>
        <trans-unit id="9baf4c56dd431ef3ad26edec02f15427fb4f8e94" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small J</source>
          <target state="translated">수정 자 문자 작은 J</target>
        </trans-unit>
        <trans-unit id="fcbede69a2944bdb4d911b826974c6a32312043f" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small K</source>
          <target state="translated">수정 자 문자 작은 K</target>
        </trans-unit>
        <trans-unit id="5d854f258e61e6965bf6816999063efd5ac79b59" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small L</source>
          <target state="translated">수정 자 문자 작은 L</target>
        </trans-unit>
        <trans-unit id="cb37d7c92d1fb26c6ec47e0939092255ffd1ff93" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small M</source>
          <target state="translated">수정 자 문자 작은 M</target>
        </trans-unit>
        <trans-unit id="4940f12ed72f76097abffee48c6caf8597c15238" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small O</source>
          <target state="translated">수정 자 문자 작은 O</target>
        </trans-unit>
        <trans-unit id="044a808dd64acb0276529fec8c8eed4151b9e1b3" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Open E</source>
          <target state="translated">수정 자 레터 스몰 오픈 E</target>
        </trans-unit>
        <trans-unit id="c5e8864168c9f7bcc5eaee6e04534f6b0ec03fe6" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small P</source>
          <target state="translated">수정 자 문자 작은 P</target>
        </trans-unit>
        <trans-unit id="5f86982de25f53705d5112c5e339fc1c06461494" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Phi</source>
          <target state="translated">수정 자 문자 작은 피</target>
        </trans-unit>
        <trans-unit id="31b385de66745576cfea4c510f4a9264de0c110c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small R</source>
          <target state="translated">수정 자 문자 작은 R</target>
        </trans-unit>
        <trans-unit id="63d45af948e161b5baf4097ac61d4ca9bde5eaf9" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small S</source>
          <target state="translated">수정 자 문자 S</target>
        </trans-unit>
        <trans-unit id="a00cedabf28dd494f16962a61b3b84c2db750c59" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small T</source>
          <target state="translated">수정 자 문자 작은 T</target>
        </trans-unit>
        <trans-unit id="934e5e0569eba2ae29b6fd7b7f3048216d6ab5b1" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Theta</source>
          <target state="translated">수정 자 문자 작은 세타</target>
        </trans-unit>
        <trans-unit id="2be80d92c9166f9508dafa1c3c4a04d968778caf" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small U</source>
          <target state="translated">수정 자 문자 작은 U</target>
        </trans-unit>
        <trans-unit id="70d29e93c6cc783288013cdd5e61222df9f49c57" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small V</source>
          <target state="translated">수정 자 문자 작은 V</target>
        </trans-unit>
        <trans-unit id="ae6c33276e50f036dcb88fa62fc9ac217fb18388" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small W</source>
          <target state="translated">수정 자 문자 작은 W</target>
        </trans-unit>
        <trans-unit id="30a372f7b079c66d667c70ed8f79a8629876ff27" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small X</source>
          <target state="translated">수정 자 문자 작은 X</target>
        </trans-unit>
        <trans-unit id="a69f6736779681fb0ed1056f1cad5cf275dd9d94" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Y</source>
          <target state="translated">수정 자 문자 작은 Y</target>
        </trans-unit>
        <trans-unit id="0b5f570214eea93dfb2923426c61433c7d0985f7" translate="yes" xml:space="preserve">
          <source>Modifier Letter Small Z</source>
          <target state="translated">수정 자 문자 작은 Z</target>
        </trans-unit>
        <trans-unit id="0a1e94c23d8acf4f254ffb7effdc13dfa9335d0c" translate="yes" xml:space="preserve">
          <source>Modifier Letter Triangular Colon</source>
          <target state="translated">수정 자 문자 삼각 콜론</target>
        </trans-unit>
        <trans-unit id="fb2ae7750f3b68bfed15753e6ba40b4fd1614bc0" translate="yes" xml:space="preserve">
          <source>Modifier Letter Up Tack</source>
          <target state="translated">수정 자 편지 업 압정</target>
        </trans-unit>
        <trans-unit id="08c923edc7b9df3dd77fec300568421baabc1855" translate="yes" xml:space="preserve">
          <source>Modifier Letter Vertical Line</source>
          <target state="translated">수정 자 문자 세로줄</target>
        </trans-unit>
        <trans-unit id="b340178957b37d595f2386a2a7c9f3c1ea3e040d" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dict&lt;/code&gt; by transforming each value from &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;f(val)&lt;/code&gt;. Note that the type of &lt;code&gt;dict&lt;/code&gt; cannot be changed: if &lt;code&gt;f(val)&lt;/code&gt; is not an instance of the key type of &lt;code&gt;dict&lt;/code&gt; then it will be converted to the key type if possible and otherwise raise an error.</source>
          <target state="translated">각 값을 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;f(val)&lt;/code&gt; 로 변환하여 &lt;code&gt;dict&lt;/code&gt; 를 수정 합니다. &lt;code&gt;dict&lt;/code&gt; 의 유형은 변경할 수 없습니다. &lt;code&gt;f(val)&lt;/code&gt; 이 &lt;code&gt;dict&lt;/code&gt; 의 키 유형의 인스턴스가 아닌 경우 가능한 경우 키 유형으로 변환되고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="860fca59a229c6f65f6ba3d80bfe791d74f369e2" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dict&lt;/code&gt; by transforming each value from &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;f(val)&lt;/code&gt;. Note that the type of &lt;code&gt;dict&lt;/code&gt; cannot be changed: if &lt;code&gt;f(val)&lt;/code&gt; is not an instance of the value type of &lt;code&gt;dict&lt;/code&gt; then it will be converted to the value type if possible and otherwise raise an error.</source>
          <target state="translated">각 값을 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;f(val)&lt;/code&gt; 로 변환하여 &lt;code&gt;dict&lt;/code&gt; 를 수정 합니다. &lt;code&gt;dict&lt;/code&gt; 의 유형은 변경할 수 없습니다. &lt;code&gt;f(val)&lt;/code&gt; 이 &lt;code&gt;dict&lt;/code&gt; 의 값 유형의 인스턴스가 아니면 가능하면 값 유형으로 변환되고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7c1db2af6a8e5de02c80ce0e770061ab316f1ee9" translate="yes" xml:space="preserve">
          <source>Modifies &lt;code&gt;dl&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, and &lt;code&gt;du&lt;/code&gt; in-place and returns them and the second superdiagonal &lt;code&gt;du2&lt;/code&gt; and the pivoting vector &lt;code&gt;ipiv&lt;/code&gt;.</source>
          <target state="translated">수정은 &lt;code&gt;dl&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; 한 &lt;code&gt;du&lt;/code&gt; 의 위치에서 반환들을 상기 제 superdiagonal &lt;code&gt;du2&lt;/code&gt; 및 피봇 벡터 &lt;code&gt;ipiv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572d43cf06548da1345ec6a3306e5d70ce13a433" translate="yes" xml:space="preserve">
          <source>Modifying OpenBLAS settings or compiling Julia with a different BLAS library, eg &lt;a href=&quot;https://software.intel.com/en-us/mkl&quot;&gt;Intel MKL&lt;/a&gt;, may provide performance improvements. You can use &lt;a href=&quot;https://github.com/JuliaComputing/MKL.jl&quot;&gt;MKL.jl&lt;/a&gt;, a package that makes Julia's linear algebra use Intel MKL BLAS and LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually. Note that Intel MKL cannot be bundled with Julia, as it is not open source.</source>
          <target state="translated">OpenBLAS 설정을 수정하거나 &lt;a href=&quot;https://software.intel.com/en-us/mkl&quot;&gt;Intel MKL&lt;/a&gt; 과 같은 다른 BLAS 라이브러리로 Julia를 컴파일하면 성능이 향상 될 수 있습니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;https://github.com/JuliaComputing/MKL.jl&quot;&gt;MKL.jl&lt;/a&gt; , 줄리아의 선형 대수학 사용 인텔 MKL BLAS 대신 OpenBLAS의 LAPACK을 만드는 패키지를, 또는 수동으로 설정하는 방법에 대한 제안에 대한 토론 포럼을 검색 할 수 있습니다. Intel MKL은 오픈 소스가 아니기 때문에 Julia와 번들로 제공 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2d8cef0c43f0dd2eaf87acf03dd76365ee4a701" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Distributed&lt;/code&gt; must be explicitly loaded on the master process before invoking &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;. It is automatically made available on the worker processes.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 마스터 프로세스에 모듈 &lt;code&gt;Distributed&lt;/code&gt; 모듈을 명시 적으로로드해야합니다 . 작업자 프로세스에서 자동으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0d4c77db7f69422d17f4d02a74c2e9ca631637" translate="yes" xml:space="preserve">
          <source>Module containing the broadcasting implementation.</source>
          <target state="translated">방송 구현을 포함하는 모듈.</target>
        </trans-unit>
        <trans-unit id="ac1e48420a4797de0ece18f47167f8bea686ef26" translate="yes" xml:space="preserve">
          <source>Module initialization and precompilation</source>
          <target state="translated">모듈 초기화 및 사전 컴파일</target>
        </trans-unit>
        <trans-unit id="ec692ee34bf5f1de5b608ef24c4276cc3d0944e7" translate="yes" xml:space="preserve">
          <source>Module with garbage collection utilities.</source>
          <target state="translated">가비지 수집 유틸리티가있는 모듈.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="c708ba26889d0fdbad848a6a34a8587e74cf3305" translate="yes" xml:space="preserve">
          <source>Modules (namespaces) can be hierarchical. &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; have a dual role: they load the code and make it available in the namespace. &lt;code&gt;import&lt;/code&gt; for only the module name is possible (roughly equivalent to &lt;code&gt;ASDF:LOAD-OP&lt;/code&gt;). Slot names don't need to be exported separately. Global variables can't be assigned to from outside the module (except with &lt;code&gt;eval(mod, :(var = val))&lt;/code&gt; as an escape hatch).</source>
          <target state="translated">모듈 (네임 스페이스)은 계층적일 수 있습니다. &lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; 에는 두 가지 역할이 있습니다. 코드를로드하고 네임 스페이스에서 사용할 수 있도록합니다. 모듈 이름에 대해서만 &lt;code&gt;import&lt;/code&gt; 가 가능합니다 ( &lt;code&gt;ASDF:LOAD-OP&lt;/code&gt; 와 거의 동일 함 ). 슬롯 이름은 별도로 내보낼 필요가 없습니다. 전역 변수는 모듈 외부에서 할당 할 수 없습니다 ( &lt;code&gt;eval(mod, :(var = val))&lt;/code&gt; 을 이스케이프 해치로 사용하는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="7f82982b865c3a95659f59755e8fee500abc86f4" translate="yes" xml:space="preserve">
          <source>Modules and files</source>
          <target state="translated">모듈과 파일</target>
        </trans-unit>
        <trans-unit id="8510a1d0d38afc78884abe8c896ed3ff2af14d40" translate="yes" xml:space="preserve">
          <source>Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside &lt;code&gt;module Name ... end&lt;/code&gt;. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code is used together with somebody else's. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting).</source>
          <target state="translated">Julia의 모듈은 별도의 가변 작업 공간입니다. 즉, 새로운 전역 범위를 도입합니다. 그것들은 &lt;code&gt;module Name ... end&lt;/code&gt; 내부에서 구문 적으로 구분 됩니다. 모듈을 사용하면 코드를 다른 사람과 함께 사용할 때 이름 충돌에 대한 걱정없이 최상위 수준 정의 (일명 글로벌 변수)를 만들 수 있습니다. 모듈 내에서 다른 모듈에서 어떤 이름을 볼 수 있는지 (가져 오기를 통해) 제어하고 공개 할 이름을 지정할 수 있습니다 (내보내기를 통해).</target>
        </trans-unit>
        <trans-unit id="91c78ad25e39e2af6d232135bc4257fd35ca7940" translate="yes" xml:space="preserve">
          <source>Modulo Two Sum</source>
          <target state="translated">모듈로 투섬</target>
        </trans-unit>
        <trans-unit id="c78082980964141d47941be353a64330f6b51990" translate="yes" xml:space="preserve">
          <source>Modulus after division by &lt;code&gt;2&amp;pi;&lt;/code&gt;, returning in the range $[0,2&amp;pi;)$.</source>
          <target state="translated">$ [0,2&amp;pi;) $ 범위에서 반환 되는 &lt;code&gt;2&amp;pi;&lt;/code&gt; 으로 나눈 모듈러스 .</target>
        </trans-unit>
        <trans-unit id="a351691306b2e5e66b41d3f5c7ffba6810525320" translate="yes" xml:space="preserve">
          <source>Modulus after flooring division, returning a value &lt;code&gt;r&lt;/code&gt; such that &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt; in the range $(0, y]$ for positive &lt;code&gt;y&lt;/code&gt; and in the range $[y,0)$ for negative &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">계수 값 반환 분할 바닥재 이후 &lt;code&gt;r&lt;/code&gt; 되도록 &lt;code&gt;mod(r, y) == mod(x, y)&lt;/code&gt; 범위 $ (0, y]는 $ 포지티브 속 &lt;code&gt;y&lt;/code&gt; 및 범위 $ [Y, 0) $ 대 음수 &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a8a13c5fc7802b76548bc6c9ce31726f4be07ed" translate="yes" xml:space="preserve">
          <source>Mon, Tue</source>
          <target state="translated">월, 화</target>
        </trans-unit>
        <trans-unit id="5ffae4168bc777c55ee4ffa00690c2cbb28b1c0b" translate="yes" xml:space="preserve">
          <source>Mon, Tues</source>
          <target state="translated">월, 화</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="3c1ff5c46aff9b279cd8a11d7962636c6c595bab" translate="yes" xml:space="preserve">
          <source>Money Bag</source>
          <target state="translated">돈 가방</target>
        </trans-unit>
        <trans-unit id="b6639cb4b312c7ff05ac7325f845c67f865def44" translate="yes" xml:space="preserve">
          <source>Money With Wings</source>
          <target state="translated">날개 달린 돈</target>
        </trans-unit>
        <trans-unit id="aeb0a4ab97f5db3410d52f9c451f8da976896310" translate="yes" xml:space="preserve">
          <source>Monitor a file descriptor &lt;code&gt;fd&lt;/code&gt; for changes in the read or write availability, and with a timeout given by &lt;code&gt;timeout_s&lt;/code&gt; seconds.</source>
          <target state="translated">읽기 또는 쓰기 가용성의 변경 사항과 &lt;code&gt;timeout_s&lt;/code&gt; 초에 의해 제공된 시간 종료에 대해 파일 디스크립터 &lt;code&gt;fd&lt;/code&gt; 를 모니터하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cd1562faa95bb9a9e863b102b09464e5cd6ea08" translate="yes" xml:space="preserve">
          <source>Monitor a file for changes by polling every &lt;code&gt;interval_s&lt;/code&gt; seconds until a change occurs or &lt;code&gt;timeout_s&lt;/code&gt; seconds have elapsed. The &lt;code&gt;interval_s&lt;/code&gt; should be a long period; the default is 5.007 seconds.</source>
          <target state="translated">변경이 발생하거나 &lt;code&gt;timeout_s&lt;/code&gt; 초가 경과 할 때까지 &lt;code&gt;interval_s&lt;/code&gt; 초 마다 폴링하여 변경 사항이 있는지 파일을 모니터하십시오 . &lt;code&gt;interval_s&lt;/code&gt; 는 오랜 기간이어야한다; 기본값은 5.007 초입니다.</target>
        </trans-unit>
        <trans-unit id="4bd0ec65b8f729d265faeba6fa933846d7c2d687" translate="yes" xml:space="preserve">
          <source>Monkey</source>
          <target state="translated">Monkey</target>
        </trans-unit>
        <trans-unit id="bb09be0ab256a995fb854ed1c681d6db409b5a63" translate="yes" xml:space="preserve">
          <source>Monkey Face</source>
          <target state="translated">원숭이 얼굴</target>
        </trans-unit>
        <trans-unit id="c8ee2da532776f830243f6b7e320f6344c60f050" translate="yes" xml:space="preserve">
          <source>Monorail</source>
          <target state="translated">Monorail</target>
        </trans-unit>
        <trans-unit id="68381046a452a28de3db3f76ce2d1e223be8c311" translate="yes" xml:space="preserve">
          <source>Month name shortened to 3-chars according to the &lt;code&gt;locale&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;locale&lt;/code&gt; 에 따라 3 자로 단축 된 월 이름</target>
        </trans-unit>
        <trans-unit id="d8bb646e34f3a1f66f555601f3aa3e959c4f36ae" translate="yes" xml:space="preserve">
          <source>Month of the year:</source>
          <target state="translated">올해의 달:</target>
        </trans-unit>
        <trans-unit id="39ffe0388e63ec156589f9f7dbfc37ce884b10df" translate="yes" xml:space="preserve">
          <source>Months of the Year:</source>
          <target state="translated">올해의 달:</target>
        </trans-unit>
        <trans-unit id="a997188c7b1041363b78bd9fdcb758e1ac901a64" translate="yes" xml:space="preserve">
          <source>Moon Viewing Ceremony</source>
          <target state="translated">달 관람 식</target>
        </trans-unit>
        <trans-unit id="5372b5bf846ad903de34d1fdbb6bac57298e63ef" translate="yes" xml:space="preserve">
          <source>More About Callbacks</source>
          <target state="translated">콜백에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="eb61252c650b20a424bb584244f7ba0af0a2bba7" translate="yes" xml:space="preserve">
          <source>More complicated index types may require more context about the dimension into which they index. To support those cases, &lt;code&gt;to_indices(A, I)&lt;/code&gt; calls &lt;code&gt;to_indices(A, axes(A), I)&lt;/code&gt;, which then recursively walks through both the given tuple of indices and the dimensional indices of &lt;code&gt;A&lt;/code&gt; in tandem. As such, not all index types are guaranteed to propagate to &lt;code&gt;Base.to_index&lt;/code&gt;.</source>
          <target state="translated">보다 복잡한 색인 유형은 색인을 생성하는 차원에 대한 컨텍스트가 더 필요할 수 있습니다. 이러한 경우를 지원하기 위해 &lt;code&gt;to_indices(A, I)&lt;/code&gt; 는 &lt;code&gt;to_indices(A, axes(A), I)&lt;/code&gt; 를 호출 한 다음 주어진 인덱스 튜플과 &lt;code&gt;A&lt;/code&gt; 의 차원 인덱스를 반복적으로 안내합니다 . 따라서 모든 인덱스 유형이 &lt;code&gt;Base.to_index&lt;/code&gt; 로 전파되는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a28b8a7a0afdfc3986f92c88b6d9bd8d72ae68b9" translate="yes" xml:space="preserve">
          <source>More dots: Fuse vectorized operations</source>
          <target state="translated">더 많은 점들 : 퓨즈 벡터화 된 연산</target>
        </trans-unit>
        <trans-unit id="e49535ab32dd41ac98143e87fe7bcbc8d58da1ac" translate="yes" xml:space="preserve">
          <source>More examples will be discussed later in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">더 많은 예제는 나중에 &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; 에서 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="9114e0a5d18633194f649ad46bb864a2d100cdcf" translate="yes" xml:space="preserve">
          <source>More examples will be discussed later in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">더 많은 예는 나중에 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; 에서 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="b5f6174dab9b174876b6d1506f1b621ea3baaea5" translate="yes" xml:space="preserve">
          <source>More fine-grained control over display of &lt;code&gt;Polar&lt;/code&gt; objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or for displaying the object as part of another object (e.g. in an array). Although by default the &lt;code&gt;show(io, z)&lt;/code&gt; function is called in both cases, you can define a &lt;em&gt;different&lt;/em&gt; multi-line format for displaying an object by overloading a three-argument form of &lt;code&gt;show&lt;/code&gt; that takes the &lt;code&gt;text/plain&lt;/code&gt; MIME type as its second argument (see &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O&quot;&gt;Multimedia I/O&lt;/a&gt;), for example:</source>
          <target state="translated">&lt;code&gt;Polar&lt;/code&gt; 개체의 표시를보다 세밀하게 제어 할 수 있습니다. 특히 때로는 REPL 및 기타 대화 형 환경에서 단일 개체를 표시하는 데 사용되는 장황한 여러 줄 인쇄 형식과 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 사용 되거나 다른 개체의 일부로 개체를 표시하는 데 사용되는보다 간결한 한 줄 형식을 모두 원합니다. 객체 (예 : 배열). 디폴트에 의해하지만 &lt;code&gt;show(io, z)&lt;/code&gt; 함수는 두 경우 모두라고, 당신은 정의 할 수 있습니다 &lt;em&gt;다른&lt;/em&gt; 의 3 인자 형태로 오버로드하여 개체를 표시하는 멀티 라인 형식을 &lt;code&gt;show&lt;/code&gt; 합니다 &lt;code&gt;text/plain&lt;/code&gt; 두 번째로 MIME 타입을 인수 ( &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O&quot;&gt;멀티미디어 I / O&lt;/a&gt; 참조 ), 예 :</target>
        </trans-unit>
        <trans-unit id="e2bb379bdba4c79a60942076ea4b662e49f8d9bb" translate="yes" xml:space="preserve">
          <source>More fine-grained control over display of &lt;code&gt;Polar&lt;/code&gt; objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or for displaying the object as part of another object (e.g. in an array). Although by default the &lt;code&gt;show(io, z)&lt;/code&gt; function is called in both cases, you can define a &lt;em&gt;different&lt;/em&gt; multi-line format for displaying an object by overloading a three-argument form of &lt;code&gt;show&lt;/code&gt; that takes the &lt;code&gt;text/plain&lt;/code&gt; MIME type as its second argument (see &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O-1&quot;&gt;Multimedia I/O&lt;/a&gt;), for example:</source>
          <target state="translated">&lt;code&gt;Polar&lt;/code&gt; 객체의 표시를보다 세밀하게 제어 할 수 있습니다. 특히, 때로는 REPL과 다른 대화식 환경에서 단일 객체를 표시하는 데 사용되는 자세한 멀티 라인 인쇄 형식과 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 또는 다른 객체의 일부로 객체를 표시하는 데 사용되는 더 작은 단일 라인 형식을 원합니다. 객체 (예 : 배열). 기본적으로 &lt;code&gt;show(io, z)&lt;/code&gt; 함수가 두 경우 모두 호출되지만 &lt;code&gt;text/plain&lt;/code&gt; MIME 유형을 두 번째로 사용 하는 3 개의 인수 형식의 &lt;code&gt;show&lt;/code&gt; 를 오버로드하여 객체를 표시하기 위해 &lt;em&gt;다른&lt;/em&gt; 여러 줄 형식을 정의 할 수 있습니다. 인수 ( 예 : &lt;a href=&quot;../../base/io-network/index#Multimedia-I/O-1&quot;&gt;멀티미디어 I / O&lt;/a&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="f807f392c5cb9f1e7fda57a006fbc06abbbb0bbb" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;f.(args...)&lt;/code&gt; is actually equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt;). For example, if you have &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt;, then &lt;code&gt;f.(pi,A)&lt;/code&gt; will return a new array consisting of &lt;code&gt;f(pi,a)&lt;/code&gt; for each &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; will return a new vector consisting of &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; for each index &lt;code&gt;i&lt;/code&gt; (throwing an exception if the vectors have different length).</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;f.(args...)&lt;/code&gt; 는 실제로 &lt;code&gt;broadcast(f, args...)&lt;/code&gt; 와 동일하며 , 이는 여러 배열 (다른 모양이라도) 또는 배열과 스칼라의 혼합 ( &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt; 참조)에서 작동 할 수 있습니다. ). 만약이 경우, 예를 들어, &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt; 다음 &lt;code&gt;f.(pi,A)&lt;/code&gt; 로 구성된 새로운 배열을 반환 &lt;code&gt;f(pi,a)&lt;/code&gt; 각각 에 및 &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; 는 각 인덱스 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; 로 구성된 새 벡터를 반환합니다 (벡터의 길이가 다른 경우 예외 발생). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f05c71e7a12085a3ebe14c1c0fed8c7488bc0dc" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;f.(args...)&lt;/code&gt; is actually equivalent to &lt;code&gt;broadcast(f, args...)&lt;/code&gt;, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt;). For example, if you have &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt;, then &lt;code&gt;f.(pi,A)&lt;/code&gt; will return a new array consisting of &lt;code&gt;f(pi,a)&lt;/code&gt; for each &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; will return a new vector consisting of &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; for each index &lt;code&gt;i&lt;/code&gt; (throwing an exception if the vectors have different length).</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;f.(args...)&lt;/code&gt; 는 실제로 &lt;code&gt;broadcast(f, args...)&lt;/code&gt; 와 동일하므로 여러 배열 (다른 모양 일지라도) 또는 배열과 스칼라를 혼합하여 사용할 수 있습니다 ( &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;브로드 캐스팅&lt;/a&gt; 참조) ). 만약이 경우, 예를 들어, &lt;code&gt;f(x,y) = 3x + 4y&lt;/code&gt; 다음 &lt;code&gt;f.(pi,A)&lt;/code&gt; 로 구성된 새로운 배열을 반환 &lt;code&gt;f(pi,a)&lt;/code&gt; 각각 에 및 &lt;code&gt;f.(vector1,vector2)&lt;/code&gt; 는 각 인덱스 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;f(vector1[i],vector2[i])&lt;/code&gt; 로 구성된 새 벡터를 반환합니다 (벡터의 길이가 다른 경우 예외 발생). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cce6b41d29dd04e55028067c508756d479b0a9aa" translate="yes" xml:space="preserve">
          <source>More generally, concatenation can be accomplished through the &lt;a href=&quot;../../base/arrays/index#Base.cat&quot;&gt;&lt;code&gt;cat&lt;/code&gt;&lt;/a&gt; function. These syntaxes are shorthands for function calls that themselves are convenience functions:</source>
          <target state="translated">보다 일반적으로 연결은 &lt;a href=&quot;../../base/arrays/index#Base.cat&quot;&gt; &lt;code&gt;cat&lt;/code&gt; &lt;/a&gt; 함수를 통해 수행 할 수 있습니다 . 이러한 구문은 그 자체가 편의 함수 인 함수 호출의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="c6b913d4fac598019e1594bf477f6f76ced64763" translate="yes" xml:space="preserve">
          <source>More generally, you can use &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; to read from or write to an external command.</source>
          <target state="translated">보다 일반적으로 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 을 사용 하여 외부 명령을 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16723d86f5a47f0ba34b59efade3de3bb73c4619" translate="yes" xml:space="preserve">
          <source>More on Channels</source>
          <target state="translated">채널에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="fbed1d73be3b8c50f079db28b743039aeaaaf4c8" translate="yes" xml:space="preserve">
          <source>More precisely, the set of all finite-length strings &lt;em&gt;S&lt;/em&gt; together with the string concatenation operator &lt;code&gt;*&lt;/code&gt; forms a &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_monoid&quot;&gt;free monoid&lt;/a&gt; (&lt;em&gt;S&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt;). The identity element of this set is the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;. Whenever a free monoid is not commutative, the operation is typically represented as &lt;code&gt;\cdot&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or a similar symbol, rather than &lt;code&gt;+&lt;/code&gt;, which as stated usually implies commutativity.</source>
          <target state="translated">보다 정확하게는, 모든 유한 길이 스트링 ( &lt;em&gt;S)&lt;/em&gt; 과 스트링 연결 연산자 &lt;code&gt;*&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Free_monoid&quot;&gt;자유 모노 이드&lt;/a&gt; ( &lt;em&gt;S&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; )를 형성한다. 이 세트의 identity 요소는 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다. 자유 monoid가 정류 적이 지 않을 때마다 연산은 일반적으로 &lt;code&gt;+&lt;/code&gt; 가 아닌 &lt;code&gt;\cdot&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 이와 유사한 기호로 표시되며, 일반적으로 언급 된 것처럼 정류를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e9cfd7dc4608b859ca3eb1fb55c826f67c16b0f8" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;a .^ b&lt;/code&gt; is parsed as the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;&quot;dot&quot; call&lt;/a&gt;&lt;code&gt;(^).(a,b)&lt;/code&gt;, which performs a &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;broadcast&lt;/a&gt; operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are &lt;em&gt;fusing&lt;/em&gt;. For example, if you compute &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (or equivalently &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt;, using the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) for an array &lt;code&gt;A&lt;/code&gt;, it performs a &lt;em&gt;single&lt;/em&gt; loop over &lt;code&gt;A&lt;/code&gt;, computing &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; for each element of &lt;code&gt;A&lt;/code&gt;. In particular, nested dot calls like &lt;code&gt;f.(g.(x))&lt;/code&gt; are fused, and &quot;adjacent&quot; binary operators like &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; are equivalent to nested dot calls &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt;.</source>
          <target state="translated">보다 구체적으로 &lt;code&gt;a .^ b&lt;/code&gt; 는 &lt;a href=&quot;../arrays/index#Broadcasting&quot;&gt;브로드 캐스트&lt;/a&gt; 작업 을 수행하는 &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;&quot;dot&quot;호출 &lt;/a&gt; &lt;code&gt;(^).(a,b)&lt;/code&gt; 로 구문 분석됩니다 . 배열과 스칼라, 동일한 크기의 배열 (요소 단위로 작업 수행)을 결합 할 수 있습니다. 및 다른 모양의 배열 (예 : 행렬을 생성하기 위해 행 벡터와 열 벡터 결합). 더욱이 모든 벡터화 된 &quot;점 호출&quot;과 마찬가지로 이러한 &quot;점 연산자&quot;는 &lt;em&gt;융합&lt;/em&gt; 됩니다. 예를 들어 배열 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (또는 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt; 와 동등하게 계산 ) 하면 &lt;em&gt;단일&lt;/em&gt; 루프를 수행합니다. &lt;code&gt;A&lt;/code&gt; 이상 , &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;A&lt;/code&gt; 의 각 요소에 대해 . 특히, &lt;code&gt;f.(g.(x))&lt;/code&gt; 와 같은 중첩 된 점 호출 은 융합되고 &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; 와 같은 &quot;인접한&quot;이항 연산자 는 중첩 된 점 호출 &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt; 과 동일합니다 . *). (3, (^). (x, 2))) .</target>
        </trans-unit>
        <trans-unit id="ad8280d892c33adf910a8bff64139b7ac3434c8e" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;a .^ b&lt;/code&gt; is parsed as the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;&quot;dot&quot; call&lt;/a&gt;&lt;code&gt;(^).(a,b)&lt;/code&gt;, which performs a &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt; operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized &quot;dot calls,&quot; these &quot;dot operators&quot; are &lt;em&gt;fusing&lt;/em&gt;. For example, if you compute &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (or equivalently &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt;, using the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) for an array &lt;code&gt;A&lt;/code&gt;, it performs a &lt;em&gt;single&lt;/em&gt; loop over &lt;code&gt;A&lt;/code&gt;, computing &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; for each element of &lt;code&gt;A&lt;/code&gt;. In particular, nested dot calls like &lt;code&gt;f.(g.(x))&lt;/code&gt; are fused, and &quot;adjacent&quot; binary operators like &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; are equivalent to nested dot calls &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt;.</source>
          <target state="translated">보다 구체적으로, &lt;code&gt;a .^ b&lt;/code&gt; 는 &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;&quot;dot&quot;호출 &lt;/a&gt; &lt;code&gt;(^).(a,b)&lt;/code&gt; 로 구문 분석되어 &lt;a href=&quot;../arrays/index#Broadcasting-1&quot;&gt;브로드 캐스트&lt;/a&gt; 작업 을 수행합니다 . 배열과 스칼라, 같은 크기의 배열 (작업을 요소 단위로 수행)을 결합 할 수 있습니다. 심지어 다른 모양의 배열 (예 : 행과 열 벡터를 결합하여 행렬 생성). 또한 모든 벡터화 된 &quot;도트 호출&quot;과 마찬가지로 이러한 &quot;도트 연산자&quot;는 서로 &lt;em&gt;융합되어&lt;/em&gt; 있습니다. 예를 들어 배열 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;2 .* A.^2 .+ sin.(A)&lt;/code&gt; (또는 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 &lt;code&gt;@. 2A^2 + sin(A)&lt;/code&gt; 와 동일 )를 계산하면 &lt;em&gt;단일&lt;/em&gt; 루프를 수행합니다. &lt;code&gt;A&lt;/code&gt; 이상 , &lt;code&gt;2a^2 + sin(a)&lt;/code&gt; &lt;em&gt;&lt;/em&gt;각 요소 . 특히 &lt;code&gt;f.(g.(x))&lt;/code&gt; 와 같은 중첩 된 점 호출 은 융합되어 있으며 &lt;code&gt;x .+ 3 .* x.^2&lt;/code&gt; 와 같은 &quot;인접한&quot;이진 연산자 는 중첩 된 점 호출 &lt;code&gt;(+).(x, (*).(3, (^).(x, 2)))&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23c6114d5cee868e3c446e0046f513b9baf30bbd" translate="yes" xml:space="preserve">
          <source>More task operations</source>
          <target state="translated">더 많은 작업 작업</target>
        </trans-unit>
        <trans-unit id="17af8621830fc8ff7e82aa48fbe7045fe41ab880" translate="yes" xml:space="preserve">
          <source>More usefully, it is possible to constrain varargs methods by a parameter. For example:</source>
          <target state="translated">보다 유용하게는 변수에 의해 varargs 메소드를 제한 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="779070101f9832b852f60dfb362c3b0c4dd35160" translate="yes" xml:space="preserve">
          <source>Moreover, &lt;em&gt;nested&lt;/em&gt;&lt;code&gt;f.(args...)&lt;/code&gt; calls are &lt;em&gt;fused&lt;/em&gt; into a single &lt;code&gt;broadcast&lt;/code&gt; loop. For example, &lt;code&gt;sin.(cos.(X))&lt;/code&gt; is equivalent to &lt;code&gt;broadcast(x -&amp;gt; sin(cos(x)), X)&lt;/code&gt;, similar to &lt;code&gt;[sin(cos(x)) for x in X]&lt;/code&gt;: there is only a single loop over &lt;code&gt;X&lt;/code&gt;, and a single array is allocated for the result. [In contrast, &lt;code&gt;sin(cos(X))&lt;/code&gt; in a typical &quot;vectorized&quot; language would first allocate one temporary array for &lt;code&gt;tmp=cos(X)&lt;/code&gt;, and then compute &lt;code&gt;sin(tmp)&lt;/code&gt; in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a &lt;em&gt;syntactic guarantee&lt;/em&gt; whenever nested &lt;code&gt;f.(args...)&lt;/code&gt; calls are encountered. Technically, the fusion stops as soon as a &quot;non-dot&quot; function call is encountered; for example, in &lt;code&gt;sin.(sort(cos.(X)))&lt;/code&gt; the &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;cos&lt;/code&gt; loops cannot be merged because of the intervening &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="translated">또한, &lt;em&gt;중첩 &lt;/em&gt; &lt;code&gt;f.(args...)&lt;/code&gt; 호출되어 &lt;em&gt;융합&lt;/em&gt; 단일로 &lt;code&gt;broadcast&lt;/code&gt; 루프. 예를 들어, &lt;code&gt;sin.(cos.(X))&lt;/code&gt; 는 &lt;code&gt;broadcast(x -&amp;gt; sin(cos(x)), X)&lt;/code&gt; 와 같 으며 &lt;code&gt;[sin(cos(x)) for x in X]&lt;/code&gt; 와 유사합니다 . &lt;code&gt;X&lt;/code&gt; 에 대한 단일 루프 및 단일 배열이 결과에 할당됩니다. 대조적으로, 전형적인 &quot;벡터화 된&quot;언어에서 &lt;code&gt;sin(cos(X))&lt;/code&gt; 는 먼저 &lt;code&gt;tmp=cos(X)&lt;/code&gt; 대해 하나의 임시 배열을 할당 한 다음 별도의 루프에서 &lt;code&gt;sin(tmp)&lt;/code&gt; 를 계산 하여 두 번째 배열을 할당합니다.] 이 루프 퓨전은 발생하거나 발생하지 않을 수있는 컴파일러 최적화가 아닙니다.&lt;em&gt;&lt;/em&gt;중첩 된 &lt;code&gt;f.(args...)&lt;/code&gt; 호출이 발생할 때마다 &lt;em&gt;구문 보장&lt;/em&gt; 기술적으로, &quot;도트가 아닌&quot;함수 호출이 발생하자마자 퓨전이 중지됩니다. 예를 들어,에 &lt;code&gt;sin.(sort(cos.(X)))&lt;/code&gt; &lt;code&gt;sin&lt;/code&gt; 와 &lt;code&gt;cos&lt;/code&gt; 루프 때문에 그 사이의 병합 할 수 없습니다 &lt;code&gt;sort&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="fd5329457d4ed40fab6163857a9591ce932a18cd" translate="yes" xml:space="preserve">
          <source>Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.</source>
          <target state="translated">또한 컴파일러가 정규식 객체가 모든 루프에서 일정하다고 판단 할 수없는 경우 특정 최적화가 불가능하여이 버전이 위의보다 편리한 리터럴 형식보다 여전히 덜 효율적입니다. 물론 리터럴이 아닌 형식이 더 편리한 상황이 여전히 있습니다. 변수를 정규식에 보간해야하는 경우에는보다 자세한 방법을 사용해야합니다. 정규식 패턴 자체가 동적이고 각 루프 반복마다 변경 될 수있는 경우, 각 정규식마다 새로운 정규식 객체를 구성해야합니다. 그러나 대부분의 사용 사례에서 정규식은 런타임 데이터를 기반으로 구성되지 않습니다. 이 대부분의 경우 컴파일 타임 값으로 정규 표현식을 작성하는 기능은 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="94796bcc387a6e8182d2873b6955e8376c00e9ec" translate="yes" xml:space="preserve">
          <source>Moreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product generation behavior is emulated:</source>
          <target state="translated">또한 여러 배열을 같은 단어로 보간하면 셸의 카티 전 곱 생성 동작이 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a35393ea29790838fd27f9dba6491b1e4a45bdca" translate="yes" xml:space="preserve">
          <source>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt;&lt;code&gt;f.(A)&lt;/code&gt;, e.g. &lt;code&gt;sin.(A)&lt;/code&gt; will compute the sine of each element of an array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">또한 이러한 함수 (Julia 함수와 마찬가지로)는 &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;점 구문 &lt;/a&gt; &lt;code&gt;f.(A)&lt;/code&gt; 를 사용하여 배열 및 기타 컬렉션에 &quot;벡터화 된&quot;방식으로 적용 할 수 있습니다 . 예를 들어 &lt;code&gt;sin.(A)&lt;/code&gt; 는 배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소에 대한 사인을 계산합니다 . .</target>
        </trans-unit>
        <trans-unit id="9e032b71807c69c0bc1be8067fda2123f4bb83a6" translate="yes" xml:space="preserve">
          <source>Moreover, these functions (like any Julia function) can be applied in &quot;vectorized&quot; fashion to arrays and other collections with the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt;&lt;code&gt;f.(A)&lt;/code&gt;, e.g. &lt;code&gt;sin.(A)&lt;/code&gt; will compute the sine of each element of an array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">또한, 이러한 함수들 (줄리아 함수처럼)은 &quot;벡터화 된&quot;방식으로 &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;도트 구문 &lt;/a&gt; &lt;code&gt;f.(A)&lt;/code&gt; 와 같은 배열과 다른 컬렉션에 적용될 수 있습니다 . 예를 들어 &lt;code&gt;sin.(A)&lt;/code&gt; 는 배열 &lt;code&gt;A&lt;/code&gt; 의 각 요소의 사인을 계산합니다 . .</target>
        </trans-unit>
        <trans-unit id="3695177f400d78b837a3ec533b6ee9eedcb9aba9" translate="yes" xml:space="preserve">
          <source>Moreover, you can also define &lt;code&gt;show&lt;/code&gt; methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia). For example, we can define formatted HTML display of &lt;code&gt;Polar&lt;/code&gt; objects, with superscripts and italics, via:</source>
          <target state="translated">또한 이를 지원하는 환경 (예 : IJulia)에서 객체를 더 풍부하게 표시 (HTML, 이미지 등) 할 수 있도록 다른 MIME 유형에 대해 &lt;code&gt;show&lt;/code&gt; 메소드를 정의 할 수도 있습니다 . 예를 들어 다음을 통해 위첨자와 이탤릭체로 &lt;code&gt;Polar&lt;/code&gt; 객체 의 형식화 된 HTML 표시를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cedbde91aadbe841dc76e371af3e62bec121526" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;Period&lt;/code&gt; values can also be rounded to a specified resolution:</source>
          <target state="translated">대부분의 &lt;code&gt;Period&lt;/code&gt; 값은 지정된 해상도로 반올림 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e19dc6bd3a4b02ba9e0283a25c37e3a958338a7" translate="yes" xml:space="preserve">
          <source>Most commonly you'll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code. Consider a file, &lt;code&gt;DummyModule.jl&lt;/code&gt;, containing the following code:</source>
          <target state="translated">가장 일반적으로 파일 또는 패키지에서 코드를로드 할 것이며로드 프로세스를 제어하는 ​​데 상당한 유연성이 있습니다. 다음 코드를 포함하는 &lt;code&gt;DummyModule.jl&lt;/code&gt; 파일을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="c650c7bdb609a6165acfd0169fae2081b78f3b86" translate="yes" xml:space="preserve">
          <source>Most functions related to random generation accept an optional &lt;code&gt;AbstractRNG&lt;/code&gt; object as first argument, which defaults to the global one if not provided. Moreover, some of them accept optionally dimension specifications &lt;code&gt;dims...&lt;/code&gt; (which can be given as a tuple) to generate arrays of random values.</source>
          <target state="translated">랜덤 생성과 관련된 대부분의 함수는 선택적인 &lt;code&gt;AbstractRNG&lt;/code&gt; 객체를 첫 번째 인수로 받아 들입니다. 또한, 그들 중 일부 는 임의의 값의 배열을 생성하기 위해 선택적으로 치수 사양 &lt;code&gt;dims...&lt;/code&gt; (튜플로 제공 가능)를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c1239d101be28fb7a51d055c4beba3cba9e6e698" translate="yes" xml:space="preserve">
          <source>Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it's fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the &lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot;&gt;cache&lt;/a&gt;. Consequently, a good multiprocessing environment should allow control over the &quot;ownership&quot; of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.</source>
          <target state="translated">대부분의 최신 컴퓨터에는 둘 이상의 CPU가 있으며 여러 컴퓨터를 클러스터에 결합 할 수 있습니다. 이러한 여러 CPU의 성능을 활용하면 많은 계산을보다 빠르게 완료 할 수 있습니다. 성능에 영향을 미치는 두 가지 주요 요소는 CPU 자체의 속도와 메모리 액세스 속도입니다. 클러스터에서 특정 CPU가 동일한 컴퓨터 (노드) 내의 RAM에 가장 빠르게 액세스 할 수 있다는 것은 명백합니다. 아마도 놀랍게도, 주 메모리 속도와 &lt;a href=&quot;https://www.akkadia.org/drepper/cpumemory.pdf&quot;&gt;캐시&lt;/a&gt; 속도의 차이로 인해 유사한 멀티 코어 랩톱에서 비슷한 문제가 발생 합니다.. 결과적으로, 좋은 멀티 프로세싱 환경은 특정 CPU에 의해 메모리 청크의 &quot;소유권&quot;을 제어 할 수 있어야합니다. Julia는 메시지 전달에 기반한 다중 처리 환경을 제공하여 프로그램이 개별 메모리 도메인의 여러 프로세스에서 한 번에 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb4a0eddebf9dead1a35f328ee8b33ef53f3e18" translate="yes" xml:space="preserve">
          <source>Most non-&lt;code&gt;AbstractString&lt;/code&gt; objects are converted to strings closely corresponding to how they are entered as literal expressions:</source>
          <target state="translated">대부분의 &lt;code&gt;AbstractString&lt;/code&gt; 객체는 리터럴 표현식으로 입력되는 방식에 밀접하게 대응되는 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="009849b63af7fd56e46b025e9e1988be97d008f3" translate="yes" xml:space="preserve">
          <source>Most of the fields in &lt;code&gt;WorkerConfig&lt;/code&gt; are used by the inbuilt managers. Custom cluster managers would typically specify only &lt;code&gt;io&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; / &lt;code&gt;port&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;WorkerConfig&lt;/code&gt; 의 대부분의 필드는 기본 제공 관리자가 사용합니다. 사용자 정의 클러스터 관리자는 일반적으로 &lt;code&gt;io&lt;/code&gt; 또는 &lt;code&gt;host&lt;/code&gt; / &lt;code&gt;port&lt;/code&gt; 만 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="fdbedbae85135376e0955ea53a24367ed77becc5" translate="yes" xml:space="preserve">
          <source>Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might encounter a situation where it needs to use two different packages that share the same name. While you might be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large, shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different packages in different components of an application.</source>
          <target state="translated">대부분의 경우 패키지는 단순히 이름에서 고유하게 식별 할 수 있습니다. 그러나 프로젝트에서 동일한 이름을 공유하는 두 개의 서로 다른 패키지를 사용해야하는 상황이 발생할 수 있습니다. 패키지 중 하나의 이름을 바꾸어이 문제를 해결할 수는 있지만, 큰 공유 코드 기반에서는 강제로 방해가 될 수 있습니다. 대신 Julia의 코드로드 메커니즘을 통해 동일한 패키지 이름이 응용 프로그램의 다른 구성 요소에있는 다른 패키지를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0a13ed301c1f3da1a566cff3cd69df8fc346456" translate="yes" xml:space="preserve">
          <source>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot;&gt;machine epsilon&lt;/a&gt;.</source>
          <target state="translated">대부분의 실수는 부동 소수점 숫자로 정확하게 표현 될 수 없으므로 많은 목적으로 두 개의 인접한 표현 가능한 부동 소수점 숫자 사이의 거리를 아는 것이 중요합니다.이 숫자는 종종 &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot;&gt;기계 epsilon이라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="451bfdf40e0411d54f7de109d79b121ca62be5c5" translate="yes" xml:space="preserve">
          <source>Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.</source>
          <target state="translated">대부분의 작업 전환은 I / O 요청과 같은 이벤트를 기다린 결과로 발생하며 Julia Base에 포함 된 스케줄러에 의해 수행됩니다. 스케줄러는 실행 가능한 작업 대기열을 유지 관리하고 메시지 도착과 같은 외부 이벤트를 기반으로 작업을 다시 시작하는 이벤트 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="979b60e882abda8a9c12cf29fe335277ebba6068" translate="yes" xml:space="preserve">
          <source>Mount Fuji</source>
          <target state="translated">후지산</target>
        </trans-unit>
        <trans-unit id="ea810cae67bdffd7ad390ce003d4876748a6fba6" translate="yes" xml:space="preserve">
          <source>Mountain Bicyclist</source>
          <target state="translated">산악 자전거</target>
        </trans-unit>
        <trans-unit id="0cf2a0344224497ad15378a05503ae78e04f4bf8" translate="yes" xml:space="preserve">
          <source>Mountain Cableway</source>
          <target state="translated">산 케이블카</target>
        </trans-unit>
        <trans-unit id="d84c680c2896ded96f7a10d71dad68ce2418ed82" translate="yes" xml:space="preserve">
          <source>Mountain Railway</source>
          <target state="translated">산악 철도</target>
        </trans-unit>
        <trans-unit id="573dd2c2ed953b97e3c31f3090925fe92109b779" translate="yes" xml:space="preserve">
          <source>Mouse</source>
          <target state="translated">Mouse</target>
        </trans-unit>
        <trans-unit id="5768b6f096a5a2264e0ec9dec9808a17ff5b43e8" translate="yes" xml:space="preserve">
          <source>Mouse Face</source>
          <target state="translated">마우스 얼굴</target>
        </trans-unit>
        <trans-unit id="8b89346ec19490ee79f4cd52a3a3717eb0a29f3b" translate="yes" xml:space="preserve">
          <source>Mouth</source>
          <target state="translated">Mouth</target>
        </trans-unit>
        <trans-unit id="30b1f202851b68387e0cf962baee4d8839bb1316" translate="yes" xml:space="preserve">
          <source>Move cursor according to the direction of the Arrow key, while activating the region (&quot;shift selection&quot;)</source>
          <target state="translated">영역을 활성화하는 동안 화살표 키의 방향에 따라 커서를 이동하십시오 ( &quot;shift selection&quot;)</target>
        </trans-unit>
        <trans-unit id="9fbb10cea5a283fe0ac0a7b27485eb8a05156e90" translate="yes" xml:space="preserve">
          <source>Move down one line (or change to the next history entry that matches the text before the cursor)</source>
          <target state="translated">한 줄 아래로 이동 (또는 커서 앞의 텍스트와 일치하는 다음 기록 항목으로 변경)</target>
        </trans-unit>
        <trans-unit id="d39ec10b803e2fe3f34325c3c3abd699531c775a" translate="yes" xml:space="preserve">
          <source>Move left one character</source>
          <target state="translated">한 문자 왼쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="0791a4c858c6d391e0ae088e06592877ac2b3393" translate="yes" xml:space="preserve">
          <source>Move left one word</source>
          <target state="translated">한 단어 왼쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="4897d4c5d557d2a36d7979e57b09fe3bcda6c0ef" translate="yes" xml:space="preserve">
          <source>Move right one character</source>
          <target state="translated">한 캐릭터 오른쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="46615955d39b79da629fb77760f9faf2397e33ae" translate="yes" xml:space="preserve">
          <source>Move right one word</source>
          <target state="translated">한 단어 오른쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="8c735f545a7e59af556c32f882f26a847507a45e" translate="yes" xml:space="preserve">
          <source>Move the file, link, or directory from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;. &lt;code&gt;force=true&lt;/code&gt; will first remove an existing &lt;code&gt;dst&lt;/code&gt;. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">파일, 링크 또는 디렉토리를 &lt;code&gt;src&lt;/code&gt; 에서 &lt;code&gt;dst&lt;/code&gt; 로 이동하십시오 . &lt;code&gt;force=true&lt;/code&gt; 는 먼저 기존 &lt;code&gt;dst&lt;/code&gt; 를 제거합니다 . &lt;code&gt;dst&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="6a9cb71d0e79bee3c1501add0807182e5ae66211" translate="yes" xml:space="preserve">
          <source>Move to beginning of line</source>
          <target state="translated">줄의 시작으로 이동</target>
        </trans-unit>
        <trans-unit id="9ac320ded099850be4cfbe5245eb54c34673ceac" translate="yes" xml:space="preserve">
          <source>Move to end of line</source>
          <target state="translated">줄의 끝으로 이동</target>
        </trans-unit>
        <trans-unit id="c1dd98d3dcbabaacbdfa5f6b95879b0b4a046a03" translate="yes" xml:space="preserve">
          <source>Move up one line (or change to the previous history entry that matches the text before the cursor)</source>
          <target state="translated">한 줄 위로 이동 (또는 커서 앞의 텍스트와 일치하는 이전 기록 항목으로 변경)</target>
        </trans-unit>
        <trans-unit id="76725352326853201f27fde4c6c1ce275b820153" translate="yes" xml:space="preserve">
          <source>Movie Camera</source>
          <target state="translated">영화 카메라</target>
        </trans-unit>
        <trans-unit id="a6ca43aa7d11d81bf2d46a043f16aaedd09ef0f6" translate="yes" xml:space="preserve">
          <source>Moyai</source>
          <target state="translated">Moyai</target>
        </trans-unit>
        <trans-unit id="2b88c19cc18879e009ec23091705fee60af05e90" translate="yes" xml:space="preserve">
          <source>Much Greater-Than / Much Greater Than</source>
          <target state="translated">훨씬 큼 /보다 큼</target>
        </trans-unit>
        <trans-unit id="d5a0fbbca8f5245c8133de8c73b23f300c244dc4" translate="yes" xml:space="preserve">
          <source>Much Greater-Than / Much Greater Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">롱 솔리스 티스 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="4f2c0deb0505dd20e806f5765890099e4b5a867f" translate="yes" xml:space="preserve">
          <source>Much Less-Than / Much Less Than</source>
          <target state="translated">훨씬 작음 / 훨씬 작음</target>
        </trans-unit>
        <trans-unit id="6be826cd51359393418fcb2adbb0047839a7b6e1" translate="yes" xml:space="preserve">
          <source>Much Less-Than / Much Less Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">훨씬 작음 / 훨씬 작음 + 긴 고형 오버레이 중첩 / 간격없는 긴 슬래시 ​​오버레이</target>
        </trans-unit>
        <trans-unit id="b47a2a6c416b663239d44555df35e9ac1ebf369f" translate="yes" xml:space="preserve">
          <source>Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared &lt;code&gt;Point{T}&lt;/code&gt; to be a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt; as follows:</source>
          <target state="translated">일반 오래된 추상 유형이 콘크리트 유형에 대한 유용한 유형의 계층 구조를 작성하는 데 도움이되는 것처럼, 파라 메트릭 추상 유형은 파라 메트릭 복합 유형과 동일한 목적으로 사용됩니다. 예를 들어 &lt;code&gt;Point{T}&lt;/code&gt; 를 다음과 같이 &lt;code&gt;Pointy{T}&lt;/code&gt; 의 하위 유형으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f35bd862c1f6f3023c5d86b53aa67708df9fe9c" translate="yes" xml:space="preserve">
          <source>Multi-Core or Distributed Processing</source>
          <target state="translated">멀티 코어 또는 분산 처리</target>
        </trans-unit>
        <trans-unit id="5d8f806bc2cb3dd821e467dcedf520889e897194" translate="yes" xml:space="preserve">
          <source>Multi-Threading</source>
          <target state="translated">Multi-Threading</target>
        </trans-unit>
        <trans-unit id="a1769e396774be66a81c06a4bc46092468f38e81" translate="yes" xml:space="preserve">
          <source>Multi-Threading (Experimental)</source>
          <target state="translated">멀티 스레딩 (실험)</target>
        </trans-unit>
        <trans-unit id="e1b066f6dcf0a56bf1362975edd9dba4ac4004b6" translate="yes" xml:space="preserve">
          <source>Multi-dimensional Arrays</source>
          <target state="translated">다차원 배열</target>
        </trans-unit>
        <trans-unit id="c2582f70ace65cdd3e0e5aa3007381331520ce71" translate="yes" xml:space="preserve">
          <source>Multi-processing and Distributed Computing</source>
          <target state="translated">다중 처리 및 분산 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="4df9252fd5d4911ee5eb1c96d25797e8cf043b28" translate="yes" xml:space="preserve">
          <source>Multi-threading</source>
          <target state="translated">Multi-threading</target>
        </trans-unit>
        <trans-unit id="304d54aad0987ef425371304d27e4ffefba7eba5" translate="yes" xml:space="preserve">
          <source>Multi-threading functionality builds on tasks by allowing them to run simultaneously on more than one thread or CPU core, sharing memory.</source>
          <target state="translated">멀티 스레딩 기능은 작업을 둘 이상의 스레드 또는 CPU 코어에서 동시에 실행하고 메모리를 공유함으로써 작업을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e421129a56610bee84054ce99746152a4e075eb0" translate="yes" xml:space="preserve">
          <source>MultiSelectMenu</source>
          <target state="translated">MultiSelectMenu</target>
        </trans-unit>
        <trans-unit id="a9d638ce5bf60587999d44aed72b74552ba37415" translate="yes" xml:space="preserve">
          <source>Multidimensional Arrays</source>
          <target state="translated">다차원 배열</target>
        </trans-unit>
        <trans-unit id="2688e5975cc55bfb07b0932fafd5c212fc5ace21" translate="yes" xml:space="preserve">
          <source>Multidimensional and nonscalar indexed assignment</source>
          <target state="translated">다차원 및 비스 칼라 인덱스 할당</target>
        </trans-unit>
        <trans-unit id="e734bd25327fbeb74d44958ad03c60a53b4c7ad6" translate="yes" xml:space="preserve">
          <source>Multidimensional and nonscalar indexing</source>
          <target state="translated">다차원 및 비스 칼라 인덱싱</target>
        </trans-unit>
        <trans-unit id="bcc8b546795a10466bd74bf69b081a62bbb6c4d8" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the &lt;code&gt;vec&lt;/code&gt; function or the syntax &lt;code&gt;[:]&lt;/code&gt; as shown below (notice that the array is ordered &lt;code&gt;[1 3 2 4]&lt;/code&gt;, not &lt;code&gt;[1 2 3 4]&lt;/code&gt;):</source>
          <target state="translated">Julia의 다차원 배열은 열 주요 순서로 저장됩니다. 즉, 어레이는 한 번에 한 열씩 쌓입니다. 아래에 표시된 것처럼 &lt;code&gt;vec&lt;/code&gt; 함수 또는 구문 &lt;code&gt;[:]&lt;/code&gt; 을 사용하여 확인할 수 있습니다 (배열은 &lt;code&gt;[1 2 3 4]&lt;/code&gt; 가 아니라 [1 &lt;code&gt;[1 3 2 4]&lt;/code&gt; 정렬 됨 ).</target>
        </trans-unit>
        <trans-unit id="8dc001479bc2220a1c498e4c1d38b3ef0687b311" translate="yes" xml:space="preserve">
          <source>Multimap</source>
          <target state="translated">Multimap</target>
        </trans-unit>
        <trans-unit id="12a550b8fa4d35649c20c485e20ba65c48140443" translate="yes" xml:space="preserve">
          <source>Multimedia I/O</source>
          <target state="translated">멀티미디어 I / O</target>
        </trans-unit>
        <trans-unit id="20daf23b87d49b545626edacfe0595bc78ffe6bb" translate="yes" xml:space="preserve">
          <source>Multimedia-capable display backends may be registered by subclassing a generic &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt; type and pushing them onto a stack of display backends via &lt;a href=&quot;#Base.Multimedia.pushdisplay&quot;&gt;&lt;code&gt;pushdisplay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">멀티미디어 가능 디스플레이 백엔드는 일반 &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; 유형 을 서브 클래 싱하고 &lt;a href=&quot;#Base.Multimedia.pushdisplay&quot;&gt; &lt;code&gt;pushdisplay&lt;/code&gt; &lt;/a&gt; 를 통해 디스플레이 백엔드 스택에 푸시하여 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f901aab2cf166bf580d3c3b10747eb77b4d28786" translate="yes" xml:space="preserve">
          <source>Multimedia.@MIME_str</source>
          <target state="translated">Multimedia.@MIME_str</target>
        </trans-unit>
        <trans-unit id="1fad381232cafa3a6519f49a82f0ad5d43ee03f8" translate="yes" xml:space="preserve">
          <source>Multimedia.AbstractDisplay</source>
          <target state="translated">Multimedia.AbstractDisplay</target>
        </trans-unit>
        <trans-unit id="3bf6b34f9dc6831162a9ed70613e7214b009773a" translate="yes" xml:space="preserve">
          <source>Multimedia.MIME</source>
          <target state="translated">Multimedia.MIME</target>
        </trans-unit>
        <trans-unit id="1a3b6cfeea4ec290d631b42e28b7fd3dd7997acf" translate="yes" xml:space="preserve">
          <source>Multimedia.TextDisplay</source>
          <target state="translated">Multimedia.TextDisplay</target>
        </trans-unit>
        <trans-unit id="7d8e050779516bbc10cc3b22a2ff20011e576c53" translate="yes" xml:space="preserve">
          <source>Multimedia.display()</source>
          <target state="translated">Multimedia.display()</target>
        </trans-unit>
        <trans-unit id="44362a84f2293978fd977ef2de61866c3a99b218" translate="yes" xml:space="preserve">
          <source>Multimedia.displayable()</source>
          <target state="translated">Multimedia.displayable()</target>
        </trans-unit>
        <trans-unit id="591d47ad80c3149fb86dc4d9393ecc120230caeb" translate="yes" xml:space="preserve">
          <source>Multimedia.istextmime()</source>
          <target state="translated">Multimedia.istextmime()</target>
        </trans-unit>
        <trans-unit id="d02a6dd8bd8f25cd25c6ab6ab392ec5dde9ef69a" translate="yes" xml:space="preserve">
          <source>Multimedia.popdisplay()</source>
          <target state="translated">Multimedia.popdisplay()</target>
        </trans-unit>
        <trans-unit id="6a6027621de0719ce755c723b278c3459d48b0d9" translate="yes" xml:space="preserve">
          <source>Multimedia.pushdisplay()</source>
          <target state="translated">Multimedia.pushdisplay()</target>
        </trans-unit>
        <trans-unit id="a173fa25b54e08e60b3fab0e43245db6b1bb5c4f" translate="yes" xml:space="preserve">
          <source>Multimedia.redisplay()</source>
          <target state="translated">Multimedia.redisplay()</target>
        </trans-unit>
        <trans-unit id="17f6e961e36391308b259ffe96e74cfb78a59cf9" translate="yes" xml:space="preserve">
          <source>Multimedia.showable()</source>
          <target state="translated">Multimedia.showable()</target>
        </trans-unit>
        <trans-unit id="8b65075f1dc2c06140e3f24524c3b8e27d9efca2" translate="yes" xml:space="preserve">
          <source>Multiple Musical Notes</source>
          <target state="translated">여러 음표</target>
        </trans-unit>
        <trans-unit id="1eae37825f972d7374db88d51813ed8e004ec47c" translate="yes" xml:space="preserve">
          <source>Multiple Objects</source>
          <target state="translated">여러 객체</target>
        </trans-unit>
        <trans-unit id="a025ceee7b8b1c711d382e33043a2b3de0e6408b" translate="yes" xml:space="preserve">
          <source>Multiple Return Values</source>
          <target state="translated">여러 반환 값</target>
        </trans-unit>
        <trans-unit id="8e15b8cb269e38ed2edf77db20f03d8707f3e964" translate="yes" xml:space="preserve">
          <source>Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.</source>
          <target state="translated">Julia는 유연한 파라 메트릭 유형 시스템과 함께 다중 디스패치를 ​​구현 세부 사항에서 분리 된 고급 알고리즘을 추상적으로 표현할 수 있지만, 런타임시 각 사례를 처리 할 수있는 효율적이고 전문화 된 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c25f913c3995067af10c2cde65a0d3a79da1b5af" translate="yes" xml:space="preserve">
          <source>Multiple function composition requires at least Julia 1.4.</source>
          <target state="translated">다중 기능 구성에는 최소한 Julia 1.4가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c7bab076d4c7874947ae3e9648b2fc792a2f1d6f" translate="yes" xml:space="preserve">
          <source>Multiple nested &lt;code&gt;for&lt;/code&gt; loops can be combined into a single outer loop, forming the cartesian product of its iterables:</source>
          <target state="translated">여러 개의 중첩 된 &lt;code&gt;for&lt;/code&gt; 루프를 단일 외부 루프로 결합하여 iterable의 직교 곱을 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="495dbcc88072f8c65c5a84ca68f0504e42ed0ed7" translate="yes" xml:space="preserve">
          <source>Multiple readers in different tasks can read data concurrently via &lt;code&gt;take!&lt;/code&gt; calls.</source>
          <target state="translated">다른 작업을 수행하는 여러 독자가 &lt;code&gt;take!&lt;/code&gt; 를 통해 동시에 데이터를 읽을 수 있습니다! 전화.</target>
        </trans-unit>
        <trans-unit id="1e71ad5291dbedb2322b217da37e04afff92dc9d" translate="yes" xml:space="preserve">
          <source>Multiple variables can be declared in a single &lt;code&gt;const&lt;/code&gt; statement:</source>
          <target state="translated">단일 &lt;code&gt;const&lt;/code&gt; 문 에서 여러 변수를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d73c9901bb6c946790a83a8a87b82ef0cec1f2c" translate="yes" xml:space="preserve">
          <source>Multiple variables can be declared within a single &lt;code&gt;const&lt;/code&gt;:</source>
          <target state="translated">단일 &lt;code&gt;const&lt;/code&gt; 내에서 여러 변수를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6191bf2ae4cde6b84e3731ebe3216e641b1f925" translate="yes" xml:space="preserve">
          <source>Multiple writers in different tasks can write to the same channel concurrently via &lt;code&gt;put!&lt;/code&gt; calls.</source>
          <target state="translated">다른 작업을 수행하는 여러 작성자가 &lt;code&gt;put!&lt;/code&gt; 통해 동일한 채널에 동시에 쓸 수 있습니다 ! 전화.</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="08798729863d0bb7b20e1d37c363bae614f6586a" translate="yes" xml:space="preserve">
          <source>Multiplication Sign</source>
          <target state="translated">곱셈 부호</target>
        </trans-unit>
        <trans-unit id="3c76df64c4a57883fa1d5a89f8c1a59b60fe613a" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Double Circle</source>
          <target state="translated">이중 원에 곱하기 기호</target>
        </trans-unit>
        <trans-unit id="0cb8782430ba3b81d227b0367b8483a3aec5c585" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Left Half Circle</source>
          <target state="translated">왼쪽 반원에 곱셈 부호</target>
        </trans-unit>
        <trans-unit id="45899b842b1e5f0e8bbcebf1613882194369635c" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Right Half Circle</source>
          <target state="translated">오른쪽 반원에 곱셈 부호</target>
        </trans-unit>
        <trans-unit id="a355acf983afd120ac915695e7bbc1cfdb422169" translate="yes" xml:space="preserve">
          <source>Multiplication Sign In Triangle</source>
          <target state="translated">곱하기 로그인 삼각형</target>
        </trans-unit>
        <trans-unit id="9d1dcaf767393e94d9fb3951d203efabe4bb0dae" translate="yes" xml:space="preserve">
          <source>Multiplication Sign With Dot Above</source>
          <target state="translated">위의 점이있는 곱셈 기호</target>
        </trans-unit>
        <trans-unit id="fbdc4c450ca5244758ddd4c66eba1288b620d400" translate="yes" xml:space="preserve">
          <source>Multiplication Sign With Underbar</source>
          <target state="translated">밑줄과 곱셈 기호</target>
        </trans-unit>
        <trans-unit id="3d3483bdb2415560ac9652dfcab542fdcef6d607" translate="yes" xml:space="preserve">
          <source>Multiplication operator. &lt;code&gt;x*y*z*...&lt;/code&gt; calls this function with all arguments, i.e. &lt;code&gt;*(x, y, z, ...)&lt;/code&gt;.</source>
          <target state="translated">곱셈 연산자. &lt;code&gt;x*y*z*...&lt;/code&gt; 는 모든 인수, 즉 &lt;code&gt;*(x, y, z, ...)&lt;/code&gt; 와 함께이 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="acd94b4a618f8f7ee2103c3ea81c4f51d1003fe1" translate="yes" xml:space="preserve">
          <source>Multiplication order</source>
          <target state="translated">곱셈 순서</target>
        </trans-unit>
        <trans-unit id="cbab753a795402e618da8df891a564ce24521592" translate="yes" xml:space="preserve">
          <source>Multiplication with respect to either full/square or non-full/square &lt;code&gt;Q&lt;/code&gt; is allowed, i.e. both &lt;code&gt;F.Q*F.R&lt;/code&gt; and &lt;code&gt;F.Q*A&lt;/code&gt; are supported. A &lt;code&gt;Q&lt;/code&gt; matrix can be converted into a regular matrix with &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/a&gt;. This operation returns the &quot;thin&quot; Q factor, i.e., if &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; with &lt;code&gt;m&amp;gt;=n&lt;/code&gt;, then &lt;code&gt;Matrix(F.Q)&lt;/code&gt; yields an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; matrix with orthonormal columns. To retrieve the &quot;full&quot; Q factor, an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;m&lt;/code&gt; orthogonal matrix, use &lt;code&gt;F.Q*Matrix(I,m,m)&lt;/code&gt;. If &lt;code&gt;m&amp;lt;=n&lt;/code&gt;, then &lt;code&gt;Matrix(F.Q)&lt;/code&gt; yields an &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;m&lt;/code&gt; orthogonal matrix.</source>
          <target state="translated">하나 스퀘어 / 전체 또는 비 전체 / 제곱에 대한 곱셈 &lt;code&gt;Q&lt;/code&gt; 는 즉 모두 허용됩니다 &lt;code&gt;F.Q*F.R&lt;/code&gt; 및 &lt;code&gt;F.Q*A&lt;/code&gt; 지원됩니다. &lt;code&gt;Q&lt;/code&gt; 의 매트릭스와 정규 행렬로 변환 할 수 &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;/a&gt; . 이 작업을하는 경우, 즉, &quot;얇은&quot;Q 인자를 반환 &lt;code&gt;A&lt;/code&gt; 가 이고 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;m&amp;gt;=n&lt;/code&gt; 다음 &lt;code&gt;Matrix(F.Q)&lt;/code&gt; 수득 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 개의 직교 열 행렬. &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;m&lt;/code&gt; 직교 행렬 인 &quot;전체&quot;Q 계수를 검색하려면 &lt;code&gt;F.Q*Matrix(I,m,m)&lt;/code&gt; . 만약 &lt;code&gt;m&amp;lt;=n&lt;/code&gt; 다음 &lt;code&gt;Matrix(F.Q)&lt;/code&gt; 은 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;m&lt;/code&gt; 직교 행렬을 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="3237fef2698864d2d4dff1442ef27b98ff896474" translate="yes" xml:space="preserve">
          <source>Multiplies the matrix &lt;code&gt;C&lt;/code&gt; by &lt;code&gt;Q&lt;/code&gt; from the transformation supplied by &lt;code&gt;tzrzf!&lt;/code&gt;. Depending on &lt;code&gt;side&lt;/code&gt; or &lt;code&gt;trans&lt;/code&gt; the multiplication can be left-sided (&lt;code&gt;side = L, Q*C&lt;/code&gt;) or right-sided (&lt;code&gt;side = R, C*Q&lt;/code&gt;) and &lt;code&gt;Q&lt;/code&gt; can be unmodified (&lt;code&gt;trans = N&lt;/code&gt;), transposed (&lt;code&gt;trans = T&lt;/code&gt;), or conjugate transposed (&lt;code&gt;trans = C&lt;/code&gt;). Returns matrix &lt;code&gt;C&lt;/code&gt; which is modified in-place with the result of the multiplication.</source>
          <target state="translated">&lt;code&gt;tzrzf!&lt;/code&gt; 제공 한 변환에서 행렬 &lt;code&gt;C&lt;/code&gt; 에 &lt;code&gt;Q&lt;/code&gt; 를 곱합니다 ! . 에 따라 &lt;code&gt;side&lt;/code&gt; 하거나 &lt;code&gt;trans&lt;/code&gt; 승산 될 수 왼쪽 단면 ( &lt;code&gt;side = L, Q*C&lt;/code&gt; ) 또는 (오른쪽 양면 &lt;code&gt;side = R, C*Q&lt;/code&gt; ) 및 &lt;code&gt;Q&lt;/code&gt; 는 비 변형 될 (수 &lt;code&gt;trans = N&lt;/code&gt; ), 전조 ( &lt;code&gt;trans = T&lt;/code&gt; ) 또는 켤레 전치 ( &lt;code&gt;trans = C&lt;/code&gt; ). 곱셈의 결과에 따라 수정 된 행렬 &lt;code&gt;C&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="51373d5164159f5426002b0598a3884a7c93923c" translate="yes" xml:space="preserve">
          <source>Multiply &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, giving the result as a larger type.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 곱하면 결과가 더 큰 유형으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8c2b66d02b47a40957a9bf040f2f9789a10c4a5f" translate="yes" xml:space="preserve">
          <source>Multiply elements of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 싱글 톤 차원 에 &lt;code&gt;A&lt;/code&gt; 의 요소를 곱하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fb50f95d1ea0332243fc7cfb57f8206ade911927" translate="yes" xml:space="preserve">
          <source>Multiply elements of an array over the given dimensions.</source>
          <target state="translated">주어진 차원에 배열의 요소를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="e702a06c59098f213dc183738514d30defe88d1d" translate="yes" xml:space="preserve">
          <source>Multiset Multiplication</source>
          <target state="translated">다중 집합 곱셈</target>
        </trans-unit>
        <trans-unit id="46e9543c61867442bcf25b304349df9f5d65ca32" translate="yes" xml:space="preserve">
          <source>Multiset Union</source>
          <target state="translated">다중 집합 연합</target>
        </trans-unit>
        <trans-unit id="c2840c311dfdf5b2dd783cb8f018f5c5edd5488d" translate="yes" xml:space="preserve">
          <source>Multithreading support.</source>
          <target state="translated">멀티 스레딩 지원.</target>
        </trans-unit>
        <trans-unit id="0159a2df7e34a6cc82e0f98d19901fe45423221a" translate="yes" xml:space="preserve">
          <source>Multivariate apply in R, e.g. &lt;code&gt;mapply(choose, 11:13, 1:3)&lt;/code&gt;, can be written as &lt;code&gt;broadcast(binomial, 11:13, 1:3)&lt;/code&gt; in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions &lt;code&gt;binomial.(11:13, 1:3)&lt;/code&gt;.</source>
          <target state="translated">R에서 다변량 적용 &lt;code&gt;mapply(choose, 11:13, 1:3)&lt;/code&gt; 예 : mapply (choose, 11:13, 1 : 3) &lt;code&gt;broadcast(binomial, 11:13, 1:3)&lt;/code&gt; 은 Julia에서 broadcast (binomial, 11:13, 1 : 3) 로 쓸 수 있습니다 . 마찬가지로 Julia는 함수 &lt;code&gt;binomial.(11:13, 1:3)&lt;/code&gt; 을 벡터화하기 위해 더 짧은 도트 구문을 제공합니다 . (11:13, 1 : 3) .</target>
        </trans-unit>
        <trans-unit id="d1eadf2c10a086c1960a9b501d59933c8974dd2b" translate="yes" xml:space="preserve">
          <source>Multplication Order</source>
          <target state="translated">곱셈 순서</target>
        </trans-unit>
        <trans-unit id="aa146572cac44a8146d28c8ac452ea7d13c9ab21" translate="yes" xml:space="preserve">
          <source>Mushroom</source>
          <target state="translated">Mushroom</target>
        </trans-unit>
        <trans-unit id="a46b6d28712c4b7b4707908d1e571236cf12721a" translate="yes" xml:space="preserve">
          <source>Music Flat Sign / Flat</source>
          <target state="translated">음악 플랫 사인 / 플랫</target>
        </trans-unit>
        <trans-unit id="a04232f01f8df8edaadcea411ff36f7f6487ee84" translate="yes" xml:space="preserve">
          <source>Music Natural Sign / Natural</source>
          <target state="translated">음악 자연 기호 / 자연</target>
        </trans-unit>
        <trans-unit id="26d750dc923f792f858ed732c6ec0b1da0e99959" translate="yes" xml:space="preserve">
          <source>Music Sharp Sign / Sharp</source>
          <target state="translated">음악 샤프 사인 / 샤프</target>
        </trans-unit>
        <trans-unit id="683e80dc8a4c6e7c8bc826f53b6dfcf0a6bda4f2" translate="yes" xml:space="preserve">
          <source>Musical Keyboard</source>
          <target state="translated">뮤지컬 키보드</target>
        </trans-unit>
        <trans-unit id="b65f0abd74cb5797c41071b0a9e2cddd68e16857" translate="yes" xml:space="preserve">
          <source>Musical Note</source>
          <target state="translated">음표</target>
        </trans-unit>
        <trans-unit id="2dfa13073285efc9898a345a8260636406d435b4" translate="yes" xml:space="preserve">
          <source>Musical Score</source>
          <target state="translated">악보</target>
        </trans-unit>
        <trans-unit id="b526f688cce16763794e58f91f1fb89b4e382f22" translate="yes" xml:space="preserve">
          <source>Mutable Composite Types</source>
          <target state="translated">가변 복합 유형</target>
        </trans-unit>
        <trans-unit id="3c9af487b0eb75065e220e4b4f64315251059f6d" translate="yes" xml:space="preserve">
          <source>Mutable collections</source>
          <target state="translated">가변 컬렉션</target>
        </trans-unit>
        <trans-unit id="f1b1ed439ba2f9dd0159774d9902013a44e5bafb" translate="yes" xml:space="preserve">
          <source>Mutable values, on the other hand are heap-allocated and passed to functions as pointers to heap-allocated values except in cases where the compiler is sure that there's no way to tell that this is not what is happening.</source>
          <target state="translated">반면에 가변 값은 힙 할당되고 힙 할당 값에 대한 포인터로 함수에 함수에 전달됩니다. 단, 컴파일러는 이것이 일어나고 있지 않다는 것을 알 수있는 방법이 없다고 확신하는 경우는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="d562bdafddbc28a1463062065c657c4bc9672cc9" translate="yes" xml:space="preserve">
          <source>Mutation of the bounds of the underlying array will invalidate this iterator.</source>
          <target state="translated">기본 배열의 경계를 변경하면이 반복자가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="2c601014fa28760ad8ec66e89966537368e4cbb2" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Dot Operator</source>
          <target state="translated">N- 아리 서클 도트 연산자</target>
        </trans-unit>
        <trans-unit id="9b908a94b34698b4d9b7b0207be4158da2feb778" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Plus Operator</source>
          <target state="translated">N-Ary Circled Plus 연산자</target>
        </trans-unit>
        <trans-unit id="2fd5ce147977305f56f82ccf66ec27699a2f05e0" translate="yes" xml:space="preserve">
          <source>N-Ary Circled Times Operator</source>
          <target state="translated">N-Ary Circled Times 연산자</target>
        </trans-unit>
        <trans-unit id="9a70409166d87ecdf40d895d65a2de86858c7d72" translate="yes" xml:space="preserve">
          <source>N-Ary Coproduct</source>
          <target state="translated">N- 아리 코 제품</target>
        </trans-unit>
        <trans-unit id="a39e136f6e4c1d1091281d6e70793affbdc62596" translate="yes" xml:space="preserve">
          <source>N-Ary Intersection</source>
          <target state="translated">N- 아리 교차로</target>
        </trans-unit>
        <trans-unit id="75cd531fa98b88aa4c1ea0f5aad0923bb35686de" translate="yes" xml:space="preserve">
          <source>N-Ary Logical And</source>
          <target state="translated">N-Ary 논리 및</target>
        </trans-unit>
        <trans-unit id="4cd0377615b0c0c9e50ec272b87620b1882f58ce" translate="yes" xml:space="preserve">
          <source>N-Ary Logical Or</source>
          <target state="translated">N-Ary 논리 또는</target>
        </trans-unit>
        <trans-unit id="12a25a06e9c573bc3729989159399e1d0bee4414" translate="yes" xml:space="preserve">
          <source>N-Ary Product</source>
          <target state="translated">N- 아리 제품</target>
        </trans-unit>
        <trans-unit id="9bceaf94be234c09815c4e2f3473560766a97e3a" translate="yes" xml:space="preserve">
          <source>N-Ary Square Intersection Operator</source>
          <target state="translated">N-Ary Square 교차로 연산자</target>
        </trans-unit>
        <trans-unit id="9acad29f71e0c492d455e428791c8757b2902981" translate="yes" xml:space="preserve">
          <source>N-Ary Square Union Operator</source>
          <target state="translated">N-Ary Square Union 연산자</target>
        </trans-unit>
        <trans-unit id="5fc7d374c42e4f2df4bcb04f0f33dc4c12531c00" translate="yes" xml:space="preserve">
          <source>N-Ary Summation</source>
          <target state="translated">N- 아리 요약</target>
        </trans-unit>
        <trans-unit id="22be9150d2380639b3cc7120e2b0ad3eb38c0c10" translate="yes" xml:space="preserve">
          <source>N-Ary Times Operator</source>
          <target state="translated">N-Ary Times 연산자</target>
        </trans-unit>
        <trans-unit id="81f1103959c04f566d198e3617a3b0a0b4932170" translate="yes" xml:space="preserve">
          <source>N-Ary Union</source>
          <target state="translated">N 아리 연합</target>
        </trans-unit>
        <trans-unit id="a7b227350c7615a207de1206fdd8cd99b07f317f" translate="yes" xml:space="preserve">
          <source>N-Ary Union Operator With Dot</source>
          <target state="translated">도트가있는 N-Ary Union 연산자</target>
        </trans-unit>
        <trans-unit id="fc811ee4937db532790cf25d7cb94a1efeaa332a" translate="yes" xml:space="preserve">
          <source>N-Ary Union Operator With Plus</source>
          <target state="translated">Plus가 포함 된 N-Ary Union 연산자</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="84eca33f462fff1d82716a00bb1a9da6eef01b51" translate="yes" xml:space="preserve">
          <source>NaN16</source>
          <target state="translated">NaN16</target>
        </trans-unit>
        <trans-unit id="c1186f579effcba17fc840178088ad9180ffa477" translate="yes" xml:space="preserve">
          <source>NaN32</source>
          <target state="translated">NaN32</target>
        </trans-unit>
        <trans-unit id="c04255172c46885eea43e832178b016bfeeae55b" translate="yes" xml:space="preserve">
          <source>Nabla</source>
          <target state="translated">Nabla</target>
        </trans-unit>
        <trans-unit id="1ef8040bc58bb62eac4b1f05cdee5404fd80b514" translate="yes" xml:space="preserve">
          <source>Nail Polish</source>
          <target state="translated">매니큐어</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="f0625d2052ba9bb5afda3d21d6721388e5f4c4b1" translate="yes" xml:space="preserve">
          <source>Name Badge</source>
          <target state="translated">이름 배지</target>
        </trans-unit>
        <trans-unit id="da36348ca4a6d538eb48f90ec86de8739a592351" translate="yes" xml:space="preserve">
          <source>Named Tuple Types</source>
          <target state="translated">명명 된 튜플 유형</target>
        </trans-unit>
        <trans-unit id="00f19d99a1a121465f53068cd3e37c47ef1fad72" translate="yes" xml:space="preserve">
          <source>Named Tuples</source>
          <target state="translated">명명 된 튜플</target>
        </trans-unit>
        <trans-unit id="dc6d9efdb67defed4600406bfad7cbe046812758" translate="yes" xml:space="preserve">
          <source>Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.</source>
          <target state="translated">이름이 있고 번호가 지정된 각주 참조는 다음 구문을 사용하여 작성할 수 있습니다. 각주 이름은 문장 부호가없는 단일 영숫자 단어 여야합니다.</target>
        </trans-unit>
        <trans-unit id="72be3008659f32677ce2d2404bd56f83680d29f1" translate="yes" xml:space="preserve">
          <source>Named tuples are instances of the &lt;a href=&quot;../../base/base/index#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt; type, which has two parameters: a tuple of symbols giving the field names, and a tuple type giving the field types.</source>
          <target state="translated">명명 된 튜플은 &lt;a href=&quot;../../base/base/index#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt; 유형의 인스턴스로, 필드 이름을 제공하는 기호 튜플과 필드 유형을 제공하는 튜플 유형의 두 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5d82adfa43b289c6963f7407c953d4e61d46b7" translate="yes" xml:space="preserve">
          <source>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (&lt;code&gt;x.a&lt;/code&gt;) in addition to the regular indexing syntax (&lt;code&gt;x[1]&lt;/code&gt;).</source>
          <target state="translated">명명 된 튜플은 일반 인덱싱 구문 ( &lt;code&gt;x[1]&lt;/code&gt; ) 외에 점 구문 ( &lt;code&gt;x.a&lt;/code&gt; )을 사용하여 이름으로 필드에 추가로 액세스 할 수 있다는 점을 제외하면 튜플과 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="3e6a4d10273503fa27f8c46a18767ab4521c07a3" translate="yes" xml:space="preserve">
          <source>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (&lt;code&gt;x.a&lt;/code&gt;).</source>
          <target state="translated">명명 된 튜플은 튜플과 매우 유사하지만 점 구문 ( &lt;code&gt;x.a&lt;/code&gt; )을 사용하여 이름으로 필드에 추가로 액세스 할 수 있다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f45cc1e50f55d768c6a39cd232336976b7732dfc" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;Type&lt;/code&gt;s and &lt;code&gt;Module&lt;/code&gt;s begin with a capital letter and word separation is shown with upper camel case instead of underscores.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 과 &lt;code&gt;Module&lt;/code&gt; 의 이름은 대문자로 시작하며 단어 구분은 밑줄 대신 대문자 낙타 문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="669b5c2a0af852115b81963203fce679df22a31e" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;function&lt;/code&gt;s and &lt;code&gt;macro&lt;/code&gt;s are in lower case, without underscores.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 와 &lt;code&gt;macro&lt;/code&gt; 의 이름은 밑줄없이 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="315abfa13d69446ee3cab0a04d182cc545dfb2c3" translate="yes" xml:space="preserve">
          <source>Names of variables are in lower case.</source>
          <target state="translated">변수 이름은 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="6caeb19c64bfdb2c7f9f0778d9792f83f81ab4c7" translate="yes" xml:space="preserve">
          <source>Namespace miscellanea</source>
          <target state="translated">네임 스페이스 기타</target>
        </trans-unit>
        <trans-unit id="81767a14b5865561a4a0f909d1a970b4158b5af2" translate="yes" xml:space="preserve">
          <source>Nand</source>
          <target state="translated">Nand</target>
        </trans-unit>
        <trans-unit id="67491a6c4d2a113101836cc6410bc0b315f4cb77" translate="yes" xml:space="preserve">
          <source>Naturally, it is possible for quote expressions to contain other quote expressions. Understanding how interpolation works in these cases can be a bit tricky. Consider this example:</source>
          <target state="translated">당연히 따옴표 표현식에 다른 따옴표 표현식이 포함될 수 있습니다. 이 경우 보간 작동 방식을 이해하는 것은 약간 까다로울 수 있습니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ff1b33b1d17b9acbddf9cac2115963e31d8b21a5" translate="yes" xml:space="preserve">
          <source>Navigate to your temporary directory and launch Julia, then do the following:</source>
          <target state="translated">임시 디렉토리로 이동하여 Julia를 시작한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8841f81b26ad9918dae04823591307ed2dd7da48" translate="yes" xml:space="preserve">
          <source>Necktie</source>
          <target state="translated">Necktie</target>
        </trans-unit>
        <trans-unit id="3ecd749b905c6977df0e77186fb9812acf0f28a8" translate="yes" xml:space="preserve">
          <source>Negated Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">부정 더블 수직 바 더블 오른쪽 개찰구</target>
        </trans-unit>
        <trans-unit id="ffe87c942f9f7bfee31e0905a674a7acab19a578" translate="yes" xml:space="preserve">
          <source>Negation of &lt;code&gt;&amp;isin;&lt;/code&gt; and &lt;code&gt;&amp;ni;&lt;/code&gt;, i.e. checks that &lt;code&gt;item&lt;/code&gt; is not in &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;isin;&lt;/code&gt; 및 &lt;code&gt;&amp;ni;&lt;/code&gt; 의 부정 , 즉 &lt;code&gt;item&lt;/code&gt; 이 &lt;code&gt;collection&lt;/code&gt; 없는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b1931659c9e1b4ce9d7ec399d6f5e740532d35d3" translate="yes" xml:space="preserve">
          <source>Negation of &lt;code&gt;&amp;sube;&lt;/code&gt; and &lt;code&gt;&amp;supe;&lt;/code&gt;, i.e. checks that &lt;code&gt;a&lt;/code&gt; is not a subset of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;sube;&lt;/code&gt; 및 &lt;code&gt;&amp;supe;&lt;/code&gt; 의 부정 , 즉 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 의 부분 집합이 아닌지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c97b9bfba068fbd7a3a1fa54e3ccb57a97d94eb2" translate="yes" xml:space="preserve">
          <source>Negative Squared Ab</source>
          <target state="translated">음의 제곱 Ab</target>
        </trans-unit>
        <trans-unit id="fb3bdc3efad3dd419c1cb492507357bf8831cc24" translate="yes" xml:space="preserve">
          <source>Negative Squared Cross Mark</source>
          <target state="translated">네거티브 제곱 크로스 마크</target>
        </trans-unit>
        <trans-unit id="7d7b2e1e90ccc0cf1ee98411e4a3d9f188ae7074" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter A</source>
          <target state="translated">음의 제곱 라틴 대문자 A</target>
        </trans-unit>
        <trans-unit id="304d28b12dcf81b90eb5e22beadebcff60a1f7d6" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter B</source>
          <target state="translated">음의 제곱 라틴 대문자 B</target>
        </trans-unit>
        <trans-unit id="0c862d7b34ecee68029345c3bf7b39b898342164" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter O</source>
          <target state="translated">음의 제곱 라틴 대문자 O</target>
        </trans-unit>
        <trans-unit id="6a6308babfec9e69cdff52893e394748de4b3b29" translate="yes" xml:space="preserve">
          <source>Negative Squared Latin Capital Letter P</source>
          <target state="translated">음의 제곱 라틴 대문자 P</target>
        </trans-unit>
        <trans-unit id="ffbd11351af129f60826174098cbdf05e74f050f" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;convert&lt;/code&gt; nor &lt;code&gt;cconvert&lt;/code&gt; should take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;.</source>
          <target state="translated">나도 &lt;code&gt;convert&lt;/code&gt; 도 &lt;code&gt;cconvert&lt;/code&gt; 는 줄리아 객체를 취하지과로를 설정해야 &lt;code&gt;Ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="233c2a39e94063ce181611891dcdd95a1291b1a5" translate="yes" xml:space="preserve">
          <source>Neither A Subset Of Nor Equal To</source>
          <target state="translated">하위 집합도 같지 않습니다</target>
        </trans-unit>
        <trans-unit id="c927af76b71cf28775cab6c0bc644144b321e55f" translate="yes" xml:space="preserve">
          <source>Neither A Superset Of Nor Equal To</source>
          <target state="translated">수퍼 세트도 같지 않다</target>
        </trans-unit>
        <trans-unit id="1b6ef024104f196dec9cbcb30309372186d114d7" translate="yes" xml:space="preserve">
          <source>Neither Approximately Nor Actually Equal To</source>
          <target state="translated">대략 같거나 실제로 같지 않음</target>
        </trans-unit>
        <trans-unit id="f956227c83f5924a3ea073b24bb6bd1a835fcb86" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Equal To / Neither Greater Than Nor Equal To</source>
          <target state="translated">크거나 같거나 같거나 같지 않음</target>
        </trans-unit>
        <trans-unit id="53a8706df6fc90ce626526d16857164211520a7a" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Equivalent To / Neither Greater Than Nor Equivalent To</source>
          <target state="translated">크거나 같거나 같거나 크거나 같지 않다</target>
        </trans-unit>
        <trans-unit id="6e188aa5a652ee8d5842cae5b3d3116acba271aa" translate="yes" xml:space="preserve">
          <source>Neither Greater-Than Nor Less-Than / Neither Greater Than Nor Less Than</source>
          <target state="translated">크거나 좁거나 / 크거나 작지 않음</target>
        </trans-unit>
        <trans-unit id="5879307721237ad3ad1ce3bf914eafeb074a68e7" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Equal To / Neither Less Than Nor Equal To</source>
          <target state="translated">적거나 같지 않음 / 같거나 작음</target>
        </trans-unit>
        <trans-unit id="ba60a77dfac9693c527e4257a55200358bb7ed68" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Equivalent To / Neither Less Than Nor Equivalent To</source>
          <target state="translated">보다 작거나 동등하지 않음</target>
        </trans-unit>
        <trans-unit id="05b8c2fde6692011493ae29c78dc0887e72418f7" translate="yes" xml:space="preserve">
          <source>Neither Less-Than Nor Greater-Than / Neither Less Than Nor Greater Than</source>
          <target state="translated">그보다 작거나 크지 않음 / 그보다 작거나 크지 않음</target>
        </trans-unit>
        <trans-unit id="8eaf74d125ce35ab9a8504c91cbc3fd36b5155df" translate="yes" xml:space="preserve">
          <source>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</source>
          <target state="translated">그러나 두 개의 괄호로 묶인 표현식의 병치 나 괄호로 묶은 표현식 앞에 변수를 배치하여 곱셈을 암시하는 데 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="125186d5ff63f69c3e2321b1e81aa13d69cff28e" translate="yes" xml:space="preserve">
          <source>Neptune</source>
          <target state="translated">Neptune</target>
        </trans-unit>
        <trans-unit id="8b4fbd05fd436fc9d45e06e93c5beb9d6849ca86" translate="yes" xml:space="preserve">
          <source>Nested quote</source>
          <target state="translated">중첩 된 견적</target>
        </trans-unit>
        <trans-unit id="552146d37d66cb78074b5849a522f96a5d21589c" translate="yes" xml:space="preserve">
          <source>Network I/O</source>
          <target state="translated">네트워크 I / O</target>
        </trans-unit>
        <trans-unit id="c0a64e9ee73a50340ce5cfbcba50917cd8be1ac8" translate="yes" xml:space="preserve">
          <source>Network Requirements for LocalManager and SSHManager</source>
          <target state="translated">LocalManager 및 SSHManager의 네트워크 요구 사항</target>
        </trans-unit>
        <trans-unit id="3a55c8cb72838904c479c39b6e41b29c517f702a" translate="yes" xml:space="preserve">
          <source>Networking and Streams</source>
          <target state="translated">네트워킹 및 스트림</target>
        </trans-unit>
        <trans-unit id="a54631a938fc351480252a8fbf952417324a21a2" translate="yes" xml:space="preserve">
          <source>Neuter</source>
          <target state="translated">Neuter</target>
        </trans-unit>
        <trans-unit id="d1b0bf8b5a4f962ac54b72ec0f3e2249c35062e8" translate="yes" xml:space="preserve">
          <source>Neutral Face</source>
          <target state="translated">중립 얼굴</target>
        </trans-unit>
        <trans-unit id="b4dda3e4d7496caa2e8efb358bf65c52a3c57038" translate="yes" xml:space="preserve">
          <source>New Moon Symbol</source>
          <target state="translated">뉴문 심볼</target>
        </trans-unit>
        <trans-unit id="5162116d9d9cdaee88a84b1fdffa1911b0cf303d" translate="yes" xml:space="preserve">
          <source>New Moon With Face</source>
          <target state="translated">얼굴을 가진 초승달</target>
        </trans-unit>
        <trans-unit id="4e0a4bfd07ff7fd179ef28a5c32dcfb6bc100f78" translate="yes" xml:space="preserve">
          <source>New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.</source>
          <target state="translated">원자가 아닌 값으로 새로운 원자 객체를 생성 할 수 있습니다. 아무것도 지정하지 않으면 원자 객체가 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="42da565d7b3c34bde47eabec6e6f2994bbe6f925" translate="yes" xml:space="preserve">
          <source>New global bindings are created on destination workers if they are referenced as part of a remote call.</source>
          <target state="translated">원격 호출의 일부로 참조되는 경우 대상 작업자에 새 글로벌 바인딩이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fcf5911a9a18167d53b9c21f18e27ba0cdf0f2d" translate="yes" xml:space="preserve">
          <source>New line, executing if it is complete</source>
          <target state="translated">새로운 라인, 완료되면 실행</target>
        </trans-unit>
        <trans-unit id="4bf7ffd18bc132813bddeb711b1027143b9438b3" translate="yes" xml:space="preserve">
          <source>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</source>
          <target state="translated">새 숫자 유형은 새 유형의 두 인수에 대해이 함수를 구현하고 가능한 경우 승격 규칙을 통해 다른 유형과의 비교를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bab8bf1f9729e23910958279e9c76398ca6d35f4" translate="yes" xml:space="preserve">
          <source>New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; instead. (x &amp;lt; y) | (x == y)</source>
          <target state="translated">정식 부분 순서를 갖는 새로운 숫자 유형은 새로운 유형의 두 인수에 대해이 함수를 구현해야합니다. 정규 전체 순서와 유형 구현해야 &lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; 대신. (x &amp;lt;y) | (x == y)</target>
        </trans-unit>
        <trans-unit id="4375e0864ac979046f6e07a8e572643b3f85eecd" translate="yes" xml:space="preserve">
          <source>New objects of type &lt;code&gt;Foo&lt;/code&gt; are created by applying the &lt;code&gt;Foo&lt;/code&gt; type object like a function to values for its fields:</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 유형의 새 오브젝트는 함수와 같은 &lt;code&gt;Foo&lt;/code&gt; 유형 오브젝트를 필드 값 에 적용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c14debc183a7a71d36ba349a00f8d8faf55873b6" translate="yes" xml:space="preserve">
          <source>New types should generally not implement this, and rely on the fallback definition &lt;code&gt;!=(x,y) = !(x==y)&lt;/code&gt; instead.</source>
          <target state="translated">새로운 유형은 일반적으로 이것을 구현해서는 안되며 대신 대체 정의 &lt;code&gt;!=(x,y) = !(x==y)&lt;/code&gt; 의존해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5288a6ff5118bf7315848b31718dedea3e423463" translate="yes" xml:space="preserve">
          <source>New types should implement the 2-argument form, typically by calling the 2-argument &lt;code&gt;hash&lt;/code&gt; method recursively in order to mix hashes of the contents with each other (and with &lt;code&gt;h&lt;/code&gt;). Typically, any type that implements &lt;code&gt;hash&lt;/code&gt; should also implement its own &lt;code&gt;==&lt;/code&gt; (hence &lt;code&gt;isequal&lt;/code&gt;) to guarantee the property mentioned above. Types supporting subtraction (operator &lt;code&gt;-&lt;/code&gt;) should also implement &lt;a href=&quot;#Base.widen&quot;&gt;&lt;code&gt;widen&lt;/code&gt;&lt;/a&gt;, which is required to hash values inside heterogeneous arrays.</source>
          <target state="translated">새로운 유형은 내용의 해시를 서로 (및 &lt;code&gt;h&lt;/code&gt; ) 혼합하기 위해 일반적으로 2 인수 &lt;code&gt;hash&lt;/code&gt; 메소드를 재귀 적 으로 호출하여 2 인수 형식을 구현해야합니다 . 일반적으로 &lt;code&gt;hash&lt;/code&gt; 를 구현하는 모든 유형은 위에서 언급 한 속성을 보장 하기 위해 자체 &lt;code&gt;==&lt;/code&gt; (따라서 &lt;code&gt;isequal&lt;/code&gt; ) 도 구현해야합니다 . 빼기를 지원하는 유형 (연산자 &lt;code&gt;-&lt;/code&gt; )도 &lt;a href=&quot;#Base.widen&quot;&gt; &lt;code&gt;widen&lt;/code&gt; &lt;/a&gt; 을 구현해야합니다. 이기종 어레이 내부 해시 값을 필요로하는.</target>
        </trans-unit>
        <trans-unit id="8ebfdd35568644f8081c35fc3f12a59a472803b6" translate="yes" xml:space="preserve">
          <source>Newly launched workers are connected to each other and the master process in an all-to-all manner. Specifying the command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; results in the launched processes initializing themselves as workers and connections being set up via TCP/IP sockets.</source>
          <target state="translated">새로 출근 한 근로자는 서로와 마스터 프로세스를 모두에게 전적으로 연결합니다. 명령 행 인수 &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; 를 지정하면 시작된 프로세스가 작업자 및 연결이 TCP / IP 소켓을 통해 설정 됨으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ebe6500747dd5dbad08cc1b33d55fac89ccbe97" translate="yes" xml:space="preserve">
          <source>Newspaper</source>
          <target state="translated">Newspaper</target>
        </trans-unit>
        <trans-unit id="5bd14d065cae3dc87a51a7f9bf093bcd68b07382" translate="yes" xml:space="preserve">
          <source>Next integer greater than or equal to &lt;code&gt;n&lt;/code&gt; that can be written as $\prod k_i^{p_i}$ for integers $p_1$, $p_2$, etc.</source>
          <target state="translated">정수 $ p_1 $, $ p_2 $ 등의 경우 $ \ prod k_i ^ {p_i} $로 쓸 수있는 &lt;code&gt;n&lt;/code&gt; 보다 크거나 같은 다음 정수</target>
        </trans-unit>
        <trans-unit id="aba200342ccf03d1bafb26bcbb6342a3a0b1643f" translate="yes" xml:space="preserve">
          <source>Next, define the kernel:</source>
          <target state="translated">다음으로 커널을 정의하십시오 :</target>
        </trans-unit>
        <trans-unit id="7f9875a180491e1b45f1d0759452d83c8b960ad6" translate="yes" xml:space="preserve">
          <source>Next, if the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline, the newline is stripped from the resulting string.</source>
          <target state="translated">다음으로 여는 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 다음에 줄 바꿈이 있으면 줄 바꾸기가 결과 문자열에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c98ca6cb45da2e13d7f7832cf79ad9c6c39a9b49" translate="yes" xml:space="preserve">
          <source>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. &lt;a href=&quot;https://doi.org/10.1137/090768539&quot;&gt;doi:10.1137/090768539&lt;/a&gt;</source>
          <target state="translated">Nicholas J. Higham, &quot;매트릭스 지수 재검토를위한 제곱 및 스케일링 방법&quot;, SIAM Journal on Matrix Analysis and Applications, 26 (4), 2005, 1179-1193. &lt;a href=&quot;https://doi.org/10.1137/090768539&quot;&gt;도이 : 10.1137 / 090768539&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a9839fb83bfc341f1b5011bf886013fa6dc9c85" translate="yes" xml:space="preserve">
          <source>Night With Stars</source>
          <target state="translated">별 밤</target>
        </trans-unit>
        <trans-unit id="3b4b68ee82d1457f561bcf2ebd93545d2930b673" translate="yes" xml:space="preserve">
          <source>No Bicycles</source>
          <target state="translated">자전거 없음</target>
        </trans-unit>
        <trans-unit id="300395a40ea5ba24b06bf5bebc77f5acb519cd26" translate="yes" xml:space="preserve">
          <source>No Entry</source>
          <target state="translated">출입 불가</target>
        </trans-unit>
        <trans-unit id="1dc67672d1e78df9c7a3ae0058c325f42dbcd6e3" translate="yes" xml:space="preserve">
          <source>No Entry Sign</source>
          <target state="translated">입장 흔적</target>
        </trans-unit>
        <trans-unit id="7c763368e2dec5b9f5a836da233b2fdd7abcf76a" translate="yes" xml:space="preserve">
          <source>No Mobile Phones</source>
          <target state="translated">휴대 전화 없음</target>
        </trans-unit>
        <trans-unit id="73a75f5a045c4f409b30178f7e28e222115eaf07" translate="yes" xml:space="preserve">
          <source>No One Under Eighteen Symbol</source>
          <target state="translated">18 세 이하의 사람은 없음</target>
        </trans-unit>
        <trans-unit id="f30174bd862c1b850d5daf2da97d7d2e0ea07764" translate="yes" xml:space="preserve">
          <source>No Pedestrians</source>
          <target state="translated">보행자 없음</target>
        </trans-unit>
        <trans-unit id="d7ef380838898f831b1fb3b2b043fc3b8530cc7f" translate="yes" xml:space="preserve">
          <source>No Smoking Symbol</source>
          <target state="translated">금연 기호 없음</target>
        </trans-unit>
        <trans-unit id="57eab258ddc4b2c598877a443b028f20a035c6a3" translate="yes" xml:space="preserve">
          <source>No checks are done during parsing to make sure that all footnote references have matching footnotes.</source>
          <target state="translated">구문 분석 중에는 모든 각주 참조에 일치하는 각주가 있는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13a6288d973ec4996b49f9948606ae303dc2af4c" translate="yes" xml:space="preserve">
          <source>No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by &lt;code&gt;Pkg.update&lt;/code&gt;), and no cleanup is done after &lt;code&gt;Pkg.rm&lt;/code&gt;</source>
          <target state="translated">소스 파일 자체를 변경 한 후 ( &lt;code&gt;Pkg.update&lt;/code&gt; 포함 ) 코드 다시로드 / 캐시 무효화가 수행 되지 않으며 &lt;code&gt;Pkg.rm&lt;/code&gt; 이후에는 정리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecbe7bcfebb243ae01bf8cd3e5a27e1861e41f26" translate="yes" xml:space="preserve">
          <source>No iteration ever waits on a previous iteration to make forward progress.</source>
          <target state="translated">이전 진행에서 앞으로 진행하기 위해 반복을 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e52b264d00ad4e4f1bda0e1a691bb9244f886ba" translate="yes" xml:space="preserve">
          <source>No more data was available to read from a file or stream.</source>
          <target state="translated">파일이나 스트림에서 더 이상 읽을 수있는 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fef04914268ffcfc814a2c459f624e4fffeea1f" translate="yes" xml:space="preserve">
          <source>No need to vectorize code for performance; devectorized code is fast</source>
          <target state="translated">성능을 위해 코드를 벡터화 할 필요가 없습니다. 벡터화되지 않은 코드는 빠릅니다</target>
        </trans-unit>
        <trans-unit id="0b4cf4302bd72eb2ed70f2329341a5c0f835663c" translate="yes" xml:space="preserve">
          <source>No, you are not allowed to have a &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; statement inside a function. If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:</source>
          <target state="translated">아니요, 함수 내에 &lt;code&gt;using&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 문을 사용할 수 없습니다 . 모듈을 가져오고 싶지만 특정 함수 또는 함수 세트 내에서만 해당 기호를 사용하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="e8031546b21c9103c8369b938a711ee94aa6cb0c" translate="yes" xml:space="preserve">
          <source>Nomenclature: while the term &quot;constructor&quot; generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as &quot;constructors&quot;. In such situations, it is generally clear from the context that the term is used to mean &quot;constructor method&quot; rather than &quot;constructor function&quot;, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.</source>
          <target state="translated">명명법 : &quot;생성자&quot;라는 용어는 일반적으로 유형의 객체를 구성하는 전체 함수를 지칭하지만 용어를 약간 남용하고 특정 생성자 방법을 &quot;생성자&quot;라고하는 것이 일반적입니다. 이러한 상황에서는 일반적으로 용어가 &quot;생성자 함수&quot;가 아니라 &quot;생성자 메서드&quot;를 의미하는 데 사용된다는 것이 분명합니다. 특히 생성자의 특정 메소드를 모두 다른 사람.</target>
        </trans-unit>
        <trans-unit id="5393bce9c456b5dccf1b10b47f64ec8dceba68b0" translate="yes" xml:space="preserve">
          <source>Non recursive version of &lt;a href=&quot;#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; 의&lt;/a&gt; 비 재귀 버전 .</target>
        </trans-unit>
        <trans-unit id="4fd4f1970b7db3e3254ed0b122568de524763f9c" translate="yes" xml:space="preserve">
          <source>Non-Potable Water Symbol</source>
          <target state="translated">비 수용성 물 기호</target>
        </trans-unit>
        <trans-unit id="924dd85922c4b4ff6e591e92e7dda2c98a76eb77" translate="yes" xml:space="preserve">
          <source>Non-Standard String Literals</source>
          <target state="translated">비표준 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="9b186b7c2f679f7744cb664b1882bcc1ac565fe3" translate="yes" xml:space="preserve">
          <source>Non-associative</source>
          <target state="translated">Non-associative</target>
        </trans-unit>
        <trans-unit id="48fc3ac98a8542a16b7dcf01a843d3f0fabfb8c5" translate="yes" xml:space="preserve">
          <source>Non-boolean integers</source>
          <target state="translated">부울이 아닌 정수</target>
        </trans-unit>
        <trans-unit id="4b33187713b64697a972670418561cf355a2a01e" translate="yes" xml:space="preserve">
          <source>Non-constant Function Specifications</source>
          <target state="translated">일정하지 않은 기능 사양</target>
        </trans-unit>
        <trans-unit id="f7f79c9047efe79f312570b471a63dcc86aa67b7" translate="yes" xml:space="preserve">
          <source>Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as &lt;code&gt;NaN&lt;/code&gt;. Types with a partial order should implement &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">총 순서가있는 숫자가 아닌 유형이이 기능을 구현해야합니다. 숫자 형은 &lt;code&gt;NaN&lt;/code&gt; 과 같은 특수 값이있는 경우에만 구현하면됩니다 . 부분 순서가있는 유형은 &lt;code&gt;&amp;lt;&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ba674a48316fb1433436a60a425791cc32b78b0" translate="yes" xml:space="preserve">
          <source>Nonforking</source>
          <target state="translated">Nonforking</target>
        </trans-unit>
        <trans-unit id="97f53a3ef5c6423e5a459f652ffb969748da2787" translate="yes" xml:space="preserve">
          <source>Nor</source>
          <target state="translated">Nor</target>
        </trans-unit>
        <trans-unit id="353d229b6f3ca31bd45bd9bebe8e58269912e930" translate="yes" xml:space="preserve">
          <source>Normal Subgroup Of</source>
          <target state="translated">정상 부분 군</target>
        </trans-unit>
        <trans-unit id="a7f48eaa19bcc609000a719de46fc1f3c28fd022" translate="yes" xml:space="preserve">
          <source>Normal Subgroup Of Or Equal To</source>
          <target state="translated">정상 하위 그룹 또는 같음</target>
        </trans-unit>
        <trans-unit id="ea65c52c4dc34140ff47fd23bf1ce89abf2497b1" translate="yes" xml:space="preserve">
          <source>Normalize a path, removing &quot;.&quot; and &quot;..&quot; entries.</source>
          <target state="translated">&quot;.&quot;를 제거하여 경로를 정규화하십시오. 및 &quot;..&quot;항목.</target>
        </trans-unit>
        <trans-unit id="5db16edc23f62be0c1341058dd3eaba05abc2f92" translate="yes" xml:space="preserve">
          <source>Normalize the array &lt;code&gt;a&lt;/code&gt; in-place so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(a, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; - &lt;code&gt;norm(a, p) == 1&lt;/code&gt; 이 1과 같 도록 배열 &lt;code&gt;a&lt;/code&gt; 를 제자리에 정규화합니다 . 즉, norm (a, p) == 1 . &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eb5e4cb9a195c300eb971c48748e73eb51af152" translate="yes" xml:space="preserve">
          <source>Normalize the array &lt;code&gt;a&lt;/code&gt; so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(a, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt;&lt;code&gt;normalize!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; - &lt;code&gt;norm(a, p) == 1&lt;/code&gt; 이 1과 같 도록 배열 &lt;code&gt;a&lt;/code&gt; 를 정규화합니다 . 즉, norm (a, p) == 1 . &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt; &lt;code&gt;normalize!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 및 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dff1142e88fe8e90deecc8b52307005080af42f" translate="yes" xml:space="preserve">
          <source>Normalize the string &lt;code&gt;s&lt;/code&gt; according to one of the four &quot;normal forms&quot; of the Unicode standard: &lt;code&gt;normalform&lt;/code&gt; can be &lt;code&gt;:NFC&lt;/code&gt;, &lt;code&gt;:NFD&lt;/code&gt;, &lt;code&gt;:NFKC&lt;/code&gt;, or &lt;code&gt;:NFKD&lt;/code&gt;. Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact. Normal forms KC and KD additionally canonicalize &quot;compatibility equivalents&quot;: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.</source>
          <target state="translated">표준화 문자열 &lt;code&gt;s&lt;/code&gt; 유니 코드 표준의 네 &quot;정상적인 형태&quot;중 하나에 따라 : &lt;code&gt;normalform&lt;/code&gt; 이 될 수 있습니다 &lt;code&gt;:NFC&lt;/code&gt; , &lt;code&gt;:NFD&lt;/code&gt; , &lt;code&gt;:NFKC&lt;/code&gt; , 또는 &lt;code&gt;:NFKD&lt;/code&gt; . 일반 형식 C (정식 구성) 및 D (정식 분해)는 동일한 추상 문자열의 서로 다른 시각적으로 동일한 표현을 단일 표준 형식으로 변환하며 형식 C는 더 간결합니다. 일반적인 형식 KC와 KD는 &quot;호환성 동등성&quot;을 추가로 정규화합니다. 이들은 추상적으로 유사하지만 시각적으로 구별되는 문자를 단일 표준 선택으로 변환합니다 (예 : 합자를 개별 문자로 확장). 형식 KC는 더 간결합니다.</target>
        </trans-unit>
        <trans-unit id="50d67ce67ee1beedca3296a6a0355b79281766ab" translate="yes" xml:space="preserve">
          <source>Normalize the string &lt;code&gt;s&lt;/code&gt;. By default, canonical composition (&lt;code&gt;compose=true&lt;/code&gt;) is performed without ensuring Unicode versioning stability (&lt;code&gt;compat=false&lt;/code&gt;), which produces the shortest possible equivalent string but may introduce composition characters not present in earlier Unicode versions.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 를 정규화하십시오 . 기본적으로 표준 작성 ( &lt;code&gt;compose=true&lt;/code&gt; )은 유니 코드 버전 안정성 ( &lt;code&gt;compat=false&lt;/code&gt; ) 을 보장하지 않고 수행 되며, 이는 가능한 가장 짧은 동등한 문자열을 생성하지만 이전 유니 코드 버전에없는 작성 문자를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1256c1ca544db3bbe8bc3cbce15ea1460cf4f911" translate="yes" xml:space="preserve">
          <source>Normalize the vector &lt;code&gt;v&lt;/code&gt; in-place so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(v, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; - &lt;code&gt;norm(v, p) == 1&lt;/code&gt; 이 1, 즉 norm (v, p) == 1이 되도록 벡터 &lt;code&gt;v&lt;/code&gt; 를 제자리에서 정규화합니다 . &lt;a href=&quot;#LinearAlgebra.normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0ca0cad26499570c164bc9b04bdb5e73ad3b767" translate="yes" xml:space="preserve">
          <source>Normalize the vector &lt;code&gt;v&lt;/code&gt; so that its &lt;code&gt;p&lt;/code&gt;-norm equals unity, i.e. &lt;code&gt;norm(v, p) == 1&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt;&lt;code&gt;normalize!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; - &lt;code&gt;norm(v, p) == 1&lt;/code&gt; 이 1, 즉 norm (v, p) == 1이 되도록 벡터 &lt;code&gt;v&lt;/code&gt; 를 정규화합니다 . &lt;a href=&quot;#LinearAlgebra.normalize!&quot;&gt; &lt;code&gt;normalize!&lt;/code&gt; &lt;/a&gt; 참조 ! 그리고 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="478b31a56bd438b5767a545ce1ed00f11487d0db" translate="yes" xml:space="preserve">
          <source>North East Arrow / Upper Right Arrow</source>
          <target state="translated">북동쪽 화살표 / 오른쪽 위 화살표</target>
        </trans-unit>
        <trans-unit id="0f9632ee4c4b3913bab8a246eac9a7aaa6e34c3e" translate="yes" xml:space="preserve">
          <source>North East Arrow And South East Arrow</source>
          <target state="translated">북동 화살표 및 남동 화살표</target>
        </trans-unit>
        <trans-unit id="30cf74356d2a464d3ca7374ff4dc9e2894799efd" translate="yes" xml:space="preserve">
          <source>North East Arrow Crossing North West Arrow</source>
          <target state="translated">북동 화살표 교차점 북서쪽 화살표</target>
        </trans-unit>
        <trans-unit id="916f9b242f547ef05ec66f2fa83e1592cdbcfdbd" translate="yes" xml:space="preserve">
          <source>North East Arrow Crossing South East Arrow</source>
          <target state="translated">동북 화살표 교차 남동 화살표</target>
        </trans-unit>
        <trans-unit id="b0e4cc646e9668d5edd815430e5705b8eb0282d0" translate="yes" xml:space="preserve">
          <source>North East Double Arrow / Upper Right Double Arrow</source>
          <target state="translated">노스 이스트 더블 애로우 / 오른쪽 위 더블 애로우</target>
        </trans-unit>
        <trans-unit id="2851194a781dba08882cd8b5dcac7c7bff4bc98b" translate="yes" xml:space="preserve">
          <source>North West Arrow / Upper Left Arrow</source>
          <target state="translated">노스 웨스트 화살표 / 왼쪽 위 화살표</target>
        </trans-unit>
        <trans-unit id="233c55eeb0aa49ef4b20ef3585841b43d859f2df" translate="yes" xml:space="preserve">
          <source>North West Arrow And North East Arrow</source>
          <target state="translated">노스 웨스트 화살표 및 노스 이스트 화살표</target>
        </trans-unit>
        <trans-unit id="c8af1f130f612aaea28cebf3c5f06dbc620210fa" translate="yes" xml:space="preserve">
          <source>North West Arrow Crossing North East Arrow</source>
          <target state="translated">노스 웨스트 화살표 교차점 노스 이스트 화살표</target>
        </trans-unit>
        <trans-unit id="f21049a5d207abc1091420d168abe05b73221d81" translate="yes" xml:space="preserve">
          <source>North West Arrow To Long Bar / Upper Left Arrow To Long Bar</source>
          <target state="translated">긴 막대에 북쪽 서쪽 화살표 / 긴 막대에 왼쪽 위 화살표</target>
        </trans-unit>
        <trans-unit id="1ef9c199f598a375deeea550d911861c89af3632" translate="yes" xml:space="preserve">
          <source>North West Double Arrow / Upper Left Double Arrow</source>
          <target state="translated">노스 웨스트 이중 화살표 / 왼쪽 위 이중 화살표</target>
        </trans-unit>
        <trans-unit id="eb9f9930aed653b8a960f004b0d33be134abd920" translate="yes" xml:space="preserve">
          <source>Nose</source>
          <target state="translated">Nose</target>
        </trans-unit>
        <trans-unit id="4924b680ce01b04d3901d5887ba0094a80386e09" translate="yes" xml:space="preserve">
          <source>Not &lt;em&gt;all&lt;/em&gt; primitive types can be wrapped in an &lt;code&gt;Atomic&lt;/code&gt; tag. Supported types are &lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt8&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;, &lt;code&gt;Float16&lt;/code&gt;, &lt;code&gt;Float32&lt;/code&gt;, and &lt;code&gt;Float64&lt;/code&gt;. Additionally, &lt;code&gt;Int128&lt;/code&gt; and &lt;code&gt;UInt128&lt;/code&gt; are not supported on AAarch32 and ppc64le.</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 기본 유형이 &lt;code&gt;Atomic&lt;/code&gt; 태그 로 랩핑 될 수있는 것은 아닙니다 . 지원되는 유형은 &lt;code&gt;Int8&lt;/code&gt; , &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int64&lt;/code&gt; , &lt;code&gt;Int128&lt;/code&gt; , &lt;code&gt;UInt8&lt;/code&gt; , &lt;code&gt;UInt16&lt;/code&gt; , &lt;code&gt;UInt32&lt;/code&gt; , &lt;code&gt;UInt64&lt;/code&gt; , &lt;code&gt;UInt128&lt;/code&gt; , &lt;code&gt;Float16&lt;/code&gt; , &lt;code&gt;Float32&lt;/code&gt; 및 &lt;code&gt;Float64&lt;/code&gt; 입니다. 또한 &lt;code&gt;Int128&lt;/code&gt; 및 &lt;code&gt;UInt128&lt;/code&gt; 에서는 Int128 및 UInt128 이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44c45a3975806f5aa3563e402ab48284ba7dd19a" translate="yes" xml:space="preserve">
          <source>Not A Subset Of</source>
          <target state="translated">하위 집단이 아님</target>
        </trans-unit>
        <trans-unit id="a17eca69bf167ebef605d6f511649ff7e242d247" translate="yes" xml:space="preserve">
          <source>Not A Superset Of</source>
          <target state="translated">슈퍼 세트가 아님</target>
        </trans-unit>
        <trans-unit id="bc9d785d0ab5238febfc3ab6b86ae20357096f11" translate="yes" xml:space="preserve">
          <source>Not Almost Equal To</source>
          <target state="translated">거의 같지 않음</target>
        </trans-unit>
        <trans-unit id="d67d6c66a36751875c25ecc62a3d848e35280e41" translate="yes" xml:space="preserve">
          <source>Not An Element Of</source>
          <target state="translated">요소가 아님</target>
        </trans-unit>
        <trans-unit id="e71b2d4992fb3377f88d850b0bb44606967664d0" translate="yes" xml:space="preserve">
          <source>Not Asymptotically Equal To</source>
          <target state="translated">무증상과 같지 않음</target>
        </trans-unit>
        <trans-unit id="0e19001a3da6b3e710f2e1e08a6e032b4620604c" translate="yes" xml:space="preserve">
          <source>Not Equal To</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="f45023c8868a909904028b86e6e07605ae94f2c2" translate="yes" xml:space="preserve">
          <source>Not Equivalent To</source>
          <target state="translated">동일하지 않음</target>
        </trans-unit>
        <trans-unit id="910c9a23745ec45bdbd8919929b0387676a27c9b" translate="yes" xml:space="preserve">
          <source>Not Greater-Than / Not Greater Than</source>
          <target state="translated">크지 않음 /보다 크지 않음</target>
        </trans-unit>
        <trans-unit id="5e65900a18143b1e895a94ccc959abe15bb1ab2e" translate="yes" xml:space="preserve">
          <source>Not Identical To</source>
          <target state="translated">동일하지 않음</target>
        </trans-unit>
        <trans-unit id="e4a2159809150c92b1584b86470e09ba5081e939" translate="yes" xml:space="preserve">
          <source>Not Less-Than / Not Less Than</source>
          <target state="translated">보다 작거나 /보다 작지 않음</target>
        </trans-unit>
        <trans-unit id="0fed8df1648d0557424154c2315a039c686f4c4d" translate="yes" xml:space="preserve">
          <source>Not Normal Subgroup Of</source>
          <target state="translated">정상 하위 그룹이 아님</target>
        </trans-unit>
        <trans-unit id="645b3d2b60dd6a7e0784186eff65f0733da3c390" translate="yes" xml:space="preserve">
          <source>Not Normal Subgroup Of Or Equal To</source>
          <target state="translated">정상 하위 그룹이 아니거나 같음</target>
        </trans-unit>
        <trans-unit id="70cb8e0c40ae6f2469c6439d1eaf86fb7dd00f0f" translate="yes" xml:space="preserve">
          <source>Not Parallel To</source>
          <target state="translated">평행하지 않은</target>
        </trans-unit>
        <trans-unit id="5ab2276b84dac0a395ff693634647ac47704aca7" translate="yes" xml:space="preserve">
          <source>Not Sign</source>
          <target state="translated">서명하지 않음</target>
        </trans-unit>
        <trans-unit id="eca01d40cd859c6c6d1c5a246f8d23349bd1b255" translate="yes" xml:space="preserve">
          <source>Not Square Image Of Or Equal To</source>
          <target state="translated">정사각형 이미지가 아닌</target>
        </trans-unit>
        <trans-unit id="9c087d8ffd300334402de9a832da5d7584b88f65" translate="yes" xml:space="preserve">
          <source>Not Square Original Of Or Equal To</source>
          <target state="translated">같거나 같지 않은 원본</target>
        </trans-unit>
        <trans-unit id="87f0c2899fae2d3fccc6eaa170295b507e0f676c" translate="yes" xml:space="preserve">
          <source>Not Tilde</source>
          <target state="translated">틸드 아님</target>
        </trans-unit>
        <trans-unit id="10e43a0344ab0a9a991f8d1b272b6b2064a08d9f" translate="yes" xml:space="preserve">
          <source>Not True</source>
          <target state="translated">사실이 아니다</target>
        </trans-unit>
        <trans-unit id="7776746fa92a51dd2e030d64afc4c033677251e7" translate="yes" xml:space="preserve">
          <source>Not all integer values are valid Unicode code points, but for performance, the &lt;code&gt;Char&lt;/code&gt; conversion does not check that every character value is valid. If you want to check that each converted value is a valid code point, use the &lt;code&gt;isvalid&lt;/code&gt; function:</source>
          <target state="translated">모든 정수 값이 유효한 유니 코드 코드 포인트는 아니지만 성능을 위해 &lt;code&gt;Char&lt;/code&gt; 변환은 모든 문자 값이 유효한지 확인하지 않습니다. 변환 된 각 값이 유효한 코드 포인트인지 확인하려면 &lt;code&gt;isvalid&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="255c75003762a3b928c02073fccb1659790b5337" translate="yes" xml:space="preserve">
          <source>Not all iterator types &lt;code&gt;T&lt;/code&gt; support reverse-order iteration. If &lt;code&gt;T&lt;/code&gt; doesn't, then iterating over &lt;code&gt;Iterators.reverse(itr::T)&lt;/code&gt; will throw a &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; because of the missing &lt;a href=&quot;../collections/index#Base.iterate&quot;&gt;&lt;code&gt;iterate&lt;/code&gt;&lt;/a&gt; methods for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (To implement these methods, the original iterator &lt;code&gt;itr::T&lt;/code&gt; can be obtained from &lt;code&gt;r = Iterators.reverse(itr)&lt;/code&gt; by &lt;code&gt;r.itr&lt;/code&gt;.)</source>
          <target state="translated">모든 반복자 유형 &lt;code&gt;T&lt;/code&gt; 가 역순 반복을 지원하는 것은 아닙니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 하지 않습니다, 다음 반복하는 이상 &lt;code&gt;Iterators.reverse(itr::T)&lt;/code&gt; 던져 것 &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 을&lt;/a&gt; 하기 때문에 누락의 &lt;a href=&quot;../collections/index#Base.iterate&quot;&gt; &lt;code&gt;iterate&lt;/code&gt; &lt;/a&gt; 하는 방법 &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; . (이러한 메소드를 구현하기 위해 &lt;code&gt;r = Iterators.reverse(itr)&lt;/code&gt; 에서 &lt;code&gt;r.itr&lt;/code&gt; 으로 원래 iterator &lt;code&gt;itr::T&lt;/code&gt; 를 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="61b9146c66e430511ba5e31c64bc766e0b09ba88" translate="yes" xml:space="preserve">
          <source>Not all types support &lt;code&gt;axes&lt;/code&gt; and indexing, but many are convenient to allow in broadcast. The &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt;&lt;code&gt;Base.broadcastable&lt;/code&gt;&lt;/a&gt; function is called on each argument to broadcast, allowing it to return something different that supports &lt;code&gt;axes&lt;/code&gt; and indexing. By default, this is the identity function for all &lt;code&gt;AbstractArray&lt;/code&gt;s and &lt;code&gt;Number&lt;/code&gt;s &amp;mdash; they already support &lt;code&gt;axes&lt;/code&gt; and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, and dates), &lt;code&gt;Base.broadcastable&lt;/code&gt; returns the argument wrapped in a &lt;code&gt;Ref&lt;/code&gt; to act as a 0-dimensional &quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize &lt;code&gt;Base.broadcastable&lt;/code&gt; to define their shape, but they should follow the convention that &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt;. A notable exception is &lt;code&gt;AbstractString&lt;/code&gt;; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt; for more).</source>
          <target state="translated">모든 유형이 &lt;code&gt;axes&lt;/code&gt; 과 인덱싱을 지원 하지는 않지만 브로드 캐스트에서 허용하기에 편리한 유형이 많습니다. &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt; &lt;code&gt;Base.broadcastable&lt;/code&gt; &lt;/a&gt; 기능이 지원의 그 뭔가 다른 반환 할 수 있도록 방송을 각 인수에 호출 &lt;code&gt;axes&lt;/code&gt; 및 인덱싱을. 디폴트로, 이것은 모든 &lt;code&gt;AbstractArray&lt;/code&gt; 와 &lt;code&gt;Number&lt;/code&gt; 에 대한 항등 함수입니다 . 이미 &lt;code&gt;axes&lt;/code&gt; 과 색인을 지원 합니다. 소수의 다른 유형 (유형 자체, 함수, &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 과 같은 특수 싱글 톤 및 날짜를 포함하지만 이에 국한되지 않음 )의 경우 &lt;code&gt;Base.broadcastable&lt;/code&gt; 은 &lt;code&gt;Ref&lt;/code&gt; 에방송 목적으로 0 차원 &quot;스칼라&quot;로 작동합니다. 사용자 정의 유형은 마찬가지로 모양을 정의하기 위해 &lt;code&gt;Base.broadcastable&lt;/code&gt; 을 특수화 할 수 있지만 &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt; 규칙을 따라야합니다 . 주목할만한 예외는 &lt;code&gt;AbstractString&lt;/code&gt; 입니다 . 문자열은 반복 가능한 문자 집합이지만 브로드 캐스트 목적으로 스칼라로 작동하도록 특수한 경우입니다 (자세한 내용은 &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;문자열&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="d06aed80f156ee518eb97f78c31bd51b6209ccf7" translate="yes" xml:space="preserve">
          <source>Not all types support &lt;code&gt;axes&lt;/code&gt; and indexing, but many are convenient to allow in broadcast. The &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt;&lt;code&gt;Base.broadcastable&lt;/code&gt;&lt;/a&gt; function is called on each argument to broadcast, allowing it to return something different that supports &lt;code&gt;axes&lt;/code&gt; and indexing. By default, this is the identity function for all &lt;code&gt;AbstractArray&lt;/code&gt;s and &lt;code&gt;Number&lt;/code&gt;s &amp;mdash; they already support &lt;code&gt;axes&lt;/code&gt; and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, and dates), &lt;code&gt;Base.broadcastable&lt;/code&gt; returns the argument wrapped in a &lt;code&gt;Ref&lt;/code&gt; to act as a 0-dimensional &quot;scalar&quot; for the purposes of broadcasting. Custom types can similarly specialize &lt;code&gt;Base.broadcastable&lt;/code&gt; to define their shape, but they should follow the convention that &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt;. A notable exception is &lt;code&gt;AbstractString&lt;/code&gt;; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;Strings&lt;/a&gt; for more).</source>
          <target state="translated">모든 유형이 &lt;code&gt;axes&lt;/code&gt; 과 인덱싱을 지원하는 것은 아니지만 많은 유형 이 브로드 캐스트에서 허용하기에 편리합니다. &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcastable&quot;&gt; &lt;code&gt;Base.broadcastable&lt;/code&gt; &lt;/a&gt; 기능이 지원의 그 뭔가 다른 반환 할 수 있도록 방송을 각 인수에 호출 &lt;code&gt;axes&lt;/code&gt; 및 인덱싱을. 기본적으로 이것은 모든 &lt;code&gt;AbstractArray&lt;/code&gt; 와 &lt;code&gt;Number&lt;/code&gt; 에 대한 식별 함수입니다 . 이미 &lt;code&gt;axes&lt;/code&gt; 과 인덱싱을 지원 합니다. 소수의 다른 유형 (유형 자체, 함수, &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 과 같은 특수 싱글 톤 및 날짜를 포함하되 이에 국한되지 않음 )의 경우 &lt;code&gt;Base.broadcastable&lt;/code&gt; 은 &lt;code&gt;Ref&lt;/code&gt; 로 래핑 된 인수를 반환합니다.방송 목적으로 0 차원 &quot;스칼라&quot;로 작동합니다. 사용자 정의 유형은 모양을 정의하기 위해 &lt;code&gt;Base.broadcastable&lt;/code&gt; 을 유사하게 특수화 할 수 있지만 &lt;code&gt;collect(Base.broadcastable(x)) == collect(x)&lt;/code&gt; 규칙을 따라야합니다 . 주목할만한 예외는 &lt;code&gt;AbstractString&lt;/code&gt; 입니다 . 문자열은 반복 가능한 문자 모음이지만 브로드 캐스트 목적으로 스칼라로 동작하도록 특수한 경우가 있습니다 (자세한 내용은 &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;문자열&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="376b17f23ac9bcdac899ff816a9bc77c9e5acbff" translate="yes" xml:space="preserve">
          <source>Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like &lt;code&gt;f(k) = 5k-1&lt;/code&gt;. The machine code for this function is just this:</source>
          <target state="translated">이와 같은 기술에 의존 할 수없는 프로그래머에게는 불행한 연관성 부족이있을뿐만 아니라 정수 산술을 최적화하기 위해 컴파일러가 수행하고자하는 거의 모든 것을 물리칩니다. 예를 들어 Julia 정수는 일반 기계 정수 산술을 사용하므로 LLVM은 &lt;code&gt;f(k) = 5k-1&lt;/code&gt; 과 같은 간단한 작은 함수를 적극적으로 최적화 할 수 있습니다. 이 기능의 기계어 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31e53323374f02c10d280447ec7713899b4aba54" translate="yes" xml:space="preserve">
          <source>Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the &lt;code&gt;Regex&lt;/code&gt; object is actually created &lt;em&gt;when the code is compiled&lt;/em&gt;, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:</source>
          <target state="translated">문자열 리터럴 형식이 더 짧고 훨씬 편리 할뿐만 아니라 더 효율적입니다. 정규식이 컴파일되고 &lt;em&gt;코드가 컴파일 될 때 &lt;/em&gt; &lt;code&gt;Regex&lt;/code&gt; 객체가 실제로 만들어 지므로 매번이 아니라 컴파일이 한 번만 수행됩니다. 코드가 실행됩니다. 정규 표현식이 루프에서 발생하는지 고려하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="578b6ae41c55ac5817217df1b33fc68cc954cc58" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on DragonFly but also on other BSD-based systems. &lt;code&gt;Sys.isdragonfly()&lt;/code&gt; refers only to DragonFly.</source>
          <target state="translated">와 혼동하지 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 이며, &lt;code&gt;true&lt;/code&gt; 잠자리뿐만 아니라 다른 BSD 기반 시스템. &lt;code&gt;Sys.isdragonfly()&lt;/code&gt; 는 DragonFly 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d42de750af9292296d2996dbdfe296c15be6dc0d" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on FreeBSD but also on other BSD-based systems. &lt;code&gt;Sys.isfreebsd()&lt;/code&gt; refers only to FreeBSD.</source>
          <target state="translated">와 혼동하지 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 이며, &lt;code&gt;true&lt;/code&gt; FreeBSD의에뿐만 아니라 다른 BSD 기반 시스템. &lt;code&gt;Sys.isfreebsd()&lt;/code&gt; 는 FreeBSD 만 참조합니다.</target>
        </trans-unit>
        <trans-unit id="bd7b8351c728f277ea375c49956a749253ca4ccd" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on NetBSD but also on other BSD-based systems. &lt;code&gt;Sys.isnetbsd()&lt;/code&gt; refers only to NetBSD.</source>
          <target state="translated">와 혼동하지 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 이며, &lt;code&gt;true&lt;/code&gt; NetBSD의에서뿐만 아니라 다른 BSD 기반 시스템. &lt;code&gt;Sys.isnetbsd()&lt;/code&gt; 는 NetBSD 만 참조합니다.</target>
        </trans-unit>
        <trans-unit id="02e040fc63d08da8130023e8bf1da51746be0eb3" translate="yes" xml:space="preserve">
          <source>Not to be confused with &lt;code&gt;Sys.isbsd()&lt;/code&gt;, which is &lt;code&gt;true&lt;/code&gt; on OpenBSD but also on other BSD-based systems. &lt;code&gt;Sys.isopenbsd()&lt;/code&gt; refers only to OpenBSD.</source>
          <target state="translated">와 혼동하지 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 이며, &lt;code&gt;true&lt;/code&gt; 오픈 BSD에뿐만 아니라 다른 BSD 기반 시스템. &lt;code&gt;Sys.isopenbsd()&lt;/code&gt; 는 OpenBSD 만 참조합니다.</target>
        </trans-unit>
        <trans-unit id="054fdc1887c4bd534bac1d0a3aea062860f9859e" translate="yes" xml:space="preserve">
          <source>Not-equals comparison operator. Always gives the opposite answer as &lt;a href=&quot;#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">같지 않은 비교 연산자 항상 반대 대답을 &lt;a href=&quot;#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; 로 지정하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09a3a6aa1ade2cda6a7d225bac58c2f12db2701f" translate="yes" xml:space="preserve">
          <source>Notably missing from this table are &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;begin blocks&lt;/a&gt; and &lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;if blocks&lt;/a&gt; which do &lt;em&gt;not&lt;/em&gt; introduce new scopes. The three types of scopes follow somewhat different rules which will be explained below.</source>
          <target state="translated">이 테이블에서 특히 누락 된 것은 &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;시작 블록&lt;/a&gt; 과 새 범위를 도입 하지 &lt;em&gt;않는 &lt;/em&gt;&lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;if 블록&lt;/a&gt; 입니다 . 세 가지 유형의 범위는 아래에서 설명 할 약간 다른 규칙을 따릅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a97115f7efbdab23d7b34d2c40462b51cbb049d" translate="yes" xml:space="preserve">
          <source>Notably missing from this table are &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;begin blocks&lt;/a&gt; and &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;if blocks&lt;/a&gt; which do &lt;em&gt;not&lt;/em&gt; introduce new scopes. Both types of scopes follow somewhat different rules which will be explained below.</source>
          <target state="translated">이 테이블에서 특히 누락 된 것은 &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;시작 블록&lt;/a&gt; 과 새로운 범위를 도입 하지 &lt;em&gt;않는 &lt;/em&gt;&lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;if 블록&lt;/a&gt; 입니다 . 두 가지 유형의 범위는 아래에서 설명 할 다소 다른 규칙을 따릅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="975b275a254bd77182b630947c7d8ebcab739d76" translate="yes" xml:space="preserve">
          <source>Note also that container types, specifically may need type parameters in function calls. See the FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers&quot;&gt;Avoid fields with abstract containers&lt;/a&gt; for more information.</source>
          <target state="translated">컨테이너 유형, 특히 함수 호출에서 유형 매개 변수가 필요할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers&quot;&gt;추상 컨테이너가&lt;/a&gt; 있는 FAQ 회피 필드 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="849d9173bfaa5bb4ab294b9df21a5967dcab8225" translate="yes" xml:space="preserve">
          <source>Note also that container types, specifically may need type parameters in function calls. See the FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers-1&quot;&gt;Avoid fields with abstract containers&lt;/a&gt; for more information.</source>
          <target state="translated">또한 컨테이너 유형, 특히 함수 호출에 유형 매개 변수가 필요할 수 있습니다. 자세한 내용은 FAQ &lt;a href=&quot;../performance-tips/index#Avoid-fields-with-abstract-containers-1&quot;&gt;추상 컨테이너가있는 필드 피하기 필드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a53f93a486d8d7a57250d379f8edb9cd25043f3" translate="yes" xml:space="preserve">
          <source>Note how each even iteration is significantly faster.</source>
          <target state="translated">각 짝수 반복이 어떻게 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="00b5f982274ede3eb024b1d3b08e8e7c8741dfd9" translate="yes" xml:space="preserve">
          <source>Note how the size of the resulting array is different in the last two cases.</source>
          <target state="translated">마지막 두 경우에서 결과 배열의 크기가 어떻게 다른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d976f8413bff8e1f0c6cdf63fd9bf71518cc2d9f" translate="yes" xml:space="preserve">
          <source>Note on Optional and keyword Arguments</source>
          <target state="translated">선택적 및 키워드 인수에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="1c7695f5595e993b4198f30c43fab04e9442751c" translate="yes" xml:space="preserve">
          <source>Note on Windows since there is a current directory for each drive, &lt;code&gt;joinpath(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; represents a path relative to the current directory on drive &quot;c:&quot; so this is equal to &quot;c:foo&quot;, not &quot;c:\foo&quot;. Furthermore, &lt;code&gt;joinpath&lt;/code&gt; treats this as a non-absolute path and ignores the drive letter casing, hence &lt;code&gt;joinpath(&quot;C:\A&quot;,&quot;c:b&quot;) = &quot;C:\A\b&quot;&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 각 드라이브에 대한 현재 디렉토리가 있으므로 &lt;code&gt;joinpath(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; 는 &quot;c :&quot;드라이브의 현재 디렉토리에 상대적인 경로를 나타내므로 &quot;c : foo&quot;와 같습니다. &quot;c : \ foo&quot;. 또한 &lt;code&gt;joinpath&lt;/code&gt; 는이를 절대 경로가 아닌 경로로 취급하고 드라이브 문자 대 / 소문자를 무시하므로 &lt;code&gt;joinpath(&quot;C:\A&quot;,&quot;c:b&quot;) = &quot;C:\A\b&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c28ded9fb86e90fa4e9b6fc5221352277f1f430d" translate="yes" xml:space="preserve">
          <source>Note that &quot;constant-ness&quot; does not extend into mutable containers; only the association between a variable and its value is constant. If &lt;code&gt;x&lt;/code&gt; is an array or dictionary (for example) you can still modify, add, or remove elements.</source>
          <target state="translated">&quot;constant-ness&quot;는 변경 가능한 컨테이너로 확장되지 않습니다. 변수와 그 값 사이의 연관성 만 일정합니다. &lt;code&gt;x&lt;/code&gt; 가 배열 또는 사전 (예 :) 인 경우 에도 요소를 수정, 추가 또는 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f33b173ac7918930bdfbf48b338b9676798c0c7" translate="yes" xml:space="preserve">
          <source>Note that 12:00AM corresponds 00:00 (midnight), and 12:00PM corresponds to 12:00 (noon). When parsing a time with a &lt;code&gt;p&lt;/code&gt; specifier, any hour (either &lt;code&gt;H&lt;/code&gt; or &lt;code&gt;I&lt;/code&gt;) is interpreted as as a 12-hour clock, so the &lt;code&gt;I&lt;/code&gt; code is mainly useful for output.</source>
          <target state="translated">12:00 AM은 00:00 (자정)에 해당하고 12:00 PM은 12:00 (정오)에 해당합니다. &lt;code&gt;p&lt;/code&gt; 지정자를 사용 하여 시간을 구문 분석 할 때 모든 시간 ( &lt;code&gt;H&lt;/code&gt; 또는 &lt;code&gt;I&lt;/code&gt; )은 12 시간 시계로 해석되므로 &lt;code&gt;I&lt;/code&gt; 코드는 주로 출력에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="696a1593f42fbf6fdb11b6e9d243436195a50762" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; without parentheses is not an exception, but a type of exception. It needs to be called to obtain an &lt;code&gt;Exception&lt;/code&gt; object:</source>
          <target state="translated">참고 &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; 괄호없이 예외지만, 예외의 유형이 아닙니다. &lt;code&gt;Exception&lt;/code&gt; 객체 를 얻으려면 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b8007f62d26730fb9d23ad56c13276aa54218371" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returns 11, the number of bytes (in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;) written to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, but this return value is suppressed with the &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 반환 (11), (의 바이트 수 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 에 기록) &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 하지만,이 반환 값은 억제되고 &lt;code&gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37adaed47b6bd184e2c19006696ca9a54db365b6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; does not have an optional reduction parameter like &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt; 처럼 선택적 감소 매개 변수가없는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt; &lt;code&gt;@distributed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56fd4dacad4e16bdd1b5c6c8643757fc415a3a05" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt; and friends will always show you specialized code, even if Julia would not normally specialize that method call. You need to check the &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#ast-lowered-method&quot;&gt;method internals&lt;/a&gt; if you want to see whether specializations are generated when argument types are changed, i.e., if &lt;code&gt;(@which f(...)).specializations&lt;/code&gt; contains specializations for the argument in question.</source>
          <target state="translated">참고 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt; 과 친구들은 항상 당신 줄리아는 일반적으로 그 메소드 호출을 전문으로하지 않을 경우에도 코드를 전문으로 표시됩니다. 인수 유형이 변경 될 때 특수화가 생성되는지 확인하려면 &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#ast-lowered-method&quot;&gt;메서드 내부&lt;/a&gt; 를 확인해야합니다 . 즉, &lt;code&gt;(@which f(...)).specializations&lt;/code&gt; specializations에 해당 인수에 대한 특수화 가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeada1a815471b81eb3fba82f7ffa1d182b6efc4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;3/4im == 3/(4*im) == -(3/4*im)&lt;/code&gt;, since a literal coefficient binds more tightly than division.</source>
          <target state="translated">참고 &lt;code&gt;3/4im == 3/(4*im) == -(3/4*im)&lt;/code&gt; ,보다 더 밀접 분할 리터럴 계수 보낸 바인딩.</target>
        </trans-unit>
        <trans-unit id="a28e4307aa56a3047fa10fe081f2a2b0189f815e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@fastmath&lt;/code&gt; also assumes that &lt;code&gt;NaN&lt;/code&gt;s will not occur during the computation, which can lead to surprising behavior:</source>
          <target state="translated">참고 &lt;code&gt;@fastmath&lt;/code&gt; 는 또한 가정 &lt;code&gt;NaN&lt;/code&gt; 이 의 놀라운 행동으로 이어질 수 계산, 동안 발생하지 않을 것이다 :</target>
        </trans-unit>
        <trans-unit id="44f37755c76cb167a60db94665d8037a8b6d4b88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Hupper&lt;/code&gt; will not be equal to &lt;code&gt;Hlower&lt;/code&gt; unless &lt;code&gt;A&lt;/code&gt; is itself Hermitian (e.g. if &lt;code&gt;A == adjoint(A)&lt;/code&gt;).</source>
          <target state="translated">참고 &lt;code&gt;Hupper&lt;/code&gt; 가 동일하지 않을 것이다 &lt;code&gt;Hlower&lt;/code&gt; 않는 &lt;code&gt;A&lt;/code&gt; 는 자체가 에르 미트 (예, 경우 &lt;code&gt;A == adjoint(A)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e856098b5c682029aff8a00fd63966146351870" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Supper&lt;/code&gt; will not be equal to &lt;code&gt;Slower&lt;/code&gt; unless &lt;code&gt;A&lt;/code&gt; is itself symmetric (e.g. if &lt;code&gt;A == transpose(A)&lt;/code&gt;).</source>
          <target state="translated">주의 &lt;code&gt;Supper&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;Slower&lt;/code&gt; 하지 않는 &lt;code&gt;A&lt;/code&gt; 가 자체 대칭 (예를 들어, 경우 &lt;code&gt;A == transpose(A)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5d20eb7b7b4658ec16f617a8d465aa8cefd27a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;a&lt;/code&gt; is written to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; by the &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; function and that the returned value is &lt;code&gt;1&lt;/code&gt; (since &lt;code&gt;0x61&lt;/code&gt; is one byte).</source>
          <target state="translated">참고 &lt;code&gt;a&lt;/code&gt; 기록되는 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 에 의해 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 기능 및 리턴 값인지 &lt;code&gt;1&lt;/code&gt; (이후 &lt;code&gt;0x61&lt;/code&gt; 1 바이트).</target>
        </trans-unit>
        <trans-unit id="49ba0090143db57a2046b4bea0136a386cb43ff2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;const&lt;/code&gt; only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified. Additionally when one tries to assign a value to a variable that is declared constant the following scenarios are possible:</source>
          <target state="translated">참고 &lt;code&gt;const&lt;/code&gt; 단지 바인딩 변수에 영향을 미친다; 변수는 가변 객체 (예 : 배열)에 바인딩 될 수 있으며 해당 객체는 여전히 수정 될 수 있습니다. 또한 상수로 선언 된 변수에 값을 할당하려고하면 다음 시나리오가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a71dd5c1dc13bb0d3426a39b5d80f1ab214d1505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;const&lt;/code&gt; only applies to one &lt;code&gt;=&lt;/code&gt; operation, therefore &lt;code&gt;const x = y = 1&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be constant but not &lt;code&gt;y&lt;/code&gt;. On the other hand, &lt;code&gt;const x = const y = 1&lt;/code&gt; declares both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; constant.</source>
          <target state="translated">참고 &lt;code&gt;const&lt;/code&gt; 하나만 적용 &lt;code&gt;=&lt;/code&gt; 조작 따라서 &lt;code&gt;const x = y = 1&lt;/code&gt; 선언 &lt;code&gt;x&lt;/code&gt; 는 정수가 아닌 수 &lt;code&gt;y&lt;/code&gt; . 반면에 &lt;code&gt;const x = const y = 1&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 상수를 모두 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="42b7bae28c5c9b6bf89128b216efa649678ec047" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; must be made available to all worker processes; see &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;Code Availability and Loading Packages&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;f&lt;/code&gt; 는 모든 작업자 프로세스에 사용할 수 있어야; 자세한 내용은 &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;코드 가용성 및 패키지로드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2da2dbc9c6e30c7173aed1390cec1b44955d9a0a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; must be made available to all worker processes; see &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;Code Availability and Loading Packages&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;f&lt;/code&gt; 는 모든 작업자 프로세스에 사용할 수 있어야; 자세한 내용은 &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;코드 가용성 및 패키지로드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92d4b4f20914a2f80297acf7d51d2f544ab0b677" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;islinux&lt;/code&gt;, &lt;code&gt;isapple&lt;/code&gt;, and &lt;code&gt;isfreebsd&lt;/code&gt; are mutually exclusive subsets of &lt;code&gt;isunix&lt;/code&gt;. Additionally, there is a macro &lt;code&gt;@static&lt;/code&gt; which makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples.</source>
          <target state="translated">참고 &lt;code&gt;islinux&lt;/code&gt; , &lt;code&gt;isapple&lt;/code&gt; 을 하고 &lt;code&gt;isfreebsd&lt;/code&gt; 는 상호 배타적 집합입니다 &lt;code&gt;isunix&lt;/code&gt; . 또한 다음 예제에서 설명하는 것처럼 이러한 함수를 사용하여 유효하지 않은 코드를 조건부로 숨길 수 있는 매크로 &lt;code&gt;@static&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecce05e977eeb562c214d3763cad6d310a27574a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;objectid&lt;/code&gt; (which works by hashing the memory pointer) has similar issues (see notes on &lt;code&gt;Dict&lt;/code&gt; usage below).</source>
          <target state="translated">메모리 포인터를 해싱하여 작동 하는 &lt;code&gt;objectid&lt;/code&gt; 에도 비슷한 문제가 있습니다 ( 아래의 &lt;code&gt;Dict&lt;/code&gt; 사용법 에 대한 참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="dec4ef0812f3a86c7546a41bb6d9a828672c6b6b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;repr(x)&lt;/code&gt; is usually similar to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia. See also &lt;a href=&quot;#Base.repr-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt;&lt;/a&gt; to instead return a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed more for human consumption, equivalent to the REPL display of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">참고 있음 &lt;code&gt;repr(x)&lt;/code&gt; 값 방법 일반적으로 유사하다 &lt;code&gt;x&lt;/code&gt; 줄리아에 입력된다. 참조 &lt;a href=&quot;#Base.repr-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt; &lt;/a&gt; 대신 &quot;꽤 인쇄&quot;버전 반환 &lt;code&gt;x&lt;/code&gt; 의 REPL 표시하는 것과 더 인간의 소비를 위해 설계, &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ebaffc5da22f58b7b0da356367cc874b632fc4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;repr(x)&lt;/code&gt; is usually similar to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia. See also &lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt; to instead return a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed more for human consumption, equivalent to the REPL display of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">참고 있음 &lt;code&gt;repr(x)&lt;/code&gt; 값 방법 일반적으로 유사하다 &lt;code&gt;x&lt;/code&gt; 줄리아에 입력된다. 참조 &lt;code&gt;repr(MIME(&quot;text/plain&quot;), x)&lt;/code&gt; 대신 &quot;꽤 인쇄&quot;버전 반환 &lt;code&gt;x&lt;/code&gt; 의 REPL 표시하는 것과 더 인간의 소비를 위해 설계, &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c63c24c562ebbeffd401b993abf9ea07344548e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; may not be defined for arrays with non-standard indices, in which case &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;axes&lt;/code&gt;&lt;/a&gt; may be useful. See the manual chapter on &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;size&lt;/code&gt; 케이스되는 비표준 인덱스와 배열에 대해 정의 될 수도 &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;axes&lt;/code&gt; &lt;/a&gt; 유용 할 수있다. &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;사용자 정의 인덱스가있는 배열&lt;/a&gt; 에 대해서는 매뉴얼 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7559405697142cf45c00dae1c325e170d476ba8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; may not be defined for arrays with non-standard indices, in which case &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;axes&lt;/code&gt;&lt;/a&gt; may be useful. See the manual chapter on &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;size&lt;/code&gt; 케이스되는 비표준 인덱스와 배열에 대해 정의 될 수도 &lt;a href=&quot;#Base.axes-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;axes&lt;/code&gt; &lt;/a&gt; 유용 할 수있다. &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;사용자 지정 인덱스가있는 배열&lt;/a&gt; 에 대한 설명서 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb1ecefd80819ec38c7d5d7a2809bfae7568534" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;x &amp;asymp; 0&lt;/code&gt; (i.e., comparing to zero with the default tolerances) is equivalent to &lt;code&gt;x == 0&lt;/code&gt; since the default &lt;code&gt;atol&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. In such cases, you should either supply an appropriate &lt;code&gt;atol&lt;/code&gt; (or use &lt;code&gt;norm(x) &amp;le; atol&lt;/code&gt;) or rearrange your code (e.g. use &lt;code&gt;x &amp;asymp; y&lt;/code&gt; rather than &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt;). It is not possible to pick a nonzero &lt;code&gt;atol&lt;/code&gt; automatically because it depends on the overall scaling (the &quot;units&quot;) of your problem: for example, in &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt;, &lt;code&gt;atol=1e-9&lt;/code&gt; is an absurdly small tolerance if &lt;code&gt;x&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Earth_radius&quot;&gt;radius of the Earth&lt;/a&gt; in meters, but an absurdly large tolerance if &lt;code&gt;x&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bohr_radius&quot;&gt;radius of a Hydrogen atom&lt;/a&gt; in meters.</source>
          <target state="translated">참고 &lt;code&gt;x &amp;asymp; 0&lt;/code&gt; (즉, 기본 공차 제로로 비교하는)에 해당 &lt;code&gt;x == 0&lt;/code&gt; 기본부터 &lt;code&gt;atol&lt;/code&gt; 이다 &lt;code&gt;0&lt;/code&gt; . 이러한 경우 적절한 &lt;code&gt;atol&lt;/code&gt; 을 제공 하거나 &lt;code&gt;norm(x) &amp;le; atol&lt;/code&gt; 사용하거나 코드를 다시 정렬해야합니다 (예 : &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt; 대신 &lt;code&gt;x &amp;asymp; y&lt;/code&gt; 사용 ). 0이 아닌 &lt;code&gt;atol&lt;/code&gt; 은 문제의 전체 스케일링 ( &quot;단위&quot;)에 따라 자동으로 선택할 수 없습니다 . 예를 들어 &lt;code&gt;x - y &amp;asymp; 0&lt;/code&gt; 에서 &lt;code&gt;atol=1e-9&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Earth_radius&quot;&gt;지구의 반경&lt;/a&gt;미터이지만 경우 불합리하게 큰 공차 &lt;code&gt;x&lt;/code&gt; 은 IS &lt;a href=&quot;https://en.wikipedia.org/wiki/Bohr_radius&quot;&gt;수소 원자 반경&lt;/a&gt; 미터는.</target>
        </trans-unit>
        <trans-unit id="24da7a9bc07548c8c342e439381af79ca72b7da1" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;nested functions&lt;/em&gt; can modify their parent scope's &lt;em&gt;local&lt;/em&gt; variables:</source>
          <target state="translated">참고 &lt;em&gt;중첩 된 함수는&lt;/em&gt; 상위 범위의 수정할 수있는 &lt;em&gt;지역&lt;/em&gt; 변수를 :</target>
        </trans-unit>
        <trans-unit id="2f99f6df1c98d4f166f129e241845886a06353ad" translate="yes" xml:space="preserve">
          <source>Note that Julia does not convert the endianness for you. Use &lt;a href=&quot;#Base.ntoh&quot;&gt;&lt;code&gt;ntoh&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.ltoh&quot;&gt;&lt;code&gt;ltoh&lt;/code&gt;&lt;/a&gt; for this purpose.</source>
          <target state="translated">Julia는 사용자를 위해 엔디안을 변환하지 않습니다. &lt;a href=&quot;#Base.ltoh&quot;&gt; &lt;code&gt;ltoh&lt;/code&gt; &lt;/a&gt; 위해 &lt;a href=&quot;#Base.ntoh&quot;&gt; &lt;code&gt;ntoh&lt;/code&gt; &lt;/a&gt; 또는 ltoh 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ff66b89cf231ebebae6ac564e03e80821f0734a" translate="yes" xml:space="preserve">
          <source>Note that a single space must appear after the &lt;code&gt;&amp;gt;&lt;/code&gt; character on each line. Quoted blocks may themselves contain other toplevel or inline elements.</source>
          <target state="translated">각 줄 에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자 다음에 단일 공백이 나타나야합니다 . 인용 블록 자체에는 다른 최상위 또는 인라인 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df038700fc9ed1f2d0e5d9e1529bee38f9f6f0ec" translate="yes" xml:space="preserve">
          <source>Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.</source>
          <target state="translated">병렬 for 루프는 직렬 for 루프처럼 보이지만 동작은 크게 다릅니다. 특히 반복은 지정된 순서로 발생하지 않으며 반복이 다른 프로세스에서 실행되므로 변수 또는 배열에 대한 쓰기는 전체적으로 표시되지 않습니다. 병렬 루프 내에서 사용 된 모든 변수는 각 프로세스로 복사 및 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="94aa43e85ddde561947d2c3630080b0641c93455" translate="yes" xml:space="preserve">
          <source>Note that although sometimes possible, changing the value of a &lt;code&gt;const&lt;/code&gt; variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed then it might keep using the old value:</source>
          <target state="translated">때때로 가능하지만 &lt;code&gt;const&lt;/code&gt; 변수 의 값을 변경하는 것은 권장하지 않으며 대화식 사용 중 편의를 위해서만 사용됩니다. 상수를 변경하면 다양한 문제 나 예기치 않은 동작이 발생할 수 있습니다. 예를 들어, 메소드가 상수를 참조하고 상수가 변경되기 전에 이미 컴파일 된 경우 이전 값을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05b0f9e216e60cb065800bf991562a8ecf76051" translate="yes" xml:space="preserve">
          <source>Note that although sometimes possible, changing the value of a &lt;code&gt;const&lt;/code&gt; variable is strongly discouraged, and is intended only for convenience during interactive use. Changing constants can cause various problems or unexpected behaviors. For instance, if a method references a constant and is already compiled before the constant is changed, then it might keep using the old value:</source>
          <target state="translated">때때로 가능하지만 &lt;code&gt;const&lt;/code&gt; 변수 의 값을 변경하는 것은 권장되지 않으며 대화 형 사용 중 편의를위한 것입니다. 상수를 변경하면 다양한 문제 나 예기치 않은 동작이 발생할 수 있습니다. 예를 들어 메서드가 상수를 참조하고 상수가 변경되기 전에 이미 컴파일 된 경우 이전 값을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f3d67b5d3f7f10d1a904a545691da68ecdd58fc" translate="yes" xml:space="preserve">
          <source>Note that although you should have a &lt;code&gt;~/.julia&lt;/code&gt; directory once you've run Julia for the first time, you may need to create the &lt;code&gt;~/.julia/config&lt;/code&gt; folder and the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file if you use it.</source>
          <target state="translated">Julia를 처음 실행하면 &lt;code&gt;~/.julia&lt;/code&gt; 디렉토리 가 있어야하지만 다음과 같은 경우 &lt;code&gt;~/.julia/config&lt;/code&gt; 폴더와 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 파일 을 만들어야 할 수도 있습니다. 당신은 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ba3d59a18530117c201d12384305dcff7641d465" translate="yes" xml:space="preserve">
          <source>Note that an error will be thrown if &lt;code&gt;types&lt;/code&gt; are not leaf types when &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and any of the corresponding methods are an &lt;code&gt;@generated&lt;/code&gt; method.</source>
          <target state="translated">만약 에러가 발생된다는 것을 유의 &lt;code&gt;types&lt;/code&gt; 때 리프 타입 아니다 &lt;code&gt;generated&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 과 대응하는 임의의 방법이있다 &lt;code&gt;@generated&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="de63020091c1737ae855533fa49f1548ba9bc637" translate="yes" xml:space="preserve">
          <source>Note that comparisons such as &lt;code&gt;==&lt;/code&gt; operate on whole arrays, giving a single boolean answer. Use dot operators like &lt;code&gt;.==&lt;/code&gt; for elementwise comparisons. (For comparison operations like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;em&gt;only&lt;/em&gt; the elementwise &lt;code&gt;.&amp;lt;&lt;/code&gt; version is applicable to arrays.)</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 와 같은 비교 는 전체 배열에서 작동하여 단일 부울 답변을 제공합니다. 요소 별 비교에는. &lt;code&gt;.==&lt;/code&gt; 와 같은 도트 연산자를 사용하십시오 . (같은 비교 연산을 위해 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;em&gt;단지&lt;/em&gt; elementwise은 &lt;code&gt;.&amp;lt;&lt;/code&gt; 버전은 배열에 적용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7284837c88b7791c6b3428c825f7f45c66f72e65" translate="yes" xml:space="preserve">
          <source>Note that currently Julia tasks are not scheduled to run on separate CPU cores. True kernel threads are discussed under the topic of &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt;.</source>
          <target state="translated">현재 Julia 작업은 별도의 CPU 코어에서 실행되도록 예약되어 있지 않습니다. 실제 커널 스레드는 &lt;a href=&quot;../parallel-computing/index#Parallel-Computing-1&quot;&gt;Parallel Computing&lt;/a&gt; 주제에서 논의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3beb748b948689adb5a3e8b4c3e812101bb26004" translate="yes" xml:space="preserve">
          <source>Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.</source>
          <target state="translated">터미널 설정에 따라 TTY가 라인 버퍼링 될 수 있으므로 데이터를 Julia로 보내기 전에 추가 입력이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="349e4d1b361394f80e838bc17f47bce14935730e" translate="yes" xml:space="preserve">
          <source>Note that environments requiring higher levels of security can implement this via a custom &lt;code&gt;ClusterManager&lt;/code&gt;. For example, cookies can be pre-shared and hence not specified as a startup argument.</source>
          <target state="translated">보다 높은 수준의 보안이 필요한 환경은 사용자 정의 &lt;code&gt;ClusterManager&lt;/code&gt; 를 통해이를 구현할 수 있습니다 . 예를 들어, 쿠키는 미리 공유 될 수 있으므로 시작 인수로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcb9bdb3f2e4e941bd30620b1ce6b0954c3e0db3" translate="yes" xml:space="preserve">
          <source>Note that equivalent expressions may be constructed using &lt;code&gt;Meta.parse&lt;/code&gt; or the direct &lt;code&gt;Expr&lt;/code&gt; form:</source>
          <target state="translated">&lt;code&gt;Meta.parse&lt;/code&gt; 또는 직접 &lt;code&gt;Expr&lt;/code&gt; 양식을 사용하여 동등한 표현식을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d754196211a26fe919af9c527a7cbca9ed7d86d3" translate="yes" xml:space="preserve">
          <source>Note that events may be coalesced, so multiple calls to &lt;code&gt;uv_async_send&lt;/code&gt; may result in a single wakeup notification to the condition.</source>
          <target state="translated">이벤트가 병합 될 수 있으므로 &lt;code&gt;uv_async_send&lt;/code&gt; 를 여러 번 호출 하면 조건에 대한 단일 웨이크 업 알림이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4849ca2aa20715f560db64abeae419c21262c08" translate="yes" xml:space="preserve">
          <source>Note that for this code to work correctly, &lt;code&gt;result_array&lt;/code&gt; must be declared to be of type &lt;code&gt;Ref{Cdouble}&lt;/code&gt; and not &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;. The memory is managed by Julia and the &lt;code&gt;Ref&lt;/code&gt; signature alerts Julia's garbage collector to keep managing the memory for &lt;code&gt;result_array&lt;/code&gt; while the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; executes. If &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; were used instead, the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; may still work, but Julia's garbage collector would not be aware that the memory declared for &lt;code&gt;result_array&lt;/code&gt; is being used by the external C function. As a result, the code may produce a memory leak if &lt;code&gt;result_array&lt;/code&gt; never gets freed by the garbage collector, or if the garbage collector prematurely frees &lt;code&gt;result_array&lt;/code&gt;, the C function may end up throwing an invalid memory access exception.</source>
          <target state="translated">이 코드가 올바르게 작동 하려면 &lt;code&gt;result_array&lt;/code&gt; 가 &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; 아닌 &lt;code&gt;Ref{Cdouble}&lt;/code&gt; 유형으로 선언되어야합니다 . 메모리는 Julia에 의해 관리되며 &lt;code&gt;Ref&lt;/code&gt; 서명은 Julia의 가비지 수집기에게 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 이&lt;/a&gt; 실행 되는 동안 &lt;code&gt;result_array&lt;/code&gt; 에 대한 메모리 관리를 계속하도록 경고합니다 . 경우 &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; 대신에 사용 하였다는 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 는&lt;/a&gt; 여전히 작동 할 수 있지만 줄리아의 가비지 컬렉터를위한 메모리가 선언 된 것을 인식하지 못할 것 &lt;code&gt;result_array&lt;/code&gt; 가 외부 C 함수를 사용하고 있습니다. 결과적으로 코드에서 메모리 누수가 발생할 수 있습니다. &lt;code&gt;result_array&lt;/code&gt; 인 발생할 수 있습니다.가비지 수집기에 의해 해제되지 않거나 가비지 수집기가 &lt;code&gt;result_array&lt;/code&gt; 를 조기에 해제하면 C 함수가 잘못된 메모리 액세스 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33dfe8b7bf03d2d566e94e83790270ed34bc079e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;on_error&lt;/code&gt; and &lt;code&gt;retry_delays&lt;/code&gt; are specified, the &lt;code&gt;on_error&lt;/code&gt; hook is called before retrying. If &lt;code&gt;on_error&lt;/code&gt; does not throw (or rethrow) an exception, the element will not be retried.</source>
          <target state="translated">두 경우주의 &lt;code&gt;on_error&lt;/code&gt; 및 &lt;code&gt;retry_delays&lt;/code&gt; 가 지정의 &lt;code&gt;on_error&lt;/code&gt; 후크 재 시도하기 전에 호출된다. 경우 &lt;code&gt;on_error&lt;/code&gt; 가 예외를 throw (또는 다시 발생)하지 않는 요소가 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8626fd0453edd656ad43ae0bf974587f0b161aee" translate="yes" xml:space="preserve">
          <source>Note that if two or more &lt;code&gt;AbstractArrayStyle&lt;/code&gt; subtypes conflict, broadcasting machinery will fall back to producing &lt;code&gt;Array&lt;/code&gt;s. If this is undesirable, you may need to define binary &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; rules to control the output type.</source>
          <target state="translated">둘 이상의 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 하위 유형이 충돌하면 브로드 캐스팅 기계는 &lt;code&gt;Array&lt;/code&gt; 를 생성 합니다. 이것이 바람직하지 않은 경우 출력 유형을 제어하기 위해 이진 &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; 규칙을 정의해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee4a4bbb303899c3b42bdc6b997f22ea80f22b9e" translate="yes" xml:space="preserve">
          <source>Note that in the above example the non-standard version number &lt;code&gt;v&quot;0.3-&quot;&lt;/code&gt; is used, with a trailing &lt;code&gt;-&lt;/code&gt;: this notation is a Julia extension of the standard, and it's used to indicate a version which is lower than any &lt;code&gt;0.3&lt;/code&gt; release, including all of its pre-releases. So in the above example the code would only run with stable &lt;code&gt;0.2&lt;/code&gt; versions, and exclude such versions as &lt;code&gt;v&quot;0.3.0-rc1&quot;&lt;/code&gt;. In order to also allow for unstable (i.e. pre-release) &lt;code&gt;0.2&lt;/code&gt; versions, the lower bound check should be modified like this: &lt;code&gt;v&quot;0.2-&quot; &amp;lt;= VERSION&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 비표준 버전 번호가 있습니다 &lt;code&gt;v&quot;0.3-&quot;&lt;/code&gt; 뒤에 함께 사용 &lt;code&gt;-&lt;/code&gt; 이 표기법은 표준의 줄리아 확장이며, 어떤보다 낮은 버전을 나타 내기 위해 사용되는 &lt;code&gt;0.3&lt;/code&gt; 버전을, 모든 시험판을 포함합니다. 위의 예에서 코드는 안정적인 &lt;code&gt;0.2&lt;/code&gt; 버전 에서만 실행 되며 &lt;code&gt;v&quot;0.3.0-rc1&quot;&lt;/code&gt; 과 같은 버전은 제외 합니다. 불안정한 (즉, 시험판 전) &lt;code&gt;0.2&lt;/code&gt; 버전 도 허용 하려면 하한 검사를 다음과 같이 수정해야합니다. &lt;code&gt;v&quot;0.2-&quot; &amp;lt;= VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be55fa4cd393d6af048c6d169ea98f1e7964ae3" translate="yes" xml:space="preserve">
          <source>Note that in this form, the variables are listed outermost-first. This matches the order in which variables are substituted when a type is &quot;applied&quot; to parameter values using the syntax &lt;code&gt;T{p1, p2, ...}&lt;/code&gt;.</source>
          <target state="translated">이 형식에서 변수는 가장 먼저 나열됩니다. 이는 구문 &lt;code&gt;T{p1, p2, ...}&lt;/code&gt; 사용하여 유형을 매개 변수 값에 &quot;적용&quot;할 때 변수가 대체되는 순서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="498b2a62007ef2fa8b25a9e52137f4198851e2fb" translate="yes" xml:space="preserve">
          <source>Note that it's very important to specify the two parameters of the &lt;code&gt;AbstractArray&lt;/code&gt;; the first defines the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;, and the second defines the &lt;a href=&quot;../../base/arrays/index#Base.ndims&quot;&gt;&lt;code&gt;ndims&lt;/code&gt;&lt;/a&gt;. That supertype and those three methods are all it takes for &lt;code&gt;SquaresVector&lt;/code&gt; to be an iterable, indexable, and completely functional array:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 의 두 매개 변수를 지정하는 것이 매우 중요합니다 . 첫 번째는 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; 을&lt;/a&gt; 정의하고 두 번째는 &lt;a href=&quot;../../base/arrays/index#Base.ndims&quot;&gt; &lt;code&gt;ndims&lt;/code&gt; &lt;/a&gt; 정의합니다 . 이 수퍼 타입과 그 세 가지 방법 &lt;code&gt;SquaresVector&lt;/code&gt; 가 반복 가능하고 색인을 생성하며 완벽하게 기능하는 배열이 되기만 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="431d8af921ae8dd91eb1906a8ae4ef18ccab5ae1" translate="yes" xml:space="preserve">
          <source>Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character &lt;code&gt;\n&lt;/code&gt; in the string, even if your editor uses a carriage return &lt;code&gt;\r&lt;/code&gt; (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape &lt;code&gt;\r&lt;/code&gt;; for example, you can enter the literal string &lt;code&gt;&quot;a CRLF line ending\r\n&quot;&lt;/code&gt;.</source>
          <target state="translated">작은 따옴표 나 삼중 따옴표에 상관없이 리터럴 문자열의 줄 바꿈은 편집기에서 캐리지 리턴 &lt;code&gt;\r&lt;/code&gt; (CR) 또는 CRLF 조합을 사용하여 줄을 바꾸 더라도 문자열에 줄 바꿈 (LF) 문자 &lt;code&gt;\n&lt;/code&gt; 을 초래 합니다. 문자열에 CR을 포함 시키려면 명시적인 이스케이프를 사용하십시오 . &lt;code&gt;\r&lt;/code&gt; ; 예를 들어 리터럴 문자열 &lt;code&gt;&quot;a CRLF line ending\r\n&quot;&lt;/code&gt; 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f41e3fca4e348fe7423c916f24a1ebeef22e314" translate="yes" xml:space="preserve">
          <source>Note that many editors are already defined. All of the following commands should already work:</source>
          <target state="translated">많은 편집기가 이미 정의되어 있습니다. 다음 명령은 모두 이미 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="606154b87124703b920a4f5ad5aaefe035ca6c54" translate="yes" xml:space="preserve">
          <source>Note that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex numbers. For example, &lt;code&gt;sqrt&lt;/code&gt; behaves differently when applied to &lt;code&gt;-1&lt;/code&gt; versus &lt;code&gt;-1 + 0im&lt;/code&gt; even though &lt;code&gt;-1 == -1 + 0im&lt;/code&gt;:</source>
          <target state="translated">수학 함수는 일반적으로 실수에 적용될 때 실수 값을 반환하고 복소수에 적용될 경우 복소수 값을 반환합니다. 예를 들어, &lt;code&gt;sqrt&lt;/code&gt; 거동한다 다르게 적용되는 경우에 &lt;code&gt;-1&lt;/code&gt; 대 &lt;code&gt;-1 + 0im&lt;/code&gt; 비록 &lt;code&gt;-1 == -1 + 0im&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9eda807989afc4e218057d81b9286e37073a79b3" translate="yes" xml:space="preserve">
          <source>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The &lt;a href=&quot;https://github.com/ihnorton/Clang.jl&quot;&gt;Clang package&lt;/a&gt; can be used to auto-generate Julia code from a C header file.)</source>
          <target state="translated">C 함수를 호출하는 과정에서 C 헤더 파일은 사용되지 않습니다. Julia 유형 및 호출 서명이 C 헤더 파일에있는 것을 정확하게 반영해야합니다. 합니다 ( &lt;a href=&quot;https://github.com/ihnorton/Clang.jl&quot;&gt;연타 패키지&lt;/a&gt; 는 C 헤더 파일에서 자동으로 생성 줄리아 코드를 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="261026964da2480f5c7569abb83b87f146a2a3d9" translate="yes" xml:space="preserve">
          <source>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file.&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">C 함수를 호출하는 과정에서 C 헤더 파일은 어디에도 사용되지 않습니다. Julia 유형 및 호출 서명이 C 헤더 파일의 내용을 정확하게 반영하는지 확인해야합니다. &lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="183a9f50d7f1857c8647ee5fe93d5bbd7477e31c" translate="yes" xml:space="preserve">
          <source>Note that no call to &lt;code&gt;free&lt;/code&gt; is required as the data is allocated by Julia.</source>
          <target state="translated">Julia가 데이터를 할당하므로 &lt;code&gt;free&lt;/code&gt; 통화 는 필요 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cfb133414980d856fc96bbdc597dbac34e0ca4ba" translate="yes" xml:space="preserve">
          <source>Note that relative-import qualifiers are only valid in &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">relative-import 한정자는 &lt;code&gt;using&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; 문 에서만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="2a7b363c54f5b2b7264272e13433592e29120ac0" translate="yes" xml:space="preserve">
          <source>Note that symbols such as &lt;code&gt;:sin&lt;/code&gt; return precedence &lt;code&gt;0&lt;/code&gt;. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity &lt;code&gt;:none&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:sin&lt;/code&gt; 과 같은 기호는 우선 순위 &lt;code&gt;0&lt;/code&gt; 을 리턴 합니다. 이 값은 우선 순위가 가장 낮은 연산자가 아닌 유효하지 않은 연산자를 나타냅니다. 마찬가지로 이러한 연산자에는 연관성 &lt;code&gt;:none&lt;/code&gt; 이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="80443d11b9c17836808e9bbc89413ca09c77f642" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:</source>
          <target state="translated">점을 유의 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법은 위에서 언급 한 바이너리 스트림에서 작동합니다. 특히, 값은 표준 텍스트 표현으로 변환되지 않지만 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0204290a5fdf9ea4887ee000c8c1756c0892f9d8" translate="yes" xml:space="preserve">
          <source>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</source>
          <target state="translated">Julia가 제공하는 LAPACK API는 향후 변경 될 수 있습니다. 이 API는 사용자 용이 아니므로 향후 릴리스에서이 특정 기능 세트를 지원 / 비정의하겠다는 약속은 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb0eb4027dfd56b0c3ba1c07c0fa8ab9ef0924d1" translate="yes" xml:space="preserve">
          <source>Note that the above nesting rules do not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Function section&lt;/a&gt;.</source>
          <target state="translated">위의 중첩 규칙은 전역 범위에서만 나타날 수 있으므로 유형 및 매크로 정의와 관련이 없습니다. &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;함수 섹션에&lt;/a&gt; 설명 된 기본 및 키워드 함수 인수의 평가와 관련하여 특별한 범위 지정 규칙이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c3ae1e74a271f6b5b8e3aafc0222e0c6dcf4e1d" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable &lt;code&gt;callable&lt;/code&gt; (this is not supported on all architectures).</source>
          <target state="translated">인수 유형 튜플은 리터럴 튜플이어야하며 튜플 값 변수 또는 표현식이 아니어야합니다 (스 플랫 표현식을 포함 할 수 있음). 그리고 이러한 인수는 컴파일 타임 동안 전역 범위에서 평가됩니다 (런타임까지 연기되지 않음). 함수 인수 앞에 '$'를 추가하면 대신 &lt;code&gt;callable&lt;/code&gt; 지역 변수에 대한 런타임 클로저를 생성하도록 변경 됩니다 (모든 아키텍처에서 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="773b4fdf9694adf7f3707027d9426f0fc3ce50f4" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable &lt;code&gt;callable&lt;/code&gt;.</source>
          <target state="translated">인수 유형 튜플은 튜플 값 변수 또는 표현식이 아닌 리터럴 튜플이어야합니다 (스 플랫 표현식을 포함 할 수 있음). 그리고이 인수들은 컴파일 타임 (런타임까지 지연되지 않음) 동안 전역 범위에서 평가됩니다. 함수 인수 앞에 '$'를 추가하면 대신 로컬 변수 &lt;code&gt;callable&lt;/code&gt; 에 대한 런타임 클로저가 생성되도록 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="242e7f9d29400b013c5ba3cc47959df71abf9a55" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</source>
          <target state="translated">인수 유형 튜플은 튜플 값 변수 나 표현식이 아닌 리터럴 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="182fad7ccb0af7ec4c64a83ead848d9efa88d9ca" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be written as &lt;code&gt;(Cstring,)&lt;/code&gt;, not &lt;code&gt;(Cstring)&lt;/code&gt;. This is because &lt;code&gt;(Cstring)&lt;/code&gt; is just the expression &lt;code&gt;Cstring&lt;/code&gt; surrounded by parentheses, rather than a 1-tuple containing &lt;code&gt;Cstring&lt;/code&gt;:</source>
          <target state="translated">인수 유형 튜플은 다음과 같이 작성해야합니다 &lt;code&gt;(Cstring,)&lt;/code&gt; ,하지 &lt;code&gt;(Cstring)&lt;/code&gt; . 이는 &lt;code&gt;(Cstring)&lt;/code&gt; 이 &lt;code&gt;Cstring&lt;/code&gt; 을 포함하는 &lt;code&gt;Cstring&lt;/code&gt; 튜플이 아니라 괄호로 둘러싸인 Cstring 표현식 이기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="c38c436778b1dcecb24bcf6a6967cf9d78faefe3" translate="yes" xml:space="preserve">
          <source>Note that the argument type tuple must be written as &lt;code&gt;(Cstring,)&lt;/code&gt;, rather than &lt;code&gt;(Cstring)&lt;/code&gt;. This is because &lt;code&gt;(Cstring)&lt;/code&gt; is just the expression &lt;code&gt;Cstring&lt;/code&gt; surrounded by parentheses, rather than a 1-tuple containing &lt;code&gt;Cstring&lt;/code&gt;:</source>
          <target state="translated">인수 유형 튜플은 &lt;code&gt;(Cstring)&lt;/code&gt; 대신 &lt;code&gt;(Cstring,)&lt;/code&gt; 으로 작성되어야합니다 . 이는 &lt;code&gt;(Cstring)&lt;/code&gt; 이 &lt;code&gt;Cstring&lt;/code&gt; 을 포함하는 &lt;code&gt;Cstring&lt;/code&gt; 튜플이 아니라 괄호로 묶인 표현식 Cstring 이기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="5b481f8f4087ae7ce46e79bd983600ff5e0124bb" translate="yes" xml:space="preserve">
          <source>Note that the behavior of &lt;code&gt;convert(T, x)&lt;/code&gt; appears to be nearly identical to &lt;code&gt;T(x)&lt;/code&gt;. Indeed, it usually is. However, there is a key semantic difference: since &lt;code&gt;convert&lt;/code&gt; can be called implicitly, its methods are restricted to cases that are considered &quot;safe&quot; or &quot;unsurprising&quot;. &lt;code&gt;convert&lt;/code&gt; will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.</source>
          <target state="translated">&lt;code&gt;convert(T, x)&lt;/code&gt; 의 동작은 &lt;code&gt;T(x)&lt;/code&gt; 거의 동일한 것으로 보입니다 . 실제로, 보통입니다. 그러나 중요한 의미 론적 차이가 있습니다. &lt;code&gt;convert&lt;/code&gt; 은 암시 적으로 호출 될 수 있으므로 해당 메소드는 &quot;안전한&quot;또는 &quot;놀랍지 않은&quot;것으로 간주되는 경우로 제한됩니다. &lt;code&gt;convert&lt;/code&gt; 은 동일한 기본 종류를 나타내는 유형 (예 : 숫자의 다른 표현 또는 다른 문자열 인코딩) 만 변환합니다. 또한 일반적으로 무손실입니다. 값을 다른 유형으로 변환 한 후 다시 되 돌리면 정확히 같은 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="de8cab5819ee3b0454c8698908ed4fca8fb69a34" translate="yes" xml:space="preserve">
          <source>Note that the body returns a quoted expression, namely &lt;code&gt;:(x * x)&lt;/code&gt;, rather than just the value of &lt;code&gt;x * x&lt;/code&gt;.</source>
          <target state="translated">즉, 몸이 인용 표현을 반환합니다 &lt;code&gt;:(x * x)&lt;/code&gt; 의,보다는 값 &lt;code&gt;x * x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da223622416ae78baf74a5fc7606f5c2031025b7" translate="yes" xml:space="preserve">
          <source>Note that the called function should never call back into Julia.</source>
          <target state="translated">호출 된 함수는 Julia를 다시 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4fe61bffc97cc873094be9b6ff384b4a7f4cb2" translate="yes" xml:space="preserve">
          <source>Note that the interactive prompt (aka REPL) is in the global scope of the module &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">대화식 프롬프트 (일명 REPL)는 &lt;code&gt;Main&lt;/code&gt; 모듈의 전체 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a7dbc6956af25ac60c32e9cb274b0c6fab138a" translate="yes" xml:space="preserve">
          <source>Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has to be a specific pattern such that the name prefix (&lt;code&gt;\\.\pipe\&lt;/code&gt;) uniquely identifies the &lt;a href=&quot;https://docs.microsoft.com/windows/desktop/ipc/pipe-names&quot;&gt;file type&lt;/a&gt;. The difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;connect&lt;/code&gt; methods. The &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; method retrieves a connection to the client that is connecting on the server we just created, while the &lt;code&gt;connect&lt;/code&gt; function connects to a server using the specified method. The &lt;code&gt;connect&lt;/code&gt; function takes the same arguments as &lt;code&gt;listen&lt;/code&gt;, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to &lt;code&gt;connect&lt;/code&gt; as you did to listen to establish the connection. So let's try that out (after having created the server above):</source>
          <target state="translated">마지막 호출의 리턴 유형이 다릅니다. 이 서버는 TCP를 수신하지 않고 명명 된 파이프 (Windows) 또는 UNIX 도메인 소켓을 수신하기 때문입니다. 또한 Windows 명명 된 파이프 형식은 이름 접두사 ( &lt;code&gt;\\.\pipe\&lt;/code&gt; )가 &lt;a href=&quot;https://docs.microsoft.com/windows/desktop/ipc/pipe-names&quot;&gt;파일 형식을&lt;/a&gt; 고유하게 식별하도록 특정 패턴이어야합니다 . TCP와 명명 된 파이프 또는 UNIX 도메인 소켓의 차이점은 미묘하며 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;connect&lt;/code&gt; 메소드 와 관련이 있습니다 . 는 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 그동안 우리가 방금 만든 서버에 연결하는 클라이언트에 접속 방식 취득을 &lt;code&gt;connect&lt;/code&gt; 서버로 기능 커넥트가 지정된 방법을 사용하여. &lt;code&gt;connect&lt;/code&gt; 함수는 &lt;code&gt;listen&lt;/code&gt; 과 동일한 인수를 취 하므로 환경 (예 : host, cwd 등)이 동일하다고 가정하면 &lt;code&gt;connect&lt;/code&gt; 을 설정하기 위해 청취 하는 것과 동일한 인수를 전달하여 연결할 수 있어야 합니다. 위의 서버를 만든 후 시도해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8dd40c0b58dda0e7d5d9e1d231741d7f693239a0" translate="yes" xml:space="preserve">
          <source>Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.</source>
          <target state="translated">생성 된 함수에서 시도하지 않아야하는 조작 세트는 제한이 없으며 런타임 시스템은 현재 유효하지 않은 조작의 서브 세트 만 감지 할 수 있습니다. 알림없이 런타임 시스템을 손상시키는 다른 많은 작업이 있습니다. 일반적으로 나쁜 정의에 분명히 연결되지 않은 미묘한 방법입니다. 함수 발생기는 추론 중에 실행되므로 해당 코드의 모든 제한 사항을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ac5f22fc15bc06ba6d15c028e253bf3612813cc" translate="yes" xml:space="preserve">
          <source>Note that the shifted factorization &lt;code&gt;A+&amp;mu;I = Q (H+&amp;mu;I) Q'&lt;/code&gt; can be constructed efficiently by &lt;code&gt;F + &amp;mu;*I&lt;/code&gt; using the &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; object &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;, which creates a new &lt;code&gt;Hessenberg&lt;/code&gt; object with shared storage and a modified shift. The shift of a given &lt;code&gt;F&lt;/code&gt; is obtained by &lt;code&gt;F.&amp;mu;&lt;/code&gt;. This is useful because multiple shifted solves &lt;code&gt;(F + &amp;mu;*I) \ b&lt;/code&gt; (for different &lt;code&gt;&amp;mu;&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt;) can be performed efficiently once &lt;code&gt;F&lt;/code&gt; is created.</source>
          <target state="translated">이동 인수 분해 &lt;code&gt;A+&amp;mu;I = Q (H+&amp;mu;I) Q'&lt;/code&gt; 는 공유 스토리지와 수정 된 이동 을 사용하여 새로운 &lt;code&gt;Hessenberg&lt;/code&gt; 객체 를 생성하는 &lt;a href=&quot;#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; 객체 &lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; 를&lt;/a&gt; 사용하여 &lt;code&gt;F + &amp;mu;*I&lt;/code&gt; 효율적으로 구성 할 수 있습니다 . 주어진 &lt;code&gt;F&lt;/code&gt; 의 이동은 &lt;code&gt;F.&amp;mu;&lt;/code&gt; 로 구합니다 . 이는 &lt;code&gt;F&lt;/code&gt; 가 생성 되면 다중 이동 풀이 &lt;code&gt;(F + &amp;mu;*I) \ b&lt;/code&gt; (다른 &lt;code&gt;&amp;mu;&lt;/code&gt; 및 / 또는 &lt;code&gt;b&lt;/code&gt; 에 대해 )를 효율적으로 수행 할 수 있기 때문에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="098c77a244efd4dcb7a85ef8231c87ef6a79d308" translate="yes" xml:space="preserve">
          <source>Note that the style is not to indent the body of the module, since that would typically lead to whole files being indented.</source>
          <target state="translated">이 스타일은 일반적으로 전체 파일을 들여 쓰기하기 때문에 모듈의 본문을 들여 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a65dec74aa9406a63b1a11d6bdf0569c8ebb5a00" translate="yes" xml:space="preserve">
          <source>Note that the symbol following &lt;code&gt;catch&lt;/code&gt; will always be interpreted as a name for the exception, so care is needed when writing &lt;code&gt;try/catch&lt;/code&gt; expressions on a single line. The following code will &lt;em&gt;not&lt;/em&gt; work to return the value of &lt;code&gt;x&lt;/code&gt; in case of an error:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 뒤에 오는 기호 는 항상 예외의 이름으로 해석되므로 &lt;code&gt;try/catch&lt;/code&gt; 표현식을 한 줄에 작성할 때는주의해야 합니다. 다음 코드는 오류가 발생한 경우 &lt;code&gt;x&lt;/code&gt; 값을 반환 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe90e4507c70efe5bc46591274db5ae42533566c" translate="yes" xml:space="preserve">
          <source>Note that there is no printout of &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached. After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 는 출력되지 않습니다 . 생성 된 함수의 본문이 특정 인수 유형 세트에 대해 여기에서 한 번만 실행되었으며 결과가 캐시 된 것을 볼 수 있습니다. 그 후,이 예제에서는 첫 번째 호출에서 생성 된 함수에서 리턴 된 표현식이 메소드 본문으로 재사용되었습니다. 그러나 실제 캐싱 동작은 구현 정의 성능 최적화이므로이 동작에 너무 밀접하게 의존하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ea0d770c1aabeba8e6465e5630623becb93c780" translate="yes" xml:space="preserve">
          <source>Note that this broad category includes characters such as &amp;frac34; and ௰. Use &lt;a href=&quot;#Base.Unicode.isdigit&quot;&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/a&gt; to check whether a character a decimal digit between 0 and 9.</source>
          <target state="translated">이 광범위한 범주에는 &amp;frac34; 및 ௰와 같은 문자가 포함됩니다. &lt;a href=&quot;#Base.Unicode.isdigit&quot;&gt; &lt;code&gt;isdigit&lt;/code&gt; &lt;/a&gt; 를 사용 하여 문자가 0과 9 사이의 10 진수인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="46bce16da8eb5fd4ccc3e853fc20098d7bbd0e2e" translate="yes" xml:space="preserve">
          <source>Note that this does not apply to globals created under module &lt;code&gt;Main&lt;/code&gt;. Globals under module &lt;code&gt;Main&lt;/code&gt; are serialized and new bindings created under &lt;code&gt;Main&lt;/code&gt; on the remote node.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 모듈에서 만든 전역에는 적용되지 않습니다 . &lt;code&gt;Main&lt;/code&gt; 모듈 아래의 전역 은 직렬화되고 원격 노드의 &lt;code&gt;Main&lt;/code&gt; 아래에 새 바인딩이 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="decefaec1642643605dc8ee1c5de68e2852a981d" translate="yes" xml:space="preserve">
          <source>Note that this function is equivalent to, but more efficient than, calling &lt;code&gt;sortperm(...)[k]&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;sortperm(...)[k]&lt;/code&gt; 호출하는 것과 같지만 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="e07027027168426f4f2b4f5df57b78ff2fab63d3" translate="yes" xml:space="preserve">
          <source>Note that this is currently only supported for &lt;code&gt;T == BigFloat&lt;/code&gt;.</source>
          <target state="translated">이것은 현재 &lt;code&gt;T == BigFloat&lt;/code&gt; 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f0c770bab0c855a7467cef4c010de3b51ac415b" translate="yes" xml:space="preserve">
          <source>Note that this must be done &lt;em&gt;before&lt;/em&gt; starting Julia.</source>
          <target state="translated">Julia &lt;em&gt;를&lt;/em&gt; 시작 &lt;em&gt;하기 전에이&lt;/em&gt; 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8f522da50be36203fff5e8db4bd6b88f1b3533d" translate="yes" xml:space="preserve">
          <source>Note that this syntax requires parser support so it is expanded directly by the parser rather than being implemented as a normal string macro &lt;code&gt;@var_str&lt;/code&gt;.</source>
          <target state="translated">이 구문은 구문 분석기 지원이 필요하므로 일반 문자열 매크로 &lt;code&gt;@var_str&lt;/code&gt; 로 구현되는 대신 구문 분석기에 의해 직접 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a69672b19bbf6fc996983df5447f2fd2baf53ea0" translate="yes" xml:space="preserve">
          <source>Note that to use &lt;code&gt;:&lt;/code&gt; syntax, the symbol's name must be a valid identifier. Otherwise the &lt;code&gt;Symbol(str)&lt;/code&gt; constructor must be used.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 구문 을 사용 하려면 기호 이름이 유효한 식별자 여야합니다. 그렇지 않으면 &lt;code&gt;Symbol(str)&lt;/code&gt; 생성자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a0687d76141aed2877a1dff058cc77fb55f506a" translate="yes" xml:space="preserve">
          <source>Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.</source>
          <target state="translated">매우 짧은 조건문 (한 줄짜리)은 다음 섹션에서 설명하는 것처럼 Julia의 단락 평가를 사용하여 자주 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c15c95912e4eeb3f6bc8a0cd88bc94054fd059" translate="yes" xml:space="preserve">
          <source>Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.</source>
          <target state="translated">제작자에서 채널을 명시 적으로 닫을 필요는 없습니다. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 에 바인딩하는 작업 은 채널 의 열린 수명을 바인딩 된 작업의 수명과 연결하기 때문입니다. 작업이 종료되면 채널 개체가 자동으로 닫힙니다. 여러 채널을 작업에 바인딩 할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a041f4940ddd89a348e7d26f6b6538be977f726f" translate="yes" xml:space="preserve">
          <source>Note that we used &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; instead of &lt;code&gt;1 .+ r&lt;/code&gt;. This is because we do not know where the code will run, so in general a &lt;code&gt;fetch&lt;/code&gt; might be required to move &lt;code&gt;r&lt;/code&gt; to the process doing the addition. In this case, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; is smart enough to perform the computation on the process that owns &lt;code&gt;r&lt;/code&gt;, so the &lt;code&gt;fetch&lt;/code&gt; will be a no-op (no work is done).</source>
          <target state="translated">우리 는 &lt;code&gt;1 .+ r&lt;/code&gt; 대신 1 &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; 사용했습니다 . 코드가 실행 어디에 우리가 모르는 때문에 이렇게 일반 정보에서, &lt;code&gt;fetch&lt;/code&gt; 이동해야 할 수도 있습니다 &lt;code&gt;r&lt;/code&gt; 추가를하고있는 과정. 이 경우 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;r&lt;/code&gt; 을 소유 한 프로세스에서 계산을 수행하기에 충분히 영리 하므로 &lt;code&gt;fetch&lt;/code&gt; 가 작동하지 않습니다 (작업이 수행되지 않음).</target>
        </trans-unit>
        <trans-unit id="8b476ca57178b877e88595d1fb22b7c6b4d72890" translate="yes" xml:space="preserve">
          <source>Note that we used &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; instead of &lt;code&gt;1 .+ r&lt;/code&gt;. This is because we do not know where the code will run, so in general a &lt;code&gt;fetch&lt;/code&gt; might be required to move &lt;code&gt;r&lt;/code&gt; to the process doing the addition. In this case, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; is smart enough to perform the computation on the process that owns &lt;code&gt;r&lt;/code&gt;, so the &lt;code&gt;fetch&lt;/code&gt; will be a no-op (no work is done).</source>
          <target state="translated">우리가 사용하는 것을 주 &lt;code&gt;1 .+ fetch(r)&lt;/code&gt; 대신 &lt;code&gt;1 .+ r&lt;/code&gt; . 이는 코드가 실행될 위치를 모르기 때문에 일반적 으로 &lt;code&gt;r&lt;/code&gt; 을 추가하는 프로세스 로 이동하려면 &lt;code&gt;fetch&lt;/code&gt; 가 필요할 수 있습니다 . 이 경우 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;r&lt;/code&gt; 을 소유 한 프로세스에서 계산을 수행 할 수있을만큼 똑똑 하므로 &lt;code&gt;fetch&lt;/code&gt; 가 작동하지 않습니다 (작업이 수행되지 않음).</target>
        </trans-unit>
        <trans-unit id="dbfb57351589495d2dd8de2006388f09857c0744" translate="yes" xml:space="preserve">
          <source>Note that when calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; you'll typically see a frame with &lt;code&gt;eval at boot.jl&lt;/code&gt;. When calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; from the REPL you'll also have a few extra frames in the stack from &lt;code&gt;REPL.jl&lt;/code&gt;, usually looking something like this:</source>
          <target state="translated">&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 일반적으로 &lt;code&gt;eval at boot.jl&lt;/code&gt; 있는 프레임이 표시 됩니다. REPL에서 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; 를 호출하면 &lt;code&gt;REPL.jl&lt;/code&gt; 의 스택에 몇 가지 추가 프레임이 있으며 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0336c6d353bdf069375cc4ebc53bc56d524d283" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;ccall&lt;/code&gt; with the tuple input (e.g., &lt;code&gt;ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)&lt;/code&gt;), the library is opened implicitly and it may not be explicitly closed.</source>
          <target state="translated">튜플 입력과 함께 &lt;code&gt;ccall&lt;/code&gt; 을 사용하는 경우 (예 : &lt;code&gt;ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)&lt;/code&gt; ) 라이브러리가 암시 적으로 열리고 명시 적으로 닫히지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7755931bfc7e42557f4980dc1550eb2a0697dbe" translate="yes" xml:space="preserve">
          <source>Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.</source>
          <target state="translated">Julia 코드는 기본적으로 단일 스레드에서 실행되지만 Julia가 사용하는 라이브러리는 자체 내부 스레드를 시작할 수 있습니다. 예를 들어, BLAS 라이브러리는 머신에 코어가있는 수만큼 스레드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d81223c9c8d2eeed50e8859a101793fd1716551" translate="yes" xml:space="preserve">
          <source>Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.</source>
          <target state="translated">doctest의 공백은 중요합니다! 예를 들어, 배열을 예쁘게 인쇄 한 결과를 잘못 정렬하면 doctest가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bd5a7cad245d42f3ac5b5566f1d477628cb424e9" translate="yes" xml:space="preserve">
          <source>Note that without a reducer function, &lt;code&gt;@distributed&lt;/code&gt; executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like :</source>
          <target state="translated">감속기 기능이 &lt;code&gt;@distributed&lt;/code&gt; 비동기식으로 실행됩니다. 즉, 사용 가능한 모든 작업자에 대해 독립적 인 작업을 생성하고 완료를 기다리지 않고 즉시 반환됩니다. 완료를 기다리려면 다음과 같이 호출 앞에 &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt; 를 붙입니다 .</target>
        </trans-unit>
        <trans-unit id="8b82f9fcca40e4c57bacd44e7da3e166bdb809a5" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</source>
          <target state="translated">작업자는 &lt;code&gt;.julia/config/startup.jl&lt;/code&gt; 시작 스크립트를 실행하거나 전역 상태 (예 : 전역 변수, 새 메소드 정의 및로드 된 모듈)를 실행중인 다른 프로세스와 동기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c96de6543363babe91fa2bd5f4b7d12201ebc82e" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</source>
          <target state="translated">작업자는 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 시작 스크립트를 실행하거나 전역 상태 (예 : 전역 변수, 새 메소드 정의 및로드 된 모듈)를 실행중인 다른 프로세스와 동기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89baaa30648337782f32c5ae2ae7030426db160f" translate="yes" xml:space="preserve">
          <source>Note that workers do not run a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes. You may use &lt;code&gt;addprocs(exeflags=&quot;--project&quot;)&lt;/code&gt; to initialize a worker with a particular environment, and then &lt;code&gt;@everywhere using &amp;lt;modulename&amp;gt;&lt;/code&gt; or &lt;code&gt;@everywhere include(&quot;file.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">워커는 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 시작 스크립트를 실행하지 않으며 전역 상태 (예 : 전역 변수, 새 메서드 정의 및로드 된 모듈)를 실행중인 다른 프로세스와 동기화하지 않습니다. 당신은 사용할 수 있습니다 &lt;code&gt;addprocs(exeflags=&quot;--project&quot;)&lt;/code&gt; 특정 환경과 작업자를 초기화 한 다음 &lt;code&gt;@everywhere using &amp;lt;modulename&amp;gt;&lt;/code&gt; 하거나 &lt;code&gt;@everywhere include(&quot;file.jl&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a97820043be9298d4bc607709ec3ef73b5ab453" translate="yes" xml:space="preserve">
          <source>Note that you can also use &lt;code&gt;string(...)&lt;/code&gt; to concatenate strings (and other values converted to strings); similarly, &lt;code&gt;repeat&lt;/code&gt; can be used instead of &lt;code&gt;^&lt;/code&gt; to repeat strings. The &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;interpolation syntax&lt;/a&gt; is also useful for constructing strings.</source>
          <target state="translated">&lt;code&gt;string(...)&lt;/code&gt; 을 사용 하여 문자열 (및 문자열로 변환 된 다른 값 ) 을 연결할 수도 있습니다 . 마찬가지로 &lt;code&gt;^&lt;/code&gt; 대신 &lt;code&gt;repeat&lt;/code&gt; 를 사용 하여 문자열을 반복 할 수 있습니다 . &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;보간 구문은&lt;/a&gt; 또한 문자열을 구성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40d8a230b804b324888f6d3a86be63b3abee81ae" translate="yes" xml:space="preserve">
          <source>Note that you can also use &lt;code&gt;string(...)&lt;/code&gt; to concatenate strings (and other values converted to strings); similarly, &lt;code&gt;repeat&lt;/code&gt; can be used instead of &lt;code&gt;^&lt;/code&gt; to repeat strings. The &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;interpolation syntax&lt;/a&gt; is also useful for constructing strings.</source>
          <target state="translated">&lt;code&gt;string(...)&lt;/code&gt; 을 사용 하여 문자열 (및 다른 값을 문자열로 변환 ) 을 연결할 수도 있습니다 . 마찬가지로 &lt;code&gt;^&lt;/code&gt; 대신에 &lt;code&gt;repeat&lt;/code&gt; 을 사용 하여 문자열을 반복 할 수 있습니다 . &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;보간 구문은&lt;/a&gt; 또한 문자열을 구성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc21cdea00752ec368b11bbb1559eb6ea1d10cf4" translate="yes" xml:space="preserve">
          <source>Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2.</source>
          <target state="translated">이 글을 쓰는 시점에서 SHA3 코드는 최적화되지 않았으므로 SHA2보다 약 10 배 정도 느립니다.</target>
        </trans-unit>
        <trans-unit id="9c3731439f34ac151e71f6a88214f5aa6a661453" translate="yes" xml:space="preserve">
          <source>Note that, in Julia script started without &lt;code&gt;-i&lt;/code&gt; (interactive) option, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by default. Calling &lt;a href=&quot;../c/index#Base.exit_on_sigint&quot;&gt;&lt;code&gt;Base.exit_on_sigint(false)&lt;/code&gt;&lt;/a&gt; in the script can recover the behavior of the REPL. Alternatively, a Julia script can be started with</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; (대화 형) 옵션 없이 시작된 Julia 스크립트 에서는 기본적으로 &lt;code&gt;InterruptException&lt;/code&gt; 이 발생하지 않습니다. 스크립트에서 &lt;a href=&quot;../c/index#Base.exit_on_sigint&quot;&gt; &lt;code&gt;Base.exit_on_sigint(false)&lt;/code&gt; &lt;/a&gt; 를 호출 하면 REPL의 동작을 복구 할 수 있습니다. 또는 Julia 스크립트를 다음으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f69f72ec1b9af255308c07545be2fc8d856f28" translate="yes" xml:space="preserve">
          <source>Note the distinguishing &lt;code&gt;@&lt;/code&gt; before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after &lt;code&gt;@name&lt;/code&gt; in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple &lt;code&gt;(expr1, expr2, ...)&lt;/code&gt; as one argument to the macro:</source>
          <target state="translated">매크로 이름 앞에 &lt;code&gt;@&lt;/code&gt; 를 구별 하고 첫 번째 형식의 인수 표현식 사이에 쉼표가없고 두 번째 형식의 &lt;code&gt;@name&lt;/code&gt; 뒤에 공백이없는 것에 주목하십시오 . 두 스타일을 혼합해서는 안됩니다. 예를 들어, 다음 구문은 위 예와 다릅니다. 매크로에 대한 하나의 인수로 튜플 &lt;code&gt;(expr1, expr2, ...)&lt;/code&gt; 을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f72a4ca407bc566d00161d17253a5df7ce9feb29" translate="yes" xml:space="preserve">
          <source>Note the dot syntax is also applicable to user-defined operators. For example, if you define &lt;code&gt;&amp;otimes;(A,B) = kron(A,B)&lt;/code&gt; to give a convenient infix syntax &lt;code&gt;A &amp;otimes; B&lt;/code&gt; for Kronecker products (&lt;a href=&quot;../../stdlib/linearalgebra/index#Base.kron&quot;&gt;&lt;code&gt;kron&lt;/code&gt;&lt;/a&gt;), then &lt;code&gt;[A,B] .&amp;otimes; [C,D]&lt;/code&gt; will compute &lt;code&gt;[A&amp;otimes;C, B&amp;otimes;D]&lt;/code&gt; with no additional coding.</source>
          <target state="translated">도트 구문은 사용자 정의 연산자에도 적용 할 수 있습니다. 정의한 경우, 예를 들어 &lt;code&gt;&amp;otimes;(A,B) = kron(A,B)&lt;/code&gt; 편리한 중위 구문 수득 &lt;code&gt;A &amp;otimes; B&lt;/code&gt; 맞췄다 제품 ( &lt;a href=&quot;../../stdlib/linearalgebra/index#Base.kron&quot;&gt; &lt;code&gt;kron&lt;/code&gt; &lt;/a&gt; 후)를, &lt;code&gt;[A,B] .&amp;otimes; [C,D]&lt;/code&gt; 계산하는 것 추가 코딩없이 &lt;code&gt;[A&amp;otimes;C, B&amp;otimes;D]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21adfeb51b92fa6389f9a0f8426e92487dbabd63" translate="yes" xml:space="preserve">
          <source>Note the evaluation behavior of chained comparisons:</source>
          <target state="translated">체인 비교의 평가 동작에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="4d5ad5e5567c252cacda0e45872c352990ca190e" translate="yes" xml:space="preserve">
          <source>Note the implications of covariance:</source>
          <target state="translated">공분산의 의미에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e365768e844c62cc4abb32f1de51046a7ca82a" translate="yes" xml:space="preserve">
          <source>Note the important difference between &lt;code&gt;sum(A)&lt;/code&gt; and &lt;code&gt;reduce(+, A)&lt;/code&gt; for arrays with small integer eltype:</source>
          <target state="translated">정수형이 작은 배열의 경우 &lt;code&gt;sum(A)&lt;/code&gt; 와 &lt;code&gt;reduce(+, A)&lt;/code&gt; 의 중요한 차이점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6be73201d2bdb5b60bd4ac16f617f03563234a7" translate="yes" xml:space="preserve">
          <source>Note the lack of a newline at the end of &lt;code&gt;/tmp/text.txt&lt;/code&gt;. Julia automatically inserts a newline before the &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">&lt;code&gt;/tmp/text.txt&lt;/code&gt; 끝에 줄 바꿈이 없다는 점에 유의하십시오 . Julia는 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 프롬프트 앞에 줄 바꿈을 자동으로 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="3b34f97175a230919ab690f3d87c164c80cc78fa" translate="yes" xml:space="preserve">
          <source>Note the two spaces before each &lt;code&gt;*&lt;/code&gt; and the single space after each one.</source>
          <target state="translated">각 &lt;code&gt;*&lt;/code&gt; 앞의 공백 두 개와 각 공백 뒤에있는 단일 공백에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="36a8e68f48fc3d2175af90fbf8e18f9e672cd18b" translate="yes" xml:space="preserve">
          <source>Note, though, that the above &lt;em&gt;only&lt;/em&gt; defines &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; with one integer index. Indexing with anything other than an &lt;code&gt;Int&lt;/code&gt; will throw a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; saying that there was no matching method. In order to support indexing with ranges or vectors of &lt;code&gt;Int&lt;/code&gt;s, separate methods must be written:</source>
          <target state="translated">그러나 위의 내용 은 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 만&lt;/em&gt; 정의합니다 . 은 하나의 정수 색인으로 . &lt;code&gt;Int&lt;/code&gt; 이외의 항목을 사용하여 인덱싱하면 일치하는 메소드가 없음을 나타내는 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 범위 또는 &lt;code&gt;Int&lt;/code&gt; 벡터로 인덱싱을 지원 하려면 별도의 메소드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8482997969bd6e2f8506bbaee3f00bf7673cbff9" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Sampler(rng, x)&lt;/code&gt; is simply a shorthand for &lt;code&gt;Sampler(rng, x, Val(Inf))&lt;/code&gt;, and &lt;code&gt;Random.Repetition&lt;/code&gt; is an alias for &lt;code&gt;Union{Val{1}, Val{Inf}}&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Sampler(rng, x)&lt;/code&gt; 는 &lt;code&gt;Sampler(rng, x, Val(Inf))&lt;/code&gt; &lt;code&gt;Random.Repetition&lt;/code&gt; 이며 Random.Repetition 은 &lt;code&gt;Union{Val{1}, Val{Inf}}&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="5d1a9fbb062505ef6ee2056aac065b143189a068" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nextfloat()&lt;/code&gt;, &lt;code&gt;prevfloat()&lt;/code&gt; do not use the precision mentioned by &lt;code&gt;setprecision&lt;/code&gt;</source>
          <target state="translated">노트 : &lt;code&gt;nextfloat()&lt;/code&gt; , &lt;code&gt;prevfloat()&lt;/code&gt; 는 &lt;code&gt;setprecision&lt;/code&gt; 에 의해 언급 된 정밀도를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d257ed043f41d212dfcd94a6cc7dccb052911321" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;zip&lt;/code&gt; orders the calls to its subiterators in such a way that stateful iterators will not advance when another iterator finishes in the current iteration.</source>
          <target state="translated">참고 : &lt;code&gt;zip&lt;/code&gt; 은 다른 반복자가 현재 반복에서 완료 될 때 상태 저장 반복자가 진행되지 않도록 하위 반복자에 대한 호출을 주문합니다.</target>
        </trans-unit>
        <trans-unit id="08efe73137cc5e3a0b821052128f9b49198fdb18" translate="yes" xml:space="preserve">
          <source>Note: The absence of warnings generated by &lt;code&gt;@warn&lt;/code&gt; cannot be tested with this macro. Use &lt;code&gt;@test_logs expr&lt;/code&gt; instead.</source>
          <target state="translated">참고 : &lt;code&gt;@warn&lt;/code&gt; 에 의해 생성 된 경고의 부재는 이 매크로로 테스트 할 수 없습니다. 대신 &lt;code&gt;@test_logs expr&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="91ce3aec96b4e4fe9ae814dda08f7cfcb11c5b12" translate="yes" xml:space="preserve">
          <source>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</source>
          <target state="translated">참고 :이 기능은 현재 64 비트 x86 및 AArch64 플랫폼에서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae106ae74dde49286b4f7547e9e4c37d9125364" translate="yes" xml:space="preserve">
          <source>Note: Warnings generated by &lt;code&gt;@warn&lt;/code&gt; cannot be tested with this macro. Use &lt;code&gt;@test_logs&lt;/code&gt; instead.</source>
          <target state="translated">참고 : &lt;code&gt;@warn&lt;/code&gt; 에 의해 생성 된 경고는 이 매크로로 테스트 할 수 없습니다. 대신 &lt;code&gt;@test_logs&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe152fdfb8ac8116096c5833a5da72fe28dcdf6" translate="yes" xml:space="preserve">
          <source>Notebook</source>
          <target state="translated">Notebook</target>
        </trans-unit>
        <trans-unit id="3745a01d14712bbd397dca189f292ef9d4f82931" translate="yes" xml:space="preserve">
          <source>Notebook With Decorative Cover</source>
          <target state="translated">장식적인 덮개를 가진 노트북</target>
        </trans-unit>
        <trans-unit id="f845802acfac532c071d4aaa950ebd7924f7445d" translate="yes" xml:space="preserve">
          <source>Noteworthy Differences from other Languages</source>
          <target state="translated">다른 언어와의 현저한 차이점</target>
        </trans-unit>
        <trans-unit id="66ce7a541bd48804d295c01fa8bd545df0afeca2" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from C/C++</source>
          <target state="translated">C / C ++와의 현저한 차이점</target>
        </trans-unit>
        <trans-unit id="e3122c16054a2bae65c636644688d117bb642dbb" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from Common Lisp</source>
          <target state="translated">Common Lisp와의 주목할만한 차이점</target>
        </trans-unit>
        <trans-unit id="7010f263a0a8c01d527c668d3aa731a8f234b4a1" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from MATLAB</source>
          <target state="translated">MATLAB과의 현저한 차이점</target>
        </trans-unit>
        <trans-unit id="0dde472d5176039598d0e8a87239f04a077f873a" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from Python</source>
          <target state="translated">파이썬과 주목할만한 차이점</target>
        </trans-unit>
        <trans-unit id="f7e2b96cfe1dbe019d8e0fb2a6d3e5e7789c4a19" translate="yes" xml:space="preserve">
          <source>Noteworthy differences from R</source>
          <target state="translated">R과 주목할만한 차이점</target>
        </trans-unit>
        <trans-unit id="8eaeecbc1c997d4fd71223a0cf24b0b3a194db6a" translate="yes" xml:space="preserve">
          <source>Noteworthy external packages</source>
          <target state="translated">주목할만한 외부 패키지</target>
        </trans-unit>
        <trans-unit id="2cfa8112f928b66aa11f861fcbbd7f424b123fed" translate="yes" xml:space="preserve">
          <source>Nothingness and missing values</source>
          <target state="translated">무 (無)와 결 측값</target>
        </trans-unit>
        <trans-unit id="b285dba5e2d226b2bb71434ab5cf1c3897f514df" translate="yes" xml:space="preserve">
          <source>Notice both the 3&amp;times; speedup and the decreased memory allocation of the &lt;code&gt;fview&lt;/code&gt; version of the function.</source>
          <target state="translated">&lt;code&gt;fview&lt;/code&gt; 버전의 함수 의 3 배 속도 향상과 감소 된 메모리 할당을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1f51bd973f62a02cf830582487e4dd72c9333cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;(1 + 2)&lt;/code&gt; now appears in the result instead of the symbol &lt;code&gt;x&lt;/code&gt;. Evaluating this expression yields an interpolated &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">통지는 &lt;code&gt;(1 + 2)&lt;/code&gt; 지금 대신 심볼의 결과에 나타나는 &lt;code&gt;x&lt;/code&gt; . 이 표현식을 평가하면 보간 된 &lt;code&gt;3&lt;/code&gt; 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="47a584fefd44f3b390733917fbd3332df61560b9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;:(1 + 2)&lt;/code&gt; now appears in the result instead of the symbol &lt;code&gt;:x&lt;/code&gt;. Evaluating this expression yields an interpolated &lt;code&gt;3&lt;/code&gt;:</source>
          <target state="translated">공지 사항은 &lt;code&gt;:(1 + 2)&lt;/code&gt; 지금 대신 기호의 결과에 나타납니다 &lt;code&gt;:x&lt;/code&gt; . 이 표현식을 평가하면 보간 된 &lt;code&gt;3&lt;/code&gt; 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf54d9610c4312df35c98185a406d728d6063413" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. Vararg tuple types are used to represent the arguments accepted by varargs methods (see &lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;).</source>
          <target state="translated">공지 사항이 &lt;code&gt;Vararg{T}&lt;/code&gt; 형의 0 개 이상의 요소에 해당하는 &lt;code&gt;T&lt;/code&gt; . Vararg 튜플 유형은 varargs 메서드에서 허용되는 인수를 나타내는 데 사용됩니다 ( &lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="da8a8a782d504cc3899237534fddcfde617523d9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. Vararg tuple types are used to represent the arguments accepted by varargs methods (see &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;).</source>
          <target state="translated">공지 사항이 &lt;code&gt;Vararg{T}&lt;/code&gt; 형의 0 개 이상의 요소에 해당하는 &lt;code&gt;T&lt;/code&gt; . Vararg 튜플 유형은 varargs 메소드에서 허용되는 인수를 나타내는 데 사용됩니다 ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="11bb07567655e1f8b926942e92a94d2603e316d5" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;copy_cols&lt;/code&gt; is much faster than &lt;code&gt;copy_rows&lt;/code&gt;. This is expected because &lt;code&gt;copy_cols&lt;/code&gt; respects the column-based memory layout of the &lt;code&gt;Matrix&lt;/code&gt; and fills it one column at a time. Additionally, &lt;code&gt;copy_col_row&lt;/code&gt; is much faster than &lt;code&gt;copy_row_col&lt;/code&gt; because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.</source>
          <target state="translated">공지 사항은 &lt;code&gt;copy_cols&lt;/code&gt; 것보다 훨씬 빠르기 때문에 &lt;code&gt;copy_rows&lt;/code&gt; . 이것은 &lt;code&gt;copy_cols&lt;/code&gt; 가 &lt;code&gt;Matrix&lt;/code&gt; 의 열 기반 메모리 레이아웃을 존중하고 한 번에 하나의 열을 채우기 때문입니다. 또한 &lt;code&gt;copy_col_row&lt;/code&gt; 는 copy_row_col 보다 훨씬 빠릅니다 . 슬라이스 식에 나타나는 첫 번째 요소가 가장 안쪽의 루프와 결합되어야한다는 경험 법칙을 &lt;code&gt;copy_row_col&lt;/code&gt; 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b6fec7442f6e6a427e8a8d522c95544bfa904449" translate="yes" xml:space="preserve">
          <source>Notice that a length-1 tuple must be written with a comma, &lt;code&gt;(1,)&lt;/code&gt;, since &lt;code&gt;(1)&lt;/code&gt; would just be a parenthesized value. &lt;code&gt;()&lt;/code&gt; represents the empty (length-0) tuple.</source>
          <target state="translated">&lt;code&gt;(1)&lt;/code&gt; 은 괄호로 묶은 값 이므로 길이 1 튜플은 쉼표 &lt;code&gt;(1,)&lt;/code&gt; 로 작성해야합니다 . &lt;code&gt;()&lt;/code&gt; 는 빈 (길이 -0) 튜플을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f287cb5fedcc8f5e7808755801d877f4587681d7" translate="yes" xml:space="preserve">
          <source>Notice that each definition looks like the form of constructor call that it handles. The call &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; will invoke the definition &lt;code&gt;Point{T}(x,y)&lt;/code&gt; inside the &lt;code&gt;struct&lt;/code&gt; block. The outer constructor declaration, on the other hand, defines a method for the general &lt;code&gt;Point&lt;/code&gt; constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like &lt;code&gt;Point(1,2)&lt;/code&gt; and &lt;code&gt;Point(1.0,2.5)&lt;/code&gt;, work. Since the method declaration restricts the arguments to being of the same type, calls like &lt;code&gt;Point(1,2.5)&lt;/code&gt;, with arguments of different types, result in &quot;no method&quot; errors.</source>
          <target state="translated">각 정의는 처리하는 생성자 호출 형식과 비슷합니다. 콜 &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 는 &lt;code&gt;struct&lt;/code&gt; 블록 내에서 정의 &lt;code&gt;Point{T}(x,y)&lt;/code&gt; 를 호출합니다 . 반면에 외부 생성자 선언 은 동일한 실수 유형의 값 쌍에만 적용되는 일반 &lt;code&gt;Point&lt;/code&gt; 생성자에 대한 메소드를 정의합니다 . 이 선언은 &lt;code&gt;Point(1,2)&lt;/code&gt; 및 &lt;code&gt;Point(1.0,2.5)&lt;/code&gt; 와 같은 명시 적 형식 매개 변수없이 생성자 호출을 작동시킵니다. 메소드 선언은 인수가 동일한 유형으로 제한되기 때문에 다른 유형의 인수를 사용하여 &lt;code&gt;Point(1,2.5)&lt;/code&gt; 와 같은 호출 은 &quot;메소드 없음&quot;오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b4e2247285a711b8f77ce042019fc6f3ec7e1067" translate="yes" xml:space="preserve">
          <source>Notice that it is perfectly possible to define a global inside a function like &lt;code&gt;__init__&lt;/code&gt;; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on &lt;code&gt;foo_data_ptr&lt;/code&gt; would also have to be initialized in &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 와 같은 함수 내에서 전역을 정의하는 것은 완벽하게 가능합니다 . 이것은 동적 언어를 사용하는 장점 중 하나입니다. 그러나 전역 범위에서 일정하게 유지하면 컴파일러에 유형이 알려지고 더 최적화 된 코드를 생성 할 수 있습니다. 분명히 &lt;code&gt;foo_data_ptr&lt;/code&gt; 에 의존하는 모듈의 다른 전역 도 &lt;code&gt;__init__&lt;/code&gt; 에서 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e26af993d1f21f6e38ead5214b5da67c55ed9c51" translate="yes" xml:space="preserve">
          <source>Notice that our use of this pattern with &lt;code&gt;count_heads&lt;/code&gt; can be generalized. We used two explicit &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statements, which limits the parallelism to two processes. To run on any number of processes, we can use a &lt;em&gt;parallel for loop&lt;/em&gt;, running in distributed memory, which can be written in Julia using &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;code&gt;count_heads&lt;/code&gt; 와 함께이 패턴을 사용하는 것이 일반화 될 수 있습니다. 병렬 처리를 두 개의 프로세스로 제한하는 두 개의 명시적인 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 문을 사용했습니다 . 여러 프로세스에서 실행 &lt;em&gt;하기 위해&lt;/em&gt; 분산 메모리에서 실행 되는 &lt;em&gt;병렬 for loop&lt;/em&gt; 를 사용할 수 있습니다 . 이는 다음과 같이 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt; &lt;code&gt;@distributed&lt;/code&gt; 를&lt;/a&gt; 사용하여 Julia에서 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6176e267224c5182e5ef2888a5422728bb14a5a" translate="yes" xml:space="preserve">
          <source>Notice that our use of this pattern with &lt;code&gt;count_heads&lt;/code&gt; can be generalized. We used two explicit &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statements, which limits the parallelism to two processes. To run on any number of processes, we can use a &lt;em&gt;parallel for loop&lt;/em&gt;, running in distributed memory, which can be written in Julia using &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt;&lt;code&gt;@distributed&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;code&gt;count_heads&lt;/code&gt; 와 함께이 패턴을 사용 하면 일반화 할 수 있습니다. 병렬 처리를 두 프로세스로 제한하는 두 개의 명시 적 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; 문을 사용했습니다 . 임의의 수의 프로세스에서 실행하려면 분산 메모리에서 실행 되는 &lt;em&gt;병렬 for 루프&lt;/em&gt; 를 사용할 수 있습니다 . 이는 다음과 같이 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@distributed&quot;&gt; &lt;code&gt;@distributed&lt;/code&gt; 를&lt;/a&gt; 사용하여 Julia에서 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7122bc7ae3f346c6db77a364221c454e445b8694" translate="yes" xml:space="preserve">
          <source>Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also &lt;em&gt;dynamically&lt;/em&gt; available to the current logger. It's simple to define a &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;custom logger&lt;/a&gt; to augment event data with the time, backtrace, values of global variables and other useful information as required.</source>
          <target state="translated">이벤트 시간과 같은 일부 유용한 정보는 기본적으로 포함되어 있지 않습니다. 이는 이러한 정보를 추출하는 데 비용이 많이 들고 현재 로거에서 &lt;em&gt;동적으로&lt;/em&gt; 사용할 수 있기 때문 입니다. 필요에 따라 시간, 역 추적, 전역 변수 값 및 기타 유용한 정보로 이벤트 데이터를 늘리기 위해 &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;사용자 정의 로거&lt;/a&gt; 를 정의하는 것은 간단 합니다.</target>
        </trans-unit>
        <trans-unit id="72438d3388f10dff00ade8e549f029a3aeac6ed1" translate="yes" xml:space="preserve">
          <source>Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also &lt;em&gt;dynamically&lt;/em&gt; available to the current logger. It's simple to define a &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;custom logger&lt;/a&gt; to augment event data with the time, backtrace, values of global variables and other useful information as required.</source>
          <target state="translated">이벤트 시간과 같은 유용한 정보는 기본적으로 포함되어 있지 않습니다. 이러한 정보는 추출하는 데 비용이 많이 들고 현재 로거가 &lt;em&gt;동적으로&lt;/em&gt; 사용할 수 있기 때문 입니다. 시간, 역 추적, 전역 변수 값 및 필요한 기타 유용한 정보로 이벤트 데이터를 보강하기 위해 &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;사용자 정의 로거&lt;/a&gt; 를 정의하는 것은 간단 합니다.</target>
        </trans-unit>
        <trans-unit id="4e77dd3d046d81afb4b62f7ad7414d418b5c22e3" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;$&lt;/code&gt; interpolation syntax allows inserting only a single expression into an enclosing expression. Occasionally, you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax &lt;code&gt;$(xs...)&lt;/code&gt;. For example, the following code generates a function call where the number of arguments is determined programmatically:</source>
          <target state="translated">알 &lt;code&gt;$&lt;/code&gt; 보간 구문 둘러싸 식으로 단일 표현을 삽입 할 수 있습니다. 때때로, 당신은 표현의 배열을 가지고 있고 그것들 모두가 주변 표현의 인수가되기 위해 필요합니다. 이것은 &lt;code&gt;$(xs...)&lt;/code&gt; 구문으로 수행 할 수 있습니다 . 예를 들어 다음 코드는 인수 개수가 프로그래밍 방식으로 결정되는 함수 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f30b72621d9228b399ae55ac5b16e08861f68644" translate="yes" xml:space="preserve">
          <source>Notice that the expressions &lt;code&gt;str[k]&lt;/code&gt; and &lt;code&gt;str[k:k]&lt;/code&gt; do not give the same result:</source>
          <target state="translated">&lt;code&gt;str[k]&lt;/code&gt; 및 &lt;code&gt;str[k:k]&lt;/code&gt; 표현식 은 동일한 결과를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50882ef5eb622d73f029f8ec3b3fd05b58b270d6" translate="yes" xml:space="preserve">
          <source>Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote character. However, the next backslash character escapes the backslash that follows it, and the last backslash escapes a quote, since these backslashes appear before a quote.</source>
          <target state="translated">처음 두 백 슬래시는 따옴표 문자 앞에 있지 않기 때문에 출력에서 ​​그대로 나타납니다. 그러나 다음 백 슬래시 문자는 뒤에 오는 백 슬래시를 이스케이프하고 마지막 백 슬래시는 따옴표 앞에 이스케이프하므로이 백 슬래시는 따옴표를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="daa54f3f580d525d2a76ffa60a5689c1c5463f9e" translate="yes" xml:space="preserve">
          <source>Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function body, &lt;code&gt;p&lt;/code&gt; will refer to the object that was called. A &lt;code&gt;Polynomial&lt;/code&gt; can be used as follows:</source>
          <target state="translated">함수는 이름 대신 유형으로 지정됩니다. 일반 함수와 마찬가지로 간결한 구문 형식이 있습니다. 함수 본문에서 &lt;code&gt;p&lt;/code&gt; 는 호출 된 객체를 나타냅니다. &lt;code&gt;Polynomial&lt;/code&gt; 다음과 같이 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5dcfe9bbe8a4c7456c17e6110860bb059bdd4a91" translate="yes" xml:space="preserve">
          <source>Notice that the result contains &lt;code&gt;$x&lt;/code&gt;, which means that &lt;code&gt;x&lt;/code&gt; has not been evaluated yet. In other words, the &lt;code&gt;$&lt;/code&gt; expression &quot;belongs to&quot; the inner quote expression, and so its argument is only evaluated when the inner quote expression is:</source>
          <target state="translated">결과에 &lt;code&gt;$x&lt;/code&gt; 가 포함되어 있습니다 . 이는 &lt;code&gt;x&lt;/code&gt; 가 아직 평가되지 않았 음 을 의미합니다 . 즉, &lt;code&gt;$&lt;/code&gt; 표현식은 내부 따옴표 표현식에 &quot;속하므로&quot;내부 따옴표 표현식이 다음과 같은 경우에만 인수가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="96ff399952b84bc498d1458b6e85213e0bfa3829" translate="yes" xml:space="preserve">
          <source>Notice that the result contains &lt;code&gt;Expr(:$, :x)&lt;/code&gt;, which means that &lt;code&gt;x&lt;/code&gt; has not been evaluated yet. In other words, the &lt;code&gt;$&lt;/code&gt; expression &quot;belongs to&quot; the inner quote expression, and so its argument is only evaluated when the inner quote expression is:</source>
          <target state="translated">결과에 &lt;code&gt;Expr(:$, :x)&lt;/code&gt; 가 포함되어 있습니다 . 이는 &lt;code&gt;x&lt;/code&gt; 가 아직 평가되지 않았 음 을 의미합니다 . 즉, &lt;code&gt;$&lt;/code&gt; 표현식은 내부 인용 표현식에 속하므로, 내부 인용 표현식이 다음과 같은 경우에만 인수가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="54f09e2f65ad8085647006de1626ffad88dc6727" translate="yes" xml:space="preserve">
          <source>Notice that the stack trace now indicates the appropriate line number and the missing frame.</source>
          <target state="translated">스택 추적은 이제 적절한 줄 번호와 누락 된 프레임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aebc78ff444f4c01a4825c1a20cbd6cc86150c76" translate="yes" xml:space="preserve">
          <source>Notice that the vector returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; had 18 elements, while the vector returned by &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; only has 6. This is because, by default, &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt; removes any lower-level C functions from the stack. If you want to include stack frames from C calls, you can do it like this:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 의해 반환 된 벡터 에는 18 개의 요소가 있지만 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 벡터 에는 6 만 있습니다. 이는 기본적으로 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 가&lt;/a&gt; 하위 수준 C 함수를 스택에서 제거 하기 때문 입니다. C 호출의 스택 프레임을 포함하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="ee5ca2b2885fa1bdef7f82616fa1f043f50e8db7" translate="yes" xml:space="preserve">
          <source>Notice that this is an &lt;code&gt;IndexCartesian&lt;/code&gt; array, so we must manually define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; at the dimensionality of the array. Unlike the &lt;code&gt;SquaresVector&lt;/code&gt;, we are able to define &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, and so we can mutate the array:</source>
          <target state="translated">이것이 &lt;code&gt;IndexCartesian&lt;/code&gt; 배열이므로 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 수동으로 정의해야합니다 ! 배열의 차원에서. &lt;code&gt;SquaresVector&lt;/code&gt; 와는 달리 setindex 를 정의 할 수 있습니다 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;배열을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af83b123f16ac259b3fe0cc2827d1e1b4b21fb95" translate="yes" xml:space="preserve">
          <source>Notice that we added an error check to the top of the function. This code will be common to both versions, and is run-time code in both versions (it will be quoted and returned as an expression from the generated version). That means that the values and types of local variables are not available at code generation time &amp;ndash;- the code-generation code can only see the types of arguments.</source>
          <target state="translated">함수 상단에 오류 검사를 추가했습니다. 이 코드는 두 버전 모두에 공통적이며 두 버전 모두에서 런타임 코드입니다 (생성 된 버전에서 인용되어 표현식으로 반환 됨). 즉, 코드 생성시 로컬 변수의 값과 유형을 사용할 수 없습니다. &amp;ndash; 코드 생성 코드는 인수 유형 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c1a66b9e620afc51ecba417f9133040596ec1a" translate="yes" xml:space="preserve">
          <source>Notice that we have to be careful about the return type: &lt;code&gt;qsort&lt;/code&gt; expects a function returning a C &lt;code&gt;int&lt;/code&gt;, so we annotate the return type of the function to be sure it returns a &lt;code&gt;Cint&lt;/code&gt;.</source>
          <target state="translated">반환 유형에 대해주의해야합니다. &lt;code&gt;qsort&lt;/code&gt; 는 C &lt;code&gt;int&lt;/code&gt; 를 반환하는 함수를 기대 하므로 &lt;code&gt;Cint&lt;/code&gt; 를 반환하도록 함수의 반환 유형에 주석을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="97bfa30273f29d9ac1e683ece19a0a5356f6f5be" translate="yes" xml:space="preserve">
          <source>Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling &lt;code&gt;jl_array_dim&lt;/code&gt;) in order to read as idiomatic C code.</source>
          <target state="translated">Julia 배열은 1 기반 인덱싱을 사용하지만 C API는 관용적 C 코드로 읽기 위해 0 기반 인덱싱 (예 : &lt;code&gt;jl_array_dim&lt;/code&gt; 호출 )을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a732c1e34616f1731678500073f8d82eb56b429" translate="yes" xml:space="preserve">
          <source>Notice the extra set of parentheses in the definition of &lt;code&gt;gap&lt;/code&gt;. Without those, &lt;code&gt;gap&lt;/code&gt; would be a two-argument function, and this example would not work.</source>
          <target state="translated">&lt;code&gt;gap&lt;/code&gt; 정의에 추가 괄호 세트가 있습니다. 그것들이 없으면 &lt;code&gt;gap&lt;/code&gt; 은 두 개의 인수 함수가 될 것이며이 예제는 작동하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec2b0ac6f443d8a0c98a2d2f9939dd9325a7d1bb" translate="yes" xml:space="preserve">
          <source>Notice the extra set of parentheses in the definition of &lt;code&gt;range&lt;/code&gt;. Without those, &lt;code&gt;range&lt;/code&gt; would be a two-argument function, and this example would not work.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 정의에서 추가 괄호 세트를 확인하십시오 . 그것들이 없으면 &lt;code&gt;range&lt;/code&gt; 는 두 개의 인수 함수가 될 것이며이 예제는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f8d9d4ee1e20bc7f450236baf5646b01a058df8" translate="yes" xml:space="preserve">
          <source>Notice the feedback has changed. &lt;code&gt;dev/Example&lt;/code&gt; refers to the location of the newly created clone. If we look inside the &lt;code&gt;/tmp/tutorial&lt;/code&gt; directory, we will notice the following files:</source>
          <target state="translated">피드백이 변경되었습니다. &lt;code&gt;dev/Example&lt;/code&gt; 은 새로 생성 된 클론의 위치를 ​​나타냅니다. &lt;code&gt;/tmp/tutorial&lt;/code&gt; 디렉토리를 살펴보면 다음 파일을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a051068a64fb1c3e3e967fac93fc0840d028c92" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;@assert&lt;/code&gt; has two modes of operation, depending upon the number of arguments it receives! If there's only one argument, the tuple of expressions captured by &lt;code&gt;msgs&lt;/code&gt; will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">이제 &lt;code&gt;@assert&lt;/code&gt; 는 수신하는 인수의 수에 따라 두 가지 작동 모드가 있습니다! 인수가 하나만있는 경우 &lt;code&gt;msgs&lt;/code&gt; 에 의해 캡처 된 표현식의 튜플은 비어 있고 위의 간단한 정의와 동일하게 작동합니다. 그러나 이제 사용자가 두 번째 인수를 지정하면 실패한 표현식 대신 메시지 본문에 인쇄됩니다. &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt; 매크로 라는 적절한 이름으로 매크로 확장 결과를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e2231a9957a4ccae243c25509bec2784a2d3a3f" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;OrderedPair&lt;/code&gt; objects can only be constructed such that &lt;code&gt;x &amp;lt;= y&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;OrderedPair&lt;/code&gt; 객체는 &lt;code&gt;x &amp;lt;= y&lt;/code&gt; 가되도록 만 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40de368ecfa7c73caca67b96df391a19f1bf239e" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;Point{Float64}&lt;/code&gt; and &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; are implementations of the &lt;code&gt;Pointy{Float64}&lt;/code&gt; abstraction, and similarly for every other possible choice of type &lt;code&gt;T&lt;/code&gt;. This allows programming to a common interface shared by all &lt;code&gt;Pointy&lt;/code&gt; objects, implemented for both &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;DiagPoint&lt;/code&gt;. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Point{Float64}&lt;/code&gt; 및 &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; 는 &lt;code&gt;Pointy{Float64}&lt;/code&gt; 추상화 의 구현이며 &lt;code&gt;T&lt;/code&gt; 유형의 다른 모든 가능한 선택에 대해서도 유사합니다 . 이를 통해 &lt;code&gt;Point&lt;/code&gt; 및 &lt;code&gt;DiagPoint&lt;/code&gt; 모두에 대해 구현 된 모든 &lt;code&gt;Pointy&lt;/code&gt; 객체가 공유하는 공통 인터페이스로 프로그래밍 할 수 있습니다 . 그러나 다음 섹션 인 &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; 에서 메소드와 디스패치를 ​​도입하기 전까지는이를 완전히 설명 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ad75dff988cb9333f0487b17ce167ce88105dcde" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;Point{Float64}&lt;/code&gt; and &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; are implementations of the &lt;code&gt;Pointy{Float64}&lt;/code&gt; abstraction, and similarly for every other possible choice of type &lt;code&gt;T&lt;/code&gt;. This allows programming to a common interface shared by all &lt;code&gt;Pointy&lt;/code&gt; objects, implemented for both &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;DiagPoint&lt;/code&gt;. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Point{Float64}&lt;/code&gt; 및 &lt;code&gt;DiagPoint{Float64}&lt;/code&gt; 는 &lt;code&gt;Pointy{Float64}&lt;/code&gt; 추상화 의 구현이며, 다른 가능한 모든 &lt;code&gt;T&lt;/code&gt; 유형 선택에 대해서도 유사합니다 . 이를 통해 &lt;code&gt;Point&lt;/code&gt; 및 &lt;code&gt;DiagPoint&lt;/code&gt; 모두에 대해 구현 된 모든 &lt;code&gt;Pointy&lt;/code&gt; 객체가 공유하는 공통 인터페이스로 프로그래밍 할 수 있습니다 . 그러나 다음 섹션 인 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; 에서 메소드를 소개하고 디스패치 할 때까지는 완전히 설명 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0a8eb478caf8225997c8cf2d8c6dbbb955a7809c" translate="yes" xml:space="preserve">
          <source>Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above of preferred declaration types. Do you see it? The function we are calling is going to free the memory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption). Therefore, it may be preferable to declare the &lt;code&gt;p&lt;/code&gt; type as &lt;code&gt;Ptr{gsl_permutation }&lt;/code&gt;, to make it harder for the user to mistakenly pass another sort of object there than one obtained via &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;.</source>
          <target state="translated">이제이 예제를 자세히 살펴보면 위의 기본 선언 유형에 대한 설명을 볼 때 잘못된 것을 알 수 있습니다. 보이나요? 우리가 호출하는 함수는 메모리를 해제하는 것입니다. 이 유형의 작업에는 Julia 개체를 지정할 수 없습니다 (충돌하거나 메모리 손상을 유발 함). 따라서 사용자가 &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; 을 통해 얻은 것보다 다른 종류의 객체를 실수로 전달하는 것을 더 어렵게 만들기 위해 &lt;code&gt;p&lt;/code&gt; 유형을 &lt;code&gt;Ptr{gsl_permutation }&lt;/code&gt; 로 선언하는 것이 바람직 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a75f16af32eb0cb857152589e2956bb0503dad48" translate="yes" xml:space="preserve">
          <source>Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, &lt;code&gt;2014-02-28 + Month(1) == 2014-03-28&lt;/code&gt;. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we're done because that's a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:</source>
          <target state="translated">이제 7-7-7 대신 슬롯이 Year-Month-Day 또는이 예에서는 2014-01-31이라고 상상해보십시오. 이 날짜에 1 개월을 추가하도록 요청하면 월 슬롯이 증가하므로 이제 2014-02-31이됩니다. 그런 다음 요일 번호가 새 달의 마지막 유효 날짜보다 큰지 확인합니다. 이 경우 (위의 경우와 같이) 날짜 번호는 마지막 유효 날짜 (28)로 조정됩니다. 이 접근 방식의 결과는 무엇입니까? 계속해서 날짜에 다른 달을 추가하십시오 &lt;code&gt;2014-02-28 + Month(1) == 2014-03-28&lt;/code&gt; . 뭐? 3 월 마지막 날을 기대 했습니까? 죄송합니다. 7-7-7 슬롯을 기억하십시오. 가능한 한 적은 수의 슬롯이 변경되므로 먼저 월 슬롯을 2014-03-28로 1 씩 늘리면 붐이 발생합니다. 유효한 날짜이므로 완료되었습니다. 반면에 원래 날짜 인 2014-01-31에 2 개월을 추가하면 예상대로 2014-03-31이됩니다. 이 접근법의 다른 결과는 특정 순서가 강요 될 때 연관성이 상실된다는 것입니다 (즉, 다른 순서로 물건을 추가하면 다른 결과가 나타납니다). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11ea30dca65a438cc99f25502ce5c85d174da718" translate="yes" xml:space="preserve">
          <source>Now let us call a Julia function that performs an in-place operation on &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;x&lt;/code&gt; 에 대해 적절한 작업을 수행하는 Julia 함수를 호출하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1b1490ef0eb4ce2e4e1ae0d6c5f4d04bddc62f73" translate="yes" xml:space="preserve">
          <source>Now let's compare three different versions, one that runs in a single process:</source>
          <target state="translated">이제 단일 프로세스에서 실행되는 세 가지 버전을 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bd4926e8c07582ea5f2f0956525f2f77d29572cb" translate="yes" xml:space="preserve">
          <source>Now that you know the rules, let's look at some examples. Each example is assumed to be evaluated in a fresh REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.</source>
          <target state="translated">이제 규칙을 알았으니 몇 가지 예를 살펴 보겠습니다. 각 예제는 새로운 REPL 세션에서 평가되는 것으로 가정하여 각 조각의 유일한 전역은 해당 코드 블록에 할당 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e900fad91950a54e7a71c41febff0c0a6fca83" translate="yes" xml:space="preserve">
          <source>Now the build command is simply &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">이제 빌드 명령은 단순히 &lt;code&gt;make&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5c8889e683ee7699980eb83ade02cdbbcf851154" translate="yes" xml:space="preserve">
          <source>Now the content of &lt;code&gt;y&lt;/code&gt; can be accessed as before using &lt;code&gt;jl_array_data&lt;/code&gt;. As always, be sure to keep a reference to the array while it is in use.</source>
          <target state="translated">이제 &lt;code&gt;y&lt;/code&gt; 의 내용은 &lt;code&gt;jl_array_data&lt;/code&gt; 를 사용하기 전과 같이 액세스 할 수 있습니다 . 항상 그렇듯이 어레이가 사용 중일 때 어레이에 대한 참조를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="57cfaa73ec119cde1094487639ea3b5c37a52882" translate="yes" xml:space="preserve">
          <source>Now things get interesting. &lt;code&gt;OurRational&lt;/code&gt; has a single inner constructor method which checks that both of &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; aren't zero and ensures that every rational is constructed in &quot;lowest terms&quot; with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the &lt;code&gt;gcd&lt;/code&gt; function. Since &lt;code&gt;gcd&lt;/code&gt; returns the greatest common divisor of its arguments with sign matching the first argument (&lt;code&gt;den&lt;/code&gt; here), after this division the new value of &lt;code&gt;den&lt;/code&gt; is guaranteed to be non-negative. Because this is the only inner constructor for &lt;code&gt;OurRational&lt;/code&gt;, we can be certain that &lt;code&gt;OurRational&lt;/code&gt; objects are always constructed in this normalized form.</source>
          <target state="translated">이제 상황이 재미있어집니다. &lt;code&gt;OurRational&lt;/code&gt; 에는 &lt;code&gt;num&lt;/code&gt; 과 &lt;code&gt;den&lt;/code&gt; 이 모두 0이 아닌지 확인하고 모든 음수가 음수가 아닌 분모를 사용하여 &quot;가장 낮은 용어&quot;로 구성되도록 하는 단일 내부 생성자 메소드가 있습니다. 이것은 주어진 분자와 분모 값을 &lt;code&gt;gcd&lt;/code&gt; 함수를 사용하여 계산 된 최대 공약수로 나눔으로써 달성됩니다 . 이후 &lt;code&gt;gcd&lt;/code&gt; 기호가 첫 번째 인수를 (일치하는 인수의 최대 공약수를 반환 &lt;code&gt;den&lt;/code&gt; 여기)이 분열 이후의 새로운 값 &lt;code&gt;den&lt;/code&gt; 음이 아닌 것으로 보장된다. 이것이 &lt;code&gt;OurRational&lt;/code&gt; 의 유일한 내부 생성자이기 때문에우리는 것을 확신 할 수 &lt;code&gt;OurRational&lt;/code&gt; 객체는 항상이 표준화 된 형태로 구성된다.</target>
        </trans-unit>
        <trans-unit id="7b1ac0d5470c2a73e8cced73d80392647d1e7c34" translate="yes" xml:space="preserve">
          <source>Now we add some new methods to &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;f(x)&lt;/code&gt; 새로운 메소드를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="2194482dd2eece4f043c167b6dbcda9beed128b2" translate="yes" xml:space="preserve">
          <source>Now we can fill the array:</source>
          <target state="translated">이제 배열을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dedd2e54cefbc13f3e2721f321d1470bf85ad17e" translate="yes" xml:space="preserve">
          <source>Now we can go back to the Julia REPL and load the package:</source>
          <target state="translated">이제 Julia REPL로 돌아가서 패키지를로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8c5d4cd8d7eaa41a61a84bdaaaa49e76aabe6887" translate="yes" xml:space="preserve">
          <source>Now we will time each of these functions using the same random &lt;code&gt;10000&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt; input vector:</source>
          <target state="translated">이제 동일한 임의의 &lt;code&gt;10000&lt;/code&gt; x &lt;code&gt;1&lt;/code&gt; 입력 벡터를 사용하여 각 함수의 시간을 정합니다 .</target>
        </trans-unit>
        <trans-unit id="f4a2c37f0e6c8ad902d4b308d7bdc8bae7e4b278" translate="yes" xml:space="preserve">
          <source>Now we're ready to profile this function:</source>
          <target state="translated">이제이 함수를 프로파일 링 할 준비가되었습니다 :</target>
        </trans-unit>
        <trans-unit id="e180693c6ce8b7b630dbe4c747b6eac35d812d82" translate="yes" xml:space="preserve">
          <source>Now you have a multitude of ways to employ those tools! For example with &lt;code&gt;OProfile&lt;/code&gt; you can try a simple recording :</source>
          <target state="translated">이제 이러한 도구를 사용할 수있는 다양한 방법이 있습니다! 예를 들어 &lt;code&gt;OProfile&lt;/code&gt; 을 사용 하면 간단한 녹음을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ad9c62852c43e82e47fc64421d617168397764" translate="yes" xml:space="preserve">
          <source>Now, consider a slightly more complex macro:</source>
          <target state="translated">이제 좀 더 복잡한 매크로를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="48984640e1b770182f7f589e3d658df61fc570eb" translate="yes" xml:space="preserve">
          <source>Now, one very good way to solve such problems is by using the &lt;a href=&quot;#kernel-functions&quot;&gt;function-barrier technique&lt;/a&gt;. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through &lt;code&gt;Val{T}()&lt;/code&gt; (see &quot;Value types&quot;):</source>
          <target state="translated">이제 이러한 문제를 해결하는 아주 좋은 방법 중 하나는 &lt;a href=&quot;#kernel-functions&quot;&gt;기능 장벽 기술&lt;/a&gt; 을 사용하는 것 입니다. 그러나 어떤 경우에는 유형 불안정성을 완전히 제거해야 할 수도 있습니다. 이러한 경우 한 가지 방법은 예를 들어 &lt;code&gt;Val{T}()&lt;/code&gt; 를 통해 차원을 매개 변수로 전달하는 것입니다 ( &quot;값 유형&quot;참조).</target>
        </trans-unit>
        <trans-unit id="4732b371dc166e4779a2688d805a6aba6fbd8acb" translate="yes" xml:space="preserve">
          <source>Now, one very good way to solve such problems is by using the &lt;a href=&quot;#kernel-functions-1&quot;&gt;function-barrier technique&lt;/a&gt;. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through &lt;code&gt;Val{T}()&lt;/code&gt; (see &quot;Value types&quot;):</source>
          <target state="translated">이제 이러한 문제를 해결하는 가장 좋은 방법은 &lt;a href=&quot;#kernel-functions-1&quot;&gt;함수 장벽 기술&lt;/a&gt; 을 사용하는 것 입니다. 그러나 경우에 따라 형식 불안정성을 완전히 제거 할 수도 있습니다. 이러한 경우에 한 가지 방법은 차원을 매개 변수로 전달하는 것입니다 (예 : &lt;code&gt;Val{T}()&lt;/code&gt; ( &quot;값 유형&quot;참조).</target>
        </trans-unit>
        <trans-unit id="6504cb22c421f4ddf0b407eb1bc7db394b17968b" translate="yes" xml:space="preserve">
          <source>Now, suppose that we have a 1-d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we consider calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function:</source>
          <target state="translated">이제 줄리아의 내장 &lt;code&gt;sort&lt;/code&gt; 함수가 아닌 &lt;code&gt;qsort&lt;/code&gt; 함수를 사용하여 정렬하려는 Julia에 값 의 1-d 배열 &lt;code&gt;A&lt;/code&gt; 가 있다고 가정합니다 . &lt;code&gt;qsort&lt;/code&gt; 호출 및 인수 전달 을 고려하기 전에 비교 함수를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="21f06871f5b7030283f5fa9adc372a9eca6b71e0" translate="yes" xml:space="preserve">
          <source>Now, when we ask Julia to &lt;code&gt;collect&lt;/code&gt; all the elements into an array it can preallocate a &lt;code&gt;Vector{Int}&lt;/code&gt; of the right size instead of blindly &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;ing each element into a &lt;code&gt;Vector{Any}&lt;/code&gt;:</source>
          <target state="translated">이제 Julia에게 모든 요소를 ​​배열로 &lt;code&gt;collect&lt;/code&gt; 하도록 요청하면 맹목적으로 &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt; 않고 올바른 크기의 &lt;code&gt;Vector{Int}&lt;/code&gt; 를 미리 할당 할 수 있습니다 ! 각 요소를 &lt;code&gt;Vector{Any}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d636f6dac8ab2c27d31703e43f4beef4b1d56310" translate="yes" xml:space="preserve">
          <source>Number of bits</source>
          <target state="translated">비트 수</target>
        </trans-unit>
        <trans-unit id="d91909ed1368e10bc84773d139187c5b722b5f11" translate="yes" xml:space="preserve">
          <source>Number of elements</source>
          <target state="translated">요소 수</target>
        </trans-unit>
        <trans-unit id="a9fc237be2cc9c335682ad011ee2e6adc0acaa38" translate="yes" xml:space="preserve">
          <source>Number of indices</source>
          <target state="translated">인덱스 수</target>
        </trans-unit>
        <trans-unit id="f85da1dd5129fe724d5c6d8cf4b7906fe8b9ce5c" translate="yes" xml:space="preserve">
          <source>Number of ones in the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현에서 1의 수 .</target>
        </trans-unit>
        <trans-unit id="e30f19e99bb31f0cd0b6205f5f10b8b22424243a" translate="yes" xml:space="preserve">
          <source>Number of ones leading the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현을 이끄는 것의 수 .</target>
        </trans-unit>
        <trans-unit id="035d70cdae066ea3296b8fbd1a9d8c92fa39c6e4" translate="yes" xml:space="preserve">
          <source>Number of ones trailing the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현을 따르는 사람의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f0f8c6eb690602177ade028609fa24bb9574fa5a" translate="yes" xml:space="preserve">
          <source>Number of zeros in the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현에서 0의 개수입니다 .</target>
        </trans-unit>
        <trans-unit id="8579d9f6447af083975c0dab9070490c43548e77" translate="yes" xml:space="preserve">
          <source>Number of zeros leading the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현을 이끄는 0의 개수입니다 .</target>
        </trans-unit>
        <trans-unit id="8260cb1716ffd3b4779fd5a8ebf394508c0f77f9" translate="yes" xml:space="preserve">
          <source>Number of zeros trailing the binary representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 이진 표현을 따르는 0의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="28e471b5b867e86ef185edcc27daa9110d23a890" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value denoted by the symbol &lt;code&gt;sym&lt;/code&gt;.</source>
          <target state="translated">기호 &lt;code&gt;sym&lt;/code&gt; 로 표시되는 정확한 비합리적인 값을 나타내는 숫자 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fa5da0a005eba7aae00bc09dde0c276025c12077" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value, which is automatically rounded to the correct precision in arithmetic operations with other numeric quantities.</source>
          <target state="translated">정확한 비합리적 값을 나타내는 숫자 유형으로, 다른 숫자 수량과 함께 산술 연산에서 올바른 정밀도로 자동 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="b9fe47bf2edbb12c61a5e953edc8a563d56b03f2" translate="yes" xml:space="preserve">
          <source>Number type representing an exact irrational value.</source>
          <target state="translated">정확한 비합리적인 값을 나타내는 숫자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1bd59bcc0babee970cc108b465cace01d488a590" translate="yes" xml:space="preserve">
          <source>Numbered capture groups can also be referenced as &lt;code&gt;\g&amp;lt;n&amp;gt;&lt;/code&gt; for disambiguation, as in:</source>
          <target state="translated">번호가 매겨진 캡처 그룹은 다음 과 같이 명확성을 위해 &lt;code&gt;\g&amp;lt;n&amp;gt;&lt;/code&gt; 으로 참조 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="dbf34012797cab9d1c84ad002d9b7fc6caeff4db" translate="yes" xml:space="preserve">
          <source>Numerator of the rational representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 합리적인 표현의 분자 .</target>
        </trans-unit>
        <trans-unit id="f269beab01cd6fcbe0ca0957b8e26bbc71c51503" translate="yes" xml:space="preserve">
          <source>Numeric Comparisons</source>
          <target state="translated">숫자 비교</target>
        </trans-unit>
        <trans-unit id="2daff25d81f34cfefe8596ae71656e7ff1f338f4" translate="yes" xml:space="preserve">
          <source>Numeric Literal Coefficients</source>
          <target state="translated">숫자 리터럴 계수</target>
        </trans-unit>
        <trans-unit id="39da4e1b4b9cefed18b0fa29568809b13a0d2a02" translate="yes" xml:space="preserve">
          <source>Numeric literals also work as coefficients to parenthesized expressions:</source>
          <target state="translated">숫자 리터럴은 괄호로 묶은 표현식에 대한 계수로도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="96a577a413493fbb35d59ebbc8fd8ccf1b95bd62" translate="yes" xml:space="preserve">
          <source>Numeric month with a minimum width</source>
          <target state="translated">최소 너비가있는 숫자 월</target>
        </trans-unit>
        <trans-unit id="b7bba39c17a5546a2869dc25f44284097be19715" translate="yes" xml:space="preserve">
          <source>Numeric year with a fixed width</source>
          <target state="translated">너비가 고정 된 연도</target>
        </trans-unit>
        <trans-unit id="f856346ac1bcf4a72d2933fe28689ea60a5e0a43" translate="yes" xml:space="preserve">
          <source>Numeric year with a minimum width</source>
          <target state="translated">최소 너비의 숫자 연도</target>
        </trans-unit>
        <trans-unit id="b4d5eae4bb697e0cf7a429c34af1a89533647ce7" translate="yes" xml:space="preserve">
          <source>Numerical Conversions</source>
          <target state="translated">수치 변환</target>
        </trans-unit>
        <trans-unit id="67318deb09e2a0233296c2abeb6ce49da2c728ec" translate="yes" xml:space="preserve">
          <source>Numero Sign / Numero</source>
          <target state="translated">Numero Sign / 누 메로</target>
        </trans-unit>
        <trans-unit id="8005cd0fe11a7ac4eb3676a4ba6c81565fe4a74a" translate="yes" xml:space="preserve">
          <source>Nut And Bolt</source>
          <target state="translated">너트와 볼트</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="93a1ab27a3b22e4b47afb67c1ce3d45df066fb66" translate="yes" xml:space="preserve">
          <source>Objects are printed at the REPL using the &lt;code&gt;show&lt;/code&gt; function with a specific &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;. In particular, the &lt;code&gt;:limit&lt;/code&gt; attribute is set to &lt;code&gt;true&lt;/code&gt;. Other attributes can receive in certain &lt;code&gt;show&lt;/code&gt; methods a default value if it's not already set, like &lt;code&gt;:compact&lt;/code&gt;. It's possible, as an experimental feature, to specify the attributes used by the REPL via the &lt;code&gt;Base.active_repl.options.iocontext&lt;/code&gt; dictionary (associating values to attributes). For example:</source>
          <target state="translated">객체는 특정 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;show&lt;/code&gt; 함수를 사용하여 REPL에서 인쇄됩니다 . 특히 &lt;code&gt;:limit&lt;/code&gt; 속성은 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 . 다른 속성은 &lt;code&gt;:compact&lt;/code&gt; 와 같이 아직 설정되지 않은 경우 특정 &lt;code&gt;show&lt;/code&gt; 메서드에서 기본값을 받을 수 있습니다 . 실험적 기능으로 &lt;code&gt;Base.active_repl.options.iocontext&lt;/code&gt; 사전을 통해 REPL에서 사용하는 속성을 지정할 수 있습니다 (값을 속성에 연결). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="556a4054d8bd5ec84efc369a4b546d910bc81a6b" translate="yes" xml:space="preserve">
          <source>Objects created by calling &lt;code&gt;skipmissing&lt;/code&gt; on an array can be indexed using indices from the parent array. Indices corresponding to missing values are not valid for these objects and an error is thrown when trying to use them (they are also skipped by &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;eachindex&lt;/code&gt;)</source>
          <target state="translated">배열에서 &lt;code&gt;skipmissing&lt;/code&gt; 을 호출하여 만든 개체 는 부모 배열의 인덱스를 사용하여 인덱싱 할 수 있습니다. 결 측값에 해당하는 색인은 이러한 객체에 유효하지 않으며이를 사용하려고 할 때 오류가 발생합니다 ( &lt;code&gt;keys&lt;/code&gt; 및 각 &lt;code&gt;eachindex&lt;/code&gt; 건너 뛰기도 함 )</target>
        </trans-unit>
        <trans-unit id="0bd56de9465fbf7f137d6e37169c5645c43a0700" translate="yes" xml:space="preserve">
          <source>Objects referred to by remote references can be freed only when &lt;em&gt;all&lt;/em&gt; held references in the cluster are deleted.</source>
          <target state="translated">원격 참조가 참조하는 오브젝트 는 클러스터의 &lt;em&gt;모든&lt;/em&gt; 보유 참조가 삭제 된 경우에만 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed0dbb8b43412ba667073b4f0e06db426a942a6" translate="yes" xml:space="preserve">
          <source>Oblique Angle Opening Down</source>
          <target state="translated">경사각 개방</target>
        </trans-unit>
        <trans-unit id="860d5d210e89bd48c50cf3489fe9ae16e754805a" translate="yes" xml:space="preserve">
          <source>Oblique Angle Opening Up</source>
          <target state="translated">비스듬한 각도</target>
        </trans-unit>
        <trans-unit id="e48da80ca4c53858a37fe7a1f6c71c784aca6c04" translate="yes" xml:space="preserve">
          <source>Observe the following specific instances of these rules in our example:</source>
          <target state="translated">이 예제에서 다음 규칙의 특정 인스턴스를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="8a73a94f9cbd7863f359e15c75973f71824c00fb" translate="yes" xml:space="preserve">
          <source>Observe, that this definition calls another method of &lt;code&gt;Date&lt;/code&gt; function that takes one argument of &lt;code&gt;UTInstant{Day}&lt;/code&gt; type.</source>
          <target state="translated">이 정의 는 &lt;code&gt;UTInstant{Day}&lt;/code&gt; 유형의 인수 하나를 취하는 다른 &lt;code&gt;Date&lt;/code&gt; 함수 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b01fccba9afe7b3a5889d5a451ef90eca8e87545" translate="yes" xml:space="preserve">
          <source>Observe, that this definition calls another method of the &lt;code&gt;Date&lt;/code&gt; function that takes one argument of type &lt;code&gt;UTInstant{Day}&lt;/code&gt;.</source>
          <target state="translated">이 정의는 &lt;code&gt;UTInstant{Day}&lt;/code&gt; 유형의 인수 하나 를 사용하는 &lt;code&gt;Date&lt;/code&gt; 함수 의 다른 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="395a4e1c3075ee49f92be819610b463cda6e30f5" translate="yes" xml:space="preserve">
          <source>Observing any mutable state.</source>
          <target state="translated">변경 가능한 상태를 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="9fefcd102a7e155e0fdf1ae0996358a339e34548" translate="yes" xml:space="preserve">
          <source>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in &lt;a href=&quot;#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. Returns a &lt;code&gt;Ptr{Type}&lt;/code&gt;, defaulting to &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; if no &lt;code&gt;Type&lt;/code&gt; argument is supplied. The values can be read or written by &lt;a href=&quot;#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">C-exported 공유 라이브러리에서 &lt;a href=&quot;#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 과 정확하게 지정된 전역 변수에 대한 포인터를 가져옵니다 . &lt;code&gt;Type&lt;/code&gt; 인수가 제공 되지 않으면 &lt;code&gt;Ptr{Type}&lt;/code&gt; 을 기본값으로 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 리턴합니다 . &lt;a href=&quot;#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt; 로 값을 읽거나 쓸 수 있습니다 ! 각각.</target>
        </trans-unit>
        <trans-unit id="af546b114320fe8198ff3e12bb225650fba5d32f" translate="yes" xml:space="preserve">
          <source>Obtain a vector-like object containing the code units of a string. Returns a &lt;code&gt;CodeUnits&lt;/code&gt; wrapper by default, but &lt;code&gt;codeunits&lt;/code&gt; may optionally be defined for new string types if necessary.</source>
          <target state="translated">문자열의 코드 단위를 포함하는 벡터와 유사한 객체를 얻습니다. 반환은 &lt;code&gt;CodeUnits&lt;/code&gt; 은 기본적으로 래퍼하지만 &lt;code&gt;codeunits&lt;/code&gt; 이 필요한 경우 선택적으로 새 문자열 유형에 대해 정의 할 수있다.</target>
        </trans-unit>
        <trans-unit id="4841adee9120f8d2d8a65cdf75b380276d57ffea" translate="yes" xml:space="preserve">
          <source>Obtain the contents of an &lt;code&gt;IOBuffer&lt;/code&gt; as an array, without copying. Afterwards, the &lt;code&gt;IOBuffer&lt;/code&gt; is reset to its initial state.</source>
          <target state="translated">복사하지 않고 &lt;code&gt;IOBuffer&lt;/code&gt; 의 내용을 배열로 가져옵니다. 그 후 &lt;code&gt;IOBuffer&lt;/code&gt; 는 초기 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="499a51c422bbaa71f462d60ecac6f2d85b8b0346" translate="yes" xml:space="preserve">
          <source>Obtain the path of a temporary directory (possibly shared with other processes).</source>
          <target state="translated">임시 디렉토리의 경로를 확보하십시오 (다른 프로세스와 공유 가능).</target>
        </trans-unit>
        <trans-unit id="4489831ce34c02ca381337736e9c9e00ae27d366" translate="yes" xml:space="preserve">
          <source>Obtain the raw bytes of the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; as a vector of length 20.</source>
          <target state="translated">길이 20의 벡터로 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 의 원시 바이트를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="7f2ec1740404502e15faeec6b56d86fabcab7ff3" translate="yes" xml:space="preserve">
          <source>Obviously the intention is to modify the existing global variable &lt;code&gt;s&lt;/code&gt;. What else could it mean? However, not all real world code is so short or so clear. We found that code like the following often occurs in the wild:</source>
          <target state="translated">분명히 의도는 기존의 전역 변수 수정하는 것입니다 &lt;code&gt;s&lt;/code&gt; . 또 무슨 의미일까요? 그러나 모든 실제 코드가 너무 짧거나 명확하지는 않습니다. 우리는 다음과 같은 코드가 종종 야생에서 발생한다는 것을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="bb6c798b8d29e94d3a8c1ad40f4212ec50bc5a9a" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty &lt;code&gt;function&lt;/code&gt; block without a tuple of arguments:</source>
          <target state="translated">때때로 메소드를 추가하지 않고 일반 함수를 도입하는 것이 유용합니다. 인터페이스 정의와 구현을 분리하는 데 사용할 수 있습니다. 문서화 또는 코드 가독성을 위해 수행 될 수도 있습니다. 이에 대한 구문 은 튜플 인수가없는 빈 &lt;code&gt;function&lt;/code&gt; 블록입니다.</target>
        </trans-unit>
        <trans-unit id="97d43ad70625a66b6b94ccb7dc102bc0d4e9d113" translate="yes" xml:space="preserve">
          <source>Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function &lt;code&gt;remotecall_fetch&lt;/code&gt; exists for this purpose. It is equivalent to &lt;code&gt;fetch(remotecall(...))&lt;/code&gt; but is more efficient.</source>
          <target state="translated">때때로 원격으로 계산 된 값을 즉시 원할 수도 있습니다. 이는 일반적으로 다음 로컬 조작에 필요한 데이터를 얻기 위해 원격 오브젝트에서 읽을 때 발생합니다. 이 목적으로 &lt;code&gt;remotecall_fetch&lt;/code&gt; 함수 가 존재합니다. 와 같습니다 &lt;code&gt;fetch(remotecall(...))&lt;/code&gt; 하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dc514d9dce6f845463dfbbd8fec27b149487fc06" translate="yes" xml:space="preserve">
          <source>Octal bytes (&lt;code&gt;\&lt;/code&gt; with 1-3 trailing octal digits)</source>
          <target state="translated">진수 바이트 ( &lt;code&gt;\&lt;/code&gt; 1-3 후행 진수 자리)</target>
        </trans-unit>
        <trans-unit id="c10a60e4dac35159da0056b94059aa3faefeaefe" translate="yes" xml:space="preserve">
          <source>Octopus</source>
          <target state="translated">Octopus</target>
        </trans-unit>
        <trans-unit id="d9359b5c701400516289c8d3362bab9584e8cb81" translate="yes" xml:space="preserve">
          <source>Oden</source>
          <target state="translated">Oden</target>
        </trans-unit>
        <trans-unit id="4ee7b7b8b904fd04e80da6c64df0a8e87c0a1ba8" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;rand&lt;/code&gt; must also be defined on those types (i.e. &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; and &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt;).</source>
          <target state="translated">물론 &lt;code&gt;rand&lt;/code&gt; 는 이러한 유형 (예 : &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; 및 &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt; ) 에서도 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9135bc9aed14b8eb1de1f8f45ce9be4516707837" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;rand&lt;/code&gt; must also be defined on those types (i.e. &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; and &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt;). Note that, as usual, &lt;code&gt;SamplerTrivial&lt;/code&gt; and &lt;code&gt;SamplerSimple&lt;/code&gt; can be used if custom types are not necessary.</source>
          <target state="translated">물론 &lt;code&gt;rand&lt;/code&gt; 는 이러한 유형에 대해서도 정의되어야합니다 (예 : &lt;code&gt;rand(::AbstractRNG, ::SamplerDie1)&lt;/code&gt; 및 &lt;code&gt;rand(::AbstractRNG, ::SamplerDieMany)&lt;/code&gt; ). 평소와 같이 사용자 지정 형식이 필요하지 않은 경우 &lt;code&gt;SamplerTrivial&lt;/code&gt; 및 &lt;code&gt;SamplerSimple&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5457388ab13abcc6abec066af3e04c777b0d8df3" translate="yes" xml:space="preserve">
          <source>Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do &amp;ndash; and all they do is construct expression objects to be inserted into your program's syntax tree.</source>
          <target state="translated">물론,이 매크로 정의에 사용 된 함수에는 많은 복잡성이 숨겨져 있지만, 이들은 Julia로만 작성된 함수일뿐입니다. 소스를 읽고 정확히 무엇을하는지 확인할 수 있으며 프로그램 구문 트리에 삽입 할 표현식 객체를 구성하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="72d7295c70e56e8466ad32c5214d78627a9bd51e" translate="yes" xml:space="preserve">
          <source>Of course, all of this is true only if we construct &lt;code&gt;m&lt;/code&gt; with a concrete type. We can break this by explicitly constructing it with an abstract type:</source>
          <target state="translated">물론,이 모든 것은 우리 가 구체적인 유형으로 &lt;code&gt;m&lt;/code&gt; 을 구성하는 경우에만 적용됩니다 . 우리는 이것을 추상 타입으로 명시 적으로 구성함으로써 이것을 깨뜨릴 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="abca40c2892b53eaf0d0eec2e63897278688a5d5" translate="yes" xml:space="preserve">
          <source>Of course, in a purely linear function body like &lt;code&gt;g&lt;/code&gt;, the usage of &lt;code&gt;return&lt;/code&gt; is pointless since the expression &lt;code&gt;x + y&lt;/code&gt; is never evaluated and we could simply make &lt;code&gt;x * y&lt;/code&gt; the last expression in the function and omit the &lt;code&gt;return&lt;/code&gt;. In conjunction with other control flow, however, &lt;code&gt;return&lt;/code&gt; is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, avoiding overflow:</source>
          <target state="translated">물론, &lt;code&gt;g&lt;/code&gt; 와 같은 순수 선형 함수 본문에서 , &lt;code&gt;x + y&lt;/code&gt; 표현식 은 절대 평가되지 않기 때문에 &lt;code&gt;return&lt;/code&gt; 사용법은 의미 가 없으며 &lt;code&gt;x * y&lt;/code&gt; 함수의 마지막 표현식으로 만들고 &lt;code&gt;return&lt;/code&gt; 생략 할 수 있습니다. 그러나 다른 제어 흐름과 함께 &lt;code&gt;return&lt;/code&gt; 이 실제로 사용됩니다. 예를 들어 다음은 오버플로를 피하면서 길이가 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 변을 가진 직각 삼각형의 빗변 길이를 계산하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="c060c4ee5f5d3d9b28299a96d5d24b90afefae70" translate="yes" xml:space="preserve">
          <source>Of course, this depends on what &lt;code&gt;Int&lt;/code&gt; is aliased to &amp;ndash; but that is predefined to be the correct type &amp;ndash; either &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">물론 이것은 &lt;code&gt;Int&lt;/code&gt; 의 별칭 에 따라 달라 지지만 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 중 올바른 유형으로 미리 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07abc77a1d3a227491552ba08254221470ef23ea" translate="yes" xml:space="preserve">
          <source>Of course, this pattern is so frequent that the helper type used above, namely &lt;code&gt;Random.SamplerSimple&lt;/code&gt;, is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">물론,이 패턴은 매우 빈번해서 위에서 사용 된 도우미 유형 인 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; 을 사용할 수 &lt;code&gt;SamplerDie&lt;/code&gt; 의 정의를 절약 할 수 있습니다. 다음과 같이 디커플링을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae308f41e4c98e31757bbb87283a37f1c3cd968" translate="yes" xml:space="preserve">
          <source>Of course, you can omit the dot if you write a specialized &quot;vector&quot; method of &lt;code&gt;f&lt;/code&gt;, e.g. via &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt;, and this is just as efficient as &lt;code&gt;f.(A)&lt;/code&gt;. But that approach requires you to decide in advance which functions you want to vectorize.</source>
          <target state="translated">당신의 전문 &quot;벡터&quot;방법을 쓰는 경우 물론, 당신은 점을 생략 할 수 &lt;code&gt;f&lt;/code&gt; 예를 통해 &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt; , 이것은 단지 효율적으로입니다 &lt;code&gt;f.(A)&lt;/code&gt; . 그러나이 방법을 사용하려면 벡터화 할 함수를 미리 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="831dc22cfdc3471ccd19f00c0d2e0d9502fd0034" translate="yes" xml:space="preserve">
          <source>Of course, you can omit the dot if you write a specialized &quot;vector&quot; method of &lt;code&gt;f&lt;/code&gt;, e.g. via &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt;, and this is just as efficient as &lt;code&gt;f.(A)&lt;/code&gt;. The advantage of the &lt;code&gt;f.(A)&lt;/code&gt; syntax is that which functions are vectorizable need not be decided upon in advance by the library writer.</source>
          <target state="translated">당신의 전문 &quot;벡터&quot;방법을 쓰는 경우 물론, 당신은 점을 생략 할 수 &lt;code&gt;f&lt;/code&gt; 예를 통해 &lt;code&gt;f(A::AbstractArray) = map(f, A)&lt;/code&gt; , 이것은 단지 효율적으로입니다 &lt;code&gt;f.(A)&lt;/code&gt; . &lt;code&gt;f.(A)&lt;/code&gt; 구문 의 장점 은 벡터화 할 수있는 함수를 라이브러리 작성자가 미리 결정할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bac1685b0fe25dd08856d4b861606712fb6d3693" translate="yes" xml:space="preserve">
          <source>Office Building</source>
          <target state="translated">사무실 건물</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="2257e26e0c9b9059b11804e45de12c297441ab86" translate="yes" xml:space="preserve">
          <source>Often &lt;code&gt;wait&lt;/code&gt; is called within a &lt;code&gt;while&lt;/code&gt; loop to ensure a waited-for condition is met before proceeding.</source>
          <target state="translated">종종 &lt;code&gt;wait&lt;/code&gt; 내에서 호출되는 &lt;code&gt;while&lt;/code&gt; 기다렸다-에 대한 조건을 계속하기 전에 충족하기 위해 루프.</target>
        </trans-unit>
        <trans-unit id="e3d60820a16fa72bfa32371eae9edc7f3327dc98" translate="yes" xml:space="preserve">
          <source>Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are &lt;code&gt;true&lt;/code&gt;. Indexing by a boolean vector &lt;code&gt;B&lt;/code&gt; is effectively the same as indexing by the vector of integers that is returned by &lt;code&gt;findall(B)&lt;/code&gt;. Similarly, indexing by a &lt;code&gt;N&lt;/code&gt;-dimensional boolean array is effectively the same as indexing by the vector of &lt;code&gt;CartesianIndex{N}&lt;/code&gt;s where its values are &lt;code&gt;true&lt;/code&gt;. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling &lt;code&gt;findall&lt;/code&gt;.</source>
          <target state="translated">논리 마스크를 사용한 논리적 인덱싱 또는 인덱싱이라고도하는 부울 배열에 의한 인덱싱은 값이 &lt;code&gt;true&lt;/code&gt; 인 인덱스에서 요소를 선택 합니다 . 부울 벡터 &lt;code&gt;B&lt;/code&gt; 에 의한 인덱싱은 &lt;code&gt;findall(B)&lt;/code&gt; 의해 반환되는 정수 벡터에 의한 인덱싱과 사실상 동일합니다 . 마찬가지로 &lt;code&gt;N&lt;/code&gt; 차원 부울 배열에 의한 인덱싱은 그 값이 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;CartesianIndex{N}&lt;/code&gt; 벡터에 의한 인덱싱과 사실상 동일 합니다.. 논리 색인은 색인을 생성하는 차원과 길이가 같은 벡터이거나 색인이 제공되는 배열의 크기 및 차원과 일치하는 유일한 색인이어야합니다. 먼저 &lt;code&gt;findall&lt;/code&gt; 을 호출하는 대신 부울 배열을 직접 인덱스로 사용하는 것이 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="edf1240e8d792d67e6dc46a33f81148bf56e1cc1" translate="yes" xml:space="preserve">
          <source>Often used as &lt;code&gt;setprecision(T, precision) do ... end&lt;/code&gt;</source>
          <target state="translated">종종 &lt;code&gt;setprecision(T, precision) do ... end&lt;/code&gt; 으로 사용됩니다 ... 끝</target>
        </trans-unit>
        <trans-unit id="b9fb34384bd74e18ded64446715a976c38fad361" translate="yes" xml:space="preserve">
          <source>Often, one wants to customize how instances of a type are displayed. This is accomplished by overloading the &lt;code&gt;show&lt;/code&gt; function. For example, suppose we define a type to represent complex numbers in polar form:</source>
          <target state="translated">종종 유형의 인스턴스가 표시되는 방법을 사용자 정의하려고합니다. 이것은 &lt;code&gt;show&lt;/code&gt; 함수 를 오버로드함으로써 달성됩니다 . 예를 들어, 복소수를 극수 형식으로 나타내는 유형을 정의한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2524666908366fb5b9cb1050fa0d98429c1b75dd" translate="yes" xml:space="preserve">
          <source>Ohm Sign / Ohm</source>
          <target state="translated">옴 사인 / 옴</target>
        </trans-unit>
        <trans-unit id="43861169e81020d9c0306dfe1f07fadd4b506cc8" translate="yes" xml:space="preserve">
          <source>Ok Hand Sign</source>
          <target state="translated">확인 손 기호</target>
        </trans-unit>
        <trans-unit id="9aeac8f5501f52ca5880e908db13ff62ecc66505" translate="yes" xml:space="preserve">
          <source>Older Man</source>
          <target state="translated">늙은이</target>
        </trans-unit>
        <trans-unit id="493e473600aee0c7bcce465fd5f66ce4c04f4e72" translate="yes" xml:space="preserve">
          <source>Older Woman</source>
          <target state="translated">나이 많은 여자</target>
        </trans-unit>
        <trans-unit id="f45cbb491b86714bd98c42e22c982d41684cdfce" translate="yes" xml:space="preserve">
          <source>Omitted and extra indices</source>
          <target state="translated">생략 및 추가 지수</target>
        </trans-unit>
        <trans-unit id="bdd9f9feaf5acde15de18ad7f8bd40de4f1b782e" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures, &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof(ans)&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. You can convert an integer value back to a &lt;code&gt;Char&lt;/code&gt; just as easily:</source>
          <target state="translated">32 비트 아키텍처에서 &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof(ans)&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 입니다. 정수 값을 &lt;code&gt;Char&lt;/code&gt; 처럼 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd09e2bd2e91471e0bc628c7f284aa260673d9ee" translate="yes" xml:space="preserve">
          <source>On Linux systems, the TCP_QUICKACK is disabled or enabled on &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">Linux 시스템에서 TCP_QUICKACK은 &lt;code&gt;socket&lt;/code&gt; 에서 비활성화되거나 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d6f162e1c6dd3fdf5b4b173fdf2b77540bc5038" translate="yes" xml:space="preserve">
          <source>On Soft Scope</source>
          <target state="translated">소프트 스코프</target>
        </trans-unit>
        <trans-unit id="9e6339065c09aa2c526a5dbaab652f506bc74797" translate="yes" xml:space="preserve">
          <source>On Unix systems, replace a tilde character at the start of a path with the current user's home directory.</source>
          <target state="translated">Unix 시스템에서 경로 시작시 물결표 문자를 현재 사용자의 홈 디렉토리로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="bb1d6d9c207542f37a0eb9a4d30104dcffd38435" translate="yes" xml:space="preserve">
          <source>On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.</source>
          <target state="translated">Windows에서는 경로를 드라이브 문자 부분과 경로 부분으로 분할하십시오. 유닉스 시스템에서 첫 번째 컴포넌트는 항상 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4c68460a13d1df8955c1f8bb29c597d386917eef" translate="yes" xml:space="preserve">
          <source>On Windows, this environment variable is ignored, and external commands are executed directly.</source>
          <target state="translated">Windows에서는이 환경 변수가 무시되고 외부 명령이 직접 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="155eaef05899463a6426667bf84d001c6851f4ef" translate="yes" xml:space="preserve">
          <source>On Windows, this is a critical section object, on pthreads, this is a &lt;code&gt;pthread_mutex_t&lt;/code&gt;.</source>
          <target state="translated">Windows에서 이는 pthreads에서 중요한 섹션 오브젝트이며 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60dc73d26d92352d669b6b314c01d0e67b4f12bc" translate="yes" xml:space="preserve">
          <source>On With Exclamation Mark With Left Right Arrow Above</source>
          <target state="translated">위의 왼쪽 오른쪽 화살표가있는 느낌표 표시</target>
        </trans-unit>
        <trans-unit id="b47df2e0f9b94e375b78ff1379a3f11415ea9470" translate="yes" xml:space="preserve">
          <source>On a computer with a 2.4GHz Intel Core i5 processor, this produces:</source>
          <target state="translated">2.4GHz Intel Core i5 프로세서가 장착 된 컴퓨터에서 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d6cc2cc0bff4a83bfe594a8a58bb2b33f6acda16" translate="yes" xml:space="preserve">
          <source>On a computer with a 2.7 GHz Intel Core i7 processor, this produces:</source>
          <target state="translated">2.7GHz Intel Core i7 프로세서가 장착 된 컴퓨터에서 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0d05c50e4f9adbf55a00b2b6337dd680a4e8ea56" translate="yes" xml:space="preserve">
          <source>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an &lt;code&gt;int&lt;/code&gt; in C is not the same as an &lt;code&gt;Int&lt;/code&gt; in Julia).</source>
          <target state="translated">현재 지원하는 모든 시스템에서 기본 C / C ++ 값 유형은 다음과 같이 Julia 유형으로 변환 될 수 있습니다. 모든 C 타입은 휴대용 코드를 작성하는 (그리고 있음을 기억을 위해 도움이 될 수 있습니다 C.이 접두어 같은 이름의 해당 줄리아 타입이 &lt;code&gt;int&lt;/code&gt; C에서이 동일하지 않습니다 &lt;code&gt;Int&lt;/code&gt; 인 줄리아 인치).</target>
        </trans-unit>
        <trans-unit id="bab9d1cbda261ee61dde55272f1af711e58d2855" translate="yes" xml:space="preserve">
          <source>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when writing portable code (and remembering that an &lt;code&gt;int&lt;/code&gt; in C is not the same as an &lt;code&gt;Int&lt;/code&gt; in Julia).</source>
          <target state="translated">현재 지원하는 모든 시스템에서 기본 C / C ++ 값 유형은 다음과 같이 Julia 유형으로 변환 될 수 있습니다. 모든 C 타입은 휴대용 코드를 작성하는 (그리고 것을 기억하면 도움이 될 수 있습니다 C.이 접두어 같은 이름의 해당 줄리아 타입이 &lt;code&gt;int&lt;/code&gt; C에서이 동일하지 않습니다 &lt;code&gt;Int&lt;/code&gt; 인 줄리아 인치).</target>
        </trans-unit>
        <trans-unit id="0381f586cce60e3ccff1893131fb730207dab27f" translate="yes" xml:space="preserve">
          <source>On the command line</source>
          <target state="translated">명령 행에서</target>
        </trans-unit>
        <trans-unit id="587c20a5e51a65e62924cbe225a3fdc1498c623a" translate="yes" xml:space="preserve">
          <source>On the contrary, if one of the operands is &lt;code&gt;false&lt;/code&gt;, the result could be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on the value of the other operand. Therefore, if that operand is &lt;code&gt;missing&lt;/code&gt;, the result has to be &lt;code&gt;missing&lt;/code&gt; too</source>
          <target state="translated">반대로, 피연산자 중 하나가 &lt;code&gt;false&lt;/code&gt; 인 경우 다른 피연산자의 값에 따라 결과가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 될 수 있습니다 . 그 피연산자이면 따라서 &lt;code&gt;missing&lt;/code&gt; 결과는해야 &lt;code&gt;missing&lt;/code&gt; 너무</target>
        </trans-unit>
        <trans-unit id="518a0d6b9d25183b82c9bf4eb99d6d93bfd19e36" translate="yes" xml:space="preserve">
          <source>On the first call (&lt;code&gt;@time sum_global()&lt;/code&gt;) the function gets compiled. (If you've not yet used &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; in this session, it will also compile functions needed for timing.) You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a significant amount of memory was allocated. We are here just computing a sum over all elements in a vector of 64-bit floats so there should be no need to allocate memory (at least not on the heap which is what &lt;code&gt;@time&lt;/code&gt; reports).</source>
          <target state="translated">첫 번째 호출 ( &lt;code&gt;@time sum_global()&lt;/code&gt; )에서 함수가 컴파일됩니다. ( 이 세션에서 &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; 을 아직 사용하지 않은 경우 타이밍에 필요한 함수도 컴파일됩니다.)이 실행 결과를 심각하게 고려해서는 안됩니다. 두 번째 실행의 경우 시간보고 외에도 많은 양의 메모리가 할당되었음을 나타냅니다. 여기서는 64 비트 부동 소수점 벡터의 모든 요소에 대한 합계를 계산하므로 메모리를 할당 할 필요가 없습니다 (적어도 &lt;code&gt;@time&lt;/code&gt; 이 보고 하는 힙에는 없음 ).</target>
        </trans-unit>
        <trans-unit id="4ad03a446adb0683f0ee72ebe5c5d4de73ec2ee9" translate="yes" xml:space="preserve">
          <source>On the flip side, it is often handy to &quot;splat&quot; the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses &lt;code&gt;...&lt;/code&gt; but in the function call instead:</source>
          <target state="translated">반대로, 반복 가능한 컬렉션에 포함 된 값을 개별 인수로 함수 호출에 &quot;스 플래트&quot;하는 것이 종종 편리합니다. 이렇게하려면 &lt;code&gt;...&lt;/code&gt; 을 사용 하지만 대신 함수 호출에서</target>
        </trans-unit>
        <trans-unit id="17b403ef50412b37149d7de8d64205fbc78be0d0" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; s are rewritable. For example, multiple processes can co-ordinate their processing by referencing the same remote &lt;code&gt;Channel&lt;/code&gt;.</source>
          <target state="translated">반면에 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 은 다시 쓸 수 있습니다. 예를 들어, 여러 프로세스가 동일한 원격 &lt;code&gt;Channel&lt;/code&gt; 을 참조하여 처리를 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63d9d088c9fae4ec91c2c4846a8d7718abfee493" translate="yes" xml:space="preserve">
          <source>On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:</source>
          <target state="translated">반면에 조건부 체인 끝에는 모든 유형의 표현을 사용할 수 있습니다. 위의 조건에 따라 평가 및 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="351c03433eb494876e9f9b819be4bdaa9e922583" translate="yes" xml:space="preserve">
          <source>On the other hand, language &lt;em&gt;interoperability&lt;/em&gt; is extremely useful: we want to exploit existing high-quality code in other languages from Julia (and vice versa)! The best way to enable this is not a transpiler, but rather via easy inter-language calling facilities. We have worked hard on this, from the built-in &lt;code&gt;ccall&lt;/code&gt; intrinsic (to call C and Fortran libraries) to &lt;a href=&quot;https://github.com/JuliaInterop&quot;&gt;JuliaInterop&lt;/a&gt; packages that connect Julia to Python, Matlab, C++, and more.</source>
          <target state="translated">다른 한편으로, 언어 &lt;em&gt;상호 운용성&lt;/em&gt; 은 매우 유용합니다. 우리는 Julia의 다른 언어로 된 기존의 고품질 코드를 이용하려고합니다 (그 반대도 마찬가지입니다)! 이를 가능하게하는 가장 좋은 방법은 트랜스 파일러가 아니라 쉬운 언어 간 통화 기능을 사용하는 것입니다. 우리는 내장 된 &lt;code&gt;ccall&lt;/code&gt; intrinsic (C 및 Fortran 라이브러리 호출 용)부터 Julia를 Python, Matlab, C ++ 등에 연결 하는 &lt;a href=&quot;https://github.com/JuliaInterop&quot;&gt;JuliaInterop&lt;/a&gt; 패키지 에 이르기 까지이를 위해 열심히 노력했습니다 .</target>
        </trans-unit>
        <trans-unit id="b02c05a8f3f1c4acb393f741faa4805c77971fea" translate="yes" xml:space="preserve">
          <source>On the other hand, missingness propagates when one of the operands is &lt;code&gt;true&lt;/code&gt;, for example the first one</source>
          <target state="translated">반면에 피연산자 중 하나가 &lt;code&gt;true&lt;/code&gt; 누락이 전파됩니다 ( 예 : 첫 번째 피연산자)</target>
        </trans-unit>
        <trans-unit id="66752d66287e12266caf0e8fe423b26d0766c1cd" translate="yes" xml:space="preserve">
          <source>On the other hand, no error is thrown when the result can be determined without the &lt;code&gt;missing&lt;/code&gt; values. This is the case when the code short-circuits before evaluating the &lt;code&gt;missing&lt;/code&gt; operand, and when the &lt;code&gt;missing&lt;/code&gt; operand is the last one</source>
          <target state="translated">반면에 결 &lt;code&gt;missing&lt;/code&gt; 없이 결과를 결정할 수 있으면 오류가 발생하지 않습니다 . &lt;code&gt;missing&lt;/code&gt; 피연산자 를 평가하기 전에 코드가 단락 되고 &lt;code&gt;missing&lt;/code&gt; 피연산자가 마지막 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="66d783b202bcb5502d49204a4c1a17474d2de0ce" translate="yes" xml:space="preserve">
          <source>On the other hand, serializing a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; only involves the serialization of an identifier that identifies the location and instance of &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; referred to by the handle. A deserialized &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; object (on any worker), therefore also points to the same backing store as the original.</source>
          <target state="translated">반면에 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 을&lt;/a&gt; 직렬화하는 것은 핸들이 참조하는 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 의 위치와 인스턴스를 식별하는 식별자의 직렬화 만 포함합니다 . 따라서 역 직렬화 된 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 객체 (모든 작업자)는 원본과 동일한 백업 저장소를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="771a6039f4f4d3ec219eb1b8ab2a7b46116413f0" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;em&gt;symbol&lt;/em&gt;&lt;code&gt;:b&lt;/code&gt; is used in the expression construction, so the value of the variable &lt;code&gt;b&lt;/code&gt; at that time is irrelevant &amp;ndash; &lt;code&gt;:b&lt;/code&gt; is just a symbol and the variable &lt;code&gt;b&lt;/code&gt; need not even be defined. At expression evaluation time, however, the value of the symbol &lt;code&gt;:b&lt;/code&gt; is resolved by looking up the value of the variable &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">반면에 &lt;code&gt;:b&lt;/code&gt; &lt;em&gt;기호&lt;/em&gt; 는 표현식 구성에 사용되므로 당시 변수 &lt;code&gt;b&lt;/code&gt; 의 값 은 관련이 없습니다. &amp;ndash; &lt;code&gt;:b&lt;/code&gt; 는 기호 일 뿐이며 변수 &lt;code&gt;b&lt;/code&gt; 도 정의 할 필요가 없습니다. 그러나 표현식 평가시 변수 &lt;code&gt;b&lt;/code&gt; 의 값을 찾아서 기호 &lt;code&gt;:b&lt;/code&gt; 의 값을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dd495e4741a90baf6003c40c92c4aa3f0b4cd557" translate="yes" xml:space="preserve">
          <source>Once a variable is made visible via &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 를 통해 변수가 표시되면 모듈은 동일한 이름으로 자체 변수를 만들 수 없습니다. 가져온 변수는 읽기 전용입니다. 전역 변수에 할당하면 항상 현재 모듈이 소유 한 변수에 영향을 주거나 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbb4245dbb4242070beff681d151067e39a6f407" translate="yes" xml:space="preserve">
          <source>Once finalized, a reference becomes invalid and cannot be used in any further calls.</source>
          <target state="translated">완료되면 참조가 유효하지 않게되어 더 이상 호출에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="153460770bc51983406d5b79bfce57e7867c875a" translate="yes" xml:space="preserve">
          <source>Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try to use it for everything. For example, you might imagine using it to store information, e.g.</source>
          <target state="translated">다중 디스패치에 대한 감사를 알게되면, 배를 타고 모든 것에 사용하려고 시도하는 경향이 있습니다. 예를 들어, 정보를 저장하기 위해이를 사용한다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c203638f9ad5d408088a4eef6ad04b4df41e5027" translate="yes" xml:space="preserve">
          <source>Oncoming Automobile</source>
          <target state="translated">다가오는 자동차</target>
        </trans-unit>
        <trans-unit id="61c05078278f8201b444547fd75a173fff4a3ad0" translate="yes" xml:space="preserve">
          <source>Oncoming Bus</source>
          <target state="translated">다가오는 버스</target>
        </trans-unit>
        <trans-unit id="ddeaee107e2c4e76bf01661779970545629d3afd" translate="yes" xml:space="preserve">
          <source>Oncoming Police Car</source>
          <target state="translated">다가오는 경찰차</target>
        </trans-unit>
        <trans-unit id="1f6e328b8fe4d57c863b1503f93724d6b14d7bf5" translate="yes" xml:space="preserve">
          <source>Oncoming Taxi</source>
          <target state="translated">다가오는 택시</target>
        </trans-unit>
        <trans-unit id="10a5bbfdc49a80bbe793aee50ef76a76a7bc98ae" translate="yes" xml:space="preserve">
          <source>One alternative is to use a macro to capture &lt;a href=&quot;../../base/base/index#Base.@__MODULE__&quot;&gt;&lt;code&gt;@__MODULE__&lt;/code&gt;&lt;/a&gt; and store it alone with the current &lt;code&gt;counter&lt;/code&gt; value, however, it may be better to redesign the code to not depend on this global state.</source>
          <target state="translated">한 가지 대안은 매크로를 사용하여 &lt;a href=&quot;../../base/base/index#Base.@__MODULE__&quot;&gt; &lt;code&gt;@__MODULE__&lt;/code&gt; &lt;/a&gt; 을 캡처 하여 현재 &lt;code&gt;counter&lt;/code&gt; 값 과 함께 저장하는 것입니다. 그러나이 전역 상태에 의존하지 않도록 코드를 다시 디자인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="68452c858f7b1ccba1312252acfbe351a171f8df" translate="yes" xml:space="preserve">
          <source>One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) &amp;ndash; it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, &lt;a href=&quot;#man-type-stability&quot;&gt;type-stability is crucial&lt;/a&gt; for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.</source>
          <target state="translated">고려해야 할 한 가지 대안은 각 정수 연산의 오버플로를 확인하고 오버플 로의 경우 결과를 &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 와 같은 더 큰 정수 유형으로 승격 하는 것입니다. 불행히도 이것은 모든 정수 연산 (루프 카운터를 증가시키는 것을 생각해보십시오)에 큰 오버 헤드를 유발합니다. 산술 명령 후 런타임 오버플로 검사를 수행하고 잠재적 인 오버플로를 처리하기 위해 분기를 수행하기 위해 코드를 내 보내야합니다. 더 나쁜 것은 정수를 포함하는 모든 계산이 유형이 불안정해질 수 있다는 것입니다. 위에서 언급했듯이 &lt;a href=&quot;#man-type-stability&quot;&gt;형식 안정성은&lt;/a&gt; 효율적인 코드 생성을 위해 매우 중요 합니다. 정수 연산의 결과가 정수라고 믿을 수 없다면 C 및 Fortran 컴파일러처럼 빠르고 간단한 코드를 생성하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="319cbfa2cb6199265b8d88a5116ab6583eb207c7" translate="yes" xml:space="preserve">
          <source>One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt;&lt;code&gt;Int128&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) &amp;ndash; it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stability is crucial&lt;/a&gt; for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.</source>
          <target state="translated">고려해야 할 한 가지 대안은 각 정수 연산에서 오버플로를 확인하고 오버플 로의 경우 &lt;a href=&quot;../../base/numbers/index#Core.Int128&quot;&gt; &lt;code&gt;Int128&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 와 같은 더 큰 정수 유형으로 결과를 승격시키는 것 입니다. 불행히도, 이것은 모든 정수 연산 (루프 카운터를 증가시키는 것)에 큰 오버 헤드를 발생시킵니다. 잠재적 인 오버 플로우를 처리하기 위해 산술 명령어 및 분기 후에 런타임 오버 플로우 검사를 수행하기 위해 코드를 생성해야합니다. 더 나쁜 것은 정수를 포함하는 모든 계산이 형식이 불안정하다는 것입니다. 위에서 언급했듯이 효율적인 코드를 효과적으로 생성하려면 &lt;a href=&quot;#man-type-stability-1&quot;&gt;형식 안정성이 중요&lt;/a&gt; 합니다. 정수 연산의 결과가 정수라고 생각할 수 없으면 C 및 Fortran 컴파일러와 같은 방식으로 빠르고 간단한 코드를 생성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="87126a794e4c39ba4df13f6963f3107de93a4e22" translate="yes" xml:space="preserve">
          <source>One can also pass &lt;code&gt;key =&amp;gt; value&lt;/code&gt; expressions after a semicolon. For example, &lt;code&gt;plot(x, y; :width =&amp;gt; 2)&lt;/code&gt; is equivalent to &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;. This is useful in situations where the keyword name is computed at runtime.</source>
          <target state="translated">세미콜론 뒤에 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; 표현식을 전달할 수도 있습니다 . 예를 들어, &lt;code&gt;plot(x, y; :width =&amp;gt; 2)&lt;/code&gt; 는 &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; . 이는 키워드 이름이 런타임에 계산되는 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="02624e42b707c1de7f41e5350b4675b4c9d0f30a" translate="yes" xml:space="preserve">
          <source>One common mistake is to try and get the element-type by using introspection:</source>
          <target state="translated">한 가지 일반적인 실수는 내부 검사를 사용하여 요소 유형을 시도하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b006eab8378514a51041aafae3b9c6e3c4afb77" translate="yes" xml:space="preserve">
          <source>One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project may end up depending on different packages that have the same name. Julia's package loading mechanism does not require package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;universally unique identifiers&lt;/a&gt; (UUIDs), which get assigned when each package is created. Usually you won't have to work directly with these somewhat cumbersome 128-bit identifiers since &lt;code&gt;Pkg&lt;/code&gt; will take care of generating and tracking them for you. However, these UUIDs provide the definitive answer to the question of &lt;em&gt;&quot;what package does &lt;code&gt;X&lt;/code&gt; refer to?&quot;&lt;/em&gt;</source>
          <target state="translated">페더레이션의 한 가지 결과는 패키지 이름 지정에 대한 중앙 권한이 없다는 것입니다. 서로 다른 엔티티는 동일한 이름을 사용하여 관련되지 않은 패키지를 나타낼 수 있습니다. 이러한 엔티티는 서로 조정하지 않으며 서로에 대해 알지 못하므로 불가피합니다. 중앙 명명 권한이 없기 때문에 동일한 이름을 가진 다른 패키지에 따라 단일 프로젝트가 끝날 수 있습니다. Julia의 패키지 로딩 메커니즘은 단일 프로젝트의 종속성 그래프 내에서도 패키지 이름이 전역 적으로 고유하지 않아도됩니다. 대신 패키지는 UUID ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Universally Unique Identifier)&lt;/a&gt; 로 식별되며 각 패키지가 작성 될 때 지정됩니다. 일반적으로 &lt;code&gt;Pkg&lt;/code&gt; 이후로 다소 번거로운 128 비트 식별자로 직접 작업 할 필요는 없습니다.생성 및 추적을 담당합니다. 그러나 이러한 UUID는 &lt;em&gt;&quot; &lt;/em&gt;&lt;em&gt; &lt;code&gt;X&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 는 어떤 패키지를 &lt;/em&gt;&lt;em&gt;참조합니까?&quot;라는&lt;/em&gt; 질문에 대한 명확한 답변을 제공합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c776cd11f414b03738dd0416b0d39d2e16e1ed10" translate="yes" xml:space="preserve">
          <source>One dimensional &lt;a href=&quot;#Base.StridedArray&quot;&gt;&lt;code&gt;StridedArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">일차원 &lt;a href=&quot;#Base.StridedArray&quot;&gt; &lt;code&gt;StridedArray&lt;/code&gt; &lt;/a&gt; 유형의 요소 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4815d6606da01b20ef10c5c0e075447bfd75d6b1" translate="yes" xml:space="preserve">
          <source>One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more &quot;space&quot; for future method definitions.</source>
          <target state="translated">여기서 한 가지 문제는 함수에 본질적으로 정수가 필요한 경우 호출자가 강제로 정수가 아닌 변환 방법 (예 : 바닥 또는 천장)을 결정하는 것이 좋습니다. 또 다른 문제는보다 구체적인 유형을 선언하면 향후 메소드 정의에 더 많은 &quot;공간&quot;이 남게된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba07493d204a55c7202f5d3dbcd2c52e223ef48f" translate="yes" xml:space="preserve">
          <source>One may also access the underlying &lt;code&gt;UTInstant&lt;/code&gt; or integer value:</source>
          <target state="translated">기본 &lt;code&gt;UTInstant&lt;/code&gt; 또는 정수 값에 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd0e415c6a547b8bbcaa1063befe52b13a2aa324" translate="yes" xml:space="preserve">
          <source>One note on parsing performance: using the &lt;code&gt;Date(date_string,format_string)&lt;/code&gt; function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;Dates.DateFormat&lt;/code&gt;&lt;/a&gt;, and pass it instead of a raw format string.</source>
          <target state="translated">구문 분석 성능에 대한 참고 사항 : 몇 번만 호출 하면 &lt;code&gt;Date(date_string,format_string)&lt;/code&gt; 함수를 사용하는 것이 좋습니다. 그러나 구문 분석 할 유사한 형식의 날짜 문자열이 많은 경우 먼저 &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;Dates.DateFormat&lt;/code&gt; 을&lt;/a&gt; 작성 하고 원시 형식 문자열 대신 전달 하는 것이 훨씬 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="9137ec2822fcee2353c1587235561d45cf358a22" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;HasLength()&lt;/code&gt;, &lt;code&gt;HasShape{N}()&lt;/code&gt;, &lt;code&gt;IsInfinite()&lt;/code&gt;, or &lt;code&gt;SizeUnknown()&lt;/code&gt; as appropriate</source>
          <target state="translated">하나 &lt;code&gt;HasLength()&lt;/code&gt; , &lt;code&gt;HasShape{N}()&lt;/code&gt; , &lt;code&gt;IsInfinite()&lt;/code&gt; 또는 &lt;code&gt;SizeUnknown()&lt;/code&gt; 적절한</target>
        </trans-unit>
        <trans-unit id="436148adcb7ac2d18abd79ff00a2d087851952a3" translate="yes" xml:space="preserve">
          <source>One of Julia's goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:</source>
          <target state="translated">Julia의 목표 중 하나는 데이터 분석 및 통계 프로그래밍에 효과적인 언어를 제공하는 것입니다. R에서 Julia로 오는 사용자에게는 다음과 같은 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55096f5245208c5eb0440ec6a345fddb43363fbe" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;connect&lt;/code&gt; methods that does not follow the &lt;code&gt;listen&lt;/code&gt; methods is &lt;code&gt;connect(host::String,port)&lt;/code&gt;, which will attempt to connect to the host given by the &lt;code&gt;host&lt;/code&gt; parameter on the port given by the &lt;code&gt;port&lt;/code&gt; parameter. It allows you to do things like:</source>
          <target state="translated">&lt;code&gt;listen&lt;/code&gt; 메소드를 따르지 않는 &lt;code&gt;connect&lt;/code&gt; 메소드 중 하나 는 &lt;code&gt;connect(host::String,port)&lt;/code&gt; 이며, 이는 &lt;code&gt;port&lt;/code&gt; 매개 변수가 제공 한 포트 에서 &lt;code&gt;host&lt;/code&gt; 매개 변수가 제공 한 호스트에 연결을 시도합니다 . 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10010155e6ee1cb87ecad6ce87a3f916af001f45" translate="yes" xml:space="preserve">
          <source>One of the most common and useful string operations is concatenation:</source>
          <target state="translated">가장 일반적이고 유용한 문자열 작업 중 하나는 연결입니다.</target>
        </trans-unit>
        <trans-unit id="e7a2348e6f04e9e17b6e21a7a69732c3c29d40af" translate="yes" xml:space="preserve">
          <source>One of the most common techniques to improve performance is to reduce memory allocation. The total amount of allocation can be measured with &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt;&lt;code&gt;@time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.@allocated&quot;&gt;&lt;code&gt;@allocated&lt;/code&gt;&lt;/a&gt;, and specific lines triggering allocation can often be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by each line of code.</source>
          <target state="translated">성능을 향상시키는 가장 일반적인 기술 중 하나는 메모리 할당을 줄이는 것입니다. 총 할당량은 &lt;a href=&quot;../../base/base/index#Base.@time&quot;&gt; &lt;code&gt;@time&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.@allocated&quot;&gt; &lt;code&gt;@allocated&lt;/code&gt; &lt;/a&gt; 로 측정 할 수 있으며 할당을 트리거하는 특정 라인은 종종 이러한 라인에서 발생하는 가비지 콜렉션 비용을 통해 프로파일 링을 통해 유추 될 수 있습니다. 그러나 때로는 각 코드 줄에 의해 할당 된 메모리 양을 직접 측정하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="9af8b1074cbe3323673dd24c49db4be8d382b298" translate="yes" xml:space="preserve">
          <source>One only needs to introduce a single type parameter to force specialization, even if the other types are unconstrained. For example, this will also specialize, and is useful when the arguments are not all of the same type:</source>
          <target state="translated">다른 유형이 제한되지 않더라도 특수화를 강제하기 위해 단일 유형 매개 변수를 도입하기 만하면됩니다. 예를 들어, 이것은 또한 전문화되며 인수가 모두 동일한 유형이 아닐 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="45374d28bce37032091a9fea4342bae27c8b8de4" translate="yes" xml:space="preserve">
          <source>One problem remains however. Consider the following use of this macro:</source>
          <target state="translated">그러나 한 가지 문제가 남아 있습니다. 이 매크로의 다음 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b9f48341b16ff2de536604efaceb8038f76fbfcd" translate="yes" xml:space="preserve">
          <source>One risk with this design is the possibility that if there is no suitable promotion method converting &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to the same type, the second method will recurse on itself infinitely and trigger a stack overflow.</source>
          <target state="translated">이 디자인의 한 가지 위험은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 동일한 유형으로 변환하는 적절한 승격 방법이없는 경우 두 번째 방법이 자체적으로 무한 반복되어 스택 오버플로를 트리거 할 가능성입니다.</target>
        </trans-unit>
        <trans-unit id="3501153e12d4b87f4638178e60c29c5d300b9f87" translate="yes" xml:space="preserve">
          <source>One risk with this design is the possibility that if there is no suitable promotion method converting &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to the same type, the second method will recurse on itself infinitely and trigger a stack overflow. The non-exported function &lt;code&gt;Base.promote_noncircular&lt;/code&gt; can be used as an alternative; when promotion fails it will still throw an error, but one that fails faster with a more specific error message.</source>
          <target state="translated">이 디자인의 한 가지 위험은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 같은 유형으로 변환하는 적절한 승격 방법이 없으면 두 번째 방법은 그 자체로 무한히 재귀하여 스택 오버플로를 유발할 수 있습니다. 내 보내지 않은 함수 &lt;code&gt;Base.promote_noncircular&lt;/code&gt; 를 대안으로 사용할 수 있습니다. 승격이 실패하면 여전히 오류가 발생하지만보다 구체적인 오류 메시지로 인해 더 빨리 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b7b822a81641982530f11d17ac5483aca96f2f6" translate="yes" xml:space="preserve">
          <source>One then writes method(s) (at least &lt;a href=&quot;#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt;) operating on &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt;. There are also several pre-defined subtypes of &lt;code&gt;BroadcastStyle&lt;/code&gt; that you may be able to leverage; see the &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting&quot;&gt;Interfaces chapter&lt;/a&gt; for more information.</source>
          <target state="translated">그런 다음 &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt; 에서 작동하는 메서드 (최소한 &lt;a href=&quot;#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; ) 를 작성 합니다. 또한 활용할 수있는 &lt;code&gt;BroadcastStyle&lt;/code&gt; 의 몇 가지 사전 정의 된 하위 유형 이 있습니다. 자세한 내용은 &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting&quot;&gt;인터페이스 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6f2f7c3f7aee7dfa793b808c1f3af767054aa1f" translate="yes" xml:space="preserve">
          <source>One then writes method(s) (at least &lt;a href=&quot;#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt;) operating on &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt;. There are also several pre-defined subtypes of &lt;code&gt;BroadcastStyle&lt;/code&gt; that you may be able to leverage; see the &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting-1&quot;&gt;Interfaces chapter&lt;/a&gt; for more information.</source>
          <target state="translated">그런 다음 &lt;code&gt;Broadcasted{MyContainerStyle}&lt;/code&gt; 에서 작동하는 메소드 (적어도 &lt;a href=&quot;#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; ) 를 작성 합니다. 또한 사용할 수있는 몇 가지 사전 정의 된 &lt;code&gt;BroadcastStyle&lt;/code&gt; 하위 유형 이 있습니다. 자세한 내용은 &lt;a href=&quot;../../manual/interfaces/index#man-interfaces-broadcasting-1&quot;&gt;인터페이스 장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d200e37937b9200fe9bf660a0dc70e4426e0648a" translate="yes" xml:space="preserve">
          <source>One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the computation. This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel.</source>
          <target state="translated">컴파일 타임과 테스트 복잡성을 크게 줄이는 한 가지 방법은 원하는 유형과 계산으로 변환하기위한 논리를 분리하는 것입니다. 이를 통해 컴파일러는 더 큰 커널의 나머지 본문과 독립적으로 변환 논리를 특수화하고 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1645f1271d39f73f0d6321f16068bb1fe04a5c9" translate="yes" xml:space="preserve">
          <source>One way to think of this behavior is that &lt;code&gt;producer&lt;/code&gt; was able to return multiple times. Between calls to &lt;code&gt;put!&lt;/code&gt;, the producer's execution is suspended and the consumer has control.</source>
          <target state="translated">이 동작을 생각하는 한 가지 방법은 &lt;code&gt;producer&lt;/code&gt; 가 여러 번 돌아올 수 있다는 것입니다 . 전화하는 사이 &lt;code&gt;put!&lt;/code&gt; 제작자의 실행이 일시 중지되고 소비자가 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fd832dc6ac0ce055682a44df74b0f43374b3e5" translate="yes" xml:space="preserve">
          <source>One-dimensional &lt;a href=&quot;#Core.DenseArray&quot;&gt;&lt;code&gt;DenseArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;. Alias for &lt;code&gt;DenseArray{T,1}&lt;/code&gt;.</source>
          <target state="translated">일차원 &lt;a href=&quot;#Core.DenseArray&quot;&gt; &lt;code&gt;DenseArray&lt;/code&gt; &lt;/a&gt; 유형의 요소 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;DenseArray{T,1}&lt;/code&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="3df27b5108b582dd0321cfd13d78f7cf11d42868" translate="yes" xml:space="preserve">
          <source>One-dimensional dense array with elements of type &lt;code&gt;T&lt;/code&gt;, often used to represent a mathematical vector. Alias for &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array{T,1}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 요소가있는 1 차원 밀도 배열로 , 종종 수학 벡터를 나타내는 데 사용됩니다. &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array{T,1}&lt;/code&gt; &lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="761532be36fbf4ec3ee7163dc62c1a3c16eed1d0" translate="yes" xml:space="preserve">
          <source>OneTo</source>
          <target state="translated">OneTo</target>
        </trans-unit>
        <trans-unit id="76ad803f3bc172b43390cf9edc7cbf4c7fe04f9b" translate="yes" xml:space="preserve">
          <source>Only a single dimension in &lt;code&gt;dims&lt;/code&gt; is currently supported. Equivalent to &lt;code&gt;(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">만에 하나의 차원 &lt;code&gt;dims&lt;/code&gt; 현재 지원됩니다. 동등 &lt;code&gt;(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 위치에 &lt;code&gt;dims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4f9c4d4b9ceb74b37011c17fefd6d754166722d" translate="yes" xml:space="preserve">
          <source>Only annotated tags can be peeled to &lt;code&gt;GitTag&lt;/code&gt; objects. Lightweight tags (the default) are references under &lt;code&gt;refs/tags/&lt;/code&gt; which point directly to &lt;code&gt;GitCommit&lt;/code&gt; objects.</source>
          <target state="translated">주석이 달린 태그 만 &lt;code&gt;GitTag&lt;/code&gt; 객체에 껍질을 벗길 수 있습니다 . 경량 태그 (기본값)는 &lt;code&gt;GitCommit&lt;/code&gt; 객체를 직접 가리키는 &lt;code&gt;refs/tags/&lt;/code&gt; 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="0826c50b1728d0d708f6df24eabe81219d4fd72a" translate="yes" xml:space="preserve">
          <source>Only certain &quot;simple&quot; types can be used atomically, namely the primitive boolean, integer, and float-point types. These are &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Int8&lt;/code&gt;...&lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt8&lt;/code&gt;...&lt;code&gt;UInt128&lt;/code&gt;, and &lt;code&gt;Float16&lt;/code&gt;...&lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">특정 &quot;간단한&quot;유형, 즉 기본 부울, 정수 및 부동 소수점 유형 만 원자 적으로 사용할 수 있습니다. 이것들은 &lt;code&gt;Bool&lt;/code&gt; , &lt;code&gt;Int8&lt;/code&gt; ... &lt;code&gt;Int128&lt;/code&gt; , &lt;code&gt;UInt8&lt;/code&gt; ... &lt;code&gt;UInt128&lt;/code&gt; 및 &lt;code&gt;Float16&lt;/code&gt; ... &lt;code&gt;Float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d3b00a80434bbed5cd383bf9ee04282bf5a25c4" translate="yes" xml:space="preserve">
          <source>Only conversion to/from UTF-8 is currently supported.</source>
          <target state="translated">현재 UTF-8과의 변환 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1eeeb7bde4b30671f25e4d852799d258e6eb1b0e" translate="yes" xml:space="preserve">
          <source>Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.</source>
          <target state="translated">재정의 할 수 없으므로 매개 변수 유형에 대해 하나의 기본 생성자 만 생성됩니다. 이 생성자는 모든 인수를 허용하고 인수를 필드 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5bed7725a4393ba41e127b736de1d452935e48f0" translate="yes" xml:space="preserve">
          <source>Only provide an argument list when really necessary.</source>
          <target state="translated">실제로 필요한 경우에만 인수 목록을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e29b5de56072ba7e7c5e4e8ea182586070ff91e4" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;master&lt;/code&gt; process can add or remove worker processes.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 프로세스 만이 작업자 프로세스를 추가하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea4110acec6b93703ee74f301aaf09b4d9cd7ab" translate="yes" xml:space="preserve">
          <source>Only the &lt;em&gt;lower&lt;/em&gt; triangle of the matrix will be used.</source>
          <target state="translated">행렬 의 &lt;em&gt;아래쪽&lt;/em&gt; 삼각형 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99042162ee5c91958ac1be23590ce2805ab4e78a" translate="yes" xml:space="preserve">
          <source>Only the &lt;em&gt;upper&lt;/em&gt; triangle of the matrix will be used.</source>
          <target state="translated">행렬 의 &lt;em&gt;상단&lt;/em&gt; 삼각형 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4ada366ae15c04b6cbda38f0f5be6dcbb2d22ea" translate="yes" xml:space="preserve">
          <source>Only valid in the context of an &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-macros&quot;&gt;Macros&lt;/a&gt; section of the Metaprogramming chapter of the manual for more details and examples.</source>
          <target state="translated">매크로에서 반환 된 &lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 의 컨텍스트에서만 유효합니다 . 매크로 위생 과정이 포함 된 변수를 gensym 변수로 바꾸는 것을 방지합니다. 자세한 내용과 예제는 매뉴얼의 메타 프로그래밍 장의 &lt;a href=&quot;../../manual/metaprogramming/index#man-macros&quot;&gt;매크로&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b41da8066e8d8f89de45d239c8dc1ffa14f3b2b" translate="yes" xml:space="preserve">
          <source>Only valid in the context of an &lt;a href=&quot;#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the &lt;a href=&quot;../../manual/metaprogramming/index#man-macros-1&quot;&gt;Macros&lt;/a&gt; section of the Metaprogramming chapter of the manual for more details and examples.</source>
          <target state="translated">매크로에서 반환 된 &lt;a href=&quot;#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 컨텍스트에서만 유효합니다 . 매크로 위생 패스가 포함 된 변수를 gensym 변수로 변환하지 못하게합니다. 자세한 내용과 예제는 설명서의 메타 프로그래밍 장 에서 &lt;a href=&quot;../../manual/metaprogramming/index#man-macros-1&quot;&gt;매크로&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21b2be4216216eef63fc5bb828bd7f58c8b5fe91" translate="yes" xml:space="preserve">
          <source>Only values, not variables, have types &amp;ndash; variables are simply names bound to values.</source>
          <target state="translated">변수가 아닌 값에만 유형이 있습니다. 변수는 단순히 값에 바인딩 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d97553895fe582daa8b11a4132b4c59d7d7a6098" translate="yes" xml:space="preserve">
          <source>Oops. Adding a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; operator to Matlab wouldn't help, because saturation that occurs when adding &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;2n&lt;/code&gt; has already destroyed the information necessary to compute the correct midpoint.</source>
          <target state="translated">죄송합니다. Matlab에 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 연산자를 추가 해도 도움이되지 않습니다. &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;2n&lt;/code&gt; 을 추가 할 때 발생하는 채도 가 이미 올바른 중간 점을 계산하는 데 필요한 정보를 파괴 했기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="406e4f0a56a5716867bbbdaa429f12887df5a44e" translate="yes" xml:space="preserve">
          <source>Open Book</source>
          <target state="translated">책 공개 시험</target>
        </trans-unit>
        <trans-unit id="febd72d5a0f70743184299e93e82b1271a88bc68" translate="yes" xml:space="preserve">
          <source>Open Box</source>
          <target state="translated">상자 열기</target>
        </trans-unit>
        <trans-unit id="c34b416e0aabc7a83bd814267dec2bceb7820832" translate="yes" xml:space="preserve">
          <source>Open File Folder</source>
          <target state="translated">파일 폴더 열기</target>
        </trans-unit>
        <trans-unit id="570f6f57d565bf8540f0881deac6b1e5aaab0640" translate="yes" xml:space="preserve">
          <source>Open Hands Sign</source>
          <target state="translated">손 기호를 엽니 다</target>
        </trans-unit>
        <trans-unit id="5468961e7240ee7f0d33502664aa34aa45966978" translate="yes" xml:space="preserve">
          <source>Open Lock</source>
          <target state="translated">열린 자물쇠</target>
        </trans-unit>
        <trans-unit id="d56fae21a8b4c42f3ddbf993f9f6189849fb4662" translate="yes" xml:space="preserve">
          <source>Open Mailbox With Lowered Flag</source>
          <target state="translated">플래그가 낮아진 우편함 열기</target>
        </trans-unit>
        <trans-unit id="4cd8dfeea777f97bde748d6c4492714eb41361d7" translate="yes" xml:space="preserve">
          <source>Open Mailbox With Raised Flag</source>
          <target state="translated">제기 된 플래그로 사서함 열기</target>
        </trans-unit>
        <trans-unit id="c5437122a10ed7699fba87aa70335b78d772e41f" translate="yes" xml:space="preserve">
          <source>Open a TCP socket using libuv. If &lt;code&gt;delay&lt;/code&gt; is true, libuv delays creation of the socket's file descriptor till the first &lt;a href=&quot;#Base.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; call. &lt;code&gt;TCPSocket&lt;/code&gt; has various fields to denote the state of the socket as well as its send/receive buffers.</source>
          <target state="translated">libuv를 사용하여 TCP 소켓을 엽니 다. 경우 &lt;code&gt;delay&lt;/code&gt; 사실, libuv 첫 번째까지 소켓의 파일 기술자의 생성 지연 &lt;a href=&quot;#Base.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 호출을. &lt;code&gt;TCPSocket&lt;/code&gt; 에는 소켓의 상태와 보내기 / 받기 버퍼를 나타내는 다양한 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c669ce9e8c7f026f83710316844506366a7e81" translate="yes" xml:space="preserve">
          <source>Open a UDP socket using libuv. &lt;code&gt;UDPSocket&lt;/code&gt; has various fields to denote the state of the socket.</source>
          <target state="translated">libuv를 사용하여 UDP 소켓을 엽니 다. &lt;code&gt;UDPSocket&lt;/code&gt; 에는 소켓 상태를 나타내는 다양한 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="52227891e75707f6a9cd180dec1ac02b43da23b0" translate="yes" xml:space="preserve">
          <source>Open a file and deserialize its contents.</source>
          <target state="translated">파일을 열고 내용을 직렬화 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="d8d0d276fcf9e878e3601e4f3ec11f282a81eeff" translate="yes" xml:space="preserve">
          <source>Open a file and read its contents. &lt;code&gt;args&lt;/code&gt; is passed to &lt;code&gt;read&lt;/code&gt;: this is equivalent to &lt;code&gt;open(io-&amp;gt;read(io, args...), filename)&lt;/code&gt;.</source>
          <target state="translated">파일을 열고 내용을 읽으십시오. &lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;read&lt;/code&gt; 로 전달됩니다 . 이것은 &lt;code&gt;open(io-&amp;gt;read(io, args...), filename)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253d17f9d0742c44928428f7a4404eb72b5d7aa3" translate="yes" xml:space="preserve">
          <source>Open a file and serialize the given value to it.</source>
          <target state="translated">파일을 열고 주어진 값을 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="47c11e34672f0f08478d57e985476572168f78bc" translate="yes" xml:space="preserve">
          <source>Open a file in a mode specified by five boolean keyword arguments:</source>
          <target state="translated">5 개의 부울 키워드 인수로 지정된 모드에서 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="b60069cfc2b0cba6a24e60f4b0e11798b23031dc" translate="yes" xml:space="preserve">
          <source>Open a git repository at &lt;code&gt;path&lt;/code&gt; with extended controls (for instance, if the current user must be a member of a special access group to read &lt;code&gt;path&lt;/code&gt;).</source>
          <target state="translated">확장 된 제어 로 &lt;code&gt;path&lt;/code&gt; 에서 git 저장소를여십시오 (예 : 현재 사용자가 &lt;code&gt;path&lt;/code&gt; 를 읽으려면 특수 액세스 그룹의 구성원이어야하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="c21ae27cc36b37896e9299f5470a30ce05318357" translate="yes" xml:space="preserve">
          <source>Open a git repository at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 git 저장소를여십시오 .</target>
        </trans-unit>
        <trans-unit id="a6bfd40f922aa7ca03128208dcd4d40013760ce0" translate="yes" xml:space="preserve">
          <source>Open a new git repository at &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;bare&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the working tree will be created in &lt;code&gt;path/.git&lt;/code&gt;. If &lt;code&gt;bare&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, no working directory will be created.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 새 자식 저장소를 엽니 다 . 경우 &lt;code&gt;bare&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; , 작업 트리에 만들어집니다 &lt;code&gt;path/.git&lt;/code&gt; . 경우 &lt;code&gt;bare&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 어떤 작업 디렉토리가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e32b68788e10f5efb73ae1c554923718ef6941a" translate="yes" xml:space="preserve">
          <source>Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this easier, there exists another invocation of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:</source>
          <target state="translated">파일을 열고 내용에 무언가를하고 다시 닫는 것은 매우 일반적인 패턴입니다. 이 작업을보다 쉽게하기 위해 첫 번째 인수로 함수를 사용하고 두 번째로 파일 이름을 사용하고 파일을 열고 파일을 인수로 사용하여 함수를 호출 한 다음 다시 닫는 또 다른 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 호출이 있습니다. 예를 들어, 함수가 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="69c9721ab40980ac2c3f7fd14c50821efba985b5" translate="yes" xml:space="preserve">
          <source>Operating system word size (&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;) as well as path separator differences (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;) will also affect the reproducibility of some doctests.</source>
          <target state="translated">경로 구분자 차이 ( &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; ) 뿐만 아니라 운영 체제 단어 크기 ( &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ) 도 일부 doctest의 재현성에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8d87b27bd5aedd5e01ab52666b185599e013766f" translate="yes" xml:space="preserve">
          <source>Operations on Types</source>
          <target state="translated">유형에 대한 작업</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">연산자 우선 순위 및 연관성</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="93b63dff42dcd53d0f12d4293741e66cb2b84321" translate="yes" xml:space="preserve">
          <source>Operators Are Functions</source>
          <target state="translated">연산자는 함수입니다</target>
        </trans-unit>
        <trans-unit id="283f15e3371d872597560981f14b9a2f5e0a420b" translate="yes" xml:space="preserve">
          <source>Operators With Special Names</source>
          <target state="translated">특별한 이름을 가진 연산자</target>
        </trans-unit>
        <trans-unit id="f019a8b6a52539e15849e341f41e00db685f57e9" translate="yes" xml:space="preserve">
          <source>Operators like &lt;code&gt;+&lt;/code&gt; are also valid identifiers, but are parsed specially. In some contexts, operators can be used just like variables; for example &lt;code&gt;(+)&lt;/code&gt; refers to the addition function, and &lt;code&gt;(+) = f&lt;/code&gt; will reassign it. Most of the Unicode infix operators (in category Sm), such as &lt;code&gt;&amp;oplus;&lt;/code&gt;, are parsed as infix operators and are available for user-defined methods (e.g. you can use &lt;code&gt;const &amp;otimes; = kron&lt;/code&gt; to define &lt;code&gt;&amp;otimes;&lt;/code&gt; as an infix Kronecker product). Operators can also be suffixed with modifying marks, primes, and sub/superscripts, e.g. &lt;code&gt;+̂ₐ&amp;Prime;&lt;/code&gt; is parsed as an infix operator with the same precedence as &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 와 같은 연산자 도 유효한 식별자이지만 특별히 구문 분석됩니다. 일부 상황에서 연산자는 변수처럼 사용할 수 있습니다. 예를 들어, &lt;code&gt;(+)&lt;/code&gt; 는 덧셈 함수를 나타내며 &lt;code&gt;(+) = f&lt;/code&gt; 는이를 다시 할당합니다. &lt;code&gt;&amp;oplus;&lt;/code&gt; 와 같은 대부분의 유니 코드 접두사 연산자 (범주 Sm) 는 접두사 연산자로 구문 분석되며 사용자 정의 방법에 사용할 수 있습니다 (예 : &lt;code&gt;const &amp;otimes; = kron&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;otimes;&lt;/code&gt; 을 접두어 Kronecker 제품으로 정의 할 수 있음 ). 운영자는 예를 들어 수정 마크, 소수 및 / 서브 첨자, 접미사 수 &lt;code&gt;+̂ₐ&amp;Prime;&lt;/code&gt; 동일한 우선 순위 중위 연산자로 파싱 &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977a00f3fb0022f9ead49744bbe4afa06cde1201" translate="yes" xml:space="preserve">
          <source>Ophiuchus</source>
          <target state="translated">Ophiuchus</target>
        </trans-unit>
        <trans-unit id="d2c649443c00279b2ab6db1f4eb3df011a9c205e" translate="yes" xml:space="preserve">
          <source>Optical Disc</source>
          <target state="translated">광 디스크</target>
        </trans-unit>
        <trans-unit id="bbe45d1200c2548054cd7105d981e5416cd548c2" translate="yes" xml:space="preserve">
          <source>Optimize network I/O during parallel execution</source>
          <target state="translated">병렬 실행 중 네트워크 I / O 최적화</target>
        </trans-unit>
        <trans-unit id="7ee57de488e50e002c8d91e9ed122222d3621625" translate="yes" xml:space="preserve">
          <source>Optimizing generation with cached computation between calls</source>
          <target state="translated">호출 간 캐시 계산으로 생성 최적화</target>
        </trans-unit>
        <trans-unit id="28b9b9628dcf8cbfb41ac0e1a118c33a59e1c755" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;key&amp;ndash;value pairs&lt;/em&gt; allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">선택적 &lt;em&gt;키-값 쌍을&lt;/em&gt; 사용하면 각 이벤트에 임의의 데이터를 첨부 할 수 있습니다. 일부 키는 이벤트 해석 방식에 영향을 줄 수있는 일반적인 의미를 갖습니다 ( &lt;a href=&quot;#Base.CoreLogging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="81d0780e7731b1fca95807bff5fa643e35b8da13" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;key&amp;ndash;value pairs&lt;/em&gt; allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see &lt;a href=&quot;#Logging.@logmsg&quot;&gt;&lt;code&gt;@logmsg&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">선택적 &lt;em&gt;키-값 쌍을&lt;/em&gt; 사용하면 임의의 데이터를 각 이벤트에 연결할 수 있습니다. 일부 키는 이벤트 해석 방식에 영향을 줄 수있는 일반적인 의미를 가지고 있습니다 ( &lt;a href=&quot;#Logging.@logmsg&quot;&gt; &lt;code&gt;@logmsg&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d691ad463ac25297b3313f781ce7492928f99d06" translate="yes" xml:space="preserve">
          <source>Optional Arguments</source>
          <target state="translated">선택적 인수</target>
        </trans-unit>
        <trans-unit id="6028b0d5037105ac8c7fc43ef8827d1357d9f48d" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments&quot;&gt;Note on Optional and keyword Arguments&lt;/a&gt;). This can be checked for our &lt;code&gt;Date&lt;/code&gt; function example by calling &lt;code&gt;methods&lt;/code&gt; function.</source>
          <target state="translated">선택적 인수는 실제로 인수 수가 다른 여러 메서드 정의를 작성하기위한 편리한 구문 일뿐입니다 ( &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments&quot;&gt;옵션 및 키워드 인수에&lt;/a&gt; 대한 참고 사항 참조 ). 이것은 우리에 대해 확인할 수 있습니다 &lt;code&gt;Date&lt;/code&gt; 를 호출하여 기능의 예 &lt;code&gt;methods&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="c156ad5dd399595345f3f0b1a62545c1d9461fea" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments-1&quot;&gt;Note on Optional and keyword Arguments&lt;/a&gt;). This can be checked for our &lt;code&gt;Date&lt;/code&gt; function example by calling &lt;code&gt;methods&lt;/code&gt; function.</source>
          <target state="translated">선택적 인수는 실제로 다른 개수의 인수로 여러 메소드 정의를 작성하기위한 편리한 구문입니다 ( &lt;a href=&quot;../methods/index#Note-on-Optional-and-keyword-Arguments-1&quot;&gt;선택 사항 및 키워드 인수에&lt;/a&gt; 대한 참고 사항 참조 ). &lt;code&gt;methods&lt;/code&gt; function 을 호출하여 &lt;code&gt;Date&lt;/code&gt; 함수 예제를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f672e593f5c2debc9f124a5145222ec3e7c5de62" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;AllowedType&lt;/code&gt; relaxes the test, by making it pass when either the type of &lt;code&gt;f(x)&lt;/code&gt; matches the inferred type modulo &lt;code&gt;AllowedType&lt;/code&gt;, or when the return type is a subtype of &lt;code&gt;AllowedType&lt;/code&gt;. This is useful when testing type stability of functions returning a small union such as &lt;code&gt;Union{Nothing, T}&lt;/code&gt; or &lt;code&gt;Union{Missing, T}&lt;/code&gt;.</source>
          <target state="translated">선택적으로 &lt;code&gt;AllowedType&lt;/code&gt; 은 &lt;code&gt;f(x)&lt;/code&gt; 유형이 유추 된 유형 modulo &lt;code&gt;AllowedType&lt;/code&gt; 과 일치 하거나 반환 유형이 &lt;code&gt;AllowedType&lt;/code&gt; 의 하위 유형 인 경우 테스트를 통과시켜 테스트를 완화합니다 . 이는 &lt;code&gt;Union{Nothing, T}&lt;/code&gt; 또는 &lt;code&gt;Union{Missing, T}&lt;/code&gt; 과 같이 작은 공용체를 리턴하는 함수의 유형 안정성을 테스트 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad55710ad0da179a2e07ff4ddd05386729e4605" translate="yes" xml:space="preserve">
          <source>Optionally, an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; may be passed as the first argument to redirect output.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; 은 출력을 리디렉션하는 첫 번째 인수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e925eadfd24d6dcadbc98af889be63a7072a20" translate="yes" xml:space="preserve">
          <source>Optionally, with this form you can also specialize on the type of &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">선택적으로이 양식을 사용하여 &lt;code&gt;dest&lt;/code&gt; 유형을 전문화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df7538e747f40841380a56713e7d2787b0188307" translate="yes" xml:space="preserve">
          <source>Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an &lt;code&gt;IOStream&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 파일에서 헤더를 건너 뛰려면 오프셋 (바이트)을 지정할 수 있습니다. 오프셋의 기본값은 &lt;code&gt;IOStream&lt;/code&gt; 의 현재 스트림 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="605701651cfa6ef7ed858d2bd4686cc27b775fbc" translate="yes" xml:space="preserve">
          <source>Optionally-generated functions</source>
          <target state="translated">선택적으로 생성 된 함수</target>
        </trans-unit>
        <trans-unit id="d7a89a6a7036867a56e048571964e7377e17b84b" translate="yes" xml:space="preserve">
          <source>Options for connecting through a proxy.</source>
          <target state="translated">프록시를 통한 연결 옵션.</target>
        </trans-unit>
        <trans-unit id="9956408533f9b356f2027c2af19ba734ff7eeffb" translate="yes" xml:space="preserve">
          <source>Options for controlling the display of profile results</source>
          <target state="translated">프로필 결과 표시 제어 옵션</target>
        </trans-unit>
        <trans-unit id="5570f96fecf594a439501b253a2a052232a9fcb8" translate="yes" xml:space="preserve">
          <source>Options to control how &lt;code&gt;git_status_foreach_ext()&lt;/code&gt; will issue callbacks. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_status_opt_t&quot;&gt;&lt;code&gt;git_status_opt_t&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">&lt;code&gt;git_status_foreach_ext()&lt;/code&gt; 가 콜백을 발행 하는 방법을 제어하는 ​​옵션 . &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_status_opt_t&quot;&gt; &lt;code&gt;git_status_opt_t&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="09b7d446a14ffb508604e0dc10c5b7aa125df09d" translate="yes" xml:space="preserve">
          <source>Or for use with Julia's metaprogramming functionality:</source>
          <target state="translated">또는 Julia의 메타 프로그래밍 기능과 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b5d347e4a07542d29e6ad6bac37e10d945034f91" translate="yes" xml:space="preserve">
          <source>Or in reverse order by a transformation:</source>
          <target state="translated">또는 변환에 의해 역순으로 :</target>
        </trans-unit>
        <trans-unit id="22c33f400210116707836ec8165b8593271e796f" translate="yes" xml:space="preserve">
          <source>Or similary with &lt;code&gt;perf&lt;/code&gt; :</source>
          <target state="translated">또는 &lt;code&gt;perf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d6f1bff2e8ff8f63044d056dab4a7ec43a5bafb9" translate="yes" xml:space="preserve">
          <source>Or similary with with &lt;code&gt;perf&lt;/code&gt; :</source>
          <target state="translated">또는 &lt;code&gt;perf&lt;/code&gt; 와의 유사성 :</target>
        </trans-unit>
        <trans-unit id="643c06d525fb92f1d6423f6e6b9cceb50ab627c9" translate="yes" xml:space="preserve">
          <source>Or the short form notation:</source>
          <target state="translated">또는 짧은 형식 표기법 :</target>
        </trans-unit>
        <trans-unit id="e325f042a4fdea4bb2bf26bcb172b85f8d8b398f" translate="yes" xml:space="preserve">
          <source>Or you could put that code into a script and run it:</source>
          <target state="translated">또는 해당 코드를 스크립트에 넣고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20dbfbec42bb9c9ae019f4de0fc6d751181ab4ba" translate="yes" xml:space="preserve">
          <source>Orange Book</source>
          <target state="translated">오렌지 북</target>
        </trans-unit>
        <trans-unit id="1f4f65818576f11a271c283501f9c9777a309c75" translate="yes" xml:space="preserve">
          <source>Order-Related Functions</source>
          <target state="translated">주문 관련 기능</target>
        </trans-unit>
        <trans-unit id="08958be0b6b4d59402e8c3539af8a1f6c4626498" translate="yes" xml:space="preserve">
          <source>Ordered lists are written by replacing the &quot;bullet&quot; character, either &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, or &lt;code&gt;-&lt;/code&gt;, with a positive integer followed by either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">정렬 된 목록은 &quot;글 머리 기호&quot;문자 ( &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; )를 양의 정수와 그 뒤에 오는으로 대체하여 작성됩니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebecd2371b5b94b4b632a7345f2ed4969d932ab" translate="yes" xml:space="preserve">
          <source>OrdinalRange</source>
          <target state="translated">OrdinalRange</target>
        </trans-unit>
        <trans-unit id="110f685c533d15161bdb96f31c09d8e08a6ec5f5" translate="yes" xml:space="preserve">
          <source>Original Of</source>
          <target state="translated">원본</target>
        </trans-unit>
        <trans-unit id="8a2c422f6e969a4ab0e509e76d2af5e57bbac8a6" translate="yes" xml:space="preserve">
          <source>Orthogonalize your design</source>
          <target state="translated">디자인을 직교</target>
        </trans-unit>
        <trans-unit id="354c9b5e6f7e399ccafd2041e1f89b4ea9b2b78c" translate="yes" xml:space="preserve">
          <source>Other Test Macros</source>
          <target state="translated">다른 테스트 매크로</target>
        </trans-unit>
        <trans-unit id="d932e5243006c50ece04ebc58ddfa354640e1bce" translate="yes" xml:space="preserve">
          <source>Other characters that support such extensions include \odot &lt;code&gt;⊙&lt;/code&gt; and \oplus &lt;code&gt;&amp;oplus;&lt;/code&gt;</source>
          <target state="translated">이러한 확장을 지원하는 다른 문자로는 \ odot &lt;code&gt;⊙&lt;/code&gt; 및 \ oplus &lt;code&gt;&amp;oplus;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f16299e775b6ed02c52fa3e91a6bae26c711f17" translate="yes" xml:space="preserve">
          <source>Other constructors:</source>
          <target state="translated">다른 생성자 :</target>
        </trans-unit>
        <trans-unit id="de3bc1f63e468cd0b128dfc49cf966142493ea71" translate="yes" xml:space="preserve">
          <source>Other functions with optimized methods</source>
          <target state="translated">최적화 된 방법을 가진 다른 기능</target>
        </trans-unit>
        <trans-unit id="73004fc90947ff97722d45638ee7f61f1d20cbf1" translate="yes" xml:space="preserve">
          <source>Other known potential failure scenarios include:</source>
          <target state="translated">다른 알려진 잠재적 실패 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c24cf096faa5c89a991560f741c7e988253e7c13" translate="yes" xml:space="preserve">
          <source>Other types of clusters can be supported by writing your own custom &lt;code&gt;ClusterManager&lt;/code&gt;, as described below in the &lt;a href=&quot;#ClusterManagers&quot;&gt;ClusterManagers&lt;/a&gt; section.</source>
          <target state="translated">다른 유형의 클러스터는 아래 &lt;a href=&quot;#ClusterManagers&quot;&gt;ClusterManagers&lt;/a&gt; 섹션 에 설명 된대로 사용자 정의 &lt;code&gt;ClusterManager&lt;/code&gt; 를 작성하여 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8180f53ba099ee9c2b3f9518b6c8ae95ee30562b" translate="yes" xml:space="preserve">
          <source>Other types of clusters can be supported by writing your own custom &lt;code&gt;ClusterManager&lt;/code&gt;, as described below in the &lt;a href=&quot;#ClusterManagers-1&quot;&gt;ClusterManagers&lt;/a&gt; section.</source>
          <target state="translated">다른 유형의 클러스터는 아래의 &lt;a href=&quot;#ClusterManagers-1&quot;&gt;ClusterManagers&lt;/a&gt; 섹션 에 설명 된대로 사용자 정의 &lt;code&gt;ClusterManager&lt;/code&gt; 를 작성하여 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="652ffacf8747e46f58045bb41bbc2a406d21640f" translate="yes" xml:space="preserve">
          <source>Other types, of course, are not subtypes of it:</source>
          <target state="translated">물론 다른 유형은 하위 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="68e4eead30d10cf40ff1bbd6f5b1c0db347b9736" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;Project.toml&lt;/code&gt; does not exist), then &lt;code&gt;uuid&lt;/code&gt; is the all-zero &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID&quot;&gt;nil UUID&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 ( &lt;code&gt;Project.toml&lt;/code&gt; 이 존재하지 않는 경우 ) &lt;code&gt;uuid&lt;/code&gt; 는 0이 아닌 &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID&quot;&gt;nil UUID&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5236b13473338eac52a3d83cc71dc415eb79f9d1" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;uuid&lt;/code&gt; is mapped to &lt;code&gt;src/X.jl&lt;/code&gt; relative to the directory containing the project file.</source>
          <target state="translated">그렇지 않으면, &lt;code&gt;uuid&lt;/code&gt; 는 프로젝트 파일을 포함하는 디렉토리를 기준으로 &lt;code&gt;src/X.jl&lt;/code&gt; 에 맵핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0609316d4310d32bfdfa1002eac1e93f25b603" translate="yes" xml:space="preserve">
          <source>Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;sup&gt;&lt;a href=&quot;#footnote-BH83&quot; id=&quot;citeref-BH83&quot;&gt;[BH83]&lt;/a&gt;&lt;/sup&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">그렇지 않으면 제곱근은 &lt;sup&gt;&lt;a href=&quot;#footnote-BH83&quot; id=&quot;citeref-BH83&quot;&gt;Bj&amp;ouml;rck&lt;/a&gt;&lt;/sup&gt; -Hammarling 방법 &lt;sup&gt;[BH83]&lt;/sup&gt; 을 사용하여 결정됩니다.이 방법 은 복잡한 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) 을 계산 한 다음 삼각 인자의 복소 제곱근을 계산합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
