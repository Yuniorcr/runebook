<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="3a523b8313fbe29c65c45525ad0a4e750b10d366" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;no-threads&lt;/code&gt;, &lt;code&gt;one-thread-per-connection&lt;/code&gt;, &lt;code&gt;pool-of-threads&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;no-threads&lt;/code&gt; , &lt;code&gt;one-thread-per-connection&lt;/code&gt; , &lt;code&gt;pool-of-threads&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aee82f467488b3cbeb65e5d1995423f4f9dc85ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;none&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;cont&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;none&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;area&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;cont&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7e0f919c027a2b02eb02819edbc488450bae651" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;none&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;reflex&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;estimate&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;keep_average&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;none&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;reflex&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;estimate&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;keep_average&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4ecd50b63a8d1586faa991c99c5cfbd2d61f09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;none&lt;/code&gt;, &lt;code&gt;aes_ecb&lt;/code&gt;, &lt;code&gt;aes_cbc&lt;/code&gt;, &lt;code&gt;aes_ctr&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;aes_ecb&lt;/code&gt; , &lt;code&gt;aes_cbc&lt;/code&gt; , &lt;code&gt;aes_ctr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0aa7a969c394a9db1b5fb23517813f9a13ce104f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;none&lt;/code&gt;, &lt;code&gt;random&lt;/code&gt;, &lt;code&gt;linear&lt;/code&gt;, &lt;code&gt;both&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;random&lt;/code&gt; , &lt;code&gt;linear&lt;/code&gt; , &lt;code&gt;both&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fdb26b9d708f58b43c0bf5719f9f25e624c0b11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;none&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt;, &lt;code&gt;lz4&lt;/code&gt;, &lt;code&gt;lzo&lt;/code&gt;, &lt;code&gt;lzma&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;snappy&lt;/code&gt; (&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;zlib&lt;/code&gt; , &lt;code&gt;lz4&lt;/code&gt; , &lt;code&gt;lzo&lt;/code&gt; , &lt;code&gt;lzma&lt;/code&gt; , &lt;code&gt;bzip2&lt;/code&gt; 또는 &lt;code&gt;snappy&lt;/code&gt; ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="53746a449db891c4fffe44f6deb4b6774ac62bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;nulls_equal&lt;/code&gt;, &lt;code&gt;nulls_unequal&lt;/code&gt;, &lt;code&gt;nulls_ignored&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;nulls_equal&lt;/code&gt; , &lt;code&gt;nulls_unequal&lt;/code&gt; , &lt;code&gt;nulls_ignored&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d964f91ddeb5e02793b884034a12c97e8e9baa15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;redundant&lt;/code&gt;, &lt;code&gt;compact&lt;/code&gt; or &lt;code&gt;dynamic&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;redundant&lt;/code&gt; , &lt;code&gt;compact&lt;/code&gt; 또는 &lt;code&gt;dynamic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5074809b890cc2b1409186e08fa9dadbf6cc37b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;rsync&lt;/code&gt;, &lt;code&gt;mysqldump&lt;/code&gt;, &lt;code&gt;xtrabackup&lt;/code&gt;, &lt;code&gt;xtrabackup-v2&lt;/code&gt;, &lt;code&gt;mariabackup&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;rsync&lt;/code&gt; , &lt;code&gt;mysqldump&lt;/code&gt; , &lt;code&gt;xtrabackup&lt;/code&gt; , &lt;code&gt;xtrabackup-v2&lt;/code&gt; , &lt;code&gt;mariabackup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e784444e0ab0f69aa36266953479514ca48fb0f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;strict&lt;/code&gt;, &lt;code&gt;optimized&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;strict&lt;/code&gt; 하고 &lt;code&gt;optimized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="832c65549487f6468c4cd3f0b04e0e295645cf01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;table&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="620f62057a388287b646f05ccdac3d6a6919f494" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;timestamp_value&lt;/code&gt; (Unix epoch timestamp, not MariaDB timestamp), &lt;code&gt;DEFAULT&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;timestamp_value&lt;/code&gt; (MariaDB 타임 스탬프가 아닌 Unix epoch 타임 스탬프), &lt;code&gt;DEFAULT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="351c2a83d5886254c51f3a660faf5000a456cd81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;tokudb_default&lt;/code&gt;, &lt;code&gt;tokudb_fast&lt;/code&gt;, &lt;code&gt;tokudb_small&lt;/code&gt;, &lt;code&gt;tokudb_zlib&lt;/code&gt;, &lt;code&gt;tokudb_quicklz&lt;/code&gt;, &lt;code&gt;tokudb_lzma&lt;/code&gt;, &lt;code&gt;tokudb_uncompressed&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;tokudb_default&lt;/code&gt; , &lt;code&gt;tokudb_fast&lt;/code&gt; , &lt;code&gt;tokudb_small&lt;/code&gt; , &lt;code&gt;tokudb_zlib&lt;/code&gt; , &lt;code&gt;tokudb_quicklz&lt;/code&gt; , &lt;code&gt;tokudb_lzma&lt;/code&gt; , &lt;code&gt;tokudb_uncompressed&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abde1cb2e219427e26169673d899c5189128522e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values:&lt;/strong&gt;&lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;experimental&lt;/code&gt;, &lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;beta&lt;/code&gt;, &lt;code&gt;gamma&lt;/code&gt;, &lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 : &lt;/strong&gt; &lt;code&gt;unknown&lt;/code&gt; , &lt;code&gt;experimental&lt;/code&gt; , &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;beta&lt;/code&gt; , &lt;code&gt;gamma&lt;/code&gt; , &lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a24b08b0f00c3ea503fac16e55a2b012df4d68ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid Values&lt;/strong&gt;: (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;) &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;SERVER&lt;/code&gt;, &lt;code&gt;TRANSACTION&lt;/code&gt;, &lt;code&gt;STREAMING&lt;/code&gt;, &lt;code&gt;CLIENT&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값&lt;/strong&gt; : (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; ) &lt;code&gt;NONE&lt;/code&gt; , &lt;code&gt;SERVER&lt;/code&gt; , &lt;code&gt;TRANSACTION&lt;/code&gt; , &lt;code&gt;STREAMING&lt;/code&gt; , &lt;code&gt;CLIENT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a10a194d91bb64a9bace39e50179b589a0b7e73c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Valid values:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;유효한 값 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b9da551a5c95a37411ea3f1a962500b3aac2b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variable Name:&lt;/strong&gt;&lt;code&gt;verify-binlog-checksum&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;변수 이름 : &lt;/strong&gt; &lt;code&gt;verify-binlog-checksum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcebb4e7232a114a1dabd263ca798d5983195d48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: Incorrect LSN values can make the backup unusable. It is impossible to diagnose this issue.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 잘못된 LSN 값은 백업을 사용할 수 없게 만들 수 있습니다. 이 문제를 진단하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="2d8d97f0747c47759767d2084d8e8988ff2307da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WFS&lt;/strong&gt; = Window Function Step: Performing a window function.</source>
          <target state="translated">&lt;strong&gt;WFS&lt;/strong&gt; = 창 기능 단계 : 창 기능 수행.</target>
        </trans-unit>
        <trans-unit id="5fc31084d23ca257f7b0555d9dd4c6231a5f92bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; After &lt;a href=&quot;../insert-delayed/index&quot;&gt;INSERT DELAYED&lt;/a&gt;, ROW_COUNT() returns the number of the rows you tried to insert, not the number of the successful writes.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt;&lt;a href=&quot;../insert-delayed/index&quot;&gt;INSERT DELAYED&lt;/a&gt; 후에 ROW_COUNT ()는 성공적인 쓰기 수가 아닌 삽입하려는 행 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61fd731262c8527853378ad930f336329797bb81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When used after a &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; statement, this function returns the number of rows affected by the last statement in the procedure, not by the whole procedure.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt;&lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; 문 다음에 사용될 경우이 함수는 전체 프로 시저가 아니라 프로 시저의 마지막 명령문에 의해 영향을받는 행 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b7cb5d260a6ecc59b5b1f017f9a700027b3c0749" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When used after a &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; statement, this function returns the number of rows selected by the last query in the procedure, not by the whole procedure.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 뒤에 사용하면 &lt;a href=&quot;../call/index&quot;&gt;CALL의&lt;/a&gt; 문이 기능은 절차의 마지막 쿼리에 의해 선택된 행의 수를 반환하지 전체 절차에 의해.</target>
        </trans-unit>
        <trans-unit id="abee62e82abd79577165446d7fc99eed7fcbd110" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; You can use ROW_COUNT() with prepared statements, but you need to call it after EXECUTE, not after &lt;a href=&quot;../deallocate-drop-prepared-statement/index&quot;&gt;DEALLOCATE PREPARE&lt;/a&gt;, because the row count for allocate prepare is always 0.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 준비된 명령문과 함께 ROW_COUNT ()를 사용할 수 있지만 할당 준비의 행 수가 항상 0이므로 &lt;a href=&quot;../deallocate-drop-prepared-statement/index&quot;&gt;DEALLOCATE PREPARE&lt;/a&gt; 이후가 아니라 EXECUTE 후에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e63e8be2a995ca3e24f4a1f142d6ebd87578771" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt;&lt;code&gt;msql2mysql&lt;/code&gt; converts the input file in place, so make a copy of the original before converting it.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;code&gt;msql2mysql&lt;/code&gt; 은 입력 파일을 제자리로 변환하므로 변환하기 전에 원본을 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="2756abf1eaa19230be9bb95e04f5d2e16307d6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae5d987fba2068ca9031ac1cd3272bc17c97bbad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; Users with &lt;code&gt;SELECT&lt;/code&gt; privileges on &lt;code&gt;&lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;USAGE&lt;/code&gt; privileges on &lt;code&gt;*.*&lt;/code&gt; can view the text of routines, even when they do not have privileges for the function or procedure itself.</source>
          <target state="translated">&lt;strong&gt;경고 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 또는 &lt;code&gt;*.*&lt;/code&gt; 에 대한 &lt;code&gt;USAGE&lt;/code&gt; 권한을 가진 사용자 는 함수 나 프로 시저 자체에 대한 권한이없는 경우에도 루틴 텍스트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc92ea8ed196a76192ec04bcc2beeeba45670d8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: If you do the above live copy, you are doing this on &lt;strong&gt;your own risk&lt;/strong&gt; as if you do something wrong, the copied table is very likely to be corrupted. The original table will of course be fine.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 위의 라이브 사본을 수행하는 경우, 잘못된 일을하는 것처럼 &lt;strong&gt;자신의 위험을 감수&lt;/strong&gt; 하고 복사 한 테이블이 손상 될 가능성이 큽니다. 원래 테이블은 물론 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="282e7b26da698c8bd2e83398cb565191187886bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: currently values in the 1000-2000 range seem to cause server crashes, see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16732&quot;&gt;MDEV-16732&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 현재 1000-2000 범위의 값은 서버 충돌을 일으키는 것으로 보입니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16732&quot;&gt;MDEV-16732&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="14155d4150a28a64c86972373f0359809cdaafb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Write-once:&lt;/strong&gt; PBXT uses a log-based storage which makes it possible to write transactional data directly to the database, without first being writen to the transaction log.</source>
          <target state="translated">&lt;strong&gt;1 회 기록 :&lt;/strong&gt; PBXT는 로그 기반 스토리지를 사용하므로 트랜잭션 로그에 먼저 기록하지 않고도 트랜잭션 데이터를 데이터베이스에 직접 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c4c128b7fba4eab6f8d5f413c604146669145c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Writeset caching during state transfer.&lt;/strong&gt; When a node is receiving a state transfer it cannot process and apply incoming writesets because it has no state to apply them to yet. Depending on a state transfer mechanism (e.g. &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;) the node that sends the state transfer may not be able to apply writesets as well. Thus they need to cache those writesets for a catch-up phase. Currently the writesets are cached in memory and, if the system runs out of memory either the state transfer will fail or the cluster will block waiting for the state transfer to end.</source>
          <target state="translated">&lt;strong&gt;상태 전송 중 쓰기 세트 캐싱 &lt;/strong&gt;노드가 상태 전송을 수신 할 때 아직 적용 할 상태가 없기 때문에 들어오는 쓰기 세트를 처리하고 적용 할 수 없습니다. 상태 전송 메커니즘 (예 : &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; )에 따라 상태 전송을 보내는 노드가 쓰기 세트를 적용하지 못할 수도 있습니다. 따라서 캐치 업 단계를 위해 해당 쓰기 세트를 캐시해야합니다. 현재 쓰기 세트는 메모리에 캐시되며 시스템의 메모리가 부족하면 상태 전송이 실패하거나 클러스터가 상태 전송이 끝나기를 기다리는 것을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="e1c8ab0b752274979fb5e5da3cd6ff4270630b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;X&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427ccb5e27847c624de66c980a4fd0ef66888e4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;YES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;YES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f32756242b82f958a367cbf2846897d616a4c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Z&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Z&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a170db9f35a38b95b8577b18f9bd42476019372" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[n]{L or B or H}[n]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;[n] {L 또는 B 또는 H} [n]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57f2ef5b9b54b14f674d86a2c6fdf1593493f1a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;aria_read_log&lt;/strong&gt; is a tool for displaying and applying log records from an &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; transaction log.</source>
          <target state="translated">&lt;strong&gt;aria_read_log&lt;/strong&gt; 는 &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 트랜잭션 로그 에서 로그 레코드를 표시하고 적용하기위한 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="147b9fb10a205ccb7cfd7fc405cf543c5ae3c4f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;avg_mode&lt;/strong&gt; - mathematical mode, i.e the most frequent value in the set</source>
          <target state="translated">&lt;strong&gt;avg_mode-&lt;/strong&gt; 수학적 모드, 즉 집합에서 가장 빈번한 값</target>
        </trans-unit>
        <trans-unit id="307e22d6e007d8c10b485800726a12d43d7833bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;backend1&lt;/strong&gt; which will act as a backed server storing data</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;데이터를 저장하는 백업 서버 역할을하는 &lt;strong&gt;backend1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0254f56382e9efb8bc1a83cf0a858f77e9455c13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;backend2&lt;/strong&gt; which will act as a second backend server storing data</source>
          <target state="translated">&lt;strong&gt;backend2&lt;/strong&gt; 데이터를 저장하는 제 백엔드 서버 역할을 할</target>
        </trans-unit>
        <trans-unit id="6dbaf7452f9728a38e8c0eeaaf66732f3606e760" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;certification&lt;/strong&gt; layer takes care of preparing write sets and performing certification</source>
          <target state="translated">&lt;strong&gt;인증&lt;/strong&gt; 계층은 쓰기 세트 준비 및 인증 수행을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="358aa1f7ab7837d719aa7564ecec64ed7ede6218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;col&lt;/strong&gt;umns</source>
          <target state="translated">&lt;strong&gt;col&lt;/strong&gt;umns</target>
        </trans-unit>
        <trans-unit id="6108bd6692936d6cd80fd58a4cc229d8982acf32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;count&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;count&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a9b9e98d9de17a41807c7dbd8f07d04520e382a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;count&lt;/strong&gt; indicates how many times the mutex was requested.</source>
          <target state="translated">&lt;strong&gt;count&lt;/strong&gt; 는 뮤텍스가 요청 된 &lt;strong&gt;횟수를&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ee5a001126306b494386ddb6e5b4191c4bd1d9df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;customer.filtered=18.08, customer.r_filtered=9.13&lt;/strong&gt;. The optimizer somewhat overestimated the number of records that will match selectivity of condition attached to `customer` table (in general, when you have a full scan and r_filtered is less than 15%, it's time to consider adding an appropriate index).</source>
          <target state="translated">&lt;strong&gt;customer.filtered = 18.08, customer.r_filtered = 9.13&lt;/strong&gt; . 옵티마이 저는 '고객'테이블에 첨부 된 조건의 선택 성과 일치하는 레코드 수를 다소 과대 평가했습니다 (일반적으로 전체 스캔이 있고 r_filtered가 15 % 미만인 경우 적절한 인덱스 추가를 고려할 때입니다).</target>
        </trans-unit>
        <trans-unit id="44ed46be8966ecbbafc6d8439c0e4e209e815e63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;datasource&lt;/strong&gt;s</source>
          <target state="translated">&lt;strong&gt;datasource&lt;/strong&gt;s</target>
        </trans-unit>
        <trans-unit id="ffccd746847cb32d67916c90038f2d9c7e9b96c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;driver&lt;/strong&gt;s</source>
          <target state="translated">&lt;strong&gt;driver&lt;/strong&gt;s</target>
        </trans-unit>
        <trans-unit id="a81f63e53c4056f9219df72284e7f8893c41333d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;dsn&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;dsn&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aefc8804d4d042b2a6f85b06f3fe27dc2186fd96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;end time&lt;/strong&gt; - the time that the last result packet exits ExeMgr, DDLProc or DMLProc</source>
          <target state="translated">&lt;strong&gt;종료 시간&lt;/strong&gt; -마지막 결과 패킷이 ExeMgr, DDLProc 또는 DMLProc을 종료 한 시간</target>
        </trans-unit>
        <trans-unit id="47f6694eea76de630aae53c74ad6b2459a19bdec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;import_sql_select&lt;/strong&gt;: &quot;This function imports the SQL table that is the result of the specified SQL query to H2OFrame in memory&quot;.</source>
          <target state="translated">&lt;strong&gt;import_sql_select&lt;/strong&gt; : &quot;이 함수는 지정된 SQL 쿼리의 결과 인 SQL 테이블을 메모리의 H2OFrame으로 가져옵니다.&quot;</target>
        </trans-unit>
        <trans-unit id="1afd59413c1b7ff53e482d7fc85146a11dac3fc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;import_sql_table&lt;/strong&gt;: &quot;This function imports a SQL table to H2OFrame in memory&quot;.</source>
          <target state="translated">&lt;strong&gt;import_sql_table&lt;/strong&gt; : &quot;이 함수는 SQL 테이블을 메모리의 H2OFrame으로 가져옵니다.&quot;</target>
        </trans-unit>
        <trans-unit id="69a0818251d3a5217fc4bb9fb539d6ed2db11767" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;libudf_mysql.so.1.0.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;libudf_mysql.so.1.0.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d4c0fccac2067eec6fc82f97353c2b3f1858806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;libudfsdk.so.1.0.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;libudfsdk.so.1.0.0&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76cf4335ac332dca1ae860c3d9aeadf4fa5593b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;median&lt;/strong&gt; - mathematical median, equivalent to percentile_cont(0.5)</source>
          <target state="translated">&lt;strong&gt;중앙값&lt;/strong&gt; -수학적 중앙값, percentile_cont (0.5)와 동일</target>
        </trans-unit>
        <trans-unit id="9e5abc5ff0e66623ebe98dbab8816d8a733a200c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;memory:&lt;/strong&gt; For tables and &lt;code&gt;performance_schema&lt;/code&gt;, this is the result of &lt;code&gt;row_size&lt;/code&gt; * &lt;code&gt;row_count&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;메모리 :&lt;/strong&gt; 테이블 및 &lt;code&gt;performance_schema&lt;/code&gt; 의 경우 이는 &lt;code&gt;row_size&lt;/code&gt; * &lt;code&gt;row_count&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="ee80275696835c3f2446c39c8a181b928bb8bfef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mycli&lt;/strong&gt; is a command line interface for MariaDB, MySQL, and Percona with auto-completion and syntax highlighting.</source>
          <target state="translated">&lt;strong&gt;mycli&lt;/strong&gt; 는 자동 완성 및 구문 강조 기능이있는 MariaDB, MySQL 및 Percona 용 명령 줄 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="6a796f716db29ea1661ac7774fd9cd26d34457cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql&lt;/strong&gt; is a simple SQL shell (with GNU readline capabilities). It supports interactive and non-interactive use. When used interactively, query results are presented in an ASCII-table format. When used non-interactively (for example, as a filter), the result is presented in tab-separated format. The output format can be changed using command options.</source>
          <target state="translated">&lt;strong&gt;mysql&lt;/strong&gt; 은 간단한 SQL 셸입니다 (GNU readline 기능 포함). 대화식 및 비 대화식 사용을 지원합니다. 대화식으로 사용하면 쿼리 결과가 ASCII 테이블 형식으로 표시됩니다. 비 대화식 (예 : 필터)으로 사용하면 결과는 탭으로 구분 된 형식으로 표시됩니다. 명령 형식을 사용하여 출력 형식을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="345f1eab095b70f5f83b4c90197c83a06018c2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysqld can't load some executable code, so it can't use the ODBC driver.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysqld는 일부 실행 코드를로드 할 수 없으므로 ODBC 드라이버를 사용할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2ebc748fb7eca78771ef09d69fb45afdeaf94b00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysqld can't open TCP sockets on some ports, so it can't connect to the foreign server.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysqld는 일부 포트에서 TCP 소켓을 열 수 없으므로 외부 서버에 연결할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4def9294595ea5346f270c5d30473083b7c5e8d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;orders.filtered=100, orders.r_filtered=30.03&lt;/strong&gt;. The optimizer didn't have any way to estimate which fraction of records will be left after it checks the condition that is attached to table orders (it's orders.o_totalprice &amp;gt; 200*1000). So, it used 100%. In reality, it is 30%. 30% is typically not selective enough to warrant adding new indexes. For joins with many tables, it might be worth to collect and use &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;column statistics&lt;/a&gt; for columns in question, this may help the optimizer to pick a better query plan.</source>
          <target state="translated">&lt;strong&gt;orders.filtered = 100, orders.r_filtered = 30.03&lt;/strong&gt; . 옵티마이 저는 테이블 주문에 첨부 된 조건을 점검 한 후 남은 레코드 비율을 추정 할 방법이 없었습니다 (orders.o_totalprice&amp;gt; 200 * 1000). 따라서 100 %를 사용했습니다. 실제로는 30 %입니다. 30 %는 일반적으로 새로운 인덱스 추가를 보증 할만큼 충분히 선택적이지 않습니다. 많은 테이블과의 조인의 경우 문제가있는 &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;열에&lt;/a&gt; 대한 열 통계 를 수집하고 사용 하는 것이 좋습니다. 이는 최적화 프로그램이 더 나은 쿼리 계획을 선택하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a6e5488471212e0f9dcea19ebaf7301efe0bef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os_wait_times&lt;/strong&gt; indicates the amount of time (in ms) spent in operating system waits, if the timed_mutexes system variable is 1 (ON). If timed_mutexes is 0 (OFF), timing is disabled, so os_wait_times is 0. timed_mutexes is off by default.</source>
          <target state="translated">&lt;strong&gt;os_wait_times&lt;/strong&gt; 는 timed_mutexes 시스템 변수가 1 (ON) 인 경우 운영 체제 대기에 소요 된 시간 (ms)을 나타냅니다. timed_mutexes가 0 (OFF)이면 타이밍이 비활성화되므로 os_wait_times는 0입니다. timed_mutexes는 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9ba93be7c71b00ba9427c515c299cba1bdc281" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os_waits&lt;/strong&gt; indicates the number of operating system waits. This occurs when the spinlock did not work (the mutex was not locked during the spinlock and it was necessary to yield to the operating system and wait).</source>
          <target state="translated">&lt;strong&gt;os_waits&lt;/strong&gt; 는 운영 체제 대기 수를 나타냅니다. 이것은 스핀 락이 작동하지 않을 때 발생합니다 (스핀 록 동안 뮤텍스가 잠기지 않았으며 운영 체제에 양보하고 기다려야했습니다).</target>
        </trans-unit>
        <trans-unit id="bd0961c6a867d8694f2562d2a2060c76c414ac5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os_yields&lt;/strong&gt; indicates the number of times a the thread trying to lock a mutex gave up its timeslice and yielded to the operating system (on the presumption that allowing other threads to run will free the mutex so that it can be locked).</source>
          <target state="translated">&lt;strong&gt;os_yields&lt;/strong&gt; 는 뮤텍스를 잠그려고하는 스레드가 타임 슬라이스를 포기하고 운영 체제에 양보 한 횟수를 나타냅니다 (다른 스레드를 실행할 수있게하면 뮤텍스가 잠길 수 있다고 가정 할 때).</target>
        </trans-unit>
        <trans-unit id="9da116233d6563f7ae8767c6b6b9e29c949ebcf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;query&lt;/strong&gt; - The text of the query</source>
          <target state="translated">&lt;strong&gt;query-쿼리&lt;/strong&gt; 텍스트</target>
        </trans-unit>
        <trans-unit id="c358e3eb0fb8091e3bca2fcf7d5d3befb25158a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;queryID&lt;/strong&gt; - A unique identifier assigned to the query</source>
          <target state="translated">&lt;strong&gt;queryID-&lt;/strong&gt; 쿼리에 할당 된 고유 식별자</target>
        </trans-unit>
        <trans-unit id="309f6e9cc0e3d900ee801a9281daad90a7ee5383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;queryType&lt;/strong&gt; - The type of the query whether insert, update, delete, select, delete, insert select or load data infile</source>
          <target state="translated">&lt;strong&gt;queryType-데이터&lt;/strong&gt; 삽입, 삽입, 업데이트, 삭제, 선택, 삭제, 삽입 선택 또는로드 여부에 대한 쿼리 유형</target>
        </trans-unit>
        <trans-unit id="0435c528fc5308de093979276d4d5c831ef0d95e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;replication&lt;/strong&gt; manages replication protocol and provides total ordering capabilities</source>
          <target state="translated">&lt;strong&gt;복제&lt;/strong&gt; 는 복제 프로토콜을 관리하고 총 주문 기능을 제공합니다</target>
        </trans-unit>
        <trans-unit id="19426a216960d07df4c5baa6a19168407c0e5635" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;row_count:&lt;/strong&gt; The number of rows in the table or buffer. For some tables, this value depends on a server system variable.</source>
          <target state="translated">&lt;strong&gt;row_count :&lt;/strong&gt; 테이블 또는 버퍼의 행 수입니다. 일부 테이블의 경우이 값은 서버 시스템 변수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0297362fab4bd120391ff5b844f7960b12f3f803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;row_size:&lt;/strong&gt; The memory used for an individual record. This value will never change.</source>
          <target state="translated">&lt;strong&gt;row_size :&lt;/strong&gt; 개별 레코드에 사용 된 메모리. 이 값은 절대 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9316b1ce55d53f059db61de8db551405a143603" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;size&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;size&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4279c20d5bde55c33a5fca07786eda67624fc6ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;spider&lt;/strong&gt; server which will act as the front end server hosting the spider storage engine.</source>
          <target state="translated">&lt;strong&gt;스파이더&lt;/strong&gt; 서버는 스파이더 스토리지 엔진을 호스팅하는 프런트 엔드 서버 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bd2c684c9985651056c29a3c7bed5fe819b7df4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;spin_rounds&lt;/strong&gt; indicates the number of spinlock rounds. (spin_rounds divided by spin_waits provides the average round count.)</source>
          <target state="translated">&lt;strong&gt;spin_rounds&lt;/strong&gt; 는 스핀 록 라운드 수를 나타냅니다. (spin_rounds를 spin_waits로 나눈 값은 평균 라운드 수를 제공합니다.)</target>
        </trans-unit>
        <trans-unit id="1cdd9f73d28b27a3742a3bbf20a2d27cbf5aae88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;spin_waits&lt;/strong&gt; indicates how many times the spinlock had to run.</source>
          <target state="translated">&lt;strong&gt;spin_waits&lt;/strong&gt; 는 spinlock을 몇 번이나 실행 &lt;strong&gt;했는지&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c28d8310e2f03c0b0cec6484f7ebd28d84aa2624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;sqldatasource&lt;/strong&gt;s</source>
          <target state="translated">&lt;strong&gt;sqldatasource&lt;/strong&gt;s</target>
        </trans-unit>
        <trans-unit id="e746893dfe0d1fb0ffb02ebd4d172968424a644d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;sqldriver&lt;/strong&gt;s</source>
          <target state="translated">&lt;strong&gt;sqldriver&lt;/strong&gt;s</target>
        </trans-unit>
        <trans-unit id="81735f5c4f174fed704281cb6b294f35341c6f76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ssq&lt;/strong&gt; - sum of squares, i.e the sum of each individual number squared in the set</source>
          <target state="translated">&lt;strong&gt;ssq-&lt;/strong&gt; 제곱의 합, 즉 세트에서 제곱 한 각 개별 수의 합</target>
        </trans-unit>
        <trans-unit id="35552f77708e47143ea9e05a306f253087f764db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start time&lt;/strong&gt; - the time that the query gets to ExeMgr, DDLProc, or DMLProc</source>
          <target state="translated">&lt;strong&gt;시작 시간&lt;/strong&gt; -쿼리가 ExeMgr, DDLProc 또는 DMLProc에 도달하는 시간</target>
        </trans-unit>
        <trans-unit id="3c53da8ab5a07b2955470127f114234432a84436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tab&lt;/strong&gt;les</source>
          <target state="translated">&lt;strong&gt;tab&lt;/strong&gt;les</target>
        </trans-unit>
        <trans-unit id="761cd232b595f72829db5860dfee60b6fdf30006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;udfmysql.cpp&lt;/strong&gt; : mariadb server UDF implementation</source>
          <target state="translated">&lt;strong&gt;udfmysql.cpp&lt;/strong&gt; : mariadb 서버 UDF 구현</target>
        </trans-unit>
        <trans-unit id="f0b6503ab17d1ffc41f859802e00c29a185a5bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;udfsdk.cpp&lt;/strong&gt; : distributed columnstore UDF implementation.</source>
          <target state="translated">&lt;strong&gt;udfsdk.cpp&lt;/strong&gt; : 분산 &lt;strong&gt;컬럼 저장소&lt;/strong&gt; UDF 구현.</target>
        </trans-unit>
        <trans-unit id="26631923726b0dd39ac83d807e1ce93ffc2593c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;udfsdk.h&lt;/strong&gt; : class headers.</source>
          <target state="translated">&lt;strong&gt;udfsdk.h&lt;/strong&gt; : 클래스 헤더.</target>
        </trans-unit>
        <trans-unit id="bbdddc0cb083fd46a94db416cc445fe27fd2471a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;wsrep API&lt;/strong&gt; specifies the interface &amp;mdash; responsibilities for DBMS and replication provider</source>
          <target state="translated">&lt;strong&gt;wsrep API&lt;/strong&gt; 가 DBMS 및 복제 제공자의 책임 인 인터페이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="eee2f4a07fe9f66e2b87fd6d9dc8e40b4cac0cd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;wsrep hooks&lt;/strong&gt; is the wsrep integration in the DBMS engine.</source>
          <target state="translated">&lt;strong&gt;wsrep 후크&lt;/strong&gt; 는 DBMS 엔진의 wsrep 통합입니다.</target>
        </trans-unit>
        <trans-unit id="dc6be7b2d79cf4083d96df3b86e937d3cb084e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Сustomization fully adapted for users&amp;rsquo; needs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сustomization은 사용자의 요구에 완전히 적응&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bf3ca129dc3ee4a1f77628f10685bf76c8ad1cdb" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;em&gt;&lt;a href=&quot;https://downloads.mariadb.org/mariadb/10.3.18/&quot;&gt;Alternate download from mariadb.org&lt;/a&gt;&lt;/em&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;&lt;a href=&quot;https://downloads.mariadb.org/mariadb/10.3.18/&quot;&gt;mariadb.org에서 대체 다운로드&lt;/a&gt;&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0fd21d4ea72ba084c5db88d5ad2b0b511d8f88cc" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;em&gt;&lt;a href=&quot;https://downloads.mariadb.org/mariadb/10.4.8/&quot;&gt;Alternate download from mariadb.org&lt;/a&gt;&lt;/em&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;&lt;a href=&quot;https://downloads.mariadb.org/mariadb/10.4.8/&quot;&gt;mariadb.org에서 대체 다운로드&lt;/a&gt;&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ad074a4051965d0b65fe66a9d2cf6e8b865dd15" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt;only needed if you want to execute DDL.</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; DDL을 실행하려는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8eaf2d577c1ccfe73e884d22c1879b4b91c674cc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;+&lt;/sup&gt;not officially supported by Pentaho.</source>
          <target state="translated">&lt;sup&gt;+&lt;/sup&gt; 공식적으로 Pentaho가 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="2b817cacc974a7fb1b892d5d0aff622f2da1ddc0" translate="yes" xml:space="preserve">
          <source>= 1.5 GB of redo log written since last checkpoint</source>
          <target state="translated">= 마지막 체크 포인트 이후 작성된 1.5GB의 리두 로그</target>
        </trans-unit>
        <trans-unit id="d7d6357dd90e729a54b82cccc78f68757229dd85" translate="yes" xml:space="preserve">
          <source>= 1631032539 byes / (1024 * 1024 * 1024) (GB/bytes)</source>
          <target state="translated">= 1631032539 바이트 / (1024 * 1024 * 1024) (GB / 바이트)</target>
        </trans-unit>
        <trans-unit id="6bef93a5cd3dfbd9c7de1d514f3bd7bb0e879ce5" translate="yes" xml:space="preserve">
          <source>= 1631032539 bytes</source>
          <target state="translated">= 1631032539 바이트</target>
        </trans-unit>
        <trans-unit id="c6c1e53ceb199e68eafb11c38f526aba29f28453" translate="yes" xml:space="preserve">
          <source>= 252794398789379 - 252792767756840</source>
          <target state="translated">= 252794398789379-252792767756840</target>
        </trans-unit>
        <trans-unit id="7283902f92638f0d632b2d9dcd2f92fe7d5a0c84" translate="yes" xml:space="preserve">
          <source>= &lt;code&gt;0.375&lt;/code&gt;</source>
          <target state="translated">= &lt;code&gt;0.375&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50caca8030931549b2aec3cf1f6dcabbcc1b0411" translate="yes" xml:space="preserve">
          <source>= &lt;code&gt;1.5G&lt;/code&gt; / &lt;code&gt;4G&lt;/code&gt;</source>
          <target state="translated">= &lt;code&gt;1.5G&lt;/code&gt; / &lt;code&gt;4G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="162873ccd31d6cea5a55d7be538845431ead0d1e" translate="yes" xml:space="preserve">
          <source>= &lt;code&gt;2G&lt;/code&gt; * &lt;code&gt;2&lt;/code&gt;</source>
          <target state="translated">= &lt;code&gt;2G&lt;/code&gt; * &lt;code&gt;2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a200bd26d1f32550bdd876bbe257607fada201" translate="yes" xml:space="preserve">
          <source>= &lt;code&gt;4G&lt;/code&gt;</source>
          <target state="translated">= &lt;code&gt;4G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16c8f8ac7b57bd5b58b41327228e3fa21201db68" translate="yes" xml:space="preserve">
          <source>??</source>
          <target state="translated">??</target>
        </trans-unit>
        <trans-unit id="9f66c326850735661881b8e7a05e28cb1f2a742a" translate="yes" xml:space="preserve">
          <source>@&quot;var_name&quot;</source>
          <target state="translated">@&quot;var_name&quot;</target>
        </trans-unit>
        <trans-unit id="95ef320ce40d03a12fcb5dcea528b8e4cc03ec8d" translate="yes" xml:space="preserve">
          <source>@'var_name'</source>
          <target state="translated">@'var_name'</target>
        </trans-unit>
        <trans-unit id="aadec88fbdba2666ab832545fc804a79ff989cf5" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_EXECUTED was changed from '%s' to '%s'.</source>
          <target state="translated">@@ GLOBAL.GTID_EXECUTED가 '% s'에서 '% s'(으)로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7586cbff14135c0638782652ea5bbfcd1a97efa" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_MODE = ON or UPGRADE_STEP_1 or UPGRADE_STEP_2 requires --log-bin and --log-slave-updates.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE = ON 또는 UPGRADE_STEP_1 또는 UPGRADE_STEP_2에는 --log-bin 및 --log-slave-updates가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bd9fd77cf1ef430540742bd799f62253f30d20cf" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_MODE = ON or UPGRADE_STEP_2 requires @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE = ON 또는 UPGRADE_STEP_2에는 @@ GLOBAL.ENFORCE_GTID_CONSISTENCY = 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a95c08d94425dcba4789ad399aef05246973bb8" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_EXECUTED is empty.</source>
          <target state="translated">@@ GLOBAL.GTID_PURGED는 @@ GLOBAL.GTID_EXECUTED가 비어있는 경우에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd15c5ec9ccbdf35877f8b2011caa0827872907f" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_PURGED can only be set when @@GLOBAL.GTID_MODE = ON.</source>
          <target state="translated">@@ GLOBAL.GTID_PURGED는 @@ GLOBAL.GTID_MODE = ON 인 경우에만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb730dfdeff4d619fcb70eee38f51cdd16df0dc" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_PURGED can only be set when there are no ongoing transactions (not even in other clients).</source>
          <target state="translated">@@ GLOBAL.GTID_PURGED는 진행중인 트랜잭션이없는 경우에만 설정할 수 있습니다 (다른 클라이언트에서도).</target>
        </trans-unit>
        <trans-unit id="789db402034eaab46e914984f7427bf66094c7be" translate="yes" xml:space="preserve">
          <source>@@GLOBAL.GTID_PURGED was changed from '%s' to '%s'.</source>
          <target state="translated">@@ GLOBAL.GTID_PURGED가 '% s'에서 '% s'(으)로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e1422016bd362c4baac4f77d5ab556927e7536f" translate="yes" xml:space="preserve">
          <source>@@SESSION.GTID_NEXT cannot be changed by a client that owns a GTID. The client owns %s. Ownership is released on COMMIT or ROLLBACK.</source>
          <target state="translated">@@ SESSION.GTID_NEXT는 GTID를 소유 한 클라이언트가 변경할 수 없습니다. 클라이언트는 % s를 소유합니다. 소유권은 COMMIT 또는 ROLLBACK에서 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="28de5a294a54a9d4e80d2bf2d353ede0e5ac83db" translate="yes" xml:space="preserve">
          <source>@@SESSION.GTID_NEXT cannot be set to ANONYMOUS when @@GLOBAL.GTID_MODE = ON.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE = ON 인 경우 @@ SESSION.GTID_NEXT를 ANONYMOUS로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="400c88ed32d8d4f80ec5bb46fbd7d6481385b708" translate="yes" xml:space="preserve">
          <source>@@SESSION.GTID_NEXT cannot be set to UUID:NUMBER when @@GLOBAL.GTID_MODE = OFF.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE = OFF 인 경우 @@ SESSION.GTID_NEXT를 UUID : NUMBER로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2194bc7e9915f3879e1213b7f36921654b0accbe" translate="yes" xml:space="preserve">
          <source>@@SESSION.GTID_NEXT_LIST cannot be set to a non-NULL value when @@GLOBAL.GTID_MODE = OFF.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE = OFF 인 경우 @@ SESSION.GTID_NEXT_LIST를 NULL이 아닌 값으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ed6915c01afe85d6ca06c5dc4a106c76aa23f07" translate="yes" xml:space="preserve">
          <source>@@rocksdb_debug_optimizer_n_rows - if not 0, report that any MyRocks table has this many rows.</source>
          <target state="translated">@@ rocksdb_debug_optimizer_n_rows-0이 아닌 경우 MyRocks 테이블에이 많은 행이 있다고보고하십시오.</target>
        </trans-unit>
        <trans-unit id="eed6d16601b333df8964c572fc1df2bfcc024147" translate="yes" xml:space="preserve">
          <source>@@rocksdb_force_index_records_in_range - if not 0, and FORCE INDEX hint is used, report that any range has this many rows.</source>
          <target state="translated">@@ rocksdb_force_index_records_in_range-0이 아니고 FORCE INDEX 힌트가 사용되는 경우 범위에이 행이 많은 것으로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="3531987e6e8aab636b34da84aa05008d72932224" translate="yes" xml:space="preserve">
          <source>@@rocksdb_records_in_range - if not 0, report that any range has this many rows</source>
          <target state="translated">@@ rocksdb_records_in_range-0이 아닌 경우 범위에이 행이 많은 것으로보고</target>
        </trans-unit>
        <trans-unit id="e073e3088984a909af471422e98aa724b66481a3" translate="yes" xml:space="preserve">
          <source>@@skip_replication and --replicate-events-marked-for-skip</source>
          <target state="translated">@@ skip_replication 및 --replicate-events-marked-for-skip</target>
        </trans-unit>
        <trans-unit id="aad5f5b863fbe5e6372a4ccb6d5be74647ef62c7" translate="yes" xml:space="preserve">
          <source>@@version</source>
          <target state="translated">@@version</target>
        </trans-unit>
        <trans-unit id="10462a7d3536f29af7141e013fb802e631f176ca" translate="yes" xml:space="preserve">
          <source>@`var_name`</source>
          <target state="translated">@`var_name`</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="d7fd50fe753d4e03b2dac78d36a8f7eae53ebc76" translate="yes" xml:space="preserve">
          <source>A &quot;Covering&quot; index is an index that contains all the columns in the SELECT. It is special in that the SELECT can be completed by looking only at the INDEX BTree. (Since InnoDB's PRIMARY KEY is clustered with the data, &quot;covering&quot; is of no benefit when considering at the PRIMARY KEY.)</source>
          <target state="translated">&quot;표지&quot;색인은 SELECT의 모든 열을 포함하는 색인입니다. INDEX BTree 만보고 SELECT를 완료 할 수 있다는 점이 특별합니다. (InnoDB의 PRIMARY KEY가 데이터와 함께 클러스터되므로 PRIMARY KEY에서 고려할 때 &quot;커버링&quot;은 도움이되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="35de189cc8d1f804a63cf3ff028dc43416a6892f" translate="yes" xml:space="preserve">
          <source>A &quot;fast&quot; DDL may as well be done via TOI. This is a tentative list of such:</source>
          <target state="translated">&quot;빠른&quot;DDL은 TOI를 통해 수행 될 수도 있습니다. 다음은 그러한 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a40c8dd4c1d6440fdbc923ad553d58d88b20c23e" translate="yes" xml:space="preserve">
          <source>A &quot;range&quot; shows up as</source>
          <target state="translated">&quot;범위&quot;는 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cd15db0ce74bb80582962542130ccee3bf5fde9f" translate="yes" xml:space="preserve">
          <source>A %s must include all columns in the table's partitioning function</source>
          <target state="translated">% s은 (는) 테이블의 파티셔닝 함수에 모든 열을 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="8ae53f3e7e61d4c277b6649d42bf0956ff08cd93" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;_&amp;rdquo; character. See note following the table.</source>
          <target state="translated">&amp;ldquo;_&amp;rdquo;문자. 다음 표를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="cc6350c4da8d2f82c70d542ab1424e2b613400af" translate="yes" xml:space="preserve">
          <source>A '&lt;code&gt;ci&lt;/code&gt;' at the end of a collation name indicates the collation is case insensitive. A '&lt;code&gt;cs&lt;/code&gt;' at the end of a collation name indicates the collation is case sensitive. A '&lt;code&gt;nopad&lt;/code&gt;' as part of the name indicates that the collation is of type &lt;code&gt;NO PAD&lt;/code&gt; as opposed to &lt;code&gt;PADSPACE&lt;/code&gt; (see below).</source>
          <target state="translated">데이터 정렬 이름 끝에 있는 ' &lt;code&gt;ci&lt;/code&gt; '는 데이터 정렬이 대소 문자를 구분하지 않음을 나타냅니다. 데이터 정렬 이름 끝에 ' &lt;code&gt;cs&lt;/code&gt; '는 데이터 정렬이 대소 문자를 구분 함을 나타냅니다. 이름의 일부인 ' &lt;code&gt;nopad&lt;/code&gt; '는 데이터 정렬이 &lt;code&gt;PADSPACE&lt;/code&gt; 와 반대로 &lt;code&gt;NO PAD&lt;/code&gt; 유형임을 나타냅니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="ff147fea38b0c78819dff108b3647f13393695a2" translate="yes" xml:space="preserve">
          <source>A 'range' access is done for for several index and the found rows are merged. The key column shows which keys are used.</source>
          <target state="translated">여러 인덱스에 대해 '범위'액세스가 수행되고 발견 된 행이 병합됩니다. 키 열에는 사용 된 키가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="84947a07344e49ebd266c967d29d6ef1af281732" translate="yes" xml:space="preserve">
          <source>A 'standard' GUID/UUID is composed of the time, machine identification and some other stuff. The combination should be unique, even without coordination between different computers that could be generating UUIDs simultaneously.</source>
          <target state="translated">'표준'GUID / UUID는 시간, 기계 식별 및 기타 요소로 구성됩니다. UUID를 동시에 생성 할 수있는 다른 컴퓨터 간의 조정 없이도 조합이 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="05fe680c8e4b11db14df86e8e1a02c6e4ceebffc" translate="yes" xml:space="preserve">
          <source>A (as yet incomplete) list of how MariaDB's output is different from MySQL can be found here: &lt;a href=&quot;../explain-formatjson-differences-from-mysql/index&quot;&gt;EXPLAIN FORMAT=JSON differences from MySQL&lt;/a&gt;.</source>
          <target state="translated">MariaDB의 출력이 MySQL과 어떻게 다른지에 대한 (아직 불완전한) 목록은 여기에서 찾을 수 있습니다 : &lt;a href=&quot;../explain-formatjson-differences-from-mysql/index&quot;&gt;EXPLAIN FORMAT = JSON MySQL과의 차이점&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2caba67cb5a3d0bcdb02d8b00a838604e0fc304b" translate="yes" xml:space="preserve">
          <source>A 5.6 GTID is the combination of a _server_ UUID and a sequence number.</source>
          <target state="translated">5.6 GTID는 _server_ UUID와 시퀀스 번호의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="9a25cc4b803e29a2151aae4c42329c46ff41cb86" translate="yes" xml:space="preserve">
          <source>A 64-bit platform (due to some 32 bit compilers having difficulties with RocksDB)</source>
          <target state="translated">64 비트 플랫폼 (RocksDB에 어려움이있는 일부 32 비트 컴파일러로 인해)</target>
        </trans-unit>
        <trans-unit id="f71143422d8e0ec535a2607656a31c3a84c9b6c0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; column with a maximum length of 16,777,215 (2&lt;sup&gt;24&lt;/sup&gt; - 1) bytes. Each MEDIUMBLOB value is stored using a three-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../blob/index&quot;&gt;BLOB의&lt;/a&gt; 16,777,215 최대 길이 열 (2 &lt;sup&gt;24&lt;/sup&gt; - 1의) 바이트. 각 MEDIUMBLOB 값은 값의 바이트 수를 나타내는 3 바이트 길이 접두사를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="582d5d1e756de6c810134b378d1b542eaefa5812" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; column with a maximum length of 255 (2&lt;sup&gt;8&lt;/sup&gt; - 1) bytes. Each TINYBLOB value is stored using a one-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../blob/index&quot;&gt;BLOB의&lt;/a&gt; (255)의 최대 길이 열 (2 &lt;sup&gt;8&lt;/sup&gt; - 1의) 바이트. 각 TINYBLOB 값은 값의 바이트 수를 나타내는 1 바이트 길이 접두사를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d227dd590f5fa71664095e743a3d017f0373fc65" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; column with a maximum length of 4,294,967,295 bytes or 4GB (2&lt;sup&gt;32&lt;/sup&gt; - 1). The effective maximum length of LONGBLOB columns depends on the configured maximum packet size in the client/server protocol and available memory. Each LONGBLOB value is stored using a four-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../blob/index&quot;&gt;BLOB의&lt;/a&gt; 4,294,967,295 바이트 4기가바이트 (2 최대 길이 컬럼 &lt;sup&gt;32&lt;/sup&gt; - 1)의. LONGBLOB 열의 유효 최대 길이는 클라이언트 / 서버 프로토콜 및 사용 가능한 메모리에서 구성된 최대 패킷 크기에 따라 다릅니다. 각 LONGBLOB 값은 값의 바이트 수를 나타내는 4 바이트 길이 접 두부를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="70d87427448c9e0e70d158a204a2a441ffaf9acf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; is parsed just like any statement. The resulting Lex has the sql_command SQLCOM_CALL, the procedure's name and the parameters are pushed to the Lex' value_list.</source>
          <target state="translated">&lt;a href=&quot;../call/index&quot;&gt;CALL은&lt;/a&gt; 그냥 문처럼 구문 분석됩니다. 결과 Lex에는 sql_command SQLCOM_CALL이 있으며 프로 시저 이름과 매개 변수는 Lex의 value_list로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="523e8e573c9eecaf60bfa08bea84614a3da24790" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statement may include a &lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT&lt;/a&gt; clause to restrict the number of rows the server returns to the client. In some cases, it is desirable to know how many rows the statement would have returned without the LIMIT, but without running the statement again. To obtain this row count, include a &lt;a href=&quot;../select/index#sql_calc_found_rows&quot;&gt;SQL_CALC_FOUND_ROWS&lt;/a&gt; option in the SELECT statement, and then invoke FOUND_ROWS() afterwards.</source>
          <target state="translated">&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문은 포함 할 수 &lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT의&lt;/a&gt; 행 클라이언트에 서버가 반환의 수를 제한하는 조항을. 어떤 경우에는 명령문이 LIMIT없이 리턴되었지만 명령문을 다시 실행하지 않고 리턴 된 행 수를 아는 것이 바람직합니다. 이 행 수를 얻으려면 SELECT 문에 &lt;a href=&quot;../select/index#sql_calc_found_rows&quot;&gt;SQL_CALC_FOUND_ROWS&lt;/a&gt; 옵션을 포함시킨 후 FOUND_ROWS ()를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="570161406360fbd9930a6a76d1fb75d455d2e3a5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../sleep/index&quot;&gt;SLEEP()&lt;/a&gt; call has been invoked.</source>
          <target state="translated">&lt;a href=&quot;../sleep/index&quot;&gt;SLEEP ()&lt;/a&gt; 호출이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed1c1596b543440810525dfa14b2c748e12dd5f9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../subqueries/index&quot;&gt;subquery&lt;/a&gt; can quite often, but not in all cases, be rewritten as a &lt;a href=&quot;../join/index&quot;&gt;JOIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리는&lt;/a&gt; A가로 자주 있지만 모든 경우에, 다시 작성할 수 있습니다 &lt;a href=&quot;../join/index&quot;&gt;가입&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="707b356de21e470ff828d139ae152976552e9fb6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; column with a maximum length of 16,777,215 (&lt;code&gt;2&lt;sup&gt;24&lt;/sup&gt; - 1&lt;/code&gt;) characters. The effective maximum length is less if the value contains multi-byte characters. Each MEDIUMTEXT value is stored using a three-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../text/index&quot;&gt;TEXT의&lt;/a&gt; 16,777,215 (최대 길이 칼럼 &lt;code&gt;2&lt;sup&gt;24&lt;/sup&gt; - 1&lt;/code&gt; 문자). 값에 멀티 바이트 문자가 포함 된 경우 유효 최대 길이는 짧습니다. 각 MEDIUMTEXT 값은 값의 바이트 수를 나타내는 3 바이트 길이 접두사를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="323219104d4bdadda9ae54f6a5a0aa5f3c1cb2bc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; column with a maximum length of 255 (&lt;code&gt;2&lt;sup&gt;8&lt;/sup&gt; - 1&lt;/code&gt;) characters. The effective maximum length is less if the value contains multi-byte characters. Each TINYTEXT value is stored using a one-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../text/index&quot;&gt;TEXT 된&lt;/a&gt; 255 (최대 길이 칼럼 &lt;code&gt;2&lt;sup&gt;8&lt;/sup&gt; - 1&lt;/code&gt; 문자). 값에 멀티 바이트 문자가 포함 된 경우 유효 최대 길이는 짧습니다. 각 TINYTEXT 값은 값의 바이트 수를 나타내는 1 바이트 길이 접두사를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e9496812baa8d4da0c9555a00f6787e58d6bb390" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; column with a maximum length of 4,294,967,295 or 4GB (&lt;code&gt;2&lt;sup&gt;32&lt;/sup&gt; - 1&lt;/code&gt;) characters. The effective maximum length is less if the value contains multi-byte characters. The effective maximum length of LONGTEXT columns also depends on the configured maximum packet size in the client/server protocol and available memory. Each LONGTEXT value is stored using a four-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;a href=&quot;../text/index&quot;&gt;TEXT의&lt;/a&gt; 4,294,967,295 또는 4기가바이트 (최대 길이와 칼럼 &lt;code&gt;2&lt;sup&gt;32&lt;/sup&gt; - 1&lt;/code&gt; 문자). 값에 멀티 바이트 문자가 포함 된 경우 유효 최대 길이는 짧습니다. LONGTEXT 열의 유효 최대 길이는 클라이언트 / 서버 프로토콜 및 사용 가능한 메모리에서 구성된 최대 패킷 크기에 따라 다릅니다. 각 LONGTEXT 값은 값의 바이트 수를 나타내는 4 바이트 길이 접두사를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="6b95a656b5351b1064172f240ea1f90a1c02dc63" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../triggers/index&quot;&gt;trigger&lt;/a&gt; may reference multiple tables, and if a &lt;code&gt;&lt;a href=&quot;../lock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt;&lt;/code&gt; statement is used on one of the tables, other tables may at the same time also implicitly be locked due to the trigger.</source>
          <target state="translated">&lt;a href=&quot;../triggers/index&quot;&gt;트리거는&lt;/a&gt; 다수의 테이블을 참조 할 수 있으며, 경우 &lt;code&gt;&lt;a href=&quot;../lock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt;&lt;/code&gt; 문 테이블 중 하나를 사용하고, 다른 테이블 동시에 묵시적 트리거에 의한 고정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c9a93244802bd101c85779c0165dd6651e29a4da" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt; against a table containing one or more foreign keys is executed as a &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; without WHERE, so that the foreign keys are enforced for each row.</source>
          <target state="translated">&lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE의&lt;/a&gt; 하나 이상의 외부 키를 포함하는 테이블에 대해이 실행된다 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 외래 키가 각각의 행에 적용되도록하는 것이 WHERE없이.</target>
        </trans-unit>
        <trans-unit id="b8cf6180d75aa849a28fa1b08c6dceeaa7f9685b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF&lt;/a&gt; installed with the &lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt;, this function copies table data from &lt;code&gt;source_link_id&lt;/code&gt; to &lt;code&gt;destination_link_id_list&lt;/code&gt;. The service does not need to be stopped in order to copy.</source>
          <target state="translated">&lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF는&lt;/a&gt; 설치 &lt;a href=&quot;../spider/index&quot;&gt;거미 저장소 엔진&lt;/a&gt; 에서이 기능을 복사 테이블 데이터 &lt;code&gt;source_link_id&lt;/code&gt; 에 &lt;code&gt;destination_link_id_list&lt;/code&gt; . 복사하기 위해 서비스를 중지 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f88b205d4e662731d1c9558b4cd2ad41e451039e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF&lt;/a&gt; installed with the &lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt;, this function is used for refreshing monitoring server information. It returns a value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt; 과 함께 설치 되는 &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF&lt;/a&gt; 인이 기능은 모니터링 서버 정보를 새로 고치는 데 사용됩니다. 값 &lt;code&gt;1&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="72b31ab9db445b6a6249b2a93cd39df385c68225" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF&lt;/a&gt; installed with the &lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt;, this function is used to execute the SQL string &lt;code&gt;sql&lt;/code&gt; on the remote server, as defined in &lt;code&gt;parameters&lt;/code&gt;. If any resultsets are returned, they are stored in the &lt;code&gt;tmp_table_list&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF는&lt;/a&gt; 설치 &lt;a href=&quot;../spider/index&quot;&gt;거미 저장소 엔진&lt;/a&gt; 이 기능은 SQL 문자열을 실행하는 데 사용됩니다, &lt;code&gt;sql&lt;/code&gt; 에 정의 된 원격 서버에서 &lt;code&gt;parameters&lt;/code&gt; . 결과 세트가 리턴되면 &lt;code&gt;tmp_table_list&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fce63d9d99ffc4aa9c9d5f395a29e8323fee347" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../views/index&quot;&gt;view&lt;/a&gt; can be used for inserting or updating. However, there are certain limitations.</source>
          <target state="translated">&lt;a href=&quot;../views/index&quot;&gt;뷰는&lt;/a&gt; 삽입 또는 업데이트에 사용될 수있다. 그러나 특정 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ab1573ab2e8d1f55323c67128657358f4a03ed" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.navicat.com/products/navicat-for-mysql-feature-matrix&quot;&gt;feature comparison matrix&lt;/a&gt; is available. More information, including pricing and &quot;trial&quot; versions, is available on the &lt;a href=&quot;http://www.navicat.com&quot;&gt;Navicat website&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.navicat.com/products/navicat-for-mysql-feature-matrix&quot;&gt;기능 비교 매트릭스를&lt;/a&gt; 사용할 수 있습니다. 가격 및 &quot;평가판&quot;버전을 포함한 자세한 내용은 &lt;a href=&quot;http://www.navicat.com&quot;&gt;Navicat 웹 사이트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6254591c608b5b898f4c50747831772d1ec5202c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://code.google.com/p/shard-query/&quot;&gt;project on Google Code&lt;/a&gt; also exists, but it is obsolete. All bugs from Google Code and all downloads from Google Code are deprecated and will be removed.</source>
          <target state="translated">&lt;a href=&quot;https://code.google.com/p/shard-query/&quot;&gt;Google 코드 프로젝트는&lt;/a&gt; 또한 존재하지만 사용되지 않습니다. Google 코드의 모든 버그 및 Google 코드의 모든 다운로드는 더 이상 사용되지 않으며 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="aee48250f880a2a2cf0fc440c5887463e83c0ee9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://mariadb.com/blog/table-and-tablespace-encryption-mariadb-101/&quot;&gt;blog post about table encryption&lt;/a&gt; with benchmark results</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/blog/table-and-tablespace-encryption-mariadb-101/&quot;&gt;테이블 암호화에 대한 블로그 게시물&lt;/a&gt; 벤치 마크 결과</target>
        </trans-unit>
        <trans-unit id="f1a1859d96c0d5046fb24b5bae0eaf027a7dd75a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://www.facebook.com/ShardQuery&quot;&gt;Facebook page&lt;/a&gt; is also available.</source>
          <target state="translated">&lt;a href=&quot;https://www.facebook.com/ShardQuery&quot;&gt;페이스 북 페이지&lt;/a&gt; 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d0edc52ff8786394f6c4d8430095c253468492" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; in the hidden metadata record is used to store column mappings. This makes it possible to drop or reorder columns without rebuilding the table. This also makes it possible to add columns to any position or drop columns from any position in the table without rebuilding the table.</source>
          <target state="translated">숨겨진 메타 데이터 레코드 의 &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 는 열 맵핑을 저장하는 데 사용됩니다. 이렇게하면 테이블을 다시 작성하지 않고도 열을 삭제하거나 재정렬 할 수 있습니다. 또한 테이블을 다시 작성하지 않고도 테이블의 임의 위치에서 열을 추가하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f89b5b65507a6398fb94bec1bb0ea882bbb481" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt;&lt;/code&gt; will show more information about the problem.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt;&lt;/code&gt; 이 문제에 대한 자세한 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e192b39dc977f95a80130a5c74136df6f621e84b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BLOB&lt;/code&gt; column with a maximum length of &lt;code&gt;65,535&lt;/code&gt; (&lt;code&gt;2&lt;sup&gt;16&lt;/sup&gt; - 1&lt;/code&gt;) bytes. Each &lt;code&gt;BLOB&lt;/code&gt; value is stored using a two-byte length prefix that indicates the number of bytes in the value.</source>
          <target state="translated">&lt;code&gt;BLOB&lt;/code&gt; 의 최대 길이 컬럼 &lt;code&gt;65,535&lt;/code&gt; ( &lt;code&gt;2&lt;sup&gt;16&lt;/sup&gt; - 1&lt;/code&gt; ) 바이트. 각 &lt;code&gt;BLOB&lt;/code&gt; 값은 값의 바이트 수를 나타내는 2 바이트 길이 접 두부를 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="952f027f47ed825efcbb824971f946da1dc0d443" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BLOB&lt;/code&gt; is a binary large object that can hold a variable amount of data. The four &lt;code&gt;BLOB&lt;/code&gt; types are</source>
          <target state="translated">&lt;code&gt;BLOB&lt;/code&gt; 는 다양한 데이터 량을 저장할 수있는 이진 큰 목적이다. 네 가지 &lt;code&gt;BLOB&lt;/code&gt; 유형은</target>
        </trans-unit>
        <trans-unit id="ee0d209e80cb76cce47e9ce37a1ad06c48aa1d0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DATE&lt;/code&gt; literal can also be an integer, in one of the following formats: &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DATE&lt;/code&gt; : 리터럴은 다음 형식 중 하나로, 정수가 될 수 &lt;code&gt;YYYYMMDD&lt;/code&gt; 또는 &lt;code&gt;YYMMDD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="561072fef96af6283e6d01c4f857c8f66e5622e0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DATE&lt;/code&gt; string is a string in one of the following formats: &lt;code&gt;'YYYY-MM-DD'&lt;/code&gt; or &lt;code&gt;'YY-MM-DD'&lt;/code&gt;. Note that any punctuation character can be used as delimiter. All delimiters must consist of 1 character. Different delimiters can be used in the same string. Delimiters are optional (but if one delimiter is used, all delimiters must be used).</source>
          <target state="translated">&lt;code&gt;DATE&lt;/code&gt; 문자열은 다음 형식 중 하나의 문자열입니다 &lt;code&gt;'YYYY-MM-DD'&lt;/code&gt; 또는 &lt;code&gt;'YY-MM-DD'&lt;/code&gt; . 문장 부호 문자는 구분 기호로 사용할 수 있습니다. 모든 분리 문자는 1 자로 구성되어야합니다. 동일한 문자열에서 다른 구분 기호를 사용할 수 있습니다. 분리 문자는 선택 사항입니다 (단, 하나의 분리 문자를 사용하는 경우 모든 분리 문자를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="57df08c7b8dd5aef0c17085156556abefd2f3e2f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DATETIME&lt;/code&gt; literal can also be a number, in one of the following formats: &lt;code&gt;YYYYMMDDHHMMSS&lt;/code&gt;, &lt;code&gt;YYMMDDHHMMSS&lt;/code&gt;, &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;. In this case, all the time subparts must consist of 2 digits.</source>
          <target state="translated">&lt;code&gt;DATETIME&lt;/code&gt; 의 : 문자는 다음 형식 중 하나로, 숫자가 될 수 &lt;code&gt;YYYYMMDDHHMMSS&lt;/code&gt; , &lt;code&gt;YYMMDDHHMMSS&lt;/code&gt; , &lt;code&gt;YYYYMMDD&lt;/code&gt; 또는 &lt;code&gt;YYMMDD&lt;/code&gt; . 이 경우 모든 시간 하위 부분은 2 자리 숫자로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a92bcec714c57c824d2298283b69e45590a58af8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DATETIME&lt;/code&gt; string is a string in one of the following formats: &lt;code&gt;'YYYY-MM-DD HH:MM:SS'&lt;/code&gt; or &lt;code&gt;'YY-MM-DD HH:MM:SS'&lt;/code&gt;. Note that any punctuation character can be used as delimiter for the date part and for the time part. All delimiters must consist of 1 character. Different delimiters can be used in the same string. The hours, minutes and seconds parts can consist of one character. For this reason, delimiters are mandatory for &lt;code&gt;DATETIME&lt;/code&gt; literals.</source>
          <target state="translated">&lt;code&gt;DATETIME&lt;/code&gt; 의 문자열은 다음 형식 중 하나의 문자열입니다 &lt;code&gt;'YYYY-MM-DD HH:MM:SS'&lt;/code&gt; 또는 &lt;code&gt;'YY-MM-DD HH:MM:SS'&lt;/code&gt; . 구두점 문자는 날짜 부분과 시간 부분의 구분 기호로 사용할 수 있습니다. 모든 분리 문자는 1 자로 구성되어야합니다. 동일한 문자열에서 다른 구분 기호를 사용할 수 있습니다. 시, 분 및 초 부분은 하나의 문자로 구성 될 수 있습니다. 따라서 &lt;code&gt;DATETIME&lt;/code&gt; 리터럴 에는 구분자가 필수입니다 .</target>
        </trans-unit>
        <trans-unit id="ba0a3ff7b3b274faa9cc63bc7cd5735b85de39a2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DO&lt;/code&gt; clause, which contains the SQL statement to be executed by an event.</source>
          <target state="translated">이벤트에 의해 실행될 SQL 문을 포함 하는 &lt;code&gt;DO&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="6b48197e300fe291c0bbc45088b9a4eb2de4b8ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LOOP&lt;/code&gt; statement can be &lt;a href=&quot;../labels/index&quot;&gt;labeled&lt;/a&gt;. &lt;code&gt;end_label&lt;/code&gt; cannot be given unless &lt;code&gt;begin_label&lt;/code&gt; also is present. If both are present, they must be the same.</source>
          <target state="translated">&lt;code&gt;LOOP&lt;/code&gt; 문이 될 수 &lt;a href=&quot;../labels/index&quot;&gt;표시&lt;/a&gt; . &lt;code&gt;begin_label&lt;/code&gt; 도 존재 하지 않으면 &lt;code&gt;end_label&lt;/code&gt; 을 제공 할 수 없습니다 . 둘 다 존재하면 모두 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f5251ae4a97f6a7f8732b51646a8734969606967" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NULL&lt;/code&gt; parameter hides all information contained in other parameters from the result. Sometimes this is not desirable; to avoid this, you can:</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 의 매개 변수 가죽 모든 정보는 결과에서 다른 매개 변수에 포함되어 있습니다. 때때로 이것은 바람직하지 않습니다. 이를 피하기 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628de5e0621171625a26c9e2d25e28b6480d0b07" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PROXY&lt;/code&gt; table can also be used by itself to modify the way a table is viewed. For instance, a proxy table does not use the indexes of the object table. It is also possible to define its columns with different names or type, to use only some of them or to changes their order. For instance:</source>
          <target state="translated">&lt;code&gt;PROXY&lt;/code&gt; 의 테이블은 테이블을 조회하는 방식을 수정 자체로 사용할 수 있습니다. 예를 들어, 프록시 테이블은 오브젝트 테이블의 인덱스를 사용하지 않습니다. 이름이나 유형이 다른 열을 정의하거나 그 중 일부만 사용하거나 순서를 변경할 수도 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="36aeeb0d9474fa8c80dcd2381cdd00af3045aec7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PROXY&lt;/code&gt; table is a table that accesses and reads the data of another table or view. For instance, to create a table based on the boys &lt;code&gt;FIX&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;PROXY&lt;/code&gt; 의 테이블은 그 테이블 접근 및 다른 테이블 또는 뷰의 데이터를 판독한다. 예를 들어 boys &lt;code&gt;FIX&lt;/code&gt; 테이블을 기반으로 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f5c788ea15c3acaf091c5bdbf329d11c91222cdf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REPEAT&lt;/code&gt; statement can be &lt;a href=&quot;../labels/index&quot;&gt;labeled&lt;/a&gt;. end_label cannot be given unless begin_label also is present. If both are present, they must be the same.</source>
          <target state="translated">&lt;code&gt;REPEAT&lt;/code&gt; 의 문이 될 수 &lt;a href=&quot;../labels/index&quot;&gt;표시&lt;/a&gt; . begin_label도 존재하지 않으면 end_label을 제공 할 수 없습니다. 둘 다 존재하면 모두 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="fd732836587623fdd1c7f1fdd079cb16e99d0445" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT...INTO&lt;/code&gt; example for &lt;code&gt;sql_mode=DEFAULT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SELECT...INTO&lt;/code&gt; 예를 들어 &lt;code&gt;sql_mode=DEFAULT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b857aa53cb021bbc5c540432c459e6cc74879398" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT...INTO&lt;/code&gt; example for &lt;code&gt;sql_mode=ORACLE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SELECT...INTO&lt;/code&gt; 예를 들어 &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9674c35c4cefb60ccd6f02ed250bcf3622bd1475" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; associated to a cursor can use variables, but the query itself cannot be a variable, and cannot be dynamically composed. The &lt;code&gt;SELECT&lt;/code&gt; statement cannot have an &lt;code&gt;INTO&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 는 변수를 사용할 수 있습니다 커서에 관련된하지만 쿼리 자체가 변수가 될 수 없으며, 동적으로 구성 할 수 없습니다. &lt;code&gt;SELECT&lt;/code&gt; 문은 할 수 없습니다 &lt;code&gt;INTO&lt;/code&gt; 의 절을.</target>
        </trans-unit>
        <trans-unit id="7455f926b744f58c8adf28547e0ec6ea6028f67c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; statement must contain one or more select expressions, separated by commas. Each select expression can be one of the following:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 문은 하나 또는 그 이상의 선택 식을 쉼표로 구분하여 포함되어 있어야합니다. 각 선택 표현식은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39c005e8a1bb8a533c3b56300246af268934bd05" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TEXT&lt;/code&gt; column with a maximum length of &lt;code&gt;65,535&lt;/code&gt; (&lt;code&gt;2&lt;sup&gt;16&lt;/sup&gt; - 1&lt;/code&gt;) characters. The effective maximum length is less if the value contains multi-byte characters. Each &lt;code&gt;TEXT&lt;/code&gt; value is stored using a two-byte length prefix that indicates the number of bytes in the value. If you need a bigger storage, consider using &lt;a href=&quot;../mediumtext/index&quot;&gt;MEDIUMTEXT&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;TEXT&lt;/code&gt; 의 최대 길이 컬럼 &lt;code&gt;65,535&lt;/code&gt; ( &lt;code&gt;2&lt;sup&gt;16&lt;/sup&gt; - 1&lt;/code&gt; 문자). 값에 멀티 바이트 문자가 포함 된 경우 유효 최대 길이는 짧습니다. 각 &lt;code&gt;TEXT&lt;/code&gt; 값은 값의 바이트 수를 나타내는 2 바이트 길이 접두사를 사용하여 저장됩니다. 더 큰 스토리지가 필요한 경우 대신 &lt;a href=&quot;../mediumtext/index&quot;&gt;MEDIUMTEXT를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a48c91a5f7577cf394d13cb50997697906beb375" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIME&lt;/code&gt; literal can also be a number in one of the following formats: &lt;code&gt;HHMMSS&lt;/code&gt;, &lt;code&gt;MMSS&lt;/code&gt;, or &lt;code&gt;SS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TIME&lt;/code&gt; : 리터럴은 다음 형식 중 하나의 숫자가 될 수 &lt;code&gt;HHMMSS&lt;/code&gt; , &lt;code&gt;MMSS&lt;/code&gt; 또는 &lt;code&gt;SS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fa7042e0f3a04eff822b00ef3a790c7a3c85d14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TIME&lt;/code&gt; string is a string in one of the following formats: &lt;code&gt; 'D HH:MM:SS'&lt;/code&gt;, &lt;code&gt;'HH:MM:SS&lt;/code&gt;, &lt;code&gt;'D HH:MM'&lt;/code&gt;, &lt;code&gt;'HH:MM'&lt;/code&gt;, &lt;code&gt;'D HH'&lt;/code&gt;, or &lt;code&gt;'SS'&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is a value from 0 to 34 which represents days. &lt;code&gt;:&lt;/code&gt; is the only allowed delimiter for &lt;code&gt;TIME&lt;/code&gt; literals. Delimiters are mandatory, with an exception: the &lt;code&gt;'HHMMSS'&lt;/code&gt; format is allowed. When delimiters are used, each part of the literal can consist of one character.</source>
          <target state="translated">&lt;code&gt;TIME&lt;/code&gt; 문자열은 다음 형식 중 하나의 문자열입니다 : &lt;code&gt; 'D HH:MM:SS'&lt;/code&gt; , &lt;code&gt;'HH:MM:SS&lt;/code&gt; , &lt;code&gt;'D HH:MM'&lt;/code&gt; , &lt;code&gt;'HH:MM'&lt;/code&gt; , &lt;code&gt;'D HH'&lt;/code&gt; , 또는 &lt;code&gt;'SS'&lt;/code&gt; . &lt;code&gt;D&lt;/code&gt; 는 일을 나타내는 0에서 34 사이의 값입니다. &lt;code&gt;:&lt;/code&gt; &lt;code&gt;TIME&lt;/code&gt; 리터럴에 허용되는 유일한 분리 문자입니다. &lt;code&gt;'HHMMSS'&lt;/code&gt; 형식이 허용되는 경우를 제외하고 구분 기호는 필수 입니다. 구분 기호를 사용하면 리터럴의 각 부분이 하나의 문자로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4669ff268b621d8883844a79a6bae27ded0898fd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;UNIQUE&lt;/code&gt; index may be displayed as &lt;code&gt;PRI&lt;/code&gt; if it cannot contain &lt;code&gt;NULL&lt;/code&gt; values and there is no &lt;code&gt;PRIMARY KEY&lt;/code&gt; in the table. A &lt;code&gt;UNIQUE&lt;/code&gt; index may display as &lt;code&gt;MUL&lt;/code&gt; if several columns form a composite &lt;code&gt;UNIQUE&lt;/code&gt; index; although the combination of the columns is unique, each column can still hold multiple occurrences of a given value.</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; 인덱스는 다음과 같이 표시 될 수 있습니다 &lt;code&gt;PRI&lt;/code&gt; 가 포함 할 수없는 경우 &lt;code&gt;NULL&lt;/code&gt; 의 값을 더 없다 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 테이블에가. &lt;code&gt;UNIQUE&lt;/code&gt; 의 지수로 표시 될 &lt;code&gt;MUL&lt;/code&gt; 여러 열 복합 형성 경우 &lt;code&gt;UNIQUE&lt;/code&gt; 의 인덱스; 열의 조합은 고유하지만 각 열은 여전히 ​​여러 번 주어진 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="534ef87c98bff04ad02e832a785bf8aef70761cc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WHERE&lt;/code&gt; expression (in additional to the possible key lookup) is used to check if the row should be accepted. If you don't have 'Using where' together with a join type of &lt;code&gt;ALL&lt;/code&gt;, you are probably doing something wrong!</source>
          <target state="translated">(가능한 키 조회에 추가의) 식 행이 허용되어야 하는지를 확인하는데 사용된다. &lt;code&gt;ALL&lt;/code&gt; 유형의 조인 유형과 함께 'Use where'를 사용하지 않으면 아마도 잘못된 것입니다! &lt;code&gt;WHERE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8864e20851bf7de64f37f8d630474c386e0b1fa4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WHILE&lt;/code&gt; statement can be &lt;a href=&quot;../labels/index&quot;&gt;labeled&lt;/a&gt;. end_label cannot be given unless begin_label also is present. If both are present, they must be the same.</source>
          <target state="translated">&lt;code&gt;WHILE&lt;/code&gt; 의 문이 될 수 &lt;a href=&quot;../labels/index&quot;&gt;표시&lt;/a&gt; . begin_label도 존재하지 않으면 end_label을 제공 할 수 없습니다. 둘 다 존재하면 모두 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ecaacf42888f6434b356960ae6da0c4f733dd69b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;commit&lt;/code&gt; is &lt;code&gt;flush of logs&lt;/code&gt; followed by a sync.</source>
          <target state="translated">A는 &lt;code&gt;commit&lt;/code&gt; 이며 &lt;code&gt;flush of logs&lt;/code&gt; 동기 하였다.</target>
        </trans-unit>
        <trans-unit id="a2aa645ad53a093521ef3be322c488d0706cea2d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;config_files()&lt;/code&gt; method returns a list of additional config files (besides &lt;code&gt;my.cnf&lt;/code&gt;), that this suite needs to be created. For every file it specifies a function that will create it, when given a &lt;code&gt;My::Config&lt;/code&gt; object. For example:</source>
          <target state="translated">&lt;code&gt;config_files()&lt;/code&gt; 메소드는 (외에 추가 설정 파일의 목록 반환 &lt;code&gt;my.cnf&lt;/code&gt; 파일을 ),이 제품군의 요구가 생성 될 것이다. 모든 파일에 대해 &lt;code&gt;My::Config&lt;/code&gt; 오브젝트가 제공 될 때이를 작성할 함수를 지정 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98a38036a0f066f424f367e3e667b8e1ac500668" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;latch&lt;/code&gt; value of &lt;code&gt;'dijkstras'&lt;/code&gt; and an &lt;code&gt;origid&lt;/code&gt; and &lt;code&gt;destid&lt;/code&gt; is used for finding the shortest path between two nodes, for example:</source>
          <target state="translated">&lt;code&gt;'dijkstras'&lt;/code&gt; &lt;code&gt;origid&lt;/code&gt; ' 의 &lt;code&gt;latch&lt;/code&gt; 값 과 origid 및 &lt;code&gt;destid&lt;/code&gt; 는 두 노드 사이의 최단 경로를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afc72c38ba7b6488e47459c5917cc5065eb45d21" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;latch&lt;/code&gt; value of &lt;code&gt;'leaves'&lt;/code&gt; and either &lt;code&gt;origid&lt;/code&gt; or &lt;code&gt;destid&lt;/code&gt; is used for finding leaf nodes at the beginning or end of a graph.</source>
          <target state="translated">&lt;code&gt;'leaves'&lt;/code&gt; 의 &lt;code&gt;latch&lt;/code&gt; 값 과 &lt;code&gt;origid&lt;/code&gt; 또는 &lt;code&gt;destid&lt;/code&gt; 는 그래프의 시작 또는 끝에서 리프 노드를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef2734d9de2457e5fb65034a4ab688344487c6e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list_cases()&lt;/code&gt; method returns a complete list of tests for this suite. By default it will be the list of files that have &lt;code&gt;.test&lt;/code&gt; extension, but without the extension. This list will be filtered by mtr, subject to different mtr options (&lt;code&gt;--big-test&lt;/code&gt;, &lt;code&gt;--start-from&lt;/code&gt;, etc), the suite object does not have to do it.</source>
          <target state="translated">&lt;code&gt;list_cases()&lt;/code&gt; 메소드가 반환이 제품군에 대한 검사의 전체 목록. 기본적으로 확장자 는 &lt;code&gt;.test&lt;/code&gt; 이지만 확장자는없는 파일 목록입니다 . 이 목록은 mtr별로 필터링되며 다른 mtr 옵션 ( &lt;code&gt;--big-test&lt;/code&gt; , &lt;code&gt;--start-from&lt;/code&gt; 등)에 따라 스위트 객체가 수행하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="ddd5f606c796a6bf839b106aa9c32544a08e7bda" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;servers()&lt;/code&gt; method returns a list of processes that needs to be started for this suite. A process is specified as a [regex, hash] pair. The regular expression must match a section in the &lt;code&gt;my.cnf&lt;/code&gt; template (for example, &lt;code&gt;qr/mysqld\./&lt;/code&gt; corresponds to all &lt;code&gt;mysqld&lt;/code&gt; processes), the hash contains these options:</source>
          <target state="translated">&lt;code&gt;servers()&lt;/code&gt; 메소드가 반환이 제품군에 대한 시작해야 할 프로세스의 목록을 표시합니다. 프로세스는 [regex, hash] 쌍으로 지정됩니다. 정규식은 &lt;code&gt;my.cnf&lt;/code&gt; 템플릿 의 섹션과 일치해야합니다 (예 : &lt;code&gt;qr/mysqld\./&lt;/code&gt; 는 모든 &lt;code&gt;mysqld&lt;/code&gt; 프로세스에 해당 ). 해시는 다음 옵션을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bf2876aae8348d6dd31d6a72c6eccce46c4dfbb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;skip_combinations()&lt;/code&gt; method returns a hash that maps file names (where combinations are defined) to a list of combinations that should be skipped. As a special case, it can disable a complete file by using a string instead of a hash. For example</source>
          <target state="translated">&lt;code&gt;skip_combinations()&lt;/code&gt; 메소드가 반환 건너 뛰어야 조합의 목록 (조합이 정의) 파일 이름을 매핑하는 해시. 특별한 경우 해시 대신 문자열을 사용하여 전체 파일을 비활성화 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="75e2124d49ada0069d3cbc0b9ce0f4bad8c7f9e5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;start_test()&lt;/code&gt; method starts one test process, by default it will be &lt;code&gt;mysqltest&lt;/code&gt;. See the &lt;em&gt;unit&lt;/em&gt; suite for a working example of &lt;code&gt;list_cases()&lt;/code&gt; and &lt;code&gt;start_test()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;start_test()&lt;/code&gt; 메소드는 것 기본적으로 하나 개의 테스트 프로세스를 시작 &lt;code&gt;mysqltest&lt;/code&gt; . &lt;code&gt;list_cases()&lt;/code&gt; 및 &lt;code&gt;start_test()&lt;/code&gt; 메소드 의 실제 예제 는 &lt;em&gt;유닛&lt;/em&gt; 스위트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3bd748deb1601956a323debc90be47daa6fe09a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;systemd&lt;/code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.unit.html&quot;&gt;template unit file&lt;/a&gt; with the name &lt;code&gt;mariadb@.service&lt;/code&gt; is installed in &lt;code&gt;INSTALL_SYSTEMD_UNITDIR&lt;/code&gt; on some systems. See &lt;a href=&quot;#locating-the-mariadb-services-unit-file&quot;&gt;Locating the MariaDB Service's Unit File&lt;/a&gt; to see what directory that refers to on each distribution.</source>
          <target state="translated">&lt;code&gt;systemd&lt;/code&gt; &lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.unit.html&quot;&gt;템플릿 유닛 파일&lt;/a&gt; 이름과 &lt;code&gt;mariadb@.service&lt;/code&gt; 설치되어 &lt;code&gt;INSTALL_SYSTEMD_UNITDIR&lt;/code&gt; 일부 시스템. 참조 &lt;a href=&quot;#locating-the-mariadb-services-unit-file&quot;&gt;MariaDB 서비스의 단위 파일 찾기&lt;/a&gt; 각 분포를 의미하는 어떤 디렉토리를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89f3cbf45274d410be3322f73b4449733c161ba" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;safe&lt;/em&gt; workaround is to refactor some of the columns into a JSON document.</source>
          <target state="translated">&lt;em&gt;안전한&lt;/em&gt; 해결 방법은 JSON 문서로 일부 열을 리팩토링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="116024c08c8836854ff1b18faa6ba647746f26e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;safe&lt;/em&gt; workaround is to refactor the single wide table, so that its columns are spread among multiple tables.</source>
          <target state="translated">&lt;em&gt;안전한&lt;/em&gt; 해결 방법은 열이 여러 테이블 사이에 분산되어 그래서, 하나의 넓은 테이블을 리팩토링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5960fc2062ed778f95e48bb2ae1c05b0a704c862" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Sequence&lt;/strong&gt; engine allows the creation of ascending or descending sequences of numbers (positive integers) with a given starting value, ending value and increment.</source>
          <target state="translated">&lt;strong&gt;시퀀스&lt;/strong&gt; 엔진 오름차순 또는 주어진 시작 값과 수 (양의 정수)의 시퀀스를 하강 값 증분 종료의 생성을 허용한다.</target>
        </trans-unit>
        <trans-unit id="a332fcb33a86e11cfe20b8483d66c50eb43e3427" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiple&lt;/strong&gt; file table is one that is physically contained in several files of the same type instead of just one. These files are processed sequentially during the process of a query and the result is the same as if all the table files were merged into one. This is great to process files coming from different sources (such as cash register log files) or made at different time periods (such as bank monthly reports) regarded as one table. Note that the operations on such files are restricted to sequential Select and Update; and that VEC multiple tables are not supported by CONNECT. The file list depends on the setting of the &lt;strong&gt;multiple&lt;/strong&gt; option of the &lt;code&gt;CREATE TABLE&lt;/code&gt; statement for that table.</source>
          <target state="translated">&lt;strong&gt;여러&lt;/strong&gt; 파일 테이블은 물리적으로 대신 하나의 동일한 유형의 여러 파일에 포함되어있는 것입니다. 이러한 파일은 쿼리 프로세스 중에 순차적으로 처리되며 결과는 모든 테이블 파일이 하나로 병합 된 것과 같습니다. 이것은 다른 소스 (예 : 금전 등록기 로그 파일)에서 가져 오거나 하나의 테이블로 간주되는 다른 기간 (예 : 은행 월별 보고서)에서 작성된 파일을 처리하는 데 유용합니다. 이러한 파일에 대한 작업은 순차적 인 선택 및 업데이트로 제한됩니다. VEC 다중 테이블은 CONNECT에서 지원되지 않습니다. 파일 목록은 해당 테이블에 대한 &lt;code&gt;CREATE TABLE&lt;/code&gt; 문의 &lt;strong&gt;다중&lt;/strong&gt; 옵션 설정에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9975779e1495422876563436578429840957cfc1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;worker thread&lt;/strong&gt; has not been created for the thread group within the &lt;em&gt;throttling interval&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;작업자 스레드는&lt;/strong&gt; 내에서 스레드 그룹에 대해 생성되지 않은 &lt;em&gt;제한 간격&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d04ee636183186f651c15bc05862ec18f2a94ed2" translate="yes" xml:space="preserve">
          <source>A BLOB field is not allowed in partition function</source>
          <target state="translated">파티션 기능에서 BLOB 필드가 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="a60deb88f8e230fa68011ed23f4c59f2219d6c39" translate="yes" xml:space="preserve">
          <source>A BTree lookup is quite fast and efficient. For a million-row table there might be 3 levels of BTree, and the top two levels are probably cached.</source>
          <target state="translated">BTree 조회는 매우 빠르고 효율적입니다. 백만 행 테이블의 경우 3 가지 레벨의 BTree가있을 수 있으며 상위 2 개 레벨이 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="244d4e650a4400e1fdcf26d5d7cee465c9437e37" translate="yes" xml:space="preserve">
          <source>A CONNECT format string consists of a series of elements that represent a particular piece of information and define its format. The elements will be recognized in the order they appear in the format string. Date and time format elements will be replaced by the actual date and time as they appear in the source string. They are defined by the following groups of characters:</source>
          <target state="translated">CONNECT 형식 문자열은 특정 정보를 나타내고 해당 형식을 정의하는 일련의 요소로 구성됩니다. 요소는 형식 문자열에 나타나는 순서대로 인식됩니다. 날짜 및 시간 형식 요소는 소스 문자열에 나타나는 실제 날짜 및 시간으로 대체됩니다. 다음과 같은 문자 그룹으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="75019b621993ea002bc81b4ffbb7ed107ce943e6" translate="yes" xml:space="preserve">
          <source>A CTE referencing Another CTE</source>
          <target state="translated">다른 CTE를 참조하는 CTE</target>
        </trans-unit>
        <trans-unit id="c9e148be037e3405a715dcef8af2a1b534ff9d07" translate="yes" xml:space="preserve">
          <source>A ColumnStore autoincrement column can be added by including an autoincrement comment at either the table level or the column level. Only one autoincrement can be defined per table.</source>
          <target state="translated">테이블 레벨 또는 컬럼 레벨에서 자동 증가 주석을 포함시켜 ColumnStore 자동 증가 열을 추가 할 수 있습니다. 테이블 당 하나의 자동 증분 만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a88fcefe0401d34a222aeb87abe0ce7894b6a839" translate="yes" xml:space="preserve">
          <source>A ColumnStore autoincrement column can be added by including an autoincrement comment at either the table level or the column level. Only one autoincrement can be defined per table. When creating data on a table with an autoincrement column either omit the column or specify the value 0 or null which will result in the system populating the autoincrement value. With cpimport, it requires an entry for each column so use the value 0 for the column in the import file. If a non 0 value is provided that value will be set for the row and the autoincrement counter does not increase.</source>
          <target state="translated">테이블 레벨 또는 컬럼 레벨에서 자동 증가 주석을 포함시켜 ColumnStore 자동 증가 열을 추가 할 수 있습니다. 테이블 당 하나의 자동 증분 만 정의 할 수 있습니다. 자동 증가 열이있는 테이블에서 데이터를 작성할 때 열을 생략하거나 값 0 또는 널을 지정하면 시스템이 자동 증가 값을 채우게됩니다. cpimport를 사용하면 각 열에 대한 항목이 필요하므로 가져 오기 파일의 열에 0 값을 사용하십시오. 0이 아닌 값을 제공하면 해당 값이 행에 설정되고 자동 증분 카운터가 증가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dbaa38e4506983a38c4d437fe0ff2729592ea89" translate="yes" xml:space="preserve">
          <source>A ColumnStore cluster can be brought up using a compose file provided in the ColumnStore github repository:</source>
          <target state="translated">ColumnStore github 저장소에 제공된 compose 파일을 사용하여 ColumnStore 클러스터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5715025f20428850094721cb90f3436ba1ca5c" translate="yes" xml:space="preserve">
          <source>A DEB upgrade would be done on a system that supports DEBs like Debian or Ubuntu systems.</source>
          <target state="translated">DEB 업그레이드는 Debian 또는 Ubuntu 시스템과 같은 DEB를 지원하는 시스템에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6854bac9ff2c1aa61cb494af11d54df4ef4d5881" translate="yes" xml:space="preserve">
          <source>A DISTINCT clause and a GROUP BY without a corresponding HAVING clause have no meaning in IN/ALL/ANY/SOME/EXISTS subqueries. The reason is that IN/ALL/ANY/SOME/EXISTS only check if an outer row satisfies some condition with respect to all or any row in the subquery result. Therefore is doesn't matter if the subquery has duplicate result rows or not - if some condition is true for some row of the subquery, this condition will be true for all duplicates of this row. Notice that GROUP BY without a corresponding HAVING clause is equivalent to a DISTINCT.</source>
          <target state="translated">해당 HAVING 절이없는 DISTINCT 절 및 GROUP BY는 IN / ALL / ANY / SOME / EXISTS 서브 쿼리에서 의미가 없습니다. 그 이유는 IN / ALL / ANY / SOME / EXISTS가 외부 행이 서브 쿼리 결과의 전체 또는 임의의 행과 관련하여 일부 조건을 만족하는지 여부 만 점검하기 때문입니다. 따라서 하위 쿼리에 중복 결과 행이 있는지 여부는 중요하지 않습니다. 하위 쿼리의 일부 행에 대해 일부 조건이 true이면이 행의 모든 ​​복제본에 대해이 조건이 적용됩니다. 해당 HAVING 절이없는 GROUP BY는 DISTINCT와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee81e75f255633cf5dd8f464b62a96b9cd6773af" translate="yes" xml:space="preserve">
          <source>A FULLTEXT index definition can be given in the &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement when a table is created, or added later using &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; or &lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX&lt;/a&gt;.</source>
          <target state="translated">FULLTEXT 인덱스 정의는 테이블이 작성되거나 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX를&lt;/a&gt; 사용하여 나중에 추가 될 때 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문에 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a37df80926c491e1a23d5457722458180cc10a15" translate="yes" xml:space="preserve">
          <source>A FUNCTION differs from a PROCEDURE in one important aspect: Whereas a PROCEDURE is CALLed as statement by itself, a FUNCTION is invoked &quot;on-the-fly&quot; during the execution of *another* statement. This makes things a lot more complicated compared to CALL: - We can't read and parse the FUNCTION from the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc table&lt;/a&gt; at the point of invocation; the server requires that all tables used are opened and locked at the beginning of the query execution. One &quot;obvious&quot; solution would be to simply push &quot;mysql.proc&quot; to the list of tables used by the query, but this implies a &quot;join&quot; with this table if the query is a select, so it doesn't work (and we can't exclude this table easily; since a privileged used might in fact want to search the proc table). Another solution would of course be to allow the opening and closing of the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc table&lt;/a&gt; during a query execution, but this it not possible at the present.</source>
          <target state="translated">FUNCTION은 한 가지 중요한 측면에서 PROCEDURE와 다릅니다. PROCEDURE가 자체적으로 명령문으로 호출되는 반면, * another * 명령문을 실행하는 동안 FUNCTION이 &quot;즉시&quot;호출됩니다. 이것은 CALL에 비해 훨씬 복잡합니다.- &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc 테이블&lt;/a&gt; 에서 FUNCTION을 읽고 구문 분석 할 수 없습니다.호출 시점에서; 서버는 사용 된 모든 테이블이 쿼리 실행 시작시 열리고 잠길 것을 요구합니다. &quot;명백한&quot;해결책 중 하나는 단순히 &quot;mysql.proc&quot;를 쿼리에서 사용하는 테이블 목록으로 푸시하는 것이지만, 쿼리가 선택 인 경우이 테이블과의 &quot;결합&quot;을 의미하므로 작동하지 않습니다. 우리는이 테이블을 쉽게 배제 할 수 없다; 사용 된 특권은 실제로 proc 테이블을 검색하기를 원하기 때문이다). 물론 다른 솔루션은 쿼리 실행 중에 &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc 테이블을&lt;/a&gt; 열고 닫을 수 있도록하는 것이지만 현재로서는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="db5d01734e80ed771f6962f78aaeb9044e5a7ffa" translate="yes" xml:space="preserve">
          <source>A Galera GTID is the combination of a _cluster_ UUID and a sequence number.</source>
          <target state="translated">Galera GTID는 _cluster_ UUID와 시퀀스 번호의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="601c2907fce1c6e6ae35fb1af9cc1c677810f2eb" translate="yes" xml:space="preserve">
          <source>A Google Group exists for MariaDB ColumnStore that can be used to discuss ideas, issues and communicate with the community: Send email to mariadb-columnstore@googlegroups.com or use the &lt;a href=&quot;https://groups.google.com/forum/#!forum/mariadb-columnstore&quot;&gt;forum interface&lt;/a&gt;</source>
          <target state="translated">MariaDB ColumnStore에 대한 Google 그룹이 존재하여 아이디어, 문제를 논의하고 커뮤니티와 커뮤니케이션 할 수 있습니다. mariadb-columnstore@googlegroups.com으로 이메일을 보내거나 &lt;a href=&quot;https://groups.google.com/forum/#!forum/mariadb-columnstore&quot;&gt;포럼 인터페이스를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="460976a061a35a79cb959a6b414bb06143de8721" translate="yes" xml:space="preserve">
          <source>A JSON document displaying the stats we collected when the query was run.</source>
          <target state="translated">쿼리가 실행될 때 수집 한 통계를 표시하는 JSON 문서입니다.</target>
        </trans-unit>
        <trans-unit id="427cd7d261ce6a3628e807b0e3988e6217f999b2" translate="yes" xml:space="preserve">
          <source>A Json path can be specified as a third string argument</source>
          <target state="translated">Json 경로는 세 번째 문자열 인수로 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="da6df9cbadbf9b9fbbca0747816fc9bca4d7dfc3" translate="yes" xml:space="preserve">
          <source>A Lot of Fast Connections + Small Set of Queries + Disconnects</source>
          <target state="translated">많은 빠른 연결 + 작은 쿼리 세트 + 연결 끊기</target>
        </trans-unit>
        <trans-unit id="cef1daf63c107f57d5bb9b0b573bcb6bbc2e3cbb" translate="yes" xml:space="preserve">
          <source>A MEMORY table can have up to 64 indexes, 16 columns for each index and a maximum key length of 3072 bytes.</source>
          <target state="translated">MEMORY 테이블은 최대 64 개의 인덱스, 각 인덱스에 대해 16 개의 열 및 최대 키 길이 3072 바이트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04431de7cd880221debb2bd2b865445becff296" translate="yes" xml:space="preserve">
          <source>A MONGO table is defined to access a MongoDB collection. The table rows will be the collection documents. For instance, to create a table based on the MongoDB sample collection restaurants, you can do something such as the following:</source>
          <target state="translated">MONGODB 콜렉션은 MongoDB 콜렉션에 액세스하도록 정의됩니다. 테이블 행은 수집 문서가됩니다. 예를 들어 MongoDB 샘플 수집 레스토랑을 기반으로 테이블을 만들려면 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ea932dbd50b290330d1be4d04f75b1f3d8300a" translate="yes" xml:space="preserve">
          <source>A MariaDB ColumnStore system can be configured with Multiple User Modules either during the install installation phase when running the configuration script postConfigure. More details can be found here:</source>
          <target state="translated">구성 스크립트 postConfigure를 실행할 때 설치 설치 단계 중 MariaDB ColumnStore 시스템을 다중 사용자 모듈로 구성 할 수 있습니다. 자세한 내용은 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3539b7abd8b3e5bb470911dec8a1658e948bf06b" translate="yes" xml:space="preserve">
          <source>A MariaDB ColumnStore system will have at least 1 User Module. It might reside on the same server as the MariaDB ColumnStore Performance Module or can reside on a separate server. A MariaDB ColumnStore system can also be configured to have more than 1 User Modules. The advantages of having Multiple User Modules:</source>
          <target state="translated">MariaDB ColumnStore 시스템에는 하나 이상의 사용자 모듈이 있습니다. MariaDB ColumnStore 성능 모듈과 동일한 서버에 있거나 별도의 서버에있을 수 있습니다. MariaDB ColumnStore 시스템은 둘 이상의 사용자 모듈을 갖도록 구성 할 수도 있습니다. 다중 사용자 모듈의 장점 :</target>
        </trans-unit>
        <trans-unit id="74c2142547fdd26a51c277ead0a2aef5ca436d8a" translate="yes" xml:space="preserve">
          <source>A MariaDB Server version can often be backed up with most other Mariabackup releases in the same release series. For example, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10221-release-notes/&quot;&gt;MariaDB 10.2.21&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10222-release-notes/&quot;&gt;MariaDB 10.2.22&lt;/a&gt; are both in the &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; release series, so MariaDB Server from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10221-release-notes/&quot;&gt;MariaDB 10.2.21&lt;/a&gt; could be backed up by Mariabackup from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10222-release-notes/&quot;&gt;MariaDB 10.2.22&lt;/a&gt;, or vice versa.</source>
          <target state="translated">MariaDB 서버 버전은 종종 동일한 릴리스 시리즈에서 대부분의 다른 Mariabackup 릴리스로 백업 될 수 있습니다. 예를 들어, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10221-release-notes/&quot;&gt;MariaDB 10.2.21&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10222-release-notes/&quot;&gt;MariaDB 10.2.22는&lt;/a&gt; 에서 모두 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 MariaDB 서버, 그래서 릴리즈 시리즈 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10221-release-notes/&quot;&gt;MariaDB 10.2.21가&lt;/a&gt; 에서 Mariabackup 백업 할 수 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10222-release-notes/&quot;&gt;MariaDB 10.2.22&lt;/a&gt; 반대, 또는 그.</target>
        </trans-unit>
        <trans-unit id="16c6eb67f3b8dc9110f618a34c836a45fe6e2185" translate="yes" xml:space="preserve">
          <source>A MariaDB Server version that supports Galera Cluster.</source>
          <target state="translated">Galera Cluster를 지원하는 MariaDB 서버 버전.</target>
        </trans-unit>
        <trans-unit id="457570280c2da7645d8af68574be0600c16293dd" translate="yes" xml:space="preserve">
          <source>A MariaDB build's support for other InnoDB page compression algorithms can be checked by querying the following status variables with &lt;code&gt;&lt;a href=&quot;../show-status/index&quot;&gt;SHOW GLOBAL STATUS&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../show-status/index&quot;&gt;SHOW GLOBAL STATUS&lt;/a&gt;&lt;/code&gt; 로 다음 상태 변수를 쿼리하여 다른 InnoDB 페이지 압축 알고리즘에 대한 MariaDB 빌드 지원을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f4e95cbaeb5e5d9ef0d562d281e2f7b94107e15" translate="yes" xml:space="preserve">
          <source>A MariaDB crash could cause system tables corruption. With the default settings, MariaDB will simply not start if the system tables are corrupted. With &lt;a href=&quot;../myisam-system-variables/index#myisam_recover_options&quot;&gt;myisam_recover_options&lt;/a&gt;, we can force MyISAM to repair damaged tables.</source>
          <target state="translated">MariaDB 충돌로 인해 시스템 테이블이 손상 될 수 있습니다. 기본 설정을 사용하면 시스템 테이블이 손상된 경우 MariaDB가 시작되지 않습니다. &lt;a href=&quot;../myisam-system-variables/index#myisam_recover_options&quot;&gt;myisam_recover_options를&lt;/a&gt; 사용하면 MyISAM이 손상된 테이블을 복구하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7446c63abaf89f7e113a2ba0a63864ce9fffbc" translate="yes" xml:space="preserve">
          <source>A MariaDB program can read options from one or many option groups. For an exact list of option groups read on your system by a specific program, you can execute:</source>
          <target state="translated">MariaDB 프로그램은 하나 이상의 옵션 그룹에서 옵션을 읽을 수 있습니다. 특정 프로그램이 시스템에서 읽는 옵션 그룹의 정확한 목록을 보려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151b03d5adc09ceed8ec951340d8fa504ae3d7c9" translate="yes" xml:space="preserve">
          <source>A MariaDB server with the binary log enabled will run slightly more slowly.</source>
          <target state="translated">이진 로그가 활성화 된 MariaDB 서버는 약간 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3f4891b2e87231f0d1fb8bebb2668eff5e79a9fc" translate="yes" xml:space="preserve">
          <source>A Module (&lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; or &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt;) can be added or removed from MariaDB ColumnStore.</source>
          <target state="translated">MariaDB ColumnStore에서 모듈 ( &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; 또는 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; )을 추가하거나 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b815a67914dc0f5ae0d27bdbad51f3e61afc93" translate="yes" xml:space="preserve">
          <source>A MyISAM table is stored in three files on disk. There's a table definition file with an extension of &lt;code&gt;.frm&lt;/code&gt;, a data file with the extension &lt;code&gt;.MYD&lt;/code&gt;, and an index file with the extension &lt;code&gt;.MYI&lt;/code&gt;.</source>
          <target state="translated">MyISAM 테이블은 디스크의 세 파일에 저장됩니다. 확장자가 &lt;code&gt;.frm&lt;/code&gt; 인 테이블 정의 파일 , 확장자가 &lt;code&gt;.MYD&lt;/code&gt; 인 데이터 파일 및 확장자가 &lt;code&gt;.MYI&lt;/code&gt; 인 인덱스 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d300f786f12032b0153756f5074acf23e7fa16ff" translate="yes" xml:space="preserve">
          <source>A MySQL proxy script</source>
          <target state="translated">MySQL 프록시 스크립트</target>
        </trans-unit>
        <trans-unit id="098cf564f6c024d7623b1c1aa68561d151e5babd" translate="yes" xml:space="preserve">
          <source>A NoSQL plugin giving you direct access to InnoDB/XtraDB and SPIDER</source>
          <target state="translated">InnoDB / XtraDB 및 SPIDER에 직접 액세스 할 수있는 NoSQL 플러그인</target>
        </trans-unit>
        <trans-unit id="17bea5432e4d2e6feb900a1ccf207c893043819d" translate="yes" xml:space="preserve">
          <source>A PHP Object Oriented interface</source>
          <target state="translated">PHP 객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="a1d7e884eca56aab4a367d3467276813020de227" translate="yes" xml:space="preserve">
          <source>A POINT is always simple.</source>
          <target state="translated">포인트는 항상 간단합니다.</target>
        </trans-unit>
        <trans-unit id="7dc19df978fef88104f17a81e36f1a0fdd3fe350" translate="yes" xml:space="preserve">
          <source>A PRIMARY KEY is a UNIQUE KEY; a UNIQUE KEY is an INDEX. (&quot;KEY&quot; == &quot;INDEX&quot;.)</source>
          <target state="translated">기본 키는 고유 키입니다. 고유 키는 색인입니다. ( &quot;KEY&quot;== &quot;INDEX&quot;입니다.)</target>
        </trans-unit>
        <trans-unit id="ee3ff20ee52c0d67f2215aa68e1697945445f9cf" translate="yes" xml:space="preserve">
          <source>A PROCEDURE is just stored in the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc table&lt;/a&gt;. A FUNCTION has an additional requirement. They will be called in expressions with the same syntax as UDFs, so UDFs and stored FUNCTIONs share the namespace. Thus, we must make sure that we do not have UDFs and FUNCTIONs with the same name (even if they are stored in different places).</source>
          <target state="translated">PROCEDURE는 &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc 테이블에&lt;/a&gt; 저장 된다 . 기능에는 추가 요구 사항이 있습니다. UDF와 동일한 구문으로 표현식에서 호출되므로 UDF 및 저장된 FUNCTION은 네임 스페이스를 공유합니다. 따라서 다른 위치에 저장되어 있어도 동일한 이름의 UDF와 FUNCTION이 없는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6f900b2dc6b54edbeff8dde0691c4dc6cf50e95" translate="yes" xml:space="preserve">
          <source>A Partition is a group of rows, or window, that have the same value for a specific column, for example a Partition can be created over a time period such as a quarter or lookup values.</source>
          <target state="translated">파티션은 특정 열에 대해 동일한 값을 갖는 행 또는 창 그룹입니다. 예를 들어 1/4 또는 조회 값과 같은 기간 동안 파티션을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c99e0e20e831a9ce3a86e2af3219fba2be0bfbf" translate="yes" xml:space="preserve">
          <source>A RESTful UI which allows you to submit queries and examine results as well as configure Shard-Query</source>
          <target state="translated">쿼리를 제출하고 결과를 검토하고 샤드 쿼리를 구성 할 수있는 RESTful UI</target>
        </trans-unit>
        <trans-unit id="2852b11ce8a6167405761ae544f604eef10454c2" translate="yes" xml:space="preserve">
          <source>A Reasonable Set of Links</source>
          <target state="translated">합리적인 링크 모음</target>
        </trans-unit>
        <trans-unit id="0eb3374939aa9d68da329e6ed74ef8a2d40c138b" translate="yes" xml:space="preserve">
          <source>A SELECT is performed to see how many items are in the square.</source>
          <target state="translated">정사각형에 몇 개의 항목이 있는지보기 위해 SELECT가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="34a6af6533380c18eb80956d7e3441d3ff09615b" translate="yes" xml:space="preserve">
          <source>A SPATIAL index may only contain a geometrical type column</source>
          <target state="translated">SPATIAL 인덱스는 기하학적 유형 열만 포함 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="de18c48d2b208a94794a38e7d8dc2c87741d6533" translate="yes" xml:space="preserve">
          <source>A Sequence engine allows ascending or descending sequences of numbers.</source>
          <target state="translated">시퀀스 엔진은 숫자의 오름차순 또는 내림차순을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="217212b858d30f7b394178c93a5157a028209c4c" translate="yes" xml:space="preserve">
          <source>A Stored Function is a defined function that is called from within an SQL statement like a regular function, and returns a single value.</source>
          <target state="translated">저장 함수는 일반 함수와 같은 SQL 문에서 호출되는 정의 된 함수이며 단일 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f25cf6fe636ab6d07ebd03350e805372c9736d7d" translate="yes" xml:space="preserve">
          <source>A Stored Procedure is a routine invoked with a &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; statement. It may have input parameters, output parameters and parameters that are both input parameters and output parameters.</source>
          <target state="translated">저장 프로시 저는 &lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt; 문으로 호출 된 루틴 입니다. 입력 매개 변수, 출력 매개 변수 및 입력 매개 변수 및 출력 매개 변수 인 매개 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8bfb18727f3b7e1a104ec866e38e40e3a928cdf" translate="yes" xml:space="preserve">
          <source>A Stored Procedure is a routine invoked with a CALL statement.</source>
          <target state="translated">저장 프로시 저는 CALL 문으로 호출 된 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="0f24ea3afe7cdae8e46a8e3c3908f1dca5f94c22" translate="yes" xml:space="preserve">
          <source>A System Module can be disabled when the system is ACTIVE or OFFLINE. To disable a module, use the &lt;em&gt;alterSystem-disableModule module_id&lt;/em&gt; command in &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt;, or simply use &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt;&lt;em&gt;alterSystem-disableModule module_id&lt;/em&gt; from the operating system prompt.</source>
          <target state="translated">시스템이 활성 또는 오프라인 일 때 시스템 모듈을 비활성화 할 수 있습니다. 모듈을 사용하지 않으려면 사용 &lt;em&gt;alterSystem-disableModule MODULE_ID의&lt;/em&gt; 에서 명령을 &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt; , 또는 단순히 사용 &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin &lt;/a&gt;&lt;em&gt;alterSystem-disableModule MODULE_ID를&lt;/em&gt; 프롬프트 운영 체제에서.</target>
        </trans-unit>
        <trans-unit id="e401827b5012197c2c83f4e3ddfe9722e86a6694" translate="yes" xml:space="preserve">
          <source>A TEXT column with a maximum length of 16,777,215 characters.</source>
          <target state="translated">최대 16,777,215 자 길이의 TEXT 열입니다.</target>
        </trans-unit>
        <trans-unit id="7ef35301eadd0a4455f9f612e167f25406dd546a" translate="yes" xml:space="preserve">
          <source>A TEXT column with a maximum length of 255 characters.</source>
          <target state="translated">최대 길이가 255자인 TEXT 열입니다.</target>
        </trans-unit>
        <trans-unit id="26a807862e87ffdf4cb1822e3b2649275c33cb60" translate="yes" xml:space="preserve">
          <source>A TEXT column with a maximum length of 4,294,967,295 characters.</source>
          <target state="translated">최대 길이가 4,294,967,295자인 TEXT 열입니다.</target>
        </trans-unit>
        <trans-unit id="ecf5a0e850fbabb8619b745de32a1c4e951811fa" translate="yes" xml:space="preserve">
          <source>A TEXT column with a maximum length of 65,535 characters.</source>
          <target state="translated">최대 길이가 65,535자인 TEXT 열입니다.</target>
        </trans-unit>
        <trans-unit id="d36d95cb0023f6a6bb05e70b666d327d39ce6cf2" translate="yes" xml:space="preserve">
          <source>A Table lock might be left set due to come failure on processing a DML/DDL command. Normally this lock can be cleared with the utility mentioned above, cleartablelock. But in the case where its doesn't clear the lock, it can also be cleared by restarting the Active DMLProc on the system. This will cause DMLProc to perform the rollback processing that will clear any table locks.</source>
          <target state="translated">DML / DDL 명령 처리에 실패하여 테이블 잠금이 설정된 상태로 남아있을 수 있습니다. 일반적으로이 잠금은 위에서 언급 한 유틸리티 인 cleartablelock을 사용하여 지울 수 있습니다. 그러나 잠금을 해제하지 않으면 시스템에서 Active DMLProc을 다시 시작하여 잠금을 해제 할 수도 있습니다. 이로 인해 DMLProc은 테이블 잠금을 지우는 롤백 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a5b77179e76fdb6c967c978e5f0b9b541d3209a5" translate="yes" xml:space="preserve">
          <source>A USB stick or CD/DVD can be used as bootable media. The preferred way is a USB stick.</source>
          <target state="translated">USB 스틱 또는 CD / DVD를 부팅 가능한 미디어로 사용할 수 있습니다. 선호되는 방법은 USB 스틱입니다.</target>
        </trans-unit>
        <trans-unit id="d941e4766232ebd3c8e75dc49ed6095c49d83645" translate="yes" xml:space="preserve">
          <source>A UUID is a 128-bit number represented by a utf8 string of five hexadecimal numbers in &lt;code&gt;aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee&lt;/code&gt; format:</source>
          <target state="translated">UUID는 &lt;code&gt;aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee&lt;/code&gt; 형식 으로 5 개의 16 진수로 구성된 utf8 문자열로 표시되는 128 비트 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="54849d269757507a8bd3b976ecf7a2214c54001a" translate="yes" xml:space="preserve">
          <source>A UUID is designed as a number that is globally unique in space and time. Two calls to &lt;code&gt;UUID()&lt;/code&gt; are expected to generate two different values, even if these calls are performed on two separate computers that are not connected to each other.</source>
          <target state="translated">UUID는 공간과 시간에서 전 세계적으로 고유 한 숫자로 설계되었습니다. &lt;code&gt;UUID()&lt;/code&gt; 를 두 번 호출하면 서로 연결되지 않은 두 대의 컴퓨터에서 이러한 호출이 수행 되더라도 두 개의 다른 값이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4ecb400e9fa1e79ec7de23a18dae5a0c3bb247" translate="yes" xml:space="preserve">
          <source>A Unique Index must be unique, but it can be null. So each key value identifies only one record, but not each record needs to be represented.</source>
          <target state="translated">고유 색인은 고유해야하지만 널이 될 수 있습니다. 따라서 각 키 값은 하나의 레코드 만 식별하지만 각 레코드를 표시 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="53360b3f24df3676d3b0550b48d3acfa5f06c6d5" translate="yes" xml:space="preserve">
          <source>A VIR table is a virtual table having only Special or Virtual columns. Its only property is its &amp;ldquo;size&amp;rdquo;, or cardinality, meaning the number of virtual rows it contains. It is created using the syntax:</source>
          <target state="translated">VIR 테이블은 특수 또는 가상 열만있는 가상 테이블입니다. 유일한 속성은 &quot;크기&quot;또는 카디널리티이며, 포함 된 가상 행의 수를 의미합니다. 다음 구문을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0b62543b4f898cc6ac051c95035a55837adfa841" translate="yes" xml:space="preserve">
          <source>A ZIP table type is also available. It is not meant to read the inside files but to display information about the zip file contents. For instance:</source>
          <target state="translated">ZIP 테이블 유형도 사용할 수 있습니다. 내부 파일을 읽는 것이 아니라 zip 파일 내용에 대한 정보를 표시하기위한 것입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8223c171e8a31621fd1f9f770a3352ca0f4a9356" translate="yes" xml:space="preserve">
          <source>A background thread performs the resizing operation. The &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_buffer_pool_resize_status&quot;&gt;Innodb_buffer_pool_resize_status&lt;/a&gt; status variable shows the progress of the resizing operation, for example:</source>
          <target state="translated">백그라운드 스레드가 크기 조정 작업을 수행합니다. &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_buffer_pool_resize_status&quot;&gt;Innodb_buffer_pool_resize_status의&lt;/a&gt; 상태량 프로그램 예를 들면, 크기 조절 동작의 진행 :</target>
        </trans-unit>
        <trans-unit id="dcac95947d0906b5760571ad38229084c6f265dc" translate="yes" xml:space="preserve">
          <source>A basic conditional construct statement.</source>
          <target state="translated">기본 조건부 구문 설명.</target>
        </trans-unit>
        <trans-unit id="a552288c0c64205b385a3d923ec7acc89dc0f2f3" translate="yes" xml:space="preserve">
          <source>A basic overview of &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; is described in &lt;a href=&quot;../window-functions-overview/index&quot;&gt;Window Functions Overview&lt;/a&gt;. Window frames expand this functionality by allowing the function to include a specified a number of rows around the current row.</source>
          <target state="translated">의 기본 개요 &lt;a href=&quot;../window-functions/index&quot;&gt;창 기능&lt;/a&gt; 에 설명되어 &lt;a href=&quot;../window-functions-overview/index&quot;&gt;윈도우 기능 개요&lt;/a&gt; . 창 프레임은 함수가 현재 행 주위에 지정된 수의 행을 포함하도록하여이 기능을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="1e15f4d3df0af2f867fdb87c7e34b5616eb57c6e" translate="yes" xml:space="preserve">
          <source>A better solution is to directly ask the filesystem to provide an atomic (all or nothing) write guarantee. Currently this is only available on &lt;a href=&quot;index#devices-that-support-atomic-writes-with-mariadb&quot;&gt;a few SSD cards&lt;/a&gt;.</source>
          <target state="translated">더 나은 솔루션은 파일 시스템에 원자 적 (모두 또는 전혀) 쓰기 보증을 제공하도록 직접 요청하는 것입니다. 현재 이것은 &lt;a href=&quot;index#devices-that-support-atomic-writes-with-mariadb&quot;&gt;몇 개의 SSD 카드&lt;/a&gt; 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d99e216dd730c5c86957f5123b46f8eb77d059b" translate="yes" xml:space="preserve">
          <source>A bit off-topic: At some places, the loop is taken around the whole synchronization pattern:</source>
          <target state="translated">약간의 주제 외 : 일부 장소에서는 전체 동기화 패턴을 중심으로 루프가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="09d0871e5ff194244b035edd565bfebc5b34867d" translate="yes" xml:space="preserve">
          <source>A bit-field type. &lt;code&gt;M&lt;/code&gt; indicates the number of bits per value, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;64&lt;/code&gt;. The default is &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;M&lt;/code&gt; is omitted.</source>
          <target state="translated">비트 필드 타입. &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;64&lt;/code&gt; 사이의 값당 비트 수를 나타냅니다 . &lt;code&gt;M&lt;/code&gt; 을 생략 하면 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7d4fdbb0ccb8fab8b88fb0bfa2a4a58b6d69008" translate="yes" xml:space="preserve">
          <source>A book which introduces core Machine Learning concepts:</source>
          <target state="translated">핵심 기계 학습 개념을 소개하는 책 :</target>
        </trans-unit>
        <trans-unit id="5f4ba7e5118898c5c59adc7ecf5af66206076f1a" translate="yes" xml:space="preserve">
          <source>A brief list of basic features can be found below:</source>
          <target state="translated">기본 기능에 대한 간략한 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f6a61ea3742116405efb2db9a18adba825f8597" translate="yes" xml:space="preserve">
          <source>A buffer pool restore, both at startup or at any other moment, can be aborted by setting &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_load_abort&quot;&gt;innodb_buffer_pool_load_abort&lt;/a&gt; to ON.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_load_abort&quot;&gt;innodb_buffer_pool_load_abort&lt;/a&gt; 를 ON 으로 설정하여 시작시 또는 다른 순간에 버퍼 풀 복원을 중단 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cba47c6e5c71f39261394c541588ba0828795b66" translate="yes" xml:space="preserve">
          <source>A buffer.</source>
          <target state="translated">버퍼.</target>
        </trans-unit>
        <trans-unit id="ca8bc8e41b30be14769fcf630029850d304f6a59" translate="yes" xml:space="preserve">
          <source>A bulk delete statement can be used to delete the remaining rows that do not fall exactly within partition ranges. The partition drops will be fastest, however the system optimizes bulk delete statements to delete by block internally so are still relatively fast.</source>
          <target state="translated">대량 삭제 문을 사용하면 파티션 범위 내에 정확하게 속하지 않는 나머지 행을 삭제할 수 있습니다. 파티션 삭제는 가장 빠르지 만 시스템은 대량 삭제 문을 최적화하여 내부적으로 블록별로 삭제하므로 비교적 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a5bb2dfdf8a2f3475d9dcd41e68d0bba047b4093" translate="yes" xml:space="preserve">
          <source>A catalog table is one that returns information about another table, or data source. It is similar to what MariaDB commands such as &lt;code&gt;DESCRIBE&lt;/code&gt; or &lt;code&gt;SHOW&lt;/code&gt; do. Applied to local tables, this just duplicates what these commands do, with the noticeable difference that they are tables and can be used inside queries as joined tables or inside sub-selects.</source>
          <target state="translated">카탈로그 테이블은 다른 테이블 또는 데이터 소스에 대한 정보를 리턴하는 것입니다. &lt;code&gt;DESCRIBE&lt;/code&gt; 또는 &lt;code&gt;SHOW&lt;/code&gt; 와 같은 MariaDB 명령이하는 것과 유사합니다 . 로컬 테이블에 적용하면 이러한 명령이 수행하는 작업이 복제되어 테이블이라는 점이 눈에 띄게 달라지며 쿼리 내부에서 조인 테이블 또는 하위 선택 내부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec6c66838bf695bfa97367678ed7df89a694fba" translate="yes" xml:space="preserve">
          <source>A caution about using @variables for strings. If, instead of '$g', you use @g, you need to be careful to make sure that @g has the same CHARACTER SET and COLLATION as `Genus`, else there could be a charset/collation conversion on the fly that prevents the use of the INDEX. Using the INDEX is vital for performance. It may require a COLLATE clause on SET NAMES and/or the @g in the SELECT.</source>
          <target state="translated">문자열에 @variables를 사용할 때주의하십시오. '$ g'대신 @g를 사용하는 경우 @g가`Genus`와 동일한 CHARACTER SET 및 COLLATION을 갖도록주의해야합니다. 그렇지 않으면 즉석에서 문자셋 / 콜 레이션 변환이 발생할 수 있습니다. INDEX 사용을 방지합니다. INDEX 사용은 성능에 매우 중요합니다. SET NAMES 및 / 또는 SELECT의 @g에 COLLATE 절이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa34112f86eb1691b7150cd7838fd2aa1bed061" translate="yes" xml:space="preserve">
          <source>A chain of convenience stores maintains an IoT (Internet of Things) network in which each store records data on its milk inventory levels and sensor data such as refrigerator temperature. The central office continuously monitors inventory levels to trigger replenishment on an as-needed basis. The maintenance teams and store also receive real-time alerts if issues arise with the cooling system, speeding repair and reducing product losses. A holistic, whole-picture view of supply levels and status allows the chain to keep costs low and the customer experience consistent.</source>
          <target state="translated">편의점 체인은 IoT (Internet of Things) 네트워크를 유지 관리하여 각 매장은 우유 재고 수준에 대한 데이터와 냉장고 온도와 같은 센서 데이터를 기록합니다. 중앙 사무소는 재고 수준을 지속적으로 모니터링하여 필요에 따라 보충을 시작합니다. 유지 보수 팀과 매장은 냉각 시스템에 문제가 발생하여 수리 속도를 높이고 제품 손실을 줄이면 실시간 경고를받습니다. 공급 수준 및 상태에 대한 전체적인 전체 화면을 통해 체인은 비용을 낮추고 고객 경험을 일관되게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fc1440884a8dc3fa6f361cbede2ea302ed477d5" translate="yes" xml:space="preserve">
          <source>A change to the global default isolation level requires the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege. Any session is free to change its session isolation level (even in the middle of a transaction), or the isolation level for its next transaction.</source>
          <target state="translated">전역 기본 격리 수준으로 변경하려면 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 권한이 필요합니다 . 모든 세션은 세션 분리 레벨 (트랜잭션 중간에도) 또는 다음 트랜잭션의 분리 레벨을 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2de6acce91671a4030f17865f88efdde4b6c616" translate="yes" xml:space="preserve">
          <source>A character set can have many collations associated with it, while each collation is only associated with one character set. In MariaDB, the character set name is always part of the collation name. For example, the &lt;code&gt;latin1_german1_ci&lt;/code&gt; collation applies only to the &lt;code&gt;latin1&lt;/code&gt; character set. Each character set also has one default collation. The &lt;code&gt;latin1&lt;/code&gt; default collation is &lt;code&gt;latin1_swedish_ci&lt;/code&gt;.</source>
          <target state="translated">문자 집합에는 이와 관련된 많은 데이터 정렬이있을 수 있지만 각 데이터 정렬은 하나의 문자 집합에만 연결됩니다. MariaDB에서 문자 집합 이름은 항상 데이터 정렬 이름의 일부입니다. 예를 들어 &lt;code&gt;latin1_german1_ci&lt;/code&gt; 데이터 정렬은 &lt;code&gt;latin1&lt;/code&gt; 문자 집합 에만 적용됩니다 . 각 문자 집합에는 하나의 기본 데이터 정렬이 있습니다. &lt;code&gt;latin1&lt;/code&gt; 기본 데이터 정렬은 &lt;code&gt;latin1_swedish_ci&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f64206d565a0e4d6995fa568256629a215ebe3d" translate="yes" xml:space="preserve">
          <source>A character set is a set of characters while a collation is the rules for comparing and sorting a particular character set.</source>
          <target state="translated">문자 집합은 문자 집합이며 데이터 정렬은 특정 문자 집합을 비교하고 정렬하는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="b1c2d74f2e01abc54801ab309422da6a47924a66" translate="yes" xml:space="preserve">
          <source>A character than can be represented by a Universal Character Name</source>
          <target state="translated">범용 문자 이름으로 표시 될 수있는 문자</target>
        </trans-unit>
        <trans-unit id="1aad79a13aaf9318eba03f3ffbd1cfd01cb856cc" translate="yes" xml:space="preserve">
          <source>A client whose connection is killed receives the following error:</source>
          <target state="translated">연결이 종료 된 클라이언트는 다음 오류를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="b0a610aa6de2c26f912258ae782b39199dfd4da0" translate="yes" xml:space="preserve">
          <source>A column can also be declared &lt;code&gt;WITH VERSIONING&lt;/code&gt;, that will automatically make the table versioned. The statement below is equivalent to the one above:</source>
          <target state="translated">열을 &lt;code&gt;WITH VERSIONING&lt;/code&gt; 으로 선언 하면 테이블의 버전이 자동으로 지정됩니다. 아래 내용은 위 내용과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="78142f73c1a0a04b12cb949665080d91cdb409c3" translate="yes" xml:space="preserve">
          <source>A column in a &lt;a href=&quot;../merge/index&quot;&gt;MERGE&lt;/a&gt; table can be built on a &lt;code&gt;PERSISTENT&lt;/code&gt; generated column.</source>
          <target state="translated">&lt;a href=&quot;../merge/index&quot;&gt;MERGE&lt;/a&gt; 테이블 의 컬럼은 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 컬럼 에 빌드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1647e156348c7f104ad162fa71b65e5e20fa175" translate="yes" xml:space="preserve">
          <source>A combined setting and unsetting is also possible, e.g. &lt;code&gt;(?im-sx)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(?im-sx)&lt;/code&gt; 와 같이 조합 된 설정 및 설정 해제도 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="8b743d7ff94e7de9d091ede75071c664a5d06477" translate="yes" xml:space="preserve">
          <source>A command may fail with &lt;code&gt;ER_UNKNOWN_COM_ERROR&lt;/code&gt; producing 'WSREP has not yet prepared node for application use' (or 'Unknown command' in older versions) error message. It happens when a cluster is suspected to be split and the node is in a smaller part &amp;mdash; for example, during a network glitch, when nodes temporarily lose each other. It can also occur during state transfer. The node takes this measure to prevent data inconsistency. Its usually a temporary state which can be detected by checking &lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_ready&quot;&gt;wsrep_ready&lt;/a&gt; value. The node, however, allows SHOW and SET command during this period.</source>
          <target state="translated">'WSREP가 아직 애플리케이션 사용을 위해 노드를 준비하지 않았습니다'(또는 이전 버전의 '알 수없는 명령') 오류 메시지를 생성 하는 명령이 &lt;code&gt;ER_UNKNOWN_COM_ERROR&lt;/code&gt; 와 함께 실패 할 수 있습니다 . 클러스터가 분할 된 것으로 의심되고 노드가 더 작은 부분에있을 때 (예 : 네트워크 결함 발생시 노드가 일시적으로 손실되는 경우) 발생합니다. 상태 전송 중에 발생할 수도 있습니다. 노드는 데이터 불일치를 방지하기 위해이 조치를 취합니다. 일반적으로 &lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_ready&quot;&gt;wsrep_ready&lt;/a&gt; 값 을 확인하여 감지 할 수있는 임시 상태입니다 . 그러나이 기간 동안 노드는 SHOW 및 SET 명령을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c37e73c4cde81c744b69fdd386a0953389d675af" translate="yes" xml:space="preserve">
          <source>A command redistributeData is available in the admin console to initiate a data distribution:</source>
          <target state="translated">redistributeData 명령을 관리 콘솔에서 사용하여 데이터 분배를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672cecbb21bd51f12f32eb858e379eec82550006" translate="yes" xml:space="preserve">
          <source>A comment of up to 1024 characters is permitted with the &lt;code&gt;COMMENT&lt;/code&gt; index option.</source>
          <target state="translated">&lt;code&gt;COMMENT&lt;/code&gt; 인덱스 옵션 에는 최대 1024 자의 주석이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ca137ecc3674910082f7228e9818a55c8d48304" translate="yes" xml:space="preserve">
          <source>A common fallacy: &quot;Partitioning will make my queries run faster&quot;. It won't. Ponder what it takes for a 'point query'. Without partitioning, but with an appropriate index, there is a BTree (the index) to drill down to find the desired row. For a billion rows, this might be 5 levels deep. With partitioning, first the partition is chosen and &quot;opened&quot;, then a smaller BTree (of say 4 levels) is drilled down. Well, the savings of the shallower BTree is consumed by having to open the partition. Similarly, if you look at the disk blocks that need to be touched, and which of those are likely to be cached, you come to the conclusion that about the same number of disk hits is likely. Since disk hits are the main cost in a query, Partitioning does not gain any performance (at least for this typical case). The 2D case (below) gives the main contradiction to this discussion.</source>
          <target state="translated">일반적인 오류 : &quot;파티셔닝은 쿼리 실행 속도를 높여줍니다&quot;. 그렇지 않습니다. '포인트 쿼리'에 필요한 사항을 숙고하십시오. 파티셔닝이 없지만 적절한 인덱스가 있으면 원하는 행을 찾기 위해 드릴 다운 할 BTree (인덱스)가 있습니다. 10 억 행의 경우 이것은 5 단계 깊이 일 수 있습니다. 파티셔닝을 사용하면 먼저 파티션을 선택하고 &quot;열린&quot;다음 작은 BTree (예 : 4 레벨)를 드릴 다운합니다. 더 얕은 BTree의 절약은 파티션을 열어야하므로 소비됩니다. 마찬가지로, 터치해야 할 디스크 블록과 캐시 될 디스크 블록을 보면 거의 같은 수의 디스크 적중 가능성이 있다는 결론에 도달하게됩니다. 디스크 적중은 쿼리에서 주요 비용이므로 분할은 성능을 얻지 못합니다 (적어도이 경우에는).2D 사례 (아래)는이 논의와 모순됩니다.</target>
        </trans-unit>
        <trans-unit id="185aa80b765bd3609c52898be9023441487885c0" translate="yes" xml:space="preserve">
          <source>A common replication setup is to have the &lt;a href=&quot;../server-system-variables/index#read_only&quot;&gt;slaves read only&lt;/a&gt; to ensure that no one accidentally updates then. If the slave has &lt;a href=&quot;../setting-up-replication/index&quot;&gt;binary logging enabled&lt;/a&gt; and &lt;a href=&quot;../gtid/index#gtid_strict_mode&quot;&gt;gid_strict_mode&lt;/a&gt; is used, then any update that cause changes to the binary log will stop replication.</source>
          <target state="translated">일반적인 복제 설정은 &lt;a href=&quot;../server-system-variables/index#read_only&quot;&gt;슬레이브가&lt;/a&gt; 실수로 업데이트하지 않도록 슬레이브 만 읽 도록하는 것입니다. 슬레이브에 &lt;a href=&quot;../setting-up-replication/index&quot;&gt;바이너리 로깅이 활성화되어&lt;/a&gt; 있고 &lt;a href=&quot;../gtid/index#gtid_strict_mode&quot;&gt;gid_strict_mode&lt;/a&gt; 가 사용 된 경우 바이너리 로그를 변경하는 업데이트는 복제를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="63f2b852e7204c2288ac531ec80e2229e66a13d1" translate="yes" xml:space="preserve">
          <source>A common use case for Flashback is the following scenario:</source>
          <target state="translated">Flashback의 일반적인 사용 사례는 다음 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="d3c629e9c6473521e525315539bb8c134e1deffb" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;mysqldump&lt;/code&gt; is for making a backup of an entire database:</source>
          <target state="translated">&lt;code&gt;mysqldump&lt;/code&gt; 의 일반적인 용도 는 전체 데이터베이스를 백업하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a49b0a9de74802ccbfb5f9b956c7156ff19999e3" translate="yes" xml:space="preserve">
          <source>A common, poorly performing, design pattern (EAV); plus an alternative</source>
          <target state="translated">일반적이고 성능이 저하 된 디자인 패턴 (EAV) 플러스 대안</target>
        </trans-unit>
        <trans-unit id="d45ccdcee8e5c8df89572f43f63c327a179fafbd" translate="yes" xml:space="preserve">
          <source>A complete &lt;code&gt;FETCH&lt;/code&gt; example for &lt;code&gt;sql_mode=DEFAULT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sql_mode=DEFAULT&lt;/code&gt; 에 대한 완전한 &lt;code&gt;FETCH&lt;/code&gt; 예제 :</target>
        </trans-unit>
        <trans-unit id="37dd22a4437d5420bd7354df45afcb43b216010c" translate="yes" xml:space="preserve">
          <source>A complete &lt;code&gt;FETCH&lt;/code&gt; example for &lt;code&gt;sql_mode=ORACLE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sql_mode=ORACLE&lt;/code&gt; 에 대한 완전한 &lt;code&gt;FETCH&lt;/code&gt; 예제 :</target>
        </trans-unit>
        <trans-unit id="6467d29275afe5ef954ccacecba2f069d3836bdb" translate="yes" xml:space="preserve">
          <source>A complete list of MariaDB functions and operators in alphabetical order.</source>
          <target state="translated">알파벳 순으로 MariaDB 함수 및 연산자의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="49e840e26b969d8351fa62fe6ea2c20fcd821f18" translate="yes" xml:space="preserve">
          <source>A complex query, well explained.</source>
          <target state="translated">복잡한 쿼리가 잘 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="338b4fb3088eb597642680768e313985043255f1" translate="yes" xml:space="preserve">
          <source>A compound statement is parsed completely&amp;mdash;note &quot;2 warnings&quot; in the above example, even if the condition was false (InnoDB was, indeed, disabled), and the &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement was not executed, it was still parsed and the parser produced &quot;Unknown storage engine&quot; warning.</source>
          <target state="translated">복합 명령문은 완전히 구문 분석됩니다. 위 예에서 &quot;2 경고&quot;에 유의하십시오. 조건이 false (InnoDB가 실제로 사용 불가능 함)이고 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문이 실행되지 않았더라도 여전히 구문 분석되고 구문 분석기가 생성되었습니다. 알 수없는 스토리지 엔진 &quot;경고.</target>
        </trans-unit>
        <trans-unit id="9550d6bd5689e69d4f36a251bca9a4c9f249a0dc" translate="yes" xml:space="preserve">
          <source>A compound statement might not start with a label.</source>
          <target state="translated">복합 명령문은 레이블로 시작하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd5257735a2878bddf6762ccfa25ec87775f2a3" translate="yes" xml:space="preserve">
          <source>A compound statement within a &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;stored program&lt;/a&gt; can be &lt;a href=&quot;../labels/index&quot;&gt;labeled&lt;/a&gt;. &lt;code&gt;end_label&lt;/code&gt; cannot be given unless &lt;code&gt;begin_label&lt;/code&gt; also is present. If both are present, they must be the same.</source>
          <target state="translated">&lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;저장된 프로그램&lt;/a&gt; 내의 복합 명령문에 &lt;a href=&quot;../labels/index&quot;&gt;레이블을&lt;/a&gt; 지정할 수 있습니다 . &lt;code&gt;begin_label&lt;/code&gt; 도 존재 하지 않으면 &lt;code&gt;end_label&lt;/code&gt; 을 제공 할 수 없습니다 . 둘 다 존재하면 모두 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="cc9e31399e05e08f0cce35d38235088cbd6747a1" translate="yes" xml:space="preserve">
          <source>A computed column cannot be based on a computed column</source>
          <target state="translated">계산 열은 계산 열을 기반으로 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="46c64f6b8e7e5e696167f36d874ece14c67f9895" translate="yes" xml:space="preserve">
          <source>A condition is a combination of expressions and operators that return TRUE, FALSE or NULL.The following syntax shows the conditions that can be used to return a TRUE, FALSE,or NULL condition.</source>
          <target state="translated">조건은 TRUE, FALSE 또는 NULL을 반환하는 식과 연산자의 조합입니다. 다음 구문은 TRUE, FALSE 또는 NULL 조건을 반환하는 데 사용할 수있는 조건을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="929b2f018ae287253a8abcb6b2ea210b8abedb6d" translate="yes" xml:space="preserve">
          <source>A condition name previously specified with &lt;code&gt;DECLARE ... CONDITION&lt;/code&gt;. It must be in the same stored program. See &lt;a href=&quot;../declare-condition/index&quot;&gt;DECLARE CONDITION&lt;/a&gt;.</source>
          <target state="translated">이전에 &lt;code&gt;DECLARE ... CONDITION&lt;/code&gt; 지정된 조건 이름 입니다. 동일한 저장된 프로그램에 있어야합니다. &lt;a href=&quot;../declare-condition/index&quot;&gt;선언 조건을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="84a6c1b87bc28146d91bcfe60a7fa88ec089d428" translate="yes" xml:space="preserve">
          <source>A condition_value for &lt;code&gt;DECLARE ... CONDITION&lt;/code&gt; can be an &lt;code&gt;&lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt;&lt;/code&gt; value (a 5-character string literal) or a MySQL error code (a number). You should not use SQLSTATE value '00000' or MySQL error code 0, because those indicate sucess rather than an error condition. If you try, or if you specify an invalid SQLSTATE value, an error like this is produced:</source>
          <target state="translated">&lt;code&gt;DECLARE ... CONDITION&lt;/code&gt; 의 condition_value 는 &lt;code&gt;&lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt;&lt;/code&gt; 값 (5 자 문자열 리터럴) 또는 MySQL 오류 코드 (숫자) 일 수 있습니다. 오류 상태가 아니라 성공을 나타내는 SQLSTATE 값 '00000'또는 MySQL 오류 코드 0을 사용하지 않아야합니다. 시도하거나 유효하지 않은 SQLSTATE 값을 지정하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5ebf426358c4c0ddf09bc021781e5b38cc3152b" translate="yes" xml:space="preserve">
          <source>A condition_value for &lt;code&gt;DECLARE ... HANDLER&lt;/code&gt; can be any of the following values:</source>
          <target state="translated">&lt;code&gt;DECLARE ... HANDLER&lt;/code&gt; 의 condition_value 는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7422d21192d681006190f24e52d7aad7c1968ab9" translate="yes" xml:space="preserve">
          <source>A container can also be frozen with the &lt;code&gt;pause&lt;/code&gt; command. Docker will freeze the process using croups. MariaDB will not know that it is being frozen and, when we &lt;code&gt;unpause&lt;/code&gt; it, MariaDB will resume its work as expected.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 명령으로 컨테이너를 고정 할 수도 있습니다 . Docker는 크룹을 사용하여 프로세스를 고정시킵니다. MariaDB는 그것이 동결되고 있음을 알지 못하며, &lt;code&gt;unpause&lt;/code&gt; 하지 않으면 MariaDB가 예상대로 작업을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c2aca2cdcd0ea70712c5786495810a176354f3fc" translate="yes" xml:space="preserve">
          <source>A convenient preview pane gives you real-time visualization of the changes you make while you adjust data generation settings. It gives you an opportunity to quickly make visual assessment of the generated data.</source>
          <target state="translated">편리한 미리보기 창에서 데이터 생성 설정을 조정하는 동안 변경 한 내용을 실시간으로 시각화 할 수 있습니다. 생성 된 데이터를 신속하게 시각적으로 평가할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a862ba7f306cec9a0f705f28a6924e08fd7bd817" translate="yes" xml:space="preserve">
          <source>A count of each page type:</source>
          <target state="translated">각 페이지 유형의 개수 :</target>
        </trans-unit>
        <trans-unit id="6d03569f55783a0d43b7db25c15862ee002cef63" translate="yes" xml:space="preserve">
          <source>A counter that increments for each statement you issue.</source>
          <target state="translated">발행 한 각 명세서마다 증가하는 카운터.</target>
        </trans-unit>
        <trans-unit id="9ac7b4c0f87260850294486cde1862dbca14d6d8" translate="yes" xml:space="preserve">
          <source>A couple of mcsadmin commands provide convenience functions for monitoring memory utilization across nodes. &lt;em&gt;getSystemMemory&lt;/em&gt; returns server level memory statistics and &lt;em&gt;getSystemMemoryUsers&lt;/em&gt; shows the the top 5 processes by server. The following examples are for a 2 server combined setup:</source>
          <target state="translated">여러 mcsadmin 명령은 노드 전체의 메모리 사용률을 모니터링하기위한 편리한 기능을 제공합니다. &lt;em&gt;getSystemMemory&lt;/em&gt; 는 서버 레벨 메모리 통계를 리턴하고 &lt;em&gt;getSystemMemoryUsers&lt;/em&gt; 는 서버 별 상위 5 개 프로세스를 표시합니다. 다음 예제는 2 서버 결합 설정에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="349138fb85310260e36847cb64152402618f197d" translate="yes" xml:space="preserve">
          <source>A critical way to improve table performance is by creating indexes on key columns.</source>
          <target state="translated">테이블 성능을 향상시키는 중요한 방법은 키 열에 인덱스를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98a12b1616660382f62e2de1168aa7d2378ac5d6" translate="yes" xml:space="preserve">
          <source>A cursor is a separate class, sp_cursor (defined in sp_rcontex.h) which encapsulates the basic operations used by the above instructions. This class contains the LEX, Protocol_cursor object, and its memroot, as well as the cursor's current state. Compiling and executing is fairly straight-forward. sp_instr_copen is a subclass of sp_instr_stmt and uses its mechanism to execute a substatement.</source>
          <target state="translated">커서는 별도의 클래스 인 sp_cursor (sp_rcontex.h에 정의 됨)로 위 명령에서 사용되는 기본 작업을 캡슐화합니다. 이 클래스에는 커서의 현재 상태뿐만 아니라 LEX, Protocol_cursor 객체 및 해당 memroot가 포함됩니다. 컴파일과 실행은 매우 간단합니다. sp_instr_copen은 sp_instr_stmt의 하위 클래스이며 해당 메커니즘을 사용하여 하위 문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="117ee546b638d33b2b565c8507da8b993fec151b" translate="yes" xml:space="preserve">
          <source>A cursor is a structure that allows you to go over records sequentially, and perform processing based on the result.</source>
          <target state="translated">커서는 레코드를 순차적으로 처리하고 결과에 따라 처리를 수행 할 수있는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="499e4a64e1a2c88896f4787b9327d687f502ec49" translate="yes" xml:space="preserve">
          <source>A database consists of tables that store user data. You can create multiple columns with the create table statement. The data type follows the column name when adding columns.</source>
          <target state="translated">데이터베이스는 사용자 데이터를 저장하는 테이블로 구성됩니다. create table 문을 사용하여 여러 열을 만들 수 있습니다. 열을 추가 할 때 데이터 유형은 열 이름을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1ac1980383bc09b1cdfe80985275358c36cc2656" translate="yes" xml:space="preserve">
          <source>A database schema for storing the Shard-Query configuration</source>
          <target state="translated">샤드 쿼리 구성을 저장하기위한 데이터베이스 스키마</target>
        </trans-unit>
        <trans-unit id="c74e5c68446c273951641c3a0ba0f397e2caebee" translate="yes" xml:space="preserve">
          <source>A date and time combination.</source>
          <target state="translated">날짜와 시간 조합</target>
        </trans-unit>
        <trans-unit id="1443383df8d112cf091bcffacca6815fbc540a13" translate="yes" xml:space="preserve">
          <source>A date and time combination. Supported range is 1000-01-01 00:00:00 to 9999-12-31 23:59:59. From version 1.2.0 microseconds are also supported.</source>
          <target state="translated">날짜와 시간 조합 지원되는 범위는 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59입니다. 버전 1.2.0부터 마이크로 초도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="11fa7f261eebb177a6205563d62c7bb3eb48aa76" translate="yes" xml:space="preserve">
          <source>A date. The supported range is '&lt;code&gt;1000-01-01&lt;/code&gt;' to '&lt;code&gt;9999-12-31&lt;/code&gt;'. MariaDB displays &lt;code&gt;DATE&lt;/code&gt; values in '&lt;code&gt;YYYY-MM-DD&lt;/code&gt;' format, but can be assigned dates in looser formats, including strings or numbers, as long as they make sense. These include a short year, &lt;code&gt;YY-MM-DD&lt;/code&gt;, no delimiters, &lt;code&gt;YYMMDD&lt;/code&gt;, or any other acceptable delimiter, for example &lt;code&gt;YYYY/MM/DD&lt;/code&gt;. For details, see &lt;a href=&quot;../date-and-time-literals/index&quot;&gt;date and time literals&lt;/a&gt;.</source>
          <target state="translated">날짜. 지원되는 범위는 ' &lt;code&gt;1000-01-01&lt;/code&gt; '~ ' &lt;code&gt;9999-12-31&lt;/code&gt; '입니다. MariaDB는 ' &lt;code&gt;YYYY-MM-DD&lt;/code&gt; '형식으로 &lt;code&gt;DATE&lt;/code&gt; 값을 표시 하지만 문자열이나 숫자를 포함하여 더 느슨한 형식으로 날짜를 지정할 수 있습니다. 여기에는 짧은 연도, &lt;code&gt;YY-MM-DD&lt;/code&gt; , 구분 기호 없음, &lt;code&gt;YYMMDD&lt;/code&gt; 또는 기타 허용 가능한 구분 기호 (예 : &lt;code&gt;YYYY/MM/DD&lt;/code&gt; )가 포함 됩니다. 자세한 내용은 &lt;a href=&quot;../date-and-time-literals/index&quot;&gt;날짜 및 시간 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="271e746060b5a31905dc0d6ef891b96c095cabe1" translate="yes" xml:space="preserve">
          <source>A datetime precision can be specified wherever a type name is used. For example:</source>
          <target state="translated">유형 이름이 사용되는 곳마다 날짜 시간 정밀도를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa8771a1c347810dd3a4cf652a6981eac49dd8d5" translate="yes" xml:space="preserve">
          <source>A default key cache exists and cannot be destroyed. To create more key caches, the &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; server system variable.</source>
          <target state="translated">기본 키 캐시가 존재하며 삭제할 수 없습니다. 더 많은 키 캐시를 작성하려면 &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; 서버 시스템 변수입니다.</target>
        </trans-unit>
        <trans-unit id="4595ed5683e26a624cd083e2284869eb80fa543a" translate="yes" xml:space="preserve">
          <source>A delayed-insert handler.</source>
          <target state="translated">지연 삽입 핸들러</target>
        </trans-unit>
        <trans-unit id="43b9df3a5239e2ec0635c86389e5a87b70466a9c" translate="yes" xml:space="preserve">
          <source>A delimited import file should be created to match the table that you want to import data to similar to the following. In this example, the file will be saved as idbtest.tbl:</source>
          <target state="translated">다음과 비슷한 방식으로 데이터를 가져 오려는 테이블과 일치하도록 구분 된 가져 오기 파일을 작성해야합니다. 이 예에서 파일은 idbtest.tbl로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="02b2996faa8b8faca5c8d7ea5270cb3d274b471e" translate="yes" xml:space="preserve">
          <source>A description of the diagnostics area and how it is populated.</source>
          <target state="translated">진단 영역에 대한 설명 및 채워지는 방법.</target>
        </trans-unit>
        <trans-unit id="f1031e3672a57c36220d7da07a351b6ba30f6aff" translate="yes" xml:space="preserve">
          <source>A deterministic function:</source>
          <target state="translated">결정적 기능 :</target>
        </trans-unit>
        <trans-unit id="8c4689586f3df8fff4911470e628b0a765221697" translate="yes" xml:space="preserve">
          <source>A federated server is a way to have a foreign data source defined-- with all connection parameters-- so that you don't have to specify explicitly the connection parameters in a string.</source>
          <target state="translated">페더 레이 티드 서버는 모든 연결 매개 변수와 함께 외부 데이터 소스를 정의하여 문자열에 연결 매개 변수를 명시 적으로 지정할 필요가없는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3b24c656d648f80923e18e0bd01bf085c2456a09" translate="yes" xml:space="preserve">
          <source>A few more disk hits to DELETE rows from Lists. This is a small price to pay -- and you are not paying it while the user is waiting for the page to render.</source>
          <target state="translated">디스크가 목록에서 DELETE 행에 추가됩니다. 이것은 지불하는 작은 가격이며 사용자가 페이지 렌더링을 기다리는 동안 지불하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f6714568ce04aa70da0842a6078182d2352c22c" translate="yes" xml:space="preserve">
          <source>A few scenarios where one might need to update statistics tables manually:</source>
          <target state="translated">통계표를 수동으로 업데이트해야하는 몇 가지 시나리오 :</target>
        </trans-unit>
        <trans-unit id="8be0b3880705172d23bfcdaecbf3022da7302ed9" translate="yes" xml:space="preserve">
          <source>A few stored procedures were added in 1.0.6 to provide summaries based on the information schema tables. These can be accessed from the COLUMNSTORE_INFO schema.</source>
          <target state="translated">정보 스키마 테이블을 기반으로 요약을 제공하기 위해 1.0.6에 몇 가지 저장 프로 시저가 추가되었습니다. 이들은 COLUMNSTORE_INFO 스키마에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d6b0b7182088b4b23c57b6e53f30e54a172d14" translate="yes" xml:space="preserve">
          <source>A field type has changed storage format</source>
          <target state="translated">필드 유형이 저장 형식을 변경했습니다</target>
        </trans-unit>
        <trans-unit id="bcfa8731cd8f4322ecdb215d965c115dc3bc0de3" translate="yes" xml:space="preserve">
          <source>A file or directory's current context can be checked by executing &lt;code&gt;ls&lt;/code&gt; with the &lt;code&gt;--context&lt;/code&gt; or &lt;code&gt;--scontext&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; 또는 &lt;code&gt;--scontext&lt;/code&gt; 옵션 과 함께 &lt;code&gt;ls&lt;/code&gt; 를 실행하여 파일 또는 디렉토리의 현재 컨텍스트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63268b3ba550456fb1e02274e67f4147c63537e" translate="yes" xml:space="preserve">
          <source>A first try to create a table on this file will be to take the outer array as the table:</source>
          <target state="translated">이 파일에서 테이블을 생성하는 첫 번째 시도는 외부 배열을 테이블로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a554cd8e07052580c6bfdab0163ed28a24e07c3b" translate="yes" xml:space="preserve">
          <source>A fix is planned for this bug in a future version of MariaDB. In the mean time, when upgrading MariaDB, use '&lt;code&gt;apt-get upgrade&lt;/code&gt;' or '&lt;code&gt;apt-get install mariadb-server-5.5&lt;/code&gt;'.</source>
          <target state="translated">차기 버전의 MariaDB에서는이 버그에 대한 픽스가 계획되어 있습니다. 그 동안 MariaDB를 업그레이드 할 때는 ' &lt;code&gt;apt-get upgrade&lt;/code&gt; '또는 ' &lt;code&gt;apt-get install mariadb-server-5.5&lt;/code&gt; '를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cc5c4c116b788b5147f3150e25c6cfb16454723" translate="yes" xml:space="preserve">
          <source>A fixed-length string that is always right-padded with spaces to the specified length when stored. &lt;code&gt;M&lt;/code&gt; represents the column length in characters. The range of &lt;code&gt;M&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If &lt;code&gt;M&lt;/code&gt; is omitted, the length is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">고정 길이 문자열은 저장시 지정된 길이만큼 공백으로 항상 오른쪽으로 채워집니다. &lt;code&gt;M&lt;/code&gt; 은 열 길이를 문자로 나타냅니다. &lt;code&gt;M&lt;/code&gt; 의 범위 는 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;255&lt;/code&gt; 입니다. 경우 &lt;code&gt;M&lt;/code&gt; 은 생략 길이는 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38532f81e817137c402951717397c42dc3f7d5e2" translate="yes" xml:space="preserve">
          <source>A foreign key is a constraint which can be used to enforce data integrity. It is composed by a column (or a set of columns) in a table called the child table, which references to a column (or a set of columns) in a table called the parent table. If foreign keys are used, MariaDB performs some checks to enforce that some integrity rules are always enforced. For a more exhaustive explanation, see &lt;a href=&quot;../relational-databases-foreign-keys/index&quot;&gt;Relational databases: Foreign Keys&lt;/a&gt;.</source>
          <target state="translated">외래 키는 데이터 무결성을 강화하는 데 사용할 수있는 제약 조건입니다. 이는 자식 테이블이라는 테이블의 열 (또는 열 집합)으로 구성되며, 부모 테이블이라는 테이블의 열 (또는 열 집합)을 참조합니다. 외래 키를 사용하는 경우 MariaDB는 일부 무결성 규칙이 항상 시행되도록 일부 검사를 수행합니다. 보다 철저한 설명은 &lt;a href=&quot;../relational-databases-foreign-keys/index&quot;&gt;관계형 데이터베이스 : 외래 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ad2d12470d77e726817c436a0243a0dc1e1d1a" translate="yes" xml:space="preserve">
          <source>A format change in the storage engine requires an update (very rare)</source>
          <target state="translated">스토리지 엔진의 형식 변경에는 업데이트가 필요합니다 (매우 드물게)</target>
        </trans-unit>
        <trans-unit id="79bfd054c9821b2b786d84c7a61cc6b4d751e9c5" translate="yes" xml:space="preserve">
          <source>A forum discussion</source>
          <target state="translated">포럼 토론</target>
        </trans-unit>
        <trans-unit id="342dd1cf56366b6b98bde61ad9d17b31b8036142" translate="yes" xml:space="preserve">
          <source>A forum thread</source>
          <target state="translated">포럼 스레드</target>
        </trans-unit>
        <trans-unit id="8800bb41f25f5fba5aacbfcae064a8fc9ad72089" translate="yes" xml:space="preserve">
          <source>A four-digit year</source>
          <target state="translated">네 자리 연도</target>
        </trans-unit>
        <trans-unit id="9d67f1af4c8a24cff8f48732b583f3edb8edd36c" translate="yes" xml:space="preserve">
          <source>A from-string can contain these special characters:</source>
          <target state="translated">From-string은 다음 특수 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3291131c051787855f03d5135b8cbd674c3887ad" translate="yes" xml:space="preserve">
          <source>A full scan over the used index. Better than ALL but still bad if index is large and the table is joined against a previous table.</source>
          <target state="translated">사용 된 인덱스에 대한 전체 스캔. ALL보다 낫지 만 인덱스가 크고 테이블이 이전 테이블에 대해 조인 된 경우 여전히 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="2d1ba7478d9cd9f8eb7476785b1a06d9e6aab639" translate="yes" xml:space="preserve">
          <source>A full table scan is done for the table (all rows are read). This is bad if the table is large and the table is joined against a previous table! This happens when the optimizer could not find any usable index to access rows.</source>
          <target state="translated">테이블에 대한 전체 테이블 스캔이 수행됩니다 (모든 행을 읽습니다). 테이블이 크고 테이블이 이전 테이블에 대해 조인 된 경우 이는 좋지 않습니다! 이것은 옵티마이 저가 행에 액세스하기 위해 사용 가능한 인덱스를 찾을 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="abf04acd013cccf60bbc5c068840c71d93b35c30" translate="yes" xml:space="preserve">
          <source>A full-text index in MariaDB is an index of type FULLTEXT, and it allows more options when searching for portions of text from a field.</source>
          <target state="translated">MariaDB의 전체 텍스트 인덱스는 FULLTEXT 유형의 인덱스이며 필드에서 텍스트 부분을 검색 할 때 더 많은 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b32f799e8e7542ad9862e37f3a4773aba5c9bd15" translate="yes" xml:space="preserve">
          <source>A fulltext index is used to access the rows.</source>
          <target state="translated">전체 텍스트 인덱스는 행에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65fa20edd396311704471f8cc04da2d101a64dd6" translate="yes" xml:space="preserve">
          <source>A function is deterministic if it can produce only one result for a given list of parameters. If the result may be affected by stored data, server variables, random numbers or any value that is not explicitly passed, then the function is not deterministic. Also, a function is non-deterministic if it uses non-deterministic functions like &lt;a href=&quot;../now/index&quot;&gt;NOW()&lt;/a&gt; or &lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_TIMESTAMP()&lt;/a&gt;. The optimizer may choose a faster execution plan if it known that the function is deterministic. In such cases, you should declare the routine using the &lt;code&gt;DETERMINISTIC&lt;/code&gt; keyword. If you want to explicitly state that the function is not deterministic (which is the default) you can use the &lt;code&gt;NOT DETERMINISTIC&lt;/code&gt; keywords.</source>
          <target state="translated">주어진 매개 변수 목록에 대해 단 하나의 결과 만 생성 할 수있는 함수는 결정적입니다. 결과가 저장된 데이터, 서버 변수, 난수 또는 명시 적으로 전달되지 않은 값에 의해 영향을받을 수있는 경우, 함수는 결정적이지 않습니다. 또한 &lt;a href=&quot;../now/index&quot;&gt;NOW ()&lt;/a&gt; 또는 &lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_TIMESTAMP ()&lt;/a&gt; 와 같은 비 결정적 함수를 사용하는 경우 함수는 비 결정적 입니다. 기능이 결정적이라는 것을 알고 있으면 옵티마이 저는 더 빠른 실행 계획을 선택할 수 있습니다. 이러한 경우 &lt;code&gt;DETERMINISTIC&lt;/code&gt; 키워드를 사용하여 루틴을 선언해야 합니다. 함수가 결정적이지 않다는 것을 명시 적으로 나타내려면 (기본값) &lt;code&gt;NOT DETERMINISTIC&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30e550d99607423187c8d8910d07a0272a9517d1" translate="yes" xml:space="preserve">
          <source>A generated column is a column in a table that cannot explicitly be set to a specific value in a &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML query&lt;/a&gt;. Instead, its value is automatically generated based on an expression. This expression might generate the value based on the values of other columns in the table, or it might generate the value by calling &lt;a href=&quot;../built-in-functions/index&quot;&gt;built-in functions&lt;/a&gt; or &lt;a href=&quot;../user-defined-functions/index&quot;&gt;user-defined functions (UDFs)&lt;/a&gt;.</source>
          <target state="translated">생성 된 열은 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML 쿼리&lt;/a&gt; 에서 명시 적으로 특정 값으로 설정할 수없는 테이블의 열입니다 . 대신, 그 값은 표현식을 기반으로 자동 생성됩니다. 이 표현식은 테이블의 다른 열 값을 기반으로 값을 생성하거나 &lt;a href=&quot;../built-in-functions/index&quot;&gt;내장 함수&lt;/a&gt; 또는 &lt;a href=&quot;../user-defined-functions/index&quot;&gt;사용자 정의 함수 (UDF)&lt;/a&gt; 를 호출하여 값을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d53dbf70d399ac8ce73d934a283f64b5eb34565" translate="yes" xml:space="preserve">
          <source>A global counter is needed, initialized to 0 at start.</source>
          <target state="translated">글로벌 카운터가 필요하며 시작시 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="2339e3e745ebe8bb4c55ee59fed4bc0fe53c0544" translate="yes" xml:space="preserve">
          <source>A global transaction ID, or GTID for short, consists of three numbers separated with dashes '-'. For example:</source>
          <target state="translated">글로벌 트랜잭션 ID 또는 줄여서 GTID는 대시 '-'로 구분 된 세 개의 숫자로 구성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3926d1ef3c16486c6c6354ea4bf7a76bbcb4d48" translate="yes" xml:space="preserve">
          <source>A global variable change affects all new sessions. It does not affect any currently open sessions, including the one that made the change.</source>
          <target state="translated">전역 변수 변경은 모든 새 세션에 영향을줍니다. 변경 한 세션을 포함하여 현재 열려있는 세션에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f03515ec94b0f522253972ee95dcf0e99c422667" translate="yes" xml:space="preserve">
          <source>A good rule of thumb for servers consisting particularly of MyISAM tables is for about 25% or more of the available server memory to be dedicated to the key buffer.</source>
          <target state="translated">특히 MyISAM 테이블로 구성된 서버에 대한 경험적 규칙은 사용 가능한 서버 메모리의 약 25 % 이상이 키 버퍼 전용입니다.</target>
        </trans-unit>
        <trans-unit id="10dcd526b53f6536edeabaa096cae4b37a37ef43" translate="yes" xml:space="preserve">
          <source>A good way to determine whether to adjust the value is to compare the &lt;a href=&quot;../server-status-variables/index#key_read_requests&quot;&gt;key_read_requests&lt;/a&gt; value, which is the total value of requests to read an index, and the &lt;a href=&quot;../server-status-variables/index#key_reads&quot;&gt;key_reads&lt;/a&gt; values, the total number of requests that had to be read from disk.</source>
          <target state="translated">값을 조정할지 여부를 결정하는 좋은 방법 은 인덱스를 읽는 총 요청 값인 &lt;a href=&quot;../server-status-variables/index#key_reads&quot;&gt;key_read_requests&lt;/a&gt; 값 과 디스크에서 읽어야하는 총 요청 &lt;a href=&quot;../server-status-variables/index#key_read_requests&quot;&gt;수인 key_reads&lt;/a&gt; 값 을 비교하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1ef04f31262ffc4589ada266350b7ee2416d1f7d" translate="yes" xml:space="preserve">
          <source>A great resource for Galera users is &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/codership-team&quot;&gt;Codership on Google Groups&lt;/a&gt; (&lt;em&gt;&lt;code&gt;codership-team&lt;/code&gt; &lt;code&gt;'at'&lt;/code&gt; &lt;code&gt;googlegroups&lt;/code&gt; &lt;code&gt;(dot)&lt;/code&gt; &lt;code&gt;com&lt;/code&gt;&lt;/em&gt;) - If you use Galera it is recommended you subscribe.</source>
          <target state="translated">갈레 사용자를위한 훌륭한 자원이다 &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/codership-team&quot;&gt;Google 그룹스에 Codership&lt;/a&gt; ( &lt;em&gt; &lt;code&gt;codership-team&lt;/code&gt; &lt;code&gt;'at'&lt;/code&gt; &lt;code&gt;googlegroups&lt;/code&gt; &lt;code&gt;(dot)&lt;/code&gt; &lt;code&gt;com&lt;/code&gt; &lt;/em&gt; ) - 당신은 갈레을 사용하는 경우 당신이 가입을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="739935d2146ff264c2e1205610faf6b95bf42bd3" translate="yes" xml:space="preserve">
          <source>A great resource for Galera users is the mailing list run by the developers at Codership. It can be found at &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/codership-team&quot;&gt;Codership on Google Groups&lt;/a&gt;. If you use Galera, then it is recommended you subscribe.</source>
          <target state="translated">Galera 사용자에게 유용한 리소스는 Codership 개발자가 운영하는 메일 링리스트입니다. &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/codership-team&quot;&gt;Google 그룹스의 Codership에서&lt;/a&gt; 찾을 수 있습니다 . Galera를 사용하는 경우 가입하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="26d2b17ecd1377cc58e6f07b84e083257ea121c3" translate="yes" xml:space="preserve">
          <source>A hidden metadata record at the start of the clustered index is used to store each column's &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value. This makes it possible to add new columns that have default values without rebuilding the table.</source>
          <target state="translated">클러스터형 인덱스 시작시 숨겨진 메타 데이터 레코드는 각 열의 &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 을 저장하는 데 사용됩니다 . 이를 통해 테이블을 다시 작성하지 않고 기본값을 가진 새 열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b207b603628467063d446bc40e350b869b446b8" translate="yes" xml:space="preserve">
          <source>A high level summary of data loading and query execution as it relates to o...</source>
          <target state="translated">데이터로드 및 쿼리 실행과 관련된 높은 수준의 요약</target>
        </trans-unit>
        <trans-unit id="b4de11dc05f9040ec002895eb1339efbf6502a18" translate="yes" xml:space="preserve">
          <source>A high-level overview of the main reasons for choosing a particular storage engine:</source>
          <target state="translated">특정 스토리지 엔진을 선택하는 주요 이유에 대한 고급 개요 :</target>
        </trans-unit>
        <trans-unit id="b0027d146667832009bd4a327673853e36eef96d" translate="yes" xml:space="preserve">
          <source>A huge table can be split into smaller subsets. Both data and indexes are partitioned.</source>
          <target state="translated">큰 테이블은 더 작은 하위 집합으로 나눌 수 있습니다. 데이터와 인덱스가 모두 분할되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c374a04eb6aeb6fad781fcaf30da73e2da957f" translate="yes" xml:space="preserve">
          <source>A hyphen followed by the option letters unset the options. For example, &lt;code&gt;(?-im)&lt;/code&gt; means case sensitive single line match.</source>
          <target state="translated">옵션 문자 뒤에 하이픈이 있으면 옵션이 설정 해제됩니다. 예를 들어 &lt;code&gt;(?-im)&lt;/code&gt; 은 대소 문자를 구분하는 단일 행 일치를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bd80ae50ff15a95e36203925cf603f0cafc410fa" translate="yes" xml:space="preserve">
          <source>A key lookup is started with:</source>
          <target state="translated">키 조회는 다음으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a821479c14901ce7dfaa82a21165d922f9989e9c" translate="yes" xml:space="preserve">
          <source>A key management and encryption plugin for data-at-rest encryption that use...</source>
          <target state="translated">사용하는 미사용 데이터 암호화를위한 키 관리 및 암호화 플러그인 ...</target>
        </trans-unit>
        <trans-unit id="40bcae58e9cc32a3aca25b1232efaf9bf0449a63" translate="yes" xml:space="preserve">
          <source>A key management and encryption plugin for data-at-rest encryption that uses a plain-text file.</source>
          <target state="translated">일반 텍스트 파일을 사용하는 미사용 데이터 암호화를위한 키 관리 및 암호화 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="353474956e00f43f0606097c87b630ff2ccd56db" translate="yes" xml:space="preserve">
          <source>A keyword with surrounding text, or the keyword in context.</source>
          <target state="translated">주변 텍스트가있는 키워드 또는 문맥에 맞는 키워드.</target>
        </trans-unit>
        <trans-unit id="5005910c8ea5c798e172d2df051fa5028ea31954" translate="yes" xml:space="preserve">
          <source>A large integer. Numeric value with scale 0. Signed: -9,223,372,036,854,775,806 to+9,223,372,036,854,775,807 Unsigned: 0 to +18,446,744,073,709,551,613</source>
          <target state="translated">큰 정수 스케일이 0 인 숫자 값. 부호 : -9,223,372,036,854,775,806에서 +9,223,372,036,854,775,807 부호 없음 : 0에서 +18,446,744,073,709,551,613</target>
        </trans-unit>
        <trans-unit id="f1d7c22c3631b587065085faf2481e44967b6604" translate="yes" xml:space="preserve">
          <source>A large integer. The signed range is &lt;code&gt;-9223372036854775808&lt;/code&gt; to &lt;code&gt;9223372036854775807&lt;/code&gt;. The unsigned range is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;18446744073709551615&lt;/code&gt;.</source>
          <target state="translated">큰 정수 부호있는 범위는 &lt;code&gt;-9223372036854775808&lt;/code&gt; ~ &lt;code&gt;9223372036854775807&lt;/code&gt; 입니다. 부호없는 범위는 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;18446744073709551615&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7b1305325f60ee126e8fb3b956fd3cfa25ec531" translate="yes" xml:space="preserve">
          <source>A large numeric value is stored in far fewer bytes than the equivalent string value. It is therefore faster to move and compare numeric data, so it's best to choose numeric columns for unique id's and other similar fields.</source>
          <target state="translated">큰 숫자 값은 동등한 문자열 값보다 훨씬 적은 바이트로 저장됩니다. 따라서 숫자 데이터를 이동하고 비교하는 것이 더 빠르므로 고유 ID 및 기타 유사한 필드에 숫자 열을 선택하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a941266f990ea4ac807857e0e421373b2b8290aa" translate="yes" xml:space="preserve">
          <source>A larger InnoDB page size can provide a larger &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;maximum row size&lt;/a&gt;.</source>
          <target state="translated">더 큰 InnoDB 페이지 크기는 더 큰 &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;최대 행 크기를&lt;/a&gt; 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f052b160654cec9d9cd54c44671b17bcfc9ae01d" translate="yes" xml:space="preserve">
          <source>A launchd Tutorial</source>
          <target state="translated">시작된 튜토리얼</target>
        </trans-unit>
        <trans-unit id="95092e9c18b63e273ed6f391b97f85a8c3a07d62" translate="yes" xml:space="preserve">
          <source>A legacy storage engine no longer in active development.</source>
          <target state="translated">레거시 스토리지 엔진은 더 이상 활발하게 개발되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf1a240308a67b7cf1e3fae93964342ec565208a" translate="yes" xml:space="preserve">
          <source>A lightweight daemon called glbd receives the connections from clients and it redirects them to nodes. No specific client exists for this demo: a generic TCP client, like nc, can be used to send administrative commands and read the usage statistics.</source>
          <target state="translated">glbd라는 경량 데몬은 클라이언트로부터 연결을 수신하여이를 노드로 리디렉션합니다. 이 데모에는 특정 클라이언트가 없습니다. nc와 같은 일반 TCP 클라이언트를 사용하여 관리 명령을 보내고 사용 통계를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8bbc9265dd7636205dc4fb00c9ee91f677b973" translate="yes" xml:space="preserve">
          <source>A limit of implementation reached</source>
          <target state="translated">구현 한계에 도달</target>
        </trans-unit>
        <trans-unit id="48f6f7a5a2a11c7f00d9b4f53adea65a42920e9b" translate="yes" xml:space="preserve">
          <source>A list of 'attname=attvalue' separated by ';' to add to the table node.</source>
          <target state="translated">';'으로 구분 된 'attname = attvalue'목록 테이블 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8652e40baaa33bc237d3fd72fd3099aa50aefb20" translate="yes" xml:space="preserve">
          <source>A list of current events can be obtained with the &lt;a href=&quot;../show-events/index&quot;&gt;SHOW EVENTS&lt;/a&gt; statement. This only shows the event name and interval - the full event details, including the SQL, can be seen by querying the &lt;a href=&quot;../information-schema-events-table/index&quot;&gt;Information Schema EVENTS table&lt;/a&gt;, or with &lt;a href=&quot;../show-create-event/index&quot;&gt;SHOW CREATE EVENT&lt;/a&gt;.</source>
          <target state="translated">현재 이벤트 목록은 &lt;a href=&quot;../show-events/index&quot;&gt;SHOW EVENTS&lt;/a&gt; 문 으로 얻을 수 있습니다 . 여기에는 이벤트 이름과 간격 만 표시됩니다. &lt;a href=&quot;../information-schema-events-table/index&quot;&gt;정보 스키마 EVENTS 테이블&lt;/a&gt; 을 쿼리 하거나 &lt;a href=&quot;../show-create-event/index&quot;&gt;SHOW CREATE EVENT&lt;/a&gt; 를 사용하여 SQL을 포함한 전체 이벤트 세부 사항을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2ce9e249fdafc8f5f57bc29c5274660b9faacdf" translate="yes" xml:space="preserve">
          <source>A list of replication-related commands. See &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; for more replication-related information.</source>
          <target state="translated">복제 관련 명령 목록 자세한 &lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; 관련 정보는 복제 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec7978de5898ab71492f52a37affa3a759c831c6" translate="yes" xml:space="preserve">
          <source>A list of users or clients that are using Spider and agree to be referenced:</source>
          <target state="translated">Spider를 사용하고 있고 참조하기로 동의 한 사용자 또는 클라이언트 목록 :</target>
        </trans-unit>
        <trans-unit id="9165d7df7584a15768b2bda233f37ff76ac12fc1" translate="yes" xml:space="preserve">
          <source>A literal &amp;ldquo;\&amp;rdquo; backslash character.</source>
          <target state="translated">리터럴 &quot;\&quot;백 슬래시 문자</target>
        </trans-unit>
        <trans-unit id="bea78e909f6c12daa20a63f4a0ebe4b3737dd15c" translate="yes" xml:space="preserve">
          <source>A literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">리터럴 &lt;code&gt;%&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="bca7515996987aaa53002d858fe4a275d910dd67" translate="yes" xml:space="preserve">
          <source>A load balancer specifically designed for Galera Cluster</source>
          <target state="translated">Galera Cluster를 위해 특별히 설계된로드 밸런서</target>
        </trans-unit>
        <trans-unit id="eb252db90cdfcbb4a516698923fe07d89ee38d0f" translate="yes" xml:space="preserve">
          <source>A lock is released with &lt;a href=&quot;../release_lock/index&quot;&gt;RELEASE_LOCK()&lt;/a&gt;, when the connection terminates (either normally or abnormally), or before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;, when the connection executes another &lt;code&gt;GET_LOCK&lt;/code&gt; statement. From &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;, a connection can hold multiple locks at the same time, so a lock that is no longer needed needs to be explicitly released.</source>
          <target state="translated">연결이 다른 (일반적으로 또는 비정상적으로) 종료되거나 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 이전 에 연결이 다른 &lt;code&gt;GET_LOCK&lt;/code&gt; 문을 실행할 때 &lt;a href=&quot;../release_lock/index&quot;&gt;RELEASE_LOCK ()으로&lt;/a&gt; 잠금이 해제됩니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 부터 연결은 여러 개의 잠금을 동시에 보유 할 수 있으므로 더 이상 필요하지 않은 잠금을 명시 적으로 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="abbe61782a692b19d78927636aa524e2984502b7" translate="yes" xml:space="preserve">
          <source>A lock which protects each transaction from external DDL statements</source>
          <target state="translated">외부 DDL 문으로부터 각 트랜잭션을 보호하는 잠금</target>
        </trans-unit>
        <trans-unit id="a96310abdde27764ed1f00768c075fa5347b1449" translate="yes" xml:space="preserve">
          <source>A low swappiness setting is recommended for database workloads. For MariaDB databases, it is recommended to set swappiness to a value of 1.</source>
          <target state="translated">데이터베이스 작업 부하에는 낮은 교체 빈도 설정이 권장됩니다. MariaDB 데이터베이스의 경우 swappiness 값을 1로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b743c91a2c5458b0ad626c4fd9f9bfa57ea2af2d" translate="yes" xml:space="preserve">
          <source>A manual SST essentially consists of taking a backup of the donor, loading the backup on the joiner, and then manually editing the cluster state on the joiner node. This page will show how to perform this process with &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt;.</source>
          <target state="translated">수동 SST는 기본적으로 공여자 백업을 수행하고 결합 자에 백업을로드 한 다음 결합 자 노드에서 클러스터 상태를 수동으로 편집하는 것으로 구성됩니다. 이 페이지는 &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; 으로이 프로세스를 수행하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="337419ae0dcf021eb667e085a0dd51e0248409b4" translate="yes" xml:space="preserve">
          <source>A manual SST essentially consists of taking a backup of the donor, loading the backup on the joiner, and then manually editing the cluster state on the joiner node. This page will show how to perform this process with &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;.</source>
          <target state="translated">수동 SST는 기본적으로 공여자 백업을 수행하고 결합 자에 백업을로드 한 다음 결합 자 노드에서 클러스터 상태를 수동으로 편집하는 것으로 구성됩니다. 이 페이지는 &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt; 으로이 프로세스를 수행하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="48b8af73b414d40eb5af1037f63db011a88a117d" translate="yes" xml:space="preserve">
          <source>A manually set limit can be restored the system default by use of &lt;code&gt;DEFAULT&lt;/code&gt;, for example:</source>
          <target state="translated">다음과 같이 &lt;code&gt;DEFAULT&lt;/code&gt; 를 사용하여 수동으로 설정 한 한계를 시스템 기본값으로 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55a523fc43e32d5f61427e95b96d8d8335db5d24" translate="yes" xml:space="preserve">
          <source>A mariadb global or session variable is available to specify a memory limit at which point the query is switched over to disk based joins:</source>
          <target state="translated">mariadb 전역 또는 세션 변수를 사용하여 쿼리가 디스크 기반 조인으로 전환되는 시점의 메모리 제한을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f74fc27695198d3fb125473ef3cd2ffe4a0ae4" translate="yes" xml:space="preserve">
          <source>A marker of the beginning of the column value written as &lt;code&gt;%n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%n&lt;/code&gt; 쓰여진 열 값 시작의 마커입니다 .</target>
        </trans-unit>
        <trans-unit id="2a6119239e3b33df36dc5a229c599d324c799309" translate="yes" xml:space="preserve">
          <source>A marker of the end of the column value written as &lt;code&gt;%n&lt;/code&gt; (or &lt;code&gt;%m&lt;/code&gt; for optional fields).</source>
          <target state="translated">&lt;code&gt;%n&lt;/code&gt; (또는 선택적 필드의 경우 &lt;code&gt;%m&lt;/code&gt; 으로 작성된 열 값의 끝 표시 자입니다 .</target>
        </trans-unit>
        <trans-unit id="b85571b02757b471e8b54dcc507ed511b3a52cd3" translate="yes" xml:space="preserve">
          <source>A master server replicates to a slave server</source>
          <target state="translated">마스터 서버는 슬레이브 서버로 복제</target>
        </trans-unit>
        <trans-unit id="4a77a028366f1e77e45308fa521d4bf5ce9c14d8" translate="yes" xml:space="preserve">
          <source>A match can be performed against more than one word with the &lt;code&gt;|&lt;/code&gt; character. For example:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 을 사용하여 둘 이상의 단어에 대해 일치를 수행 할 수 있습니다. 캐릭터. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc9ef9d489c5db5988f41fc72ae992ed6333c861" translate="yes" xml:space="preserve">
          <source>A medium-sized integer. The signed range is -8388608 to 8388607. The unsigned range is 0 to 16777215.</source>
          <target state="translated">중간 크기의 정수입니다. 부호있는 범위는 -8388608-8388607입니다. 부호없는 범위는 0-16777215입니다.</target>
        </trans-unit>
        <trans-unit id="3ea4ef1019f79fb5caa3a09c5b23f0511a75820c" translate="yes" xml:space="preserve">
          <source>A member of the MariaDB community, Mark &lt;code&gt;&amp;lt;ms (at) it-infrastrukturen (dot) org&amp;gt;&lt;/code&gt;, has created some Debian &quot;squeeze&quot; 6.0.4 based, live iso images with &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; or 5.3 pre-installed on them and some Debian &quot;squeeze&quot; 6.0.5 based, live iso images with &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; pre-installed on them.</source>
          <target state="translated">MariaDB 커뮤니티 인 Mark &lt;code&gt;&amp;lt;ms (at) it-infrastrukturen (dot) org&amp;gt;&lt;/code&gt; 는 &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; 또는 5.3이 사전 설치된 일부 데비안 &quot;squeeze&quot;6.0.4 기반 라이브 iso 이미지와 일부 데비안을 만들었습니다. &quot;squeeze&quot;6.0.5 기반의 라이브 iso 이미지와 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5가&lt;/a&gt; 사전 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7d2dc8eecb61a20e9edf0d2393672d64fc0b778" translate="yes" xml:space="preserve">
          <source>A mini-lesson in &quot;compound indexes&quot; (&quot;composite indexes&quot;)</source>
          <target state="translated">&quot;복합 인덱스&quot;( &quot;복합 인덱스&quot;)의 미니 레슨</target>
        </trans-unit>
        <trans-unit id="57eddb9691216bafb47b148870106c059ff8bb3b" translate="yes" xml:space="preserve">
          <source>A misplaced parenthesis:</source>
          <target state="translated">잘못 놓인 괄호 :</target>
        </trans-unit>
        <trans-unit id="29e7a44d4d9bcb9b0c69fa2df296b80018363406" translate="yes" xml:space="preserve">
          <source>A mode where at least one of &lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; or &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt; is enabled is called &lt;em&gt;strict mode&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; 또는 &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt; 중 하나 이상 이 활성화 된 &lt;em&gt;모드를 엄격 모드&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="092c342d7b29c164a58fd85691ab5fdc8d359f21" translate="yes" xml:space="preserve">
          <source>A modern, native macOS client for relational databases</source>
          <target state="translated">관계형 데이터베이스를위한 최신의 고유 한 macOS 클라이언트</target>
        </trans-unit>
        <trans-unit id="f3a9f836fe87cec9d36683dfcb53ab3b78b277b4" translate="yes" xml:space="preserve">
          <source>A more accurate name for the algorithm would have been the &lt;code&gt;ENGINE&lt;/code&gt; algorithm, since the &lt;a href=&quot;../storage-engines/index&quot;&gt;storage engine&lt;/a&gt; decides how to implement the algorithm.</source>
          <target state="translated">&lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진&lt;/a&gt; 이 알고리즘을 구현하는 방법을 결정 하므로 알고리즘의 정확한 이름은 &lt;code&gt;ENGINE&lt;/code&gt; 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="be4ca3fa6c2a84678b309a294e353d0cb29eef36" translate="yes" xml:space="preserve">
          <source>A more accurate name would have been &lt;code&gt;ALGORITHM=ENGINE&lt;/code&gt;, where &lt;code&gt;ENGINE&lt;/code&gt; refers to an &quot;engine-specific&quot; algorithm.</source>
          <target state="translated">보다 정확한 이름은 &lt;code&gt;ALGORITHM=ENGINE&lt;/code&gt; 이며 여기서 &lt;code&gt;ENGINE&lt;/code&gt; 은 &quot;엔진 별&quot;알고리즘을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bc8e9198a178b1ebb46dac964598ad64aba1f0dd" translate="yes" xml:space="preserve">
          <source>A more advanced tutorial on JOINs.</source>
          <target state="translated">JOIN에 대한 고급 학습서.</target>
        </trans-unit>
        <trans-unit id="ce763b4e2e7a8748fb2a28cd23a6947ed6db2ffe" translate="yes" xml:space="preserve">
          <source>A more complex example, with input parameters, from an actual procedure used by banks:</source>
          <target state="translated">은행이 사용하는 실제 절차의 입력 매개 변수가있는 더 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="8c5d61a6d693f3633bd47569ffda174108c330c8" translate="yes" xml:space="preserve">
          <source>A more traditional scalar subquery, as part of a WHERE clause:</source>
          <target state="translated">WHERE 절의 일부인보다 전통적인 스칼라 서브 쿼리 :</target>
        </trans-unit>
        <trans-unit id="ed49f7fdc8e7672b03098b75225eb88694947b69" translate="yes" xml:space="preserve">
          <source>A multicolumn index on InnoDB can use a maximum of 16 columns. If you attempt to create a multicolumn index that uses more than 16 columns, MariaDB returns an Error 1070.</source>
          <target state="translated">InnoDB의 다중 열 인덱스는 최대 16 개의 열을 사용할 수 있습니다. 16 개가 넘는 열을 사용하는 다중 열 인덱스를 만들려고하면 MariaDB가 오류 1070을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bb581bd3d0e6633409a86966067cedabf6a6002" translate="yes" xml:space="preserve">
          <source>A multiple table can be created on them, for instance by:</source>
          <target state="translated">다음과 같은 방법으로 여러 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a6d313132a29dcdb905f66395dfd0511c09832e" translate="yes" xml:space="preserve">
          <source>A mutex is a code mechanism for ensuring that threads can only access resources one at a time. A second thread attempting to access a resource will find it protected by a mutex, and will wait for it to be unlocked.</source>
          <target state="translated">뮤텍스는 스레드가 한 번에 하나씩 리소스에만 액세스 할 수 있도록하는 코드 메커니즘입니다. 리소스에 액세스하려고 시도하는 두 번째 스레드는 뮤텍스에 의해 보호되고 잠금 해제 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="4ea077bbfdcd40e99e58989707e9085edbcc0da4" translate="yes" xml:space="preserve">
          <source>A negative number in a &lt;code&gt;\g&lt;/code&gt; sequence means a relative reference. Relative references can be helpful in long patterns, and also in patterns that are created by joining fragments together that contain references within themselves. The sequence &lt;code&gt;\g{-1}&lt;/code&gt; is a reference to the most recently started capturing subpattern before &lt;code&gt;\g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; 시퀀스 에서 음수 는 상대 참조를 의미합니다. 상대 참조는 긴 패턴 및 자체 내에 참조가 포함 된 조각을 결합하여 생성 된 패턴에서 유용 할 수 있습니다. 시퀀스 &lt;code&gt;\g{-1}&lt;/code&gt; 전에 가장 최근에 촬영 시작 서브 패턴에 대한 참조 &lt;code&gt;\g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="222716c7f515efe875d8c610d2e0c82d7b0f50b6" translate="yes" xml:space="preserve">
          <source>A negative starting position:</source>
          <target state="translated">부정적인 시작 위치 :</target>
        </trans-unit>
        <trans-unit id="f5074a5d35a3d4839620deb3f81fd50e8ec76a9c" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;../information-schema/index&quot;&gt;Information Schema&lt;/a&gt; table is installed - &lt;a href=&quot;../information-schema-spider_alloc_mem-table/index&quot;&gt;SPIDER_ALLOC_MEM&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;../information-schema/index&quot;&gt;정보 스키마&lt;/a&gt; 테이블 ( &lt;a href=&quot;../information-schema-spider_alloc_mem-table/index&quot;&gt;SPIDER_ALLOC_MEM)&lt;/a&gt; 이 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb030d64a4319ad581304f7323388a4981332c9e" translate="yes" xml:space="preserve">
          <source>A new binary log, with a new extension, is created every time the server starts, the logs are flushed, or the maximum size is reached (determined by &lt;a href=&quot;../server-system-variables/index#max_binlog_size&quot;&gt;max_binlog_size&lt;/a&gt;).</source>
          <target state="translated">서버가 시작되거나 로그가 플러시되거나 최대 크기에 도달 할 때마다 ( &lt;a href=&quot;../server-system-variables/index#max_binlog_size&quot;&gt;max_binlog_size로&lt;/a&gt; 결정 ) 새로운 확장명을 가진 새로운 이진 로그가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="371e2a4bdae5525e9a633e5e6464fe3b5e24679f" translate="yes" xml:space="preserve">
          <source>A new connection is used for each execution of statements within the body of an event, so the session counts for &lt;a href=&quot;../server-status-variables/index&quot;&gt;server status variables&lt;/a&gt; such as Com_delete and Com_select will not reflect these.</source>
          <target state="translated">이벤트 본문 내에서 명령문을 실행할 때마다 새 연결이 사용되므로 Com_delete 및 Com_select와 같은 &lt;a href=&quot;../server-status-variables/index&quot;&gt;서버 상태 변수에&lt;/a&gt; 대한 세션 수가 이러한 값을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc1916a51998b479d31780ab60d7f2e8d9414593" translate="yes" xml:space="preserve">
          <source>A new geometry with a buffer added to the original geometry</source>
          <target state="translated">원래 형상에 버퍼가 추가 된 새로운 형상</target>
        </trans-unit>
        <trans-unit id="1c450c85a15378e933e2410ecce16429f05b69a8" translate="yes" xml:space="preserve">
          <source>A new geometry with a buffer added to the original geometry.</source>
          <target state="translated">원래 지오메트리에 버퍼가 추가 된 새 지오메트리.</target>
        </trans-unit>
        <trans-unit id="7cdc2aa2d3e725a9f3a7c4739a0fbdcdd9d0dae2" translate="yes" xml:space="preserve">
          <source>A new slave can also be set up with &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; 로 새로운 슬레이브를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a80182e966ea138c7ec08d32816f143212935352" translate="yes" xml:space="preserve">
          <source>A new slave can easily be set up with &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;, which is a fork of &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt;. See &lt;a href=&quot;../setting-up-a-replication-slave-with-mariabackup/index&quot;&gt;Setting up a Replication Slave with Mariabackup&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; 의 포크 인 &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt; 으로 새로운 슬레이브를 쉽게 설정할 수 있습니다 . 자세한 내용 &lt;a href=&quot;../setting-up-a-replication-slave-with-mariabackup/index&quot;&gt;은 Mariabackup&lt;/a&gt; 을 사용 하여 복제 슬레이브 설정 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36745c0d299e17550f4486163a9216412e58c71c" translate="yes" xml:space="preserve">
          <source>A new table &lt;code&gt;tt&lt;/code&gt; with a field check constraint called &lt;code&gt;b&lt;/code&gt; , as well as a table check constraint called &lt;code&gt; b_upper&lt;/code&gt;:</source>
          <target state="translated">새로운 테이블 &lt;code&gt;tt&lt;/code&gt; 라는 필드 점검 제한 조건과 &lt;code&gt;b&lt;/code&gt; 라는뿐만 아니라, 테이블 점검 제한 조건 &lt;code&gt; b_upper&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db841251f7846c14bb6a5ab66c299cafd4b650a7" translate="yes" xml:space="preserve">
          <source>A new table check constraint called &lt;code&gt;a_upper&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;a_upper&lt;/code&gt; 라는 새로운 테이블 검사 제약 조건 :</target>
        </trans-unit>
        <trans-unit id="3ae24f5d4176d738520e7960db4b7b90c8d9de59" translate="yes" xml:space="preserve">
          <source>A new table has been created as part of an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; statement, and rows are about to be copied into it.</source>
          <target state="translated">&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 문의 일부로 새 테이블이 작성되었으며 행이 복사 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4f6eafa29d6d115a0f5dc0465fb42f927fcfc09f" translate="yes" xml:space="preserve">
          <source>A new thread is created in a thread group in the scenarios listed below.</source>
          <target state="translated">아래 나열된 시나리오에서 스레드 그룹에 새 스레드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="413ea6dd2e82cde3f0795817ac5470ca383cdc15" translate="yes" xml:space="preserve">
          <source>A newline character.</source>
          <target state="translated">줄 바꿈 문자.</target>
        </trans-unit>
        <trans-unit id="655437dc5e3813226cfbd0444120c72978b2cdd3" translate="yes" xml:space="preserve">
          <source>A non unique index or prefix of an unique index is used to find the rows. Good if the prefix doesn't match many rows.</source>
          <target state="translated">고유 색인의 고유하지 않은 색인 또는 접 두부가 행을 찾는 데 사용됩니다. 접두사가 많은 행과 일치하지 않으면 좋습니다.</target>
        </trans-unit>
        <trans-unit id="03f4816ad6022fe8c99c8ec0df40a477c1a60c59" translate="yes" xml:space="preserve">
          <source>A non-deterministic function, since it uses the &lt;a href=&quot;../uuid_short/index&quot;&gt;UUID_SHORT&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;../uuid_short/index&quot;&gt;UUID_SHORT&lt;/a&gt; 함수를 사용하므로 비 결정적 함수입니다.</target>
        </trans-unit>
        <trans-unit id="613634354f02cd6010f56e8d77023ea43b917a0c" translate="yes" xml:space="preserve">
          <source>A non-recursive CTE is basically a query-local &lt;a href=&quot;../views/index&quot;&gt;VIEW&lt;/a&gt;. There are several advantages and caveats to them. The syntax is more readable than nested &lt;code&gt;FROM (SELECT ...)&lt;/code&gt;. A CTE can refer to another and it can be referenced from multiple places.</source>
          <target state="translated">비 재귀 CTE는 기본적으로 쿼리 로컬 &lt;a href=&quot;../views/index&quot;&gt;VIEW&lt;/a&gt; 입니다. 그들에게는 몇 가지 장점과 경고가 있습니다. 구문은 중첩 된 &lt;code&gt;FROM (SELECT ...)&lt;/code&gt; 보다 읽기 쉽습니다 . CTE는 다른 곳을 참조 할 수 있으며 여러 곳에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="973c726e3ae4e2cb710617c7299b498ddc0fc852" translate="yes" xml:space="preserve">
          <source>A non-replicated table (eg, MyISAM) does not have to have a PK.</source>
          <target state="translated">복제되지 않은 테이블 (예 : MyISAM)에는 PK가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0e5da113aec8a86a29f6f6ac45df3695b46e371" translate="yes" xml:space="preserve">
          <source>A non-trivial example that cannot easily be rewritten using existing functions:</source>
          <target state="translated">기존 함수를 사용하여 쉽게 다시 작성할 수없는 사소한 예 :</target>
        </trans-unit>
        <trans-unit id="0eee01928988c08d6bd81f38934aba422ca2b36d" translate="yes" xml:space="preserve">
          <source>A normal-size (double-precision) floating-point number (see &lt;a href=&quot;../float/index&quot;&gt;FLOAT&lt;/a&gt; for a single-precision floating-point number).</source>
          <target state="translated">정규 크기 (배정 밀도) 부동 소수점 숫자 ( 단 정밀도 부동 소수점 숫자에 대해서는 &lt;a href=&quot;../float/index&quot;&gt;FLOAT&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3a3e867414a1ed3802a819ecb33ee2978da08c68" translate="yes" xml:space="preserve">
          <source>A normal-size integer. Numeric value with scale 0. Signed: -2,147,483,646 to 2,147,483,647. Unsigned: 0 to 4,294,967,293</source>
          <target state="translated">보통 크기의 정수 스케일이 0 인 숫자 값. 부호 : -2,147,483,646-2,147,483,647. 부호없는 : 0 ~ 4,294,967,293</target>
        </trans-unit>
        <trans-unit id="228c8e98a60b0ead736ce9e2623f9b4c923d0b18" translate="yes" xml:space="preserve">
          <source>A normal-size integer. When marked UNSIGNED, it ranges from 0 to 4294967295, otherwise its range is -2147483648 to 2147483647 (SIGNED is the default). If a column has been set to ZEROFILL, all values will be prepended by zeros so that the INT value contains a number of M digits. INTEGER is a synonym for INT.</source>
          <target state="translated">보통 크기의 정수 UNSIGNED로 표시되면 범위는 0-4294967295이며, 그렇지 않으면 범위는 -2147483648-2147483647입니다 (SIGNED가 기본값 임). 열이 ZEROFILL로 설정된 경우 INT 값에 M 개의 숫자가 포함되도록 모든 값 앞에 0이 붙습니다. INTEGER는 INT와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="449784097fb4eae4e60471204e59887180044ac1" translate="yes" xml:space="preserve">
          <source>A note about Cassandra 1.2</source>
          <target state="translated">카산드라 1.2에 대한 메모</target>
        </trans-unit>
        <trans-unit id="c0043fb0a96b1ceb5b5047da2990ccd674b5aed0" translate="yes" xml:space="preserve">
          <source>A note about lengths</source>
          <target state="translated">길이에 대한 메모</target>
        </trans-unit>
        <trans-unit id="f5704ffe0800185de9b2d587d34fa9b3e163c465" translate="yes" xml:space="preserve">
          <source>A note is different to a warning in that it only appears if the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_notes&quot;&gt;sql_notes&lt;/a&gt;&lt;/code&gt; variable is set to 1 (the default), and is not converted to an error if &lt;code&gt;&lt;a href=&quot;../sql_mode/index&quot;&gt;strict mode&lt;/a&gt;&lt;/code&gt; is enabled.</source>
          <target state="translated">메모는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_notes&quot;&gt;sql_notes&lt;/a&gt;&lt;/code&gt; 변수가 1 (기본값)로 설정된 경우에만 표시 되고 &lt;code&gt;&lt;a href=&quot;../sql_mode/index&quot;&gt;strict mode&lt;/a&gt;&lt;/code&gt; 가 활성화 된 경우 오류로 변환되지 않는다는 점에서 경고와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="dae7d7a54a2f026a5839c77da1ed1a514d25e86d" translate="yes" xml:space="preserve">
          <source>A note on GTIDs</source>
          <target state="translated">GTID에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="52f8144e76c7470b35e1741b5d5f5adcdf6c47be" translate="yes" xml:space="preserve">
          <source>A number of new &lt;a href=&quot;../server-status-variables/index&quot;&gt;status variables&lt;/a&gt; have been introduced:</source>
          <target state="translated">여러 가지 새로운 &lt;a href=&quot;../server-status-variables/index&quot;&gt;상태 변수&lt;/a&gt; 가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="063453b9cc1604b78ef09f16e0495123f9bd7296" translate="yes" xml:space="preserve">
          <source>A number of new system and status variables for controlling and monitoring the feature are introduced.</source>
          <target state="translated">기능을 제어하고 모니터링하기위한 많은 새로운 시스템 및 상태 변수가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="30ce18e98f4d493561441dfface4f6b21c0d6c3e" translate="yes" xml:space="preserve">
          <source>A number of normal table operations work on Sequence tables. See next section.</source>
          <target state="translated">시퀀스 테이블에는 많은 일반 테이블 작업이 작동합니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="108d7cb2c17e84130b71060f0b0754d27667edec" translate="yes" xml:space="preserve">
          <source>A number of options need to be set in order for Galera Cluster to work when using MariaDB. See &lt;a href=&quot;../configuring-mariadb-galera-cluster/index&quot;&gt;Configuring MariaDB Galera Cluster&lt;/a&gt; for more information.</source>
          <target state="translated">MariaDB를 사용할 때 Galera Cluster가 작동하려면 여러 옵션을 설정해야합니다. 자세한 정보는 &lt;a href=&quot;../configuring-mariadb-galera-cluster/index&quot;&gt;MariaDB Galera 클러스터 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b92cc2537d8c331f8a181ff0205019454de77bdd" translate="yes" xml:space="preserve">
          <source>A number of options need to be set in order for Galera Cluster to work when using MariaDB. These should be set in the &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;MariaDB option file&lt;/a&gt;.</source>
          <target state="translated">MariaDB를 사용할 때 Galera Cluster가 작동하려면 여러 옵션을 설정해야합니다. 이것은 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;MariaDB 옵션 파일&lt;/a&gt; 에서 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="03a85f39faa150b338ae87f3b0b1ca96cc691a92" translate="yes" xml:space="preserve">
          <source>A number of options that control the default match behavior can be changed within the pattern by a sequence of option letters enclosed between &lt;code&gt;(?&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">기본 일치 동작을 제어하는 ​​많은 옵션은 패턴에서 &lt;code&gt;(?&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt; 로 묶인 일련의 옵션 문자에 의해 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb6c082ae5574c02caa4bb3e047fd3f4e6fe1c2" translate="yes" xml:space="preserve">
          <source>A number of status variables provide information about the query cache.</source>
          <target state="translated">여러 상태 변수는 쿼리 캐시에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ffe839799c8b013c0b3de0d3bbdef32cbac7bcc" translate="yes" xml:space="preserve">
          <source>A number of system configuration variables exist to allow fine tuning of the system monitoring capabilities. In general the default values will work relatively well for many cases.</source>
          <target state="translated">시스템 모니터링 기능을 미세 조정할 수있는 많은 시스템 구성 변수가 있습니다. 일반적으로 기본값은 많은 경우에 비교적 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="369b0a296c8bbaafcb54ad009a3ecb5351778321" translate="yes" xml:space="preserve">
          <source>A number of system configuration variables exist to allow fine tuning of the system to suit the physical hardware and query characteristics. In general the default values will work relatively well for many cases.</source>
          <target state="translated">실제 하드웨어 및 쿼리 특성에 맞게 시스템을 미세 조정할 수있는 여러 시스템 구성 변수가 있습니다. 일반적으로 기본값은 많은 경우에 비교적 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92ce3d78d077af937c6d2883dde2cd19a5b72810" translate="yes" xml:space="preserve">
          <source>A numeric error code, in this case &lt;code&gt;1046&lt;/code&gt;. Error codes from 1900 and up are specific to MariaDB, while error codes from 1000 to 1800 are shared by MySQL and MariaDB.</source>
          <target state="translated">이 경우 숫자 오류 코드, &lt;code&gt;1046&lt;/code&gt; . 1900 이상의 오류 코드는 MariaDB에만 해당되는 반면, 1000에서 1800까지의 오류 코드는 MySQL 및 MariaDB가 공유합니다.</target>
        </trans-unit>
        <trans-unit id="7a9c910ab1a0409235635d51b6d11b613b654904" translate="yes" xml:space="preserve">
          <source>A package body provides implementations of the package public routines and can optionally have:</source>
          <target state="translated">패키지 본문은 패키지 공개 루틴의 구현을 제공하며 선택적으로 다음을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df7e46fc6c19162020ca451274c586bcf44b4ba0" translate="yes" xml:space="preserve">
          <source>A package whose specification was created by the &lt;code&gt;CREATE PACKAGE&lt;/code&gt; statement, should later be implemented using the &lt;a href=&quot;../create-package-body/index&quot;&gt;CREATE PACKAGE BODY&lt;/a&gt; statement.</source>
          <target state="translated">&lt;code&gt;CREATE PACKAGE&lt;/code&gt; 문으로 스펙을 작성한 패키지 는 나중에 &lt;a href=&quot;../create-package-body/index&quot;&gt;CREATE PACKAGE BODY&lt;/a&gt; 문을 사용하여 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="be533b737d971b0b1bfef6db695b5b5a39d2144f" translate="yes" xml:space="preserve">
          <source>A packed &quot;exact&quot; fixed-point number.</source>
          <target state="translated">압축 된 &quot;정확한&quot;고정 소수점 숫자.</target>
        </trans-unit>
        <trans-unit id="dbc49898e3d6abf5d99ef62d85b0e5fd938e5390" translate="yes" xml:space="preserve">
          <source>A packed &quot;exact&quot; fixed-point number. &lt;code&gt;M&lt;/code&gt; is the total number of digits (the precision) and &lt;code&gt;D&lt;/code&gt; is the number of digits after the decimal point (the scale). The decimal point and (for negative numbers) the &quot;-&quot; sign are not counted in &lt;code&gt;M&lt;/code&gt;. If &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, values have no decimal point or fractional part and on &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; the value will be rounded to the nearest &lt;code&gt;DECIMAL&lt;/code&gt;. The maximum number of digits (&lt;code&gt;M&lt;/code&gt;) for &lt;code&gt;DECIMAL&lt;/code&gt; is 65. The maximum number of supported decimals (&lt;code&gt;D&lt;/code&gt;) is &lt;code&gt;30&lt;/code&gt; before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariadB 10.2.1&lt;/a&gt; and &lt;code&gt;38&lt;/code&gt; afterwards. If &lt;code&gt;D&lt;/code&gt; is omitted, the default is &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;M&lt;/code&gt; is omitted, the default is &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">압축 된 &quot;정확한&quot;고정 소수점 숫자. &lt;code&gt;M&lt;/code&gt; 은 전체 자릿수 (정밀도)이고 &lt;code&gt;D&lt;/code&gt; 는 소수점 뒤의 자릿수 (스케일)입니다. 소수점과 (음수의 경우) &quot;-&quot;부호는 &lt;code&gt;M&lt;/code&gt; 으로 계산되지 않습니다 . 경우 &lt;code&gt;D&lt;/code&gt; 는 인 &lt;code&gt;0&lt;/code&gt; , 값은 소수점 또는 분수 부분이없고에 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 값 근처로 반올림한다 &lt;code&gt;DECIMAL&lt;/code&gt; . 숫자 (최대 수 &lt;code&gt;M&lt;/code&gt; 의 경우) &lt;code&gt;DECIMAL&lt;/code&gt; 지원 소수 (최대 수가 65이고 &lt;code&gt;D&lt;/code&gt; 가 ) 인 &lt;code&gt;30&lt;/code&gt; 전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariadB 10.2.1&lt;/a&gt; 및 &lt;code&gt;38&lt;/code&gt; 이후 입니다. 만약 &lt;code&gt;D&lt;/code&gt; 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 경우 &lt;code&gt;M&lt;/code&gt; 이 생략되면, 기본값은 &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee027e5a5f389397e914ff23542626711ab49d4" translate="yes" xml:space="preserve">
          <source>A packed fixed-point number that can have a specific total number of digits and with a set number of digits after a decimal. The maximum precision (total number of digits) that can be specified is 18.</source>
          <target state="translated">특정 총 자릿수와 소수 자릿수 뒤에 설정된 자릿수를 가질 수있는 팩형 고정 소수점 숫자입니다. 지정할 수있는 최대 정밀도 (총 자릿수)는 18입니다.</target>
        </trans-unit>
        <trans-unit id="39db3d4ddb4980c16920dd24edd21dc10e5f8cc2" translate="yes" xml:space="preserve">
          <source>A page can be modified several times in memory and be flushed to disk only once.</source>
          <target state="translated">메모리에서 페이지를 여러 번 수정하고 디스크로 한 번만 플러시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="511e38bc8f055ac352c4e7373777dfdac2f94b6b" translate="yes" xml:space="preserve">
          <source>A partial list of error codes and matching SQLSTATE values can be found in the page &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;MariaDB Error Codes&lt;/a&gt;.</source>
          <target state="translated">오류 코드 및 일치하는 SQLSTATE 값의 일부 목록은 &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;MariaDB 오류 코드&lt;/a&gt; 페이지에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7714058c5e51235c5a4823a8f74579381c17428" translate="yes" xml:space="preserve">
          <source>A particular user:</source>
          <target state="translated">특정 사용자 :</target>
        </trans-unit>
        <trans-unit id="8643a4306e897f81811944f37abd5d11f7ee44fa" translate="yes" xml:space="preserve">
          <source>A partition type determines how a partitioned table rows are distributed across partitions</source>
          <target state="translated">파티션 유형은 파티션 된 테이블 행이 파티션에 분산되는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="45a5d0711a5ccc25c6381d230374802678ba5dcc" translate="yes" xml:space="preserve">
          <source>A partitioned table cannot contain, or be referenced by, &lt;a href=&quot;../foreign-keys/index&quot;&gt;foreign keys&lt;/a&gt;.</source>
          <target state="translated">파티션 된 테이블은 &lt;a href=&quot;../foreign-keys/index&quot;&gt;외래 키를&lt;/a&gt; 포함하거나 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4109f5bfed369ec2cbd2f9b7f83e9e342f323f20" translate="yes" xml:space="preserve">
          <source>A partitioned table is stored in multiple files</source>
          <target state="translated">분할 된 테이블은 여러 파일에 저장됩니다</target>
        </trans-unit>
        <trans-unit id="bfa3a7f68016ee4fa8f5f25502c6a79b54942bda" translate="yes" xml:space="preserve">
          <source>A partitioned table is stored in multiple files. By default, these files are stored in the MariaDB (or InnoDB) data directory. It is possible to keep them in different paths by specifying &lt;a href=&quot;../create-table/index#data-directoryindex-directory&quot;&gt;DATA_DIRECTORY and INDEX_DIRECTORY&lt;/a&gt; table options. This is useful to store different partitions on different devices.</source>
          <target state="translated">분할 된 테이블은 여러 파일에 저장됩니다. 기본적으로 이러한 파일은 MariaDB (또는 InnoDB) 데이터 디렉토리에 저장됩니다. &lt;a href=&quot;../create-table/index#data-directoryindex-directory&quot;&gt;DATA_DIRECTORY 및 INDEX_DIRECTORY&lt;/a&gt; 테이블 옵션 을 지정하여 서로 다른 경로에 유지할 수 있습니다. 이것은 다른 장치에 다른 파티션을 저장하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f4038528243d29a19d73a4ab3e50a74fb80fbb9d" translate="yes" xml:space="preserve">
          <source>A partitioning type determines how a partitioned table's rows are distributed across partitions. Some partition types require the user to specify a partitioning expression that determines in which partition a row will be stored.</source>
          <target state="translated">분할 유형은 분할 된 테이블의 행이 분할 영역에 분산되는 방식을 결정합니다. 일부 파티션 유형에서는 사용자가 행을 저장할 파티션을 결정하는 파티셔닝 표현식을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f51db895dd639bfad92e653e7823918ee2121" translate="yes" xml:space="preserve">
          <source>A partitioning type determines how a table rows are distributed across partitions.</source>
          <target state="translated">파티셔닝 유형에 따라 테이블 행이 여러 파티션에 분산되는 방식이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2868c4741237ae5a99ecfc55922348522c2fc49c" translate="yes" xml:space="preserve">
          <source>A partitioning type is the method used by MariaDB to decide how rows are distributed over existing partitions. Choosing the proper partitioning type is important to distribute rows over partitions in an efficient way.</source>
          <target state="translated">파티셔닝 유형은 MariaDB가 기존 파티션에 행을 분산시키는 방법을 결정하기 위해 사용하는 방법입니다. 효율적인 방식으로 파티션에 행을 분배하려면 적절한 파티션 유형을 선택하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="39ee8184d7725e7274be8aad83265e2fcf5b6c47" translate="yes" xml:space="preserve">
          <source>A password should be set for these user accounts immediately after installation. This can be done either by executing the &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; statement or by running &lt;code&gt;&lt;a href=&quot;../mysql_secure_installation/index&quot;&gt;mysql_secure_installation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">설치 직후 이러한 사용자 계정에 대한 비밀번호를 설정해야합니다. &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; 문을 실행하거나 &lt;code&gt;&lt;a href=&quot;../mysql_secure_installation/index&quot;&gt;mysql_secure_installation&lt;/a&gt;&lt;/code&gt; 을 실행하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c57fc65cd2b086d961d5a43534c21b8e10d1eb6" translate="yes" xml:space="preserve">
          <source>A plugin can be installed dynamically by executing either the &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 문 을 실행하여 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4f76274676f5e506c7d46f10406f038bb5ae6bc" translate="yes" xml:space="preserve">
          <source>A plugin can be installed dynamically with an SQL statement.</source>
          <target state="translated">플러그인은 SQL 문으로 동적으로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01aae4b486539eaa4d83858db892fc314b5426e3" translate="yes" xml:space="preserve">
          <source>A plugin can be installed with a &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; option by providing either the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">플러그인이 설치 될 수 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 중 하나를 제공하여 옵션 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="bacd1d7f7ada7f771466c04a8d85e505365a09ad" translate="yes" xml:space="preserve">
          <source>A plugin can be installed with a &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; option, but it requires a server restart.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 옵션 으로 설치할 수 있지만 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c639a62932e213dee8718fd7749408966c45f7b0" translate="yes" xml:space="preserve">
          <source>A plugin can be installed with the &lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; utility if the server is completely offline.</source>
          <target state="translated">서버가 완전히 오프라인 인 경우 &lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 플러그인을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c2b2c60c54782efe834ca3477352a699b7a5942" translate="yes" xml:space="preserve">
          <source>A plugin can be installed with the &lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; utility, while the server is completely offline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 플러그인을 설치할 수 있으며 서버는 완전히 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="642eac751b57bd0e92ecca4f5224c5537156d324" translate="yes" xml:space="preserve">
          <source>A plugin will automatically be skipped by cmake if it cannot be built; for example, if some required libraries are missing or if you want to statically link a plugin that only supports dynamic linking.</source>
          <target state="translated">플러그인을 빌드 할 수없는 경우 cmake가 플러그인을 자동으로 건너 뜁니다. 예를 들어, 일부 필수 라이브러리가 없거나 동적 링크 만 지원하는 플러그인을 정적으로 링크하려는 경우.</target>
        </trans-unit>
        <trans-unit id="ef34bd9e490ff839875f866e0d1f230db30fd1cb" translate="yes" xml:space="preserve">
          <source>A plugin will be loaded by default when the server starts if:</source>
          <target state="translated">다음과 같은 경우 서버가 시작될 때 기본적으로 플러그인이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="1d30ce8625b57e73042655a3186a0939e67a18b7" translate="yes" xml:space="preserve">
          <source>A plugin's status can be found by looking at the &lt;code&gt;PLUGIN_STATUS&lt;/code&gt; column of the &lt;code&gt;&lt;a href=&quot;../information_schemaplugins-table/index&quot;&gt;information_schema.PLUGINS&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">플러그인의 상태는 &lt;code&gt;PLUGIN_STATUS&lt;/code&gt; 열을 보면 찾을 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../information_schemaplugins-table/index&quot;&gt;information_schema.PLUGINS&lt;/a&gt;&lt;/code&gt; 테이블.</target>
        </trans-unit>
        <trans-unit id="951249391965be516e62ac60bce6beb4003e7e89" translate="yes" xml:space="preserve">
          <source>A point in time when a row was inserted or deleted does not necessarily mean that a change became visible at the same moment. With transactional tables, a row might have been inserted in a long transaction, and became visible hours after it was inserted.</source>
          <target state="translated">행이 삽입되거나 삭제 된 시점이 반드시 변경 사항이 동시에 표시되었음을 의미하지는 않습니다. 트랜잭션 테이블을 사용하면 행이 긴 트랜잭션에 삽입되어 삽입 된 지 몇 시간 후에 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b4fc0799719b6ba7824b6c41e0aa93c93c50a7" translate="yes" xml:space="preserve">
          <source>A pointer for use as required by the function. Commonly, &lt;em&gt;initid-&amp;gt;ptr&lt;/em&gt; is used to communicate allocated memory, with &lt;em&gt;x_init()&lt;/em&gt; allocating the memory and assigning it to this pointer, &lt;em&gt;x()&lt;/em&gt; using it, and &lt;em&gt;x_deinit()&lt;/em&gt; de-allocating it.</source>
          <target state="translated">함수에 필요한 포인터입니다. 일반적 &lt;em&gt;&amp;gt; PTR initid-&lt;/em&gt; 으로 할당 된 메모리를 통신하는 데 사용된다 &lt;em&gt;x_init ()&lt;/em&gt; 메모리를 할당하고,이 포인터에 할당, &lt;em&gt;X ()&lt;/em&gt; 를 사용하고, &lt;em&gt;() x_deinit&lt;/em&gt; 이를 할당 해제.</target>
        </trans-unit>
        <trans-unit id="d9e798d00c41f51a9bcf951d5348d902c6030cfb" translate="yes" xml:space="preserve">
          <source>A possible 2-partition use case: &lt;a href=&quot;http://forums.mysql.com/read.php?24,633179,633179&quot;&gt;http://forums.mysql.com/read.php?24,633179,633179&lt;/a&gt;</source>
          <target state="translated">가능한 2 파티션 사용 사례 : &lt;a href=&quot;http://forums.mysql.com/read.php?24,633179,633179&quot;&gt; http://forums.mysql.com/read.php?24,633179,633179&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6d606a71e875a2b242106e4a596aea31de43434" translate="yes" xml:space="preserve">
          <source>A possible alternative on Unix (if taskset or a separate machine running the benchmark is not desired for some reason) would be to increase thread_pool_size to make the server threads more &quot;competitive&quot; against the client threads.</source>
          <target state="translated">유닉스에서 가능한 대안은 (어떤 이유로 작업 세트 나 벤치 마크를 실행하는 별도의 머신이 바람직하지 않은 경우) thread_pool_size를 증가시켜 서버 스레드를 클라이언트 스레드에 대해 &quot;경쟁적&quot;으로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c062df8afb5e8a5a47ba3397ac97288abd4c03ae" translate="yes" xml:space="preserve">
          <source>A prepared statement can access &lt;a href=&quot;../user-defined-variables/index&quot;&gt;user-defined variables&lt;/a&gt;, but not &lt;a href=&quot;../declare-variable/index&quot;&gt;local variables&lt;/a&gt; or procedure's parameters.</source>
          <target state="translated">준비된 명령문은 &lt;a href=&quot;../user-defined-variables/index&quot;&gt;사용자 정의 변수에&lt;/a&gt; 액세스 할 수 있지만 &lt;a href=&quot;../declare-variable/index&quot;&gt;로컬 변수&lt;/a&gt; 나 프로 시저의 매개 변수 에는 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="03c9602384c14118a99064cd9e1c8445d0d1293b" translate="yes" xml:space="preserve">
          <source>A prepared statement is executed with &lt;code&gt;&lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt;&lt;/code&gt; and released with &lt;code&gt;&lt;a href=&quot;../deallocate-drop-prepared-statement/index&quot;&gt;DEALLOCATE PREPARE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">준비된 명령문은 &lt;code&gt;&lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt;&lt;/code&gt; 로 실행 되고 &lt;code&gt;&lt;a href=&quot;../deallocate-drop-prepared-statement/index&quot;&gt;DEALLOCATE PREPARE&lt;/a&gt;&lt;/code&gt; 로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="baa04f029620a606b6e3533f20612c35b54e999f" translate="yes" xml:space="preserve">
          <source>A prepared statement is implicitly deallocated when a new &lt;code&gt;PREPARE&lt;/code&gt; command is issued. In that case, there is no need to use &lt;code&gt;DEALLOCATE&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;PREPARE&lt;/code&gt; 명령이 발행 되면 준비된 명령문이 내재적으로 할당 해제됩니다 . 이 경우 &lt;code&gt;DEALLOCATE&lt;/code&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2d3155f2d4c49c2536cf189eb052f46b916c576d" translate="yes" xml:space="preserve">
          <source>A primary key is unique and can never be null. It will always identify only one record, and each record must be represented. Each table can only have one primary key.</source>
          <target state="translated">기본 키는 고유하며 절대 null 일 수 없습니다. 항상 하나의 레코드 만 식별하며 각 레코드를 나타내야합니다. 각 테이블에는 기본 키가 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe64845bbcf88de4a4b5b6ba2f1d1ce1ebcd16d" translate="yes" xml:space="preserve">
          <source>A process matches if its output line from the &lt;em&gt;ps&lt;/em&gt; command contains the pattern. By default, mysql_zap asks for confirmation for each process. Respond &lt;em&gt;y&lt;/em&gt; to kill the process, or &lt;em&gt;q&lt;/em&gt; to exit mysql_zap. For any other response, mysql_zap does not attempt to kill the process.</source>
          <target state="translated">&lt;em&gt;ps&lt;/em&gt; 명령 의 출력 행 에 패턴이 있으면 프로세스가 일치합니다 . 기본적으로 mysql_zap는 각 프로세스에 대한 확인을 요청합니다. 프로세스 를 종료 하려면 &lt;em&gt;y&lt;/em&gt; 에 응답 하고, mysql_zap를 종료하려면 &lt;em&gt;q&lt;/em&gt; 에 응답하십시오. 다른 응답의 경우 mysql_zap는 프로세스 종료를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04fc2217de45980208e7a4fe7a07a3ef52cd76a0" translate="yes" xml:space="preserve">
          <source>A prompt.</source>
          <target state="translated">프롬프트.</target>
        </trans-unit>
        <trans-unit id="6408eb869410d74531cb405c2608a0b1e8a3fc0d" translate="yes" xml:space="preserve">
          <source>A property of the &lt;code&gt;IGNORE&lt;/code&gt; clause consists in causing transactional engines and non-transactional engines (like XtraDB and Aria) to behave the same way. For example, normally a multi-row insert which tries to violate a &lt;code&gt;UNIQUE&lt;/code&gt; contraint is completely rolled back on XtraDB/InnoDB, but might be partially executed on Aria. With the &lt;code&gt;IGNORE&lt;/code&gt; clause, the statement will be partially executed in both engines.</source>
          <target state="translated">&lt;code&gt;IGNORE&lt;/code&gt; 절의 속성은 트랜잭션 엔진과 비 트랜잭션 엔진 (예 : XtraDB 및 Aria)이 동일한 방식으로 작동하도록 구성됩니다. 예를 들어, 일반적으로 &lt;code&gt;UNIQUE&lt;/code&gt; 제약 조건 을 위반하는 다중 행 삽입 은 XtraDB / InnoDB에서 완전히 롤백되지만 Aria에서 부분적으로 실행될 수 있습니다. &lt;code&gt;IGNORE&lt;/code&gt; 와 함께 절, 문장은 부분적으로 양쪽 엔진에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="eb9134185b2bbda5790b622a001428f0b015504d" translate="yes" xml:space="preserve">
          <source>A purgeable log is in use, will not purge</source>
          <target state="translated">제거 가능한 로그가 사용 중이며 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e031574fb463e2d3ff03e2cdab525039917333" translate="yes" xml:space="preserve">
          <source>A query expansion search is a modification of a natural language search. The search string is used to perform a regular natural language search. Then, words from the most relevant rows returned by the search are added to the search string and the search is done again. The query returns the rows from the second search. The IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION or WITH QUERY EXPANSION modifier specifies a query expansion search. It can be useful when relying on implied knowledge within the data, for example that MariaDB is a database.</source>
          <target state="translated">검색어 확장 검색은 자연어 검색의 수정입니다. 검색 문자열은 일반 자연어 검색을 수행하는 데 사용됩니다. 그런 다음 검색에서 반환 된 가장 관련있는 행의 단어가 검색 문자열에 추가되고 검색이 다시 수행됩니다. 쿼리는 두 번째 검색에서 행을 반환합니다. QUERY EXPANSION WITH WITH QUERY EXPANSION 수정자가 IN NATURAL LANGUAGE 모드에서 쿼리 확장 검색을 지정합니다. 데이터 내에 암시 적 지식 (예 : MariaDB가 데이터베이스 임)에 의존 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8982a3bb7c9a6e3b7e80cd6bc1e4834c6370fa52" translate="yes" xml:space="preserve">
          <source>A query is first parsed by the MariaDB server &lt;em&gt;mysqld&lt;/em&gt; process and passed through to the ColumnStore storage engine. This passes the request onto the &lt;em&gt;ExeMgr&lt;/em&gt; process which is responsible for optimizing and orchestrating execution of the query. The &lt;em&gt;ExeMgr&lt;/em&gt; optimizer creates a series of batch primitive steps that are executed on the PM nodes by the &lt;em&gt;PrimProc&lt;/em&gt; processes. Since multiple PM servers can be deployed this allows for scale out execution of the queries by multiple servers. As much as possible the optimizer attempts to push query execution down to the PM server however certain operations inherently must be executed centrally by the &lt;em&gt;ExeMgr&lt;/em&gt; process, for example final result ordering. Filtering, joins, aggregates, and group by are in general pushed down and executed at the PM level. At the PM level batch primitive steps are performed at a granular level where individual threads operate on individual 1K-8K blocks within an extent. This enables a larger multi core server to be fully consumed and scale out within a single server. The current batch primitive steps available in the system include:</source>
          <target state="translated">쿼리는 먼저 MariaDB 서버 &lt;em&gt;mysqld&lt;/em&gt; 프로세스에 의해 구문 분석되어 ColumnStore 스토리지 엔진으로 전달됩니다. 그러면 쿼리 실행을 최적화하고 조정 하는 &lt;em&gt;ExeMgr&lt;/em&gt; 프로세스로 요청이 전달 됩니다. &lt;em&gt;ExeMgr의&lt;/em&gt; 최적화는에 의해 오후 노드에서 실행되는 배치 원시 일련의 단계를 생성 &lt;em&gt;PrimProc의&lt;/em&gt; 프로세스를. 여러 PM 서버를 배포 할 수 있으므로 여러 서버에서 쿼리 실행을 확장 할 수 있습니다. 가능한 한 옵티마이 저는 쿼리 실행을 PM 서버로 푸시하려고 시도하지만 특정 작업은 기본적으로&lt;em&gt; ExeMgr&lt;/em&gt;최종 결과 순서와 같은 프로세스. 필터링, 조인, 집계 및 그룹 기준은 일반적으로 PM 수준에서 푸시 다운되고 실행됩니다. PM 레벨에서 배치 프리미티브 단계는 개별 스레드가 범위 내에서 개별 1K-8K 블록에서 작동하는 세분화 된 수준에서 수행됩니다. 이를 통해 더 큰 멀티 코어 서버를 완전히 사용하고 단일 서버 내에서 확장 할 수 있습니다. 시스템에서 사용 가능한 현재 배치 기본 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d039d4df6db1d04c48cce0b5f0656ec9e601404b" translate="yes" xml:space="preserve">
          <source>A query is not limited to a single partition by clause. Different partition clauses can be used across different window function applications.</source>
          <target state="translated">쿼리는 단일 파티션 기준 절로 제한되지 않습니다. 다른 파티션 함수는 다른 윈도우 기능 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1035252de6b2c6aee52381c32eb88d6d6c7a9d" translate="yes" xml:space="preserve">
          <source>A query may produce some identical rows. By default, all rows are retrieved, even when their values are the same. To explicitly specify that you want to retrieve identical rows, use the &lt;code&gt;ALL&lt;/code&gt; option. If you want duplicates to be removed from the resultset, use the &lt;code&gt;DISTINCT&lt;/code&gt; option. &lt;code&gt;DISTINCTROW&lt;/code&gt; is a synonym for &lt;code&gt;DISTINCT&lt;/code&gt;. See also &lt;a href=&quot;../count-distinct/index&quot;&gt;COUNT DISTINCT&lt;/a&gt; and &lt;a href=&quot;../sql_modeoracle-from-mariadb-103/index#simple-syntax-compatibility&quot;&gt;SELECT UNIQUE in Oracle mode&lt;/a&gt;.</source>
          <target state="translated">쿼리는 동일한 행을 생성 할 수 있습니다. 기본적으로 값이 동일하더라도 모든 행이 검색됩니다. 동일한 행을 검색하도록 명시 적으로 지정하려면 &lt;code&gt;ALL&lt;/code&gt; 옵션을 사용하십시오 . 결과 집합에서 중복을 제거하려면 &lt;code&gt;DISTINCT&lt;/code&gt; 옵션을 사용하십시오 . &lt;code&gt;DISTINCTROW&lt;/code&gt; 는 동의어입니다 &lt;code&gt;DISTINCT&lt;/code&gt; . &lt;a href=&quot;../sql_modeoracle-from-mariadb-103/index#simple-syntax-compatibility&quot;&gt;Oracle 모드에서 &lt;/a&gt;&lt;a href=&quot;../count-distinct/index&quot;&gt;COUNT DISTINCT&lt;/a&gt; 및 SELECT UNIQUE 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ebb7586615cbf5682e16b000fba00489025e215" translate="yes" xml:space="preserve">
          <source>A query to check what compression is used in the SST files that store the data for a given table (test.t1):</source>
          <target state="translated">주어진 테이블 (test.t1)의 데이터를 저장하는 SST 파일에서 어떤 압축이 사용되는지 확인하는 쿼리 :</target>
        </trans-unit>
        <trans-unit id="e7b5a7fc6da9634dcd05f45db322d7e420b21804" translate="yes" xml:space="preserve">
          <source>A query to grab the list of phone numbers for clients who ordered in the la...</source>
          <target state="translated">La에서 주문한 고객의 전화 번호 목록을 가져 오는 쿼리 ...</target>
        </trans-unit>
        <trans-unit id="e089ff5db0352f60299785a9db41db3186167c26" translate="yes" xml:space="preserve">
          <source>A query to grab the list of phone numbers for clients who ordered in the last two weeks might be written in a couple of ways. Here are two:</source>
          <target state="translated">지난 2 주 동안 주문한 고객의 전화 번호 목록을 가져 오는 쿼리는 몇 가지 방법으로 작성 될 수 있습니다. 다음은 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="99a5a8c41c14b61365834809b7fa777a59c6100b" translate="yes" xml:space="preserve">
          <source>A query will also not be added to the cache if:</source>
          <target state="translated">다음과 같은 경우 쿼리가 캐시에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08f9af63b450b675c64eb483f2d1878284058bd5" translate="yes" xml:space="preserve">
          <source>A question &quot;type&quot;, which has one of the following values:</source>
          <target state="translated">다음 값 중 하나를 갖는 질문 &quot;유형&quot;</target>
        </trans-unit>
        <trans-unit id="d2c2261c348dad570580f2ceea14a92d6dfa4ba2" translate="yes" xml:space="preserve">
          <source>A quick way to get the values of these system variables is to execute the following commands:</source>
          <target state="translated">이러한 시스템 변수의 값을 얻는 빠른 방법은 다음 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec3d48f24904873b3e94d326d39195f4f723bd1e" translate="yes" xml:space="preserve">
          <source>A read-only storage engine that stores its data in Amazon S3.</source>
          <target state="translated">Amazon S3에 데이터를 저장하는 읽기 전용 스토리지 엔진.</target>
        </trans-unit>
        <trans-unit id="92976c8eb9301aa97b60f90d15a5987ad6838d70" translate="yes" xml:space="preserve">
          <source>A recommended book for understanding the underlying statistics in the R packages is:</source>
          <target state="translated">R 패키지의 기본 통계를 이해하기 위해 권장되는 책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72afe4d406da8147b7b74557b2e64a5fdfb84cb5" translate="yes" xml:space="preserve">
          <source>A record of SQL queries that took a long time to perform.</source>
          <target state="translated">수행하는 데 시간이 오래 걸린 SQL 쿼리 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="9dc662cb69fe9183fd3141029d31a1450e913d7e" translate="yes" xml:space="preserve">
          <source>A recursive CTE will repeatedly execute subsets of the data until obtaining the complete results</source>
          <target state="translated">재귀 CTE는 완전한 결과를 얻을 때까지 데이터의 하위 집합을 반복적으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7daf16ce05f958f6263b75859c19b377774989f1" translate="yes" xml:space="preserve">
          <source>A regular INSERT with a primary key value of 1 will fail, due to the existing key:</source>
          <target state="translated">기존 키로 인해 기본 키 값이 1 인 일반 INSERT가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="192ef6b14829b65580a293d8e918158eff957fca" translate="yes" xml:space="preserve">
          <source>A related statement, &lt;code&gt;&lt;a href=&quot;../show-errors/index&quot;&gt;SHOW ERRORS&lt;/a&gt;&lt;/code&gt;, shows only the errors.</source>
          <target state="translated">관련 &lt;code&gt;&lt;a href=&quot;../show-errors/index&quot;&gt;SHOW ERRORS&lt;/a&gt;&lt;/code&gt; 는 오류 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="eb2098fc5f61f95bfbf814ed7c0b54601d664078" translate="yes" xml:space="preserve">
          <source>A result found in the query cache is being sent to the client.</source>
          <target state="translated">쿼리 캐시에서 찾은 결과가 클라이언트로 전송되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d07599ddd9529cb40c30ea80c449ea361ab506" translate="yes" xml:space="preserve">
          <source>A retail bank maintains a customer database that includes their account information and a transaction activities ledger. When a customer makes a deposit or a withdrawal, the application updates the transaction activities ledger of their account. The customer can access their account information and activity through the bank's online portal.</source>
          <target state="translated">소매 은행은 계정 정보와 거래 활동 원장을 포함하는 고객 데이터베이스를 유지 관리합니다. 고객이 입금 또는 출금을하면 응용 프로그램은 계정의 거래 활동 원장을 업데이트합니다. 고객은 은행의 온라인 포털을 통해 계정 정보 및 활동에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fee561fb460412dd3c78bb6889a74f5ade8db6b" translate="yes" xml:space="preserve">
          <source>A retail store wants to amplify sales by providing a personalized shopping experience. When a customer checks out at a cash register or online, the customer is presented promotions tailored to the customer's interests. These offers may also be integrated across channels, available when the known customer visits the website, shops by mobile phone app, or be included in the next personalized email sent to the customer.</source>
          <target state="translated">소매점은 개인화 된 쇼핑 경험을 제공하여 판매를 확대하고자합니다. 고객이 금전 등록기 또는 온라인에서 체크 아웃하면 고객의 관심사에 맞는 프로모션이 고객에게 제공됩니다. 이러한 제안은 채널 전체에 통합되거나 알려진 고객이 웹 사이트를 방문하거나 휴대 전화 앱을 통해 쇼핑하거나 고객에게 전송 된 다음 개인화 된 전자 메일에 포함될 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53d9a2289f7e5e6af5dd1ae8bd21f3e7dacc042" translate="yes" xml:space="preserve">
          <source>A role bundles a number of privileges together. It assists larger organizations where, typically, a number of users would have the same privileges, and, previously, the only way to change the privileges for a group of users was by changing each user's privileges individually.</source>
          <target state="translated">역할은 여러 권한을 하나로 묶습니다. 일반적으로 많은 사용자가 동일한 권한을 가진 대규모 조직을 지원하며 이전에는 사용자 그룹의 권한을 변경하는 유일한 방법은 각 사용자의 권한을 개별적으로 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="467fc7a1d936a7c6c333d701609fd35937bbc8d7" translate="yes" xml:space="preserve">
          <source>A routine failed and has neither NO SQL nor READS SQL DATA in its declaration and binary logging is enabled; if non-transactional tables were updated, the binary log will miss their changes</source>
          <target state="translated">루틴이 실패했으며 선언에 SQL 또는 READS SQL DATA가 없으며 이진 로깅이 사용 가능합니다. 비 트랜잭션 테이블이 업데이트 된 경우 이진 로그의 변경 내용이 누락됩니다</target>
        </trans-unit>
        <trans-unit id="af3b15501181390bd510d1a3f9bf07554323803f" translate="yes" xml:space="preserve">
          <source>A row subquery is a &lt;a href=&quot;../subqueries/index&quot;&gt;subquery&lt;/a&gt; returning a single row, as opposed to a &lt;a href=&quot;../subqueries-scalar-subqueries/index&quot;&gt;scalar subquery&lt;/a&gt;, which returns a single column from a row, or a literal.</source>
          <target state="translated">행 부질의는있다 &lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리&lt;/a&gt; A와는 대조적으로, 단일 행을 반환 &lt;a href=&quot;../subqueries-scalar-subqueries/index&quot;&gt;스칼라 서브 쿼리&lt;/a&gt; 행 또는 리터럴에서 단일 열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68ace0d55a94f35f3508b218e9e3e574524a9be3" translate="yes" xml:space="preserve">
          <source>A row-size limit of 65535 bytes applies</source>
          <target state="translated">65535 바이트의 행 크기 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8be15dbf7755bedde90bb2f95174d74ae64c5ce" translate="yes" xml:space="preserve">
          <source>A safe statement is generally deterministic; in other words the statement will always produce the same result. For example, an INSERT statement producing a random number will most likely produce a different result on the master than on the slave, and so cannot be replicated safely.</source>
          <target state="translated">안전한 진술은 일반적으로 결정적입니다. 다시 말해이 진술은 항상 같은 결과를 낳을 것입니다. 예를 들어, 난수를 생성하는 INSERT 문은 마스터에서 슬레이브와 다른 결과를 생성 할 가능성이 높으므로 안전하게 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e141e9831d25bfe5be1a5ef04176f405bd5fa9e2" translate="yes" xml:space="preserve">
          <source>A sample OEM wrapper displaying a one line table saying &amp;ldquo;Hello world&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;Hello world&amp;rdquo;라는 한 줄 테이블을 표시하는 샘플 OEM 래퍼</target>
        </trans-unit>
        <trans-unit id="2e27bbdf6b6cbabec500d826caf6bc872fc2183e" translate="yes" xml:space="preserve">
          <source>A sample listing from a directory containing the binary logs:</source>
          <target state="translated">이진 로그가 포함 된 디렉토리의 샘플 목록 :</target>
        </trans-unit>
        <trans-unit id="6e0fc9354e1a964374b495ca4e0cf0e1edbcc080" translate="yes" xml:space="preserve">
          <source>A scalar subquery is a &lt;a href=&quot;../subqueries/index&quot;&gt;subquery&lt;/a&gt; that returns a single value. This is the simplest form of a subquery, and can be used in most places a literal or single column value is valid.</source>
          <target state="translated">스칼라 하위 쿼리는 단일 값을 반환하는 &lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리&lt;/a&gt; 입니다. 이것은 하위 쿼리의 가장 간단한 형태이며 대부분의 장소에서 리터럴 또는 단일 열 값이 유효한 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9369f1fe61c96132ce7b7eaf40fce7abf45c4914" translate="yes" xml:space="preserve">
          <source>A scalar's length is always 1.</source>
          <target state="translated">스칼라의 길이는 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="db5f7e8e1f23ff4459a4b70efee64e8f76e01c9f" translate="yes" xml:space="preserve">
          <source>A segmented key cache is a collection of structures for regular &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; key caches called key cache segments. Segmented key caches mitigate one of the major problems of the simple key cache: thread contention for key cache lock (mutex). With regular key caches, every call of a key cache interface function must acquire this lock. So threads compete for this lock even in the case when they have acquired shared locks for the file and the pages they want to read from are in the key cache buffers.</source>
          <target state="translated">세그먼트 키 캐시는 키 캐시 세그먼트라고 하는 일반 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 키 캐시 의 구조 모음입니다 . 세그먼트 키 캐시는 단순 키 캐시의 주요 문제점 중 하나 인 키 캐시 잠금 (mutex)에 대한 스레드 경합을 완화합니다. 일반 키 캐시를 사용하면 키 캐시 인터페이스 함수를 호출 할 때마다이 잠금을 획득해야합니다. 따라서 스레드는 파일에 대한 공유 잠금을 획득하고 읽을 페이지가 키 캐시 버퍼에있는 경우에도이 잠금과 경쟁합니다.</target>
        </trans-unit>
        <trans-unit id="10cc120cd360cf8a788582cee85ecd1a564af69e" translate="yes" xml:space="preserve">
          <source>A semi-join subquery has a form of</source>
          <target state="translated">semi-join 하위 쿼리는 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="73fb74bf8837e62946740062066b107a7a211809" translate="yes" xml:space="preserve">
          <source>A separate command for each time zone and time zone file the server needs is required.</source>
          <target state="translated">서버에 필요한 각 시간대 및 시간대 파일에 대해 별도의 명령이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="968238234aeea3a820f707ba8997802c2b408032" translate="yes" xml:space="preserve">
          <source>A sequence can go backwards too. In this case the final value will always be the &lt;code&gt;TO&lt;/code&gt; value, so that a descending sequence has the same values as an ascending sequence:</source>
          <target state="translated">시퀀스도 거꾸로 갈 수 있습니다. 이 경우 최종 값은 항상 &lt;code&gt;TO&lt;/code&gt; 값이므로 내림차순은 오름차순과 같은 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="82dde7f1d5d70dd98562f714bc75a2e1817daf87" translate="yes" xml:space="preserve">
          <source>A sequence inside &lt;code&gt;(?&amp;gt;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; makes an atomic group. Backtracking inside an atomic group is prevented once it has matched; however, backtracking past to the previous items works normally.</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;&lt;/code&gt; ... &lt;code&gt;)&lt;/code&gt; 내부의 시퀀스 는 원자 그룹을 만듭니다. 원자 그룹 내부의 역 추적은 일단 일치하면 방지됩니다. 그러나 이전 항목으로의 역 추적은 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="306036dddbc1d0d3dc898dd2d06dd04f2fef93f6" translate="yes" xml:space="preserve">
          <source>A sequence is an object that generates a sequence of numeric values, as specified by the &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt; statement.</source>
          <target state="translated">시퀀스는 &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 문에 지정된대로 숫자 값 시퀀스를 생성하는 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="ad82353990590b889731144db26f8fac4eafc8cb" translate="yes" xml:space="preserve">
          <source>A sequence is an object that generates a sequence of numeric values, as specified by the &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt; statement. Sequences are an alternative to &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; when you want more control over how sequence numbers are generated.</source>
          <target state="translated">시퀀스는 &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 문에 지정된대로 숫자 값 시퀀스를 생성하는 오브젝트입니다 . 시퀀스 번호를 생성하는 방법을보다 세밀하게 제어하려는 경우 시퀀스는 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 의 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="79c40b45cc12aa993a422de5df3ba9936e38f9a1" translate="yes" xml:space="preserve">
          <source>A sequence table has always one row.</source>
          <target state="translated">시퀀스 테이블에는 항상 하나의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37617fa4762c762e24c84a16d2279bda563ac2f" translate="yes" xml:space="preserve">
          <source>A server almost always has a large number of active plugins, because the server contains a large number of built-in plugins, which are active by default and cannot be uninstalled.</source>
          <target state="translated">서버에는 기본적으로 활성화되어 있으며 제거 할 수없는 많은 내장 플러그인이 포함되어 있기 때문에 거의 항상 활성 플러그인이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad76e57a6121e5726d3510e27907c73db4ec9273" translate="yes" xml:space="preserve">
          <source>A server restart (or closing the current connection) also causes a drop of all cached values. The cached sequence numbers are reserved only for the current connection.</source>
          <target state="translated">서버를 다시 시작하거나 현재 연결을 닫으면 캐시 된 모든 값이 삭제됩니다. 캐시 된 시퀀스 번호는 현재 연결 용으로 만 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd5b314560cafc501fe83ddd84409289c8e9484" translate="yes" xml:space="preserve">
          <source>A session variable change affects the current session only.</source>
          <target state="translated">세션 변수 변경은 현재 세션에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="643daca8752399e8d1c5e9f6e8da83d32e511fab" translate="yes" xml:space="preserve">
          <source>A session's time zone can be changed dynamically by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 세션 시간대를 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f43b1a2df5816cda209c734ce1fd813f2b8538c" translate="yes" xml:space="preserve">
          <source>A set number of rows after the current row (expr PRECEDING AND expr FOLLOWING) for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND 2 FOLLOWING&lt;/code&gt;</source>
          <target state="translated">현재 행 이후의 행 수 (expr PRECEDING 및 expr FOLLOWING) (예 : &lt;code&gt;RANGE BETWEEN CURRENT ROW AND 2 FOLLOWING&lt;/code&gt; FOLLOWING 사이의 범위 )</target>
        </trans-unit>
        <trans-unit id="d11f71966acbf5fd3b9ea3649b3079e69ec18552" translate="yes" xml:space="preserve">
          <source>A set number of rows before the current row (expr PRECEDING) for example &lt;code&gt;RANGE BETWEEN 6 PRECEDING AND CURRENT ROW&lt;/code&gt;</source>
          <target state="translated">현재 행 앞의 일련의 행 수 (expr PRECEDING) 예 : &lt;code&gt;RANGE BETWEEN 6 PRECEDING AND CURRENT ROW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4ba279883c03618afe926f9d533a730d1b594e4" translate="yes" xml:space="preserve">
          <source>A set of columns belonging to the source table, not including the &amp;ldquo;facts&amp;rdquo; and &amp;ldquo;pivot&amp;rdquo; columns.</source>
          <target state="translated">&quot;사실&quot;및 &quot;피벗&quot;열을 포함하지 않는 소스 테이블에 속하는 열 세트.</target>
        </trans-unit>
        <trans-unit id="24da7c108869faeb9707192530767b34d0411acf" translate="yes" xml:space="preserve">
          <source>A set. A string object that can have zero or more values, each of which must be chosen from the list of values 'value1', 'value2', ... A SET column can have a maximum of 64 members. SET values are represented internally as integers.</source>
          <target state="translated">세트. 0 개 이상의 값을 가질 수있는 문자열 오브젝트. 각 값은 'value1', 'value2'값 목록에서 선택해야합니다. SET 열은 최대 64 개의 멤버를 가질 수 있습니다. SET 값은 내부적으로 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a94debfd839667a356951cfa7410dc741d90d8" translate="yes" xml:space="preserve">
          <source>A shared lock is obtained to read a row, and allows other transactions to read the locked row, but not to write to the locked row. Other transactions may also acquire their own shared locks.</source>
          <target state="translated">공유 잠금은 행을 읽고 다른 트랜잭션이 잠긴 행을 읽을 수는 있지만 잠긴 행에 쓰지 못하도록합니다. 다른 트랜잭션도 자체 공유 잠금을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd477c2d212864c48e2d14cd802dc710134dd1d" translate="yes" xml:space="preserve">
          <source>A short algorithm that works for many simpler SELECTs and helps in complex queries.</source>
          <target state="translated">더 간단한 SELECT에 사용할 수 있고 복잡한 쿼리에 도움이되는 짧은 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="8cc51658edb5868cee97088ee27678b1a177ac4b" translate="yes" xml:space="preserve">
          <source>A short description of the files used by PBXT.</source>
          <target state="translated">PBXT가 사용하는 파일에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="7bc9f07a515d3a67e0ac29fb7592127700978a94" translate="yes" xml:space="preserve">
          <source>A short, but complicated, &lt;a href=&quot;http://stackoverflow.com/questions/28974572/mysql-index-for-order-by-with-date-range-in-where&quot;&gt;example&lt;/a&gt;</source>
          <target state="translated">짧지 만 복잡한 &lt;a href=&quot;http://stackoverflow.com/questions/28974572/mysql-index-for-order-by-with-date-range-in-where&quot;&gt;예&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e714eafaa712bf04d85e70ff4b7a0f2d9701bdc" translate="yes" xml:space="preserve">
          <source>A short, but complicated, &lt;a href=&quot;https://stackoverflow.com/questions/28974572/mysql-index-for-order-by-with-date-range-in-where&quot;&gt;example&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991787a475e9113cb00d2f2fd0c925375796e01e" translate="yes" xml:space="preserve">
          <source>A signal remains in effect until it is overwritten. If &lt;code&gt;conn1&lt;/code&gt; signals &lt;code&gt;'opened'&lt;/code&gt; before &lt;code&gt;conn2&lt;/code&gt; reaches &lt;code&gt;'now'&lt;/code&gt;, &lt;code&gt;conn2&lt;/code&gt; will still find the &lt;code&gt;'opened'&lt;/code&gt; signal. It does not wait in this case.</source>
          <target state="translated">신호를 덮어 쓸 때까지 신호가 유지됩니다. &lt;code&gt;conn1&lt;/code&gt; 인 경우 신호가 &lt;code&gt;'opened'&lt;/code&gt; 전 &lt;code&gt;conn2&lt;/code&gt; 도달 &lt;code&gt;'now'&lt;/code&gt; , &lt;code&gt;conn2&lt;/code&gt; 여전히 발견 할 것이다 &lt;code&gt;'opened'&lt;/code&gt; 신호를. 이 경우에는 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a78ed710ebfe976e7db9d64db6803d8b64510d9e" translate="yes" xml:space="preserve">
          <source>A similar problem can happen when stopping the MariaDB service. Therefore, it may also be a good idea to set &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.service.html#TimeoutStopSec=&quot;&gt;TimeoutStopSec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">MariaDB 서비스를 중지 할 때 비슷한 문제가 발생할 수 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.service.html#TimeoutStopSec=&quot;&gt;TimeoutStopSec&lt;/a&gt;&lt;/code&gt; 을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="80e50604fac2b202feb140fddf2ad8e35643101a" translate="yes" xml:space="preserve">
          <source>A similar problem is that, if you set the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option for a table that is unencrypted because the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option is set to &lt;code&gt;NO&lt;/code&gt;, then this encryption key ID will be saved in the table's &lt;code&gt;.frm&lt;/code&gt; file, but the encryption key will not be saved to the table's &lt;code&gt;.ibd&lt;/code&gt; file.</source>
          <target state="translated">비슷한 문제 는 암호화되지 않은 테이블에 대해 &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 설정 하면 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 설정되어 &lt;code&gt;NO&lt;/code&gt; 를 다음이 암호화 키 ID가 테이블의에 저장됩니다, &lt;code&gt;.frm&lt;/code&gt; 파일 만 암호화 키하지 않습니다 테이블의 &lt;code&gt;.ibd&lt;/code&gt; 파일에저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffeb68b31bbfb0263d332a9350e184409709aea" translate="yes" xml:space="preserve">
          <source>A similar syntax can be used on the mtr command line to specify what tests to run:</source>
          <target state="translated">mtr 명령 행에서 유사한 구문을 사용하여 실행할 테스트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19fc617d9d5032657c8d9df95a45324448e61e9f" translate="yes" xml:space="preserve">
          <source>A simple example of the clause is:</source>
          <target state="translated">이 절의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e82ad699aae5e8e085092add20e84b80b877690d" translate="yes" xml:space="preserve">
          <source>A simple set of examples to see how &lt;code&gt;EXPLAIN&lt;/code&gt; can identify poor index usage:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 이 인덱스 사용률을 식별 할 수있는 방법을 보여주는 간단한 예제 세트 :</target>
        </trans-unit>
        <trans-unit id="fb5f2c025a5c6b8634f4a4005db70094f3c3da45" translate="yes" xml:space="preserve">
          <source>A simple, common-sense restriction to put in place is to restrict the range of IP addresses that are allowed to use your master key. This way, even if someone obtains API credentials, they'll be unable to use them to decrypt your encryptions keys from a different host.</source>
          <target state="translated">간단하고 상식적인 제한은 마스터 키 사용이 허용되는 IP 주소 범위를 제한하는 것입니다. 이렇게하면 누군가가 API 자격 증명을 얻더라도이를 사용하여 다른 호스트에서 암호화 키를 해독 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43c60f3eaf41e2f3e9c155778e8975014228488b" translate="yes" xml:space="preserve">
          <source>A single node docker image can be found at &lt;a href=&quot;https://hub.docker.com/r/mariadb/columnstore/&quot;&gt;MariaDB on docker hub&lt;/a&gt;.</source>
          <target state="translated">단일 노드 도커 이미지는 &lt;a href=&quot;https://hub.docker.com/r/mariadb/columnstore/&quot;&gt; docker hub의 MariaDB에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c40b754f35e454939afe2e1fa0050dd9ab6b3db0" translate="yes" xml:space="preserve">
          <source>A size parameter was incorrectly specified, either number or on the form 10M</source>
          <target state="translated">숫자 또는 10M 형식의 크기 매개 변수가 잘못 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f193b5fc1b763dd1816c9fd75c0d7c031dc82f2" translate="yes" xml:space="preserve">
          <source>A slave is configured to use GTID by &lt;code&gt;CHANGE MASTER TO master_use_gtid=slave_pos&lt;/code&gt;. When the slave connects to the master, it will start replication at the position of the last GTID replicated to the slave, which can be seen in the variable &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;. Since GTIDs are the same across all replication servers, the slave can then be pointed to a different master, and the correct position will be determined automatically.</source>
          <target state="translated">슬레이브는 &lt;code&gt;CHANGE MASTER TO master_use_gtid=slave_pos&lt;/code&gt; 에 의해 GTID를 사용하도록 구성되어 있습니다 . 슬레이브가 마스터에 연결되면 슬레이브에 복제 된 마지막 GTID 위치에서 복제가 시작됩니다 . 변수는 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 에서 볼 수 있습니다 . GTID는 모든 복제 서버에서 동일하므로 슬레이브를 다른 마스터로 지정할 수 있으며 올바른 위치가 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="05bbe1c2b592cb94a8597a796312df8e864746f2" translate="yes" xml:space="preserve">
          <source>A slave server keeps track of the position in the master's binlog of the last event applied on the slave. This allows the slave server to re-connect and resume from where it left off after replication has been temporarily stopped. It also allows a slave to disconnect, be cloned and then have the new slave resume replication from the same master.</source>
          <target state="translated">슬레이브 서버는 마스터의 binlog에서 슬레이브에 적용된 마지막 이벤트의 위치를 ​​추적합니다. 이를 통해 슬레이브 서버는 복제가 일시적으로 중지 된 후 중단 된 위치부터 다시 연결하고 다시 시작할 수 있습니다. 또한 슬레이브가 연결을 끊고 복제 한 다음 새로운 슬레이브가 동일한 마스터에서 복제를 재개하도록합니다.</target>
        </trans-unit>
        <trans-unit id="086e8979aa76d8c6f8f047a89cb1f90b1da5568b" translate="yes" xml:space="preserve">
          <source>A slave server then keeps track of its replication position by recording the last GTID applied within each replication stream. When connecting to a new master, the slave can start replication from a different point in the binlog for each domain ID.</source>
          <target state="translated">그런 다음 슬레이브 서버는 각 복제 스트림 내에 적용된 마지막 GTID를 기록하여 복제 위치를 추적합니다. 새 마스터에 연결할 때 슬레이브는 각 도메인 ID에 대해 binlog의 다른 지점에서 복제를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d60ee9477cfad8c2089ab5ff9e4023865be9e86" translate="yes" xml:space="preserve">
          <source>A slight difference in ROLLBACK for conflict: InnoDB rolls back smaller transaction; Galera rolls back last.</source>
          <target state="translated">충돌에 대한 ROLLBACK의 약간의 차이 : InnoDB는 더 작은 트랜잭션을 롤백합니다. Galera는 마지막으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="1589e8f5e00092ad64d33c6e79caaf895971855d" translate="yes" xml:space="preserve">
          <source>A small (single-precision) floating-point number (see &lt;a href=&quot;../double/index&quot;&gt;DOUBLE&lt;/a&gt; for a regular-size floating point number). Allowable values are:</source>
          <target state="translated">작은 (단일 정밀도) 부동 소수점 숫자 ( 일반 크기 부동 소수점 숫자는 &lt;a href=&quot;../double/index&quot;&gt;DOUBLE&lt;/a&gt; 참조 ). 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7c6d25c831d38658fd4a82f3aedd169bca36ad2" translate="yes" xml:space="preserve">
          <source>A small &lt;a href=&quot;../sql_language-data_types-int/index&quot;&gt;integer&lt;/a&gt;. The signed range is -32768 to 32767. The unsigned range is 0 to 65535.</source>
          <target state="translated">작은 &lt;a href=&quot;../sql_language-data_types-int/index&quot;&gt;정수&lt;/a&gt; . 부호있는 범위는 -32768 ~ 32767입니다. 부호없는 범위는 0 ~ 65535입니다.</target>
        </trans-unit>
        <trans-unit id="4fdb06be1fbcb9a09146b736debc95296e91fde2" translate="yes" xml:space="preserve">
          <source>A small integer. Signed: -32,766 to 32,767. Unsigned: 0 to 65,533.</source>
          <target state="translated">작은 정수 서명 : -32,766 ~ 32,767 부호 없음 : 0 ~ 65,533</target>
        </trans-unit>
        <trans-unit id="b314905f2060051b64d111262357f3a5e93d17df" translate="yes" xml:space="preserve">
          <source>A smaller InnoDB page size might work more effectively in a situation with many small writes (OLTP), or with SSD storage, which usually has smaller block sizes.</source>
          <target state="translated">더 작은 InnoDB 페이지 크기는 OLTP (Small Writes)가 많거나 일반적으로 블록 크기가 더 작은 SSD 스토리지가있는 상황에서 더 효과적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b8bfb208bba534eb5ce49bf615a8936ec87816" translate="yes" xml:space="preserve">
          <source>A solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="82d7fff1ead251da619153fddb945802db0950bf" translate="yes" xml:space="preserve">
          <source>A solution -- first, the principles</source>
          <target state="translated">해결책-첫째, 원칙</target>
        </trans-unit>
        <trans-unit id="49c2cb7a610b531e1b7866029695132d8c48accd" translate="yes" xml:space="preserve">
          <source>A somewhat Oracle-like isolation level with respect to consistent (non-locking) reads: Each consistent read, even within the same transaction, sets and reads its own fresh snapshot. See &lt;a href=&quot;http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html&lt;/a&gt;.</source>
          <target state="translated">일관된 (비 잠금) 읽기와 관련하여 다소 Oracle과 유사한 격리 수준 : 동일한 트랜잭션 내에서도 각각의 일관된 읽기는 고유 한 새 스냅 샷을 설정하고 읽습니다. &lt;a href=&quot;http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="29494d2951983e0caba9f03930e6ef1169c27f8f" translate="yes" xml:space="preserve">
          <source>A somewhat Oracle-like isolation level with respect to consistent (non-locking) reads: Each consistent read, even within the same transaction, sets and reads its own fresh snapshot. See &lt;a href=&quot;https://dev.mysql.com/doc/refman/en/innodb-consistent-read.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba6513c3523697bf0004933c6ae147d1dd8bf44" translate="yes" xml:space="preserve">
          <source>A space (a space follows the backslash).</source>
          <target state="translated">공백 (백 슬래시 뒤에 공백).</target>
        </trans-unit>
        <trans-unit id="c8b55b709dc7c7d913907f5546aa211cebd8a8e8" translate="yes" xml:space="preserve">
          <source>A space.</source>
          <target state="translated">우주.</target>
        </trans-unit>
        <trans-unit id="644f31aa2dd167e8d8bb9a4317d4081f4ad357eb" translate="yes" xml:space="preserve">
          <source>A special case is DATE columns with a DATE_FORMAT specified. Any value not matching the format can be regarded as NULL.</source>
          <target state="translated">특별한 경우는 DATE_FORMAT이 지정된 DATE 열입니다. 형식과 일치하지 않는 값은 NULL로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aad8b458008e9024b0e8b04475af712505fa61b" translate="yes" xml:space="preserve">
          <source>A special case is one of columns containing a formatted date. In this case, two formats must be specified:</source>
          <target state="translated">특별한 경우는 형식이 지정된 날짜가 포함 된 열 중 하나입니다. 이 경우 두 가지 형식을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d3768a4d2499b8c01aeeb7dc02ad34ca215397d" translate="yes" xml:space="preserve">
          <source>A special construct used to perform a fulltext search on a fulltext index.</source>
          <target state="translated">전체 텍스트 인덱스에서 전체 텍스트 검색을 수행하는 데 사용되는 특수 구문입니다.</target>
        </trans-unit>
        <trans-unit id="e6d25838bef3b977e0fa899ed5d813b22ae26eb0" translate="yes" xml:space="preserve">
          <source>A special owner (indicated by '0') is reserved for &quot;free&quot; or &quot;not-owned&quot; blocks. Hence, sparse allocation of address blocks is no problem. Also, the 'free' owner is handled no differently than real owners, so there are no extra Stored Routines for such.</source>
          <target state="translated">특수 소유자 ( '0'으로 표시)는 &quot;무료&quot;또는 &quot;비 소유&quot;블록 용으로 예약되어 있습니다. 따라서, 주소 블록의 희소 한 할당은 문제가되지 않습니다. 또한 '무료'소유자는 실제 소유자와 다르게 처리되므로 추가 저장 루틴이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b798a7963b47af9150794774909d3c738908de0" translate="yes" xml:space="preserve">
          <source>A special type of file-based CONNECT tables are &amp;ldquo;inward&amp;rdquo; tables. They are file-based tables whose file name is not specified in the &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement (no &lt;em&gt;file_name&lt;/em&gt; option).</source>
          <target state="translated">특수한 유형의 파일 기반 CONNECT 테이블은 &quot;내부&quot;테이블입니다. &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에 파일 이름이 지정되지 않은 파일 기반 테이블입니다 ( &lt;em&gt;file_name&lt;/em&gt; 옵션 없음 ).</target>
        </trans-unit>
        <trans-unit id="db305c37092e84af807b041e514f4ee146c452f6" translate="yes" xml:space="preserve">
          <source>A special value (such as 0 or '') must be provided for 'free'.</source>
          <target state="translated">'무료'에는 특수 값 (예 : 0 또는 '')을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e73905708110965a57aa63a54cbced9a4962d0b3" translate="yes" xml:space="preserve">
          <source>A specific authentication plugin can be used for an account by providing the &lt;code&gt;IDENTIFIED VIA authentication_plugin&lt;/code&gt; clause with the &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; 문과 함께 &lt;code&gt;IDENTIFIED VIA authentication_plugin&lt;/code&gt; 절을 제공하여 계정에 특정 인증 플러그인을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa7d4905432553bd405c10067c37b43732d17614" translate="yes" xml:space="preserve">
          <source>A specified number of rows both before and after the current row, for example &lt;code&gt;RANGE BETWEEN 6 PRECEDING AND 3 FOLLOWING &lt;/code&gt;</source>
          <target state="translated">현재 행 앞뒤에 지정된 수의 행 (예 : &lt;code&gt;RANGE BETWEEN 6 PRECEDING AND 3 FOLLOWING &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782568605f71b4d58b1edaa26fd5067a344cec8" translate="yes" xml:space="preserve">
          <source>A stop/start/restart request for a process failed.</source>
          <target state="translated">프로세스에 대한 중지 / 시작 / 다시 시작 요청이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e714dd47e927304cad57a976899d74aca0da9d38" translate="yes" xml:space="preserve">
          <source>A stop/start/restart request for the system or a server failed.</source>
          <target state="translated">시스템 또는 서버에 대한 중지 / 시작 / 다시 시작 요청이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e518b580d1403bee61234b595dbeda7b47d72da6" translate="yes" xml:space="preserve">
          <source>A storage engine can allow the user to specify additional attributes per index, field, or table.</source>
          <target state="translated">스토리지 엔진을 사용하면 인덱스, 필드 또는 테이블 당 추가 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db184031b0281e649a6a3ea3b713897beeaf222" translate="yes" xml:space="preserve">
          <source>A storage engine interface to &lt;a href=&quot;http://cassandra.apache.org/&quot;&gt;Cassandra&lt;/a&gt;. Read the original &lt;a href=&quot;https://mariadb.org/announcing-the-cassandra-storage-engine/&quot;&gt;announcement information about CassandraSE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://cassandra.apache.org/&quot;&gt;Cassandra에&lt;/a&gt; 대한 스토리지 엔진 인터페이스 . &lt;a href=&quot;https://mariadb.org/announcing-the-cassandra-storage-engine/&quot;&gt;CassandraSE에 대한&lt;/a&gt; 원본 발표 정보를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="546c2e10900bc5b1d353adb22d1efdb503d426bd" translate="yes" xml:space="preserve">
          <source>A storage engine interface to &lt;a href=&quot;https://cassandra.apache.org/&quot;&gt;Cassandra&lt;/a&gt;. Read the original &lt;a href=&quot;https://mariadb.org/announcing-the-cassandra-storage-engine/&quot;&gt;announcement information about CassandraSE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28026f47a9c5db0e76c224a507ce49854be89db2" translate="yes" xml:space="preserve">
          <source>A storage engine interface to Cassandra.</source>
          <target state="translated">Cassandra에 대한 스토리지 엔진 인터페이스.</target>
        </trans-unit>
        <trans-unit id="9f6a4f885f9d6cf01ff5063e7dde3a11de62149f" translate="yes" xml:space="preserve">
          <source>A storage engine that was included by default until MariaDB 5.2</source>
          <target state="translated">MariaDB 5.2까지 기본적으로 포함 된 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="f88ca8a53bb42bc95eec195ab1b53ef166767af9" translate="yes" xml:space="preserve">
          <source>A stored function is a defined function that is called from within an SQL statement like a regular function, and returns a single value.</source>
          <target state="translated">저장된 함수는 일반 함수와 같은 SQL 문에서 호출되는 정의 된 함수이며 단일 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="52cf75b905d6333e8c6219080b9b49b15cbe9d7b" translate="yes" xml:space="preserve">
          <source>A stored procedure is a routine invoked with a CALL statement. It may have input parameters, output parameters and parameters that are both input parameters and output parameters.</source>
          <target state="translated">스토어드 프로시 저는 CALL 문으로 호출 된 루틴입니다. 입력 매개 변수, 출력 매개 변수 및 입력 매개 변수 및 출력 매개 변수 인 매개 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b152ef456570a955bc7c021efc3c2f963fe87d" translate="yes" xml:space="preserve">
          <source>A string argument is the path to the sub-item to be returned. An integer argument specifies the pretty format value of the file.</source>
          <target state="translated">문자열 인수는 반환 할 하위 항목의 경로입니다. 정수 인수는 파일의 예쁜 형식 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f2f916789b45c056e589cd59cb3770af652e50e4" translate="yes" xml:space="preserve">
          <source>A string describing the error, in this case &lt;code&gt;No database selected&lt;/code&gt;.</source>
          <target state="translated">오류를 설명하는 문자열입니다 (이 경우 &lt;code&gt;No database selected&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="6e4648ac50cd4eb80124b0b840bfddc525396e79" translate="yes" xml:space="preserve">
          <source>A string which identifies a condition's class and subclass</source>
          <target state="translated">조건의 클래스와 서브 클래스를 식별하는 문자열</target>
        </trans-unit>
        <trans-unit id="657134db5b51d58c3ea52d1f30cad4aae5653950" translate="yes" xml:space="preserve">
          <source>A subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; or &lt;code&gt;(?'name'&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt; as in Python. References to capturing subpatterns from other parts of the pattern, can be made by name as well as by number.</source>
          <target state="translated">하위 패턴은 Perl에서와 같이 &lt;code&gt;(?&amp;lt;name&amp;gt;&lt;/code&gt; ... &lt;code&gt;)&lt;/code&gt; 또는 &lt;code&gt;(?'name'&lt;/code&gt; ... &lt;code&gt;)&lt;/code&gt; 또는 Python에서와 같이 &lt;code&gt;(?P&amp;lt;name&amp;gt;&lt;/code&gt; ... &lt;code&gt;)&lt;/code&gt; 의 세 가지 방법 중 하나로 이름을 지정할 수 있습니다 . 패턴의 다른 부분에서 하위 패턴을 캡처하는 것에 대한 참조는 이름과 번호로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd99dae7386fced8d63dddfc2da4f9757078ac96" translate="yes" xml:space="preserve">
          <source>A subquery can refer to a &lt;a href=&quot;../stored-functions/index&quot;&gt;stored function&lt;/a&gt; which modifies data. This is an extension to the SQL standard, but can result in indeterminate outcomes. For example, take:</source>
          <target state="translated">부속 조회 는 데이터를 수정 하는 &lt;a href=&quot;../stored-functions/index&quot;&gt;저장된 함수&lt;/a&gt; 를 참조 할 수 있습니다 . 이는 SQL 표준의 확장이지만 결과가 불확실 할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="68f5be6559cfe04657be6e2c5907769bd807ec72" translate="yes" xml:space="preserve">
          <source>A subquery cannot be used where only a literal is expected, for example &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA INFILE&lt;/a&gt; expects a literal string containing the file name, and LIMIT requires a literal integer.</source>
          <target state="translated">리터럴 만 필요한 경우 하위 쿼리를 사용할 수 없습니다. 예를 들어, &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA INFILE&lt;/a&gt; 은 파일 이름을 포함하는 리터럴 문자열을 기대하며 LIMIT에는 리터럴 정수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49091175a6f1b3c593f4a3ff8c945382103001f0" translate="yes" xml:space="preserve">
          <source>A subquery in the FROM clause is however permitted:</source>
          <target state="translated">그러나 FROM 절의 하위 쿼리는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8813981dcf0bbaafdf7812ca4020b11849ca8a87" translate="yes" xml:space="preserve">
          <source>A subquery is a query nested in another query.</source>
          <target state="translated">하위 쿼리는 다른 쿼리에 중첩 된 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="91b7302f5faed17a396c0ff1bdaafc7f71699925" translate="yes" xml:space="preserve">
          <source>A subquery using &lt;code&gt;IN&lt;/code&gt; can be rewritten with the &lt;code&gt;DISTINCT&lt;/code&gt; keyword, for example:</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 을 사용하는 하위 쿼리 는 &lt;code&gt;DISTINCT&lt;/code&gt; 키워드 로 다시 작성할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8111d13ffc22b2179ad579de4c96883168c563b9" translate="yes" xml:space="preserve">
          <source>A sufficiently random hash (eg MD5) will fold userids into the same bits with a predictable frequency. We need to figure this out, and work backwards. That is, given that X percent of the bits are set, we need a formula that says approximately how many userids were used to get those bits.</source>
          <target state="translated">충분히 임의의 해시 (예 : MD5)는 예측 가능한 빈도로 사용자 비트를 동일한 비트로 접습니다. 우리는 이것을 알아 내고 거꾸로 일해야합니다. 즉, 비트의 X 퍼센트가 설정되면 해당 비트를 얻는 데 대략 몇 개의 사용자 ID가 사용되었는지를 나타내는 공식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="89cac4df0284c3cb814e8d72ed2fb8fa1f1b7f6d" translate="yes" xml:space="preserve">
          <source>A sufficiently recent compiler:</source>
          <target state="translated">충분히 최근의 컴파일러 :</target>
        </trans-unit>
        <trans-unit id="8966047dc662b35143479470802a37a11416594a" translate="yes" xml:space="preserve">
          <source>A suite class can define the following methods:</source>
          <target state="translated">스위트 클래스는 다음 메소드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49bf1eaf66de2a1d479fb2466114305e760ac34" translate="yes" xml:space="preserve">
          <source>A summary table includes two sets of columns:</source>
          <target state="translated">요약 테이블에는 두 개의 열 세트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e5766092cac1d6589a4d41d243cbd2eb7763e154" translate="yes" xml:space="preserve">
          <source>A sync point becomes active when an action is requested for it. To do so, put a line like this in the test case file:</source>
          <target state="translated">작업이 요청되면 동기화 지점이 활성화됩니다. 이렇게하려면 테스트 케이스 파일에 다음과 같은 행을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="8384bb0aefed7228a99d723b99765442f6ef4848" translate="yes" xml:space="preserve">
          <source>A synonym for &quot;TINYINT(1)&quot;. Supported from version 1.2.0 onwards.</source>
          <target state="translated">&quot;TINYINT (1)&quot;의 동의어 버전 1.2.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="942b33f0c87f190f4f563c04f3475dec39837e54" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../mlinefromtext/index&quot;&gt;MLineFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mlinefromtext/index&quot;&gt;MLineFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="b487e211759f6681061af65872aeac29cfc3c26b" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../mlinefromwkb/index&quot;&gt;MLineFromWKB()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mlinefromwkb/index&quot;&gt;MLineFromWKB ()&lt;/a&gt; 의 동의어 .</target>
        </trans-unit>
        <trans-unit id="53f9e8676e9713fc16add0046034799c461766ad" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../mpointfromtext/index&quot;&gt;MPointFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mpointfromtext/index&quot;&gt;MPointFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="7769039deadd2e88d1dc7454ee5bd03572cfbf5b" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../mpointfromwkb/index&quot;&gt;MPointFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mpointfromwkb/index&quot;&gt;MPointFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="0a6fb9a43c0f67d8311f7cb18e890ca9aef3ebe3" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../mpolyfromtext/index&quot;&gt;MPolyFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mpolyfromtext/index&quot;&gt;MPolyFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="fd7abb563e56b84e31da350566d99ae5601d473f" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_area/index&quot;&gt;ST_AREA&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_area/index&quot;&gt;ST_AREA와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="98afc3d4f3ca9839f5136c4876abe742ada774be" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_asbinary/index&quot;&gt;ST_AsBinary()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_asbinary/index&quot;&gt;ST_AsBinary ()와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="1de17275e71a96deeff771b9c14f1b7c1f00ce3b" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_astext/index&quot;&gt;ST_ASTEXT()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_astext/index&quot;&gt;ST_ASTEXT ()와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="65a54b79589c1b45a03f10a0f037f3c9c5c21606" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_astext/index&quot;&gt;ST_AsText()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_astext/index&quot;&gt;ST_AsText ()와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="49e9881bebbc40513fc2badd689d5ebec744cf9f" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_boundary/index&quot;&gt;ST_BOUNDARY&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_boundary/index&quot;&gt;ST_BOUNDARY와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="96e4883cbd2bb9de91e25450479390cafdd9ed5f" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_buffer/index&quot;&gt;ST_BUFFER&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_buffer/index&quot;&gt;에는 ST_Buffer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc03b6a65d93f769195ee62df3a470118a68fde6" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_centroid/index&quot;&gt;ST_CENTROID&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_centroid/index&quot;&gt;ST_CENTROID와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="fb06bc5543c8f21ce90d8c7bb876a3dc3875cba3" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_convexhull/index&quot;&gt;ST_CONVEXHULL&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_convexhull/index&quot;&gt;ST_CONVEXHULL과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="b2e02660e33299b7fdd67dbbc7ae200d9dc6a6c6" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_dimension/index&quot;&gt;ST_DIMENSION&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_dimension/index&quot;&gt;ST_DIMENSION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd343dd498662000cd1b1410f4bd504a12ac3182" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_endpoint/index&quot;&gt;ST_ENDPOINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_endpoint/index&quot;&gt;ST_ENDPOINT와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="ffe494673c174018f246d4d41b7cf6127626ffb5" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_envelope/index&quot;&gt;ST_ENVELOPE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_envelope/index&quot;&gt;ST_ENVELOPE&lt;/a&gt; 의 동의어 .</target>
        </trans-unit>
        <trans-unit id="6820e06fef5cbc633c6618bd41a665459f6b06de" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_exteriorring/index&quot;&gt;ST_ExteriorRing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_exteriorring/index&quot;&gt;ST_ExteriorRing과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="8dfd405120765bfb104191a4abc64e42609bb07b" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geomcollfromtext/index&quot;&gt;ST_GeomCollFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_geomcollfromtext/index&quot;&gt;ST_GeomCollFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="f718136e89f64661693018c80829f025d843f979" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geomcollfromwkb/index&quot;&gt;ST_GeomCollFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_geomcollfromwkb/index&quot;&gt;ST_GeomCollFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="56e67ec9f13b8d8e3e9139b139531e8a458cee0f" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geometryn/index&quot;&gt;ST_GeometryN&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_geometryn/index&quot;&gt;ST_GeometryN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="519b8dbc4eb6b7661f2fa87336f63f1db86f5908" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geometrytype/index&quot;&gt;ST_GeometryType&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_geometrytype/index&quot;&gt;의 : ST_GeometryType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d60e0ab83f21b084121e2b7eab2259c1f4a3b8a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geomfromtext/index&quot;&gt;ST_GeomFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_geomfromtext/index&quot;&gt;ST_GeomFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="ce912002fbf5fc6c60e0c6c5b1e53dd60a373c24" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_geomfromwkb/index&quot;&gt;ST_GeomFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_geomfromwkb/index&quot;&gt;ST_GeomFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="c105101fc5059ddd9632e2ae33ee561f245cdd61" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_interiorringn/index&quot;&gt;ST_InteriorRingN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_interiorringn/index&quot;&gt;ST_InteriorRingN과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="5aa74de6b6008dc49d58abb7f02b97751783d272" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_isclosed/index&quot;&gt;ST_IsClosed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_isclosed/index&quot;&gt;ST_IsClosed와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="18a50907b84c6c2375128b1dcdac9243de26f1a4" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_isempty/index&quot;&gt;ST_IsEmpty&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_isempty/index&quot;&gt;ST_IsEmpty와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="e4c9b1b348b1031a9446f32f6bff2219933cc080" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_isring/index&quot;&gt;ST_IsRing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_isring/index&quot;&gt;ST_IsRing과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="af42f5798421cea7e3a766379e802dff05c4947d" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_issimple/index&quot;&gt;ST_IsSImple&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_issimple/index&quot;&gt;ST_IsSImple과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="76f1fd701e620d62c9118bd3b3d147d4542ab4a5" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_linefromtext/index&quot;&gt;ST_LineFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_linefromtext/index&quot;&gt;ST_LineFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="4f13892188d9990a102b837a62ff8497bc70add3" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_linefromwkb/index&quot;&gt;ST_LineFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_linefromwkb/index&quot;&gt;ST_LineFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="28e78b1cf0f6cf785375f8254face4b0706aa935" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_numgeometries/index&quot;&gt;ST_NumGeometries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_numgeometries/index&quot;&gt;ST_NumGeometries와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="30fcf15f9e1ee4d60c8a3d4858e92e2528952707" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_numinteriorrings/index&quot;&gt;ST_NumInteriorRings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_numinteriorrings/index&quot;&gt;ST_NumInteriorRings&lt;/a&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="6a1956159a7eb3eff99f91e655ef709dcea728ce" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_numpoints/index&quot;&gt;ST_NumPoints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_numpoints/index&quot;&gt;ST_NumPoints와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="c5c6abcdebb180d2361b4eccbfd672c4412f5a6c" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_pointfromtext/index&quot;&gt;ST_PointFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_pointfromtext/index&quot;&gt;ST_PointFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="fd8cc4835a68d73553671499aa9e96a3034925c5" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_pointfromwkb/index&quot;&gt;ST_PointFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_pointfromwkb/index&quot;&gt;ST_PointFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="afd5057c6f9573aad654cbc8cb3955d45dd74ab5" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_pointn/index&quot;&gt;ST_PointN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_pointn/index&quot;&gt;ST_PointN과&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="4017d2d5bcecaffcdb196e32b74a76fdc81ac79e" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_pointonsurface/index&quot;&gt;ST_PointOnSurface&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_pointonsurface/index&quot;&gt;의 : ST_PointOnSurface&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab882f5cf783e8550aa964c07cbe7a89a08568" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_polyfromtext/index&quot;&gt;ST_PolyFromText&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_polyfromtext/index&quot;&gt;ST_PolyFromText와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="023cecd404bab349225998625c9a04ba62ea83f4" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_polyfromwkb/index&quot;&gt;ST_PolyFromWKB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_polyfromwkb/index&quot;&gt;ST_PolyFromWKB와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="574025b0ad16ec20fafe0941008956a61e13605d" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_srid/index&quot;&gt;ST_SRID&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;../st_srid/index&quot;&gt;ST_SRID&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="906ab935b34b04091a72cbfee772ef6a34e7ee90" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_startpoint/index&quot;&gt;ST_STARTPOINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_startpoint/index&quot;&gt;ST_STARTPOINT와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="e3b7023660e151b4d00f57825f7e0801f7f82e9b" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_x/index&quot;&gt;ST_X&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_x/index&quot;&gt;ST_X와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="3d291c0c6d300f84df59d87d2663bb8303096912" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;../st_y/index&quot;&gt;ST_Y&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../st_y/index&quot;&gt;ST_Y와&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="790f7fd8225b584d6c1fde096e42eeb44fbda543" translate="yes" xml:space="preserve">
          <source>A synonym for MLineFromWKB</source>
          <target state="translated">MLineFromWKB의 동의어</target>
        </trans-unit>
        <trans-unit id="bd21fa26dd10c9ec36ca2dbcf90222fc93b9aa38" translate="yes" xml:space="preserve">
          <source>A synonym for MLineFromWKB.</source>
          <target state="translated">MLineFromWKB와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="ca1980a4724fd525b5ebbcf1452b30cbffeb3f6b" translate="yes" xml:space="preserve">
          <source>A tab character.</source>
          <target state="translated">탭 문자.</target>
        </trans-unit>
        <trans-unit id="5c286a8b89a6e6fac1fee2c9e5a2690d4b6d0375" translate="yes" xml:space="preserve">
          <source>A table based on another table existing on the current server with one of its column containing of comma separated values.</source>
          <target state="translated">쉼표로 구분 된 값을 포함하는 열 중 하나를 가진 현재 서버에 존재하는 다른 테이블을 기반으로하는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="b9cc760512948dedd629a0b1b9bbd683b50f2ff8" translate="yes" xml:space="preserve">
          <source>A table based on another table existing on the current server, several columns of the object table containing values that can be grouped in only one column.</source>
          <target state="translated">현재 서버에 존재하는 다른 테이블을 기반으로하는 테이블로서, 하나의 열에 만 그룹화 할 수있는 값을 포함하는 오브젝트 테이블의 여러 열입니다.</target>
        </trans-unit>
        <trans-unit id="c4f36283b8b28570edf8dc97305dfe273d71d756" translate="yes" xml:space="preserve">
          <source>A table based on another table existing on the current server.</source>
          <target state="translated">현재 서버에 존재하는 다른 테이블을 기반으로하는 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="6fe9abc5d245588a41b8fc1604421c4f56e0a4f4" translate="yes" xml:space="preserve">
          <source>A table can be created in the front end only by using a &amp;lsquo;schema sync only&amp;rsquo; comment. This could be useful when the table has been created on one user module, and needs to be synced to others.</source>
          <target state="translated">'스키마 동기화 전용'주석을 사용하여 프런트 엔드에서만 테이블을 만들 수 있습니다. 이는 하나의 사용자 모듈에서 테이블을 작성하고 다른 사용자 모듈과 동기화해야 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b851685d4936c5e5bbb125e5c371d9e7b98cc3" translate="yes" xml:space="preserve">
          <source>A table can be created on this file as:</source>
          <target state="translated">이 파일에서 다음과 같이 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10d501fdc58ce4ab9110405ab5689f1977869fa8" translate="yes" xml:space="preserve">
          <source>A table can only be partitioned if the storage engine supports partitioning.</source>
          <target state="translated">스토리지 엔진이 파티셔닝을 지원하는 경우에만 테이블을 파티셔닝 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6caac35a52db8832b6f9a7f900d3049986a439b5" translate="yes" xml:space="preserve">
          <source>A table has been created from a master dump and is now being opened.</source>
          <target state="translated">마스터 덤프에서 테이블이 작성되었으며 현재 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cff2473a3adfb1f457eb84d1c9da6d4e53a88e8a" translate="yes" xml:space="preserve">
          <source>A table in the &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; database is being built.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; 의 테이블 데이터베이스 작성 중입니다.</target>
        </trans-unit>
        <trans-unit id="d1cbb80e1ab0eb84418289cd2be9e1b699d53f54" translate="yes" xml:space="preserve">
          <source>A table must have at least 1 column</source>
          <target state="translated">테이블에는 적어도 하나의 열이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="3b917aa77e535e90439e9ef79bcc64bb8458844e" translate="yes" xml:space="preserve">
          <source>A table of type &lt;code&gt;DBF&lt;/code&gt; is physically a dBASE III or IV formatted file (used by many products like dBASE, Xbase, FoxPro etc.). This format is similar to the &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt; type format with in addition a prefix giving the characteristics of the file, describing in particular all the fields (columns) of the table.</source>
          <target state="translated">&lt;code&gt;DBF&lt;/code&gt; 유형의 테이블 은 실제로 dBASE III 또는 IV 형식의 파일입니다 (dBASE, Xbase, FoxPro 등의 많은 제품에서 사용). 이 형식은 특히 테이블의 모든 필드 (열)를 설명하는 파일 특성을 제공하는 접두사와 함께 &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt; 형식 형식과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="f257c4aad2cb463a84b1035904585ff4181789aa" translate="yes" xml:space="preserve">
          <source>A table of type BIN is physically a binary file in which each row is a logical record of fixed length&lt;sup id=&quot;_ref-0&quot;&gt;[&lt;a href=&quot;#_note-0&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;. Within a record, column fields are of a fixed offset and length as with &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX tables&lt;/a&gt;. Specific to BIN tables is that numerical values are internally encoded using native platform representation, so no conversion is needed to handle numerical values in expressions.</source>
          <target state="translated">BIN 유형의 테이블은 물리적으로 각 행이 고정 길이의 논리적 레코드 &lt;sup id=&quot;_ref-0&quot;&gt;[ &lt;a href=&quot;#_note-0&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt; 인 이진 파일입니다 . 레코드 내에서 열 필드는 &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX 테이블에서&lt;/a&gt; 와 같이 고정 오프셋 및 길이 입니다. BIN 테이블에는 고유 한 플랫폼 표현을 사용하여 숫자 값이 내부적으로 인코딩되므로 식에서 숫자 값을 처리하기 위해 변환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="89b7e8473df2fa8e33f18bdb229f3337f6685fbc" translate="yes" xml:space="preserve">
          <source>A table of type DIR returns a list of file name and description as a result set. To create a DIR table, use a Create Table statement such as:</source>
          <target state="translated">DIR 유형의 테이블은 파일 이름 및 설명 목록을 결과 집합으로 반환합니다. DIR 테이블을 작성하려면 다음과 같은 테이블 작성 명령문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc97ced2bba81dc996462a97c5edaaa6d42c197" translate="yes" xml:space="preserve">
          <source>A table partitioning overview</source>
          <target state="translated">테이블 파티셔닝 개요</target>
        </trans-unit>
        <trans-unit id="96fc30a4d397deda6582ccbd0d9cbe26713f982e" translate="yes" xml:space="preserve">
          <source>A table reference is also known as a join expression.</source>
          <target state="translated">테이블 참조는 조인 식이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="6adb722a9ff9124a8f73a720b09f664fee4d1c73" translate="yes" xml:space="preserve">
          <source>A table using the &lt;code&gt;ARCHIVE&lt;/code&gt; storage engine is stored in two files on disk. There's a table definition file with an extension of .frm, and a data file with the extension .ARZ. At times during optimization, a .ARN file will appear.</source>
          <target state="translated">&lt;code&gt;ARCHIVE&lt;/code&gt; 를 사용하는 테이블 스토리지 엔진을 은 디스크의 두 파일에 저장됩니다. 확장자가 .frm 인 테이블 정의 파일과 확장자가 .ARZ 인 데이터 파일이 있습니다. 최적화 중에 때때로 .ARN 파일이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cdde633795579aa75ffb4c2a9b5434000fa93727" translate="yes" xml:space="preserve">
          <source>A table using the &lt;code&gt;BLACKHOLE&lt;/code&gt; storage engine consists of a single .frm table format file, but no associated data or index files.</source>
          <target state="translated">&lt;code&gt;BLACKHOLE&lt;/code&gt; 스토리지 엔진을 사용하는 테이블 은 단일 .frm 테이블 형식 파일로 구성되지만 관련 데이터 나 인덱스 파일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5b8e098385e828d1f7ae5584ce9de8e225dba88" translate="yes" xml:space="preserve">
          <source>A table with a numeric table check constraint and with a default check constraint name:</source>
          <target state="translated">숫자 테이블 점검 제한 조건과 기본 점검 제한 조건 이름이있는 테이블 :</target>
        </trans-unit>
        <trans-unit id="9876ac52ef777173e9557e2a17a9a2ee42c4c953" translate="yes" xml:space="preserve">
          <source>A table's index is too big to be cached, but the index for one partition is cacheable, and</source>
          <target state="translated">테이블의 인덱스가 캐시하기에는 너무 크지 만 한 파티션의 인덱스는 캐시 가능하며</target>
        </trans-unit>
        <trans-unit id="31b24c454afa15fd02bbf9ae547749d1a85871d7" translate="yes" xml:space="preserve">
          <source>A table's tablespace is tagged with the lowest InnoDB file format that supports the table's &lt;a href=&quot;../xtradbinnodb-storage-formats/index&quot;&gt;row format&lt;/a&gt;. So, even if the &lt;code&gt;Barracuda&lt;/code&gt; file format is enabled, tables that use the &lt;code&gt;COMPACT&lt;/code&gt; or &lt;code&gt;REDUNDANT&lt;/code&gt; row formats will be tagged with the &lt;code&gt;Antelope&lt;/code&gt; file format in the &lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;information_schema.INNODB_SYS_TABLES&lt;/a&gt; table.</source>
          <target state="translated">테이블의 테이블 스페이스는 테이블의 &lt;a href=&quot;../xtradbinnodb-storage-formats/index&quot;&gt;행 형식&lt;/a&gt; 을 지원하는 가장 낮은 InnoDB 파일 형식으로 태그가 지정 됩니다 . 따라서 &lt;code&gt;Barracuda&lt;/code&gt; 파일 형식이 사용 가능하더라도 &lt;code&gt;COMPACT&lt;/code&gt; 또는 &lt;code&gt;REDUNDANT&lt;/code&gt; 행 형식 을 사용하는 테이블 은 &lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;information_schema&lt;/a&gt; 에서 &lt;code&gt;Antelope&lt;/code&gt; 파일 형식 으로 태그됩니다. 테이블 테이블 .</target>
        </trans-unit>
        <trans-unit id="6a97be09be116c30fd76e16a2d1446071b60f7b4" translate="yes" xml:space="preserve">
          <source>A table's tablespace is tagged with the lowest InnoDB file format that supports the table's row format. So, even if the &lt;code&gt;Barracuda&lt;/code&gt; file format is enabled, tables that use the &lt;code&gt;COMPACT&lt;/code&gt; or &lt;code&gt;REDUNDANT&lt;/code&gt; row formats will be tagged with the &lt;code&gt;Antelope&lt;/code&gt; file format in the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;information_schema.INNODB_SYS_TABLES&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">테이블의 테이블 스페이스는 테이블의 행 형식을 지원하는 가장 낮은 InnoDB 파일 형식으로 태그가 지정됩니다. 따라서 &lt;code&gt;Barracuda&lt;/code&gt; 파일 형식이 사용 가능하더라도 &lt;code&gt;COMPACT&lt;/code&gt; 또는 &lt;code&gt;REDUNDANT&lt;/code&gt; 행 형식 을 사용하는 테이블 은 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;information_schema.INNODB_SYS_TABLES&lt;/a&gt;&lt;/code&gt; 테이블 에서 &lt;code&gt;Antelope&lt;/code&gt; 파일 형식 으로 태그됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe175ccdfe1eb3af1a58394c0ba44373a8484262" translate="yes" xml:space="preserve">
          <source>A tarball that contains the &lt;code&gt;.deb&lt;/code&gt; packages can be downloaded from the following URL:</source>
          <target state="translated">&lt;code&gt;.deb&lt;/code&gt; 패키지 가 포함 된 tarball 은 다음 URL에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40b5e4abc084e8be0389056791639dd8febaff2" translate="yes" xml:space="preserve">
          <source>A temporary table is created to hold the result. This typically happens if you are using &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">결과를 보유하기 위해 임시 테이블이 작성됩니다. 이것은 일반적으로 &lt;code&gt;GROUP BY&lt;/code&gt; , &lt;code&gt;DISTINCT&lt;/code&gt; 또는 &lt;code&gt;ORDER BY&lt;/code&gt; 를 사용하는 경우 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="5eb1b202138432b2026916957b1755c2eedefecd" translate="yes" xml:space="preserve">
          <source>A temporary table will always be used if the fields which will be sorted are not from the first table in the &lt;a href=&quot;../join/index&quot;&gt;JOIN&lt;/a&gt; order.</source>
          <target state="translated">정렬 될 필드가 &lt;a href=&quot;../join/index&quot;&gt;JOIN&lt;/a&gt; 순서 의 첫 번째 테이블이 아닌 경우 임시 테이블이 항상 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="eec4c2cc68e2f70edf9590da113f2385f31b6321" translate="yes" xml:space="preserve">
          <source>A temporary table with a SEQUENCE-like name can always be created and used:</source>
          <target state="translated">SEQUENCE와 같은 이름을 가진 임시 테이블은 항상 작성하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91af0dd1da86833b1f662c34a0898db46da94bb2" translate="yes" xml:space="preserve">
          <source>A test file can include other files (with the &lt;code&gt;source&lt;/code&gt; command). These included files can have any name and may be placed anywhere, but customarily they have a &lt;code&gt;.inc&lt;/code&gt; extension and are located either in the suite directory or in the &lt;code&gt;inc&lt;/code&gt; or &lt;code&gt;include&lt;/code&gt; subdirectories (for example, &lt;code&gt;mysql-test/suite/handler/init.inc&lt;/code&gt; or &lt;code&gt;mysql-test/include/start_slave.inc&lt;/code&gt;).</source>
          <target state="translated">테스트 파일은 다른 파일을 포함 할 수 있습니다 ( &lt;code&gt;source&lt;/code&gt; 명령 사용). 이 포함 된 파일은 어떤 이름을 가질 수 있습니다 어디서나 배치 될 수 있지만, 통상적으로 그들은이 &lt;code&gt;.inc&lt;/code&gt; 의 확장과 스위트 디렉토리 나에 하나 있습니다 &lt;code&gt;inc&lt;/code&gt; 또는 &lt;code&gt;include&lt;/code&gt; 예를 들어, (하위 디렉토리를 &lt;code&gt;mysql-test/suite/handler/init.inc&lt;/code&gt; 또는 &lt;code&gt;mysql-test/include/start_slave.inc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="71ae0c4668a9d63b05bca23a940c929e0026155f" translate="yes" xml:space="preserve">
          <source>A third way is to INSERT or LOAD into a Staging table, then</source>
          <target state="translated">세 번째 방법은 준비 테이블에 삽입 또는로드 한 다음</target>
        </trans-unit>
        <trans-unit id="465eb6281a6e073c2f38851d9530cbfa657cf1ab" translate="yes" xml:space="preserve">
          <source>A thread can have any of the following &lt;code&gt;COMMAND&lt;/code&gt; values (displayed by the &lt;code&gt;COMMAND&lt;/code&gt; field listed by the &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; statement or in the &lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;Information Schema PROCESSLIST Table&lt;/a&gt;, as well as the &lt;code&gt;PROCESSLIST_COMMAND&lt;/code&gt; value listed in the &lt;a href=&quot;../performance-schema-threads-table/index&quot;&gt;Performance Schema threads Table&lt;/a&gt;). These indicate the nature of the thread's activity.</source>
          <target state="translated">스레드는 다음 &lt;code&gt;COMMAND&lt;/code&gt; 값 ( &lt;a href=&quot;../performance-schema-threads-table/index&quot;&gt;성능 스키마 스레드 테이블에&lt;/a&gt; 나열된 &lt;code&gt;PROCESSLIST_COMMAND&lt;/code&gt; 값 뿐만 아니라 &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; 문 또는 &lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;정보 스키마 PROCESSLIST 테이블에&lt;/a&gt; 나열된 &lt;code&gt;COMMAND&lt;/code&gt; 필드로 표시됨)을 가질 수 있습니다 . 스레드 활동의 특성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ec95f28d73d0cb990ffc9f205f6dfbb194531f3" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;listener thread&lt;/strong&gt; can create a new &lt;strong&gt;worker thread&lt;/strong&gt; when it has more client connection requests to distribute, but no pre-existing &lt;strong&gt;worker threads&lt;/strong&gt; are available to work on the requests. This can help to ensure that the thread group always has enough threads to keep one &lt;strong&gt;worker thread&lt;/strong&gt; active at a time.</source>
          <target state="translated">스레드 그룹의 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 는 분배 할 클라이언트 연결 요청이 더 많을 때 새 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; 작성할 수 있지만 요청에 대한 기존 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 를 사용할 수 없습니다. 이렇게하면 스레드 그룹에 항상 한 번에 하나의 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; 활성 상태로 유지할 수있는 충분한 스레드가 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54679ff224232db64a84c5a13af5022540b930cd" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;listener thread&lt;/strong&gt; creates a new &lt;strong&gt;worker thread&lt;/strong&gt; if all of the following conditions are met:</source>
          <target state="translated">다음 조건이 모두 충족되면 스레드 그룹의 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 가 새 &lt;strong&gt;작업자 &lt;/strong&gt;&lt;strong&gt;스레드를&lt;/strong&gt; 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="2fc29c13d56ad8d7b1901833e58bc8a678b2a96a" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;listener thread&lt;/strong&gt; listens for I/O events and distributes work to the &lt;strong&gt;worker threads&lt;/strong&gt;. If it detects that there is a request that needs to be worked on, then it can wake up a sleeping &lt;strong&gt;worker thread&lt;/strong&gt; in the thread group, if any exist. If the &lt;strong&gt;listener thread&lt;/strong&gt; is the only thread in the thread group, then it can also create a new &lt;strong&gt;worker thread&lt;/strong&gt;. If there is only one request to handle, and if the &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_dedicated_listener&quot;&gt;thread_pool_dedicated_listener&lt;/a&gt;&lt;/code&gt; system variable is not enabled, then the &lt;strong&gt;listener thread&lt;/strong&gt; can also become a &lt;strong&gt;worker thread&lt;/strong&gt; and handle the request itself. This helps decrease the overhead that may be introduced by excessively waking up sleeping &lt;strong&gt;worker threads&lt;/strong&gt; and excessively creating new &lt;strong&gt;worker threads&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹의 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 는 I / O 이벤트를 청취하고 작업을 &lt;strong&gt;작업자 스레드에&lt;/strong&gt; 분배 &lt;strong&gt;합니다&lt;/strong&gt; . 작업이 필요한 요청이 있음을 발견 하면 스레드 그룹에 대기중인 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가있을 경우 깨울 수 있습니다. 는 IF &lt;strong&gt;수신기 스레드가&lt;/strong&gt; 스레드 그룹의 유일한 스레드이며, 그것은 또한 새로운 만들 수 있습니다 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; . 처리 요청이 하나 &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_dedicated_listener&quot;&gt;thread_pool_dedicated_listener&lt;/a&gt;&lt;/code&gt; 시스템 변수가 사용 가능하지 않으면 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 도 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 될 수 있습니다.&lt;strong&gt;&lt;/strong&gt;요청 자체를 처리하십시오. 이렇게하면 휴면중인 하여 발생할 수있는 오버 헤드를 줄일 수 있습니다&lt;strong&gt;작업자 스레드&lt;/strong&gt; 과도하게 새로운 만드는 &lt;strong&gt;작업자 스레드&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eb7d7b44c59b567444099d0a8f1084c2e9f869ac" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;worker thread&lt;/strong&gt; can create a new &lt;strong&gt;worker thread&lt;/strong&gt; when the thread has to wait on something, and the thread group has more client connection requests queued, but no pre-existing &lt;strong&gt;worker threads&lt;/strong&gt; are available to work on them. This can help to ensure that the thread group always has enough threads to keep one &lt;strong&gt;worker thread&lt;/strong&gt; active at a time. For most workloads, this tends to be the primary mechanism that creates new &lt;strong&gt;worker threads&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹의 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 는 스레드가 무언가를 기다려야 할 때 새 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; 작성할 수 있으며 스레드 그룹에 더 많은 클라이언트 연결 요청이 대기 중이지만 기존 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 작동하지 않습니다. 이렇게하면 스레드 그룹에 항상 한 번에 하나의 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; 활성 상태로 유지할 수있는 충분한 스레드가 있는지 확인할 수 있습니다 . 대부분의 워크로드에서 이는 새 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 를 작성하는 기본 메커니즘 인 경향이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eefa3bd57a74fbeaeb27aa2727d3df706350565" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;worker thread&lt;/strong&gt; creates a new thread if all of the following conditions are met:</source>
          <target state="translated">다음 조건이 모두 충족되면 스레드 그룹의 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 새 &lt;strong&gt;스레드를&lt;/strong&gt; 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ed7058b7d12a2dca3f9483fd3d15ac62c040060f" translate="yes" xml:space="preserve">
          <source>A thread group's &lt;strong&gt;worker threads&lt;/strong&gt; actually perform work on behalf of client connections. A thread group can have many &lt;strong&gt;worker threads&lt;/strong&gt;, but usually, only one will be actively running at a time. This is not always the case. For example, the thread group can become &lt;em&gt;oversubscribed&lt;/em&gt; if the thread pool's &lt;strong&gt;timer thread&lt;/strong&gt; detects that the thread group is &lt;em&gt;stalled&lt;/em&gt;. This is explained more in the sections below.</source>
          <target state="translated">스레드 그룹의 &lt;strong&gt;작업자 스레드는&lt;/strong&gt; 실제로 클라이언트 연결 대신 작업을 수행합니다. 스레드 그룹에는 많은 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가있을 수 있지만 일반적으로 한 번에 하나의 &lt;strong&gt;스레드&lt;/strong&gt; 만 실행됩니다. 항상 그런 것은 아닙니다. 예를 들어, 스레드 풀의 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 가 스레드 그룹이 &lt;em&gt;정지&lt;/em&gt; 되었음을 감지하면 스레드 그룹이 &lt;em&gt;초과 구독&lt;/em&gt; 될 수 있습니다 . 이에 대해서는 아래 섹션에서 자세히 설명합니다.&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7a9329617602749a88282905c8f60501c7dc91e" translate="yes" xml:space="preserve">
          <source>A time. The range is &lt;code&gt;'-838:59:59.999999'&lt;/code&gt; to &lt;code&gt;'838:59:59.999999'&lt;/code&gt;. &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;Microsecond precision&lt;/a&gt; can be from 0-6; if not specified 0 is used. Microseconds have been available since &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;.</source>
          <target state="translated">시간. 범위는 &lt;code&gt;'-838:59:59.999999'&lt;/code&gt; ~ &lt;code&gt;'838:59:59.999999'&lt;/code&gt; 입니다. &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;마이크로 초 정밀도&lt;/a&gt; 는 0-6 일 수 있습니다. 지정하지 않으면 0이 사용됩니다. &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 이후 마이크로 초가 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a8401e92cb477b943b03b30f242d45789a038bce" translate="yes" xml:space="preserve">
          <source>A timestamp in the format &lt;code&gt;YYYY-MM-DD HH:MM:SS.ffffff&lt;/code&gt;.</source>
          <target state="translated">형식 소인 &lt;code&gt;YYYY-MM-DD HH:MM:SS.ffffff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf335f6a81c458db8109e5bf2357450e0f925d11" translate="yes" xml:space="preserve">
          <source>A timestamp. The range is '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC. TIMESTAMP values are stored as the number of seconds since the epoch ('1970-01-01 00:00:00' UTC). A TIMESTAMP cannot represent the value '1970-01-01 00:00:00' because that is equivalent to 0 seconds from the epoch and the value 0 is reserved for representing '0000-00-00 00:00:00', the &quot;zero&quot; TIMESTAMP value.</source>
          <target state="translated">타임 스탬프 범위는 '1970-01-01 00:00:01'UTC에서 '2038-01-19 03:14:07'UTC입니다. TIMESTAMP 값은 에포크 ( '1970-01-01 00:00:00'UTC) 이후 초 수로 저장됩니다. TIMESTAMP는 '1970-01-01 00:00:00'값을 나타낼 수 없습니다. 이는 에포크에서 0 초에 해당하고 값 0은 '0000-00-00 00:00:00'을 나타 내기 위해 예약되어 있기 때문입니다. &quot;제로&quot;TIMESTAMP 값.</target>
        </trans-unit>
        <trans-unit id="d97841aac634cfab1bb324c59dc1829f4358baa9" translate="yes" xml:space="preserve">
          <source>A tool for comparison and synchronization of DDL differences between database objects.</source>
          <target state="translated">데이터베이스 개체 간의 DDL 차이점을 비교하고 동기화하기위한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="c064589e99b38d4d464bdbbd8f131b1f956d1b03" translate="yes" xml:space="preserve">
          <source>A tool for comparison and synchronization of data between databases.</source>
          <target state="translated">데이터베이스 간의 데이터 비교 및 ​​동기화를위한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="2920bb7e28fa9d0160e3077de61bab9a283fbd53" translate="yes" xml:space="preserve">
          <source>A tool for displaying information on MyISAM FULLTEXT indexes.</source>
          <target state="translated">MyISAM FULLTEXT 색인에 대한 정보를 표시하는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="a4dc65c390f7ed993a1e438f3e0c768a068a1d82" translate="yes" xml:space="preserve">
          <source>A tool for generation of large volumes of meaningful test table data.</source>
          <target state="translated">의미있는 테스트 테이블 데이터를 대량으로 생성하기위한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="ff173973ae60c9e7bcececc13587cd3f5b0bd555" translate="yes" xml:space="preserve">
          <source>A tool for visual query creation without code typing.</source>
          <target state="translated">코드 입력없이 시각적 쿼리를 작성하는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="d57632854f0ca38995ee53d51f56fdc3c8e4ffed" translate="yes" xml:space="preserve">
          <source>A tool that backs up MariaDB by taking a snapshot of a file system, SAN, or some other kind of storage device could use each &lt;code&gt;BACKUP STAGE&lt;/code&gt; command in the following way:</source>
          <target state="translated">파일 시스템, SAN 또는 다른 종류의 저장 장치의 스냅 샷을 만들어 MariaDB를 백업하는 도구 는 다음과 같은 방식으로 각 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ed12cae2f563b5926fadd99a83ebdd9bc2d591b" translate="yes" xml:space="preserve">
          <source>A transaction acquires a &lt;a href=&quot;../metadata-locking/index&quot;&gt;metadata lock&lt;/a&gt; on every table it accesses to prevent other connections from altering their structure. The lock is released at the end of the transaction. This happens even with non-transactional storage engines (like &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;MEMORY&lt;/a&gt; or &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt;), so it makes sense to use transactions with non-transactional tables.</source>
          <target state="translated">트랜잭션은 액세스하는 모든 테이블 에서 &lt;a href=&quot;../metadata-locking/index&quot;&gt;메타 데이터 잠금&lt;/a&gt; 을 획득하여 다른 연결이 구조를 변경하지 못하도록합니다. 트랜잭션이 끝나면 잠금이 해제됩니다. 이는 트랜잭션이 아닌 스토리지 엔진 (예 : &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;MEMORY&lt;/a&gt; 또는 &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; )에서도 발생하므로 트랜잭션이 아닌 테이블의 트랜잭션을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ee68ce489def82afd1a95b47e95e6ffd2bb42fbc" translate="yes" xml:space="preserve">
          <source>A transaction is being rolled back.</source>
          <target state="translated">트랜잭션이 롤백되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64ae04f52852243c31653d405d15a2091c9a85f" translate="yes" xml:space="preserve">
          <source>A transaction that affects tables of both types can ROLLBACK InnoDB changes, but will leave MyISAM changes intact.</source>
          <target state="translated">두 유형의 테이블에 영향을 미치는 트랜잭션은 InnoDB 변경을 롤백 할 수 있지만 MyISAM 변경은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58803461d295ba5ce1f2e22816f891c1e17b0490" translate="yes" xml:space="preserve">
          <source>A trigger is a set of statements that run when an event occurs on a table.</source>
          <target state="translated">트리거는 이벤트가 테이블에서 발생할 때 실행되는 명령문 세트입니다.</target>
        </trans-unit>
        <trans-unit id="9234ec7b122cb23fb06d31dace51898341509217" translate="yes" xml:space="preserve">
          <source>A trigger, as its name suggests, is a set of statements that run, or are triggered, when an event occurs on a table.</source>
          <target state="translated">이름에서 알 수 있듯이 트리거는 이벤트가 테이블에서 발생할 때 실행되거나 트리거되는 명령문 세트입니다.</target>
        </trans-unit>
        <trans-unit id="45f94f83421c82165c0dda13741462eb6cb12f93" translate="yes" xml:space="preserve">
          <source>A tutorial for the Kafka adapter for ingesting Avro formatted data can be found in the &lt;a href=&quot;../kafka-to-columnstore-data-adapter/index&quot;&gt;kafka-to-columnstore-data-adapter&lt;/a&gt; document.</source>
          <target state="translated">Avro 형식의 데이터를 수집하기위한 Kafka 어댑터에 대한 자습서는 &lt;a href=&quot;../kafka-to-columnstore-data-adapter/index&quot;&gt;kafka-to-columnstore-data-adapter&lt;/a&gt; 문서 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61f53f61b7250ce6931b84dff427bb608f84b9d6" translate="yes" xml:space="preserve">
          <source>A tutorial on creating and using views.</source>
          <target state="translated">뷰 작성 및 사용에 대한 튜토리얼.</target>
        </trans-unit>
        <trans-unit id="ebb83b07589763c8a6b148295b36e385e365d724" translate="yes" xml:space="preserve">
          <source>A typical Spider deployment has a shared-nothing clustered architecture. The system works with any inexpensive hardware, and with a minimum of specific requirements for hardware or software. It consists of a set of computers, with one or more MariaDB processes known as nodes.</source>
          <target state="translated">일반적인 Spider 배포에는 클러스터가없는 공유 아키텍처가 있습니다. 이 시스템은 저렴한 하드웨어 및 하드웨어 또는 소프트웨어에 대한 최소 특정 요구 사항과 함께 작동합니다. 노드라고하는 하나 이상의 MariaDB 프로세스가있는 컴퓨터 세트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b51f9625499eb8d0444614588fe8f0f7b63c65fa" translate="yes" xml:space="preserve">
          <source>A typical TokuDB section looks like the following:</source>
          <target state="translated">일반적인 TokuDB 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a5c2c8b39937b28a78aff4a409c7661cd560eed" translate="yes" xml:space="preserve">
          <source>A typical compilation used by a developer would be:</source>
          <target state="translated">개발자가 사용하는 일반적인 컴파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35bc26bb18d25c129c97a4ff8bc6faedd3568e65" translate="yes" xml:space="preserve">
          <source>A typical scenario of when this is useful is if you have set up a new version of MariaDB as a slave, for example for testing, and want to upgrade your master to the new version.</source>
          <target state="translated">이것이 유용한 경우의 일반적인 시나리오는 테스트를 위해 새 버전의 MariaDB를 슬레이브로 설정하고 마스터를 새 버전으로 업그레이드하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="dfa3a65c95b38ae472b611f76d996a68b46b84bc" translate="yes" xml:space="preserve">
          <source>A typical synchronization pattern</source>
          <target state="translated">전형적인 동기화 패턴</target>
        </trans-unit>
        <trans-unit id="1a8a76eb8f55aa716a331457cb33f71f2f881d48" translate="yes" xml:space="preserve">
          <source>A typical usage example is &lt;code&gt;include/have_blackhole.inc&lt;/code&gt; and &lt;code&gt;include/have_blackhole.opt&lt;/code&gt;. The latter contains the necessary command-line options to load the Blackhole storage engine, while the former verifies that the engine was really loaded. Any test that needs the Blackhole engine needs only to start from &lt;code&gt;source include/have_blackhole.inc;&lt;/code&gt; and the engine will be automatically loaded for the test.</source>
          <target state="translated">일반적인 사용 예는 &lt;code&gt;include/have_blackhole.inc&lt;/code&gt; 및 &lt;code&gt;include/have_blackhole.opt&lt;/code&gt; 입니다. 후자는 Blackhole 스토리지 엔진을로드하는 데 필요한 명령 줄 옵션을 포함하고 전자는 엔진이 실제로로드되었는지 확인합니다. Blackhole 엔진이 필요한 모든 테스트는 &lt;code&gt;source include/have_blackhole.inc;&lt;/code&gt; 에서만 시작하면 됩니다. 테스트를 위해 엔진이 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="426342425d2aa58b3cb3e1afd6e5ac05b9ca0cb7" translate="yes" xml:space="preserve">
          <source>A typical use case is when one needs to store items that may have many different attributes (like size, color, weight, etc), and the set of possible attributes is very large and/or unknown in advance. In that case, attributes can be put into dynamic columns.</source>
          <target state="translated">일반적인 유스 케이스는 크기, 색상, 무게 등과 같은 다양한 속성을 가질 수있는 항목을 저장해야하고 가능한 속성 세트가 매우 크고 사전에 알 수없는 경우입니다. 이 경우 속성을 동적 열에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d16e5b7b73c78374cf54488d3075487081068c" translate="yes" xml:space="preserve">
          <source>A typical use case is when we want to partition a table whose rows refer to a moment or period in time; for example commercial transactions, blog posts, or events of some kind. We can partition the table by year, to keep all recent data in one partition and distribute historical data in big partitions that are stored on slower disks. Or, if our queries always read rows which refer to the same month or week, we can partition the table by month or year week (in this case, historical data and recent data will be stored together).</source>
          <target state="translated">일반적인 사용 사례는 행이 특정 시점 또는 시간을 나타내는 테이블을 분할하려는 경우입니다. 예를 들어 상업 거래, 블로그 게시물 또는 어떤 종류의 이벤트. 연도별로 테이블을 분할하여 모든 최근 데이터를 하나의 파티션에 유지하고 기록 데이터를 느린 디스크에 저장된 큰 파티션으로 분배 할 수 있습니다. 또는 쿼리에서 항상 같은 달 또는 주를 나타내는 행을 읽는 경우 테이블을 월 또는 연도별로 분할 할 수 있습니다 (이 경우 기록 데이터와 최근 데이터가 함께 저장 됨).</target>
        </trans-unit>
        <trans-unit id="4e7b586506892aa565ac5c737da663bdbc89d7a9" translate="yes" xml:space="preserve">
          <source>A unique index identifier.</source>
          <target state="translated">고유 한 인덱스 식별자.</target>
        </trans-unit>
        <trans-unit id="1a6b11fb6fd765eb462673c0951d7e33032818dc" translate="yes" xml:space="preserve">
          <source>A unique index is used to find the rows. This is the best possible plan to find the row.</source>
          <target state="translated">고유 색인은 행을 찾는 데 사용됩니다. 이것은 행을 찾는 가장 좋은 계획입니다.</target>
        </trans-unit>
        <trans-unit id="08d8d657eedc04161c3e73ee01cd09e9233848d6" translate="yes" xml:space="preserve">
          <source>A unique thread identifier.</source>
          <target state="translated">고유 한 스레드 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="e7c9b9a424faf0bb59928a9608934925ac3c3e4e" translate="yes" xml:space="preserve">
          <source>A useful option to set is &lt;code&gt;pc.wait_prim=no&lt;/code&gt; to ensure the server will start running even if it can't determine a primary node. This is useful if all members go down at the same time.</source>
          <target state="translated">설정하는 유용한 옵션은 &lt;code&gt;pc.wait_prim=no&lt;/code&gt; 입니다. 기본 노드를 결정할 수없는 경우에도 서버가 실행되기 시작합니다. 모든 멤버가 동시에 다운되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4bd90e4e779491aa2f5f532a6ca8bc6929e05924" translate="yes" xml:space="preserve">
          <source>A user account can grant the &lt;code&gt;PROXY&lt;/code&gt; privilege for any other user account if the granter has the &lt;code&gt;PROXY&lt;/code&gt; privilege for the &lt;code&gt;''@'%'&lt;/code&gt; anonymous user account, like this:</source>
          <target state="translated">권한 부여자가 다음 과 같이 &lt;code&gt;''@'%'&lt;/code&gt; 익명 사용자 계정에 대한 &lt;code&gt;PROXY&lt;/code&gt; 권한을 가진 경우 사용자 계정은 다른 사용자 계정에 대해 &lt;code&gt;PROXY&lt;/code&gt; 권한을 부여 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a6a35fe7062df68ba3b018357916f6dec9a70b3" translate="yes" xml:space="preserve">
          <source>A user account can have different definitions depending on what host the user account is logging in from. Therefore, it is possible to have different TLS requirements for the same username for different hosts. For example:</source>
          <target state="translated">사용자 계정은 사용자 계정이 로그인 한 호스트에 따라 다른 정의를 가질 수 있습니다. 따라서 다른 호스트에 대해 동일한 사용자 이름에 대해 다른 TLS 요구 사항을 가질 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51e77e736f5b567e775e8412681ee5954e84479f" translate="yes" xml:space="preserve">
          <source>A user account can only grant the &lt;code&gt;PROXY&lt;/code&gt; privilege for a specific user account if the granter also has the &lt;code&gt;PROXY&lt;/code&gt; privilege for that specific user account, and if that privilege is defined &lt;code&gt;WITH GRANT OPTION&lt;/code&gt;. For example, the following example fails because the granter does not have the &lt;code&gt;PROXY&lt;/code&gt; privilege for that specific user account at all:</source>
          <target state="translated">권한 부 여자에게 해당 특정 사용자 계정에 대한 &lt;code&gt;PROXY&lt;/code&gt; 권한이 있고 해당 권한이 &lt;code&gt;WITH GRANT OPTION&lt;/code&gt; 으로 정의 된 경우 사용자 계정은 특정 사용자 계정에 대해서만 &lt;code&gt;PROXY&lt;/code&gt; 권한을 부여 할 수 있습니다 . 예를 들어, 부 여자 에게 해당 특정 사용자 계정에 대한 &lt;code&gt;PROXY&lt;/code&gt; 권한 이 없기 때문에 다음 예는 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="575c968e7d2afa2ced7ac0f5ce654c0bd981d4f7" translate="yes" xml:space="preserve">
          <source>A user account must connect via TLS if the user account is defined with the &lt;code&gt;REQUIRE SSL&lt;/code&gt; clause.</source>
          <target state="translated">사용자 계정이 &lt;code&gt;REQUIRE SSL&lt;/code&gt; 절로 정의 된 경우 사용자 계정은 TLS를 통해 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="455a583fd56f1ac7bbfccdab796ca617c5aedc9f" translate="yes" xml:space="preserve">
          <source>A user account must connect via TLS with a client certificate that must be signed by a specific certificate authority if the user account is defined with the &lt;code&gt;REQUIRE ISSUER&lt;/code&gt; clause.</source>
          <target state="translated">사용자 계정이 &lt;code&gt;REQUIRE ISSUER&lt;/code&gt; 절로 정의 된 경우 특정 인증 기관에서 서명해야하는 클라이언트 인증서로 TLS를 통해 사용자 계정을 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="31d1c10cee79087fa7ea7d64a7993aee4513ff39" translate="yes" xml:space="preserve">
          <source>A user account must connect via TLS with a specific cipher if the user account is defined with the &lt;code&gt;REQUIRE CIPHER&lt;/code&gt; clause.</source>
          <target state="translated">사용자 계정이 &lt;code&gt;REQUIRE CIPHER&lt;/code&gt; 절로 정의 된 경우 사용자 계정은 특정 암호로 TLS를 통해 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c19d1c4526e3169e5fd25347595a70fe3419d77" translate="yes" xml:space="preserve">
          <source>A user account must connect via TLS with a specific client certificate if the user account is defined with the &lt;code&gt;REQUIRE SUBJECT&lt;/code&gt; clause.</source>
          <target state="translated">사용자 계정이 &lt;code&gt;REQUIRE SUBJECT&lt;/code&gt; 절로 정의 된 경우 사용자 계정은 특정 클라이언트 인증서로 TLS를 통해 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5fb5c316094718a3f45f49ec6274914ef515aa0b" translate="yes" xml:space="preserve">
          <source>A user account must connect via TLS with a valid client certificate if the user account is defined with the &lt;code&gt;REQUIRE X509&lt;/code&gt; clause.</source>
          <target state="translated">사용자 계정이 &lt;code&gt;REQUIRE X509&lt;/code&gt; 절로 정의 된 경우 사용자 계정은 유효한 클라이언트 인증서로 TLS를 통해 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1e319b6260ecbe08519ba2d40da84ab2443d955" translate="yes" xml:space="preserve">
          <source>A user with the &lt;code&gt;&lt;a href=&quot;../library/grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege can disable logging to the general query log for a connection by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_log_off&quot;&gt;SQL_LOG_OFF&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;1&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../library/grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 권한이 있는 사용자 는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_log_off&quot;&gt;SQL_LOG_OFF&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하여 연결에 대한 일반 조회 로그에 로깅을 사용하지 않을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d1002bd2ee1955f9ec8855d38646c524659bdbd" translate="yes" xml:space="preserve">
          <source>A user-defined function (UDF) is a way to extend MariaDB with a new function that works like a native (built-in) MariaDB function such as &lt;a href=&quot;../abs/index&quot;&gt;ABS( )&lt;/a&gt; or &lt;a href=&quot;../concat/index&quot;&gt;CONCAT( )&lt;/a&gt;.</source>
          <target state="translated">UDF (사용자 정의 함수)는 &lt;a href=&quot;../abs/index&quot;&gt;ABS ()&lt;/a&gt; 또는 &lt;a href=&quot;../concat/index&quot;&gt;CONCAT ()&lt;/a&gt; 와 같은 기본 (내장) MariaDB 함수처럼 작동하는 새로운 함수로 MariaDB를 확장하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="d51041b49148a37dafd907b21a9003620c3bc07a" translate="yes" xml:space="preserve">
          <source>A user-defined function (UDF) is a way to extend MariaDB with a new function that works like a native (built-in) MariaDB function such as &lt;a href=&quot;../abs/index&quot;&gt;ABS()&lt;/a&gt; or &lt;a href=&quot;../concat/index&quot;&gt;CONCAT()&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 함수 (UDF)는 &lt;a href=&quot;../abs/index&quot;&gt;ABS ()&lt;/a&gt; 또는 &lt;a href=&quot;../concat/index&quot;&gt;CONCAT ()&lt;/a&gt; 와 같은 기본 (내장) MariaDB 함수처럼 작동하는 새로운 함수로 MariaDB를 확장하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="5f1643f9a01a368b2a4c1ce3bafa911686fb3ac0" translate="yes" xml:space="preserve">
          <source>A value of 022 can be set in the current session or in /etc/profile as follows:</source>
          <target state="translated">022 값은 현재 세션 또는 / etc / profile에서 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c2f8c7c94156b650a73077eb31436d2e4d0678" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;0&lt;/code&gt; means the key cache is a regular (i.e. non-segmented) key cache. This is the default. If &lt;code&gt;key_cache_segments&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; (or higher) then the new key cache segmentation code is used. In practice there is no practical use of a single-segment segmented key cache except for testing purposes, and setting &lt;code&gt;key_cache_segments = 1&lt;/code&gt; should be slower than any other option and should not be used in production.</source>
          <target state="translated">값이 &lt;code&gt;0&lt;/code&gt; 이면 키 캐시가 일반 (예 : 세그먼트 화되지 않은) 키 캐시임을 의미합니다. 이것이 기본값입니다. 경우 &lt;code&gt;key_cache_segments&lt;/code&gt; 이 있다 &lt;code&gt;1&lt;/code&gt; (또는 그 이상) 다음 새 키 캐시 분할 코드가 사용됩니다. 실제로 테스트 목적을 제외하고는 단일 세그먼트 세그먼트 키 캐시를 실제로 사용하지 않으며 &lt;code&gt;key_cache_segments = 1&lt;/code&gt; 설정 하면 다른 옵션보다 느려 야하며 프로덕션에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ef3717e2568caac37fe15c67f2d88338a504b03" translate="yes" xml:space="preserve">
          <source>A value of a global variable that persists until overwritten by a new signal. The global variable can also be seen as a &quot;signal post&quot; or &quot;flag mast&quot;. Then the signal is what is attached to the &quot;signal post&quot; or &quot;flag mast&quot;.</source>
          <target state="translated">새 신호로 덮어 쓸 때까지 지속되는 전역 변수의 값입니다. 전역 변수는 &quot;시그널 포스트&quot;또는 &quot;플래그 마스트&quot;로 볼 수도 있습니다. 그런 다음 신호는 &quot;신호 포스트&quot;또는 &quot;플래그 마스트&quot;에 부착 된 신호입니다.</target>
        </trans-unit>
        <trans-unit id="160a94568eb43fbab51c46352f9f840288d4fdaa" translate="yes" xml:space="preserve">
          <source>A variable of a non-integer based type in LIMIT clause</source>
          <target state="translated">LIMIT 절에서 정수가 아닌 유형의 변수</target>
        </trans-unit>
        <trans-unit id="79d830b82b3ac59504611664c360fd0d1b14237e" translate="yes" xml:space="preserve">
          <source>A variable-length string. M represents the maximum column length in characters. The range of M is 0 to 65,532. The effective maximum length of a VARCHAR is subject to the maximum row size and the character set used. For example, utf8 characters can require up to three bytes per character, so a VARCHAR column that uses the utf8 character set can be declared to be a maximum of 21,844 characters.</source>
          <target state="translated">가변 길이 문자열 M은 최대 열 길이를 문자로 나타냅니다. M의 범위는 0 내지 65,532입니다. VARCHAR의 유효 최대 길이는 최대 행 크기 및 사용 된 문자 세트에 따라 다릅니다. 예를 들어, utf8 문자는 문자 당 최대 3 바이트를 요구할 수 있으므로 utf8 문자 세트를 사용하는 VARCHAR 컬럼은 최대 21,844 자로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e060614e1e0e2bef1dcffe79ed4286958b7af5" translate="yes" xml:space="preserve">
          <source>A variant of this partitioning method, &lt;a href=&quot;../range-columns-and-list-columns-partitioning-types/index&quot;&gt;LIST COLUMNS&lt;/a&gt;, allows us to use multiple columns and more datatypes.</source>
          <target state="translated">이 분할 방법 인 &lt;a href=&quot;../range-columns-and-list-columns-partitioning-types/index&quot;&gt;LIST COLUMNS&lt;/a&gt; 의 변형으로 여러 열과 더 많은 데이터 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf41a9597fe96dbfb9e3665aab18d680fd80ada" translate="yes" xml:space="preserve">
          <source>A variant of this partitioning method, &lt;a href=&quot;../range-columns-and-list-columns-partitioning-types/index&quot;&gt;RANGE COLUMNS&lt;/a&gt;, allows us to use multiple columns and more datatypes.</source>
          <target state="translated">이 분할 방법 인 &lt;a href=&quot;../range-columns-and-list-columns-partitioning-types/index&quot;&gt;RANGE COLUMNS&lt;/a&gt; 의 변형으로 여러 열과 더 많은 데이터 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ae2d1416b618551bda557f373f66962eaf8321" translate="yes" xml:space="preserve">
          <source>A variant on that would be to have a separate processing process for each Insertion process.</source>
          <target state="translated">이에 대한 변형은 각 삽입 프로세스마다 별도의 처리 프로세스를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80288ab282b15573d30ec66293cc0b569924384e" translate="yes" xml:space="preserve">
          <source>A variant on the 2-table flip-flop is to have a separate `Staging` table for each Insertion process. The Processing process would run around to each Staging in turn.</source>
          <target state="translated">2 테이블 플립 플롭의 변형은 각 삽입 공정에 대해 별도의 '스테이징'테이블을 갖는 것입니다. 처리 프로세스는 각 준비 단계에서 차례로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="43b2b53a974cba1a2a2abb7020dff6dd377aa607" translate="yes" xml:space="preserve">
          <source>A variant:</source>
          <target state="translated">변형 :</target>
        </trans-unit>
        <trans-unit id="f3678b3c5eb619daf6e70d79150de8f82351f738" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;mysqlbinlog&lt;/code&gt; from MySQL &amp;gt;= 5.6.1 will have similar problems as a slave until this is fixed in MySQL. When reading a binlog file with checksums produced by MariaDB &amp;gt;= 5.3.0 but &amp;lt; 5.6.1, it will not realise that checksums are included, and will produce garbled output just like an old version of &lt;code&gt;mysqlbinlog&lt;/code&gt;. The MariaDB version of &lt;code&gt;mysqlbinlog&lt;/code&gt; can read binlog files produced by either MySQL or MariaDB just fine.</source>
          <target state="translated">MySQL&amp;gt; = 5.6.1 의 &lt;code&gt;mysqlbinlog&lt;/code&gt; 버전은 이것이 MySQL에서 수정 될 때까지 슬레이브와 비슷한 문제가 있습니다. MariaDB&amp;gt; = 5.3.0이지만 &amp;lt;5.6.1에 의해 생성 된 체크섬이있는 binlog 파일을 읽을 때 체크섬이 포함되어 있다는 것을 인식하지 못하고 이전 버전의 &lt;code&gt;mysqlbinlog&lt;/code&gt; 와 같이 출력이 깨져서 출력 됩니다. &lt;code&gt;mysqlbinlog&lt;/code&gt; 의 MariaDB 버전은 MySQL 또는 MariaDB에서 생성 된 binlog 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e70519fcdbd9c37d0f96218039ec06d754b8eb9" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;mysqlbinlog&lt;/code&gt; which understands checksums can read binlog files from either old or new servers, with or without checksums enabled.</source>
          <target state="translated">체크섬을 이해 하는 &lt;code&gt;mysqlbinlog&lt;/code&gt; 버전은 체크섬을 사용하거나 사용하지 않고 이전 또는 새 서버에서 binlog 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa62e6f5f7907e9bf5b9634976b81be891255ba" translate="yes" xml:space="preserve">
          <source>A very important flag is -fno-rtti. Without it you would be in big trouble.</source>
          <target state="translated">매우 중요한 플래그는 -fno-rtti입니다. 그것 없이는 큰 어려움에 처할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ed18eef0eafa88434639305986c43d0ac341626" translate="yes" xml:space="preserve">
          <source>A very small &lt;a href=&quot;../sql_language-data_types-int/index&quot;&gt;integer&lt;/a&gt;. The signed range is -128 to 127. The unsigned range is 0 to 255. For details on the attributes, see &lt;a href=&quot;../numeric-data-type-overview/index&quot;&gt;Numeric Data Type Overview&lt;/a&gt;.</source>
          <target state="translated">매우 작은 &lt;a href=&quot;../sql_language-data_types-int/index&quot;&gt;정수&lt;/a&gt; 입니다. 부호있는 범위는 -128-127입니다. 부호없는 범위는 0-255입니다. 속성에 대한 자세한 내용은 &lt;a href=&quot;../numeric-data-type-overview/index&quot;&gt;숫자 데이터 유형 개요를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a71f3350d4f9f7098262bf54006e38874196ec00" translate="yes" xml:space="preserve">
          <source>A very small integer. Numeric value with scale 0. Signed: -126 to +127. Unsigned: 0 to 253.</source>
          <target state="translated">매우 작은 정수입니다. 스케일이 0 인 숫자 값. 부호 : -126에서 +127. 부호없는 : 0-253.</target>
        </trans-unit>
        <trans-unit id="fffa3c8dab45721890a92177bdb04b90f4c6c499" translate="yes" xml:space="preserve">
          <source>A view belongs to a database. By default, a new view is created in the default database. To create the view explicitly in a given database, specify the name as db_name.view_name when you create it.</source>
          <target state="translated">뷰는 데이터베이스에 속합니다. 기본적으로 기본 데이터베이스에 새보기가 작성됩니다. 주어진 데이터베이스에서 명시 적으로보기를 작성하려면 작성할 때 이름을 db_name.view_name으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4763ec7a4f7f3da049dacea36ab41f5c160f2a37" translate="yes" xml:space="preserve">
          <source>A view can be created from many kinds of SELECT statements. It can refer to base tables or other views. It can use joins, UNION, and subqueries. The SELECT need not even refer to any tables. The following example defines a view that selects two columns from another table, as well as an expression calculated from those columns:</source>
          <target state="translated">많은 종류의 SELECT 문에서 뷰를 만들 수 있습니다. 기본 테이블 또는 다른 뷰를 참조 할 수 있습니다. 조인, UNION 및 하위 쿼리를 사용할 수 있습니다. SELECT는 어떤 테이블도 참조 할 필요가 없습니다. 다음 예제는 다른 테이블에서 두 개의 열을 선택하는 뷰와 해당 열에서 계산 된 표현식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3e6c31a62b55775adfb6785be1dd3c956c3ddb7d" translate="yes" xml:space="preserve">
          <source>A view cannot be of type ALGORITHM=MERGE if it uses any of the following:</source>
          <target state="translated">다음 중 하나를 사용하는 경우보기는 ALGORITHM = MERGE 유형일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0558fb3cad36bce6e983e75651c0c70d17da667" translate="yes" xml:space="preserve">
          <source>A view cannot be used for inserting if it fails any of the criteria for &lt;a href=&quot;#updating-with-views&quot;&gt;updating&lt;/a&gt;, and must also meet the following conditions:</source>
          <target state="translated">&lt;a href=&quot;#updating-with-views&quot;&gt;업데이트&lt;/a&gt; 기준에 실패하면 뷰를 삽입에 사용할 수 없으며 다음 조건도 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="b58c05307ce5df1fc378be7ebcf390ea855408fc" translate="yes" xml:space="preserve">
          <source>A view cannot be used for updating if it uses any of the following:</source>
          <target state="translated">다음 중 하나를 사용하는 경우 업데이트에보기를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a44b9dc65d60f805070f4ecfb122dd7a6a790944" translate="yes" xml:space="preserve">
          <source>A view definition is subject to the following restrictions:</source>
          <target state="translated">뷰 정의에는 다음 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0c057e87867bf906d2114ffadb251425803b2b" translate="yes" xml:space="preserve">
          <source>A view with a WHERE which is always false (like &lt;code&gt;WHERE 0&lt;/code&gt;) and WITH CHECK OPTION is similar to a &lt;a href=&quot;../blackhole/index&quot;&gt;BLACKHOLE&lt;/a&gt; table: no row is ever inserted and no row is ever returned. An insertable view with a WHERE which is always false but no CHECK OPTION is a view that accepts data but does not show them.</source>
          <target state="translated">WHERE가 항상 false ( &lt;code&gt;WHERE 0&lt;/code&gt; 과 같은 )이고 WITH CHECK OPTION이 있는 뷰 는 &lt;a href=&quot;../blackhole/index&quot;&gt;BLACKHOLE&lt;/a&gt; 테이블 과 유사 합니다. 행이 삽입되지 않고 행이 리턴되지 않습니다. WHERE가 항상 false이지만 CHECK OPTION이없는 삽입 가능한 뷰는 데이터를 허용하지만 표시하지 않는 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="61787225a3e41738d55babc6e8b73b5a2fc9310a" translate="yes" xml:space="preserve">
          <source>A vignette on how to use the RODBC package can be found here: &lt;a href=&quot;https://cran.r-project.org/web/packages/RODBC/vignettes/RODBC.pdf&quot;&gt;RODBC CRAN Vignette&lt;/a&gt;</source>
          <target state="translated">RODBC 패키지 사용 방법에 대한 비 네트는 여기에서 찾을 수 있습니다. &lt;a href=&quot;https://cran.r-project.org/web/packages/RODBC/vignettes/RODBC.pdf&quot;&gt;RODBC CRAN Vignette&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fdc5779b9236a04083ee0970014026ccae85f01f" translate="yes" xml:space="preserve">
          <source>A virtual machine would certainly serve the scope. However, this means installing a system on the top of another system. It requires a lot of resources.</source>
          <target state="translated">가상 머신은 확실히 범위를 제공합니다. 그러나 이는 다른 시스템 위에 시스템을 설치하는 것을 의미합니다. 많은 자원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4788dcfb432562e11c72d212601560dad91f25b1" translate="yes" xml:space="preserve">
          <source>A warning is generated of the form: &quot;Query execution was interrupted. The query examined at least 100 rows, which exceeds LIMIT ROWS EXAMINED (20). The query result may be incomplete.&quot;</source>
          <target state="translated">&quot;쿼리 실행이 중단되었습니다. 쿼리가 100 개 이상의 행을 검사하여 LIMIT ROWS EXAMINED (20)를 초과했습니다. 쿼리 결과가 불완전 할 수 있습니다.&quot;라는 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9993715b9a444ac7215de4118f41609d5c234880" translate="yes" xml:space="preserve">
          <source>A warning will occur if the JSON document is not valid, any of the path arguments are not valid, if &lt;em&gt;return_arg&lt;/em&gt; is neither &lt;em&gt;one&lt;/em&gt; nor &lt;em&gt;all&lt;/em&gt;, or if the escape character is not a constant. NULL will be returned.</source>
          <target state="translated">JSON 문서가 유효하지 않은 경우 경고 메시지가있는 경우 경로의 모든 인수가 유효하지 않습니다, 발생합니다 &lt;em&gt;return_arg이&lt;/em&gt; 도 아닌 &lt;em&gt;하나&lt;/em&gt; 나 &lt;em&gt;모두&lt;/em&gt; , 또는 이스케이프 문자가 일정하지 않은 경우. NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf6f06759cb528c33969a9a648ef800d0b9d029" translate="yes" xml:space="preserve">
          <source>A way to fix this is to specify the exact version of the two packages that you want to install. To do this, first determine the full version numbers of the affected packages. An easy way to do so is with &lt;code&gt;'apt-cache show'&lt;/code&gt;:</source>
          <target state="translated">이 문제를 해결하는 방법은 설치할 두 패키지의 정확한 버전을 지정하는 것입니다. 이렇게하려면 먼저 영향을받는 패키지의 전체 버전 번호를 확인하십시오. 이렇게하는 쉬운 방법은 &lt;code&gt;'apt-cache show'&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="342ec6ff215fc9c391d8dd377a9c600aa7d7010d" translate="yes" xml:space="preserve">
          <source>A way to simulate the MyISAM 'feature' might be something like: What you want is this, but it won't work because it is referencing the table twice:</source>
          <target state="translated">MyISAM '기능'을 시뮬레이션하는 방법은 다음과 같습니다. 원하는 것은 이것이지만, 테이블을 두 번 참조하기 때문에 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e48a01ecad40292bc90eab6d4c27246069c4f554" translate="yes" xml:space="preserve">
          <source>A web server like Apache runs multiple threads. If each thread opens a connection to MariaDB, you could run out of connections. Make sure MaxClients (or equivalent) is set to some civilized number (under 50).</source>
          <target state="translated">Apache와 같은 웹 서버는 여러 스레드를 실행합니다. 각 스레드가 MariaDB에 대한 연결을 열면 연결이 부족할 수 있습니다. MaxClients (또는 이와 동등한)가 문명 번호 (50 미만)로 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7835ada477902f8fb1b2662d4f61de9dc72ff680" translate="yes" xml:space="preserve">
          <source>A window function is applied in the select clause using the following syntax:</source>
          <target state="translated">윈도우 함수는 다음 구문을 사용하여 select 절에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5796bd239a379f81cb89c6b7baa819958b504285" translate="yes" xml:space="preserve">
          <source>A window with a client open to the federatedx server on port 5554</source>
          <target state="translated">포트 5554에서 federatedx 서버에 열려있는 클라이언트가있는 창</target>
        </trans-unit>
        <trans-unit id="35982d5a3fb2ba9cee6cba2316d2f720fb7b94fb" translate="yes" xml:space="preserve">
          <source>A window with a client open to the federatedx server on port 5555</source>
          <target state="translated">포트 5555에서 페더 레이팅 된 서버에 열려있는 클라이언트가있는 창</target>
        </trans-unit>
        <trans-unit id="42dbd7d63a385b7569a4fe2b1b51714a9991bfdc" translate="yes" xml:space="preserve">
          <source>A workaround is to use UNION. Each part of the UNION is optimized separately. For the second case:</source>
          <target state="translated">해결 방법은 UNION을 사용하는 것입니다. UNION의 각 부분은 별도로 최적화됩니다. 두 번째 경우 :</target>
        </trans-unit>
        <trans-unit id="4084399a95e2f5d47caffcfd14500afcd5fabfb2" translate="yes" xml:space="preserve">
          <source>A worker thread noticed that there is already another thread executing the same GTID from another connection and it's waiting for the other to complete.</source>
          <target state="translated">작업자 스레드는 다른 연결에서 동일한 GTID를 실행하는 다른 스레드가 이미 있으며 다른 스레드가 완료되기를 기다리고 있음을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="ea5610fa71ff94b1b6b60c998a5773708f63ed76" translate="yes" xml:space="preserve">
          <source>A year in two-digit or four-digit format. The default is four-digit format. Note that the two-digit format has been deprecated since 5.5.27.</source>
          <target state="translated">두 자리 또는 네 자리 형식의 연도입니다. 기본값은 네 자리 형식입니다. 두 자리 형식은 5.5.27부터 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b37c53d451030ce5f1893b32cd35ef59bfe1008d" translate="yes" xml:space="preserve">
          <source>A zero delay disables delayed replication. The slave must be stopped when changing the delay value.</source>
          <target state="translated">지연이 0이면 지연된 복제가 비활성화됩니다. 지연 값을 변경할 때 슬레이브를 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="f03c0954557e252c55bd15f695d32503c913cfd1" translate="yes" xml:space="preserve">
          <source>A(ttribute) or @</source>
          <target state="translated">A (ttribute) 또는 @</target>
        </trans-unit>
        <trans-unit id="cf0a867adeaabd9da97d975b9ae943292d0f4475" translate="yes" xml:space="preserve">
          <source>A) Programming</source>
          <target state="translated">A) 프로그래밍</target>
        </trans-unit>
        <trans-unit id="74963c1155daa092b7201d999e761fdc6a1f4ca1" translate="yes" xml:space="preserve">
          <source>A. The recommended R distribution is &amp;ldquo;Microsoft R Open&amp;rdquo;: &lt;a href=&quot;https://mran.microsoft.com/&quot;&gt;MRAN&lt;/a&gt;</source>
          <target state="translated">A. 권장 R 배포는&amp;ldquo;Microsoft R Open&amp;rdquo;입니다. &lt;a href=&quot;https://mran.microsoft.com/&quot;&gt;MRAN&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b299a842bb72461f708b9f6f8cd8932a22cf444a" translate="yes" xml:space="preserve">
          <source>ABS</source>
          <target state="translated">ABS</target>
        </trans-unit>
        <trans-unit id="b680399e674b7c0c02c1909c0f17db3ccf5dfdb8" translate="yes" xml:space="preserve">
          <source>ABS()</source>
          <target state="translated">ABS()</target>
        </trans-unit>
        <trans-unit id="100c555ef288ec205473df7d482de7e07a94e39f" translate="yes" xml:space="preserve">
          <source>ACCESSIBLE</source>
          <target state="translated">ACCESSIBLE</target>
        </trans-unit>
        <trans-unit id="309ae1de35ac7cfc5e1c1365f122fe7c3d5e6f2b" translate="yes" xml:space="preserve">
          <source>ACID compliant</source>
          <target state="translated">ACID 호환</target>
        </trans-unit>
        <trans-unit id="6b1cf8a49d547f451d83ea90014fdfe7687be67a" translate="yes" xml:space="preserve">
          <source>ACK</source>
          <target state="translated">ACK</target>
        </trans-unit>
        <trans-unit id="d66c69a3a10311def16f83936d580dc4e1b6b47c" translate="yes" xml:space="preserve">
          <source>ACK Receiver Thread</source>
          <target state="translated">ACK 수신기 스레드</target>
        </trans-unit>
        <trans-unit id="f47f10ba5ea545caa0a421972fc7fe1f9c136d03" translate="yes" xml:space="preserve">
          <source>ACOS</source>
          <target state="translated">ACOS</target>
        </trans-unit>
        <trans-unit id="799af5dd6aaa1dd48afd4b9ca29f369b1d8ecc12" translate="yes" xml:space="preserve">
          <source>ACOS()</source>
          <target state="translated">ACOS()</target>
        </trans-unit>
        <trans-unit id="2b9f1cf5c4d33807129af3dcb41af0a491f4cda7" translate="yes" xml:space="preserve">
          <source>ACTION</source>
          <target state="translated">ACTION</target>
        </trans-unit>
        <trans-unit id="f9460492306d4b99cd31848c3a99a26a7e978d96" translate="yes" xml:space="preserve">
          <source>ADD</source>
          <target state="translated">ADD</target>
        </trans-unit>
        <trans-unit id="1e7b23fdea8f52c3001cd141d894c2bad27f8306" translate="yes" xml:space="preserve">
          <source>ADD COLUMN</source>
          <target state="translated">열 추가</target>
        </trans-unit>
        <trans-unit id="86686b9c3c76af3b6ab46479ee6f678506bb5d0c" translate="yes" xml:space="preserve">
          <source>ADD CONSTRAINT</source>
          <target state="translated">제약 추가</target>
        </trans-unit>
        <trans-unit id="c8654dcdfe7294b908015ba0c48881901813357b" translate="yes" xml:space="preserve">
          <source>ADD FOREIGN KEY</source>
          <target state="translated">외래 키 추가</target>
        </trans-unit>
        <trans-unit id="dc6339e256e3da457aafd81895faee02df09384c" translate="yes" xml:space="preserve">
          <source>ADD FULLTEXT INDEX</source>
          <target state="translated">전체 텍스트 색인 추가</target>
        </trans-unit>
        <trans-unit id="eeaa251b088b2fd92648d1bd69aa28a65341bbcd" translate="yes" xml:space="preserve">
          <source>ADD INDEX</source>
          <target state="translated">색인 추가</target>
        </trans-unit>
        <trans-unit id="f7a635b3db50f9ef80dedbae3805511e80a95f1b" translate="yes" xml:space="preserve">
          <source>ADD INDEX?</source>
          <target state="translated">색인을 추가 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="479337f0103b1c8eb13db360e079b8cfbb6d582b" translate="yes" xml:space="preserve">
          <source>ADD PERIOD FOR SYSTEM_TIME</source>
          <target state="translated">SYSTEM_TIME에 기간 추가</target>
        </trans-unit>
        <trans-unit id="26b4341855facdd3d50fdebc71567e7de123a695" translate="yes" xml:space="preserve">
          <source>ADD PRIMARY KEY</source>
          <target state="translated">기본 키 추가</target>
        </trans-unit>
        <trans-unit id="75e2157e99ad95297163105cc389e7cf1912e4be" translate="yes" xml:space="preserve">
          <source>ADD SPATIAL INDEX</source>
          <target state="translated">SPATIAL INDEX 추가</target>
        </trans-unit>
        <trans-unit id="a53ceed4a2f4fe529267f3beeebfbd5f4035dc5e" translate="yes" xml:space="preserve">
          <source>ADD SYSTEM VERSIONING</source>
          <target state="translated">시스템 버전 추가</target>
        </trans-unit>
        <trans-unit id="55d625a1ea2ae8c2ae01c1b86f72af52ac3ba564" translate="yes" xml:space="preserve">
          <source>ADD UNIQUE INDEX</source>
          <target state="translated">고유 색인 추가</target>
        </trans-unit>
        <trans-unit id="f561957411d74d0d50845a7b44e79cc3d3a79428" translate="yes" xml:space="preserve">
          <source>ADDDATE</source>
          <target state="translated">ADDDATE</target>
        </trans-unit>
        <trans-unit id="f8f3c30bef103ecfae401c222da06b1d50e014ca" translate="yes" xml:space="preserve">
          <source>ADDDATE()</source>
          <target state="translated">ADDDATE()</target>
        </trans-unit>
        <trans-unit id="ce46f4ac10419ef5c06f8e2203c2a5b4ce72221f" translate="yes" xml:space="preserve">
          <source>ADDTIME</source>
          <target state="translated">ADDTIME</target>
        </trans-unit>
        <trans-unit id="5cf2246c8f00f5961e5bfa8bc41996674ae836d1" translate="yes" xml:space="preserve">
          <source>ADDTIME()</source>
          <target state="translated">ADDTIME()</target>
        </trans-unit>
        <trans-unit id="5b16b8de51e23d4e1e088f6b3cca954f7d68e9b9" translate="yes" xml:space="preserve">
          <source>ADMINISTRATIF</source>
          <target state="translated">ADMINISTRATIF</target>
        </trans-unit>
        <trans-unit id="25c5d184fd3c8e7d24af0e237c061f5480a5e86e" translate="yes" xml:space="preserve">
          <source>ADMINISTRATOR</source>
          <target state="translated">ADMINISTRATOR</target>
        </trans-unit>
        <trans-unit id="bf5d352542861d3cb47f65bcdfe1411096640f88" translate="yes" xml:space="preserve">
          <source>AES_DECRYPT</source>
          <target state="translated">AES_DECRYPT</target>
        </trans-unit>
        <trans-unit id="b639d53cd48403f8d5b7b42a377ee230941a76bb" translate="yes" xml:space="preserve">
          <source>AES_ENCRYPT</source>
          <target state="translated">AES_ENCRYPT</target>
        </trans-unit>
        <trans-unit id="5456595e40128843a0d93faf093ee834151a691d" translate="yes" xml:space="preserve">
          <source>AFTER DELETE (only if a row is being deleted);</source>
          <target state="translated">AFTER DELETE (행이 삭제되는 경우에만);</target>
        </trans-unit>
        <trans-unit id="ab834ae89ac9761774e8901f703c719d72132eae" translate="yes" xml:space="preserve">
          <source>AFTER INSERT.</source>
          <target state="translated">삽입 후.</target>
        </trans-unit>
        <trans-unit id="c370b8bf9efed356236b51c599a393e38f8318a2" translate="yes" xml:space="preserve">
          <source>AFTER UPDATE.</source>
          <target state="translated">업데이트 후.</target>
        </trans-unit>
        <trans-unit id="79d3ad25c48ab94802530b2aafd0e91e4c58fde6" translate="yes" xml:space="preserve">
          <source>AGGREGATE</source>
          <target state="translated">AGGREGATE</target>
        </trans-unit>
        <trans-unit id="643694607822b98cbaeadef29d4ae0b6799c80ad" translate="yes" xml:space="preserve">
          <source>AGGREGATE is not supported for stored functions</source>
          <target state="translated">저장된 기능에는 AGGREGATE가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5059e13b3301294855ee42530522bfcfb21a5602" translate="yes" xml:space="preserve">
          <source>ALGORITHM=TEMPTABLE (see &lt;a href=&quot;../view-algorithms/index&quot;&gt;View Algorithms&lt;/a&gt;)</source>
          <target state="translated">ALGORITHM = TEMPTABLE ( &lt;a href=&quot;../view-algorithms/index&quot;&gt;알고리즘보기&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="a1bb06c1a1756cef3f2516bd913e28310358a53c" translate="yes" xml:space="preserve">
          <source>ALL is not supported by &lt;code&gt;EXCEPT&lt;/code&gt; (and it is difficult to make sense of ALL with EXCEPT).</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 는 ALL을 지원하지 않으며 EXCEPT 는 ALL을 이해하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="709b80d1f14dd0eddc93184e48f7eaf12c30d341" translate="yes" xml:space="preserve">
          <source>ALL is not supported by &lt;code&gt;INTERSECT&lt;/code&gt; (and it is difficult to make sense of ALL with INTERSECT).</source>
          <target state="translated">&lt;code&gt;INTERSECT&lt;/code&gt; 는 ALL을 지원하지 않으며 INTERSECT로는 ALL을 이해하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="85140ed05520d2befde0aa0503d8f3802364fa56" translate="yes" xml:space="preserve">
          <source>ALL/DISTINCT</source>
          <target state="translated">ALL/DISTINCT</target>
        </trans-unit>
        <trans-unit id="68fcb076e586e0278145efedb0329675f6b18bc2" translate="yes" xml:space="preserve">
          <source>ALLOWREMOTEROOTACCESS</source>
          <target state="translated">ALLOWREMOTEROOTACCESS</target>
        </trans-unit>
        <trans-unit id="6e69e31990a7343ff088d4c32eea14ef655df385" translate="yes" xml:space="preserve">
          <source>ALTER</source>
          <target state="translated">ALTER</target>
        </trans-unit>
        <trans-unit id="265c85b7eccbaa586989e71f75da4dd11cad1f6f" translate="yes" xml:space="preserve">
          <source>ALTER COLUMN</source>
          <target state="translated">ALTER COLUMN</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">데이터베이스 변경</target>
        </trans-unit>
        <trans-unit id="eebe353d39e7f1062daa4204a67eab5a587902f0" translate="yes" xml:space="preserve">
          <source>ALTER EVENT</source>
          <target state="translated">이벤트 변경</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">기능 변경</target>
        </trans-unit>
        <trans-unit id="91eb9aaf9cf7c8c968e08009cf2ae02e9e37ff41" translate="yes" xml:space="preserve">
          <source>ALTER LOGFILE GROUP</source>
          <target state="translated">로그 파일 그룹 변경</target>
        </trans-unit>
        <trans-unit id="3b90410610dbb0521c9137412184aa662e58c0d6" translate="yes" xml:space="preserve">
          <source>ALTER ONLINE TABLE has also worked for partitioned tables since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;MariaDB 10.0.11&lt;/a&gt;.</source>
          <target state="translated">ALTER ONLINE TABLE은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;MariaDB 10.0.11&lt;/a&gt; 이후 파티션 된 테이블에서도 작동했습니다 .</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">절차 변경</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">순서 변경</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">대체 서버</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">테이블 변경</target>
        </trans-unit>
        <trans-unit id="6c06ce11c70f8c88c6b46a6a36ecb4a6eaa0dbf6" translate="yes" xml:space="preserve">
          <source>ALTER TABLE '%s' IMPORT TABLESPACE failed with error %lu : '%s'</source>
          <target state="translated">ALTER TABLE '% s'IMPORT TABLESPACE가 % lu 오류와 함께 실패했습니다 : '% s'</target>
        </trans-unit>
        <trans-unit id="d9f2e3ea6a497df32f81b90a89205db2f5a05103" translate="yes" xml:space="preserve">
          <source>ALTER TABLE causes auto_increment resequencing, resulting in duplicate entry '%s' for key '%s'</source>
          <target state="translated">ALTER TABLE로 인해 자동 증분 재 시퀀싱이 발생하여 키 '% s'에 대한 중복 항목 '% s'이 (가) 발생 함</target>
        </trans-unit>
        <trans-unit id="c9099c1644df6dfcefe0295757fd90d686dc40c9" translate="yes" xml:space="preserve">
          <source>ALTER TABLE sequence RENAME TO sequence2</source>
          <target state="translated">ALTER TABLE 시퀀스 이름을 sequence2로 변경</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">테이블 스페이스 변경</target>
        </trans-unit>
        <trans-unit id="cc91164b09cdaac019da7c5478fea43b230a1793" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE is not available in MariaDB.</source>
          <target state="translated">MariaDB에서는 ALTER TABLESPACE를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">사용자 변경</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">변경보기</target>
        </trans-unit>
        <trans-unit id="b33f3fe6c70bdadd1ec7332413fa40c2464b2bc5" translate="yes" xml:space="preserve">
          <source>ALTER to change DEFAULT</source>
          <target state="translated">기본 변경 변경</target>
        </trans-unit>
        <trans-unit id="61eb4df4d293456f08301790ef064a866ba46cab" translate="yes" xml:space="preserve">
          <source>ALTER to change definition of ENUM or SET (see caveats in manual)</source>
          <target state="translated">ENUM 또는 SET의 정의를 변경하도록 변경 (설명서의주의 사항 참조)</target>
        </trans-unit>
        <trans-unit id="f2f4b30dad1d66da848263fc8acaf0c327e61398" translate="yes" xml:space="preserve">
          <source>ALTERs</source>
          <target state="translated">ALTERs</target>
        </trans-unit>
        <trans-unit id="59ded97dd5e7ba08186c4b3acd7a9c61865f5b8c" translate="yes" xml:space="preserve">
          <source>ALTERs are handled differently.</source>
          <target state="translated">ALTER는 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a78032a89d6c44fca8c1bb76fa350974eddb6ae3" translate="yes" xml:space="preserve">
          <source>AM/PM according to current locale (Variable &lt;a href=&quot;../server-system-variables/index#lc_time_names&quot;&gt;lc_time_names&lt;/a&gt;).</source>
          <target state="translated">현재 로케일에 따른 AM / PM (변수 &lt;a href=&quot;../server-system-variables/index#lc_time_names&quot;&gt;lc_time_names&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="91a1cb331a3a7dc9b9a5e15603d50d7e4e82c88d" translate="yes" xml:space="preserve">
          <source>AMD FX-4100 / Asus M5A99X EVO desktop (16GB ECC RAM)</source>
          <target state="translated">AMD FX-4100 / Asus M5A99X EVO 데스크탑 (16GB ECC RAM)</target>
        </trans-unit>
        <trans-unit id="abd20c69e9b1c4ec9f0196385a8604239b7fea4c" translate="yes" xml:space="preserve">
          <source>AMOUNT</source>
          <target state="translated">AMOUNT</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="dffdd2a28fb47efb1351a45cc36d4110c95579b3" translate="yes" xml:space="preserve">
          <source>ANALYZE FORMAT=JSON</source>
          <target state="translated">분석 형식 = JSON</target>
        </trans-unit>
        <trans-unit id="a0c3f9b806d091a9c24ce8aac00be35be149ef20" translate="yes" xml:space="preserve">
          <source>ANALYZE FORMAT=JSON Examples</source>
          <target state="translated">분석 형식 = JSON 예</target>
        </trans-unit>
        <trans-unit id="45125cc9090d0ac679a09ab0d26d9e0ebe6febf7" translate="yes" xml:space="preserve">
          <source>ANALYZE FORMAT=JSON output for table orders will show</source>
          <target state="translated">ANALYZE FORMAT = 테이블 주문에 대한 JSON 출력이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="265b4ace813904b077fc2eeaafbe813e4a4c48dc" translate="yes" xml:space="preserve">
          <source>ANALYZE Statement</source>
          <target state="translated">ANALYZE 문</target>
        </trans-unit>
        <trans-unit id="b8d87263dd27f379bb132798e5d09aaad0ce7877" translate="yes" xml:space="preserve">
          <source>ANALYZE TABLE</source>
          <target state="translated">분석 테이블</target>
        </trans-unit>
        <trans-unit id="11391aa44e132621e065e677b19e2e22e2178932" translate="yes" xml:space="preserve">
          <source>ANALYZE TABLE will possibly flush the MemTable (depending on the &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_flush_memtable_on_analyze&quot;&gt;rocksdb_flush_memtable_on_analyze&lt;/a&gt; and &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_pause_background_work&quot;&gt;rocksdb_pause_background_work&lt;/a&gt; settings).</source>
          <target state="translated">ANALYZE TABLE은 &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_flush_memtable_on_analyze&quot;&gt;rockmdb_flush_memtable_on_analyze&lt;/a&gt; 및 &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_pause_background_work&quot;&gt;rocksdb_pause_background_work&lt;/a&gt; 설정 에 따라 MemTable을 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe593ad1a50b3b944d7700086d6f8aa820985d2b" translate="yes" xml:space="preserve">
          <source>ANALYZE and EXPLAIN Statements</source>
          <target state="translated">분석 및 설명문</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="bfbdb33c73225e1b2cef58456830dbda8d39ef48" translate="yes" xml:space="preserve">
          <source>ANTERPE</source>
          <target state="translated">ANTERPE</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="f8d5d8deb59b62c271a09d6de1fe10cbd13941e2" translate="yes" xml:space="preserve">
          <source>API changed to be able to work with the new format (*_named functions).</source>
          <target state="translated">API가 새로운 형식 (* _named 함수)을 사용할 수 있도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="45747a68b9fc5df40140201b35abe8cff77afe0c" translate="yes" xml:space="preserve">
          <source>APPEND*</source>
          <target state="translated">APPEND*</target>
        </trans-unit>
        <trans-unit id="c4bda433965722a7bc7ba54dcfd4a8c3017b2a32" translate="yes" xml:space="preserve">
          <source>ARCHIBALD</source>
          <target state="translated">ARCHIBALD</target>
        </trans-unit>
        <trans-unit id="bf1a890e68e4671c51e8c3d58f76f4dafbe0eef2" translate="yes" xml:space="preserve">
          <source>AREA</source>
          <target state="translated">AREA</target>
        </trans-unit>
        <trans-unit id="e429428ac7964f25c43fc0d6ebd5145edc154314" translate="yes" xml:space="preserve">
          <source>ARMSCII-8 Armenian</source>
          <target state="translated">ARMSCII-8 아르메니아어</target>
        </trans-unit>
        <trans-unit id="3e36d1ca2adf5962801ee67544d6b213480d0743" translate="yes" xml:space="preserve">
          <source>ARRAY</source>
          <target state="translated">ARRAY</target>
        </trans-unit>
        <trans-unit id="d00bb3f3b7c7b8815b6dcf237dd16aab9744eca8" translate="yes" xml:space="preserve">
          <source>AS</source>
          <target state="translated">AS</target>
        </trans-unit>
        <trans-unit id="4281b54e74d439c873da3b5d326e7fb126b48e5f" translate="yes" xml:space="preserve">
          <source>AS BINARY(N) measures the length in bytes rather than characters, and right pads with 0x00 bytes to the desired length.</source>
          <target state="translated">AS BINARY (N)은 문자가 아닌 바이트 단위의 길이를 측정하고 원하는 길이까지 0x00 바이트의 오른쪽 패드를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="41c7a2727ac0a995d74e67dc416649e99bb01300" translate="yes" xml:space="preserve">
          <source>AS CHAR(N) measures the length in characters, and right pads with spaces to the desired length.</source>
          <target state="translated">AS CHAR (N)은 문자의 길이를 측정하고 원하는 길이의 공백이있는 오른쪽 패드입니다.</target>
        </trans-unit>
        <trans-unit id="eaffec78401451424652480dc382235348ce1b66" translate="yes" xml:space="preserve">
          <source>ASC</source>
          <target state="translated">ASC</target>
        </trans-unit>
        <trans-unit id="ecedf25b91e283df93f094bf5370cc08c975d9d6" translate="yes" xml:space="preserve">
          <source>ASC (default) and DESC options allow for ordering ascending or descending.</source>
          <target state="translated">ASC (기본값) 및 DESC 옵션을 사용하면 오름차순 또는 내림차순으로 주문할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="8ffb9c21598c618fa90ef89572a49c45803c3700" translate="yes" xml:space="preserve">
          <source>ASCII 26 (Control+Z). See note following the table.</source>
          <target state="translated">ASCII 26 (Control + Z). 다음 표를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="3254150465aaf8a8182b0624794ac37b71b82d61" translate="yes" xml:space="preserve">
          <source>ASCII NUL (0x00).</source>
          <target state="translated">ASCII NUL (0x00).</target>
        </trans-unit>
        <trans-unit id="939682e23d2c28e6e79640f1595ac3a301f87254" translate="yes" xml:space="preserve">
          <source>ASCII()</source>
          <target state="translated">ASCII()</target>
        </trans-unit>
        <trans-unit id="d27e64d0c826cdfc7fdc8017fb7b14cbbf8456c6" translate="yes" xml:space="preserve">
          <source>ASCII: U+0001 .. U+007F (full Unicode Basic Multilingual Plane (BMP) except for U+0000)</source>
          <target state="translated">ASCII : U + 0001 .. U + 007F (U + 0000을 제외한 전체 유니 코드 기본 다국어 평면 (BMP))</target>
        </trans-unit>
        <trans-unit id="efcee1da5ae3a3eae9f7354bb2225efbc25d4174" translate="yes" xml:space="preserve">
          <source>ASCII: [0-9,a-z,A-Z$_] (numerals 0-9, basic Latin letters, both lowercase and uppercase, dollar sign, underscore)</source>
          <target state="translated">ASCII : [0-9, az, AZ $ _] (숫자 0-9, 기본 라틴 문자, 소문자와 대문자, 달러 기호, 밑줄)</target>
        </trans-unit>
        <trans-unit id="f6613e34cc5aea06f362fc97d61d8a06d10e5180" translate="yes" xml:space="preserve">
          <source>ASENSITIVE</source>
          <target state="translated">ASENSITIVE</target>
        </trans-unit>
        <trans-unit id="f19e5c9ef1b1dea16be6bcc72d835cd9e7afcc13" translate="yes" xml:space="preserve">
          <source>ASIN</source>
          <target state="translated">ASIN</target>
        </trans-unit>
        <trans-unit id="03c113589c260907cd99305cb0a5dc6220e038a0" translate="yes" xml:space="preserve">
          <source>ASIN()</source>
          <target state="translated">ASIN()</target>
        </trans-unit>
        <trans-unit id="031fd11ba8734ab304116a023b5216306b246bee" translate="yes" xml:space="preserve">
          <source>AT</source>
          <target state="translated">AT</target>
        </trans-unit>
        <trans-unit id="0e3ba08070893718cd81942a382b31503c5b0d40" translate="yes" xml:space="preserve">
          <source>ATAN</source>
          <target state="translated">ATAN</target>
        </trans-unit>
        <trans-unit id="b574c58dddc98caa2086d15391667a5d018bd15b" translate="yes" xml:space="preserve">
          <source>ATAN()</source>
          <target state="translated">ATAN()</target>
        </trans-unit>
        <trans-unit id="a0d9e4c79a8896107ee237a570eac0b0a79fbcb2" translate="yes" xml:space="preserve">
          <source>ATAN2</source>
          <target state="translated">ATAN2</target>
        </trans-unit>
        <trans-unit id="8b61f8355a2ccf4ace40fd469d2de5233617a66b" translate="yes" xml:space="preserve">
          <source>AUTHOR</source>
          <target state="translated">AUTHOR</target>
        </trans-unit>
        <trans-unit id="587376a33709a3b10d327a7dca9196681acd278d" translate="yes" xml:space="preserve">
          <source>AUTHOR(S)</source>
          <target state="translated">AUTHOR(S)</target>
        </trans-unit>
        <trans-unit id="5670fa7ed66b0ad342cdfed76ab8fb6f24efd28a" translate="yes" xml:space="preserve">
          <source>AUTHOR..FIRSTNAME</source>
          <target state="translated">AUTHOR..FIRSTNAME</target>
        </trans-unit>
        <trans-unit id="ff0524c02fa0013f0b96ed1fc09f1ed2d16b62a1" translate="yes" xml:space="preserve">
          <source>AUTHOR..LASTNAME</source>
          <target state="translated">AUTHOR..LASTNAME</target>
        </trans-unit>
        <trans-unit id="cba12e8376eed8cb674bdcd3b8e40f2d8f3dd67a" translate="yes" xml:space="preserve">
          <source>AUTHOR/FIRSTNAME</source>
          <target state="translated">AUTHOR/FIRSTNAME</target>
        </trans-unit>
        <trans-unit id="7be1c0b1b6881dd9292aef9d59f1b0c3f56645bf" translate="yes" xml:space="preserve">
          <source>AUTHOR/LASTNAME</source>
          <target state="translated">AUTHOR/LASTNAME</target>
        </trans-unit>
        <trans-unit id="5bba0beb5c3c426ac890b38da7e26c65d0f9467f" translate="yes" xml:space="preserve">
          <source>AUTHOR::FIRSTNAME</source>
          <target state="translated">AUTHOR::FIRSTNAME</target>
        </trans-unit>
        <trans-unit id="7247b4b64be34c0a0d839eaa3ac2a6ae8aa3df25" translate="yes" xml:space="preserve">
          <source>AUTHOR::LASTNAME</source>
          <target state="translated">AUTHOR::LASTNAME</target>
        </trans-unit>
        <trans-unit id="3f6d826824ff426de7d6ac93eea6463af82a601a" translate="yes" xml:space="preserve">
          <source>AUTHORS:[0]:LN</source>
          <target state="translated">AUTHORS:[0]:LN</target>
        </trans-unit>
        <trans-unit id="eb7ccf212a46a7f449a785abeddbcb3700df05c9" translate="yes" xml:space="preserve">
          <source>AUTHORS:[1]:FN</source>
          <target state="translated">AUTHORS:[1]:FN</target>
        </trans-unit>
        <trans-unit id="7343c5e11d03cd762f152e4aca404802887805cd" translate="yes" xml:space="preserve">
          <source>AUTHOR_FIRSTNAME</source>
          <target state="translated">AUTHOR_FIRSTNAME</target>
        </trans-unit>
        <trans-unit id="e18ec4e71a179c7db031ce2f68b79c493f0bae30" translate="yes" xml:space="preserve">
          <source>AUTHOR_LASTNAME</source>
          <target state="translated">AUTHOR_LASTNAME</target>
        </trans-unit>
        <trans-unit id="2f0b21573f390bae4fcc19ddc58c56d2fc023873" translate="yes" xml:space="preserve">
          <source>AUTO INCREMENT</source>
          <target state="translated">자동 증가</target>
        </trans-unit>
        <trans-unit id="21a7e17a976b425553bc577b3148824d2a1f1a44" translate="yes" xml:space="preserve">
          <source>AUTOINCREMENT</source>
          <target state="translated">AUTOINCREMENT</target>
        </trans-unit>
        <trans-unit id="97bfa0716c602feb3a838767af4775ed446c0478" translate="yes" xml:space="preserve">
          <source>AUTO_DOWNLOAD=&quot;yes&quot; ./utils/build.sh innodb51_builtin (build against built-in InnoDB in MySQL 5.1)</source>
          <target state="translated">AUTO_DOWNLOAD = &quot;yes&quot;./utils/build.sh innodb51_builtin (MySQL 5.1의 내장 InnoDB에 대한 빌드)</target>
        </trans-unit>
        <trans-unit id="c362656949d40d609a5cc132f1535e36659fb960" translate="yes" xml:space="preserve">
          <source>AUTO_DOWNLOAD=&quot;yes&quot; ./utils/build.sh innodb55 (build against InnoDB in MySQL 5.5)</source>
          <target state="translated">AUTO_DOWNLOAD = &quot;yes&quot;./utils/build.sh innodb55 (MySQL 5.5의 InnoDB에 대한 빌드)</target>
        </trans-unit>
        <trans-unit id="5ec794beef65027ae454ae73fe14abbef0e5aa60" translate="yes" xml:space="preserve">
          <source>AUTO_DOWNLOAD=&quot;yes&quot; ./utils/build.sh xtradb (build against XtraDB 5.1)</source>
          <target state="translated">AUTO_DOWNLOAD = &quot;yes&quot;./utils/build.sh xtradb (XtraDB 5.1에 대한 빌드)</target>
        </trans-unit>
        <trans-unit id="24b5889f63accf194013d95a8f9eba3fb9805d5f" translate="yes" xml:space="preserve">
          <source>AUTO_DOWNLOAD=&quot;yes&quot; ./utils/build.sh xtradb55 (build against XtraDB 5.5)</source>
          <target state="translated">AUTO_DOWNLOAD = &quot;yes&quot;./utils/build.sh xtradb55 (XtraDB 5.5에 대한 빌드)</target>
        </trans-unit>
        <trans-unit id="a94e16b9c60dfaa959cc02f4c3d57944c9dbfaaa" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT</source>
          <target state="translated">AUTO_INCREMENT</target>
        </trans-unit>
        <trans-unit id="f1fff5cd3a13b9c185b4d0c2b200cf7c5dcfd015" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT -- essentially 0 IOPs</source>
          <target state="translated">AUTO_INCREMENT-본질적으로 0 개의 IOP</target>
        </trans-unit>
        <trans-unit id="d02d2ed41cbf1740f90689f581e6330193f2cbfd" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT FAQ</source>
          <target state="translated">AUTO_INCREMENT FAQ</target>
        </trans-unit>
        <trans-unit id="b4e43c6644ae29c6add8a1f52ef477543ed3ed0d" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT Handling in InnoDB</source>
          <target state="translated">InnoDB에서의 AUTO_INCREMENT 처리</target>
        </trans-unit>
        <trans-unit id="922388234c61ba8e4a7e11be149698b3644db510" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT Lock Modes</source>
          <target state="translated">AUTO_INCREMENT 잠금 모드</target>
        </trans-unit>
        <trans-unit id="dbe16b8524327a13a4c30fe163e5375dfb819fd5" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT Locks</source>
          <target state="translated">AUTO_INCREMENT 잠금</target>
        </trans-unit>
        <trans-unit id="ea8f2d40639cba572dbb79ada24d6c77a4f09786" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT handling in XtraDB/InnoDB</source>
          <target state="translated">XtraDB / InnoDB에서의 AUTO_INCREMENT 처리</target>
        </trans-unit>
        <trans-unit id="50ea315d815d3add35187889fad4ce0080c85db5" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT handling in XtraDB/InnoDB and the lock modes.</source>
          <target state="translated">XtraDB / InnoDB 및 잠금 모드에서 AUTO_INCREMENT 처리</target>
        </trans-unit>
        <trans-unit id="193311af6991d2a48432c00b40508af3564d3677" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT in PARTITION</source>
          <target state="translated">PARTITION의 AUTO_INCREMENT</target>
        </trans-unit>
        <trans-unit id="dba027c55f5a8f289702643eabfd9a5135eb57ca" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT need not be UNIQUE. What you lose: prevention of explicitly inserting a duplicate id. (This is rarely needed, anyway.)</source>
          <target state="translated">AUTO_INCREMENT는 고유하지 않아도됩니다. 잃어버린 것 : 중복 ID를 명시 적으로 삽입하는 것을 방지합니다. (어쨌든 이것은 거의 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="a3e8d8adcaeab603b410785842ccc8f277748afc" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT secrets</source>
          <target state="translated">AUTO_INCREMENT 비밀</target>
        </trans-unit>
        <trans-unit id="1446ccc76f02dc0409ae208b6eb5adc02e9d15e0" translate="yes" xml:space="preserve">
          <source>AUTO_INCREMENT, TIMESTAMP and Virtual Columns</source>
          <target state="translated">AUTO_INCREMENT, TIMESTAMP 및 가상 열</target>
        </trans-unit>
        <trans-unit id="b9b9cbc61f603796c637e2ddce97fe7a7f8d0e55" translate="yes" xml:space="preserve">
          <source>AVERAGE</source>
          <target state="translated">AVERAGE</target>
        </trans-unit>
        <trans-unit id="1e822fce89fdee36d7476135922e827796665f61" translate="yes" xml:space="preserve">
          <source>AVG</source>
          <target state="translated">AVG</target>
        </trans-unit>
        <trans-unit id="2ae5d2e4be31d03af5c3742931eb465e98915d1c" translate="yes" xml:space="preserve">
          <source>AVG()</source>
          <target state="translated">AVG()</target>
        </trans-unit>
        <trans-unit id="4f5af0970b9334a0e63e96eafb265754559f3822" translate="yes" xml:space="preserve">
          <source>AVG() returns NULL if there were no matching rows.</source>
          <target state="translated">일치하는 행이 없으면 AVG ()는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d77ce4b651bfb175815635adc9d7986398eb29c" translate="yes" xml:space="preserve">
          <source>AVG([DISTINCT] column)</source>
          <target state="translated">AVG ([DISTINCT] 열)</target>
        </trans-unit>
        <trans-unit id="328219088ac73c8b8e1479e14659564e04351003" translate="yes" xml:space="preserve">
          <source>AVGS</source>
          <target state="translated">AVGS</target>
        </trans-unit>
        <trans-unit id="aa82f276e415bc2b6b10737a851a028561a81400" translate="yes" xml:space="preserve">
          <source>AVGSUM</source>
          <target state="translated">AVGSUM</target>
        </trans-unit>
        <trans-unit id="57bb60654c21e0983dce2cfcd94833378eb0799e" translate="yes" xml:space="preserve">
          <source>AWS Certifications Keys - Access and Secret Keys</source>
          <target state="translated">AWS 인증 키-액세스 및 비밀 키</target>
        </trans-unit>
        <trans-unit id="eceb9ff0cb2a04254483b8805444d8da61045aff" translate="yes" xml:space="preserve">
          <source>AWS KMS Key Policy</source>
          <target state="translated">AWS KMS 키 정책</target>
        </trans-unit>
        <trans-unit id="0aac9007a964de733c021bdb70d090ac2a6a7b29" translate="yes" xml:space="preserve">
          <source>AWS KMS allows flexible, user-editable key policy. This offers fine-grained control over which users can operate on keys. The possibilities range from simply restricting which IP addresses are allowed to perform operations on the key, to requiring a MFA (Multi-Factor Authentication) device to use the key, to enforcing separation of responsibilities by creating an additional user with limited privileges to enable and disable the key. All 3 of these options will be outlined in this section.</source>
          <target state="translated">AWS KMS는 유연하고 사용자가 편집 할 수있는 키 정책을 허용합니다. 이를 통해 사용자가 키를 조작 할 수있는 세밀한 제어가 가능합니다. 키에 대한 작업을 수행 할 수있는 IP 주소를 제한하는 것부터 키를 사용하도록 MFA (Multi-Factor Authentication) 장치를 요구하는 것부터 활성화 할 수있는 권한이 제한된 추가 사용자를 생성하여 책임을 분리하는 것까지 다양한 가능성이 있습니다. 키를 비활성화하십시오. 이러한 옵션 중 3 가지가 모두이 섹션에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8895b9ec4a8186bf3c5099ee6ef56a04075d443b" translate="yes" xml:space="preserve">
          <source>AWS KMS plugin option reference</source>
          <target state="translated">AWS KMS 플러그인 옵션 참조</target>
        </trans-unit>
        <trans-unit id="68245423ecdfef5e3d7240d533814aa8866dcbdd" translate="yes" xml:space="preserve">
          <source>AWS Key Management Encryption Plugin</source>
          <target state="translated">AWS 키 관리 암호화 플러그인</target>
        </trans-unit>
        <trans-unit id="8b7ed3b3c27d438baf160581b8e86ce05226cdda" translate="yes" xml:space="preserve">
          <source>AWS Key Management Plugin</source>
          <target state="translated">AWS 키 관리 플러그인</target>
        </trans-unit>
        <trans-unit id="2d8e172719107b56ffebf9a8351129dee17ac03e" translate="yes" xml:space="preserve">
          <source>AWS Management Console page</source>
          <target state="translated">AWS Management Console 페이지</target>
        </trans-unit>
        <trans-unit id="dfdf8d5d139d76f9f92c1f321d9ff9a5804e84aa" translate="yes" xml:space="preserve">
          <source>AWS access key ID</source>
          <target state="translated">AWS 액세스 키 ID</target>
        </trans-unit>
        <trans-unit id="aaca30b0bba485cf893d0aa9b64ace9696dc11a9" translate="yes" xml:space="preserve">
          <source>AWS credentials can also be put directly into a &quot;drop-in&quot; systemd file that will be read when starting the MariaDB service:</source>
          <target state="translated">또한 AWS 자격 증명을 MariaDB 서비스를 시작할 때 읽을 &quot;드롭 인&quot;시스템 파일에 직접 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1fd6e3f42bd732cd5d2776e955e9caf2cad0444" translate="yes" xml:space="preserve">
          <source>AWS instance sizes</source>
          <target state="translated">AWS 인스턴스 크기</target>
        </trans-unit>
        <trans-unit id="9773fbbc3960b1975be5c8b976f4a9c49ecff0b8" translate="yes" xml:space="preserve">
          <source>AWS prefix for tables</source>
          <target state="translated">테이블 용 AWS 접두사</target>
        </trans-unit>
        <trans-unit id="81664b8730a5d7f48a61eeb67029aa2a73ce357b" translate="yes" xml:space="preserve">
          <source>AWS region</source>
          <target state="translated">AWS 리전</target>
        </trans-unit>
        <trans-unit id="b6ccb376e71332f28bbbf10b7c5cc731d9f3ed4b" translate="yes" xml:space="preserve">
          <source>AWS secret access key ID</source>
          <target state="translated">AWS 비밀 액세스 키 ID</target>
        </trans-unit>
        <trans-unit id="174018f03d9d71a094fc66067ddf40c1bcecc584" translate="yes" xml:space="preserve">
          <source>Abata</source>
          <target state="translated">Abata</target>
        </trans-unit>
        <trans-unit id="b9c082d72808f1c38725af3ac5e81e12c6280c92" translate="yes" xml:space="preserve">
          <source>Abatz</source>
          <target state="translated">Abatz</target>
        </trans-unit>
        <trans-unit id="5457e4d5deac17ffe27b27f2d8ca23a9421bf7e5" translate="yes" xml:space="preserve">
          <source>Ability to browse schema objects in a single editor (pin document option)</source>
          <target state="translated">단일 편집기에서 스키마 객체를 탐색하는 기능 (문서 고정 옵션)</target>
        </trans-unit>
        <trans-unit id="14cd174e8d596502d3b32b630ecff2d1e695a13d" translate="yes" xml:space="preserve">
          <source>Ability to browse schema objects in a single editor (pin document)</source>
          <target state="translated">단일 편집기에서 스키마 객체를 탐색하는 기능 (핀 문서)</target>
        </trans-unit>
        <trans-unit id="6f254e928d2360a1b541914cb474843343b3d76e" translate="yes" xml:space="preserve">
          <source>Ability to exclude some record types during comparison</source>
          <target state="translated">비교하는 동안 일부 레코드 유형을 제외하는 기능</target>
        </trans-unit>
        <trans-unit id="ac4a0d074a336294b68dacee31cd19bbdc4a1f54" translate="yes" xml:space="preserve">
          <source>Ability to limit result set sizes</source>
          <target state="translated">결과 세트 크기를 제한하는 기능</target>
        </trans-unit>
        <trans-unit id="feebb30d51a5c2d14092cadf48ef242451513cff" translate="yes" xml:space="preserve">
          <source>Ability to postpone sending of data updates to the server (Cached updates mode)</source>
          <target state="translated">서버로 데이터 업데이트 전송을 연기하는 기능 (캐시 된 업데이트 모드)</target>
        </trans-unit>
        <trans-unit id="79bb65357d1036a0f16f9564a5b7cdba2dfd0dfa" translate="yes" xml:space="preserve">
          <source>Abort 'source filename' operations in case of errors.</source>
          <target state="translated">오류가 발생하면 '소스 파일 이름'작업을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="2508f2becb47c4034da8beccc946ac4b5695dbb6" translate="yes" xml:space="preserve">
          <source>Abort if we can't find/read the maria_log_control file</source>
          <target state="translated">maria_log_control 파일을 찾거나 읽을 수 없으면 중단</target>
        </trans-unit>
        <trans-unit id="76385c5ef502301498371425e4f34aa5a6631592" translate="yes" xml:space="preserve">
          <source>Aborted connection %ld to db: '%s' user: '%s' (%s)</source>
          <target state="translated">연결 % ld을 db로 중단 : '% s'사용자 : '% s'(% s)</target>
        </trans-unit>
        <trans-unit id="ed0a7b01f9ec5c326171497642b42ea6308390db" translate="yes" xml:space="preserve">
          <source>Aborted connection %ld to db: '%s' user: '%s' host: '%s' (%s)</source>
          <target state="translated">연결 % ld을 (를) db : '% s'사용자 : '% s'호스트 : '% s'(% s)에 중단했습니다.</target>
        </trans-unit>
        <trans-unit id="1f5b6942842c7d59b39c070f8599cae3a9013f4f" translate="yes" xml:space="preserve">
          <source>Aborted_clients</source>
          <target state="translated">Aborted_clients</target>
        </trans-unit>
        <trans-unit id="a8a6aef71353c0bf7b99005796f40d2aa3ebf5f7" translate="yes" xml:space="preserve">
          <source>Aborted_connects</source>
          <target state="translated">Aborted_connects</target>
        </trans-unit>
        <trans-unit id="3bd02063712fd2554e3e6c96faca51eda6cb658f" translate="yes" xml:space="preserve">
          <source>Aborted_connects_preauth</source>
          <target state="translated">Aborted_connects_preauth</target>
        </trans-unit>
        <trans-unit id="e6d25dd09ca5cefc6357f5131f544a2ab43a1a68" translate="yes" xml:space="preserve">
          <source>Aborting &lt;code&gt;ALTER TABLE ... ALGORITHM=COPY&lt;/code&gt; was made faster by removing excessive undo logging (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-11415&quot;&gt;MDEV-11415&lt;/a&gt;). This significantly shortens the time it takes to abort a running ALTER TABLE operation.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE ... ALGORITHM=COPY&lt;/code&gt; 중지 ... ALGORITHM = COPY 는 과도한 실행 취소 로깅 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-11415&quot;&gt;MDEV-11415&lt;/a&gt; ) 을 제거하여 더 빨라졌습니다 . 이렇게하면 실행중인 ALTER TABLE 작업을 중단하는 데 걸리는 시간이 크게 단축됩니다.</target>
        </trans-unit>
        <trans-unit id="814d32e56b4bdc1eedccff7c635d4abe6692d173" translate="yes" xml:space="preserve">
          <source>Aborting ALTER TABLE Operations</source>
          <target state="translated">ALTER TABLE 작업 중단</target>
        </trans-unit>
        <trans-unit id="4c1113bfa386dc5dcaccc245da5c6745f6fd12d1" translate="yes" xml:space="preserve">
          <source>Aborting Statements that Exceed a Certain Time to Execute</source>
          <target state="translated">특정 실행 시간을 초과 한 진술 중단</target>
        </trans-unit>
        <trans-unit id="af656cb2e2f3b79e2651800c0021782bfe900f7f" translate="yes" xml:space="preserve">
          <source>Aborting statements that exceed a certain time to execute</source>
          <target state="translated">실행 시간이 초과 된 명령문 중단</target>
        </trans-unit>
        <trans-unit id="58963ff941f83f320b233d9889172ed7d507d4c0" translate="yes" xml:space="preserve">
          <source>Aborting statements that take longer than a certain time to execute</source>
          <target state="translated">실행하는 데 특정 시간보다 오래 걸리는 명령문 중단</target>
        </trans-unit>
        <trans-unit id="b69428bc08845e1d0cf34e16d638fe8869a974b5" translate="yes" xml:space="preserve">
          <source>Aborting statements that take longer than a certain time to execute.</source>
          <target state="translated">실행하는 데 특정 시간보다 오래 걸리는 명령문을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="6b21fb791ac05170893860c248401cd24a59b732" translate="yes" xml:space="preserve">
          <source>About</source>
          <target state="translated">About</target>
        </trans-unit>
        <trans-unit id="a9d57ecabff74aebd3179840590a7a7e6499d4c9" translate="yes" xml:space="preserve">
          <source>About CVEs</source>
          <target state="translated">CVE 정보</target>
        </trans-unit>
        <trans-unit id="017d5ff92915b2c78110d67f7965f6c5d62f22be" translate="yes" xml:space="preserve">
          <source>About Devart</source>
          <target state="translated">Devart 소개</target>
        </trans-unit>
        <trans-unit id="e9bd4fb7ad9eada913c5b83156e0eea53a1da18d" translate="yes" xml:space="preserve">
          <source>About FederatedX</source>
          <target state="translated">FederatedX 정보</target>
        </trans-unit>
        <trans-unit id="2e93e7b46494ee7525027b30a55df2e692d62d5b" translate="yes" xml:space="preserve">
          <source>About Galera Replication</source>
          <target state="translated">Galera 복제 정보</target>
        </trans-unit>
        <trans-unit id="359ab6a77175e16119caacac84e589712105c794" translate="yes" xml:space="preserve">
          <source>About Galera replication.</source>
          <target state="translated">Galera 복제 정보.</target>
        </trans-unit>
        <trans-unit id="54a1aeeb518d0e9621d1232d141934869b5bd6ae" translate="yes" xml:space="preserve">
          <source>About MariaDB ColumnStore</source>
          <target state="translated">MariaDB ColumnStore 정보</target>
        </trans-unit>
        <trans-unit id="7c55e3390f562e8992c226389d3be00478f35eb7" translate="yes" xml:space="preserve">
          <source>About Mroonga</source>
          <target state="translated">Mroonga 소개</target>
        </trans-unit>
        <trans-unit id="36eaf15d9689622acbb9ee4b45af48f92e4f5140" translate="yes" xml:space="preserve">
          <source>About MyRocks for MariaDB</source>
          <target state="translated">MariaDB 용 MyRocks 정보</target>
        </trans-unit>
        <trans-unit id="e448a1c896ba39d44d0e80dd68ba2b93c72e2dd2" translate="yes" xml:space="preserve">
          <source>About PBXT</source>
          <target state="translated">PBXT 소개</target>
        </trans-unit>
        <trans-unit id="cbd380a16572ad171ccdbddde13dc7b6fcfcf6b7" translate="yes" xml:space="preserve">
          <source>About SHOW</source>
          <target state="translated">SHOW 소개</target>
        </trans-unit>
        <trans-unit id="51156db87bed7b4d131cf4e3a375d096d712dcb0" translate="yes" xml:space="preserve">
          <source>About Segmented Key Cache</source>
          <target state="translated">세그먼트 키 캐시 정보</target>
        </trans-unit>
        <trans-unit id="fb706efac19e70d28322b2c5da1ae5788d446cb6" translate="yes" xml:space="preserve">
          <source>About SphinxSE</source>
          <target state="translated">스핑크스 소개</target>
        </trans-unit>
        <trans-unit id="0e8dd04569df7d6a9c4a5d89eef7ab741965d24a" translate="yes" xml:space="preserve">
          <source>About XtraDB</source>
          <target state="translated">XtraDB 소개</target>
        </trans-unit>
        <trans-unit id="2e076ba876cfd63a515f63413f11aba5f5c6bd0f" translate="yes" xml:space="preserve">
          <source>About innodb_use_atomic_writes (in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;)</source>
          <target state="translated">innodb_use_atomic_writes 정보 ( &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; ~ &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c359f74b7c3d1c0092e5bbb449c1c61b7e935bfe" translate="yes" xml:space="preserve">
          <source>About pool of threads</source>
          <target state="translated">스레드 풀 정보</target>
        </trans-unit>
        <trans-unit id="544e867b1cb439acd2511e5979adba202c61c480" translate="yes" xml:space="preserve">
          <source>About the MariaDB RPM Files</source>
          <target state="translated">MariaDB RPM 파일 정보</target>
        </trans-unit>
        <trans-unit id="9362751e153d012a26914d7fd50edbdc8c4c9d49" translate="yes" xml:space="preserve">
          <source>About the Server System Variables</source>
          <target state="translated">서버 시스템 변수</target>
        </trans-unit>
        <trans-unit id="000496e42d9a8683986bd38b6565d3b31b583393" translate="yes" xml:space="preserve">
          <source>About the Sphinx Storage Engine</source>
          <target state="translated">스핑크스 스토리지 엔진 정보</target>
        </trans-unit>
        <trans-unit id="406a234639f65b19c198a735eba23a61cb3fed4d" translate="yes" xml:space="preserve">
          <source>About the mysql Command-Line Client</source>
          <target state="translated">mysql 명령 줄 클라이언트</target>
        </trans-unit>
        <trans-unit id="487e45a72963a9997d730a561928eafb14842e00" translate="yes" xml:space="preserve">
          <source>About this release</source>
          <target state="translated">이 릴리스에 대하여</target>
        </trans-unit>
        <trans-unit id="942e8794ed84be13de31f816ab428340fce1014b" translate="yes" xml:space="preserve">
          <source>About to initialize an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;, &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; statement. Could be performaing &lt;a href=&quot;../query-cache/index&quot;&gt;query cache&lt;/a&gt; cleanup, or flushing the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; or InnoDB log.</source>
          <target state="translated">&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; , &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 문 을 초기화하려고 합니다. &lt;a href=&quot;../query-cache/index&quot;&gt;쿼리 캐시&lt;/a&gt; 정리를 수행하거나 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 또는 InnoDB 로그를 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30bbdd8dd163f4555ab009cdf442b4d4eee5ce19" translate="yes" xml:space="preserve">
          <source>About to insert rows into the table.</source>
          <target state="translated">테이블에 행을 삽입하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8e5219e804dcdbb721b5c7f09a03248eb0b1a30b" translate="yes" xml:space="preserve">
          <source>About to request a table's &lt;em&gt;internal&lt;/em&gt; lock after acquiring the table's &lt;em&gt;external&lt;/em&gt; lock. This thread state occurs after the &lt;em&gt;System lock&lt;/em&gt; thread state.</source>
          <target state="translated">테이블의 &lt;em&gt;외부&lt;/em&gt; 잠금을 획득 한 후 테이블의 &lt;em&gt;내부&lt;/em&gt; 잠금 을 요청하려고합니다 . 이 스레드 상태는 &lt;em&gt;시스템 잠금&lt;/em&gt; 스레드 상태 후에 발생합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a221b666a1ee57fd2d3b804aa2818f59d01631e5" translate="yes" xml:space="preserve">
          <source>About to request or waiting for an advisory lock from a &lt;a href=&quot;../get_lock/index&quot;&gt;GET LOCK()&lt;/a&gt; call. For &lt;a href=&quot;../show-profile/index&quot;&gt;SHOW PROFILE&lt;/a&gt;, means requesting a lock only.</source>
          <target state="translated">&lt;a href=&quot;../get_lock/index&quot;&gt;GET LOCK ()&lt;/a&gt; 호출 에서 권고 잠금을 요청하거나 대기하려고 합니다. 내용은 &lt;a href=&quot;../show-profile/index&quot;&gt;SHOW 프로필&lt;/a&gt; 만 잠금을 요청하는 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="fa1be60bf48045656f4229642730de8358be377d" translate="yes" xml:space="preserve">
          <source>About to start updating table.</source>
          <target state="translated">테이블 업데이트를 시작하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bad47b29a6080f9e4c987378c0357fe2b957747a" translate="yes" xml:space="preserve">
          <source>Above '$PWD' is the environment variable that points to your current directory. If you added &lt;code&gt;datadir&lt;/code&gt; to your &lt;code&gt;my.cnf&lt;/code&gt;, you don't have to give this option above. Also above, --user=$LOGNAME is necessary when using msqyld 10.0.1-MariaDB (and possibly other versions)</source>
          <target state="translated">위의 '$ PWD'는 현재 디렉토리를 가리키는 환경 변수입니다. &lt;code&gt;my.cnf&lt;/code&gt; 에 &lt;code&gt;datadir&lt;/code&gt; 을 추가 한 경우 위의 옵션을 지정할 필요가 없습니다. 또한 msqyld 10.0.1-MariaDB (및 기타 버전)를 사용하는 경우 --user = $ LOGNAME이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fff32a35255d7fc15b32dcba93d55e5e8b08ddc0" translate="yes" xml:space="preserve">
          <source>Absolute and Relative Numeric Backreferences</source>
          <target state="translated">절대 및 상대 숫자 역 참조</target>
        </trans-unit>
        <trans-unit id="3f17b6ba233ea4ee769ed8074fb2a4188dbfa94e" translate="yes" xml:space="preserve">
          <source>Abstract number representing the time the page was first accessed.</source>
          <target state="translated">페이지에 처음 액세스 한 시간을 나타내는 추상 번호입니다.</target>
        </trans-unit>
        <trans-unit id="66abf96dcd935afa8f9ac9c9d287c9bacb5072e0" translate="yes" xml:space="preserve">
          <source>Abstract numbers with at least &lt;em&gt;NUM&lt;/em&gt; digits within names</source>
          <target state="translated">이름 내에 &lt;em&gt;NUM&lt;/em&gt; 자리 이상의 추상 숫자</target>
        </trans-unit>
        <trans-unit id="bb54db510a92908a5a4df79fc1ad1eae8df50ec3" translate="yes" xml:space="preserve">
          <source>Accept</source>
          <target state="translated">Accept</target>
        </trans-unit>
        <trans-unit id="49288682b602c65e67b3d831a186c4b91bb46f5e" translate="yes" xml:space="preserve">
          <source>Accepting a string or a number:</source>
          <target state="translated">문자열 또는 숫자 수락 :</target>
        </trans-unit>
        <trans-unit id="de2580d4f07f9405dead6e40aaaf779cd776fe91" translate="yes" xml:space="preserve">
          <source>Access Mode</source>
          <target state="translated">액세스 모드</target>
        </trans-unit>
        <trans-unit id="f7338d14981c9af199cb5d0c53e9fd86ec71dd18" translate="yes" xml:space="preserve">
          <source>Access Type</source>
          <target state="translated">접근 유형</target>
        </trans-unit>
        <trans-unit id="0f5ee9e5f022be6e432741958d4ebe0fd30bc413" translate="yes" xml:space="preserve">
          <source>Access and returns a json item by a JPATH key.</source>
          <target state="translated">JPATH 키로 json 항목에 액세스하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="81280cd9edc8bb9c5d090f660c1fcfc3e5ace53d" translate="yes" xml:space="preserve">
          <source>Access and returns a real element by a JPATH key.</source>
          <target state="translated">JPATH 키로 실제 요소에 액세스하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="71fbf21f49c393c4e72d485e89012ff868f3c4b1" translate="yes" xml:space="preserve">
          <source>Access and returns a string element by a JPATH key.</source>
          <target state="translated">JPATH 키로 문자열 요소에 액세스하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9adb16493aad02cae54e7bda66bef770fea2db9e" translate="yes" xml:space="preserve">
          <source>Access and returns an integer element by a JPATH key.</source>
          <target state="translated">JPATH 키로 정수 요소에 액세스하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f79da466a293c3618618bb405cdcca8fb56bd735" translate="yes" xml:space="preserve">
          <source>Access denied errors.</source>
          <target state="translated">액세스 거부 오류</target>
        </trans-unit>
        <trans-unit id="1eefd91934e9af1fa19c82378113c496c02939f6" translate="yes" xml:space="preserve">
          <source>Access denied for user '%s'@'%s'</source>
          <target state="translated">사용자 '% s'@ '% s'에 대한 액세스가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e208e6c75da5a3d209ca00104d6195896f4b961" translate="yes" xml:space="preserve">
          <source>Access denied for user '%s'@'%s' (using password: %s)</source>
          <target state="translated">사용자 '% s'@ '% s'에 대한 액세스가 거부되었습니다 (암호 사용 : % s).</target>
        </trans-unit>
        <trans-unit id="733617798b1855480f0f22d9584a2a2f8a81a76f" translate="yes" xml:space="preserve">
          <source>Access denied for user '%s'@'%s' to database '%s'</source>
          <target state="translated">데이터베이스 '% s'에 대한 사용자 '% s'@ '% s'에 대한 액세스가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="9602ef45d8d406d4b2001e97c614500e847c0b86" translate="yes" xml:space="preserve">
          <source>Access denied trying to change to user '%s'@'%s' (using password: %s). Disconnecting.</source>
          <target state="translated">액세스가 사용자 '% s'@ '% s'(암호 : % s)로 변경을 거부했습니다. 연결 해제</target>
        </trans-unit>
        <trans-unit id="9e154160b449bf29675037a339eec4951995e614" translate="yes" xml:space="preserve">
          <source>Access denied; you need (at least one of) the %s privilege(s) for this operation</source>
          <target state="translated">접근 불가; 이 작업에 대해 % s 권한이 필요합니다 (적어도 하나 이상).</target>
        </trans-unit>
        <trans-unit id="ac31054a25afac9e99c86077dab1966cb2ed65ed" translate="yes" xml:space="preserve">
          <source>Access of subpart of json by JPATH that can include calculations on arrays.</source>
          <target state="translated">배열에 대한 계산을 포함 할 수있는 JPATH에 의해 json의 하위 부분에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="bfbaeaaa511a2e7774d64facdb2562cfa508e7c9" translate="yes" xml:space="preserve">
          <source>Access tables belonging to the current or another server</source>
          <target state="translated">현재 또는 다른 서버에 속하는 액세스 테이블</target>
        </trans-unit>
        <trans-unit id="bb064757d4edf238cdbd30cae8bd5867393db2bb" translate="yes" xml:space="preserve">
          <source>Access tables from the PlugDB DBMS.</source>
          <target state="translated">PlugDB DBMS에서 테이블에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="0a8cb6e745c5606f4e018405ff4da6fd672df761" translate="yes" xml:space="preserve">
          <source>Access the server</source>
          <target state="translated">서버에 액세스</target>
        </trans-unit>
        <trans-unit id="0bd1984b9f7e469264f0238c3d18b9a294dea5a7" translate="yes" xml:space="preserve">
          <source>Access through a storage engine will additionally allow:</source>
          <target state="translated">스토리지 엔진을 통한 액세스는 다음을 추가로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d8335ea031a80982aa5ed7562bf6c27aa5b8966b" translate="yes" xml:space="preserve">
          <source>Access to Launched AMI Instance</source>
          <target state="translated">시작된 AMI 인스턴스에 액세스</target>
        </trans-unit>
        <trans-unit id="dc7ee98390df35cbed98d8d573bb31831390db94" translate="yes" xml:space="preserve">
          <source>Access to the API will now be restricted to requests coming from the IP address or range of IP addresses specified in the policy.</source>
          <target state="translated">이제 API에 대한 액세스는 정책에 지정된 IP 주소 또는 IP 주소 범위에서 오는 요청으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3092ceb05ea3dbf133516663a492bcd9d62c2d17" translate="yes" xml:space="preserve">
          <source>Access_denied_errors</source>
          <target state="translated">Access_denied_errors</target>
        </trans-unit>
        <trans-unit id="9a6c35d5cdec826c322378ec9cfb32b55e64a71d" translate="yes" xml:space="preserve">
          <source>Accessed only via id</source>
          <target state="translated">ID를 통해서만 액세스</target>
        </trans-unit>
        <trans-unit id="e4ea6766cad008476a1a71d0e2f17b820c057847" translate="yes" xml:space="preserve">
          <source>Accesses data from a following row in the same result set without the need for a self-join.</source>
          <target state="translated">자체 조인없이 동일한 결과 집합에서 다음 행의 데이터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="1317a242e677f2143a161ab9879e59eb6c4e5dca" translate="yes" xml:space="preserve">
          <source>Accesses data from a previous row in the same result set without the need for a self-join.</source>
          <target state="translated">자체 조인없이 동일한 결과 집합에서 이전 행의 데이터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="ceedb8677c6474fbc65bc89fc0d4c729e769ac28" translate="yes" xml:space="preserve">
          <source>Accessing MongDB from CONNECT</source>
          <target state="translated">CONNECT에서 MongDB에 액세스</target>
        </trans-unit>
        <trans-unit id="6d1116c6db7e8a4bb3403a6233a79f2854d7b8d5" translate="yes" xml:space="preserve">
          <source>Accessing MongoDB from CONNECT can be done in different ways:</source>
          <target state="translated">CONNECT에서 MongoDB에 액세스하는 방법은 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16fea4f667c925cae7160d89f85f63ca17e8f19e" translate="yes" xml:space="preserve">
          <source>Accessing a MySQL or MariaDB table or view</source>
          <target state="translated">MySQL 또는 MariaDB 테이블 또는 뷰에 액세스</target>
        </trans-unit>
        <trans-unit id="31d9b5a1c48f709cc2f0bbcb20ce7fb56e2f9b6c" translate="yes" xml:space="preserve">
          <source>Accessing a collection of tables as one table (like the MERGE engine does for MyIsam tables)</source>
          <target state="translated">하나의 테이블로 테이블 콜렉션에 액세스 (MERGE 엔진이 MyIsam 테이블에 대해 수행하는 것처럼)</target>
        </trans-unit>
        <trans-unit id="fb09bb75c536092ba782184c211384d1473ee22a" translate="yes" xml:space="preserve">
          <source>Accessing a table on S3 can take some time , especially if you are using big packets (&lt;a href=&quot;../s3-storage-engine-system-variables/index#s3_block_size&quot;&gt;s3_block_size&lt;/a&gt;). However the second access to the same data should be fast as it's then cached in the S3 page cache.</source>
          <target state="translated">특히 큰 패킷을 사용하는 경우 ( &lt;a href=&quot;../s3-storage-engine-system-variables/index#s3_block_size&quot;&gt;s3_block_size&lt;/a&gt; ) S3의 테이블에 액세스하는 데 시간이 걸릴 수 있습니다 . 그러나 동일한 데이터에 대한 두 번째 액세스는 S3 페이지 캐시에 캐시되는 것처럼 빨라야합니다.</target>
        </trans-unit>
        <trans-unit id="3ce6e8b5b27db8b35bdcddabbf5b4ea60e2230f7" translate="yes" xml:space="preserve">
          <source>Accessing specified views</source>
          <target state="translated">지정된 뷰에 액세스</target>
        </trans-unit>
        <trans-unit id="69bc8845abc92f21736978385572e7dacd106ce4" translate="yes" xml:space="preserve">
          <source>Accessing specified views (SRCDEF)</source>
          <target state="translated">지정된 뷰에 액세스 (SRCDEF)</target>
        </trans-unit>
        <trans-unit id="922e11c40e55391f5930cf7c34e7368225fbe368" translate="yes" xml:space="preserve">
          <source>Accessing the Container</source>
          <target state="translated">컨테이너에 액세스</target>
        </trans-unit>
        <trans-unit id="3aa0f0b4c8caf6dc79cb2be8f8176cf55186b6a2" translate="yes" xml:space="preserve">
          <source>Accessing this table via JDBC by:</source>
          <target state="translated">다음을 통해 JDBC를 통해이 테이블에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="c1ce71129cc15c5043ba9c748ed5ea84c1e4d624" translate="yes" xml:space="preserve">
          <source>Accor</source>
          <target state="translated">Accor</target>
        </trans-unit>
        <trans-unit id="3c290ed8c2c8825b3a425d536d219aee5a43263e" translate="yes" xml:space="preserve">
          <source>According to anchor modeling, each attribute should go into its own table:</source>
          <target state="translated">앵커 모델링에 따르면 각 속성은 자체 테이블로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="4929307b70990ca369bb05d09ce9d6c798dcac0d" translate="yes" xml:space="preserve">
          <source>According to the &lt;a href=&quot;../clientserver-protocol/index&quot;&gt;client-server protocol&lt;/a&gt;, the server first sends the handshake packet to the client, then the client replies with a packet containing the user name of the user account that is requesting access. The server handshake packet initially tells the client to use the default server authentication plugin, and the client reply initially tells the server that it will use the default client authentication plugin.</source>
          <target state="translated">&lt;a href=&quot;../clientserver-protocol/index&quot;&gt;클라이언트-서버 프로토콜&lt;/a&gt; 에 따르면 , 서버는 먼저 핸드 셰이크 패킷을 클라이언트에게 보낸 다음 클라이언트는 액세스를 요청하는 사용자 계정의 사용자 이름이 포함 된 패킷으로 응답합니다. 서버 핸드 쉐이크 패킷은 초기에 클라이언트에게 기본 서버 인증 플러그인을 사용하도록 지시하고 클라이언트 응답은 초기에 서버에 기본 클라이언트 인증 플러그인을 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="27438aa21e1dba200f0ad6dda5f55b01d13e0e9c" translate="yes" xml:space="preserve">
          <source>Account Locking</source>
          <target state="translated">계정 잠금</target>
        </trans-unit>
        <trans-unit id="3f45218c35f85b2318591abecbfadf8cc896ca12" translate="yes" xml:space="preserve">
          <source>Account Management SQL Commands</source>
          <target state="translated">계정 관리 SQL 명령</target>
        </trans-unit>
        <trans-unit id="754c84d95ce8e7d21ba529074dc88401e6dc4f06" translate="yes" xml:space="preserve">
          <source>Account Names</source>
          <target state="translated">계정 이름</target>
        </trans-unit>
        <trans-unit id="d6650831948e0bab0dc991bef49e8b7128ecbc77" translate="yes" xml:space="preserve">
          <source>Account connection information</source>
          <target state="translated">계정 연결 정보</target>
        </trans-unit>
        <trans-unit id="65b7874225ee37ed06f3686ad43e04a0abbcd9e0" translate="yes" xml:space="preserve">
          <source>Account granted the privilege in the format &lt;code&gt;user_name@host_name&lt;/code&gt;.</source>
          <target state="translated">계정은 &lt;code&gt;user_name@host_name&lt;/code&gt; 형식으로 권한을 부여했습니다 .</target>
        </trans-unit>
        <trans-unit id="80e78009145b70a2d69d1f77d41a92a53cf178a1" translate="yes" xml:space="preserve">
          <source>Account locking permits privileged administrators to lock/unlock user accounts.</source>
          <target state="translated">계정 잠금을 통해 권한있는 관리자가 사용자 계정을 잠 그거나 잠금 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df06b383dd495644410b1844e5439c698e0f7b87" translate="yes" xml:space="preserve">
          <source>Account locking permits privileged administrators to lock/unlock user accounts. No new client connections will be permitted if an account is locked (existing connections are not affected).</source>
          <target state="translated">계정 잠금을 통해 권한있는 관리자가 사용자 계정을 잠 그거나 잠금 해제 할 수 있습니다. 계정이 잠기면 새 클라이언트 연결이 허용되지 않습니다 (기존 연결은 영향을받지 않음).</target>
        </trans-unit>
        <trans-unit id="c172de4aabe758b77130b834bf3d03a8052608cc" translate="yes" xml:space="preserve">
          <source>Account locking permits privileged administrators to lock/unlock user accounts. No new client connections will be permitted if an account is locked (existing connections are not affected). For example:</source>
          <target state="translated">계정 잠금을 통해 권한있는 관리자가 사용자 계정을 잠 그거나 잠금 해제 할 수 있습니다. 계정이 잠기면 새 클라이언트 연결이 허용되지 않습니다 (기존 연결은 영향을받지 않음). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ad6de1a5c1b8231bcc17172b710031e6fd5bfdc" translate="yes" xml:space="preserve">
          <source>Account locking was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1042-release-notes/&quot;&gt;MariaDB 10.4.2&lt;/a&gt;.</source>
          <target state="translated">계정 잠금은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1042-release-notes/&quot;&gt;MariaDB 10.4.2&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="debb787f93c5288c91e7533c8a9db2cc78a10784" translate="yes" xml:space="preserve">
          <source>Account names have both a user name component and a host name component, and are specified as &lt;code&gt;'user_name'@'host_name'&lt;/code&gt;.</source>
          <target state="translated">계정 이름은 사용자 이름 구성 요소와 호스트 이름 구성 요소를 모두 가지며 &lt;code&gt;'user_name'@'host_name'&lt;/code&gt; 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5cb8b72723a71b6fbca2643436a32b88750af16" translate="yes" xml:space="preserve">
          <source>Account specified in the DEFINER clause (or the default when created).</source>
          <target state="translated">DEFINER 절에 지정된 계정 (또는 작성시 기본값)</target>
        </trans-unit>
        <trans-unit id="52c39e902d4995c115ee194e5365aa9a7b7b6c2a" translate="yes" xml:space="preserve">
          <source>Account that the role was granted to.</source>
          <target state="translated">역할이 부여 된 계정</target>
        </trans-unit>
        <trans-unit id="8a0abf322a82af1ab6789bc2b2e40b54442a9651" translate="yes" xml:space="preserve">
          <source>Account user name being used to connect to the master.</source>
          <target state="translated">마스터에 연결하는 데 사용되는 계정 사용자 이름</target>
        </trans-unit>
        <trans-unit id="03552536f0e237611c12d0d5edce8e894df929dc" translate="yes" xml:space="preserve">
          <source>Accounts used by slave servers on the master need this privilege. This is needed to get the updates made on the master.</source>
          <target state="translated">마스터에서 슬레이브 서버가 사용하는 계정에는이 권한이 필요합니다. 마스터에서 업데이트를 받으려면이 과정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="85d822637a6953eb20de710098b53e8c581dc24f" translate="yes" xml:space="preserve">
          <source>Accounts with a non-empty user name sort before accounts with an empty user name.</source>
          <target state="translated">비어 있지 않은 사용자 이름을 가진 계정은 빈 사용자 이름을 가진 계정보다 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="47568ce5fb5c544e7fb73e83e63f6aca177ffb2c" translate="yes" xml:space="preserve">
          <source>Accounts with a wildcard in the host name are sorted according to the position of the first wildcard character. Those with a wildcard character later in the host name sort before those with a wildcard character earlier in the host name.</source>
          <target state="translated">호스트 이름에 와일드 카드가있는 계정은 첫 번째 와일드 카드 문자의 위치에 따라 정렬됩니다. 호스트 이름 뒤에 와일드 카드 문자가있는 호스트 이름 앞에 와일드 카드 문자가있는 사용자보다 먼저 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="835490aee71fa45e8042ac8d8ec393896fcd02d5" translate="yes" xml:space="preserve">
          <source>Accounts with an empty user name are sorted last. As mentioned previously, these are known as anonymous accounts. These are described more in the next section.</source>
          <target state="translated">빈 사용자 이름을 가진 계정이 마지막으로 정렬됩니다. 앞에서 언급했듯이이를 익명 계정이라고합니다. 이에 대해서는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7976bd390884f3c16960f7b327536a7a1bff2278" translate="yes" xml:space="preserve">
          <source>Accounts with an exact host name are sorted before accounts using a wildcard in the host name. Host names using a netmask are considered to be exact for sorting.</source>
          <target state="translated">호스트 이름이 정확한 계정은 호스트 이름에 와일드 카드를 사용하는 계정보다 먼저 정렬됩니다. 넷 마스크를 사용하는 호스트 이름은 정렬에 정확한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="29718e1a752532888d9b6274932fa784db1a79d6" translate="yes" xml:space="preserve">
          <source>Acer</source>
          <target state="translated">Acer</target>
        </trans-unit>
        <trans-unit id="f8d022bffcb6beaed07029a5a4d047e37b23c831" translate="yes" xml:space="preserve">
          <source>Acer ASPIRE @ne netbooks (1GB RAM)</source>
          <target state="translated">에이서 ASPIRE @ne 넷북 (1GB RAM)</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="e1cda006341a1c3a1ac8914530087a36cba146e8" translate="yes" xml:space="preserve">
          <source>Acl_column_grants</source>
          <target state="translated">Acl_column_grants</target>
        </trans-unit>
        <trans-unit id="95207b173b125935b66f73c43fbda0b40ca757c4" translate="yes" xml:space="preserve">
          <source>Acl_database_grants</source>
          <target state="translated">Acl_database_grants</target>
        </trans-unit>
        <trans-unit id="cc9c3df108dcb17b7519d7def83d82eb732278f0" translate="yes" xml:space="preserve">
          <source>Acl_function_grants</source>
          <target state="translated">Acl_function_grants</target>
        </trans-unit>
        <trans-unit id="c4488fe20900e7699e4a4fe01e77e0855e0fce06" translate="yes" xml:space="preserve">
          <source>Acl_package_body_grants</source>
          <target state="translated">Acl_package_body_grants</target>
        </trans-unit>
        <trans-unit id="145ca7269e1b6a6f132c6d5cded2879d5b733b77" translate="yes" xml:space="preserve">
          <source>Acl_package_spec_grants</source>
          <target state="translated">Acl_package_spec_grants</target>
        </trans-unit>
        <trans-unit id="a24704404214442ce5bfcad957e7ba44ec95a6db" translate="yes" xml:space="preserve">
          <source>Acl_procedure_grants</source>
          <target state="translated">Acl_procedure_grants</target>
        </trans-unit>
        <trans-unit id="c3d5464d9cc19e9cc5d798e1ea34b2257802a4d0" translate="yes" xml:space="preserve">
          <source>Acl_proxy_users</source>
          <target state="translated">Acl_proxy_users</target>
        </trans-unit>
        <trans-unit id="d2a641644d1264642aa471097224bf814dc9683e" translate="yes" xml:space="preserve">
          <source>Acl_role_grants</source>
          <target state="translated">Acl_role_grants</target>
        </trans-unit>
        <trans-unit id="4d787945682b7c88b312f26820cddc4fdaa0cc1f" translate="yes" xml:space="preserve">
          <source>Acl_roles</source>
          <target state="translated">Acl_roles</target>
        </trans-unit>
        <trans-unit id="59743d81790f52bb4700b7756f0dd82e60995c1d" translate="yes" xml:space="preserve">
          <source>Acl_table_grants</source>
          <target state="translated">Acl_table_grants</target>
        </trans-unit>
        <trans-unit id="ed0690fd7f3555a7db95710a468e982e3a05c01f" translate="yes" xml:space="preserve">
          <source>Acl_users</source>
          <target state="translated">Acl_users</target>
        </trans-unit>
        <trans-unit id="89680499d4eeba25cf6d15628bdc516ac6ad274c" translate="yes" xml:space="preserve">
          <source>Acoss (DG des URSSAF)</source>
          <target state="translated">아 코스 (DG des URSSAF)</target>
        </trans-unit>
        <trans-unit id="65c02124e5239675746e6cb46fa0eb2762ecfd23" translate="yes" xml:space="preserve">
          <source>Acquire explicit locks using the &lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt; statement; user also needs to have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a table in order to lock it.</source>
          <target state="translated">&lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt; 문을 사용하여 명시 적 잠금을 확보하십시오 . 또한 테이블을 잠 그려면 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="bfa64051ea1d48d5636b537369d8bfed490a0deb" translate="yes" xml:space="preserve">
          <source>Acquire explicit locks using the &lt;code&gt;&lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt;&lt;/code&gt; statement; you also need to have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a table, in order to lock it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt;&lt;/code&gt; 문을 사용하여 명시 적 잠금을 확보하십시오 . 또한 테이블을 잠 그려면 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="0607f85c7357b9f25de2d5c06859942039f4df63" translate="yes" xml:space="preserve">
          <source>Acquires a lock on the rows</source>
          <target state="translated">행 잠금을 획득합니다</target>
        </trans-unit>
        <trans-unit id="4fb2b0237fc847d5cf05d7178ae0b4716ea8aa37" translate="yes" xml:space="preserve">
          <source>Acquires a write lock</source>
          <target state="translated">쓰기 잠금 획득</target>
        </trans-unit>
        <trans-unit id="4d9a76410d86857132085c9f145f5afb1a683b0c" translate="yes" xml:space="preserve">
          <source>Action, event or state indicating what the thread is doing.</source>
          <target state="translated">스레드가 수행중인 작업을 나타내는 조치, 이벤트 또는 상태</target>
        </trans-unit>
        <trans-unit id="e2362e86023c76ea689e393b149e652c54cb9571" translate="yes" xml:space="preserve">
          <source>Actions Performed by DEB Packages</source>
          <target state="translated">DEB 패키지가 수행하는 작업</target>
        </trans-unit>
        <trans-unit id="2fdb3bfdbb29137f1eb1e592b1ffcf55bd761abb" translate="yes" xml:space="preserve">
          <source>Actions Performed by RPM Packages</source>
          <target state="translated">RPM 패키지가 수행하는 작업</target>
        </trans-unit>
        <trans-unit id="8925bef78e62ce1215c4cce12f85b6a5be00aac3" translate="yes" xml:space="preserve">
          <source>Activate the Spider probes to be monitored.</source>
          <target state="translated">모니터링 할 스파이더 프로브를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c78296f7df0a91852d23bdb53e2b05a35e4cd76e" translate="yes" xml:space="preserve">
          <source>Activating Auditing for MariaDB in 5 Minutes</source>
          <target state="translated">5 분 안에 MariaDB에 대한 감사 활성화</target>
        </trans-unit>
        <trans-unit id="93d0b756bcdde1091bd5d311fb559711266020d1" translate="yes" xml:space="preserve">
          <source>Activating the Binary Log</source>
          <target state="translated">이진 로그 활성화</target>
        </trans-unit>
        <trans-unit id="2554379f05913bd36c35454a950383748fac07bc" translate="yes" xml:space="preserve">
          <source>Activating the Binary Log.</source>
          <target state="translated">이진 로그 활성화</target>
        </trans-unit>
        <trans-unit id="460ea63c667767091ced1a64663f34c5a7ff2011" translate="yes" xml:space="preserve">
          <source>Activating the Performance Schema</source>
          <target state="translated">성능 스키마 활성화</target>
        </trans-unit>
        <trans-unit id="043afa2b8e68021105e36879d558a6b68726b564" translate="yes" xml:space="preserve">
          <source>Activation/Deactivation</source>
          <target state="translated">Activation/Deactivation</target>
        </trans-unit>
        <trans-unit id="a733b809d2f1233496ab516eed0f3ef75cf3791a" translate="yes" xml:space="preserve">
          <source>Active</source>
          <target state="translated">Active</target>
        </trans-unit>
        <trans-unit id="32593e7c32e0a7ff517d6df7f21be3c7152bbf1f" translate="yes" xml:space="preserve">
          <source>Active Directory Domain Services: Service Principal Names</source>
          <target state="translated">Active Directory 도메인 서비스 : 서비스 사용자 이름</target>
        </trans-unit>
        <trans-unit id="c279bbfa212e8df35793a9cfa71d9fc36f4dce97" translate="yes" xml:space="preserve">
          <source>Active connections.</source>
          <target state="translated">활성 연결.</target>
        </trans-unit>
        <trans-unit id="a967835abfb8cb6f07ef39cbd6dec20cb75f45c6" translate="yes" xml:space="preserve">
          <source>Active database (as set by &lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt;).</source>
          <target state="translated">활성 데이터베이스 ( &lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt; 에서 설정 한대로 ).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
